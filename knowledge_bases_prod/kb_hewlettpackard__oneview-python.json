[
  "def handle_exceptions(exception_type, exception_value, exception_traceback, logger=logger):\n    message = __get_message(exception_value, exception_type)\n\n    logger.error(\"Uncaught Exception: %s with message: %s\" % (exception_type.__name__, message))\n    traceback.print_exception(exception_type, exception_value, exception_traceback)",
  "def __get_message(exception_value, exception_type):\n    message = \"\"\n\n    if issubclass(exception_type, HPEOneViewException):\n        if exception_value.msg:\n            message = exception_value.msg\n        if exception_value.oneview_response:\n            message += \"\\n\" + str(exception_value.oneview_response)\n    elif len(exception_value.args) > 0:\n        message = exception_value.args[0]\n\n    return message",
  "class HPEOneViewException(Exception):\n    \"\"\"\n    OneView base Exception.\n\n    Attributes:\n       msg (str): Exception message.\n       oneview_response (dict): OneView rest response.\n   \"\"\"\n\n    def __init__(self, data, error=None):\n        self.msg = None\n        self.oneview_response = None\n\n        if isinstance(data, basestring):\n            self.msg = data\n        else:\n            self.oneview_response = data\n\n            if data and isinstance(data, dict):\n                self.msg = data.get('message')\n\n        if self.oneview_response:\n            Exception.__init__(self, self.msg, self.oneview_response)\n        else:\n            Exception.__init__(self, self.msg)",
  "class HPEOneViewInvalidResource(HPEOneViewException):\n    \"\"\"\n    OneView Invalid Resource Exception.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewTaskError(HPEOneViewException):\n    \"\"\"\n    OneView Task Error Exception.\n\n    Attributes:\n       msg (str): Exception message.\n       error_code (str): A code which uniquely identifies the specific error.\n    \"\"\"\n\n    def __init__(self, msg, error_code=None):\n        super(HPEOneViewTaskError, self).__init__(msg)\n        self.error_code = error_code",
  "class HPEOneViewUnknownType(HPEOneViewException):\n    \"\"\"\n    OneView Unknown Type Error.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewTimeout(HPEOneViewException):\n    \"\"\"\n    OneView Timeout Exception.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewValueError(HPEOneViewException):\n    \"\"\"\n    OneView Value Error.\n    The exception is raised when the data contains an inappropriate value.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewResourceNotFound(HPEOneViewException):\n    \"\"\"\n    OneView Resource Not Found Exception.\n    The exception is raised when an associated resource was not found.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewUnavailableMethod(HPEOneViewException):\n    \"\"\"\n    OneView Unavailable Method Exception.\n    The exception is raised when a method is not available for the resource class.\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "class HPEOneViewMissingUniqueIdentifiers(HPEOneViewException):\n    \"\"\"\n    OneView Missing Unique Identifiers Exception.\n    The exception is raised when unique identifiers are missing for the resource\n\n    Attributes:\n       msg (str): Exception message.\n    \"\"\"\n    pass",
  "def __init__(self, data, error=None):\n        self.msg = None\n        self.oneview_response = None\n\n        if isinstance(data, basestring):\n            self.msg = data\n        else:\n            self.oneview_response = data\n\n            if data and isinstance(data, dict):\n                self.msg = data.get('message')\n\n        if self.oneview_response:\n            Exception.__init__(self, self.msg, self.oneview_response)\n        else:\n            Exception.__init__(self, self.msg)",
  "def __init__(self, msg, error_code=None):\n        super(HPEOneViewTaskError, self).__init__(msg)\n        self.error_code = error_code",
  "def main():\n    parser = argparse.ArgumentParser(add_help=True, description='Usage')\n    parser.add_argument('-a', '--appliance', dest='host', required=True,\n                        help='HPE OneView Appliance hostname or IP')\n    parser.add_argument('-u', '--user', dest='user', required=True,\n                        help='HPE OneView Username')\n    parser.add_argument('-p', '--pass', dest='passwd', required=True,\n                        help='HPE OneView Password')\n    parser.add_argument('-c', '--certificate', dest='cert', required=False,\n                        help='Trusted SSL Certificate Bundle in PEM '\n                             '(Base64 Encoded DER) Format')\n    parser.add_argument('-r', '--proxy', dest='proxy', required=False,\n                        help='Proxy (host:port format')\n    args = parser.parse_args()\n    con = connection(args.host)\n    if args.proxy:\n        con.set_proxy(args.proxy)\n    if args.cert:   \n        con.set_trusted_ssl_bundle(args.cert)\n    credential = {'userName': args.user, 'password': args.passwd}\n    con.login(args.host, credential)\n    con.logout()",
  "class OneViewClient(object):\n\n    def __init__(self, config, sessionID=None):\n        self.__connection = connection(config.get('ip'), config.get('api_version'), config.get('ssl_certificate', False),\n                                       config.get('timeout'), config.get(\"proxy\"))\n        self.__validate_host()\n        self.__connection.login(config[\"credentials\"], sessionID=sessionID)\n        self.__certificate_authority = None\n        self.__connections = None\n        self.__connection_templates = None\n        self.__fc_networks = None\n        self.__repositories = None\n        self.__fcoe_networks = None\n        self.__ethernet_networks = None\n        self.__fabrics = None\n        self.__network_sets = None\n        self.__switches = None\n        self.__switch_types = None\n        self.__tasks = None\n        self.__scopes = None\n        self.__enclosures = None\n        self.__logical_enclosures = None\n        self.__enclosure_groups = None\n        self.__metric_streaming = None\n        self.__server_hardware = None\n        self.__server_hardware_types = None\n        self.__rack_managers = None\n        self.__id_pools_vsn_ranges = None\n        self.__id_pools_vmac_ranges = None\n        self.__id_pools_vwwn_ranges = None\n        self.__id_pools_ipv4_ranges = None\n        self.__id_pools_ipv4_subnets = None\n        self.__id_pools = None\n        self.__interconnects = None\n        self.__interconnect_types = None\n        self.__interconnect_link_topologies = None\n        self.__sas_interconnect_types = None\n        self.__internal_link_sets = None\n        self.__power_devices = None\n        self.__unmanaged_devices = None\n        self.__racks = None\n        self.__roles = None\n        self.__datacenters = None\n        self.__san_managers = None\n        self.__san_providers = None\n        self.__endpoints = None\n        self.__logical_interconnects = None\n        self.__sas_logical_interconnects = None\n        self.__logical_interconnect_groups = None\n        self.__logical_switch_groups = None\n        self.__logical_switches = None\n        self.__logical_downlinks = None\n        self.__restores = None\n        self.__server_profiles = None\n        self.__server_profile_templates = None\n        self.__sas_logical_jbods = None\n        self.__storage_systems = None\n        self.__storage_pools = None\n        self.__storage_volume_templates = None\n        self.__storage_volume_attachments = None\n        self.__firmware_drivers = None\n        self.__firmware_bundles = None\n        self.__uplink_sets = None\n        self.__volumes = None\n        self.__sas_logical_jbod_attachments = None\n        self.__managed_sans = None\n        self.__migratable_vc_domains = None\n        self.__sas_interconnects = None\n        self.__index_resources = None\n        self.__labels = None\n        self.__sas_logical_interconnect_groups = None\n        self.__alerts = None\n        self.__events = None\n        self.__drive_enclures = None\n        self.__certificate_rabbitmq = None\n        self.__users = None\n        self.__appliance_device_read_community = None\n        self.__appliance_device_snmp_v1_trap_destinations = None\n        self.__appliance_device_snmp_v3_trap_destinations = None\n        self.__appliance_device_snmp_v3_users = None\n        self.__appliance_time_and_locale_configuration = None\n        self.__appliance_node_information = None\n        self.__appliance_health_status = None\n        self.__appliance_proxy_configuration = None\n        self.__appliance_network_interfaces = None\n        self.__versions = None\n        self.__backups = None\n        self.__login_details = None\n        self.__licenses = None\n        self.__hypervisor_managers = None\n        self.__certificates_server = None\n        self.__appliance_configuration_timeconfig = None\n        self.__appliance_ssh_access = None\n        self.__ha_nodes = None\n\n    @classmethod\n    def from_json_file(cls, file_name, sessionID=None):\n        \"\"\"\n        Construct OneViewClient using a json file.\n\n        Args:\n            file_name: json full path.\n\n        Returns:\n            OneViewClient:\n        \"\"\"\n        with open(file_name) as json_data:\n            config = json.load(json_data)\n        if sessionID is not None:\n            return cls(config, sessionID=sessionID)\n        else:\n            return cls(config)\n\n    @classmethod\n    def from_environment_variables(cls, session_id=None):\n        \"\"\"\n        Construct OneViewClient using environment variables.\n\n        Allowed variables: ONEVIEWSDK_IP (required), ONEVIEWSDK_USERNAME (required), ONEVIEWSDK_PASSWORD (required),\n        ONEVIEWSDK_AUTH_LOGIN_DOMAIN, ONEVIEWSDK_API_VERSION, ONEVIEWSDK_SESSIONID, ONEVIEWSDK_SSL_CERTIFICATE,\n        ONEVIEWSDK_CONNECTION_TIMEOUT and ONEVIEWSDK_PROXY.\n\n        Returns:\n            OneViewClient:\n        \"\"\"\n        ip = os.environ.get('ONEVIEWSDK_IP', '')\n        api_version = os.environ.get('ONEVIEWSDK_API_VERSION', '')\n        ssl_certificate = os.environ.get('ONEVIEWSDK_SSL_CERTIFICATE', '')\n        username = os.environ.get('ONEVIEWSDK_USERNAME', '')\n        auth_login_domain = os.environ.get('ONEVIEWSDK_AUTH_LOGIN_DOMAIN', '')\n        password = os.environ.get('ONEVIEWSDK_PASSWORD', '')\n        proxy = os.environ.get('ONEVIEWSDK_PROXY', '')\n        sessionID = os.environ.get('ONEVIEWSDK_SESSIONID', '')\n        timeout = os.environ.get('ONEVIEWSDK_CONNECTION_TIMEOUT')\n\n        config = dict(ip=ip,\n                      api_version=api_version,\n                      ssl_certificate=ssl_certificate,\n                      credentials=dict(userName=username, authLoginDomain=auth_login_domain, password=password, sessionID=sessionID),\n                      proxy=proxy, timeout=timeout)\n\n        if session_id is not None:\n            return cls(config, sessionID=session_id)\n        else:\n            return cls(config)\n\n    def __validate_host(self):\n        \"\"\"\n        Fails if oneview ip is not provided\n        \"\"\"\n        if not self.__connection._host:\n            raise ValueError(ONEVIEW_CLIENT_MISSING_IP)\n\n    @property\n    def api_version(self):\n        \"\"\"\n        Gets the OneView API Version.\n\n        Returns:\n            int: API Version.\n        \"\"\"\n        return self.__connection._apiVersion\n\n    @property\n    def connection(self):\n        \"\"\"\n        Gets the underlying HPE OneView connection used by the OneViewClient.\n\n        Returns:\n            connection:\n        \"\"\"\n        return self.__connection\n\n    @property\n    def certificate_authority(self):\n        \"\"\"\n        Gets the Certificate Authority API client.\n\n        Returns:\n            CertificateAuthority:\n        \"\"\"\n        return CertificateAuthority(self.__connection)\n\n    @property\n    def connections(self):\n        \"\"\"\n        Gets the Connections API client.\n\n        Returns:\n            Connections:\n        \"\"\"\n        if not self.__connections:\n            self.__connections = Connections(\n                self.__connection)\n        return self.__connections\n\n    @property\n    def connection_templates(self):\n        \"\"\"\n        Gets the ConnectionTemplates API client.\n\n        Returns:\n            ConnectionTemplates:\n        \"\"\"\n        return ConnectionTemplates(self.__connection)\n\n    @property\n    def fc_networks(self):\n        \"\"\"\n        Gets the FcNetworks API client.\n\n        Returns:\n            FcNetworks:\n        \"\"\"\n        return FcNetworks(self.__connection)\n\n    @property\n    def fcoe_networks(self):\n        \"\"\"\n        Gets the FcoeNetworks API client.\n\n        Returns:\n            FcoeNetworks:\n        \"\"\"\n        return FcoeNetworks(self.__connection)\n\n    @property\n    def ethernet_networks(self):\n        \"\"\"\n        Gets the EthernetNetworks API client.\n\n        Returns:\n            EthernetNetworks:\n        \"\"\"\n        return EthernetNetworks(self.__connection)\n\n    @property\n    def fabrics(self):\n        \"\"\"\n        Gets the Fabrics API client.\n\n        Returns:\n            Fabrics:\n        \"\"\"\n        if not self.__fabrics:\n            self.__fabrics = Fabrics(self.__connection)\n        return self.__fabrics\n\n    @property\n    def restores(self):\n        \"\"\"\n        Gets the Restores API client.\n\n        Returns:\n            Restores:\n        \"\"\"\n        return Restores(self.__connection)\n\n    @property\n    def scopes(self):\n        \"\"\"\n        Gets the Scopes API client.\n\n        Returns:\n            Scopes:\n        \"\"\"\n        return Scopes(self.__connection)\n\n    @property\n    def datacenters(self):\n        \"\"\"\n        Gets the Datacenters API client.\n\n        Returns:\n            Datacenters:\n        \"\"\"\n        if not self.__datacenters:\n            self.__datacenters = Datacenters(self.__connection)\n        return self.__datacenters\n\n    @property\n    def network_sets(self):\n        \"\"\"\n        Gets the NetworkSets API client.\n\n        Returns:\n            NetworkSets:\n        \"\"\"\n        return NetworkSets(self.__connection)\n\n    @property\n    def server_hardware(self):\n        \"\"\"\n        Gets the ServerHardware API client.\n\n        Returns:\n            ServerHardware:\n        \"\"\"\n        return ServerHardware(self.__connection)\n\n    @property\n    def server_hardware_types(self):\n        \"\"\"\n        Gets the ServerHardwareTypes API client.\n\n        Returns:\n            ServerHardwareTypes:\n        \"\"\"\n        return ServerHardwareTypes(self.__connection)\n\n    @property\n    def rack_managers(self):\n        \"\"\"\n        Gets the Rack Manager API client.\n\n        Returns:\n            RackManager:\n        \"\"\"\n        return RackManager(self.__connection)\n\n    @property\n    def id_pools_vsn_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VSN Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vsn_ranges:\n            self.__id_pools_vsn_ranges = IdPoolsRanges('vsn', self.__connection)\n        return self.__id_pools_vsn_ranges\n\n    @property\n    def id_pools_vmac_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VMAC Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vmac_ranges:\n            self.__id_pools_vmac_ranges = IdPoolsRanges('vmac', self.__connection)\n        return self.__id_pools_vmac_ranges\n\n    @property\n    def id_pools_vwwn_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VWWN Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vwwn_ranges:\n            self.__id_pools_vwwn_ranges = IdPoolsRanges('vwwn', self.__connection)\n        return self.__id_pools_vwwn_ranges\n\n    @property\n    def id_pools_ipv4_ranges(self):\n        \"\"\"\n        Gets the IdPoolsIpv4Ranges API client.\n\n        Returns:\n            IdPoolsIpv4Ranges:\n        \"\"\"\n        return IdPoolsIpv4Ranges(self.__connection)\n\n    @property\n    def id_pools_ipv4_subnets(self):\n        \"\"\"\n        Gets the IdPoolsIpv4Subnets API client.\n\n        Returns:\n            IdPoolsIpv4Subnets:\n        \"\"\"\n        return IdPoolsIpv4Subnets(self.__connection)\n\n    @property\n    def id_pools(self):\n        \"\"\"\n        Gets the IdPools API client.\n\n        Returns:\n            IdPools:\n        \"\"\"\n        return IdPools(self.__connection)\n\n    @property\n    def switches(self):\n        \"\"\"\n        Gets the Switches API client.\n\n        Returns:\n            Switches:\n        \"\"\"\n        if not self.__switches:\n            self.__switches = Switches(self.__connection)\n        return self.__switches\n\n    @property\n    def roles(self):\n        \"\"\"\n        Gets the Roles API client.\n\n        Returns:\n            Roles:\n        \"\"\"\n        if not self.__roles:\n            self.__roles = Roles(self.__connection)\n        return self.__roles\n\n    @property\n    def switch_types(self):\n        \"\"\"\n        Gets the SwitchTypes API client.\n\n        Returns:\n            SwitchTypes:\n        \"\"\"\n        return SwitchTypes(self.__connection)\n\n    @property\n    def logical_switch_groups(self):\n        \"\"\"\n        Gets the LogicalSwitchGroups API client.\n\n        Returns:\n            LogicalSwitchGroups:\n        \"\"\"\n        return LogicalSwitchGroups(self.__connection)\n\n    @property\n    def logical_switches(self):\n        \"\"\"\n        Gets the LogicalSwitches API client.\n\n        Returns:\n            LogicalSwitches:\n        \"\"\"\n        if not self.__logical_switches:\n            self.__logical_switches = LogicalSwitches(self.__connection)\n        return self.__logical_switches\n\n    @property\n    def tasks(self):\n        \"\"\"\n        Gets the Tasks API client.\n\n        Returns:\n            Tasks:\n        \"\"\"\n        if not self.__tasks:\n            self.__tasks = Tasks(self.__connection)\n        return self.__tasks\n\n    @property\n    def enclosure_groups(self):\n        \"\"\"\n        Gets the EnclosureGroups API client.\n\n        Returns:\n            EnclosureGroups:\n        \"\"\"\n        return EnclosureGroups(self.__connection)\n\n    @property\n    def enclosures(self):\n        \"\"\"\n        Gets the Enclosures API client.\n\n        Returns:\n            Enclosures:\n        \"\"\"\n        return Enclosures(self.__connection)\n\n    @property\n    def logical_enclosures(self):\n        \"\"\"\n        Gets the LogicalEnclosures API client.\n\n        Returns:\n            LogicalEnclosures:\n        \"\"\"\n        return LogicalEnclosures(self.__connection)\n\n    @property\n    def metric_streaming(self):\n        \"\"\"\n        Gets the MetricStreaming API client.\n\n        Returns:\n            MetricStreaming:\n        \"\"\"\n        if not self.__metric_streaming:\n            self.__metric_streaming = MetricStreaming(self.__connection)\n        return self.__metric_streaming\n\n    @property\n    def interconnects(self):\n        \"\"\"\n        Gets the Interconnects API client.\n\n        Returns:\n            Interconnects:\n        \"\"\"\n        return Interconnects(self.__connection)\n\n    @property\n    def interconnect_types(self):\n        \"\"\"\n        Gets the InterconnectTypes API client.\n\n        Returns:\n            InterconnectTypes:\n        \"\"\"\n        return InterconnectTypes(self.__connection)\n\n    @property\n    def interconnect_link_topologies(self):\n        \"\"\"\n        Gets the InterconnectLinkTopologies API client.\n\n        Returns:\n            InterconnectLinkTopologies:\n        \"\"\"\n        if not self.__interconnect_link_topologies:\n            self.__interconnect_link_topologies = InterconnectLinkTopologies(self.__connection)\n        return self.__interconnect_link_topologies\n\n    @property\n    def sas_interconnect_types(self):\n        \"\"\"\n        Gets the SasInterconnectTypes API client.\n\n        Returns:\n            SasInterconnectTypes:\n        \"\"\"\n        return SasInterconnectTypes(self.__connection)\n\n    @property\n    def internal_link_sets(self):\n        \"\"\"\n        Gets the InternalLinkSets API client.\n\n        Returns:\n            InternalLinkSets:\n        \"\"\"\n        return InternalLinkSets(self.__connection)\n\n    @property\n    def logical_interconnect_groups(self):\n        \"\"\"\n        Gets the LogicalInterconnectGroups API client.\n\n        Returns:\n            LogicalInterconnectGroups:\n        \"\"\"\n        return LogicalInterconnectGroups(self.__connection)\n\n    @property\n    def logical_interconnects(self):\n        \"\"\"\n        Gets the LogicalInterconnects API client.\n\n        Returns:\n            LogicalInterconnects:\n        \"\"\"\n        return LogicalInterconnects(self.__connection)\n\n    @property\n    def sas_logical_interconnects(self):\n        \"\"\"\n        Gets the SasLogicalInterconnects API client.\n\n        Returns:\n            SasLogicalInterconnects:\n        \"\"\"\n        return SasLogicalInterconnects(self.__connection)\n\n    @property\n    def logical_downlinks(self):\n        \"\"\"\n        Gets the LogicalDownlinks API client.\n\n        Returns:\n            LogicalDownlinks:\n        \"\"\"\n        if not self.__logical_downlinks:\n            self.__logical_downlinks = LogicalDownlinks(\n                self.__connection)\n        return self.__logical_downlinks\n\n    @property\n    def power_devices(self):\n        \"\"\"\n        Gets the PowerDevices API client.\n\n        Returns:\n            PowerDevices:\n        \"\"\"\n        if not self.__power_devices:\n            self.__power_devices = PowerDevices(self.__connection)\n        return self.__power_devices\n\n    @property\n    def unmanaged_devices(self):\n        \"\"\"\n        Gets the Unmanaged Devices API client.\n\n        Returns:\n            UnmanagedDevices:\n        \"\"\"\n        if not self.__unmanaged_devices:\n            self.__unmanaged_devices = UnmanagedDevices(self.__connection)\n        return self.__unmanaged_devices\n\n    @property\n    def racks(self):\n        \"\"\"\n        Gets the Racks API client.\n\n        Returns:\n            Racks:\n        \"\"\"\n        if not self.__racks:\n            self.__racks = Racks(self.__connection)\n        return self.__racks\n\n    @property\n    def san_managers(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return SanManagers(self.__connection)\n\n    @property\n    def endpoints(self):\n        \"\"\"\n        Gets the Endpoints API client.\n\n        Returns:\n            Endpoints:\n        \"\"\"\n        if not self.__endpoints:\n            self.__endpoints = Endpoints(self.__connection)\n        return self.__endpoints\n\n    @property\n    def server_profiles(self):\n        \"\"\"\n        Gets the ServerProfiles API client.\n\n        Returns:\n            ServerProfiles:\n        \"\"\"\n        return ServerProfiles(self.__connection)\n\n    @property\n    def server_profile_templates(self):\n        \"\"\"\n        Gets the ServerProfileTemplate API client.\n\n        Returns:\n            ServerProfileTemplate:\n        \"\"\"\n        return ServerProfileTemplate(self.__connection)\n\n    @property\n    def storage_systems(self):\n        \"\"\"\n        Gets the StorageSystems API client.\n\n        Returns:\n            StorageSystems:\n        \"\"\"\n        return StorageSystems(self.__connection)\n\n    @property\n    def storage_pools(self):\n        \"\"\"\n        Gets the StoragePools API client.\n\n        Returns:\n            StoragePools:\n        \"\"\"\n        return StoragePools(self.__connection)\n\n    @property\n    def storage_volume_templates(self):\n        \"\"\"\n        Gets the StorageVolumeTemplates API client.\n\n        Returns:\n            StorageVolumeTemplates:\n        \"\"\"\n        return StorageVolumeTemplates(self.__connection)\n\n    @property\n    def storage_volume_attachments(self):\n        \"\"\"\n        Gets the StorageVolumeAttachments API client.\n\n        Returns:\n            StorageVolumeAttachments:\n        \"\"\"\n        return StorageVolumeAttachments(self.__connection)\n\n    @property\n    def firmware_drivers(self):\n        \"\"\"\n        Gets the FirmwareDrivers API client.\n\n        Returns:\n            FirmwareDrivers:\n        \"\"\"\n        return FirmwareDrivers(self.__connection)\n\n    @property\n    def firmware_bundles(self):\n        \"\"\"\n        Gets the FirmwareBundles API client.\n\n        Returns:\n            FirmwareBundles:\n        \"\"\"\n        return FirmwareBundles(self.__connection)\n\n    @property\n    def uplink_sets(self):\n        \"\"\"\n        Gets the UplinkSets API client.\n\n        Returns:\n            UplinkSets:\n        \"\"\"\n        return UplinkSets(self.__connection)\n\n    @property\n    def volumes(self):\n        \"\"\"\n        Gets the Volumes API client.\n\n        Returns:\n            Volumes:\n        \"\"\"\n        return Volumes(self.__connection)\n\n    @property\n    def sas_logical_jbod_attachments(self):\n        \"\"\"\n        Gets the SAS Logical JBOD Attachments client.\n\n        Returns:\n            SasLogicalJbodAttachments:\n        \"\"\"\n        if not self.__sas_logical_jbod_attachments:\n            self.__sas_logical_jbod_attachments = SasLogicalJbodAttachments(self.__connection)\n        return self.__sas_logical_jbod_attachments\n\n    @property\n    def managed_sans(self):\n        \"\"\"\n        Gets the Managed SANs API client.\n\n        Returns:\n            ManagedSANs:\n        \"\"\"\n        return ManagedSANs(self.__connection)\n\n    @property\n    def migratable_vc_domains(self):\n        \"\"\"\n        Gets the VC Migration Manager API client.\n\n        Returns:\n            MigratableVcDomains:\n        \"\"\"\n        if not self.__migratable_vc_domains:\n            self.__migratable_vc_domains = MigratableVcDomains(self.__connection)\n        return self.__migratable_vc_domains\n\n    @property\n    def sas_interconnects(self):\n        \"\"\"\n        Gets the SAS Interconnects API client.\n\n        Returns:\n            SasInterconnects:\n        \"\"\"\n        return SasInterconnects(self.__connection)\n\n    @property\n    def sas_logical_interconnect_groups(self):\n        \"\"\"\n        Gets the SasLogicalInterconnectGroups API client.\n\n        Returns:\n            SasLogicalInterconnectGroups:\n        \"\"\"\n        return SasLogicalInterconnectGroups(self.__connection)\n\n    @property\n    def drive_enclosures(self):\n        \"\"\"\n        Gets the Drive Enclosures API client.\n\n        Returns:\n            DriveEnclosures:\n        \"\"\"\n        if not self.__drive_enclures:\n            self.__drive_enclures = DriveEnclosures(self.__connection)\n        return self.__drive_enclures\n\n    @property\n    def sas_logical_jbods(self):\n        \"\"\"\n        Gets the SAS Logical JBODs API client.\n\n        Returns:\n            SasLogicalJbod:\n        \"\"\"\n        if not self.__sas_logical_jbods:\n            self.__sas_logical_jbods = SasLogicalJbods(self.__connection)\n        return self.__sas_logical_jbods\n\n    @property\n    def labels(self):\n        \"\"\"\n        Gets the Labels API client.\n\n        Returns:\n            Labels:\n        \"\"\"\n        return Labels(self.__connection)\n\n    @property\n    def index_resources(self):\n        \"\"\"\n        Gets the Index Resources API client.\n\n        Returns:\n            IndexResources:\n        \"\"\"\n        return IndexResources(self.__connection)\n\n    @property\n    def alerts(self):\n        \"\"\"\n        Gets the Alerts API client.\n\n        Returns:\n            Alerts:\n        \"\"\"\n        if not self.__alerts:\n            self.__alerts = Alerts(self.__connection)\n        return self.__alerts\n\n    @property\n    def events(self):\n        \"\"\"\n        Gets the Events API client.\n\n        Returns:\n            Events:\n        \"\"\"\n        if not self.__events:\n            self.__events = Events(self.__connection)\n        return self.__events\n\n    @property\n    def certificate_rabbitmq(self):\n        \"\"\"\n        Gets the Certificate RabbitMQ API client.\n\n        Returns:\n            CertificateRabbitMQ:\n        \"\"\"\n        if not self.__certificate_rabbitmq:\n            self.__certificate_rabbitmq = CertificateRabbitMQ(self.__connection)\n        return self.__certificate_rabbitmq\n\n    @property\n    def users(self):\n        \"\"\"\n        Gets the Users API client.\n\n        Returns:\n            Users:\n        \"\"\"\n        return Users(self.__connection)\n\n    @property\n    def appliance_device_read_community(self):\n        \"\"\"\n        Gets the ApplianceDeviceReadCommunity API client.\n\n        Returns:\n            ApplianceDeviceReadCommunity:\n        \"\"\"\n        if not self.__appliance_device_read_community:\n            self.__appliance_device_read_community = ApplianceDeviceReadCommunity(self.__connection)\n        return self.__appliance_device_read_community\n\n    @property\n    def appliance_device_snmp_v1_trap_destinations(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv1TrapDestinations API client.\n\n        Returns:\n            ApplianceDeviceSNMPv1TrapDestinations:\n        \"\"\"\n        return ApplianceDeviceSNMPv1TrapDestinations(self.__connection)\n\n    @property\n    def appliance_device_snmp_v3_trap_destinations(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv3TrapDestinations API client.\n\n        Returns:\n            ApplianceDeviceSNMPv3TrapDestinations:\n        \"\"\"\n        return ApplianceDeviceSNMPv3TrapDestinations(self.__connection)\n\n    @property\n    def appliance_device_snmp_v3_users(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv3Users API client.\n\n        Returns:\n            ApplianceDeviceSNMPv3Users:\n        \"\"\"\n        return ApplianceDeviceSNMPv3Users(self.__connection)\n\n    @property\n    def appliance_node_information(self):\n        \"\"\"\n        Gets the ApplianceNodeInformation API client.\n\n        Returns:\n            ApplianceNodeInformation:\n        \"\"\"\n        return ApplianceNodeInformation(self.__connection)\n\n    @property\n    def appliance_health_status(self):\n        \"\"\"\n        Gets the ApplianceHealthStatus API client.\n\n        Returns:\n            ApplianceHealthStatus:\n        \"\"\"\n        return ApplianceHealthStatus(self.__connection)\n\n    @property\n    def appliance_proxy_configuration(self):\n        \"\"\"\n        Gets the ApplianceProxyConfiguration API client.\n\n        Returns:\n            ApplianceProxyConfiguration:\n        \"\"\"\n        return ApplianceProxyConfiguration(self.__connection)\n\n    @property\n    def appliance_network_interfaces(self):\n        \"\"\"\n        Gets the ApplianceNetworkInterfaces API client.\n\n        Returns:\n            ApplianceNetworkInterfaces:\n        \"\"\"\n        return ApplianceNetworkInterfaces(self.__connection)\n\n    @property\n    def ha_nodes(self):\n        \"\"\"\n        Gets the HANodes API client.\n\n        Returns:\n            HANodes:\n        \"\"\"\n        return HANodes(self.__connection)\n\n    @property\n    def appliance_time_and_locale_configuration(self):\n        \"\"\"\n        Gets the ApplianceTimeAndLocaleConfiguration API client.\n\n        Returns:\n            ApplianceTimeAndLocaleConfiguration:\n        \"\"\"\n        return ApplianceTimeAndLocaleConfiguration(self.__connection)\n\n    @property\n    def versions(self):\n        \"\"\"\n        Gets the Version API client.\n\n        Returns:\n            Version:\n        \"\"\"\n        if not self.__versions:\n            self.__versions = Versions(self.__connection)\n        return self.__versions\n\n    @property\n    def backups(self):\n        \"\"\"\n        Gets the Backup API client.\n\n        Returns:\n            Backups:\n        \"\"\"\n        if not self.__backups:\n            self.__backups = Backups(self.__connection)\n        return self.__backups\n\n    @property\n    def login_details(self):\n        \"\"\"\n        Gets the login details\n\n        Returns:\n        List of login details\n        \"\"\"\n        if not self.__login_details:\n            self.__login_details = LoginDetails(self.__connection)\n        return self.__login_details\n\n    @property\n    def licenses(self):\n        \"\"\"\n        Gets all the licenses\n        Returns:\n        List of licenses\n        \"\"\"\n        if not self.__licenses:\n            self.__licenses = Licenses(self.__connection)\n        return self.__licenses\n\n    @property\n    def hypervisor_managers(self):\n        \"\"\"\n        Gets the Hypervisor Managers API client.\n\n        Returns:\n            HypervisorManagers\n        \"\"\"\n        return HypervisorManagers(self.__connection)\n\n    @property\n    def certificates_server(self):\n        \"\"\"\n        Gets the Certificates Server API client.\n\n        Returns:\n            Server Certificate:\n        \"\"\"\n        return CertificatesServer(self.__connection)\n\n    @property\n    def hypervisor_cluster_profiles(self):\n        \"\"\"\n        Gets the Hypervisor Cluster Profiles API client.\n\n        Returns:\n            Hypervisor Cluster Profiles:\n        \"\"\"\n        return HypervisorClusterProfiles(self.__connection)\n\n    @property\n    def appliance_configuration_timeconfig(self):\n        \"\"\"\n        Gets the ApplianceConfigurationTimeconfig API client.\n\n        Returns:\n            ApplianceConfigurationTimeconfig:\n        \"\"\"\n        return ApplianceConfigurationTimeconfig(self.__connection)\n\n    @property\n    def appliance_ssh_access(self):\n        \"\"\"\n        Gets the ApplianceSshAccess API client.\n\n        Returns:\n            ApplianceSshAccess:\n        \"\"\"\n        return ApplianceSshAccess(self.__connection)\n\n    @property\n    def repositories(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return Repositories(self.__connection)\n\n    @property\n    def san_providers(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return SanProviders(self.__connection)",
  "def __init__(self, config, sessionID=None):\n        self.__connection = connection(config.get('ip'), config.get('api_version'), config.get('ssl_certificate', False),\n                                       config.get('timeout'), config.get(\"proxy\"))\n        self.__validate_host()\n        self.__connection.login(config[\"credentials\"], sessionID=sessionID)\n        self.__certificate_authority = None\n        self.__connections = None\n        self.__connection_templates = None\n        self.__fc_networks = None\n        self.__repositories = None\n        self.__fcoe_networks = None\n        self.__ethernet_networks = None\n        self.__fabrics = None\n        self.__network_sets = None\n        self.__switches = None\n        self.__switch_types = None\n        self.__tasks = None\n        self.__scopes = None\n        self.__enclosures = None\n        self.__logical_enclosures = None\n        self.__enclosure_groups = None\n        self.__metric_streaming = None\n        self.__server_hardware = None\n        self.__server_hardware_types = None\n        self.__rack_managers = None\n        self.__id_pools_vsn_ranges = None\n        self.__id_pools_vmac_ranges = None\n        self.__id_pools_vwwn_ranges = None\n        self.__id_pools_ipv4_ranges = None\n        self.__id_pools_ipv4_subnets = None\n        self.__id_pools = None\n        self.__interconnects = None\n        self.__interconnect_types = None\n        self.__interconnect_link_topologies = None\n        self.__sas_interconnect_types = None\n        self.__internal_link_sets = None\n        self.__power_devices = None\n        self.__unmanaged_devices = None\n        self.__racks = None\n        self.__roles = None\n        self.__datacenters = None\n        self.__san_managers = None\n        self.__san_providers = None\n        self.__endpoints = None\n        self.__logical_interconnects = None\n        self.__sas_logical_interconnects = None\n        self.__logical_interconnect_groups = None\n        self.__logical_switch_groups = None\n        self.__logical_switches = None\n        self.__logical_downlinks = None\n        self.__restores = None\n        self.__server_profiles = None\n        self.__server_profile_templates = None\n        self.__sas_logical_jbods = None\n        self.__storage_systems = None\n        self.__storage_pools = None\n        self.__storage_volume_templates = None\n        self.__storage_volume_attachments = None\n        self.__firmware_drivers = None\n        self.__firmware_bundles = None\n        self.__uplink_sets = None\n        self.__volumes = None\n        self.__sas_logical_jbod_attachments = None\n        self.__managed_sans = None\n        self.__migratable_vc_domains = None\n        self.__sas_interconnects = None\n        self.__index_resources = None\n        self.__labels = None\n        self.__sas_logical_interconnect_groups = None\n        self.__alerts = None\n        self.__events = None\n        self.__drive_enclures = None\n        self.__certificate_rabbitmq = None\n        self.__users = None\n        self.__appliance_device_read_community = None\n        self.__appliance_device_snmp_v1_trap_destinations = None\n        self.__appliance_device_snmp_v3_trap_destinations = None\n        self.__appliance_device_snmp_v3_users = None\n        self.__appliance_time_and_locale_configuration = None\n        self.__appliance_node_information = None\n        self.__appliance_health_status = None\n        self.__appliance_proxy_configuration = None\n        self.__appliance_network_interfaces = None\n        self.__versions = None\n        self.__backups = None\n        self.__login_details = None\n        self.__licenses = None\n        self.__hypervisor_managers = None\n        self.__certificates_server = None\n        self.__appliance_configuration_timeconfig = None\n        self.__appliance_ssh_access = None\n        self.__ha_nodes = None",
  "def from_json_file(cls, file_name, sessionID=None):\n        \"\"\"\n        Construct OneViewClient using a json file.\n\n        Args:\n            file_name: json full path.\n\n        Returns:\n            OneViewClient:\n        \"\"\"\n        with open(file_name) as json_data:\n            config = json.load(json_data)\n        if sessionID is not None:\n            return cls(config, sessionID=sessionID)\n        else:\n            return cls(config)",
  "def from_environment_variables(cls, session_id=None):\n        \"\"\"\n        Construct OneViewClient using environment variables.\n\n        Allowed variables: ONEVIEWSDK_IP (required), ONEVIEWSDK_USERNAME (required), ONEVIEWSDK_PASSWORD (required),\n        ONEVIEWSDK_AUTH_LOGIN_DOMAIN, ONEVIEWSDK_API_VERSION, ONEVIEWSDK_SESSIONID, ONEVIEWSDK_SSL_CERTIFICATE,\n        ONEVIEWSDK_CONNECTION_TIMEOUT and ONEVIEWSDK_PROXY.\n\n        Returns:\n            OneViewClient:\n        \"\"\"\n        ip = os.environ.get('ONEVIEWSDK_IP', '')\n        api_version = os.environ.get('ONEVIEWSDK_API_VERSION', '')\n        ssl_certificate = os.environ.get('ONEVIEWSDK_SSL_CERTIFICATE', '')\n        username = os.environ.get('ONEVIEWSDK_USERNAME', '')\n        auth_login_domain = os.environ.get('ONEVIEWSDK_AUTH_LOGIN_DOMAIN', '')\n        password = os.environ.get('ONEVIEWSDK_PASSWORD', '')\n        proxy = os.environ.get('ONEVIEWSDK_PROXY', '')\n        sessionID = os.environ.get('ONEVIEWSDK_SESSIONID', '')\n        timeout = os.environ.get('ONEVIEWSDK_CONNECTION_TIMEOUT')\n\n        config = dict(ip=ip,\n                      api_version=api_version,\n                      ssl_certificate=ssl_certificate,\n                      credentials=dict(userName=username, authLoginDomain=auth_login_domain, password=password, sessionID=sessionID),\n                      proxy=proxy, timeout=timeout)\n\n        if session_id is not None:\n            return cls(config, sessionID=session_id)\n        else:\n            return cls(config)",
  "def __validate_host(self):\n        \"\"\"\n        Fails if oneview ip is not provided\n        \"\"\"\n        if not self.__connection._host:\n            raise ValueError(ONEVIEW_CLIENT_MISSING_IP)",
  "def api_version(self):\n        \"\"\"\n        Gets the OneView API Version.\n\n        Returns:\n            int: API Version.\n        \"\"\"\n        return self.__connection._apiVersion",
  "def connection(self):\n        \"\"\"\n        Gets the underlying HPE OneView connection used by the OneViewClient.\n\n        Returns:\n            connection:\n        \"\"\"\n        return self.__connection",
  "def certificate_authority(self):\n        \"\"\"\n        Gets the Certificate Authority API client.\n\n        Returns:\n            CertificateAuthority:\n        \"\"\"\n        return CertificateAuthority(self.__connection)",
  "def connections(self):\n        \"\"\"\n        Gets the Connections API client.\n\n        Returns:\n            Connections:\n        \"\"\"\n        if not self.__connections:\n            self.__connections = Connections(\n                self.__connection)\n        return self.__connections",
  "def connection_templates(self):\n        \"\"\"\n        Gets the ConnectionTemplates API client.\n\n        Returns:\n            ConnectionTemplates:\n        \"\"\"\n        return ConnectionTemplates(self.__connection)",
  "def fc_networks(self):\n        \"\"\"\n        Gets the FcNetworks API client.\n\n        Returns:\n            FcNetworks:\n        \"\"\"\n        return FcNetworks(self.__connection)",
  "def fcoe_networks(self):\n        \"\"\"\n        Gets the FcoeNetworks API client.\n\n        Returns:\n            FcoeNetworks:\n        \"\"\"\n        return FcoeNetworks(self.__connection)",
  "def ethernet_networks(self):\n        \"\"\"\n        Gets the EthernetNetworks API client.\n\n        Returns:\n            EthernetNetworks:\n        \"\"\"\n        return EthernetNetworks(self.__connection)",
  "def fabrics(self):\n        \"\"\"\n        Gets the Fabrics API client.\n\n        Returns:\n            Fabrics:\n        \"\"\"\n        if not self.__fabrics:\n            self.__fabrics = Fabrics(self.__connection)\n        return self.__fabrics",
  "def restores(self):\n        \"\"\"\n        Gets the Restores API client.\n\n        Returns:\n            Restores:\n        \"\"\"\n        return Restores(self.__connection)",
  "def scopes(self):\n        \"\"\"\n        Gets the Scopes API client.\n\n        Returns:\n            Scopes:\n        \"\"\"\n        return Scopes(self.__connection)",
  "def datacenters(self):\n        \"\"\"\n        Gets the Datacenters API client.\n\n        Returns:\n            Datacenters:\n        \"\"\"\n        if not self.__datacenters:\n            self.__datacenters = Datacenters(self.__connection)\n        return self.__datacenters",
  "def network_sets(self):\n        \"\"\"\n        Gets the NetworkSets API client.\n\n        Returns:\n            NetworkSets:\n        \"\"\"\n        return NetworkSets(self.__connection)",
  "def server_hardware(self):\n        \"\"\"\n        Gets the ServerHardware API client.\n\n        Returns:\n            ServerHardware:\n        \"\"\"\n        return ServerHardware(self.__connection)",
  "def server_hardware_types(self):\n        \"\"\"\n        Gets the ServerHardwareTypes API client.\n\n        Returns:\n            ServerHardwareTypes:\n        \"\"\"\n        return ServerHardwareTypes(self.__connection)",
  "def rack_managers(self):\n        \"\"\"\n        Gets the Rack Manager API client.\n\n        Returns:\n            RackManager:\n        \"\"\"\n        return RackManager(self.__connection)",
  "def id_pools_vsn_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VSN Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vsn_ranges:\n            self.__id_pools_vsn_ranges = IdPoolsRanges('vsn', self.__connection)\n        return self.__id_pools_vsn_ranges",
  "def id_pools_vmac_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VMAC Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vmac_ranges:\n            self.__id_pools_vmac_ranges = IdPoolsRanges('vmac', self.__connection)\n        return self.__id_pools_vmac_ranges",
  "def id_pools_vwwn_ranges(self):\n        \"\"\"\n        Gets the IdPoolsRanges API Client for VWWN Ranges.\n\n        Returns:\n            IdPoolsRanges:\n        \"\"\"\n        if not self.__id_pools_vwwn_ranges:\n            self.__id_pools_vwwn_ranges = IdPoolsRanges('vwwn', self.__connection)\n        return self.__id_pools_vwwn_ranges",
  "def id_pools_ipv4_ranges(self):\n        \"\"\"\n        Gets the IdPoolsIpv4Ranges API client.\n\n        Returns:\n            IdPoolsIpv4Ranges:\n        \"\"\"\n        return IdPoolsIpv4Ranges(self.__connection)",
  "def id_pools_ipv4_subnets(self):\n        \"\"\"\n        Gets the IdPoolsIpv4Subnets API client.\n\n        Returns:\n            IdPoolsIpv4Subnets:\n        \"\"\"\n        return IdPoolsIpv4Subnets(self.__connection)",
  "def id_pools(self):\n        \"\"\"\n        Gets the IdPools API client.\n\n        Returns:\n            IdPools:\n        \"\"\"\n        return IdPools(self.__connection)",
  "def switches(self):\n        \"\"\"\n        Gets the Switches API client.\n\n        Returns:\n            Switches:\n        \"\"\"\n        if not self.__switches:\n            self.__switches = Switches(self.__connection)\n        return self.__switches",
  "def roles(self):\n        \"\"\"\n        Gets the Roles API client.\n\n        Returns:\n            Roles:\n        \"\"\"\n        if not self.__roles:\n            self.__roles = Roles(self.__connection)\n        return self.__roles",
  "def switch_types(self):\n        \"\"\"\n        Gets the SwitchTypes API client.\n\n        Returns:\n            SwitchTypes:\n        \"\"\"\n        return SwitchTypes(self.__connection)",
  "def logical_switch_groups(self):\n        \"\"\"\n        Gets the LogicalSwitchGroups API client.\n\n        Returns:\n            LogicalSwitchGroups:\n        \"\"\"\n        return LogicalSwitchGroups(self.__connection)",
  "def logical_switches(self):\n        \"\"\"\n        Gets the LogicalSwitches API client.\n\n        Returns:\n            LogicalSwitches:\n        \"\"\"\n        if not self.__logical_switches:\n            self.__logical_switches = LogicalSwitches(self.__connection)\n        return self.__logical_switches",
  "def tasks(self):\n        \"\"\"\n        Gets the Tasks API client.\n\n        Returns:\n            Tasks:\n        \"\"\"\n        if not self.__tasks:\n            self.__tasks = Tasks(self.__connection)\n        return self.__tasks",
  "def enclosure_groups(self):\n        \"\"\"\n        Gets the EnclosureGroups API client.\n\n        Returns:\n            EnclosureGroups:\n        \"\"\"\n        return EnclosureGroups(self.__connection)",
  "def enclosures(self):\n        \"\"\"\n        Gets the Enclosures API client.\n\n        Returns:\n            Enclosures:\n        \"\"\"\n        return Enclosures(self.__connection)",
  "def logical_enclosures(self):\n        \"\"\"\n        Gets the LogicalEnclosures API client.\n\n        Returns:\n            LogicalEnclosures:\n        \"\"\"\n        return LogicalEnclosures(self.__connection)",
  "def metric_streaming(self):\n        \"\"\"\n        Gets the MetricStreaming API client.\n\n        Returns:\n            MetricStreaming:\n        \"\"\"\n        if not self.__metric_streaming:\n            self.__metric_streaming = MetricStreaming(self.__connection)\n        return self.__metric_streaming",
  "def interconnects(self):\n        \"\"\"\n        Gets the Interconnects API client.\n\n        Returns:\n            Interconnects:\n        \"\"\"\n        return Interconnects(self.__connection)",
  "def interconnect_types(self):\n        \"\"\"\n        Gets the InterconnectTypes API client.\n\n        Returns:\n            InterconnectTypes:\n        \"\"\"\n        return InterconnectTypes(self.__connection)",
  "def interconnect_link_topologies(self):\n        \"\"\"\n        Gets the InterconnectLinkTopologies API client.\n\n        Returns:\n            InterconnectLinkTopologies:\n        \"\"\"\n        if not self.__interconnect_link_topologies:\n            self.__interconnect_link_topologies = InterconnectLinkTopologies(self.__connection)\n        return self.__interconnect_link_topologies",
  "def sas_interconnect_types(self):\n        \"\"\"\n        Gets the SasInterconnectTypes API client.\n\n        Returns:\n            SasInterconnectTypes:\n        \"\"\"\n        return SasInterconnectTypes(self.__connection)",
  "def internal_link_sets(self):\n        \"\"\"\n        Gets the InternalLinkSets API client.\n\n        Returns:\n            InternalLinkSets:\n        \"\"\"\n        return InternalLinkSets(self.__connection)",
  "def logical_interconnect_groups(self):\n        \"\"\"\n        Gets the LogicalInterconnectGroups API client.\n\n        Returns:\n            LogicalInterconnectGroups:\n        \"\"\"\n        return LogicalInterconnectGroups(self.__connection)",
  "def logical_interconnects(self):\n        \"\"\"\n        Gets the LogicalInterconnects API client.\n\n        Returns:\n            LogicalInterconnects:\n        \"\"\"\n        return LogicalInterconnects(self.__connection)",
  "def sas_logical_interconnects(self):\n        \"\"\"\n        Gets the SasLogicalInterconnects API client.\n\n        Returns:\n            SasLogicalInterconnects:\n        \"\"\"\n        return SasLogicalInterconnects(self.__connection)",
  "def logical_downlinks(self):\n        \"\"\"\n        Gets the LogicalDownlinks API client.\n\n        Returns:\n            LogicalDownlinks:\n        \"\"\"\n        if not self.__logical_downlinks:\n            self.__logical_downlinks = LogicalDownlinks(\n                self.__connection)\n        return self.__logical_downlinks",
  "def power_devices(self):\n        \"\"\"\n        Gets the PowerDevices API client.\n\n        Returns:\n            PowerDevices:\n        \"\"\"\n        if not self.__power_devices:\n            self.__power_devices = PowerDevices(self.__connection)\n        return self.__power_devices",
  "def unmanaged_devices(self):\n        \"\"\"\n        Gets the Unmanaged Devices API client.\n\n        Returns:\n            UnmanagedDevices:\n        \"\"\"\n        if not self.__unmanaged_devices:\n            self.__unmanaged_devices = UnmanagedDevices(self.__connection)\n        return self.__unmanaged_devices",
  "def racks(self):\n        \"\"\"\n        Gets the Racks API client.\n\n        Returns:\n            Racks:\n        \"\"\"\n        if not self.__racks:\n            self.__racks = Racks(self.__connection)\n        return self.__racks",
  "def san_managers(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return SanManagers(self.__connection)",
  "def endpoints(self):\n        \"\"\"\n        Gets the Endpoints API client.\n\n        Returns:\n            Endpoints:\n        \"\"\"\n        if not self.__endpoints:\n            self.__endpoints = Endpoints(self.__connection)\n        return self.__endpoints",
  "def server_profiles(self):\n        \"\"\"\n        Gets the ServerProfiles API client.\n\n        Returns:\n            ServerProfiles:\n        \"\"\"\n        return ServerProfiles(self.__connection)",
  "def server_profile_templates(self):\n        \"\"\"\n        Gets the ServerProfileTemplate API client.\n\n        Returns:\n            ServerProfileTemplate:\n        \"\"\"\n        return ServerProfileTemplate(self.__connection)",
  "def storage_systems(self):\n        \"\"\"\n        Gets the StorageSystems API client.\n\n        Returns:\n            StorageSystems:\n        \"\"\"\n        return StorageSystems(self.__connection)",
  "def storage_pools(self):\n        \"\"\"\n        Gets the StoragePools API client.\n\n        Returns:\n            StoragePools:\n        \"\"\"\n        return StoragePools(self.__connection)",
  "def storage_volume_templates(self):\n        \"\"\"\n        Gets the StorageVolumeTemplates API client.\n\n        Returns:\n            StorageVolumeTemplates:\n        \"\"\"\n        return StorageVolumeTemplates(self.__connection)",
  "def storage_volume_attachments(self):\n        \"\"\"\n        Gets the StorageVolumeAttachments API client.\n\n        Returns:\n            StorageVolumeAttachments:\n        \"\"\"\n        return StorageVolumeAttachments(self.__connection)",
  "def firmware_drivers(self):\n        \"\"\"\n        Gets the FirmwareDrivers API client.\n\n        Returns:\n            FirmwareDrivers:\n        \"\"\"\n        return FirmwareDrivers(self.__connection)",
  "def firmware_bundles(self):\n        \"\"\"\n        Gets the FirmwareBundles API client.\n\n        Returns:\n            FirmwareBundles:\n        \"\"\"\n        return FirmwareBundles(self.__connection)",
  "def uplink_sets(self):\n        \"\"\"\n        Gets the UplinkSets API client.\n\n        Returns:\n            UplinkSets:\n        \"\"\"\n        return UplinkSets(self.__connection)",
  "def volumes(self):\n        \"\"\"\n        Gets the Volumes API client.\n\n        Returns:\n            Volumes:\n        \"\"\"\n        return Volumes(self.__connection)",
  "def sas_logical_jbod_attachments(self):\n        \"\"\"\n        Gets the SAS Logical JBOD Attachments client.\n\n        Returns:\n            SasLogicalJbodAttachments:\n        \"\"\"\n        if not self.__sas_logical_jbod_attachments:\n            self.__sas_logical_jbod_attachments = SasLogicalJbodAttachments(self.__connection)\n        return self.__sas_logical_jbod_attachments",
  "def managed_sans(self):\n        \"\"\"\n        Gets the Managed SANs API client.\n\n        Returns:\n            ManagedSANs:\n        \"\"\"\n        return ManagedSANs(self.__connection)",
  "def migratable_vc_domains(self):\n        \"\"\"\n        Gets the VC Migration Manager API client.\n\n        Returns:\n            MigratableVcDomains:\n        \"\"\"\n        if not self.__migratable_vc_domains:\n            self.__migratable_vc_domains = MigratableVcDomains(self.__connection)\n        return self.__migratable_vc_domains",
  "def sas_interconnects(self):\n        \"\"\"\n        Gets the SAS Interconnects API client.\n\n        Returns:\n            SasInterconnects:\n        \"\"\"\n        return SasInterconnects(self.__connection)",
  "def sas_logical_interconnect_groups(self):\n        \"\"\"\n        Gets the SasLogicalInterconnectGroups API client.\n\n        Returns:\n            SasLogicalInterconnectGroups:\n        \"\"\"\n        return SasLogicalInterconnectGroups(self.__connection)",
  "def drive_enclosures(self):\n        \"\"\"\n        Gets the Drive Enclosures API client.\n\n        Returns:\n            DriveEnclosures:\n        \"\"\"\n        if not self.__drive_enclures:\n            self.__drive_enclures = DriveEnclosures(self.__connection)\n        return self.__drive_enclures",
  "def sas_logical_jbods(self):\n        \"\"\"\n        Gets the SAS Logical JBODs API client.\n\n        Returns:\n            SasLogicalJbod:\n        \"\"\"\n        if not self.__sas_logical_jbods:\n            self.__sas_logical_jbods = SasLogicalJbods(self.__connection)\n        return self.__sas_logical_jbods",
  "def labels(self):\n        \"\"\"\n        Gets the Labels API client.\n\n        Returns:\n            Labels:\n        \"\"\"\n        return Labels(self.__connection)",
  "def index_resources(self):\n        \"\"\"\n        Gets the Index Resources API client.\n\n        Returns:\n            IndexResources:\n        \"\"\"\n        return IndexResources(self.__connection)",
  "def alerts(self):\n        \"\"\"\n        Gets the Alerts API client.\n\n        Returns:\n            Alerts:\n        \"\"\"\n        if not self.__alerts:\n            self.__alerts = Alerts(self.__connection)\n        return self.__alerts",
  "def events(self):\n        \"\"\"\n        Gets the Events API client.\n\n        Returns:\n            Events:\n        \"\"\"\n        if not self.__events:\n            self.__events = Events(self.__connection)\n        return self.__events",
  "def certificate_rabbitmq(self):\n        \"\"\"\n        Gets the Certificate RabbitMQ API client.\n\n        Returns:\n            CertificateRabbitMQ:\n        \"\"\"\n        if not self.__certificate_rabbitmq:\n            self.__certificate_rabbitmq = CertificateRabbitMQ(self.__connection)\n        return self.__certificate_rabbitmq",
  "def users(self):\n        \"\"\"\n        Gets the Users API client.\n\n        Returns:\n            Users:\n        \"\"\"\n        return Users(self.__connection)",
  "def appliance_device_read_community(self):\n        \"\"\"\n        Gets the ApplianceDeviceReadCommunity API client.\n\n        Returns:\n            ApplianceDeviceReadCommunity:\n        \"\"\"\n        if not self.__appliance_device_read_community:\n            self.__appliance_device_read_community = ApplianceDeviceReadCommunity(self.__connection)\n        return self.__appliance_device_read_community",
  "def appliance_device_snmp_v1_trap_destinations(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv1TrapDestinations API client.\n\n        Returns:\n            ApplianceDeviceSNMPv1TrapDestinations:\n        \"\"\"\n        return ApplianceDeviceSNMPv1TrapDestinations(self.__connection)",
  "def appliance_device_snmp_v3_trap_destinations(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv3TrapDestinations API client.\n\n        Returns:\n            ApplianceDeviceSNMPv3TrapDestinations:\n        \"\"\"\n        return ApplianceDeviceSNMPv3TrapDestinations(self.__connection)",
  "def appliance_device_snmp_v3_users(self):\n        \"\"\"\n        Gets the ApplianceDeviceSNMPv3Users API client.\n\n        Returns:\n            ApplianceDeviceSNMPv3Users:\n        \"\"\"\n        return ApplianceDeviceSNMPv3Users(self.__connection)",
  "def appliance_node_information(self):\n        \"\"\"\n        Gets the ApplianceNodeInformation API client.\n\n        Returns:\n            ApplianceNodeInformation:\n        \"\"\"\n        return ApplianceNodeInformation(self.__connection)",
  "def appliance_health_status(self):\n        \"\"\"\n        Gets the ApplianceHealthStatus API client.\n\n        Returns:\n            ApplianceHealthStatus:\n        \"\"\"\n        return ApplianceHealthStatus(self.__connection)",
  "def appliance_proxy_configuration(self):\n        \"\"\"\n        Gets the ApplianceProxyConfiguration API client.\n\n        Returns:\n            ApplianceProxyConfiguration:\n        \"\"\"\n        return ApplianceProxyConfiguration(self.__connection)",
  "def appliance_network_interfaces(self):\n        \"\"\"\n        Gets the ApplianceNetworkInterfaces API client.\n\n        Returns:\n            ApplianceNetworkInterfaces:\n        \"\"\"\n        return ApplianceNetworkInterfaces(self.__connection)",
  "def ha_nodes(self):\n        \"\"\"\n        Gets the HANodes API client.\n\n        Returns:\n            HANodes:\n        \"\"\"\n        return HANodes(self.__connection)",
  "def appliance_time_and_locale_configuration(self):\n        \"\"\"\n        Gets the ApplianceTimeAndLocaleConfiguration API client.\n\n        Returns:\n            ApplianceTimeAndLocaleConfiguration:\n        \"\"\"\n        return ApplianceTimeAndLocaleConfiguration(self.__connection)",
  "def versions(self):\n        \"\"\"\n        Gets the Version API client.\n\n        Returns:\n            Version:\n        \"\"\"\n        if not self.__versions:\n            self.__versions = Versions(self.__connection)\n        return self.__versions",
  "def backups(self):\n        \"\"\"\n        Gets the Backup API client.\n\n        Returns:\n            Backups:\n        \"\"\"\n        if not self.__backups:\n            self.__backups = Backups(self.__connection)\n        return self.__backups",
  "def login_details(self):\n        \"\"\"\n        Gets the login details\n\n        Returns:\n        List of login details\n        \"\"\"\n        if not self.__login_details:\n            self.__login_details = LoginDetails(self.__connection)\n        return self.__login_details",
  "def licenses(self):\n        \"\"\"\n        Gets all the licenses\n        Returns:\n        List of licenses\n        \"\"\"\n        if not self.__licenses:\n            self.__licenses = Licenses(self.__connection)\n        return self.__licenses",
  "def hypervisor_managers(self):\n        \"\"\"\n        Gets the Hypervisor Managers API client.\n\n        Returns:\n            HypervisorManagers\n        \"\"\"\n        return HypervisorManagers(self.__connection)",
  "def certificates_server(self):\n        \"\"\"\n        Gets the Certificates Server API client.\n\n        Returns:\n            Server Certificate:\n        \"\"\"\n        return CertificatesServer(self.__connection)",
  "def hypervisor_cluster_profiles(self):\n        \"\"\"\n        Gets the Hypervisor Cluster Profiles API client.\n\n        Returns:\n            Hypervisor Cluster Profiles:\n        \"\"\"\n        return HypervisorClusterProfiles(self.__connection)",
  "def appliance_configuration_timeconfig(self):\n        \"\"\"\n        Gets the ApplianceConfigurationTimeconfig API client.\n\n        Returns:\n            ApplianceConfigurationTimeconfig:\n        \"\"\"\n        return ApplianceConfigurationTimeconfig(self.__connection)",
  "def appliance_ssh_access(self):\n        \"\"\"\n        Gets the ApplianceSshAccess API client.\n\n        Returns:\n            ApplianceSshAccess:\n        \"\"\"\n        return ApplianceSshAccess(self.__connection)",
  "def repositories(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return Repositories(self.__connection)",
  "def san_providers(self):\n        \"\"\"\n        Gets the Repositories API client.\n\n        Returns:\n            Repositories:\n        \"\"\"\n        return SanProviders(self.__connection)",
  "class connection(object):\n    def __init__(self, applianceIp, api_version=None, sslBundle=False, timeout=None, proxy=None):\n        self._session = None\n        self._host = applianceIp\n        self._cred = None\n        self._proxyHost = None\n        self._proxyPort = None\n        self._doProxy = False\n        self.set_proxy(proxy)\n        self._sslTrustAll = True\n        self._sslBundle = sslBundle\n        self._sslTrustedBundle = self.set_trusted_ssl_bundle(sslBundle)\n        self._nextPage = None\n        self._prevPage = None\n        self._numTotalRecords = 0\n        self._numDisplayedRecords = 0\n        self._validateVersion = False\n        self._timeout = timeout\n        if not api_version:\n            api_version = self.get_default_api_version()\n        self._apiVersion = int(api_version)\n        self._headers = {\n            'X-API-Version': self._apiVersion,\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'}\n\n    def get_default_api_version(self):\n        self._headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'}\n        version = self.get(uri['version'])\n        return version['currentVersion']\n\n    def validateVersion(self):\n        version = self.get(uri['version'])\n        if 'minimumVersion' in version:\n            if self._apiVersion < version['minimumVersion']:\n                raise HPEOneViewException('Unsupported API Version')\n        if 'currentVersion' in version:\n            if self._apiVersion > version['currentVersion']:\n                raise HPEOneViewException('Unsupported API Version')\n        self._validateVersion = True\n\n    def set_proxy(self, proxy):\n        if proxy and len(proxy) > 0:\n            splitted = proxy.split(':')\n            if len(splitted) != 2:\n                raise ValueError(ONEVIEW_CLIENT_INVALID_PROXY)\n            self._proxyHost = splitted[0]\n            self._proxyPort = int(splitted[1])\n            self._doProxy = True\n\n    def set_trusted_ssl_bundle(self, sslBundle):\n        if sslBundle:\n            self._sslTrustAll = False\n        return sslBundle\n\n    def get_session(self):\n        return self._session\n\n    def get_session_id(self):\n        return self._headers.get('auth')\n\n    def set_session_id(self, session_id):\n        self._headers['auth'] = session_id\n        self._session = True\n\n    def get_host(self):\n        return self._host\n\n    def get_by_uri(self, xuri):\n        return self.get(xuri)\n\n    def make_url(self, path):\n        return 'https://%s%s' % (self._host, path)\n\n    def do_http(self, method, path, body, custom_headers=None):\n        http_headers = self._headers.copy()\n        if custom_headers:\n            http_headers.update(custom_headers)\n\n        bConnected = False\n        conn = None\n        while bConnected is False:\n            try:\n                conn = self.get_connection()\n                conn.request(method, path, body, http_headers)\n                resp = conn.getresponse()\n                tempbytes = ''\n                try:\n                    tempbytes = resp.read()\n                    tempbody = tempbytes.decode('utf-8')\n                except UnicodeDecodeError:  # Might be binary data\n                    tempbody = tempbytes\n                    conn.close()\n                    bConnected = True\n                    return resp, tempbody\n                if tempbody:\n                    try:\n                        body = json.loads(tempbody)\n                    except ValueError:\n                        body = tempbody\n                conn.close()\n                bConnected = True\n            except http.client.BadStatusLine:\n                logger.warning('Bad Status Line. Trying again...')\n                if conn:\n                    conn.close()\n                time.sleep(1)\n                continue\n            except http.client.HTTPException:\n                raise HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc())\n\n        return resp, body\n\n    def download_to_stream(self, stream_writer, url, body='', method='GET', custom_headers=None):\n        http_headers = self._headers.copy()\n        if custom_headers:\n            http_headers.update(custom_headers)\n\n        chunk_size = 4096\n        conn = None\n\n        successful_connected = False\n        while not successful_connected:\n            try:\n                conn = self.get_connection()\n                conn.request(method, url, body, http_headers)\n                resp = conn.getresponse()\n\n                if resp.status >= 400:\n                    self.__handle_download_error(resp, conn)\n\n                if resp.status == 302:\n                    return self.download_to_stream(stream_writer=stream_writer,\n                                                   url=resp.getheader('Location'),\n                                                   body=body,\n                                                   method=method,\n                                                   custom_headers=http_headers)\n\n                tempbytes = True\n                while tempbytes:\n                    tempbytes = resp.read(chunk_size)\n                    if tempbytes:  # filter out keep-alive new chunks\n                        stream_writer.write(tempbytes)\n\n                conn.close()\n                successful_connected = True\n            except http.client.BadStatusLine:\n                logger.warning('Bad Status Line. Trying again...')\n                if conn:\n                    conn.close()\n                time.sleep(1)\n                continue\n            except http.client.HTTPException:\n                raise HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc())\n\n        return successful_connected\n\n    def __handle_download_error(self, resp, conn):\n        try:\n            tempbytes = resp.read()\n            tempbody = tempbytes.decode('utf-8')\n            try:\n                body = json.loads(tempbody)\n            except ValueError:\n                body = tempbody\n        except UnicodeDecodeError:  # Might be binary data\n            body = tempbytes\n            conn.close()\n        if not body:\n            body = \"Error \" + str(resp.status)\n\n        conn.close()\n        raise HPEOneViewException(body)\n\n    def get_connection(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n        if self._sslTrustAll is False:\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(self._sslTrustedBundle)\n            if self._doProxy is False:\n                conn = http.client.HTTPSConnection(self._host,\n                                                   context=context,\n                                                   timeout=self._timeout)\n            else:\n                conn = http.client.HTTPSConnection(self._proxyHost,\n                                                   self._proxyPort,\n                                                   context=context,\n                                                   timeout=self._timeout)\n                conn.set_tunnel(self._host, 443)\n        else:\n            context.verify_mode = ssl.CERT_NONE\n            if self._doProxy is False:\n                conn = http.client.HTTPSConnection(self._host,\n                                                   context=context,\n                                                   timeout=self._timeout)\n            else:\n                conn = http.client.HTTPSConnection(self._proxyHost,\n                                                   self._proxyPort,\n                                                   context=context,\n                                                   timeout=self._timeout)\n                conn.set_tunnel(self._host, 443)\n\n        return conn\n\n    def _open(self, name, mode):\n        return open(name, mode)\n\n    def encode_multipart_formdata(self, fields, files, baseName, verbose=False):\n        \"\"\"\n        Fields is a sequence of (name, value) elements for regular form fields.\n        Files is a sequence of (name, filename, value) elements for data\n        to be uploaded as files\n\n        Returns: (content_type, body) ready for httplib.HTTP instance\n        \"\"\"\n        BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'\n        CRLF = '\\r\\n'\n        content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n        if verbose is True:\n            print(('Encoding ' + baseName + ' for upload...'))\n        fin = self._open(files, 'rb')\n        fout = self._open(files + '.b64', 'wb')\n        fout.write(bytearray('--' + BOUNDARY + CRLF, 'utf-8'))\n        fout.write(bytearray('Content-Disposition: form-data'\n                             '; name=\"file\"; filename=\"' + baseName + '\"' + CRLF, \"utf-8\"))\n        fout.write(bytearray('Content-Type: application/octet-stream' + CRLF,\n                             'utf-8'))\n        fout.write(bytearray(CRLF, 'utf-8'))\n        shutil.copyfileobj(fin, fout)\n        fout.write(bytearray(CRLF, 'utf-8'))\n        fout.write(bytearray('--' + BOUNDARY + '--' + CRLF, 'utf-8'))\n        fout.write(bytearray(CRLF, 'utf-8'))\n        fout.close()\n        fin.close()\n        return content_type\n\n    def post_multipart_with_response_handling(self, uri, file_path, baseName):\n        resp, body = self.post_multipart(uri, None, file_path, baseName)\n\n        if resp.status == 202:\n            task = self.__get_task_from_response(resp, body)\n            return task, body\n\n        if self.__body_content_is_task(body):\n            return body, body\n\n        return None, body\n\n    def post_multipart(self, uri, fields, files, baseName, verbose=False):\n        content_type = self.encode_multipart_formdata(fields, files, baseName,\n                                                      verbose)\n        inputfile = self._open(files + '.b64', 'rb')\n        mappedfile = mmap.mmap(inputfile.fileno(), 0, access=mmap.ACCESS_READ)\n        if verbose is True:\n            print(('Uploading ' + files + '...'))\n        conn = self.get_connection()\n        # conn.set_debuglevel(1)\n        conn.connect()\n        conn.putrequest('POST', uri)\n        conn.putheader('uploadfilename', baseName)\n        conn.putheader('auth', self._headers['auth'])\n        conn.putheader('Content-Type', content_type)\n        totalSize = os.path.getsize(files + '.b64')\n        conn.putheader('Content-Length', totalSize)\n        conn.putheader('X-API-Version', self._apiVersion)\n        conn.endheaders()\n\n        while mappedfile.tell() < mappedfile.size():\n            # Send 1MB at a time\n            # NOTE: Be careful raising this value as the read chunk\n            # is stored in RAM\n            readSize = 1048576\n            conn.send(mappedfile.read(readSize))\n            if verbose is True:\n                print('%d bytes sent... \\r' % mappedfile.tell())\n        mappedfile.close()\n        inputfile.close()\n        os.remove(files + '.b64')\n        response = conn.getresponse()\n        body = response.read().decode('utf-8')\n\n        if body:\n            try:\n                body = json.loads(body)\n            except ValueError:\n                body = response.read().decode('utf-8')\n\n        conn.close()\n\n        if response.status >= 400:\n            raise HPEOneViewException(body)\n\n        return response, body\n\n    ###########################################################################\n    # Utility functions for making requests - the HTTP verbs\n    ###########################################################################\n    def get(self, uri, custom_headers=None):\n        resp, body = self.do_http('GET', uri, '', custom_headers=custom_headers)\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n        if resp.status == 302:\n            body = self.get(resp.getheader('Location'))\n        if type(body) is dict:\n            if 'nextPageUri' in body:\n                self._nextPage = body['nextPageUri']\n            if 'prevPageUri' in body:\n                self._prevPage = body['prevPageUri']\n            if 'total' in body:\n                self._numTotalRecords = body['total']\n            if 'count' in body:\n                self._numDisplayedRecords = body['count']\n        return body\n\n    def getNextPage(self):\n        body = self.get(self._nextPage)\n        return get_members(body)\n\n    def getPrevPage(self):\n        body = self.get(self._prevPage)\n        return get_members(body)\n\n    def getLastPage(self):\n        while self._nextPage is not None:\n            members = self.getNextPage()\n        return members\n\n    def getFirstPage(self):\n        while self._prevPage is not None:\n            members = self.getPrevPage()\n        return members\n\n    def delete(self, uri, custom_headers=None):\n        return self.__do_rest_call('DELETE', uri, {}, custom_headers=custom_headers)\n\n    def put(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('PUT', uri, body, custom_headers=custom_headers)\n\n    def post(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('POST', uri, body, custom_headers=custom_headers)\n\n    def patch(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('PATCH', uri, body, custom_headers=custom_headers)\n\n    def __body_content_is_task(self, body):\n        return isinstance(body, dict) and 'category' in body and body['category'] == 'tasks'\n\n    def __get_task_from_response(self, response, body):\n        location = response.getheader('Location')\n        if location:\n            task = self.get(location)\n        elif 'taskState' in body:\n            # This check is needed to handle a status response 202 without the location header,\n            # as is for PowerDevices. We are not sure if there are more resources with the same behavior.\n            task = body\n        else:\n            # For the resource Label the status is 202 but the response not contains a task.\n            task = None\n        return task\n\n    def __do_rest_call(self, http_method, uri, body, custom_headers):\n        resp, body = self.do_http(method=http_method,\n                                  path=uri,\n                                  body=json.dumps(body),\n                                  custom_headers=custom_headers)\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n\n        if resp.status == 304:\n            if body and not isinstance(body, dict):\n                try:\n                    body = json.loads(body)\n                except Exception:\n                    pass\n        elif resp.status == 202:\n            task = self.__get_task_from_response(resp, body)\n            return task, body\n\n        if self.__body_content_is_task(body):\n            return body, body\n\n        return None, body\n\n    ###########################################################################\n    # EULA\n    ###########################################################################\n    def get_eula_status(self):\n        return self.get(uri['eulaStatus'])\n\n    def set_eula(self, supportAccess='yes'):\n        eula = make_eula_dict(supportAccess)\n        self.post(uri['eulaSave'], eula)\n        return\n\n    ###########################################################################\n    # Initial Setup\n    ###########################################################################\n    def change_initial_password(self, newPassword):\n        password = make_initial_password_change_dict('Administrator',\n                                                     'admin', newPassword)\n        # This will throw an exception if the password is already changed\n        self.post(uri['changePassword'], password)\n\n    ###########################################################################\n    # Login/Logout to/from appliance\n    ###########################################################################\n    def login(self, cred, sessionID=None, verbose=False):\n        try:\n            if self._validateVersion is False:\n                self.validateVersion()\n        except Exception:\n            raise (HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc()))\n\n        cred['loginMsgAck'] = True  # This will handle the login acknowledgement message\n        self._cred = cred\n        try:\n            if self._cred.get(\"sessionID\"):\n                self.set_session_id(self._cred[\"sessionID\"])\n                task, body = self.put(uri['loginSessions'], None)\n            elif sessionID is not None:\n                self.set_session_id(sessionID)\n                task, body = self.put(uri['loginSessions'], None)\n            else:\n                self._cred.pop(\"sessionID\", None)\n                task, body = self.post(uri['loginSessions'], self._cred)\n        except HPEOneViewException:\n            logger.exception('Login failed')\n            raise\n        auth = body['sessionID']\n        # Add the auth ID to the headers dictionary\n        self._headers['auth'] = auth\n        self._session = True\n        if verbose is True:\n            print(('Session Key: ' + auth))\n        logger.info('Logged in successfully')\n\n    def logout(self, verbose=False):\n        # resp, body = self.do_http(method, uri['loginSessions'] \\\n        #                        , body, self._headers)\n        try:\n            self.delete(uri['loginSessions'])\n        except HPEOneViewException:\n            logger.exception('Logout failed')\n            raise\n        if verbose is True:\n            print('Logged Out')\n        del self._headers['auth']\n        self._session = False\n        logger.info('Logged out successfully')\n        return None\n\n    def enable_etag_validation(self):\n        \"\"\"\n        Enable the concurrency control for the PUT and DELETE requests, in which the requests are conditionally\n        processed only if the provided entity tag in the body matches the latest entity tag stored for the resource.\n\n        The eTag validation is enabled by default.\n        \"\"\"\n        self._headers.pop('If-Match', None)\n\n    def disable_etag_validation(self):\n        \"\"\"\n        Disable the concurrency control for the PUT and DELETE requests. The requests will be forced without specifying\n        an explicit ETag. This method sets an If-Match header of \"*\".\n        \"\"\"\n        self._headers['If-Match'] = '*'",
  "def get_members(mlist):\n    if not mlist:\n        return []\n    if not mlist['members']:\n        return []\n    return mlist['members']",
  "def get_member(mlist):\n    if not mlist:\n        return None\n    if not mlist['members']:\n        return None\n    return mlist['members'][0]",
  "def make_eula_dict(supportAccess):\n    return {'supportAccess': supportAccess}",
  "def make_initial_password_change_dict(userName, oldPassword, newPassword):\n    return {\n        'userName': userName,\n        'oldPassword': oldPassword,\n        'newPassword': newPassword}",
  "def __init__(self, applianceIp, api_version=None, sslBundle=False, timeout=None, proxy=None):\n        self._session = None\n        self._host = applianceIp\n        self._cred = None\n        self._proxyHost = None\n        self._proxyPort = None\n        self._doProxy = False\n        self.set_proxy(proxy)\n        self._sslTrustAll = True\n        self._sslBundle = sslBundle\n        self._sslTrustedBundle = self.set_trusted_ssl_bundle(sslBundle)\n        self._nextPage = None\n        self._prevPage = None\n        self._numTotalRecords = 0\n        self._numDisplayedRecords = 0\n        self._validateVersion = False\n        self._timeout = timeout\n        if not api_version:\n            api_version = self.get_default_api_version()\n        self._apiVersion = int(api_version)\n        self._headers = {\n            'X-API-Version': self._apiVersion,\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'}",
  "def get_default_api_version(self):\n        self._headers = {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'}\n        version = self.get(uri['version'])\n        return version['currentVersion']",
  "def validateVersion(self):\n        version = self.get(uri['version'])\n        if 'minimumVersion' in version:\n            if self._apiVersion < version['minimumVersion']:\n                raise HPEOneViewException('Unsupported API Version')\n        if 'currentVersion' in version:\n            if self._apiVersion > version['currentVersion']:\n                raise HPEOneViewException('Unsupported API Version')\n        self._validateVersion = True",
  "def set_proxy(self, proxy):\n        if proxy and len(proxy) > 0:\n            splitted = proxy.split(':')\n            if len(splitted) != 2:\n                raise ValueError(ONEVIEW_CLIENT_INVALID_PROXY)\n            self._proxyHost = splitted[0]\n            self._proxyPort = int(splitted[1])\n            self._doProxy = True",
  "def set_trusted_ssl_bundle(self, sslBundle):\n        if sslBundle:\n            self._sslTrustAll = False\n        return sslBundle",
  "def get_session(self):\n        return self._session",
  "def get_session_id(self):\n        return self._headers.get('auth')",
  "def set_session_id(self, session_id):\n        self._headers['auth'] = session_id\n        self._session = True",
  "def get_host(self):\n        return self._host",
  "def get_by_uri(self, xuri):\n        return self.get(xuri)",
  "def make_url(self, path):\n        return 'https://%s%s' % (self._host, path)",
  "def do_http(self, method, path, body, custom_headers=None):\n        http_headers = self._headers.copy()\n        if custom_headers:\n            http_headers.update(custom_headers)\n\n        bConnected = False\n        conn = None\n        while bConnected is False:\n            try:\n                conn = self.get_connection()\n                conn.request(method, path, body, http_headers)\n                resp = conn.getresponse()\n                tempbytes = ''\n                try:\n                    tempbytes = resp.read()\n                    tempbody = tempbytes.decode('utf-8')\n                except UnicodeDecodeError:  # Might be binary data\n                    tempbody = tempbytes\n                    conn.close()\n                    bConnected = True\n                    return resp, tempbody\n                if tempbody:\n                    try:\n                        body = json.loads(tempbody)\n                    except ValueError:\n                        body = tempbody\n                conn.close()\n                bConnected = True\n            except http.client.BadStatusLine:\n                logger.warning('Bad Status Line. Trying again...')\n                if conn:\n                    conn.close()\n                time.sleep(1)\n                continue\n            except http.client.HTTPException:\n                raise HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc())\n\n        return resp, body",
  "def download_to_stream(self, stream_writer, url, body='', method='GET', custom_headers=None):\n        http_headers = self._headers.copy()\n        if custom_headers:\n            http_headers.update(custom_headers)\n\n        chunk_size = 4096\n        conn = None\n\n        successful_connected = False\n        while not successful_connected:\n            try:\n                conn = self.get_connection()\n                conn.request(method, url, body, http_headers)\n                resp = conn.getresponse()\n\n                if resp.status >= 400:\n                    self.__handle_download_error(resp, conn)\n\n                if resp.status == 302:\n                    return self.download_to_stream(stream_writer=stream_writer,\n                                                   url=resp.getheader('Location'),\n                                                   body=body,\n                                                   method=method,\n                                                   custom_headers=http_headers)\n\n                tempbytes = True\n                while tempbytes:\n                    tempbytes = resp.read(chunk_size)\n                    if tempbytes:  # filter out keep-alive new chunks\n                        stream_writer.write(tempbytes)\n\n                conn.close()\n                successful_connected = True\n            except http.client.BadStatusLine:\n                logger.warning('Bad Status Line. Trying again...')\n                if conn:\n                    conn.close()\n                time.sleep(1)\n                continue\n            except http.client.HTTPException:\n                raise HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc())\n\n        return successful_connected",
  "def __handle_download_error(self, resp, conn):\n        try:\n            tempbytes = resp.read()\n            tempbody = tempbytes.decode('utf-8')\n            try:\n                body = json.loads(tempbody)\n            except ValueError:\n                body = tempbody\n        except UnicodeDecodeError:  # Might be binary data\n            body = tempbytes\n            conn.close()\n        if not body:\n            body = \"Error \" + str(resp.status)\n\n        conn.close()\n        raise HPEOneViewException(body)",
  "def get_connection(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n        if self._sslTrustAll is False:\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(self._sslTrustedBundle)\n            if self._doProxy is False:\n                conn = http.client.HTTPSConnection(self._host,\n                                                   context=context,\n                                                   timeout=self._timeout)\n            else:\n                conn = http.client.HTTPSConnection(self._proxyHost,\n                                                   self._proxyPort,\n                                                   context=context,\n                                                   timeout=self._timeout)\n                conn.set_tunnel(self._host, 443)\n        else:\n            context.verify_mode = ssl.CERT_NONE\n            if self._doProxy is False:\n                conn = http.client.HTTPSConnection(self._host,\n                                                   context=context,\n                                                   timeout=self._timeout)\n            else:\n                conn = http.client.HTTPSConnection(self._proxyHost,\n                                                   self._proxyPort,\n                                                   context=context,\n                                                   timeout=self._timeout)\n                conn.set_tunnel(self._host, 443)\n\n        return conn",
  "def _open(self, name, mode):\n        return open(name, mode)",
  "def encode_multipart_formdata(self, fields, files, baseName, verbose=False):\n        \"\"\"\n        Fields is a sequence of (name, value) elements for regular form fields.\n        Files is a sequence of (name, filename, value) elements for data\n        to be uploaded as files\n\n        Returns: (content_type, body) ready for httplib.HTTP instance\n        \"\"\"\n        BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'\n        CRLF = '\\r\\n'\n        content_type = 'multipart/form-data; boundary=%s' % BOUNDARY\n        if verbose is True:\n            print(('Encoding ' + baseName + ' for upload...'))\n        fin = self._open(files, 'rb')\n        fout = self._open(files + '.b64', 'wb')\n        fout.write(bytearray('--' + BOUNDARY + CRLF, 'utf-8'))\n        fout.write(bytearray('Content-Disposition: form-data'\n                             '; name=\"file\"; filename=\"' + baseName + '\"' + CRLF, \"utf-8\"))\n        fout.write(bytearray('Content-Type: application/octet-stream' + CRLF,\n                             'utf-8'))\n        fout.write(bytearray(CRLF, 'utf-8'))\n        shutil.copyfileobj(fin, fout)\n        fout.write(bytearray(CRLF, 'utf-8'))\n        fout.write(bytearray('--' + BOUNDARY + '--' + CRLF, 'utf-8'))\n        fout.write(bytearray(CRLF, 'utf-8'))\n        fout.close()\n        fin.close()\n        return content_type",
  "def post_multipart_with_response_handling(self, uri, file_path, baseName):\n        resp, body = self.post_multipart(uri, None, file_path, baseName)\n\n        if resp.status == 202:\n            task = self.__get_task_from_response(resp, body)\n            return task, body\n\n        if self.__body_content_is_task(body):\n            return body, body\n\n        return None, body",
  "def post_multipart(self, uri, fields, files, baseName, verbose=False):\n        content_type = self.encode_multipart_formdata(fields, files, baseName,\n                                                      verbose)\n        inputfile = self._open(files + '.b64', 'rb')\n        mappedfile = mmap.mmap(inputfile.fileno(), 0, access=mmap.ACCESS_READ)\n        if verbose is True:\n            print(('Uploading ' + files + '...'))\n        conn = self.get_connection()\n        # conn.set_debuglevel(1)\n        conn.connect()\n        conn.putrequest('POST', uri)\n        conn.putheader('uploadfilename', baseName)\n        conn.putheader('auth', self._headers['auth'])\n        conn.putheader('Content-Type', content_type)\n        totalSize = os.path.getsize(files + '.b64')\n        conn.putheader('Content-Length', totalSize)\n        conn.putheader('X-API-Version', self._apiVersion)\n        conn.endheaders()\n\n        while mappedfile.tell() < mappedfile.size():\n            # Send 1MB at a time\n            # NOTE: Be careful raising this value as the read chunk\n            # is stored in RAM\n            readSize = 1048576\n            conn.send(mappedfile.read(readSize))\n            if verbose is True:\n                print('%d bytes sent... \\r' % mappedfile.tell())\n        mappedfile.close()\n        inputfile.close()\n        os.remove(files + '.b64')\n        response = conn.getresponse()\n        body = response.read().decode('utf-8')\n\n        if body:\n            try:\n                body = json.loads(body)\n            except ValueError:\n                body = response.read().decode('utf-8')\n\n        conn.close()\n\n        if response.status >= 400:\n            raise HPEOneViewException(body)\n\n        return response, body",
  "def get(self, uri, custom_headers=None):\n        resp, body = self.do_http('GET', uri, '', custom_headers=custom_headers)\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n        if resp.status == 302:\n            body = self.get(resp.getheader('Location'))\n        if type(body) is dict:\n            if 'nextPageUri' in body:\n                self._nextPage = body['nextPageUri']\n            if 'prevPageUri' in body:\n                self._prevPage = body['prevPageUri']\n            if 'total' in body:\n                self._numTotalRecords = body['total']\n            if 'count' in body:\n                self._numDisplayedRecords = body['count']\n        return body",
  "def getNextPage(self):\n        body = self.get(self._nextPage)\n        return get_members(body)",
  "def getPrevPage(self):\n        body = self.get(self._prevPage)\n        return get_members(body)",
  "def getLastPage(self):\n        while self._nextPage is not None:\n            members = self.getNextPage()\n        return members",
  "def getFirstPage(self):\n        while self._prevPage is not None:\n            members = self.getPrevPage()\n        return members",
  "def delete(self, uri, custom_headers=None):\n        return self.__do_rest_call('DELETE', uri, {}, custom_headers=custom_headers)",
  "def put(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('PUT', uri, body, custom_headers=custom_headers)",
  "def post(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('POST', uri, body, custom_headers=custom_headers)",
  "def patch(self, uri, body, custom_headers=None):\n        return self.__do_rest_call('PATCH', uri, body, custom_headers=custom_headers)",
  "def __body_content_is_task(self, body):\n        return isinstance(body, dict) and 'category' in body and body['category'] == 'tasks'",
  "def __get_task_from_response(self, response, body):\n        location = response.getheader('Location')\n        if location:\n            task = self.get(location)\n        elif 'taskState' in body:\n            # This check is needed to handle a status response 202 without the location header,\n            # as is for PowerDevices. We are not sure if there are more resources with the same behavior.\n            task = body\n        else:\n            # For the resource Label the status is 202 but the response not contains a task.\n            task = None\n        return task",
  "def __do_rest_call(self, http_method, uri, body, custom_headers):\n        resp, body = self.do_http(method=http_method,\n                                  path=uri,\n                                  body=json.dumps(body),\n                                  custom_headers=custom_headers)\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n\n        if resp.status == 304:\n            if body and not isinstance(body, dict):\n                try:\n                    body = json.loads(body)\n                except Exception:\n                    pass\n        elif resp.status == 202:\n            task = self.__get_task_from_response(resp, body)\n            return task, body\n\n        if self.__body_content_is_task(body):\n            return body, body\n\n        return None, body",
  "def get_eula_status(self):\n        return self.get(uri['eulaStatus'])",
  "def set_eula(self, supportAccess='yes'):\n        eula = make_eula_dict(supportAccess)\n        self.post(uri['eulaSave'], eula)\n        return",
  "def change_initial_password(self, newPassword):\n        password = make_initial_password_change_dict('Administrator',\n                                                     'admin', newPassword)\n        # This will throw an exception if the password is already changed\n        self.post(uri['changePassword'], password)",
  "def login(self, cred, sessionID=None, verbose=False):\n        try:\n            if self._validateVersion is False:\n                self.validateVersion()\n        except Exception:\n            raise (HPEOneViewException('Failure during login attempt.\\n %s' % traceback.format_exc()))\n\n        cred['loginMsgAck'] = True  # This will handle the login acknowledgement message\n        self._cred = cred\n        try:\n            if self._cred.get(\"sessionID\"):\n                self.set_session_id(self._cred[\"sessionID\"])\n                task, body = self.put(uri['loginSessions'], None)\n            elif sessionID is not None:\n                self.set_session_id(sessionID)\n                task, body = self.put(uri['loginSessions'], None)\n            else:\n                self._cred.pop(\"sessionID\", None)\n                task, body = self.post(uri['loginSessions'], self._cred)\n        except HPEOneViewException:\n            logger.exception('Login failed')\n            raise\n        auth = body['sessionID']\n        # Add the auth ID to the headers dictionary\n        self._headers['auth'] = auth\n        self._session = True\n        if verbose is True:\n            print(('Session Key: ' + auth))\n        logger.info('Logged in successfully')",
  "def logout(self, verbose=False):\n        # resp, body = self.do_http(method, uri['loginSessions'] \\\n        #                        , body, self._headers)\n        try:\n            self.delete(uri['loginSessions'])\n        except HPEOneViewException:\n            logger.exception('Logout failed')\n            raise\n        if verbose is True:\n            print('Logged Out')\n        del self._headers['auth']\n        self._session = False\n        logger.info('Logged out successfully')\n        return None",
  "def enable_etag_validation(self):\n        \"\"\"\n        Enable the concurrency control for the PUT and DELETE requests, in which the requests are conditionally\n        processed only if the provided entity tag in the body matches the latest entity tag stored for the resource.\n\n        The eTag validation is enabled by default.\n        \"\"\"\n        self._headers.pop('If-Match', None)",
  "def disable_etag_validation(self):\n        \"\"\"\n        Disable the concurrency control for the PUT and DELETE requests. The requests will be forced without specifying\n        an explicit ETag. This method sets an If-Match header of \"*\".\n        \"\"\"\n        self._headers['If-Match'] = '*'",
  "class TaskMonitor(object):\n    # Seconds to wait when a network failure occurs\n    CONNECTION_FAILURE_TIMEOUT = 90\n\n    # Known error numbers when the connection drops\n    CONNECTION_FAILURE_ERROR_NUMBERS = [ENOEXEC, EINVAL, ENETUNREACH, ETIMEDOUT, ECONNRESET,\n                                        ECONNABORTED, ENETUNREACH, ENETDOWN, ECONNREFUSED]\n\n    def __init__(self, con):\n        self._connection = con\n\n    @staticmethod\n    def get_current_seconds():\n        return int(time.time())\n\n    def wait_for_task(self, task, timeout=-1):\n        \"\"\"\n        Wait for task execution and return associated resource.\n\n        Args:\n            task: task dict\n            timeout: timeout in seconds\n\n        Returns:\n            Associated resource when creating or updating; True when deleting.\n        \"\"\"\n        self.__wait_task_completion(task, timeout)\n\n        task = self.get(task)\n\n        logger.debug(\"Waiting for task. Percentage complete: \" + str(task.get('computedPercentComplete')))\n        logger.debug(\"Waiting for task. Task state: \" + str(task.get('taskState')))\n\n        task_response = self.__get_task_response(task)\n        logger.debug('Task completed')\n        return task_response\n\n    def get_completed_task(self, task, timeout=-1):\n        \"\"\"\n        Waits until the task is completed and returns the task resource.\n\n        Args:\n            task: TaskResource\n            timeout: Timeout in seconds\n\n        Returns:\n            dict: TaskResource\n        \"\"\"\n        self.__wait_task_completion(task, timeout)\n\n        return self.get(task)\n\n    def __wait_task_completion(self, task, timeout):\n        if not task:\n            raise HPEOneViewUnknownType(MSG_INVALID_TASK)\n\n        logger.debug('Waiting for task completion...')\n\n        # gets current cpu second for timeout\n        start_time = self.get_current_seconds()\n        connection_failure_control = dict(last_success=self.get_current_seconds())\n\n        i = 0\n        while self.is_task_running(task, connection_failure_control):\n            # wait 1 to 10 seconds\n            # the value increases to avoid flooding server with requests\n            i = i + 1 if i < 10 else 10\n\n            logger.debug(\"Waiting for task. Percentage complete: \" + str(task.get('computedPercentComplete')))\n            logger.debug(\"Waiting for task. Task state: \" + str(task.get('taskState')))\n\n            time.sleep(i)\n            if (timeout != UNLIMITED_TIMEOUT) and (start_time + timeout < self.get_current_seconds()):\n                raise HPEOneViewTimeout(MSG_TIMEOUT % str(timeout))\n\n    def __get_task_response(self, task):\n        deleted_states = ['Delete',\n                          'Remove',\n                          'Delete server hardware type',\n                          'Remove SAN manager',\n                          'Delete hypervisor cluster profile.']\n\n        if task['taskState'] in TASK_ERROR_STATES and task['taskState'] != 'Warning':\n            msg = None\n            error_code = None\n            if 'taskErrors' in task and len(task['taskErrors']) > 0:\n                err = task['taskErrors'][0]\n                if 'message' in err:\n                    msg = err['message']\n\n                error_code = err.get('errorCode')\n\n            if msg:\n                raise HPEOneViewTaskError(msg, error_code)\n            elif 'taskStatus' in task and task['taskStatus']:\n                raise HPEOneViewTaskError(task['taskStatus'], error_code)\n            else:\n                raise HPEOneViewTaskError(MSG_UNKNOWN_EXCEPTION, error_code)\n\n        if 'name' in task and task['name'] in deleted_states:\n            return True\n\n        if 'type' in task and task['type'].startswith('Task'):\n            # get associated resource when is not a delete task\n            task, entity = self.get_associated_resource(task)\n            return entity\n\n        logger.warning('Task completed, unknown response: ' + str(task))\n        return task\n\n    def is_task_running(self, task, connection_failure_control=None):\n        \"\"\"\n        Check if a task is running according to: TASK_PENDING_STATES ['New', 'Starting',\n        'Pending', 'Running', 'Suspended', 'Stopping']\n\n        Args:\n            task (dict): OneView Task resource.\n            connection_failure_control (dict):\n                A dictionary instance that contains last_success for error tolerance control.\n\n        Examples:\n\n            >>> connection_failure_control = dict(last_success=int(time.time()))\n            >>> while self.is_task_running(task, connection_failure_control):\n            >>>     pass\n\n        Returns:\n            True when in TASK_PENDING_STATES; False when not.\n        \"\"\"\n        if 'uri' in task:\n            try:\n                task = self.get(task)\n                if connection_failure_control:\n                    # Updates last success\n                    connection_failure_control['last_success'] = self.get_current_seconds()\n                if 'taskState' in task and task['taskState'] in TASK_PENDING_STATES:\n                    return True\n\n            except Exception as error:\n                logger.error('; '.join(str(e) for e in error.args) + ' when waiting for the task: ' + str(task))\n\n                if not connection_failure_control:\n                    raise error\n\n                if hasattr(error, 'errno') and error.errno in self.CONNECTION_FAILURE_ERROR_NUMBERS:\n                    last_success = connection_failure_control['last_success']\n                    if last_success + self.CONNECTION_FAILURE_TIMEOUT < self.get_current_seconds():\n                        # Timeout reached\n                        raise error\n                    else:\n                        # Return task is running when network instability occurs\n                        return True\n                else:\n                    raise error\n\n        return False\n\n    def get(self, task):\n        \"\"\"\n        Retrieve a task by its uri.\n\n        Args:\n            task: task dict, must have 'uri' key.\n\n        Returns:\n            task dict\n        \"\"\"\n\n        task = self._connection.get(task['uri'])\n        return task\n\n    def get_associated_resource(self, task):\n        \"\"\"\n        Retrieve a resource associated with a task.\n\n        Args:\n            task: task dict\n\n        Returns:\n            tuple: task (updated), the entity found (dict)\n        \"\"\"\n\n        if not task:\n            raise HPEOneViewUnknownType(MSG_INVALID_TASK)\n\n        if task['category'] not in ['tasks', 'backups']:\n            # it is an error if type is not in obj, so let the except flow\n            raise HPEOneViewUnknownType(MSG_UNKNOWN_OBJECT_TYPE)\n\n        if task['type'] in ['TaskResourceV2', 'TaskResourceV3']:\n            resource_uri = task['associatedResource']['resourceUri']\n\n            if resource_uri and resource_uri.startswith(\"/rest/appliance/support-dumps/\"):\n                # Specific for support dumps\n                return task, resource_uri\n\n        elif task['type'] == 'BACKUP':\n            task = self._connection.get(task['taskUri'])\n            resource_uri = task['uri']\n        else:\n            raise HPEOneViewInvalidResource(MSG_TASK_TYPE_UNRECONIZED % task['type'])\n\n        entity = {}\n\n        if resource_uri:\n            entity = self._connection.get(resource_uri)\n\n        return task, entity",
  "def __init__(self, con):\n        self._connection = con",
  "def get_current_seconds():\n        return int(time.time())",
  "def wait_for_task(self, task, timeout=-1):\n        \"\"\"\n        Wait for task execution and return associated resource.\n\n        Args:\n            task: task dict\n            timeout: timeout in seconds\n\n        Returns:\n            Associated resource when creating or updating; True when deleting.\n        \"\"\"\n        self.__wait_task_completion(task, timeout)\n\n        task = self.get(task)\n\n        logger.debug(\"Waiting for task. Percentage complete: \" + str(task.get('computedPercentComplete')))\n        logger.debug(\"Waiting for task. Task state: \" + str(task.get('taskState')))\n\n        task_response = self.__get_task_response(task)\n        logger.debug('Task completed')\n        return task_response",
  "def get_completed_task(self, task, timeout=-1):\n        \"\"\"\n        Waits until the task is completed and returns the task resource.\n\n        Args:\n            task: TaskResource\n            timeout: Timeout in seconds\n\n        Returns:\n            dict: TaskResource\n        \"\"\"\n        self.__wait_task_completion(task, timeout)\n\n        return self.get(task)",
  "def __wait_task_completion(self, task, timeout):\n        if not task:\n            raise HPEOneViewUnknownType(MSG_INVALID_TASK)\n\n        logger.debug('Waiting for task completion...')\n\n        # gets current cpu second for timeout\n        start_time = self.get_current_seconds()\n        connection_failure_control = dict(last_success=self.get_current_seconds())\n\n        i = 0\n        while self.is_task_running(task, connection_failure_control):\n            # wait 1 to 10 seconds\n            # the value increases to avoid flooding server with requests\n            i = i + 1 if i < 10 else 10\n\n            logger.debug(\"Waiting for task. Percentage complete: \" + str(task.get('computedPercentComplete')))\n            logger.debug(\"Waiting for task. Task state: \" + str(task.get('taskState')))\n\n            time.sleep(i)\n            if (timeout != UNLIMITED_TIMEOUT) and (start_time + timeout < self.get_current_seconds()):\n                raise HPEOneViewTimeout(MSG_TIMEOUT % str(timeout))",
  "def __get_task_response(self, task):\n        deleted_states = ['Delete',\n                          'Remove',\n                          'Delete server hardware type',\n                          'Remove SAN manager',\n                          'Delete hypervisor cluster profile.']\n\n        if task['taskState'] in TASK_ERROR_STATES and task['taskState'] != 'Warning':\n            msg = None\n            error_code = None\n            if 'taskErrors' in task and len(task['taskErrors']) > 0:\n                err = task['taskErrors'][0]\n                if 'message' in err:\n                    msg = err['message']\n\n                error_code = err.get('errorCode')\n\n            if msg:\n                raise HPEOneViewTaskError(msg, error_code)\n            elif 'taskStatus' in task and task['taskStatus']:\n                raise HPEOneViewTaskError(task['taskStatus'], error_code)\n            else:\n                raise HPEOneViewTaskError(MSG_UNKNOWN_EXCEPTION, error_code)\n\n        if 'name' in task and task['name'] in deleted_states:\n            return True\n\n        if 'type' in task and task['type'].startswith('Task'):\n            # get associated resource when is not a delete task\n            task, entity = self.get_associated_resource(task)\n            return entity\n\n        logger.warning('Task completed, unknown response: ' + str(task))\n        return task",
  "def is_task_running(self, task, connection_failure_control=None):\n        \"\"\"\n        Check if a task is running according to: TASK_PENDING_STATES ['New', 'Starting',\n        'Pending', 'Running', 'Suspended', 'Stopping']\n\n        Args:\n            task (dict): OneView Task resource.\n            connection_failure_control (dict):\n                A dictionary instance that contains last_success for error tolerance control.\n\n        Examples:\n\n            >>> connection_failure_control = dict(last_success=int(time.time()))\n            >>> while self.is_task_running(task, connection_failure_control):\n            >>>     pass\n\n        Returns:\n            True when in TASK_PENDING_STATES; False when not.\n        \"\"\"\n        if 'uri' in task:\n            try:\n                task = self.get(task)\n                if connection_failure_control:\n                    # Updates last success\n                    connection_failure_control['last_success'] = self.get_current_seconds()\n                if 'taskState' in task and task['taskState'] in TASK_PENDING_STATES:\n                    return True\n\n            except Exception as error:\n                logger.error('; '.join(str(e) for e in error.args) + ' when waiting for the task: ' + str(task))\n\n                if not connection_failure_control:\n                    raise error\n\n                if hasattr(error, 'errno') and error.errno in self.CONNECTION_FAILURE_ERROR_NUMBERS:\n                    last_success = connection_failure_control['last_success']\n                    if last_success + self.CONNECTION_FAILURE_TIMEOUT < self.get_current_seconds():\n                        # Timeout reached\n                        raise error\n                    else:\n                        # Return task is running when network instability occurs\n                        return True\n                else:\n                    raise error\n\n        return False",
  "def get(self, task):\n        \"\"\"\n        Retrieve a task by its uri.\n\n        Args:\n            task: task dict, must have 'uri' key.\n\n        Returns:\n            task dict\n        \"\"\"\n\n        task = self._connection.get(task['uri'])\n        return task",
  "def get_associated_resource(self, task):\n        \"\"\"\n        Retrieve a resource associated with a task.\n\n        Args:\n            task: task dict\n\n        Returns:\n            tuple: task (updated), the entity found (dict)\n        \"\"\"\n\n        if not task:\n            raise HPEOneViewUnknownType(MSG_INVALID_TASK)\n\n        if task['category'] not in ['tasks', 'backups']:\n            # it is an error if type is not in obj, so let the except flow\n            raise HPEOneViewUnknownType(MSG_UNKNOWN_OBJECT_TYPE)\n\n        if task['type'] in ['TaskResourceV2', 'TaskResourceV3']:\n            resource_uri = task['associatedResource']['resourceUri']\n\n            if resource_uri and resource_uri.startswith(\"/rest/appliance/support-dumps/\"):\n                # Specific for support dumps\n                return task, resource_uri\n\n        elif task['type'] == 'BACKUP':\n            task = self._connection.get(task['taskUri'])\n            resource_uri = task['uri']\n        else:\n            raise HPEOneViewInvalidResource(MSG_TASK_TYPE_UNRECONIZED % task['type'])\n\n        entity = {}\n\n        if resource_uri:\n            entity = self._connection.get(resource_uri)\n\n        return task, entity",
  "class EnsureResourceClient(object):\n    \"\"\"Decorator class to update the resource data.\"\"\"\n\n    def __init__(self, method=None, update_data=False):\n        self.method = method\n        self.update_data = update_data\n\n    def __get__(self, obj, objtype):\n        return partial(self.__call__, obj)\n\n    def __call__(self, obj, *args, **kwargs):\n        if self.method:\n            obj.ensure_resource_data(update_data=self.update_data)\n            return self.method(obj, *args, **kwargs)\n\n        def wrap(*args, **kwargs):\n            args[0].ensure_resource_data(update_data=self.update_data)\n            return obj(*args, **kwargs)\n\n        return wrap",
  "class Resource(object):\n    \"\"\"Base class for OneView resources.\n\n    Args:\n        connection: OneView connection object\n        data: Resource data\n    \"\"\"\n    # Base URI for the rest calls\n    URI = '/rest'\n\n    # Unique identifiers to query the resource\n    UNIQUE_IDENTIFIERS = ['uri', 'name']\n\n    # Default values required for the api versions\n    DEFAULT_VALUES = {}\n\n    def __init__(self, connection, data=None):\n        self._connection = connection\n        self._task_monitor = TaskMonitor(connection)\n        self._helper = ResourceHelper(self.URI,\n                                      self._connection,\n                                      self._task_monitor)\n        # Resource data\n        self.data = data if data else {}\n\n        # Merge resoure data with the default values\n        self._merge_default_values()\n\n    def ensure_resource_data(self, update_data=False):\n        \"\"\"Retrieves data from OneView and updates resource object.\n\n        Args:\n            update_data: Flag to update resource data when it is required.\n        \"\"\"\n        # Check for unique identifier in the resource data\n        if not any(key in self.data for key in self.UNIQUE_IDENTIFIERS):\n            raise exceptions.HPEOneViewMissingUniqueIdentifiers(MISSING_UNIQUE_IDENTIFIERS)\n\n        # Returns if data update is not required\n        if not update_data:\n            return\n\n        resource_data = None\n\n        if 'uri' in self.UNIQUE_IDENTIFIERS and self.data.get('uri'):\n            resource_data = self._helper.do_get(self.data['uri'])\n        else:\n            for identifier in self.UNIQUE_IDENTIFIERS:\n                identifier_value = self.data.get(identifier)\n\n                if identifier_value:\n                    result = self.get_by(identifier, identifier_value)\n                    if result and isinstance(result, list):\n                        resource_data = result[0]\n                        break\n\n        if resource_data:\n            self.data.update(resource_data)\n        else:\n            raise exceptions.HPEOneViewResourceNotFound(RESOURCE_DOES_NOT_EXIST)\n\n    @ensure_resource_client\n    def refresh(self):\n        \"\"\"Helps to get the latest resource data from the server.\"\"\"\n        self.data = self._helper.do_get(self.data[\"uri\"])\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"Gets all items according with the given arguments.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n\n        Returns:\n            list: A list of items matching the specified filter.\n        \"\"\"\n        result = self._helper.get_all(start=start, count=count, filter=filter, sort=sort)\n        return result\n\n    def create(self, data=None, uri=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        data = self._helper.update_resource_fields(data, default_values)\n\n        logger.debug('Create (uri = %s, resource = %s)' % (uri, str(data)))\n        resource_data = self._helper.create(data, uri, timeout, custom_headers, force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource\n\n    @ensure_resource_client\n    def delete(self, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Deletes current resource.\n\n        Args:\n            timeout: Timeout in seconds.\n            custom_headers: Allows to set custom http headers.\n            force: Flag to force the operation.\n        \"\"\"\n        uri = self.data['uri']\n\n        logger.debug(\"Delete resource (uri = %s)\" % (str(uri)))\n\n        return self._helper.delete(uri, timeout=timeout,\n                                   custom_headers=custom_headers, force=force)\n\n    @ensure_resource_client(update_data=True)\n    def update(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n\n        self.data = self._helper.update(resource, uri, force, timeout, custom_headers)\n\n        return self\n\n    def get_by(self, field, value):\n        \"\"\"Get the resource by passing a field and its value.\n\n        Note:\n            This function uses get_all passing a filter.The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            dict\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        filter = \"\\\"{0}='{1}'\\\"\".format(field, value)\n        results = self.get_all(filter=filter)\n\n        # Workaround when the OneView filter does not work, it will filter again\n        if \".\" not in field:\n            # This filter only work for the first level\n            results = [item for item in results if str(item.get(field, \"\")).lower() == value.lower()]\n        return results\n\n    def get_by_name(self, name):\n        \"\"\"Retrieves a resource by its name.\n\n        Args:\n            name: Resource name.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        result = self.get_by(\"name\", name)\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource\n\n    # Sometimes get_all() with filters are not returning correct values, so added this method to overcome that issue\n    def get_by_field(self, field, value):\n        \"\"\"Retrieves a resource by its field.\n\n        Args:\n            field: Resource field name.\n            value: Resource field value.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        results = self.get_all()\n\n        # This filter only work for the first level\n        result = [item for item in results if value.lower() in str(\n            item.get(field, \"\")).lower()]\n\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource\n\n    def get_by_uri(self, uri):\n        \"\"\"Retrieves a resource by its URI\n\n        Args:\n            uri: URI of the resource\n\n        Returns:\n            Resource object\n        \"\"\"\n        self._helper.validate_resource_uri(uri)\n        data = self._helper.do_get(uri)\n\n        if data:\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n\n        return new_resource\n\n    def get_by_id(self, id):\n        \"\"\"Retrieves a resource by its id.\n\n        Args:\n            id: id of Resource\n\n        Returns:\n            Resource object or None if resource does not exist.\n\n        \"\"\"\n\n        uri = \"{}/{}\".format(self.URI, id)\n        self._helper.validate_resource_uri(uri)\n        data = self._helper.do_get(uri)\n\n        if data:\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n\n        return new_resource\n\n    def _get_default_values(self, default_values=None):\n        \"\"\"Gets the default values set for a resource\"\"\"\n\n        if not default_values:\n            default_values = self.DEFAULT_VALUES\n\n        if default_values:\n            api_version = str(self._connection._apiVersion)\n            values = default_values.get(api_version, {}).copy()\n        else:\n            values = {}\n\n        return values\n\n    def _merge_default_values(self):\n        \"\"\"Merge default values with resource data.\"\"\"\n        values = self._get_default_values()\n        for key, value in values.items():\n            if not self.data.get(key):\n                self.data[key] = value\n\n    @classmethod\n    def new(cls, connection, data):\n        \"\"\"Returns a new resource object\"\"\"\n        return cls(connection, data)",
  "class ResourceHelper(object):\n\n    def __init__(self, base_uri, connection, task_monitor):\n        self._base_uri = base_uri\n        self._connection = connection\n        self._task_monitor = task_monitor\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris='', custom_headers=None,\n                name_prefix='', category=[], childLimit=0, topCount=0,):\n        \"\"\"Gets all items according with the given arguments.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query: A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            custom_headers: custom headers\n\n        Returns:\n             list: A list of items matching the specified filter.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        uri = self.build_query_uri(uri=uri,\n                                   start=start,\n                                   count=count,\n                                   filter=filter,\n                                   query=query,\n                                   sort=sort,\n                                   view=view,\n                                   fields=fields,\n                                   scope_uris=scope_uris,\n                                   name_prefix=name_prefix,\n                                   category=category,\n                                   childLimit=childLimit,\n                                   topCount=topCount)\n\n        logger.debug('Getting all resources with uri: {0}'.format(uri))\n\n        return self.do_requests_to_getall(uri, count, custom_headers=custom_headers)\n\n    def delete_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes all resources from the appliance that match the provided filter.\n\n        Args:\n            filter:\n                A general filter/query string to narrow the list of items deleted.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resources were successfully deleted.\n        \"\"\"\n        uri = \"{}?filter={}&force={}\".format(self._base_uri, quote(filter), force)\n        logger.debug(\"Delete all resources (uri = %s)\" % uri)\n\n        return self.delete(uri)\n\n    def create(self, data=None, uri=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        if force:\n            uri += '?force={}'.format(force)\n\n        logger.debug('Create (uri = %s, resource = %s)' % (uri, str(data)))\n        return self.do_post(uri, data, timeout, custom_headers)\n\n    def delete(self, uri, force=False, timeout=-1, custom_headers=None):\n        \"\"\"Deletes current resource.\n\n        Args:\n            force: Flag to delete the resource forcefully, default is False.\n            timeout: Timeout in seconds.\n            custom_headers: Allows to set custom http headers.\n        \"\"\"\n        if force:\n            uri += '?force=True'\n\n        logger.debug(\"Delete resource (uri = %s)\" % (str(uri)))\n\n        task, body = self._connection.delete(uri, custom_headers=custom_headers)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        task = self._task_monitor.wait_for_task(task, timeout=timeout)\n\n        return task\n\n    def update(self, resource, uri=None, force=False, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            resource: Data to update the resource.\n            uri: Resource uri\n            force: If set to true, the operation completes despite any problems\n                with network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n        if not uri:\n            uri = resource['uri']\n\n        if force:\n            uri += '?force=True'\n\n        return self.do_put(uri, resource, timeout, custom_headers)\n\n    def update_with_zero_body(self, uri, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri: Allows to use a different URI other than resource URI\n            timeout: Timeout in seconds. Wait for task completion by default.\n                The timeout does not abort the operation in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to set custom HTTP headers.\n\n        Returns:\n            A dict with updated resource data.\n        \"\"\"\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n\n        return self.do_put(uri, None, timeout, custom_headers)\n\n    def create_report(self, uri, timeout=-1):\n        \"\"\"\n        Creates a report and returns the output.\n\n        Args:\n            uri: URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list:\n        \"\"\"\n        logger.debug('Creating Report')\n        task, _ = self._connection.post(uri, {})\n\n        if not task:\n            raise exceptions.HPEOneViewException(RESOURCE_CLIENT_TASK_EXPECTED)\n\n        task = self._task_monitor.get_completed_task(task, timeout)\n\n        return task['taskOutput']\n\n    def get_collection(self, uri=None, filter='', path=''):\n        \"\"\"Retrieves a collection of resources.\n\n        Use this function when the 'start' and 'count' parameters are not allowed in the GET call.\n        Otherwise, use get_all instead.\n\n        Optional filtering criteria may be specified.\n\n        Args:\n            filter (list or str): General filter/query string.\n            path (str): path to be added with base URI\n\n        Returns:\n             Collection of the requested resource.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        if filter:\n            filter = self.make_query_filter(filter)\n            filter = \"?\" + filter[1:]\n\n        uri = \"{uri}{path}{filter}\".format(uri=uri, path=path, filter=filter)\n        logger.debug('Get resource collection (uri = %s)' % uri)\n\n        response = self._connection.get(uri)\n\n        return self.get_members(response)\n\n    def build_query_uri(self, uri=None, start=0, count=-1, filter='', query='', sort='', view='', fields='', scope_uris='',\n                        name_prefix='', category=[], childLimit=0, topCount=0):\n        \"\"\"Builds the URI from given parameters.\n\n        More than one request can be send to get the items, regardless the query parameter 'count', because the actual\n        number of items in the response might differ from the requested count. Some types of resource have a limited\n        number of items returned on each call. For those resources, additional calls are made to the API to retrieve\n        any other items matching the given filter. The actual number of items can also differ from the requested call\n        if the requested number of items would take too long.\n\n        The use of optional parameters for OneView 2.0 is described at:\n        http://h17007.www1.hpe.com/docs/enterprise/servers/oneview2.0/cic-api/en/api-docs/current/index.html\n\n        Note:\n            Single quote - \"'\" - inside a query parameter is not supported by OneView API.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query: A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view: Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields: Name of the fields.\n            uri: A specific URI (optional)\n            scope_uris: An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            name_prefix: Filters the resource returned by the given prefix.\n\n        Returns:\n            uri: The complete uri\n        \"\"\"\n        if filter:\n            filter = self.make_query_filter(filter)\n\n        if query:\n            query = \"&query=\" + quote(query)\n\n        if sort:\n            sort = \"&sort=\" + quote(sort)\n\n        if view:\n            view = \"&view=\" + quote(view)\n\n        if fields:\n            fields = \"&fields=\" + quote(fields)\n\n        if scope_uris:\n            scope_uris = \"&scopeUris=\" + quote(scope_uris)\n\n        if name_prefix:\n            name_prefix = \"&namePrefix=\" + quote(name_prefix)\n\n        categories = ''\n        if category:\n            for cat in category:\n                categories = categories + \"&category=\" + quote(cat)\n\n        if childLimit:\n            childLimit = \"&childLimit=\" + str(childLimit)\n\n        if topCount:\n            topCount = \"&topCount=\" + str(topCount)\n\n        path = uri if uri else self._base_uri\n\n        self.validate_resource_uri(path)\n\n        symbol = '?' if '?' not in path else '&'\n\n        uri = \"{0}{1}start={2}&count={3}{4}{5}{6}{7}{8}{9}{10}{11}\".format(path, symbol, start, count, filter, query, sort,\n                                                                           view, fields, scope_uris, name_prefix, categories)\n        return uri\n\n    def build_uri_with_query_string(self, kwargs, sufix_path='', uri=None):\n        if not uri:\n            uri = self._base_uri\n\n        query_string = '&'.join('{}={}'.format(key, kwargs[key]) for key in sorted(kwargs))\n        return uri + sufix_path + '?' + query_string\n\n    def build_uri(self, id_or_uri):\n        \"\"\"Helps to build the URI from resource id and validate the URI.\n\n        Args:\n            id_or_uri: ID/URI of the resource.\n\n        Returns:\n            Returns a valid resource URI\n        \"\"\"\n        if not id_or_uri:\n            logger.exception(RESOURCE_CLIENT_INVALID_ID)\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        if \"/\" in id_or_uri:\n            self.validate_resource_uri(id_or_uri)\n            return id_or_uri\n        else:\n            return self._base_uri + \"/\" + id_or_uri\n\n    def build_subresource_uri(self, resource_id_or_uri=None, subresource_id_or_uri=None, subresource_path=''):\n        \"\"\"Helps to build a URI with resource path and its sub resource path.\n\n        Args:\n            resoure_id_or_uri: ID/URI of the main resource.\n            subresource_id__or_uri: ID/URI of the sub resource.\n            subresource_path: Sub resource path to be added with the URI.\n\n        Returns:\n            Returns URI\n        \"\"\"\n        if subresource_id_or_uri and \"/\" in subresource_id_or_uri:\n            return subresource_id_or_uri\n        else:\n            if not resource_id_or_uri:\n                raise exceptions.HPEOneViewValueError(RESOURCE_ID_OR_URI_REQUIRED)\n\n            resource_uri = self.build_uri(resource_id_or_uri)\n\n            uri = \"{}/{}/{}\".format(resource_uri, subresource_path, str(subresource_id_or_uri or ''))\n            uri = uri.replace(\"//\", \"/\")\n\n            if uri.endswith(\"/\"):\n                uri = uri[:-1]\n\n            return uri\n\n    def validate_resource_uri(self, path):\n        \"\"\"Helper method to validate URI of the resource.\"\"\"\n        if self._base_uri not in path:\n            logger.exception('Get by uri : unrecognized uri: (%s)' % path)\n            raise exceptions.HPEOneViewUnknownType(UNRECOGNIZED_URI)\n\n    def make_query_filter(self, filters):\n        \"\"\"Helper method to build filter query parameter.\"\"\"\n        if isinstance(filters, list):\n            formated_filter = \"&filter=\".join(quote(f) for f in filters)\n        else:\n            formated_filter = quote(filters)\n\n        return \"&filter=\" + formated_filter\n\n    def get_members(self, mlist):\n        \"\"\"Get members from list of resources\"\"\"\n        if mlist and mlist.get('members'):\n            return mlist['members']\n        else:\n            return []\n\n    def update_resource_fields(self, data, data_to_add):\n        \"\"\"Update resource data with new fields.\n\n        Args:\n            data: resource data\n            data_to_update: dict of data to update resource data\n\n        Returnes:\n            Returnes dict\n        \"\"\"\n        for key, value in data_to_add.items():\n            if not data.get(key):\n                data[key] = value\n\n        return data\n\n    def do_requests_to_getall(self, uri, requested_count, custom_headers=None):\n        \"\"\"Helps to make http request for get_all method.\n\n        Note:\n            This method will be checking for the pagination URI in the response\n            and make request to pagination URI to get all the resources.\n        \"\"\"\n        items = []\n        while uri:\n            logger.debug('Making HTTP request to get all resources. Uri: {0}'.format(uri))\n            response = self._connection.get(uri, custom_headers=custom_headers)\n            members = self.get_members(response)\n            items += members\n\n            logger.debug(\"Response getAll: nextPageUri = {0}, members list length: {1}\".format(uri, str(len(members))))\n            uri = self.get_next_page(response, items, requested_count)\n\n        logger.debug('Total # of members found = {0}'.format(str(len(items))))\n        return items\n\n    def get_next_page(self, response, items, requested_count):\n        \"\"\"Returns next page URI.\"\"\"\n        next_page_is_empty = response.get('nextPageUri') is None\n        has_different_next_page = not response.get('uri') == response.get('nextPageUri')\n        has_next_page = not next_page_is_empty and has_different_next_page\n\n        if len(items) >= requested_count and requested_count != -1:\n            return None\n\n        return response.get('nextPageUri') if has_next_page else None\n\n    def do_get(self, uri):\n        \"\"\"Helps to make get requests\n\n        Args:\n            uri: URI of the resource\n\n        Returns:\n            Returns: Returns the resource data\n        \"\"\"\n        self.validate_resource_uri(uri)\n        return self._connection.get(uri)\n\n    def do_post(self, uri, resource, timeout, custom_headers):\n        \"\"\"Helps to make post requests.\n\n        Args:\n            uri: URI of  the resource.\n            resource: Resource data to post.\n            timeout: Time out for the request in seconds.\n            cutom_headers: Allows to add custom http headers.\n\n        Returns:\n            Retunrs Task object.\n        \"\"\"\n        self.validate_resource_uri(uri)\n        task, entity = self._connection.post(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def do_put(self, uri, resource, timeout, custom_headers):\n        \"\"\"Helps to make put requests.\n\n        Args:\n            uri: URI of the resource\n            timeout: Time out for the request in seconds.\n            custom_headers: Allows to set custom http headers.\n\n        Retuns:\n            Returns Task object\n        \"\"\"\n        self.validate_resource_uri(uri)\n\n        task, body = self._connection.put(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return body\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def add_new_fields(data, data_to_add):\n        \"\"\"Update resource data with new fields.\n\n        Args:\n            data: resource data\n            data_to_update: dict of data to update resource data\n\n        Returnes:\n            Returnes dict\n        \"\"\"\n        for key, value in data_to_add.items():\n            if not data.get(key):\n                data[key] = value\n\n        return data",
  "class ResourcePatchMixin(object):\n\n    @ensure_resource_client\n    def patch(self, operation, path, value, custom_headers=None, timeout=-1):\n        \"\"\"Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom http headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        patch_request_body = [{'op': operation, 'path': path, 'value': value}]\n        resource_uri = self.data['uri']\n\n        self.data = self.patch_request(resource_uri,\n                                       body=patch_request_body,\n                                       custom_headers=custom_headers,\n                                       timeout=timeout)\n        return self\n\n    def patch_request(self, uri, body, custom_headers=None, timeout=-1):\n        \"\"\"Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            body (list): Patch request body\n            timeout (int): Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers (dict): Allows to add custom http headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        logger.debug('Patch resource (uri = %s, data = %s)' % (uri, body))\n\n        if not custom_headers:\n            custom_headers = {}\n\n        if self._connection._apiVersion >= 300 and 'Content-Type' not in custom_headers:\n            custom_headers['Content-Type'] = 'application/json-patch+json'\n\n        task, entity = self._connection.patch(uri, body, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "class ResourceFileHandlerMixin(object):\n\n    def upload(self, file_path, uri=None, timeout=-1):\n        \"\"\"Makes a multipart request.\n\n        Args:\n            file_path: File to upload.\n            uri: A specific URI (optional).\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Response body.\n        \"\"\"\n        if not uri:\n            uri = self.URI\n\n        upload_file_name = os.path.basename(file_path)\n        task, entity = self._connection.post_multipart_with_response_handling(uri, file_path, upload_file_name)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def download(self, uri, file_path):\n        \"\"\"Downloads the contents of the requested URI to a stream.\n\n        Args:\n            uri: URI\n            file_path: File path destination\n\n        Returns:\n            bool: Indicates if the file was successfully downloaded.\n        \"\"\"\n        with open(file_path, 'wb') as file:\n            return self._connection.download_to_stream(file, uri)",
  "class ResourceUtilizationMixin(object):\n\n    def get_utilization(self, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"Retrieves historical utilization data for the specified resource, metrics, and time span.\n\n        Args:\n            fields: Name of the supported metric(s) to be retrieved in the format METRIC[,METRIC]...\n                If unspecified, all metrics supported are returned.\n\n            filter (list or str): Filters should be in the format FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n                E.g.: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate\n                    End date of requested starting time range in ISO 8601 format. When omitted, the endDate includes\n                    the latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The\n                caller is responsible for comparing the returned sliceStartTime with the requested startTime in the\n                response. If the sliceStartTime is greater than the oldestSampleTime and the requested start time,\n                the caller is responsible for repeating the request with endTime set to sliceStartTime to obtain the\n                next segment. This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource has, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh: Specifies that if necessary, an additional request will be queued to obtain the most recent\n                utilization data from the iLO. The response will not include any refreshed data. To track the\n                availability of the newly collected data, monitor the TaskResource identified by the refreshTaskUri\n                property in the response. If null, no refresh was queued.\n\n            view: Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the iLO. Samples at this resolution\n                    are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict\n        \"\"\"\n        resource_uri = self.data['uri']\n        query = ''\n\n        if filter:\n            query += self._helper.make_query_filter(filter)\n\n        if fields:\n            query += \"&fields=\" + quote(fields)\n\n        if refresh:\n            query += \"&refresh=true\"\n\n        if view:\n            query += \"&view=\" + quote(view)\n\n        if query:\n            query = \"?\" + query[1:]\n\n        uri = \"{0}/utilization{1}\".format(self._helper.build_uri(resource_uri), query)\n\n        return self._helper.do_get(uri)",
  "class ResourceSchemaMixin(object):\n\n    def get_schema(self):\n        \"\"\"Supports schema requests.\n\n        Returns:\n            A dict with the schema.\n        \"\"\"\n        return self._helper.do_get(self.URI + '/schema')",
  "class ResourceZeroBodyMixin(object):\n\n    def create_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"Makes a POST request to create a resource when no request body is required.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self.URI\n\n        logger.debug('Create with zero body (uri = %s)' % uri)\n        resource_data = self._helper.do_post(uri, {}, timeout, custom_headers)\n\n        return resource_data\n\n    def update_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri: Allows to use a different URI other than resource URI\n            timeout: Timeout in seconds. Wait for task completion by default.\n                The timeout does not abort the operation in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to set custom HTTP headers.\n\n        Returns:\n            A dict with updated resource data.\n        \"\"\"\n        if not uri:\n            uri = self.data['uri']\n\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n        resource_data = self._helper.do_put(uri, None, timeout, custom_headers)\n\n        return resource_data",
  "class ResourceClient(object):\n    \"\"\"\n    This class implements common functions for HpOneView API rest\n    \"\"\"\n\n    def __init__(self, con, uri):\n        self._connection = con\n        self._uri = uri\n        self._task_monitor = TaskMonitor(con)\n\n    def build_query_uri(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris=''):\n        \"\"\"\n        Builds the URI given the parameters.\n\n        More than one request can be send to get the items, regardless the query parameter 'count', because the actual\n        number of items in the response might differ from the requested count. Some types of resource have a limited\n        number of items returned on each call. For those resources, additional calls are made to the API to retrieve\n        any other items matching the given filter. The actual number of items can also differ from the requested call\n        if the requested number of items would take too long.\n\n        The use of optional parameters for OneView 2.0 is described at:\n        http://h17007.www1.hpe.com/docs/enterprise/servers/oneview2.0/cic-api/en/api-docs/current/index.html\n\n        Note:\n            Single quote - \"'\" - inside a query parameter is not supported by OneView API.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query:\n                A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            uri: The complete uri\n        \"\"\"\n\n        if filter:\n            filter = self.__make_query_filter(filter)\n\n        if query:\n            query = \"&query=\" + quote(query)\n\n        if sort:\n            sort = \"&sort=\" + quote(sort)\n\n        if view:\n            view = \"&view=\" + quote(view)\n\n        if fields:\n            fields = \"&fields=\" + quote(fields)\n\n        if scope_uris:\n            scope_uris = \"&scopeUris=\" + quote(scope_uris)\n\n        path = uri if uri else self._uri\n        self.__validate_resource_uri(path)\n\n        symbol = '?' if '?' not in path else '&'\n\n        uri = \"{0}{1}start={2}&count={3}{4}{5}{6}{7}{8}{9}\".format(path, symbol, start, count, filter, query, sort,\n                                                                   view, fields, scope_uris)\n        return uri\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris=''):\n        \"\"\"\n        Gets all items according with the given arguments.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query:\n                A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of items matching the specified filter.\n        \"\"\"\n\n        uri = self.build_query_uri(start=start, count=count, filter=filter,\n                                   query=query, sort=sort, view=view, fields=fields, uri=uri, scope_uris=scope_uris)\n\n        logger.debug('Getting all resources with uri: {0}'.format(uri))\n\n        result = self.__do_requests_to_getall(uri, count)\n\n        return result\n\n    def delete_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes all resources from the appliance that match the provided filter.\n\n        Args:\n            filter:\n                A general filter/query string to narrow the list of items deleted.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resources were successfully deleted.\n        \"\"\"\n        uri = \"{}?filter={}&force={}\".format(self._uri, quote(filter), force)\n        logger.debug(\"Delete all resources (uri = %s)\" % uri)\n\n        task, body = self._connection.delete(uri)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        return self._task_monitor.wait_for_task(task, timeout=timeout)\n\n    def delete(self, resource, force=False, timeout=-1, custom_headers=None):\n\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        if isinstance(resource, dict):\n            if 'uri' in resource and resource['uri']:\n                uri = resource['uri']\n            else:\n                logger.exception(RESOURCE_CLIENT_UNKNOWN_OBJECT_TYPE)\n                raise exceptions.HPEOneViewUnknownType(RESOURCE_CLIENT_UNKNOWN_OBJECT_TYPE)\n        else:\n            uri = self.build_uri(resource)\n\n        if force:\n            uri += '?force=True'\n\n        logger.debug(\"Delete resource (uri = %s, resource = %s)\" %\n                     (self._uri, str(resource)))\n\n        task, body = self._connection.delete(uri, custom_headers=custom_headers)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        task = self._task_monitor.wait_for_task(task, timeout=timeout)\n\n        return task\n\n    def get_schema(self):\n        logger.debug('Get schema (uri = %s, resource = %s)' %\n                     (self._uri, self._uri))\n        return self._connection.get(self._uri + '/schema')\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Returns:\n             The requested resource.\n        \"\"\"\n        uri = self.build_uri(id_or_uri)\n        logger.debug('Get resource (uri = %s, ID = %s)' %\n                     (uri, str(id_or_uri)))\n        return self._connection.get(uri)\n\n    def get_collection(self, id_or_uri, filter=''):\n        \"\"\"\n        Retrieves a collection of resources.\n\n        Use this function when the 'start' and 'count' parameters are not allowed in the GET call.\n        Otherwise, use get_all instead.\n\n        Optional filtering criteria may be specified.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            filter (list or str): General filter/query string.\n\n        Returns:\n             Collection of the requested resource.\n        \"\"\"\n        if filter:\n            filter = self.__make_query_filter(filter)\n            filter = \"?\" + filter[1:]\n\n        uri = \"{uri}{filter}\".format(uri=self.build_uri(id_or_uri), filter=filter)\n        logger.debug('Get resource collection (uri = %s)' % uri)\n        response = self._connection.get(uri)\n        return self.__get_members(response)\n\n    def update_with_zero_body(self, uri, timeout=-1, custom_headers=None):\n        \"\"\"\n        Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n\n        return self.__do_put(uri, None, timeout, custom_headers)\n\n    def update(self, resource, uri=None, force=False, timeout=-1, custom_headers=None, default_values={}):\n        \"\"\"\n        Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            resource:\n                OneView resource dictionary.\n            uri:\n                Can be either the resource ID or the resource URI.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n            default_values:\n                Dictionary with default values grouped by OneView API version. This dictionary will be be merged with\n                the resource dictionary only if the dictionary does not contain the keys.\n                This argument is optional and the default value is an empty dictionary.\n                Ex.:\n                    default_values = {\n                        '200': {\"type\": \"logical-switch-group\"},\n                        '300': {\"type\": \"logical-switch-groupV300\"}\n                    }\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (self._uri, str(resource)))\n\n        if not uri:\n            uri = resource['uri']\n\n        if force:\n            uri += '?force=True'\n\n        resource = self.merge_default_values(resource, default_values)\n\n        return self.__do_put(uri, resource, timeout, custom_headers)\n\n    def create_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"\n        Makes a POST request to create a resource when no request body is required.\n\n        Args:\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self._uri\n\n        logger.debug('Create with zero body (uri = %s)' % uri)\n\n        return self.__do_post(uri, {}, timeout, custom_headers)\n\n    def create(self, resource, uri=None, timeout=-1, custom_headers=None, default_values={}):\n        \"\"\"\n        Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            resource:\n                OneView resource dictionary.\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n            default_values:\n                Dictionary with default values grouped by OneView API version. This dictionary will be be merged with\n                the resource dictionary only if the dictionary does not contain the keys.\n                This argument is optional and the default value is an empty dictionary.\n                Ex.:\n                    default_values = {\n                        '200': {\"type\": \"logical-switch-group\"},\n                        '300': {\"type\": \"logical-switch-groupV300\"}\n                    }\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        if not uri:\n            uri = self._uri\n\n        logger.debug('Create (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n\n        resource = self.merge_default_values(resource, default_values)\n\n        return self.__do_post(uri, resource, timeout, custom_headers)\n\n    def upload(self, file_path, uri=None, timeout=-1):\n        \"\"\"\n        Makes a multipart request.\n\n        Args:\n            file_path:\n                File to upload.\n            uri:\n                A specific URI (optional).\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Response body.\n        \"\"\"\n        if not uri:\n            uri = self._uri\n\n        upload_file_name = os.path.basename(file_path)\n        task, entity = self._connection.post_multipart_with_response_handling(uri, file_path, upload_file_name)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def patch(self, id_or_uri, operation, path, value, timeout=-1, custom_headers=None):\n        \"\"\"\n        Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        patch_request_body = [{'op': operation, 'path': path, 'value': value}]\n\n        return self.patch_request(id_or_uri=id_or_uri,\n                                  body=patch_request_body,\n                                  timeout=timeout,\n                                  custom_headers=custom_headers)\n\n    def patch_request(self, id_or_uri, body, timeout=-1, custom_headers=None):\n        \"\"\"\n        Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            body: Patch request body\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        uri = self.build_uri(id_or_uri)\n\n        logger.debug('Patch resource (uri = %s, data = %s)' % (uri, body))\n\n        custom_headers_copy = custom_headers.copy() if custom_headers else {}\n        if self._connection._apiVersion >= 300 and 'Content-Type' not in custom_headers_copy:\n            custom_headers_copy['Content-Type'] = 'application/json-patch+json'\n\n        task, entity = self._connection.patch(uri, body, custom_headers=custom_headers_copy)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def get_by(self, field, value, uri=None):\n        \"\"\"\n        This function uses get_all passing a filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n            uri: Resource uri.\n\n        Returns:\n            dict\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        if not uri:\n            uri = self._uri\n        self.__validate_resource_uri(uri)\n\n        logger.debug('Get by (uri = %s, field = %s, value = %s)' %\n                     (uri, field, str(value)))\n\n        filter = \"\\\"{0}='{1}'\\\"\".format(field, value)\n        results = self.get_all(filter=filter, uri=uri)\n\n        # Workaround when the OneView filter does not work, it will filter again\n        if \".\" not in field:\n            # This filter only work for the first level\n            results = [item for item in results if str(item.get(field, '')).lower() == value.lower()]\n\n        return results\n\n    def get_by_name(self, name):\n        \"\"\"\n        Retrieve a resource by its name.\n\n        Args:\n            name: Resource name.\n\n        Returns:\n            dict\n        \"\"\"\n        result = self.get_by('name', name)\n        if not result:\n            return None\n        else:\n            return result[0]\n\n    def get_utilization(self, id_or_uri, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"\n        Retrieves historical utilization data for the specified resource, metrics, and time span.\n\n        Args:\n            id_or_uri:\n                Resource identification\n            fields:\n                Name of the supported metric(s) to be retrieved in the format METRIC[,METRIC]...\n                If unspecified, all metrics supported are returned.\n\n            filter (list or str):\n                Filters should be in the format FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n                E.g.: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate\n                    End date of requested starting time range in ISO 8601 format. When omitted, the endDate includes\n                    the latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The\n                caller is responsible for comparing the returned sliceStartTime with the requested startTime in the\n                response. If the sliceStartTime is greater than the oldestSampleTime and the requested start time,\n                the caller is responsible for repeating the request with endTime set to sliceStartTime to obtain the\n                next segment. This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource has, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh:\n                Specifies that if necessary, an additional request will be queued to obtain the most recent\n                utilization data from the iLO. The response will not include any refreshed data. To track the\n                availability of the newly collected data, monitor the TaskResource identified by the refreshTaskUri\n                property in the response. If null, no refresh was queued.\n\n            view:\n                Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the iLO. Samples at this resolution\n                    are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict\n        \"\"\"\n\n        if not id_or_uri:\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        query = ''\n\n        if filter:\n            query += self.__make_query_filter(filter)\n\n        if fields:\n            query += \"&fields=\" + quote(fields)\n\n        if refresh:\n            query += \"&refresh=true\"\n\n        if view:\n            query += \"&view=\" + quote(view)\n\n        if query:\n            query = \"?\" + query[1:]\n\n        uri = \"{0}/utilization{1}\".format(self.build_uri(id_or_uri), query)\n\n        return self._connection.get(uri)\n\n    def create_report(self, uri, timeout=-1):\n        \"\"\"\n        Creates a report and returns the output.\n\n        Args:\n            uri: URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list:\n        \"\"\"\n        logger.debug('Creating Report')\n        task, _ = self._connection.post(uri, {})\n\n        if not task:\n            raise exceptions.HPEOneViewException(RESOURCE_CLIENT_TASK_EXPECTED)\n\n        task = self._task_monitor.get_completed_task(task, timeout)\n\n        return task['taskOutput']\n\n    def build_uri(self, id_or_uri):\n        if not id_or_uri:\n            logger.exception(RESOURCE_CLIENT_INVALID_ID)\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        if \"/\" in id_or_uri:\n            self.__validate_resource_uri(id_or_uri)\n            return id_or_uri\n        else:\n            return self._uri + \"/\" + id_or_uri\n\n    def build_subresource_uri(self, resource_id_or_uri=None, subresource_id_or_uri=None, subresource_path=''):\n        if subresource_id_or_uri and \"/\" in subresource_id_or_uri:\n            return subresource_id_or_uri\n        else:\n            if not resource_id_or_uri:\n                raise exceptions.HPEOneViewValueError(RESOURCE_ID_OR_URI_REQUIRED)\n\n            resource_uri = self.build_uri(resource_id_or_uri)\n\n            uri = \"{}/{}/{}\".format(resource_uri, subresource_path, str(subresource_id_or_uri or ''))\n            uri = uri.replace(\"//\", \"/\")\n\n            if uri.endswith(\"/\"):\n                uri = uri[:-1]\n\n            return uri\n\n    def download(self, uri, file_path):\n        \"\"\"\n        Downloads the contents of the requested URI to a stream.\n\n        Args:\n            uri: URI\n            file_path: File path destination\n\n        Returns:\n            bool: Indicates if the file was successfully downloaded.\n        \"\"\"\n        with open(file_path, 'wb') as file:\n            return self._connection.download_to_stream(\n                file,\n                uri,\n                custom_headers={\"Accept\": \"application/octetstream;q=0.8, application/json\"})\n\n    def __validate_resource_uri(self, path):\n        if self._uri not in path:\n            logger.exception('Get by uri : unrecognized uri: (%s)' % path)\n            raise exceptions.HPEOneViewUnknownType(UNRECOGNIZED_URI)\n\n    def __make_query_filter(self, filters):\n        if isinstance(filters, list):\n            formated_filter = \"&filter=\".join(quote(f) for f in filters)\n        else:\n            formated_filter = quote(filters)\n\n        return \"&filter=\" + formated_filter\n\n    def __get_members(self, mlist):\n        if mlist and 'members' in mlist and mlist['members']:\n            return mlist['members']\n        else:\n            return []\n\n    def __do_post(self, uri, resource, timeout, custom_headers):\n        task, entity = self._connection.post(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def __do_put(self, uri, resource, timeout, custom_headers):\n        task, body = self._connection.put(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return body\n\n        return self._task_monitor.wait_for_task(task, timeout)\n\n    def __do_requests_to_getall(self, uri, requested_count):\n        items = []\n\n        while uri:\n            logger.debug('Making HTTP request to get all resources. Uri: {0}'.format(uri))\n            response = self._connection.get(uri)\n            members = self.__get_members(response)\n            items += members\n\n            logger.debug(\"Response getAll: nextPageUri = {0}, members list length: {1}\".format(uri, str(len(members))))\n            uri = self.__get_next_page(response, items, requested_count)\n\n        logger.debug('Total # of members found = {0}'.format(str(len(items))))\n        return items\n\n    def __get_next_page(self, response, items, requested_count):\n        next_page_is_empty = response.get('nextPageUri') is None\n        has_different_next_page = not response.get('uri') == response.get('nextPageUri')\n        has_next_page = not next_page_is_empty and has_different_next_page\n\n        if len(items) >= requested_count and requested_count != -1:\n            return None\n\n        return response.get('nextPageUri') if has_next_page else None\n\n    def merge_default_values(self, resource, default_values):\n        if not default_values:\n            return resource\n\n        merged_resource = None\n\n        if not isinstance(resource, list):\n            api_version = str(self._connection._apiVersion)\n            data = default_values.get(api_version, {}).copy()\n            merged_resource = merge_resources(data, resource)\n\n        return merged_resource or resource",
  "def merge_resources(resource1, resource2):\n    \"\"\"\n    Updates a copy of resource1 with resource2 values and returns the merged dictionary.\n\n    Args:\n        resource1: original resource\n        resource2: resource to update resource1\n\n    Returns:\n        dict: merged resource\n    \"\"\"\n    merged = resource1.copy()\n    merged.update(resource2)\n    return merged",
  "def merge_default_values(resource_list, default_values):\n    \"\"\"\n    Generate a new list where each item of original resource_list will be merged with the default_values.\n\n    Args:\n        resource_list: list with items to be merged\n        default_values: properties to be merged with each item list. If the item already contains some property\n            the original value will be maintained.\n\n    Returns:\n        list: list containing each item merged with default_values\n    \"\"\"\n\n    def merge_item(resource):\n        return merge_resources(default_values, resource)\n\n    return lmap(merge_item, resource_list)",
  "def transform_list_to_dict(list):\n    \"\"\"\n        Transforms a list into a dictionary, putting values as keys\n    Args:\n        id:\n    Returns:\n        dict: dictionary built\n    \"\"\"\n\n    ret = {}\n\n    for value in list:\n        if isinstance(value, dict):\n            ret.update(value)\n        else:\n            ret[str(value)] = True\n\n    return ret",
  "def extract_id_from_uri(id_or_uri):\n    \"\"\"\n    Extract ID from the end of the URI\n\n    Args:\n        id_or_uri: ID or URI of the OneView resources.\n\n    Returns:\n        str: The string founded after the last \"/\"\n    \"\"\"\n    if '/' in id_or_uri:\n        return id_or_uri[id_or_uri.rindex('/') + 1:]\n    else:\n        return id_or_uri",
  "def unavailable_method():\n    \"\"\"Raise an exception if method is not available for the resource.\"\"\"\n    raise exceptions.HPEOneViewUnavailableMethod(UNAVAILABLE_METHOD)",
  "def __init__(self, method=None, update_data=False):\n        self.method = method\n        self.update_data = update_data",
  "def __get__(self, obj, objtype):\n        return partial(self.__call__, obj)",
  "def __call__(self, obj, *args, **kwargs):\n        if self.method:\n            obj.ensure_resource_data(update_data=self.update_data)\n            return self.method(obj, *args, **kwargs)\n\n        def wrap(*args, **kwargs):\n            args[0].ensure_resource_data(update_data=self.update_data)\n            return obj(*args, **kwargs)\n\n        return wrap",
  "def __init__(self, connection, data=None):\n        self._connection = connection\n        self._task_monitor = TaskMonitor(connection)\n        self._helper = ResourceHelper(self.URI,\n                                      self._connection,\n                                      self._task_monitor)\n        # Resource data\n        self.data = data if data else {}\n\n        # Merge resoure data with the default values\n        self._merge_default_values()",
  "def ensure_resource_data(self, update_data=False):\n        \"\"\"Retrieves data from OneView and updates resource object.\n\n        Args:\n            update_data: Flag to update resource data when it is required.\n        \"\"\"\n        # Check for unique identifier in the resource data\n        if not any(key in self.data for key in self.UNIQUE_IDENTIFIERS):\n            raise exceptions.HPEOneViewMissingUniqueIdentifiers(MISSING_UNIQUE_IDENTIFIERS)\n\n        # Returns if data update is not required\n        if not update_data:\n            return\n\n        resource_data = None\n\n        if 'uri' in self.UNIQUE_IDENTIFIERS and self.data.get('uri'):\n            resource_data = self._helper.do_get(self.data['uri'])\n        else:\n            for identifier in self.UNIQUE_IDENTIFIERS:\n                identifier_value = self.data.get(identifier)\n\n                if identifier_value:\n                    result = self.get_by(identifier, identifier_value)\n                    if result and isinstance(result, list):\n                        resource_data = result[0]\n                        break\n\n        if resource_data:\n            self.data.update(resource_data)\n        else:\n            raise exceptions.HPEOneViewResourceNotFound(RESOURCE_DOES_NOT_EXIST)",
  "def refresh(self):\n        \"\"\"Helps to get the latest resource data from the server.\"\"\"\n        self.data = self._helper.do_get(self.data[\"uri\"])",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"Gets all items according with the given arguments.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n\n        Returns:\n            list: A list of items matching the specified filter.\n        \"\"\"\n        result = self._helper.get_all(start=start, count=count, filter=filter, sort=sort)\n        return result",
  "def create(self, data=None, uri=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        data = self._helper.update_resource_fields(data, default_values)\n\n        logger.debug('Create (uri = %s, resource = %s)' % (uri, str(data)))\n        resource_data = self._helper.create(data, uri, timeout, custom_headers, force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource",
  "def delete(self, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Deletes current resource.\n\n        Args:\n            timeout: Timeout in seconds.\n            custom_headers: Allows to set custom http headers.\n            force: Flag to force the operation.\n        \"\"\"\n        uri = self.data['uri']\n\n        logger.debug(\"Delete resource (uri = %s)\" % (str(uri)))\n\n        return self._helper.delete(uri, timeout=timeout,\n                                   custom_headers=custom_headers, force=force)",
  "def update(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n\n        self.data = self._helper.update(resource, uri, force, timeout, custom_headers)\n\n        return self",
  "def get_by(self, field, value):\n        \"\"\"Get the resource by passing a field and its value.\n\n        Note:\n            This function uses get_all passing a filter.The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            dict\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        filter = \"\\\"{0}='{1}'\\\"\".format(field, value)\n        results = self.get_all(filter=filter)\n\n        # Workaround when the OneView filter does not work, it will filter again\n        if \".\" not in field:\n            # This filter only work for the first level\n            results = [item for item in results if str(item.get(field, \"\")).lower() == value.lower()]\n        return results",
  "def get_by_name(self, name):\n        \"\"\"Retrieves a resource by its name.\n\n        Args:\n            name: Resource name.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        result = self.get_by(\"name\", name)\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource",
  "def get_by_field(self, field, value):\n        \"\"\"Retrieves a resource by its field.\n\n        Args:\n            field: Resource field name.\n            value: Resource field value.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        results = self.get_all()\n\n        # This filter only work for the first level\n        result = [item for item in results if value.lower() in str(\n            item.get(field, \"\")).lower()]\n\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource",
  "def get_by_uri(self, uri):\n        \"\"\"Retrieves a resource by its URI\n\n        Args:\n            uri: URI of the resource\n\n        Returns:\n            Resource object\n        \"\"\"\n        self._helper.validate_resource_uri(uri)\n        data = self._helper.do_get(uri)\n\n        if data:\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n\n        return new_resource",
  "def get_by_id(self, id):\n        \"\"\"Retrieves a resource by its id.\n\n        Args:\n            id: id of Resource\n\n        Returns:\n            Resource object or None if resource does not exist.\n\n        \"\"\"\n\n        uri = \"{}/{}\".format(self.URI, id)\n        self._helper.validate_resource_uri(uri)\n        data = self._helper.do_get(uri)\n\n        if data:\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n\n        return new_resource",
  "def _get_default_values(self, default_values=None):\n        \"\"\"Gets the default values set for a resource\"\"\"\n\n        if not default_values:\n            default_values = self.DEFAULT_VALUES\n\n        if default_values:\n            api_version = str(self._connection._apiVersion)\n            values = default_values.get(api_version, {}).copy()\n        else:\n            values = {}\n\n        return values",
  "def _merge_default_values(self):\n        \"\"\"Merge default values with resource data.\"\"\"\n        values = self._get_default_values()\n        for key, value in values.items():\n            if not self.data.get(key):\n                self.data[key] = value",
  "def new(cls, connection, data):\n        \"\"\"Returns a new resource object\"\"\"\n        return cls(connection, data)",
  "def __init__(self, base_uri, connection, task_monitor):\n        self._base_uri = base_uri\n        self._connection = connection\n        self._task_monitor = task_monitor",
  "def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris='', custom_headers=None,\n                name_prefix='', category=[], childLimit=0, topCount=0,):\n        \"\"\"Gets all items according with the given arguments.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query: A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            custom_headers: custom headers\n\n        Returns:\n             list: A list of items matching the specified filter.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        uri = self.build_query_uri(uri=uri,\n                                   start=start,\n                                   count=count,\n                                   filter=filter,\n                                   query=query,\n                                   sort=sort,\n                                   view=view,\n                                   fields=fields,\n                                   scope_uris=scope_uris,\n                                   name_prefix=name_prefix,\n                                   category=category,\n                                   childLimit=childLimit,\n                                   topCount=topCount)\n\n        logger.debug('Getting all resources with uri: {0}'.format(uri))\n\n        return self.do_requests_to_getall(uri, count, custom_headers=custom_headers)",
  "def delete_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes all resources from the appliance that match the provided filter.\n\n        Args:\n            filter:\n                A general filter/query string to narrow the list of items deleted.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resources were successfully deleted.\n        \"\"\"\n        uri = \"{}?filter={}&force={}\".format(self._base_uri, quote(filter), force)\n        logger.debug(\"Delete all resources (uri = %s)\" % uri)\n\n        return self.delete(uri)",
  "def create(self, data=None, uri=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        if force:\n            uri += '?force={}'.format(force)\n\n        logger.debug('Create (uri = %s, resource = %s)' % (uri, str(data)))\n        return self.do_post(uri, data, timeout, custom_headers)",
  "def delete(self, uri, force=False, timeout=-1, custom_headers=None):\n        \"\"\"Deletes current resource.\n\n        Args:\n            force: Flag to delete the resource forcefully, default is False.\n            timeout: Timeout in seconds.\n            custom_headers: Allows to set custom http headers.\n        \"\"\"\n        if force:\n            uri += '?force=True'\n\n        logger.debug(\"Delete resource (uri = %s)\" % (str(uri)))\n\n        task, body = self._connection.delete(uri, custom_headers=custom_headers)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        task = self._task_monitor.wait_for_task(task, timeout=timeout)\n\n        return task",
  "def update(self, resource, uri=None, force=False, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            resource: Data to update the resource.\n            uri: Resource uri\n            force: If set to true, the operation completes despite any problems\n                with network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n        if not uri:\n            uri = resource['uri']\n\n        if force:\n            uri += '?force=True'\n\n        return self.do_put(uri, resource, timeout, custom_headers)",
  "def update_with_zero_body(self, uri, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri: Allows to use a different URI other than resource URI\n            timeout: Timeout in seconds. Wait for task completion by default.\n                The timeout does not abort the operation in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to set custom HTTP headers.\n\n        Returns:\n            A dict with updated resource data.\n        \"\"\"\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n\n        return self.do_put(uri, None, timeout, custom_headers)",
  "def create_report(self, uri, timeout=-1):\n        \"\"\"\n        Creates a report and returns the output.\n\n        Args:\n            uri: URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list:\n        \"\"\"\n        logger.debug('Creating Report')\n        task, _ = self._connection.post(uri, {})\n\n        if not task:\n            raise exceptions.HPEOneViewException(RESOURCE_CLIENT_TASK_EXPECTED)\n\n        task = self._task_monitor.get_completed_task(task, timeout)\n\n        return task['taskOutput']",
  "def get_collection(self, uri=None, filter='', path=''):\n        \"\"\"Retrieves a collection of resources.\n\n        Use this function when the 'start' and 'count' parameters are not allowed in the GET call.\n        Otherwise, use get_all instead.\n\n        Optional filtering criteria may be specified.\n\n        Args:\n            filter (list or str): General filter/query string.\n            path (str): path to be added with base URI\n\n        Returns:\n             Collection of the requested resource.\n        \"\"\"\n        if not uri:\n            uri = self._base_uri\n\n        if filter:\n            filter = self.make_query_filter(filter)\n            filter = \"?\" + filter[1:]\n\n        uri = \"{uri}{path}{filter}\".format(uri=uri, path=path, filter=filter)\n        logger.debug('Get resource collection (uri = %s)' % uri)\n\n        response = self._connection.get(uri)\n\n        return self.get_members(response)",
  "def build_query_uri(self, uri=None, start=0, count=-1, filter='', query='', sort='', view='', fields='', scope_uris='',\n                        name_prefix='', category=[], childLimit=0, topCount=0):\n        \"\"\"Builds the URI from given parameters.\n\n        More than one request can be send to get the items, regardless the query parameter 'count', because the actual\n        number of items in the response might differ from the requested count. Some types of resource have a limited\n        number of items returned on each call. For those resources, additional calls are made to the API to retrieve\n        any other items matching the given filter. The actual number of items can also differ from the requested call\n        if the requested number of items would take too long.\n\n        The use of optional parameters for OneView 2.0 is described at:\n        http://h17007.www1.hpe.com/docs/enterprise/servers/oneview2.0/cic-api/en/api-docs/current/index.html\n\n        Note:\n            Single quote - \"'\" - inside a query parameter is not supported by OneView API.\n\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query: A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view: Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields: Name of the fields.\n            uri: A specific URI (optional)\n            scope_uris: An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            name_prefix: Filters the resource returned by the given prefix.\n\n        Returns:\n            uri: The complete uri\n        \"\"\"\n        if filter:\n            filter = self.make_query_filter(filter)\n\n        if query:\n            query = \"&query=\" + quote(query)\n\n        if sort:\n            sort = \"&sort=\" + quote(sort)\n\n        if view:\n            view = \"&view=\" + quote(view)\n\n        if fields:\n            fields = \"&fields=\" + quote(fields)\n\n        if scope_uris:\n            scope_uris = \"&scopeUris=\" + quote(scope_uris)\n\n        if name_prefix:\n            name_prefix = \"&namePrefix=\" + quote(name_prefix)\n\n        categories = ''\n        if category:\n            for cat in category:\n                categories = categories + \"&category=\" + quote(cat)\n\n        if childLimit:\n            childLimit = \"&childLimit=\" + str(childLimit)\n\n        if topCount:\n            topCount = \"&topCount=\" + str(topCount)\n\n        path = uri if uri else self._base_uri\n\n        self.validate_resource_uri(path)\n\n        symbol = '?' if '?' not in path else '&'\n\n        uri = \"{0}{1}start={2}&count={3}{4}{5}{6}{7}{8}{9}{10}{11}\".format(path, symbol, start, count, filter, query, sort,\n                                                                           view, fields, scope_uris, name_prefix, categories)\n        return uri",
  "def build_uri_with_query_string(self, kwargs, sufix_path='', uri=None):\n        if not uri:\n            uri = self._base_uri\n\n        query_string = '&'.join('{}={}'.format(key, kwargs[key]) for key in sorted(kwargs))\n        return uri + sufix_path + '?' + query_string",
  "def build_uri(self, id_or_uri):\n        \"\"\"Helps to build the URI from resource id and validate the URI.\n\n        Args:\n            id_or_uri: ID/URI of the resource.\n\n        Returns:\n            Returns a valid resource URI\n        \"\"\"\n        if not id_or_uri:\n            logger.exception(RESOURCE_CLIENT_INVALID_ID)\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        if \"/\" in id_or_uri:\n            self.validate_resource_uri(id_or_uri)\n            return id_or_uri\n        else:\n            return self._base_uri + \"/\" + id_or_uri",
  "def build_subresource_uri(self, resource_id_or_uri=None, subresource_id_or_uri=None, subresource_path=''):\n        \"\"\"Helps to build a URI with resource path and its sub resource path.\n\n        Args:\n            resoure_id_or_uri: ID/URI of the main resource.\n            subresource_id__or_uri: ID/URI of the sub resource.\n            subresource_path: Sub resource path to be added with the URI.\n\n        Returns:\n            Returns URI\n        \"\"\"\n        if subresource_id_or_uri and \"/\" in subresource_id_or_uri:\n            return subresource_id_or_uri\n        else:\n            if not resource_id_or_uri:\n                raise exceptions.HPEOneViewValueError(RESOURCE_ID_OR_URI_REQUIRED)\n\n            resource_uri = self.build_uri(resource_id_or_uri)\n\n            uri = \"{}/{}/{}\".format(resource_uri, subresource_path, str(subresource_id_or_uri or ''))\n            uri = uri.replace(\"//\", \"/\")\n\n            if uri.endswith(\"/\"):\n                uri = uri[:-1]\n\n            return uri",
  "def validate_resource_uri(self, path):\n        \"\"\"Helper method to validate URI of the resource.\"\"\"\n        if self._base_uri not in path:\n            logger.exception('Get by uri : unrecognized uri: (%s)' % path)\n            raise exceptions.HPEOneViewUnknownType(UNRECOGNIZED_URI)",
  "def make_query_filter(self, filters):\n        \"\"\"Helper method to build filter query parameter.\"\"\"\n        if isinstance(filters, list):\n            formated_filter = \"&filter=\".join(quote(f) for f in filters)\n        else:\n            formated_filter = quote(filters)\n\n        return \"&filter=\" + formated_filter",
  "def get_members(self, mlist):\n        \"\"\"Get members from list of resources\"\"\"\n        if mlist and mlist.get('members'):\n            return mlist['members']\n        else:\n            return []",
  "def update_resource_fields(self, data, data_to_add):\n        \"\"\"Update resource data with new fields.\n\n        Args:\n            data: resource data\n            data_to_update: dict of data to update resource data\n\n        Returnes:\n            Returnes dict\n        \"\"\"\n        for key, value in data_to_add.items():\n            if not data.get(key):\n                data[key] = value\n\n        return data",
  "def do_requests_to_getall(self, uri, requested_count, custom_headers=None):\n        \"\"\"Helps to make http request for get_all method.\n\n        Note:\n            This method will be checking for the pagination URI in the response\n            and make request to pagination URI to get all the resources.\n        \"\"\"\n        items = []\n        while uri:\n            logger.debug('Making HTTP request to get all resources. Uri: {0}'.format(uri))\n            response = self._connection.get(uri, custom_headers=custom_headers)\n            members = self.get_members(response)\n            items += members\n\n            logger.debug(\"Response getAll: nextPageUri = {0}, members list length: {1}\".format(uri, str(len(members))))\n            uri = self.get_next_page(response, items, requested_count)\n\n        logger.debug('Total # of members found = {0}'.format(str(len(items))))\n        return items",
  "def get_next_page(self, response, items, requested_count):\n        \"\"\"Returns next page URI.\"\"\"\n        next_page_is_empty = response.get('nextPageUri') is None\n        has_different_next_page = not response.get('uri') == response.get('nextPageUri')\n        has_next_page = not next_page_is_empty and has_different_next_page\n\n        if len(items) >= requested_count and requested_count != -1:\n            return None\n\n        return response.get('nextPageUri') if has_next_page else None",
  "def do_get(self, uri):\n        \"\"\"Helps to make get requests\n\n        Args:\n            uri: URI of the resource\n\n        Returns:\n            Returns: Returns the resource data\n        \"\"\"\n        self.validate_resource_uri(uri)\n        return self._connection.get(uri)",
  "def do_post(self, uri, resource, timeout, custom_headers):\n        \"\"\"Helps to make post requests.\n\n        Args:\n            uri: URI of  the resource.\n            resource: Resource data to post.\n            timeout: Time out for the request in seconds.\n            cutom_headers: Allows to add custom http headers.\n\n        Returns:\n            Retunrs Task object.\n        \"\"\"\n        self.validate_resource_uri(uri)\n        task, entity = self._connection.post(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def do_put(self, uri, resource, timeout, custom_headers):\n        \"\"\"Helps to make put requests.\n\n        Args:\n            uri: URI of the resource\n            timeout: Time out for the request in seconds.\n            custom_headers: Allows to set custom http headers.\n\n        Retuns:\n            Returns Task object\n        \"\"\"\n        self.validate_resource_uri(uri)\n\n        task, body = self._connection.put(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return body\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def add_new_fields(data, data_to_add):\n        \"\"\"Update resource data with new fields.\n\n        Args:\n            data: resource data\n            data_to_update: dict of data to update resource data\n\n        Returnes:\n            Returnes dict\n        \"\"\"\n        for key, value in data_to_add.items():\n            if not data.get(key):\n                data[key] = value\n\n        return data",
  "def patch(self, operation, path, value, custom_headers=None, timeout=-1):\n        \"\"\"Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom http headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        patch_request_body = [{'op': operation, 'path': path, 'value': value}]\n        resource_uri = self.data['uri']\n\n        self.data = self.patch_request(resource_uri,\n                                       body=patch_request_body,\n                                       custom_headers=custom_headers,\n                                       timeout=timeout)\n        return self",
  "def patch_request(self, uri, body, custom_headers=None, timeout=-1):\n        \"\"\"Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            body (list): Patch request body\n            timeout (int): Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers (dict): Allows to add custom http headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        logger.debug('Patch resource (uri = %s, data = %s)' % (uri, body))\n\n        if not custom_headers:\n            custom_headers = {}\n\n        if self._connection._apiVersion >= 300 and 'Content-Type' not in custom_headers:\n            custom_headers['Content-Type'] = 'application/json-patch+json'\n\n        task, entity = self._connection.patch(uri, body, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def upload(self, file_path, uri=None, timeout=-1):\n        \"\"\"Makes a multipart request.\n\n        Args:\n            file_path: File to upload.\n            uri: A specific URI (optional).\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Response body.\n        \"\"\"\n        if not uri:\n            uri = self.URI\n\n        upload_file_name = os.path.basename(file_path)\n        task, entity = self._connection.post_multipart_with_response_handling(uri, file_path, upload_file_name)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def download(self, uri, file_path):\n        \"\"\"Downloads the contents of the requested URI to a stream.\n\n        Args:\n            uri: URI\n            file_path: File path destination\n\n        Returns:\n            bool: Indicates if the file was successfully downloaded.\n        \"\"\"\n        with open(file_path, 'wb') as file:\n            return self._connection.download_to_stream(file, uri)",
  "def get_utilization(self, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"Retrieves historical utilization data for the specified resource, metrics, and time span.\n\n        Args:\n            fields: Name of the supported metric(s) to be retrieved in the format METRIC[,METRIC]...\n                If unspecified, all metrics supported are returned.\n\n            filter (list or str): Filters should be in the format FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n                E.g.: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate\n                    End date of requested starting time range in ISO 8601 format. When omitted, the endDate includes\n                    the latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The\n                caller is responsible for comparing the returned sliceStartTime with the requested startTime in the\n                response. If the sliceStartTime is greater than the oldestSampleTime and the requested start time,\n                the caller is responsible for repeating the request with endTime set to sliceStartTime to obtain the\n                next segment. This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource has, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh: Specifies that if necessary, an additional request will be queued to obtain the most recent\n                utilization data from the iLO. The response will not include any refreshed data. To track the\n                availability of the newly collected data, monitor the TaskResource identified by the refreshTaskUri\n                property in the response. If null, no refresh was queued.\n\n            view: Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the iLO. Samples at this resolution\n                    are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict\n        \"\"\"\n        resource_uri = self.data['uri']\n        query = ''\n\n        if filter:\n            query += self._helper.make_query_filter(filter)\n\n        if fields:\n            query += \"&fields=\" + quote(fields)\n\n        if refresh:\n            query += \"&refresh=true\"\n\n        if view:\n            query += \"&view=\" + quote(view)\n\n        if query:\n            query = \"?\" + query[1:]\n\n        uri = \"{0}/utilization{1}\".format(self._helper.build_uri(resource_uri), query)\n\n        return self._helper.do_get(uri)",
  "def get_schema(self):\n        \"\"\"Supports schema requests.\n\n        Returns:\n            A dict with the schema.\n        \"\"\"\n        return self._helper.do_get(self.URI + '/schema')",
  "def create_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"Makes a POST request to create a resource when no request body is required.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self.URI\n\n        logger.debug('Create with zero body (uri = %s)' % uri)\n        resource_data = self._helper.do_post(uri, {}, timeout, custom_headers)\n\n        return resource_data",
  "def update_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri: Allows to use a different URI other than resource URI\n            timeout: Timeout in seconds. Wait for task completion by default.\n                The timeout does not abort the operation in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to set custom HTTP headers.\n\n        Returns:\n            A dict with updated resource data.\n        \"\"\"\n        if not uri:\n            uri = self.data['uri']\n\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n        resource_data = self._helper.do_put(uri, None, timeout, custom_headers)\n\n        return resource_data",
  "def __init__(self, con, uri):\n        self._connection = con\n        self._uri = uri\n        self._task_monitor = TaskMonitor(con)",
  "def build_query_uri(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris=''):\n        \"\"\"\n        Builds the URI given the parameters.\n\n        More than one request can be send to get the items, regardless the query parameter 'count', because the actual\n        number of items in the response might differ from the requested count. Some types of resource have a limited\n        number of items returned on each call. For those resources, additional calls are made to the API to retrieve\n        any other items matching the given filter. The actual number of items can also differ from the requested call\n        if the requested number of items would take too long.\n\n        The use of optional parameters for OneView 2.0 is described at:\n        http://h17007.www1.hpe.com/docs/enterprise/servers/oneview2.0/cic-api/en/api-docs/current/index.html\n\n        Note:\n            Single quote - \"'\" - inside a query parameter is not supported by OneView API.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query:\n                A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            uri: The complete uri\n        \"\"\"\n\n        if filter:\n            filter = self.__make_query_filter(filter)\n\n        if query:\n            query = \"&query=\" + quote(query)\n\n        if sort:\n            sort = \"&sort=\" + quote(sort)\n\n        if view:\n            view = \"&view=\" + quote(view)\n\n        if fields:\n            fields = \"&fields=\" + quote(fields)\n\n        if scope_uris:\n            scope_uris = \"&scopeUris=\" + quote(scope_uris)\n\n        path = uri if uri else self._uri\n        self.__validate_resource_uri(path)\n\n        symbol = '?' if '?' not in path else '&'\n\n        uri = \"{0}{1}start={2}&count={3}{4}{5}{6}{7}{8}{9}\".format(path, symbol, start, count, filter, query, sort,\n                                                                   view, fields, scope_uris)\n        return uri",
  "def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields='', uri=None, scope_uris=''):\n        \"\"\"\n        Gets all items according with the given arguments.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items (default).\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The default is no\n                filter; all resources are returned.\n            query:\n                A single query parameter can do what would take multiple parameters or multiple GET requests using\n                filter. Use query for more complex queries. NOTE: This parameter is experimental for OneView 2.0.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n            uri:\n                A specific URI (optional)\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of items matching the specified filter.\n        \"\"\"\n\n        uri = self.build_query_uri(start=start, count=count, filter=filter,\n                                   query=query, sort=sort, view=view, fields=fields, uri=uri, scope_uris=scope_uris)\n\n        logger.debug('Getting all resources with uri: {0}'.format(uri))\n\n        result = self.__do_requests_to_getall(uri, count)\n\n        return result",
  "def delete_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes all resources from the appliance that match the provided filter.\n\n        Args:\n            filter:\n                A general filter/query string to narrow the list of items deleted.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resources were successfully deleted.\n        \"\"\"\n        uri = \"{}?filter={}&force={}\".format(self._uri, quote(filter), force)\n        logger.debug(\"Delete all resources (uri = %s)\" % uri)\n\n        task, body = self._connection.delete(uri)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        return self._task_monitor.wait_for_task(task, timeout=timeout)",
  "def delete(self, resource, force=False, timeout=-1, custom_headers=None):\n\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        if isinstance(resource, dict):\n            if 'uri' in resource and resource['uri']:\n                uri = resource['uri']\n            else:\n                logger.exception(RESOURCE_CLIENT_UNKNOWN_OBJECT_TYPE)\n                raise exceptions.HPEOneViewUnknownType(RESOURCE_CLIENT_UNKNOWN_OBJECT_TYPE)\n        else:\n            uri = self.build_uri(resource)\n\n        if force:\n            uri += '?force=True'\n\n        logger.debug(\"Delete resource (uri = %s, resource = %s)\" %\n                     (self._uri, str(resource)))\n\n        task, body = self._connection.delete(uri, custom_headers=custom_headers)\n\n        if not task:\n            # 204 NO CONTENT\n            # Successful return from a synchronous delete operation.\n            return True\n\n        task = self._task_monitor.wait_for_task(task, timeout=timeout)\n\n        return task",
  "def get_schema(self):\n        logger.debug('Get schema (uri = %s, resource = %s)' %\n                     (self._uri, self._uri))\n        return self._connection.get(self._uri + '/schema')",
  "def get(self, id_or_uri):\n        \"\"\"\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Returns:\n             The requested resource.\n        \"\"\"\n        uri = self.build_uri(id_or_uri)\n        logger.debug('Get resource (uri = %s, ID = %s)' %\n                     (uri, str(id_or_uri)))\n        return self._connection.get(uri)",
  "def get_collection(self, id_or_uri, filter=''):\n        \"\"\"\n        Retrieves a collection of resources.\n\n        Use this function when the 'start' and 'count' parameters are not allowed in the GET call.\n        Otherwise, use get_all instead.\n\n        Optional filtering criteria may be specified.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            filter (list or str): General filter/query string.\n\n        Returns:\n             Collection of the requested resource.\n        \"\"\"\n        if filter:\n            filter = self.__make_query_filter(filter)\n            filter = \"?\" + filter[1:]\n\n        uri = \"{uri}{filter}\".format(uri=self.build_uri(id_or_uri), filter=filter)\n        logger.debug('Get resource collection (uri = %s)' % uri)\n        response = self._connection.get(uri)\n        return self.__get_members(response)",
  "def update_with_zero_body(self, uri, timeout=-1, custom_headers=None):\n        \"\"\"\n        Makes a PUT request to update a resource when no request body is required.\n\n        Args:\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        logger.debug('Update with zero length body (uri = %s)' % uri)\n\n        return self.__do_put(uri, None, timeout, custom_headers)",
  "def update(self, resource, uri=None, force=False, timeout=-1, custom_headers=None, default_values={}):\n        \"\"\"\n        Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            resource:\n                OneView resource dictionary.\n            uri:\n                Can be either the resource ID or the resource URI.\n            force:\n                If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n            default_values:\n                Dictionary with default values grouped by OneView API version. This dictionary will be be merged with\n                the resource dictionary only if the dictionary does not contain the keys.\n                This argument is optional and the default value is an empty dictionary.\n                Ex.:\n                    default_values = {\n                        '200': {\"type\": \"logical-switch-group\"},\n                        '300': {\"type\": \"logical-switch-groupV300\"}\n                    }\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        logger.debug('Update async (uri = %s, resource = %s)' %\n                     (self._uri, str(resource)))\n\n        if not uri:\n            uri = resource['uri']\n\n        if force:\n            uri += '?force=True'\n\n        resource = self.merge_default_values(resource, default_values)\n\n        return self.__do_put(uri, resource, timeout, custom_headers)",
  "def create_with_zero_body(self, uri=None, timeout=-1, custom_headers=None):\n        \"\"\"\n        Makes a POST request to create a resource when no request body is required.\n\n        Args:\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not uri:\n            uri = self._uri\n\n        logger.debug('Create with zero body (uri = %s)' % uri)\n\n        return self.__do_post(uri, {}, timeout, custom_headers)",
  "def create(self, resource, uri=None, timeout=-1, custom_headers=None, default_values={}):\n        \"\"\"\n        Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            resource:\n                OneView resource dictionary.\n            uri:\n                Can be either the resource ID or the resource URI.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers:\n                Allows set specific HTTP headers.\n            default_values:\n                Dictionary with default values grouped by OneView API version. This dictionary will be be merged with\n                the resource dictionary only if the dictionary does not contain the keys.\n                This argument is optional and the default value is an empty dictionary.\n                Ex.:\n                    default_values = {\n                        '200': {\"type\": \"logical-switch-group\"},\n                        '300': {\"type\": \"logical-switch-groupV300\"}\n                    }\n\n        Returns:\n            Created resource.\n        \"\"\"\n        if not resource:\n            logger.exception(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n            raise ValueError(RESOURCE_CLIENT_RESOURCE_WAS_NOT_PROVIDED)\n\n        if not uri:\n            uri = self._uri\n\n        logger.debug('Create (uri = %s, resource = %s)' %\n                     (uri, str(resource)))\n\n        resource = self.merge_default_values(resource, default_values)\n\n        return self.__do_post(uri, resource, timeout, custom_headers)",
  "def upload(self, file_path, uri=None, timeout=-1):\n        \"\"\"\n        Makes a multipart request.\n\n        Args:\n            file_path:\n                File to upload.\n            uri:\n                A specific URI (optional).\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Response body.\n        \"\"\"\n        if not uri:\n            uri = self._uri\n\n        upload_file_name = os.path.basename(file_path)\n        task, entity = self._connection.post_multipart_with_response_handling(uri, file_path, upload_file_name)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def patch(self, id_or_uri, operation, path, value, timeout=-1, custom_headers=None):\n        \"\"\"\n        Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        patch_request_body = [{'op': operation, 'path': path, 'value': value}]\n\n        return self.patch_request(id_or_uri=id_or_uri,\n                                  body=patch_request_body,\n                                  timeout=timeout,\n                                  custom_headers=custom_headers)",
  "def patch_request(self, id_or_uri, body, timeout=-1, custom_headers=None):\n        \"\"\"\n        Uses the PATCH to update a resource.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            body: Patch request body\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Updated resource.\n        \"\"\"\n        uri = self.build_uri(id_or_uri)\n\n        logger.debug('Patch resource (uri = %s, data = %s)' % (uri, body))\n\n        custom_headers_copy = custom_headers.copy() if custom_headers else {}\n        if self._connection._apiVersion >= 300 and 'Content-Type' not in custom_headers_copy:\n            custom_headers_copy['Content-Type'] = 'application/json-patch+json'\n\n        task, entity = self._connection.patch(uri, body, custom_headers=custom_headers_copy)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def get_by(self, field, value, uri=None):\n        \"\"\"\n        This function uses get_all passing a filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n            uri: Resource uri.\n\n        Returns:\n            dict\n        \"\"\"\n        if not field:\n            logger.exception(RESOURCE_CLIENT_INVALID_FIELD)\n            raise ValueError(RESOURCE_CLIENT_INVALID_FIELD)\n\n        if not uri:\n            uri = self._uri\n        self.__validate_resource_uri(uri)\n\n        logger.debug('Get by (uri = %s, field = %s, value = %s)' %\n                     (uri, field, str(value)))\n\n        filter = \"\\\"{0}='{1}'\\\"\".format(field, value)\n        results = self.get_all(filter=filter, uri=uri)\n\n        # Workaround when the OneView filter does not work, it will filter again\n        if \".\" not in field:\n            # This filter only work for the first level\n            results = [item for item in results if str(item.get(field, '')).lower() == value.lower()]\n\n        return results",
  "def get_by_name(self, name):\n        \"\"\"\n        Retrieve a resource by its name.\n\n        Args:\n            name: Resource name.\n\n        Returns:\n            dict\n        \"\"\"\n        result = self.get_by('name', name)\n        if not result:\n            return None\n        else:\n            return result[0]",
  "def get_utilization(self, id_or_uri, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"\n        Retrieves historical utilization data for the specified resource, metrics, and time span.\n\n        Args:\n            id_or_uri:\n                Resource identification\n            fields:\n                Name of the supported metric(s) to be retrieved in the format METRIC[,METRIC]...\n                If unspecified, all metrics supported are returned.\n\n            filter (list or str):\n                Filters should be in the format FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n                E.g.: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate\n                    End date of requested starting time range in ISO 8601 format. When omitted, the endDate includes\n                    the latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The\n                caller is responsible for comparing the returned sliceStartTime with the requested startTime in the\n                response. If the sliceStartTime is greater than the oldestSampleTime and the requested start time,\n                the caller is responsible for repeating the request with endTime set to sliceStartTime to obtain the\n                next segment. This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource has, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh:\n                Specifies that if necessary, an additional request will be queued to obtain the most recent\n                utilization data from the iLO. The response will not include any refreshed data. To track the\n                availability of the newly collected data, monitor the TaskResource identified by the refreshTaskUri\n                property in the response. If null, no refresh was queued.\n\n            view:\n                Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the iLO. Samples at this resolution\n                    are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict\n        \"\"\"\n\n        if not id_or_uri:\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        query = ''\n\n        if filter:\n            query += self.__make_query_filter(filter)\n\n        if fields:\n            query += \"&fields=\" + quote(fields)\n\n        if refresh:\n            query += \"&refresh=true\"\n\n        if view:\n            query += \"&view=\" + quote(view)\n\n        if query:\n            query = \"?\" + query[1:]\n\n        uri = \"{0}/utilization{1}\".format(self.build_uri(id_or_uri), query)\n\n        return self._connection.get(uri)",
  "def create_report(self, uri, timeout=-1):\n        \"\"\"\n        Creates a report and returns the output.\n\n        Args:\n            uri: URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list:\n        \"\"\"\n        logger.debug('Creating Report')\n        task, _ = self._connection.post(uri, {})\n\n        if not task:\n            raise exceptions.HPEOneViewException(RESOURCE_CLIENT_TASK_EXPECTED)\n\n        task = self._task_monitor.get_completed_task(task, timeout)\n\n        return task['taskOutput']",
  "def build_uri(self, id_or_uri):\n        if not id_or_uri:\n            logger.exception(RESOURCE_CLIENT_INVALID_ID)\n            raise ValueError(RESOURCE_CLIENT_INVALID_ID)\n\n        if \"/\" in id_or_uri:\n            self.__validate_resource_uri(id_or_uri)\n            return id_or_uri\n        else:\n            return self._uri + \"/\" + id_or_uri",
  "def build_subresource_uri(self, resource_id_or_uri=None, subresource_id_or_uri=None, subresource_path=''):\n        if subresource_id_or_uri and \"/\" in subresource_id_or_uri:\n            return subresource_id_or_uri\n        else:\n            if not resource_id_or_uri:\n                raise exceptions.HPEOneViewValueError(RESOURCE_ID_OR_URI_REQUIRED)\n\n            resource_uri = self.build_uri(resource_id_or_uri)\n\n            uri = \"{}/{}/{}\".format(resource_uri, subresource_path, str(subresource_id_or_uri or ''))\n            uri = uri.replace(\"//\", \"/\")\n\n            if uri.endswith(\"/\"):\n                uri = uri[:-1]\n\n            return uri",
  "def download(self, uri, file_path):\n        \"\"\"\n        Downloads the contents of the requested URI to a stream.\n\n        Args:\n            uri: URI\n            file_path: File path destination\n\n        Returns:\n            bool: Indicates if the file was successfully downloaded.\n        \"\"\"\n        with open(file_path, 'wb') as file:\n            return self._connection.download_to_stream(\n                file,\n                uri,\n                custom_headers={\"Accept\": \"application/octetstream;q=0.8, application/json\"})",
  "def __validate_resource_uri(self, path):\n        if self._uri not in path:\n            logger.exception('Get by uri : unrecognized uri: (%s)' % path)\n            raise exceptions.HPEOneViewUnknownType(UNRECOGNIZED_URI)",
  "def __make_query_filter(self, filters):\n        if isinstance(filters, list):\n            formated_filter = \"&filter=\".join(quote(f) for f in filters)\n        else:\n            formated_filter = quote(filters)\n\n        return \"&filter=\" + formated_filter",
  "def __get_members(self, mlist):\n        if mlist and 'members' in mlist and mlist['members']:\n            return mlist['members']\n        else:\n            return []",
  "def __do_post(self, uri, resource, timeout, custom_headers):\n        task, entity = self._connection.post(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return entity\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def __do_put(self, uri, resource, timeout, custom_headers):\n        task, body = self._connection.put(uri, resource, custom_headers=custom_headers)\n\n        if not task:\n            return body\n\n        return self._task_monitor.wait_for_task(task, timeout)",
  "def __do_requests_to_getall(self, uri, requested_count):\n        items = []\n\n        while uri:\n            logger.debug('Making HTTP request to get all resources. Uri: {0}'.format(uri))\n            response = self._connection.get(uri)\n            members = self.__get_members(response)\n            items += members\n\n            logger.debug(\"Response getAll: nextPageUri = {0}, members list length: {1}\".format(uri, str(len(members))))\n            uri = self.__get_next_page(response, items, requested_count)\n\n        logger.debug('Total # of members found = {0}'.format(str(len(items))))\n        return items",
  "def __get_next_page(self, response, items, requested_count):\n        next_page_is_empty = response.get('nextPageUri') is None\n        has_different_next_page = not response.get('uri') == response.get('nextPageUri')\n        has_next_page = not next_page_is_empty and has_different_next_page\n\n        if len(items) >= requested_count and requested_count != -1:\n            return None\n\n        return response.get('nextPageUri') if has_next_page else None",
  "def merge_default_values(self, resource, default_values):\n        if not default_values:\n            return resource\n\n        merged_resource = None\n\n        if not isinstance(resource, list):\n            api_version = str(self._connection._apiVersion)\n            data = default_values.get(api_version, {}).copy()\n            merged_resource = merge_resources(data, resource)\n\n        return merged_resource or resource",
  "def merge_item(resource):\n        return merge_resources(default_values, resource)",
  "def wrap(*args, **kwargs):\n            args[0].ensure_resource_data(update_data=self.update_data)\n            return obj(*args, **kwargs)",
  "class UnmanagedDevices(object):\n    URI = '/rest/unmanaged-devices'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of unmanaged device resources according to the specified parameters. Filters can be used to get a\n        specific set of unmanaged devices. With no filters specified, the API returns a potentially paginated list of\n        all the unmanaged device resources subject to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n             list: Unmanaged Devices\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a single Unmanaged Device resource based upon its uri or id.\n\n        Args:\n            id_or_uri:\n                Can be either the Unmanaged Device id or the uri\n\n        Returns:\n            dict: The Unmanaged Device\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds an unmanaged device resource based upon the attributes specified. Use this method to create an unmanaged\n        device to represent resources that consume space within a rack, or consume power from a power delivery device\n        but cannot otherwise be represented by the management appliance.\n\n        Args:\n            information:\n                Unmanaged Device information\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added Unmanaged Device\n        \"\"\"\n        return self._client.create(information, timeout=timeout)\n\n    def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified.\n\n        Args:\n            resource:\n                 Dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def remove_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of unmanaged-devices according to the specified parameters. A filter is required to identify\n        the set of resources to be deleted.\n\n        Args:\n            filter:\n                 A general filter/query string to narrow the list of items that will be removed.\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete_all(filter=filter, force=force, timeout=timeout)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the resource for the specified. The properties that are omitted (not included as part of the the\n        request body) are reset to their respective default values. The id and uuid properties are required and cannot\n        be changed.\n\n        Args:\n            resource (dict): Object to update\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated Unmanaged Devices\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)\n\n    def get_environmental_configuration(self, id_or_uri):\n        \"\"\"\n        Returns a description of the environmental configuration (supported feature set, calibrated minimum & maximum\n        power, location & dimensions, ...) of the resource.\n\n        Args:\n            id_or_uri:\n                Can be either the Unmanaged Device id or the uri\n\n        Returns:\n            dict:\n                EnvironmentalConfiguration\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/environmentalConfiguration\"\n        return self._client.get(uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all Unmanaged Devices that match the filter\n        The search is case-insensitive\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            dict: Unmanaged Devices\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of unmanaged device resources according to the specified parameters. Filters can be used to get a\n        specific set of unmanaged devices. With no filters specified, the API returns a potentially paginated list of\n        all the unmanaged device resources subject to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n             list: Unmanaged Devices\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a single Unmanaged Device resource based upon its uri or id.\n\n        Args:\n            id_or_uri:\n                Can be either the Unmanaged Device id or the uri\n\n        Returns:\n            dict: The Unmanaged Device\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds an unmanaged device resource based upon the attributes specified. Use this method to create an unmanaged\n        device to represent resources that consume space within a rack, or consume power from a power delivery device\n        but cannot otherwise be represented by the management appliance.\n\n        Args:\n            information:\n                Unmanaged Device information\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added Unmanaged Device\n        \"\"\"\n        return self._client.create(information, timeout=timeout)",
  "def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified.\n\n        Args:\n            resource:\n                 Dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def remove_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of unmanaged-devices according to the specified parameters. A filter is required to identify\n        the set of resources to be deleted.\n\n        Args:\n            filter:\n                 A general filter/query string to narrow the list of items that will be removed.\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete_all(filter=filter, force=force, timeout=timeout)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the resource for the specified. The properties that are omitted (not included as part of the the\n        request body) are reset to their respective default values. The id and uuid properties are required and cannot\n        be changed.\n\n        Args:\n            resource (dict): Object to update\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated Unmanaged Devices\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "def get_environmental_configuration(self, id_or_uri):\n        \"\"\"\n        Returns a description of the environmental configuration (supported feature set, calibrated minimum & maximum\n        power, location & dimensions, ...) of the resource.\n\n        Args:\n            id_or_uri:\n                Can be either the Unmanaged Device id or the uri\n\n        Returns:\n            dict:\n                EnvironmentalConfiguration\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/environmentalConfiguration\"\n        return self._client.get(uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all Unmanaged Devices that match the filter\n        The search is case-insensitive\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            dict: Unmanaged Devices\n        \"\"\"\n        return self._client.get_by(field, value)",
  "class EthernetNetworks(ResourcePatchMixin, Resource):\n    \"\"\"\n    Ethernet Networks API client.\n\n    \"\"\"\n    URI = '/rest/ethernet-networks'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"ethernet-networkV3\"},\n        '300': {\"type\": \"ethernet-networkV300\"},\n        '500': {\"type\": \"ethernet-networkV300\"},\n        '600': {\"type\": \"ethernet-networkV4\"},\n        '800': {\"type\": \"ethernet-networkV4\"},\n        '1000': {\"type\": \"ethernet-networkV4\"},\n        '1200': {\"type\": \"ethernet-networkV4\"},\n        '1600': {\"type\": \"ethernet-networkV4\"},\n        '1800': {\"type\": \"ethernet-networkV4\"}\n\n    }\n    BULK_DEFAULT_VALUES = {\n        '200': {\"type\": \"bulk-ethernet-network\"},\n        '300': {\"type\": \"bulk-ethernet-network\"},\n        '500': {\"type\": \"bulk-ethernet-network\"},\n        '600': {\"type\": \"bulk-ethernet-networkV1\"},\n        '800': {\"type\": \"bulk-ethernet-networkV1\"},\n        '1000': {\"type\": \"bulk-ethernet-networkV1\"},\n        '1200': {\"type\": \"bulk-ethernet-networkV2\"},\n        '1600': {\"type\": \"bulk-ethernet-networkV2\"},\n        '1800': {\"type\": \"bulk-ethernet-networkV2\"}\n\n    }\n\n    def __init__(self, connection, data=None):\n        super(EthernetNetworks, self).__init__(connection, data)\n\n    def create_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Creates bulk Ethernet networks.\n\n        Args:\n            resource (dict): Specifications to create in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list: List of created Ethernet Networks.\n\n        \"\"\"\n        uri = self.URI + '/bulk'\n        default_values = self._get_default_values(self.BULK_DEFAULT_VALUES)\n        updated_data = self._helper.update_resource_fields(resource, default_values)\n\n        self._helper.create(updated_data, uri=uri, timeout=timeout)\n\n        return self.get_range(resource['namePrefix'], resource['vlanIdRange'])\n\n    def get_range(self, name_prefix, vlan_id_range):\n        \"\"\"\n        Gets a list of Ethernet Networks that match the 'given name_prefix' and the 'vlan_id_range'.\n\n        Examples:\n            >>> enet.get_range('Enet_name', '1-2,5')\n                # The result contains the ethernet network with names:\n                ['Enet_name_1', 'Enet_name_2', 'Enet_name_5']\n\n            >>> enet.get_range('Enet_name', '2')\n                # The result contains the ethernet network with names:\n                ['Enet_name_1', 'Enet_name_2']\n\n        Args:\n            name_prefix: The Ethernet Network prefix\n            vlan_id_range: A combination of values or ranges to be retrieved. For example, '1-10,50,51,500-700'.\n\n        Returns:\n            list: A list of Ethernet Networks.\n\n        \"\"\"\n        filter = '\"\\'name\\' matches \\'{}\\_%\\'\"'.format(name_prefix)\n        ethernet_networks = self.get_all(filter=filter, sort='vlanId:ascending')\n\n        vlan_ids = self.dissociate_values_or_ranges(vlan_id_range)\n\n        for net in ethernet_networks[:]:\n            if int(net['vlanId']) not in vlan_ids:\n                ethernet_networks.remove(net)\n        return ethernet_networks\n\n    def dissociate_values_or_ranges(self, vlan_id_range):\n        \"\"\"\n        Build a list of vlan ids given a combination of ranges and/or values\n\n        Examples:\n            >>> enet.dissociate_values_or_ranges('1-2,5')\n                [1, 2, 5]\n\n            >>> enet.dissociate_values_or_ranges('5')\n                [1, 2, 3, 4, 5]\n\n            >>> enet.dissociate_values_or_ranges('4-5,7-8')\n                [4, 5, 7, 8]\n\n        Args:\n            vlan_id_range: A combination of values or ranges. For example, '1-10,50,51,500-700'.\n\n        Returns:\n            list: vlan ids\n        \"\"\"\n        values_or_ranges = vlan_id_range.split(',')\n        vlan_ids = []\n        # The expected result is different if the vlan_id_range contains only one value\n        if len(values_or_ranges) == 1 and '-' not in values_or_ranges[0]:\n            vlan_ids = list(range(1, int(values_or_ranges[0]) + 1))\n        else:\n            for value_or_range in values_or_ranges:\n                value_or_range.strip()\n                if '-' not in value_or_range:\n                    vlan_ids.append(int(value_or_range))\n                else:\n                    start, end = value_or_range.split('-')\n                    range_ids = range(int(start), int(end) + 1)\n                    vlan_ids.extend(range_ids)\n\n        return vlan_ids\n\n    @ensure_resource_client\n    def get_associated_profiles(self):\n        \"\"\"\n        Gets the URIs of profiles which are using an Ethernet network.\n\n        Args:\n            id_or_uri: Can be either the logical interconnect group id or the logical interconnect group uri\n\n        Returns:\n            list: URIs of the associated profiles.\n\n        \"\"\"\n        uri = \"{}/associatedProfiles\".format(self.data['uri'])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_associated_uplink_groups(self):\n        \"\"\"\n        Gets the uplink sets which are using an Ethernet network.\n\n        Returns:\n            list: URIs of the associated uplink sets.\n\n        \"\"\"\n        uri = \"{}/associatedUplinkGroups\".format(self.data['uri'])\n        return self._helper.do_get(uri)\n\n    def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk Ethernet networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(EthernetNetworks, self).__init__(connection, data)",
  "def create_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Creates bulk Ethernet networks.\n\n        Args:\n            resource (dict): Specifications to create in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            list: List of created Ethernet Networks.\n\n        \"\"\"\n        uri = self.URI + '/bulk'\n        default_values = self._get_default_values(self.BULK_DEFAULT_VALUES)\n        updated_data = self._helper.update_resource_fields(resource, default_values)\n\n        self._helper.create(updated_data, uri=uri, timeout=timeout)\n\n        return self.get_range(resource['namePrefix'], resource['vlanIdRange'])",
  "def get_range(self, name_prefix, vlan_id_range):\n        \"\"\"\n        Gets a list of Ethernet Networks that match the 'given name_prefix' and the 'vlan_id_range'.\n\n        Examples:\n            >>> enet.get_range('Enet_name', '1-2,5')\n                # The result contains the ethernet network with names:\n                ['Enet_name_1', 'Enet_name_2', 'Enet_name_5']\n\n            >>> enet.get_range('Enet_name', '2')\n                # The result contains the ethernet network with names:\n                ['Enet_name_1', 'Enet_name_2']\n\n        Args:\n            name_prefix: The Ethernet Network prefix\n            vlan_id_range: A combination of values or ranges to be retrieved. For example, '1-10,50,51,500-700'.\n\n        Returns:\n            list: A list of Ethernet Networks.\n\n        \"\"\"\n        filter = '\"\\'name\\' matches \\'{}\\_%\\'\"'.format(name_prefix)\n        ethernet_networks = self.get_all(filter=filter, sort='vlanId:ascending')\n\n        vlan_ids = self.dissociate_values_or_ranges(vlan_id_range)\n\n        for net in ethernet_networks[:]:\n            if int(net['vlanId']) not in vlan_ids:\n                ethernet_networks.remove(net)\n        return ethernet_networks",
  "def dissociate_values_or_ranges(self, vlan_id_range):\n        \"\"\"\n        Build a list of vlan ids given a combination of ranges and/or values\n\n        Examples:\n            >>> enet.dissociate_values_or_ranges('1-2,5')\n                [1, 2, 5]\n\n            >>> enet.dissociate_values_or_ranges('5')\n                [1, 2, 3, 4, 5]\n\n            >>> enet.dissociate_values_or_ranges('4-5,7-8')\n                [4, 5, 7, 8]\n\n        Args:\n            vlan_id_range: A combination of values or ranges. For example, '1-10,50,51,500-700'.\n\n        Returns:\n            list: vlan ids\n        \"\"\"\n        values_or_ranges = vlan_id_range.split(',')\n        vlan_ids = []\n        # The expected result is different if the vlan_id_range contains only one value\n        if len(values_or_ranges) == 1 and '-' not in values_or_ranges[0]:\n            vlan_ids = list(range(1, int(values_or_ranges[0]) + 1))\n        else:\n            for value_or_range in values_or_ranges:\n                value_or_range.strip()\n                if '-' not in value_or_range:\n                    vlan_ids.append(int(value_or_range))\n                else:\n                    start, end = value_or_range.split('-')\n                    range_ids = range(int(start), int(end) + 1)\n                    vlan_ids.extend(range_ids)\n\n        return vlan_ids",
  "def get_associated_profiles(self):\n        \"\"\"\n        Gets the URIs of profiles which are using an Ethernet network.\n\n        Args:\n            id_or_uri: Can be either the logical interconnect group id or the logical interconnect group uri\n\n        Returns:\n            list: URIs of the associated profiles.\n\n        \"\"\"\n        uri = \"{}/associatedProfiles\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def get_associated_uplink_groups(self):\n        \"\"\"\n        Gets the uplink sets which are using an Ethernet network.\n\n        Returns:\n            list: URIs of the associated uplink sets.\n\n        \"\"\"\n        uri = \"{}/associatedUplinkGroups\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk Ethernet networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "class Switches(object):\n    \"\"\"\n    Switches API client.\n\n    Note:\n        This resource is only available on C7000 enclosures.\n\n    \"\"\"\n    URI = '/rest/switches'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_statistics(self, id_or_uri, port_name=''):\n        \"\"\"\n        Gets statistics for a switch.\n\n        Args:\n            id_or_uri: Can be either the switch id or the switch uri.\n            port_name: switch port number (optional)\n\n        Returns:\n            dict\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/statistics\"\n\n        if port_name:\n            uri += \"/\" + port_name\n\n        return self._client.get(uri)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of top of rack switches.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of rack switches.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a switch by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the switch ID or URI.\n\n        Returns:\n            dict: Switch\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes a migrated switch.\n\n        Args:\n            resource (dict): Object to delete.\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def get_environmental_configuration(self, id_or_uri):\n        \"\"\"\n        Gets the environmental configuration for a switch.\n\n        Args:\n            id_or_uri: Can be either the resource ID or URI.\n\n        Returns:\n            dict: environmental configuration\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/environmentalConfiguration\"\n        return self._client.get(uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all switches that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            list: A list of rack switches.\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def update_ports(self, ports, id_or_uri):\n        \"\"\"\n        Updates the switch ports. Only the ports under the management of OneView and those that are unlinked are\n        supported for update.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            ports: List of Switch Ports.\n            id_or_uri: Can be either the switch id or the switch uri.\n\n        Returns:\n            dict: Switch\n        \"\"\"\n        ports = merge_default_values(ports, {'type': 'port'})\n\n        uri = self._client.build_uri(id_or_uri) + \"/update-ports\"\n        return self._client.update(uri=uri, resource=ports)\n\n    def patch(self, id_or_uri, operation, path, value, timeout=-1):\n        \"\"\"\n        Uses the PATCH to update a resource for a given logical switch.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        return self._client.patch(id_or_uri, operation, path, value, timeout=timeout)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_statistics(self, id_or_uri, port_name=''):\n        \"\"\"\n        Gets statistics for a switch.\n\n        Args:\n            id_or_uri: Can be either the switch id or the switch uri.\n            port_name: switch port number (optional)\n\n        Returns:\n            dict\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/statistics\"\n\n        if port_name:\n            uri += \"/\" + port_name\n\n        return self._client.get(uri)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of top of rack switches.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of rack switches.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a switch by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the switch ID or URI.\n\n        Returns:\n            dict: Switch\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes a migrated switch.\n\n        Args:\n            resource (dict): Object to delete.\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def get_environmental_configuration(self, id_or_uri):\n        \"\"\"\n        Gets the environmental configuration for a switch.\n\n        Args:\n            id_or_uri: Can be either the resource ID or URI.\n\n        Returns:\n            dict: environmental configuration\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/environmentalConfiguration\"\n        return self._client.get(uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all switches that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            list: A list of rack switches.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def update_ports(self, ports, id_or_uri):\n        \"\"\"\n        Updates the switch ports. Only the ports under the management of OneView and those that are unlinked are\n        supported for update.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            ports: List of Switch Ports.\n            id_or_uri: Can be either the switch id or the switch uri.\n\n        Returns:\n            dict: Switch\n        \"\"\"\n        ports = merge_default_values(ports, {'type': 'port'})\n\n        uri = self._client.build_uri(id_or_uri) + \"/update-ports\"\n        return self._client.update(uri=uri, resource=ports)",
  "def patch(self, id_or_uri, operation, path, value, timeout=-1):\n        \"\"\"\n        Uses the PATCH to update a resource for a given logical switch.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        return self._client.patch(id_or_uri, operation, path, value, timeout=timeout)",
  "class LogicalInterconnects(ResourcePatchMixin, Resource):\n    \"\"\"\n    Logical Interconnects API client.\n\n    \"\"\"\n    URI = '/rest/logical-interconnects'\n    FIRMWARE_PATH = \"/firmware\"\n    SNMP_CONFIGURATION_PATH = \"/snmp-configuration\"\n    PORT_MONITOR_PATH = \"/port-monitor\"\n    FORWARDING_INFORMATION_PATH = \"/forwarding-information-base\"\n    QOS_AGGREGATED_CONFIGURATION = \"/qos-aggregated-configuration\"\n\n    SETTINGS_DEFAULT_VALUES = {\n        '200': {\"type\": \"InterconnectSettingsV3\"},\n        '300': {\"type\": \"InterconnectSettingsV201\"},\n        '500': {\"type\": \"InterconnectSettingsV201\"},\n    }\n\n    SETTINGS_ETHERNET_DEFAULT_VALUES = {\n        '200': {\"type\": \"EthernetInterconnectSettingsV3\"},\n        '300': {\"type\": \"EthernetInterconnectSettingsV201\"},\n        '500': {\"type\": \"EthernetInterconnectSettingsV201\"},\n        '600': {\"type\": \"EthernetInterconnectSettingsV4\"},\n        '800': {\"type\": \"EthernetInterconnectSettingsV4\"},\n        '1000': {'type': \"EthernetInterconnectSettingsV5\"},\n        '1200': {'type': \"EthernetInterconnectSettingsV6\"},\n        '1400': {'type': \"EthernetInterconnectSettingsV7\"},\n        '1600': {'type': \"EthernetInterconnectSettingsV7\"},\n        '1800': {'type': \"EthernetInterconnectSettingsV7\"}\n    }\n\n    SETTINGS_TELEMETRY_CONFIG_DEFAULT_VALUES = {\n        '200': {\"type\": \"telemetry-configuration\"},\n        '300': {\"type\": \"telemetry-configuration\"},\n        '500': {\"type\": \"telemetry-configuration\"},\n        '600': {\"type\": \"telemetry-configuration\"},\n        '800': {\"type\": \"telemetry-configuration\"},\n        '1000': {\"type\": \"telemetry-configuration\"},\n        '1200': {\"type\": \"telemetry-configuration\"},\n        '1400': {\"type\": \"telemetry-configuration\"},\n        '1600': {\"type\": \"telemetry-configuration\"},\n        '1800': {\"type\": \"telemetry-configuration\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(LogicalInterconnects, self).__init__(connection, data)\n\n    def create(self):\n        \"\"\"Create method is not available for this resource\"\"\"\n        unavailable_method()\n\n    def update(self):\n        \"\"\"Update method is not available for this resource\"\"\"\n        unavailable_method()\n\n    def delete(self):\n        \"\"\"Delete method is not available for this resource\"\"\"\n        unavailable_method()\n\n    def get_all(self, start=0, count=-1, sort=''):\n        \"\"\"\n        Gets a list of logical interconnects based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of logical interconnects.\n        \"\"\"\n        return self._helper.get_all(start, count, sort=sort)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Gets a logical interconnect by name.\n\n        Args:\n            name: Name of the logical interconnect.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        logical_interconnects = self.get_all()\n        result = [x for x in logical_interconnects if x['name'] == name]\n        resource = result[0] if result else None\n\n        if resource:\n            resource = self.new(self._connection, resource)\n\n        return resource\n\n    @ensure_resource_client\n    def update_compliance(self, timeout=-1):\n        \"\"\"\n        Returns logical interconnects to a consistent state. The current logical interconnect state is\n        compared to the associated logical interconnect group.\n\n        Any differences identified are corrected, bringing the logical interconnect back to a consistent\n        state. Changes are asynchronously applied to all managed interconnects. Note that if the changes detected\n        involve differences in the interconnect map between the logical interconnect group and the logical interconnect,\n        the process of bringing the logical interconnect back to a consistent state might involve automatically removing\n        existing interconnects from management and/or adding new interconnects for management.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/compliance\".format(self.data[\"uri\"])\n        return self._helper.update(None, uri, timeout=timeout)\n\n    @ensure_resource_client\n    def update_ethernet_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the Ethernet interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Ethernet interconnect settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/ethernetSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def update_internal_networks(self, network_uri_list, force=False, timeout=-1):\n        \"\"\"\n        Updates internal networks on the logical interconnect.\n\n        Args:\n            network_uri_list: List of Ethernet network uris.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/internalNetworks\".format(self.data[\"uri\"])\n        return self._helper.update(network_uri_list, uri=uri, force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def get_internal_vlans(self):\n        \"\"\"\n        Gets the internal VLAN IDs for the provisioned networks on a logical interconnect.\n\n        Returns:\n            dict: Collection of URIs\n\n        \"\"\"\n        uri = \"{}/internalVlans\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)\n\n    @ensure_resource_client\n    def update_settings(self, settings, force=False, timeout=-1):\n        \"\"\"\n        Updates interconnect settings on the logical interconnect. Changes to interconnect settings are asynchronously\n        applied to all managed interconnects.\n        (This method is not available from API version 600 onwards)\n        Args:\n            settings: Interconnect settings\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect\n        \"\"\"\n        data = settings.copy()\n\n        if 'ethernetSettings' in data:\n            ethernet_default_values = self._get_default_values(self.SETTINGS_ETHERNET_DEFAULT_VALUES)\n            data['ethernetSettings'] = merge_resources(data['ethernetSettings'],\n                                                       ethernet_default_values)\n\n        uri = \"{}/settings\".format(self.data[\"uri\"])\n        default_values = self._get_default_values(self.SETTINGS_DEFAULT_VALUES)\n        data = self._helper.update_resource_fields(data, default_values)\n\n        return self._helper.update(data, uri=uri, force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def update_configuration(self, timeout=-1):\n        \"\"\"\n        Asynchronously applies or re-applies the logical interconnect configuration to all managed interconnects.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        return self._helper.update(None, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_snmp_configuration(self):\n        \"\"\"\n        Gets the SNMP configuration for a logical interconnect.\n\n        Returns:\n            dict: SNMP configuration.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.SNMP_CONFIGURATION_PATH)\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_snmp_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Updates the SNMP configuration of a logical interconnect. Changes to the SNMP configuration are asynchronously\n        applied to all managed interconnects.\n\n        Args:\n            configuration: snmp configuration.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        data = configuration.copy()\n        if 'type' not in data:\n            data['type'] = 'snmp-configuration'\n\n        uri = \"{}{}\".format(self.data[\"uri\"], self.SNMP_CONFIGURATION_PATH)\n        return self._helper.update(data, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_unassigned_ports(self):\n        \"\"\"\n        Gets the collection ports from the member interconnects\n        which are eligible for assignment to an anlyzer port\n\n        Returns:\n            dict: Collection of ports\n        \"\"\"\n        uri = \"{}/unassignedPortsForPortMonitor\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)\n\n    @ensure_resource_client\n    def get_unassigned_uplink_ports(self):\n        \"\"\"\n        Gets a collection of uplink ports from the member interconnects which are eligible for assignment to an\n        analyzer port. To be eligible, a port must be a valid uplink, must not be a member of an existing uplink set,\n        and must not currently be used for stacking.\n\n        Returns:\n            dict: Collection of uplink ports.\n        \"\"\"\n        uri = \"{}/unassignedUplinkPortsForPortMonitor\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)\n\n    @ensure_resource_client\n    def get_port_monitor(self):\n        \"\"\"\n        Gets the port monitor configuration of a logical interconnect.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.PORT_MONITOR_PATH)\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_port_monitor(self, resource, timeout=-1):\n        \"\"\"\n        Updates the port monitor configuration of a logical interconnect.\n\n        Args:\n            resource: Port monitor configuration.\n\n        Returns:\n            dict: Port monitor configuration.\n        \"\"\"\n        data = resource.copy()\n        if 'type' not in data:\n            data['type'] = 'port-monitor'\n\n        uri = \"{}{}\".format(self.data[\"uri\"], self.PORT_MONITOR_PATH)\n        return self._helper.update(data, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_firmware(self):\n        \"\"\"\n        Gets the installed firmware for a logical interconnect.\n\n        Returns:\n            dict: LIFirmware.\n        \"\"\"\n        firmware_uri = self._helper.build_subresource_uri(self.data[\"uri\"], subresource_path=self.FIRMWARE_PATH)\n        return self._helper.do_get(firmware_uri)\n\n    @ensure_resource_client\n    def install_firmware(self, firmware_information):\n        \"\"\"\n        Installs firmware to a logical interconnect. The three operations that are supported for the firmware\n        update are Stage (uploads firmware to the interconnect), Activate (installs firmware on the interconnect),\n        and Update (which does a Stage and Activate in a sequential manner).\n\n        Args:\n            firmware_information: Options to install firmware to a logical interconnect.\n\n        Returns:\n            dict\n        \"\"\"\n        firmware_uri = self._helper.build_subresource_uri(self.data[\"uri\"], subresource_path=self.FIRMWARE_PATH)\n        return self._helper.update(firmware_information, firmware_uri)\n\n    @ensure_resource_client\n    def get_forwarding_information_base(self, filter=''):\n        \"\"\"\n        Gets the forwarding information base data for a logical interconnect. A maximum of 100 entries is returned.\n        Optional filtering criteria might be specified.\n\n        Args:\n            filter (list or str):\n                Filtering criteria may be specified using supported attributes: interconnectUri, macAddress,\n                internalVlan, externalVlan, and supported relation = (Equals). macAddress is 12 hexadecimal digits with\n                a colon between each pair of digits (upper case or lower case).\n                The default is no filter; all resources are returned.\n\n        Returns:\n            list: A set of interconnect MAC address entries.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.FORWARDING_INFORMATION_PATH)\n        return self._helper.get_collection(uri, filter=filter)\n\n    @ensure_resource_client\n    def create_forwarding_information_base(self, timeout=-1):\n        \"\"\"\n        Generates the forwarding information base dump file for a logical interconnect.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: Interconnect Forwarding Information Base DataInfo.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.FORWARDING_INFORMATION_PATH)\n        return self._helper.do_post(uri, None, timeout, None)\n\n    @ensure_resource_client\n    def get_qos_aggregated_configuration(self):\n        \"\"\"\n        Gets the QoS aggregated configuration for the logical interconnect.\n\n        Returns:\n            dict: QoS Configuration.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.QOS_AGGREGATED_CONFIGURATION)\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_qos_aggregated_configuration(self, qos_configuration, timeout=-1):\n        \"\"\"\n        Updates the QoS aggregated configuration for the logical interconnect.\n\n        Args:\n            qos_configuration:\n                QOS configuration.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.QOS_AGGREGATED_CONFIGURATION)\n        return self._helper.update(qos_configuration, uri=uri, timeout=timeout)\n\n    def _get_telemetry_configuration_uri(self):\n        telemetry_conf = self.data.get(\"telemetryConfiguration\", {})\n        if not telemetry_conf.get(\"uri\"):\n            raise HPEOneViewResourceNotFound(\"Telemetry configuration uri is not available\")\n        return telemetry_conf[\"uri\"]\n\n    @ensure_resource_client\n    def get_telemetry_configuration(self):\n        \"\"\"\n        Gets the telemetry configuration of a logical interconnect.\n\n        Returns:\n            dict: Telemetry configuration.\n\n        \"\"\"\n        telemetry_conf_uri = self._get_telemetry_configuration_uri()\n        return self._helper.do_get(telemetry_conf_uri)\n\n    @ensure_resource_client\n    def update_telemetry_configurations(self, configuration, timeout=-1):\n        \"\"\"\n        Updates the telemetry configuration of a logical interconnect. Changes to the telemetry configuration are\n        asynchronously applied to all managed interconnects.\n\n        Args:\n            configuration:\n                The telemetry configuration for the logical interconnect.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        telemetry_conf_uri = self._get_telemetry_configuration_uri()\n        default_values = self._get_default_values(self.SETTINGS_TELEMETRY_CONFIG_DEFAULT_VALUES)\n        configuration = self._helper.update_resource_fields(configuration, default_values)\n\n        return self._helper.update(configuration, uri=telemetry_conf_uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_ethernet_settings(self):\n        \"\"\"\n        Gets the Ethernet interconnect settings for the Logical Interconnect.\n\n        Returns:\n            dict: Ethernet Interconnect Settings\n        \"\"\"\n        uri = \"{}/ethernetSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_igmp_settings(self):\n        \"\"\"\n        Gets the Igmp settings for the Logical Interconnect.\n\n        Returns:\n            dict: Ethernet Igmp Settings\n        \"\"\"\n        uri = \"{}/igmpSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_igmp_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the Igmp interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Igmp interconnect settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/igmpSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def bulk_inconsistency_validate(self, validation_request, timeout=-1):\n        \"\"\"\n        Validates the bulk update from group operation and gets the consolidated inconsistency report\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: Consolidated inconsistency report.\n        \"\"\"\n        uri = \"{}/bulk-inconsistency-validation\".format(self.URI)\n        return self._helper.do_post(uri, validation_request, timeout, None)\n\n    @ensure_resource_client\n    def update_port_flap_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the port flap interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Port flap settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/portFlapSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(LogicalInterconnects, self).__init__(connection, data)",
  "def create(self):\n        \"\"\"Create method is not available for this resource\"\"\"\n        unavailable_method()",
  "def update(self):\n        \"\"\"Update method is not available for this resource\"\"\"\n        unavailable_method()",
  "def delete(self):\n        \"\"\"Delete method is not available for this resource\"\"\"\n        unavailable_method()",
  "def get_all(self, start=0, count=-1, sort=''):\n        \"\"\"\n        Gets a list of logical interconnects based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of logical interconnects.\n        \"\"\"\n        return self._helper.get_all(start, count, sort=sort)",
  "def get_by_name(self, name):\n        \"\"\"\n        Gets a logical interconnect by name.\n\n        Args:\n            name: Name of the logical interconnect.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        logical_interconnects = self.get_all()\n        result = [x for x in logical_interconnects if x['name'] == name]\n        resource = result[0] if result else None\n\n        if resource:\n            resource = self.new(self._connection, resource)\n\n        return resource",
  "def update_compliance(self, timeout=-1):\n        \"\"\"\n        Returns logical interconnects to a consistent state. The current logical interconnect state is\n        compared to the associated logical interconnect group.\n\n        Any differences identified are corrected, bringing the logical interconnect back to a consistent\n        state. Changes are asynchronously applied to all managed interconnects. Note that if the changes detected\n        involve differences in the interconnect map between the logical interconnect group and the logical interconnect,\n        the process of bringing the logical interconnect back to a consistent state might involve automatically removing\n        existing interconnects from management and/or adding new interconnects for management.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/compliance\".format(self.data[\"uri\"])\n        return self._helper.update(None, uri, timeout=timeout)",
  "def update_ethernet_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the Ethernet interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Ethernet interconnect settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/ethernetSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)",
  "def update_internal_networks(self, network_uri_list, force=False, timeout=-1):\n        \"\"\"\n        Updates internal networks on the logical interconnect.\n\n        Args:\n            network_uri_list: List of Ethernet network uris.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/internalNetworks\".format(self.data[\"uri\"])\n        return self._helper.update(network_uri_list, uri=uri, force=force, timeout=timeout)",
  "def get_internal_vlans(self):\n        \"\"\"\n        Gets the internal VLAN IDs for the provisioned networks on a logical interconnect.\n\n        Returns:\n            dict: Collection of URIs\n\n        \"\"\"\n        uri = \"{}/internalVlans\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)",
  "def update_settings(self, settings, force=False, timeout=-1):\n        \"\"\"\n        Updates interconnect settings on the logical interconnect. Changes to interconnect settings are asynchronously\n        applied to all managed interconnects.\n        (This method is not available from API version 600 onwards)\n        Args:\n            settings: Interconnect settings\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect\n        \"\"\"\n        data = settings.copy()\n\n        if 'ethernetSettings' in data:\n            ethernet_default_values = self._get_default_values(self.SETTINGS_ETHERNET_DEFAULT_VALUES)\n            data['ethernetSettings'] = merge_resources(data['ethernetSettings'],\n                                                       ethernet_default_values)\n\n        uri = \"{}/settings\".format(self.data[\"uri\"])\n        default_values = self._get_default_values(self.SETTINGS_DEFAULT_VALUES)\n        data = self._helper.update_resource_fields(data, default_values)\n\n        return self._helper.update(data, uri=uri, force=force, timeout=timeout)",
  "def update_configuration(self, timeout=-1):\n        \"\"\"\n        Asynchronously applies or re-applies the logical interconnect configuration to all managed interconnects.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        return self._helper.update(None, uri=uri, timeout=timeout)",
  "def get_snmp_configuration(self):\n        \"\"\"\n        Gets the SNMP configuration for a logical interconnect.\n\n        Returns:\n            dict: SNMP configuration.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.SNMP_CONFIGURATION_PATH)\n        return self._helper.do_get(uri)",
  "def update_snmp_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Updates the SNMP configuration of a logical interconnect. Changes to the SNMP configuration are asynchronously\n        applied to all managed interconnects.\n\n        Args:\n            configuration: snmp configuration.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        data = configuration.copy()\n        if 'type' not in data:\n            data['type'] = 'snmp-configuration'\n\n        uri = \"{}{}\".format(self.data[\"uri\"], self.SNMP_CONFIGURATION_PATH)\n        return self._helper.update(data, uri=uri, timeout=timeout)",
  "def get_unassigned_ports(self):\n        \"\"\"\n        Gets the collection ports from the member interconnects\n        which are eligible for assignment to an anlyzer port\n\n        Returns:\n            dict: Collection of ports\n        \"\"\"\n        uri = \"{}/unassignedPortsForPortMonitor\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)",
  "def get_unassigned_uplink_ports(self):\n        \"\"\"\n        Gets a collection of uplink ports from the member interconnects which are eligible for assignment to an\n        analyzer port. To be eligible, a port must be a valid uplink, must not be a member of an existing uplink set,\n        and must not currently be used for stacking.\n\n        Returns:\n            dict: Collection of uplink ports.\n        \"\"\"\n        uri = \"{}/unassignedUplinkPortsForPortMonitor\".format(self.data[\"uri\"])\n        response = self._helper.do_get(uri)\n\n        return self._helper.get_members(response)",
  "def get_port_monitor(self):\n        \"\"\"\n        Gets the port monitor configuration of a logical interconnect.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.PORT_MONITOR_PATH)\n        return self._helper.do_get(uri)",
  "def update_port_monitor(self, resource, timeout=-1):\n        \"\"\"\n        Updates the port monitor configuration of a logical interconnect.\n\n        Args:\n            resource: Port monitor configuration.\n\n        Returns:\n            dict: Port monitor configuration.\n        \"\"\"\n        data = resource.copy()\n        if 'type' not in data:\n            data['type'] = 'port-monitor'\n\n        uri = \"{}{}\".format(self.data[\"uri\"], self.PORT_MONITOR_PATH)\n        return self._helper.update(data, uri=uri, timeout=timeout)",
  "def get_firmware(self):\n        \"\"\"\n        Gets the installed firmware for a logical interconnect.\n\n        Returns:\n            dict: LIFirmware.\n        \"\"\"\n        firmware_uri = self._helper.build_subresource_uri(self.data[\"uri\"], subresource_path=self.FIRMWARE_PATH)\n        return self._helper.do_get(firmware_uri)",
  "def install_firmware(self, firmware_information):\n        \"\"\"\n        Installs firmware to a logical interconnect. The three operations that are supported for the firmware\n        update are Stage (uploads firmware to the interconnect), Activate (installs firmware on the interconnect),\n        and Update (which does a Stage and Activate in a sequential manner).\n\n        Args:\n            firmware_information: Options to install firmware to a logical interconnect.\n\n        Returns:\n            dict\n        \"\"\"\n        firmware_uri = self._helper.build_subresource_uri(self.data[\"uri\"], subresource_path=self.FIRMWARE_PATH)\n        return self._helper.update(firmware_information, firmware_uri)",
  "def get_forwarding_information_base(self, filter=''):\n        \"\"\"\n        Gets the forwarding information base data for a logical interconnect. A maximum of 100 entries is returned.\n        Optional filtering criteria might be specified.\n\n        Args:\n            filter (list or str):\n                Filtering criteria may be specified using supported attributes: interconnectUri, macAddress,\n                internalVlan, externalVlan, and supported relation = (Equals). macAddress is 12 hexadecimal digits with\n                a colon between each pair of digits (upper case or lower case).\n                The default is no filter; all resources are returned.\n\n        Returns:\n            list: A set of interconnect MAC address entries.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.FORWARDING_INFORMATION_PATH)\n        return self._helper.get_collection(uri, filter=filter)",
  "def create_forwarding_information_base(self, timeout=-1):\n        \"\"\"\n        Generates the forwarding information base dump file for a logical interconnect.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: Interconnect Forwarding Information Base DataInfo.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.FORWARDING_INFORMATION_PATH)\n        return self._helper.do_post(uri, None, timeout, None)",
  "def get_qos_aggregated_configuration(self):\n        \"\"\"\n        Gets the QoS aggregated configuration for the logical interconnect.\n\n        Returns:\n            dict: QoS Configuration.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.QOS_AGGREGATED_CONFIGURATION)\n        return self._helper.do_get(uri)",
  "def update_qos_aggregated_configuration(self, qos_configuration, timeout=-1):\n        \"\"\"\n        Updates the QoS aggregated configuration for the logical interconnect.\n\n        Args:\n            qos_configuration:\n                QOS configuration.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}{}\".format(self.data[\"uri\"], self.QOS_AGGREGATED_CONFIGURATION)\n        return self._helper.update(qos_configuration, uri=uri, timeout=timeout)",
  "def _get_telemetry_configuration_uri(self):\n        telemetry_conf = self.data.get(\"telemetryConfiguration\", {})\n        if not telemetry_conf.get(\"uri\"):\n            raise HPEOneViewResourceNotFound(\"Telemetry configuration uri is not available\")\n        return telemetry_conf[\"uri\"]",
  "def get_telemetry_configuration(self):\n        \"\"\"\n        Gets the telemetry configuration of a logical interconnect.\n\n        Returns:\n            dict: Telemetry configuration.\n\n        \"\"\"\n        telemetry_conf_uri = self._get_telemetry_configuration_uri()\n        return self._helper.do_get(telemetry_conf_uri)",
  "def update_telemetry_configurations(self, configuration, timeout=-1):\n        \"\"\"\n        Updates the telemetry configuration of a logical interconnect. Changes to the telemetry configuration are\n        asynchronously applied to all managed interconnects.\n\n        Args:\n            configuration:\n                The telemetry configuration for the logical interconnect.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: The Logical Interconnect.\n        \"\"\"\n        telemetry_conf_uri = self._get_telemetry_configuration_uri()\n        default_values = self._get_default_values(self.SETTINGS_TELEMETRY_CONFIG_DEFAULT_VALUES)\n        configuration = self._helper.update_resource_fields(configuration, default_values)\n\n        return self._helper.update(configuration, uri=telemetry_conf_uri, timeout=timeout)",
  "def get_ethernet_settings(self):\n        \"\"\"\n        Gets the Ethernet interconnect settings for the Logical Interconnect.\n\n        Returns:\n            dict: Ethernet Interconnect Settings\n        \"\"\"\n        uri = \"{}/ethernetSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_igmp_settings(self):\n        \"\"\"\n        Gets the Igmp settings for the Logical Interconnect.\n\n        Returns:\n            dict: Ethernet Igmp Settings\n        \"\"\"\n        uri = \"{}/igmpSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def update_igmp_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the Igmp interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Igmp interconnect settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/igmpSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)",
  "def bulk_inconsistency_validate(self, validation_request, timeout=-1):\n        \"\"\"\n        Validates the bulk update from group operation and gets the consolidated inconsistency report\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: Consolidated inconsistency report.\n        \"\"\"\n        uri = \"{}/bulk-inconsistency-validation\".format(self.URI)\n        return self._helper.do_post(uri, validation_request, timeout, None)",
  "def update_port_flap_settings(self, configuration, force=False, timeout=-1):\n        \"\"\"\n        Updates the port flap interconnect settings for the logical interconnect.\n\n        Args:\n            configuration:  Port flap settings.\n            force: If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical Interconnect.\n        \"\"\"\n        uri = \"{}/portFlapSettings\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, force=force, timeout=timeout)",
  "class NetworkSets(Resource, ResourcePatchMixin):\n    \"\"\"\n    Network Sets API client.\n\n    \"\"\"\n    URI = '/rest/network-sets'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"network-set\"},\n        '300': {\"type\": \"network-setV300\"},\n        '500': {\"type\": \"network-setV300\"},\n        '600': {\"type\": \"network-setV4\"},\n        '800': {\"type\": \"network-setV4\"},\n        '1000': {\"type\": \"network-setV4\"},\n        '1200': {\"type\": \"network-setV5\"},\n        '1600': {\"type\": \"network-setV5\"},\n        '1800': {\"type\": \"network-setV5\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(NetworkSets, self).__init__(connection, data)\n\n    def get_all_without_ethernet(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of network sets without ethernet. The collection is based\n        on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of network sets, excluding Ethernet networks.\n        \"\"\"\n        without_ethernet_client = ResourceHelper(\"/rest/network-sets/withoutEthernet\",\n                                                 self._connection,\n                                                 self._task_monitor)\n\n        return without_ethernet_client.get_all(start, count, filter=filter, sort=sort)\n\n    def get_without_ethernet(self):\n        \"\"\"\n        Gets the network set with the specified ID or URI without ethernet.\n\n        Returns:\n            dict: Network set excluding Ethernet networks.\n         uri = \"{}/script\".format(self.data['uri'])\n        return self._helper.do_get(uri)\n        \"\"\"\n        uri = \"{}/withoutEthernet\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(NetworkSets, self).__init__(connection, data)",
  "def get_all_without_ethernet(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of network sets without ethernet. The collection is based\n        on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of network sets, excluding Ethernet networks.\n        \"\"\"\n        without_ethernet_client = ResourceHelper(\"/rest/network-sets/withoutEthernet\",\n                                                 self._connection,\n                                                 self._task_monitor)\n\n        return without_ethernet_client.get_all(start, count, filter=filter, sort=sort)",
  "def get_without_ethernet(self):\n        \"\"\"\n        Gets the network set with the specified ID or URI without ethernet.\n\n        Returns:\n            dict: Network set excluding Ethernet networks.\n         uri = \"{}/script\".format(self.data['uri'])\n        return self._helper.do_get(uri)\n        \"\"\"\n        uri = \"{}/withoutEthernet\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "class InterconnectTypes(Resource):\n    \"\"\"\n    Interconnect Types API client.\n\n    \"\"\"\n    URI = '/rest/interconnect-types'\n\n    def __init__(self, connection, data=None):\n        super(InterconnectTypes, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(InterconnectTypes, self).__init__(connection, data)",
  "class LogicalDownlinks(object):\n    \"\"\"\n    Logical Downlinks API client.\n\n    \"\"\"\n    URI = '/rest/logical-downlinks'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of logical downlinks. The collection is based on\n        optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of logical downlinks.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a logical downlink by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the logical downlink id or the logical downlink uri.\n\n        Returns:\n            dict: The logical downlink.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all logical downlinks that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of logical downlinks.\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def get_all_without_ethernet(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of logical downlinks without ethernet. The collection is\n        based on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            dict\n        \"\"\"\n        without_ethernet_client = ResourceClient(\n            self._connection, \"/rest/logical-downlinks/withoutEthernet\")\n        return without_ethernet_client.get_all(start, count, filter=filter, sort=sort)\n\n    def get_without_ethernet(self, id_or_uri):\n        \"\"\"\n        Gets the logical downlink with the specified ID without ethernet.\n\n        Args:\n            id_or_uri: Can be either the logical downlink id or the logical downlink uri.\n\n        Returns:\n            dict\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/withoutEthernet\"\n        return self._client.get(uri)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of logical downlinks. The collection is based on\n        optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of logical downlinks.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a logical downlink by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the logical downlink id or the logical downlink uri.\n\n        Returns:\n            dict: The logical downlink.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all logical downlinks that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of logical downlinks.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def get_all_without_ethernet(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of logical downlinks without ethernet. The collection is\n        based on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            dict\n        \"\"\"\n        without_ethernet_client = ResourceClient(\n            self._connection, \"/rest/logical-downlinks/withoutEthernet\")\n        return without_ethernet_client.get_all(start, count, filter=filter, sort=sort)",
  "def get_without_ethernet(self, id_or_uri):\n        \"\"\"\n        Gets the logical downlink with the specified ID without ethernet.\n\n        Args:\n            id_or_uri: Can be either the logical downlink id or the logical downlink uri.\n\n        Returns:\n            dict\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/withoutEthernet\"\n        return self._client.get(uri)",
  "class FcoeNetworks(ResourcePatchMixin, Resource):\n    \"\"\"\n    FCoE Networks API client.\n\n    \"\"\"\n    URI = '/rest/fcoe-networks'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"fcoe-network\"},\n        '300': {\"type\": \"fcoe-networkV300\"},\n        '500': {\"type\": \"fcoe-networkV300\"},\n        '600': {\"type\": \"fcoe-networkV4\"},\n        '800': {\"type\": \"fcoe-networkV4\"},\n        '1000': {\"type\": \"fcoe-networkV4\"},\n        '1200': {\"type\": \"fcoe-networkV4\"},\n        '1600': {\"type\": \"fcoe-networkV4\"},\n        '1800': {\"type\": \"fcoe-networkV4\"}\n\n    }\n\n    def __init__(self, connection, data=None):\n        super(FcoeNetworks, self).__init__(connection, data)\n\n    def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk FCoE networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(FcoeNetworks, self).__init__(connection, data)",
  "def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk FCoE networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "class SasInterconnects(ResourcePatchMixin, Resource):\n    \"\"\"\n    SAS Interconnects API client.\n\n    Note:\n        This resource is only available on HPE Synergy.\n\n    \"\"\"\n    URI = '/rest/sas-interconnects'\n\n    def __init__(self, connection, data=None):\n        super(SasInterconnects, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view=''):\n        \"\"\"\n        Get list of SAS interconnects each with port details.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceeds the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of SAS interconnects.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields)\n\n    def refresh_state(self, configuration):\n        \"\"\"\n        Refresh a SAS Interconnect.\n\n        Args:\n            configuration: Configuration\n\n        Returns:\n            dict: SAS Interconnect\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data[\"uri\"])\n        return self._helper.update(uri=uri, resource=configuration)\n\n    def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()\n\n    def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()\n\n    def update(self):\n        \"\"\"Update method is not available\"\"\"\n        unavailable_method()",
  "def __init__(self, connection, data=None):\n        super(SasInterconnects, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view=''):\n        \"\"\"\n        Get list of SAS interconnects each with port details.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceeds the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of SAS interconnects.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields)",
  "def refresh_state(self, configuration):\n        \"\"\"\n        Refresh a SAS Interconnect.\n\n        Args:\n            configuration: Configuration\n\n        Returns:\n            dict: SAS Interconnect\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data[\"uri\"])\n        return self._helper.update(uri=uri, resource=configuration)",
  "def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()",
  "def update(self):\n        \"\"\"Update method is not available\"\"\"\n        unavailable_method()",
  "class LogicalInterconnectGroups(ResourcePatchMixin, Resource):\n    \"\"\"\n    Logical Interconnect Groups API client.\n\n    \"\"\"\n    URI = '/rest/logical-interconnect-groups'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"logical-interconnect-groupV3\"},\n        '300': {\"type\": \"logical-interconnect-groupV300\"},\n        '500': {\"type\": \"logical-interconnect-groupV300\"},\n        '600': {\"type\": \"logical-interconnect-groupV4\"},\n        '800': {\"type\": \"logical-interconnect-groupV5\"},\n        '1000': {\"type\": \"logical-interconnect-groupV6\"},\n        '1200': {\"type\": \"logical-interconnect-groupV7\"},\n        '1400': {\"type\": \"logical-interconnect-groupV8\"},\n        '1600': {\"type\": \"logical-interconnect-groupV8\"},\n        '1800': {\"type\": \"logical-interconnect-groupV8\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(LogicalInterconnectGroups, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of logical interconnect groups based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of logical interconnect groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, scope_uris=scope_uris)\n\n    def get_default_settings(self):\n        \"\"\"\n        Gets the default interconnect settings for a logical interconnect group.\n\n        Returns:\n            dict: Interconnect Settings.\n        \"\"\"\n        uri = self.URI + \"/defaultSettings\"\n        return self._helper.do_get(uri)\n\n    def get_settings(self):\n        \"\"\"\n        Gets the interconnect settings for a logical interconnect group.\n\n        Returns:\n            dict: Interconnect Settings.\n        \"\"\"\n        uri = \"{}/settings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(LogicalInterconnectGroups, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of logical interconnect groups based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of logical interconnect groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, scope_uris=scope_uris)",
  "def get_default_settings(self):\n        \"\"\"\n        Gets the default interconnect settings for a logical interconnect group.\n\n        Returns:\n            dict: Interconnect Settings.\n        \"\"\"\n        uri = self.URI + \"/defaultSettings\"\n        return self._helper.do_get(uri)",
  "def get_settings(self):\n        \"\"\"\n        Gets the interconnect settings for a logical interconnect group.\n\n        Returns:\n            dict: Interconnect Settings.\n        \"\"\"\n        uri = \"{}/settings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "class Interconnects(ResourcePatchMixin, Resource):\n    \"\"\"\n    Interconnects API client.\n\n    \"\"\"\n\n    URI = '/rest/interconnects'\n\n    def __init__(self, connection, data=None):\n        super(Interconnects, self).__init__(connection, data)\n\n    def get_statistics(self, port_name=''):\n        \"\"\"\n        Gets the statistics from an interconnect.\n\n        Args:\n            port_name (str): A specific port name of an interconnect.\n\n        Returns:\n             dict: The statistics for the interconnect that matches id.\n        \"\"\"\n        uri = \"{}/statistics\".format(self.data[\"uri\"])\n\n        if port_name:\n            uri = uri + \"/\" + port_name\n\n        return self._helper.do_get(uri)\n\n    def get_subport_statistics(self, port_name, subport_number):\n        \"\"\"\n        Gets the subport statistics on an interconnect.\n\n        Args:\n            port_name (str): A specific port name of an interconnect.\n            subport_number (int): The subport.\n\n        Returns:\n             dict: The statistics for the interconnect that matches id, port_name, and subport_number.\n        \"\"\"\n        uri = \"{}/statistics/{}/subport/{}\".format(self.data[\"uri\"], port_name, subport_number)\n        return self._helper.do_get(uri)\n\n    def get_name_servers(self):\n        \"\"\"\n        Gets the named servers for an interconnect.\n\n        Returns:\n             dict: the name servers for an interconnect.\n        \"\"\"\n\n        uri = \"{}/nameServers\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def update_port(self, port_information, timeout=-1):\n        \"\"\"\n        Updates an interconnect port.\n\n        Args:\n            port_information (dict): object to update\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        uri = \"{}/ports\".format(self.data[\"uri\"])\n        return self._helper.update(port_information, uri, timeout=timeout)\n\n    def update_ports(self, ports, timeout=-1):\n        \"\"\"\n        Updates the interconnect ports.\n\n        Args:\n            ports (list): Ports to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        resources = merge_default_values(ports, {'type': 'port'})\n\n        uri = \"{}/update-ports\".format(self.data[\"uri\"])\n        return self._helper.update(resources, uri, timeout=timeout)\n\n    def reset_port_protection(self, timeout=-1):\n        \"\"\"\n        Triggers a reset of port protection.\n\n        Cause port protection to be reset on all the interconnects of the logical interconnect that matches ID.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        uri = \"{}/resetportprotection\".format(self.data[\"uri\"])\n        return self._helper.update_with_zero_body(uri, timeout)\n\n    def get_ports(self, start=0, count=-1):\n        \"\"\"\n        Gets all interconnect ports.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n\n        Returns:\n            list: All interconnect ports.\n        \"\"\"\n        uri = \"{}/ports\".format(self.data[\"uri\"])\n        return self._helper.get_all(start, count, uri=uri)\n\n    def get_port(self, port_id_or_uri):\n        \"\"\"\n        Gets an interconnect port.\n\n        Args:\n            port_id_or_uri: The interconnect port id or uri.\n\n        Returns:\n            dict: The interconnect port.\n        \"\"\"\n        uri = \"{}/ports/{}\".format(self.data[\"uri\"], port_id_or_uri)\n        return self._helper.do_get(uri)\n\n    def get_pluggable_module_information(self):\n        \"\"\"\n        Gets all the pluggable module information.\n\n        Returns:\n            array: dicts of the pluggable module information.\n        \"\"\"\n        uri = \"{}/pluggableModuleInformation\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on the interconnect. This includes running the same configure steps\n        that were performed as part of the interconnect add by the enclosure.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Interconnect\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        return self._helper.update_with_zero_body(uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(Interconnects, self).__init__(connection, data)",
  "def get_statistics(self, port_name=''):\n        \"\"\"\n        Gets the statistics from an interconnect.\n\n        Args:\n            port_name (str): A specific port name of an interconnect.\n\n        Returns:\n             dict: The statistics for the interconnect that matches id.\n        \"\"\"\n        uri = \"{}/statistics\".format(self.data[\"uri\"])\n\n        if port_name:\n            uri = uri + \"/\" + port_name\n\n        return self._helper.do_get(uri)",
  "def get_subport_statistics(self, port_name, subport_number):\n        \"\"\"\n        Gets the subport statistics on an interconnect.\n\n        Args:\n            port_name (str): A specific port name of an interconnect.\n            subport_number (int): The subport.\n\n        Returns:\n             dict: The statistics for the interconnect that matches id, port_name, and subport_number.\n        \"\"\"\n        uri = \"{}/statistics/{}/subport/{}\".format(self.data[\"uri\"], port_name, subport_number)\n        return self._helper.do_get(uri)",
  "def get_name_servers(self):\n        \"\"\"\n        Gets the named servers for an interconnect.\n\n        Returns:\n             dict: the name servers for an interconnect.\n        \"\"\"\n\n        uri = \"{}/nameServers\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def update_port(self, port_information, timeout=-1):\n        \"\"\"\n        Updates an interconnect port.\n\n        Args:\n            port_information (dict): object to update\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        uri = \"{}/ports\".format(self.data[\"uri\"])\n        return self._helper.update(port_information, uri, timeout=timeout)",
  "def update_ports(self, ports, timeout=-1):\n        \"\"\"\n        Updates the interconnect ports.\n\n        Args:\n            ports (list): Ports to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        resources = merge_default_values(ports, {'type': 'port'})\n\n        uri = \"{}/update-ports\".format(self.data[\"uri\"])\n        return self._helper.update(resources, uri, timeout=timeout)",
  "def reset_port_protection(self, timeout=-1):\n        \"\"\"\n        Triggers a reset of port protection.\n\n        Cause port protection to be reset on all the interconnects of the logical interconnect that matches ID.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The interconnect.\n\n        \"\"\"\n        uri = \"{}/resetportprotection\".format(self.data[\"uri\"])\n        return self._helper.update_with_zero_body(uri, timeout)",
  "def get_ports(self, start=0, count=-1):\n        \"\"\"\n        Gets all interconnect ports.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n\n        Returns:\n            list: All interconnect ports.\n        \"\"\"\n        uri = \"{}/ports\".format(self.data[\"uri\"])\n        return self._helper.get_all(start, count, uri=uri)",
  "def get_port(self, port_id_or_uri):\n        \"\"\"\n        Gets an interconnect port.\n\n        Args:\n            port_id_or_uri: The interconnect port id or uri.\n\n        Returns:\n            dict: The interconnect port.\n        \"\"\"\n        uri = \"{}/ports/{}\".format(self.data[\"uri\"], port_id_or_uri)\n        return self._helper.do_get(uri)",
  "def get_pluggable_module_information(self):\n        \"\"\"\n        Gets all the pluggable module information.\n\n        Returns:\n            array: dicts of the pluggable module information.\n        \"\"\"\n        uri = \"{}/pluggableModuleInformation\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on the interconnect. This includes running the same configure steps\n        that were performed as part of the interconnect add by the enclosure.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Interconnect\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        return self._helper.update_with_zero_body(uri, timeout=timeout)",
  "class ConnectionTemplates(Resource):\n    \"\"\"\n    Connection Templates API client.\n\n    \"\"\"\n    URI = '/rest/connection-templates'\n\n    def __init__(self, connection, data=None):\n        super(ConnectionTemplates, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'connection-template'\n        }\n\n    def get_default(self):\n        \"\"\"\n        Gets the default network connection template. This is the default connection template used\n        for construction of networks. Its value is copied when a new connection template is made.\n\n        Returns:\n            dict:\n        \"\"\"\n        uri = self.URI + \"/defaultConnectionTemplate\"\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(ConnectionTemplates, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'connection-template'\n        }",
  "def get_default(self):\n        \"\"\"\n        Gets the default network connection template. This is the default connection template used\n        for construction of networks. Its value is copied when a new connection template is made.\n\n        Returns:\n            dict:\n        \"\"\"\n        uri = self.URI + \"/defaultConnectionTemplate\"\n        return self._helper.do_get(uri)",
  "class InternalLinkSets(Resource):\n    \"\"\"\n    Internal Link Sets API client.\n\n    Note:\n        This resource is available for API version 300 or later.\n\n    \"\"\"\n\n    URI = '/rest/internal-link-sets'\n\n    def __init__(self, connection, data=None):\n        super(InternalLinkSets, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields=''):\n        \"\"\"\n        Gets a paginated collection of all internal link sets.\n        The collection is based on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default is\n                no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            fields:\n                Specifies which fields should be returned in the result set.\n            view:\n                Return a specific subset of the attributes of the resource or collection, by specifying the name\n                of a predefined view. The default view is expand - show all attributes of the resource and all\n                elements of collections of resources.\n\n        Returns:\n            list:  Internal Link Set Collection.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter,\n                                    query=query, sort=sort, view=view, fields=fields)",
  "def __init__(self, connection, data=None):\n        super(InternalLinkSets, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', query='', sort='', view='', fields=''):\n        \"\"\"\n        Gets a paginated collection of all internal link sets.\n        The collection is based on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default is\n                no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            fields:\n                Specifies which fields should be returned in the result set.\n            view:\n                Return a specific subset of the attributes of the resource or collection, by specifying the name\n                of a predefined view. The default view is expand - show all attributes of the resource and all\n                elements of collections of resources.\n\n        Returns:\n            list:  Internal Link Set Collection.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter,\n                                    query=query, sort=sort, view=view, fields=fields)",
  "class UplinkSets(Resource):\n    \"\"\"\n    Uplink Sets API client.\n\n    \"\"\"\n    URI = '/rest/uplink-sets'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"uplink-setV3\"},\n        '300': {\"type\": \"uplink-setV300\"},\n        '500': {\"type\": \"uplink-setV300\"},\n        '600': {\"type\": \"uplink-setV4\"},\n        '800': {\"type\": \"uplink-setV4\"},\n        '1000': {\"type\": \"uplink-setV5\"},\n        '1200': {\"type\": \"uplink-setV6\"},\n        '1600': {\"type\": \"uplink-setV7\"},\n        '1800': {\"type\": \"uplink-setV7\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(UplinkSets, self).__init__(connection, data)\n        self._ethernet_networks = EthernetNetworks(connection)\n\n    @ensure_resource_client\n    def get_ethernet_networks(self):\n        \"\"\"\n        Gets a list of associated ethernet networks of an uplink set.\n\n        Args:\n            id_or_uri: Can be either the uplink set id or the uplink set uri.\n\n        Returns:\n            list: Associated ethernet networks.\n        \"\"\"\n        network_uris = self.data.get('networkUris')\n        networks = []\n        if network_uris:\n            for uri in network_uris:\n                networks.append(self._ethernet_networks.get_by_uri(uri))\n        return networks\n\n    @ensure_resource_client\n    def add_ethernet_networks(self, ethernet_names):\n        \"\"\"\n        Adds existing ethernet networks to an uplink set.\n\n        Args:\n            id_or_uri:\n                Can be either the uplink set id or the uplink set uri.\n            ethernet_name:\n                Could be either one or more ethernet network names.\n        Returns:\n            dict: The updated uplink set.\n        \"\"\"\n        self.__set_ethernet_uris(ethernet_names, operation=\"add\")\n        return self.data\n\n    @ensure_resource_client\n    def remove_ethernet_networks(self, ethernet_names):\n        \"\"\"\n        Remove existing ethernet networks of an uplink set.\n\n        Args:\n            id_or_uri:\n                Can be either the uplink set id or the uplink set uri.\n            ethernet_id_or_uris:\n                Could be either one or more ethernet network id or ethernet network uri.\n\n        Returns:\n            dict: The updated uplink set.\n        \"\"\"\n        self.__set_ethernet_uris(ethernet_names, operation=\"remove\")\n        return self.data\n\n    def __set_ethernet_uris(self, ethernet_names, operation=\"add\"):\n        \"\"\"Updates network uris.\"\"\"\n        if not isinstance(ethernet_names, list):\n            ethernet_names = [ethernet_names]\n\n        associated_enets = self.data.get('networkUris', [])\n        ethernet_uris = []\n\n        for i, enet in enumerate(ethernet_names):\n            enet_exists = self._ethernet_networks.get_by_name(enet)\n            if enet_exists:\n                ethernet_uris.append(enet_exists.data['uri'])\n            else:\n                raise HPEOneViewResourceNotFound(\"Ethernet: {} does not exist\".foramt(enet))\n\n        if operation == \"remove\":\n            enets_to_update = sorted(list(set(associated_enets) - set(ethernet_uris)))\n        elif operation == \"add\":\n            enets_to_update = sorted(list(set(associated_enets).union(set(ethernet_uris))))\n        else:\n            raise ValueError(\"Value {} is not supported as operation. The supported values are: ['add', 'remove']\")\n\n        if set(enets_to_update) != set(associated_enets):\n            updated_network = {'networkUris': enets_to_update}\n            self.update(updated_network)",
  "def __init__(self, connection, data=None):\n        super(UplinkSets, self).__init__(connection, data)\n        self._ethernet_networks = EthernetNetworks(connection)",
  "def get_ethernet_networks(self):\n        \"\"\"\n        Gets a list of associated ethernet networks of an uplink set.\n\n        Args:\n            id_or_uri: Can be either the uplink set id or the uplink set uri.\n\n        Returns:\n            list: Associated ethernet networks.\n        \"\"\"\n        network_uris = self.data.get('networkUris')\n        networks = []\n        if network_uris:\n            for uri in network_uris:\n                networks.append(self._ethernet_networks.get_by_uri(uri))\n        return networks",
  "def add_ethernet_networks(self, ethernet_names):\n        \"\"\"\n        Adds existing ethernet networks to an uplink set.\n\n        Args:\n            id_or_uri:\n                Can be either the uplink set id or the uplink set uri.\n            ethernet_name:\n                Could be either one or more ethernet network names.\n        Returns:\n            dict: The updated uplink set.\n        \"\"\"\n        self.__set_ethernet_uris(ethernet_names, operation=\"add\")\n        return self.data",
  "def remove_ethernet_networks(self, ethernet_names):\n        \"\"\"\n        Remove existing ethernet networks of an uplink set.\n\n        Args:\n            id_or_uri:\n                Can be either the uplink set id or the uplink set uri.\n            ethernet_id_or_uris:\n                Could be either one or more ethernet network id or ethernet network uri.\n\n        Returns:\n            dict: The updated uplink set.\n        \"\"\"\n        self.__set_ethernet_uris(ethernet_names, operation=\"remove\")\n        return self.data",
  "def __set_ethernet_uris(self, ethernet_names, operation=\"add\"):\n        \"\"\"Updates network uris.\"\"\"\n        if not isinstance(ethernet_names, list):\n            ethernet_names = [ethernet_names]\n\n        associated_enets = self.data.get('networkUris', [])\n        ethernet_uris = []\n\n        for i, enet in enumerate(ethernet_names):\n            enet_exists = self._ethernet_networks.get_by_name(enet)\n            if enet_exists:\n                ethernet_uris.append(enet_exists.data['uri'])\n            else:\n                raise HPEOneViewResourceNotFound(\"Ethernet: {} does not exist\".foramt(enet))\n\n        if operation == \"remove\":\n            enets_to_update = sorted(list(set(associated_enets) - set(ethernet_uris)))\n        elif operation == \"add\":\n            enets_to_update = sorted(list(set(associated_enets).union(set(ethernet_uris))))\n        else:\n            raise ValueError(\"Value {} is not supported as operation. The supported values are: ['add', 'remove']\")\n\n        if set(enets_to_update) != set(associated_enets):\n            updated_network = {'networkUris': enets_to_update}\n            self.update(updated_network)",
  "class InterconnectLinkTopologies(object):\n    \"\"\"\n    Interconnect Link Topologies API client.\n\n    Note:\n        This resource is only available on HPE Synergy.\n\n    \"\"\"\n\n    URI = '/rest/interconnect-link-topologies'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of all the interconnect link topologies based on the specified parameters.\n\n        Filters can be used in the URL to control the number of interconnect link topologies that are returned.\n        With no filters specified, the API returns all interconnect link toplogies.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of interconnect link topologies.\n\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets an interconnect link topology by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the interconnect type id or the interconnect type uri.\n\n        Returns:\n            dict: The interconnect link topology.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all interconnect link topologies that match the filter.\n        The search is case-insensitive\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of interconnect link topologies.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of all the interconnect link topologies based on the specified parameters.\n\n        Filters can be used in the URL to control the number of interconnect link topologies that are returned.\n        With no filters specified, the API returns all interconnect link toplogies.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of interconnect link topologies.\n\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets an interconnect link topology by ID or by URI.\n\n        Args:\n            id_or_uri: Can be either the interconnect type id or the interconnect type uri.\n\n        Returns:\n            dict: The interconnect link topology.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all interconnect link topologies that match the filter.\n        The search is case-insensitive\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of interconnect link topologies.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "class SasInterconnectTypes(Resource):\n    \"\"\"\n    SAS Interconnect Types API client.\n\n    Note:\n        This resource is only available on HPE Synergy.\n\n    \"\"\"\n    URI = '/rest/sas-interconnect-types'\n\n    def __init__(self, connection, data=None):\n        super(SasInterconnectTypes, self).__init__(connection, data)\n\n    def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()\n\n    def delete(self):\n        \"\"\"Delete method is not avaialble\"\"\"\n        unavailable_method()\n\n    def update(self):\n        \"\"\"Update method is not avaialble\"\"\"\n        unavailable_method()",
  "def __init__(self, connection, data=None):\n        super(SasInterconnectTypes, self).__init__(connection, data)",
  "def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "def delete(self):\n        \"\"\"Delete method is not avaialble\"\"\"\n        unavailable_method()",
  "def update(self):\n        \"\"\"Update method is not avaialble\"\"\"\n        unavailable_method()",
  "class LogicalSwitchGroups(ResourcePatchMixin, Resource):\n    \"\"\"\n    Logical Switch Groups API client.\n\n    Note:\n        This resource is only available on C7000 enclosures.\n\n    \"\"\"\n    URI = '/rest/logical-switch-groups'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"logical-switch-group\"},\n        '300': {\"type\": \"logical-switch-groupV300\"},\n        '500': {\"type\": \"logical-switch-groupV300\"},\n        '600': {\"type\": \"logical-switch-groupV4\"},\n        '800': {\"type\": \"logical-switch-groupV4\"},\n        '1000': {\"type\": \"logical-switch-groupV4\"},\n        '1200': {\"type\": \"logical-switch-groupV4\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(LogicalSwitchGroups, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(LogicalSwitchGroups, self).__init__(connection, data)",
  "class FcNetworks(ResourcePatchMixin, Resource):\n    \"\"\"\n    Fibre Channel networks API client.\n\n    \"\"\"\n\n    URI = '/rest/fc-networks'\n\n    DEFAULT_VALUES = {\n        '200': {'type': 'fc-networkV2'},\n        '300': {\"type\": \"fc-networkV300\"},\n        '500': {\"type\": \"fc-networkV300\"},\n        '600': {\"type\": \"fc-networkV4\"},\n        '800': {\"type\": \"fc-networkV4\"},\n        '1000': {\"type\": \"fc-networkV4\"},\n        '1200': {\"type\": \"fc-networkV4\"},\n        '1600': {\"type\": \"fc-networkV4\"},\n        '1800': {\"type\": \"fc-networkV4\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(FcNetworks, self).__init__(connection, data)\n\n    def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk fc networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(FcNetworks, self).__init__(connection, data)",
  "def delete_bulk(self, resource, timeout=-1):\n        \"\"\"\n        Deletes bulk fc networks.\n\n        Args:\n            resource (dict): Specifications to delete in bulk.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        \"\"\"\n        uri = self.URI + '/bulk-delete'\n\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "class LogicalSwitches(object):\n    \"\"\"\n    Logical Switches API client.\n\n    Note:\n        This resource is only available on C7000 enclosures.\n\n    \"\"\"\n    URI = '/rest/logical-switches'\n\n    SWITCH_DEFAULT_VALUES = {\n        '200': {\"type\": \"logical-switch\"},\n        '300': {\"type\": \"logical-switchV300\"},\n        '500': {\"type\": \"logical-switchV300\"},\n        '600': {\"type\": \"logical-switchV4\"}\n    }\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of Logical Switches. The collection is based on optional\n        sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Logical Switches.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)\n\n    def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes a Logical Switch.\n\n        Args:\n            resource: dict object to delete\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets the Logical Switch with the specified ID.\n\n        Args:\n            id_or_uri: Can be either the Logical Switch ID or URI\n\n        Returns:\n            dict: Logical Switch.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates a Logical Switch.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n        \"\"\"\n        self.__set_default_values(resource)\n        return self._client.create(resource, timeout=timeout)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates a Logical Switch.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        self.__set_default_values(resource)\n        uri = self._client.build_uri(resource['logicalSwitch']['uri'])\n        return self._client.update(resource, uri=uri, timeout=timeout)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all Logical Switches that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of Logical Switches.\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def refresh(self, id_or_uri, timeout=-1):\n        \"\"\"\n        The Refresh action reclaims the top-of-rack switches in a logical switch.\n\n        Args:\n            id_or_uri:\n                Can be either the Logical Switch ID or URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: The Logical Switch\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/refresh\"\n        return self._client.update_with_zero_body(uri, timeout=timeout)\n\n    def patch(self, id_or_uri, operation, path, value, timeout=-1):\n        \"\"\"\n        Uses the PATCH to update a resource for a given logical switch group.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        return self._client.patch(id_or_uri, operation, path, value, timeout=timeout)\n\n    def __set_default_values(self, resource):\n        if 'logicalSwitch' in resource:\n            resource['logicalSwitch'] = self._client.merge_default_values(resource['logicalSwitch'],\n                                                                          self.SWITCH_DEFAULT_VALUES)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of Logical Switches. The collection is based on optional\n        sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Logical Switches.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes a Logical Switch.\n\n        Args:\n            resource: dict object to delete\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets the Logical Switch with the specified ID.\n\n        Args:\n            id_or_uri: Can be either the Logical Switch ID or URI\n\n        Returns:\n            dict: Logical Switch.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates a Logical Switch.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n        \"\"\"\n        self.__set_default_values(resource)\n        return self._client.create(resource, timeout=timeout)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates a Logical Switch.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        self.__set_default_values(resource)\n        uri = self._client.build_uri(resource['logicalSwitch']['uri'])\n        return self._client.update(resource, uri=uri, timeout=timeout)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all Logical Switches that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of Logical Switches.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def refresh(self, id_or_uri, timeout=-1):\n        \"\"\"\n        The Refresh action reclaims the top-of-rack switches in a logical switch.\n\n        Args:\n            id_or_uri:\n                Can be either the Logical Switch ID or URI\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: The Logical Switch\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/refresh\"\n        return self._client.update_with_zero_body(uri, timeout=timeout)",
  "def patch(self, id_or_uri, operation, path, value, timeout=-1):\n        \"\"\"\n        Uses the PATCH to update a resource for a given logical switch group.\n\n        Only one operation can be performed in each PATCH call.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            operation: Patch operation\n            path: Path\n            value: Value\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        return self._client.patch(id_or_uri, operation, path, value, timeout=timeout)",
  "def __set_default_values(self, resource):\n        if 'logicalSwitch' in resource:\n            resource['logicalSwitch'] = self._client.merge_default_values(resource['logicalSwitch'],\n                                                                          self.SWITCH_DEFAULT_VALUES)",
  "class Fabrics(object):\n    \"\"\"\n    Fabrics API client.\n\n    \"\"\"\n    URI = '/rest/fabrics'\n\n    DEFAULT_VALUES = {\n        '300': {'type': 'vlan-pool'},\n        '500': {'type': 'vlan-pool'}\n    }\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of all fabrics based on the specified parameters.\n\n        Filters can be used in the URL to control the number of fabrics that are returned.\n        With no filters specified, the API returns all supported fabrics.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of fabrics.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets the fabric with the specified ID.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n\n        Returns:\n            dict: The fabric.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all fabrics that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of fabrics.\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def get_reserved_vlan_range(self, id_or_uri):\n        \"\"\"\n        Gets the reserved vlan ID range for the fabric.\n\n        Note:\n            This method is only available on HPE Synergy.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n\n        Returns:\n            dict: vlan-pool\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/reserved-vlan-range\"\n        return self._client.get(uri)\n\n    def update_reserved_vlan_range(self, id_or_uri, vlan_pool, force=False):\n        \"\"\"\n        Updates the reserved vlan ID range for the fabric.\n\n        Note:\n            This method is only available on HPE Synergy.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n            vlan_pool (dict): vlan-pool data to update.\n            force:  If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n\n        Returns:\n            dict: The fabric\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/reserved-vlan-range\"\n        return self._client.update(resource=vlan_pool, uri=uri, force=force, default_values=self.DEFAULT_VALUES)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a paginated collection of all fabrics based on the specified parameters.\n\n        Filters can be used in the URL to control the number of fabrics that are returned.\n        With no filters specified, the API returns all supported fabrics.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of fabrics.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets the fabric with the specified ID.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n\n        Returns:\n            dict: The fabric.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all fabrics that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of fabrics.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def get_reserved_vlan_range(self, id_or_uri):\n        \"\"\"\n        Gets the reserved vlan ID range for the fabric.\n\n        Note:\n            This method is only available on HPE Synergy.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n\n        Returns:\n            dict: vlan-pool\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/reserved-vlan-range\"\n        return self._client.get(uri)",
  "def update_reserved_vlan_range(self, id_or_uri, vlan_pool, force=False):\n        \"\"\"\n        Updates the reserved vlan ID range for the fabric.\n\n        Note:\n            This method is only available on HPE Synergy.\n\n        Args:\n            id_or_uri: ID or URI of fabric.\n            vlan_pool (dict): vlan-pool data to update.\n            force:  If set to true, the operation completes despite any problems with network connectivity or errors\n                on the resource itself. The default is false.\n\n        Returns:\n            dict: The fabric\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/reserved-vlan-range\"\n        return self._client.update(resource=vlan_pool, uri=uri, force=force, default_values=self.DEFAULT_VALUES)",
  "class SwitchTypes(Resource):\n    \"\"\"\n    Switch Types API client.\n\n    \"\"\"\n    URI = '/rest/switch-types'\n\n    def __init__(self, connection, data=None):\n        super(SwitchTypes, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(SwitchTypes, self).__init__(connection, data)",
  "class SasLogicalInterconnects(Resource):\n    \"\"\"\n    SAS Logical Interconnects API client.\n\n    \"\"\"\n    URI = '/rest/sas-logical-interconnects'\n\n    def __init__(self, connection, data=None):\n        super(SasLogicalInterconnects, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets a list of SAS Logical Interconnects based on optional sorting and filtering and constrained by start and\n        count parameters.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceeds the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of SAS logical interconnects.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields)\n\n    @ensure_resource_client\n    def update_firmware(self, firmware_information, force=False):\n        \"\"\"\n        Installs firmware to the member interconnects of a SAS Logical Interconnect.\n\n        Args:\n            firmware_information: Options to install firmware to a SAS Logical Interconnect.\n            force: If sets to true, the operation completes despite any problems with the network connectivy\n              or the erros on the resource itself.\n        Returns:\n            dict: SAS Logical Interconnect Firmware.\n        \"\"\"\n        firmware_uri = \"{}/firmware\".format(self.data[\"uri\"])\n        result = self._helper.update(firmware_information, firmware_uri, force=force)\n        self.refresh()\n\n        return result\n\n    @ensure_resource_client\n    def get_firmware(self):\n        \"\"\"\n        Gets baseline firmware information for a SAS Logical Interconnect.\n\n        Returns:\n            dict: SAS Logical Interconnect Firmware.\n        \"\"\"\n        firmware_uri = \"{}/firmware\".format(self.data[\"uri\"])\n        return self._helper.do_get(firmware_uri)\n\n    def update_compliance_all(self, information, timeout=-1):\n        \"\"\"\n        Returns SAS Logical Interconnects to a consistent state. The current SAS Logical Interconnect state is\n        compared to the associated SAS Logical Interconnect group.\n\n        Args:\n            information: Can be either the resource ID or URI.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n\n        uri = self.URI + \"/compliance\"\n        result = self._helper.update(information, uri, timeout=timeout)\n\n        return result\n\n    @ensure_resource_client\n    def update_compliance(self, timeout=-1):\n        \"\"\"\n        Returns a SAS Logical Interconnect to a consistent state. The current SAS Logical Interconnect state is\n        compared to the associated SAS Logical Interconnect group.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n        uri = \"{}/compliance\".format(self.data[\"uri\"])\n        result = self._helper.update({}, uri, timeout=timeout)\n        self.refresh()\n\n        return result\n\n    @ensure_resource_client\n    def replace_drive_enclosure(self, information):\n        \"\"\"\n        When a drive enclosure has been physically replaced, initiate the replacement operation that enables the\n        new drive enclosure to take over as a replacement for the prior drive enclosure. The request requires\n        specification of both the serial numbers of the original drive enclosure and its replacement to be provided.\n\n        Args:\n            information: Options to replace the drive enclosure.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n\n        uri = \"{}/replaceDriveEnclosure\".format(self.data[\"uri\"])\n        result = self._helper.create(information, uri)\n        self.refresh()\n\n        return result\n\n    @ensure_resource_client\n    def update_configuration(self):\n        \"\"\"\n        Asynchronously applies or re-applies the SAS Logical Interconnect configuration to all managed interconnects\n        of a SAS Logical Interconnect.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        result = self._helper.update({}, uri)\n        self.refresh()\n\n        return result\n\n    def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()\n\n    def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()\n\n    def update(self):\n        \"\"\"update method is not available\"\"\"\n        unavailable_method()",
  "def __init__(self, connection, data=None):\n        super(SasLogicalInterconnects, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets a list of SAS Logical Interconnects based on optional sorting and filtering and constrained by start and\n        count parameters.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceeds the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of SAS logical interconnects.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields)",
  "def update_firmware(self, firmware_information, force=False):\n        \"\"\"\n        Installs firmware to the member interconnects of a SAS Logical Interconnect.\n\n        Args:\n            firmware_information: Options to install firmware to a SAS Logical Interconnect.\n            force: If sets to true, the operation completes despite any problems with the network connectivy\n              or the erros on the resource itself.\n        Returns:\n            dict: SAS Logical Interconnect Firmware.\n        \"\"\"\n        firmware_uri = \"{}/firmware\".format(self.data[\"uri\"])\n        result = self._helper.update(firmware_information, firmware_uri, force=force)\n        self.refresh()\n\n        return result",
  "def get_firmware(self):\n        \"\"\"\n        Gets baseline firmware information for a SAS Logical Interconnect.\n\n        Returns:\n            dict: SAS Logical Interconnect Firmware.\n        \"\"\"\n        firmware_uri = \"{}/firmware\".format(self.data[\"uri\"])\n        return self._helper.do_get(firmware_uri)",
  "def update_compliance_all(self, information, timeout=-1):\n        \"\"\"\n        Returns SAS Logical Interconnects to a consistent state. The current SAS Logical Interconnect state is\n        compared to the associated SAS Logical Interconnect group.\n\n        Args:\n            information: Can be either the resource ID or URI.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n\n        uri = self.URI + \"/compliance\"\n        result = self._helper.update(information, uri, timeout=timeout)\n\n        return result",
  "def update_compliance(self, timeout=-1):\n        \"\"\"\n        Returns a SAS Logical Interconnect to a consistent state. The current SAS Logical Interconnect state is\n        compared to the associated SAS Logical Interconnect group.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n        uri = \"{}/compliance\".format(self.data[\"uri\"])\n        result = self._helper.update({}, uri, timeout=timeout)\n        self.refresh()\n\n        return result",
  "def replace_drive_enclosure(self, information):\n        \"\"\"\n        When a drive enclosure has been physically replaced, initiate the replacement operation that enables the\n        new drive enclosure to take over as a replacement for the prior drive enclosure. The request requires\n        specification of both the serial numbers of the original drive enclosure and its replacement to be provided.\n\n        Args:\n            information: Options to replace the drive enclosure.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n\n        uri = \"{}/replaceDriveEnclosure\".format(self.data[\"uri\"])\n        result = self._helper.create(information, uri)\n        self.refresh()\n\n        return result",
  "def update_configuration(self):\n        \"\"\"\n        Asynchronously applies or re-applies the SAS Logical Interconnect configuration to all managed interconnects\n        of a SAS Logical Interconnect.\n\n        Returns:\n            dict: SAS Logical Interconnect.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        result = self._helper.update({}, uri)\n        self.refresh()\n\n        return result",
  "def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()",
  "def update(self):\n        \"\"\"update method is not available\"\"\"\n        unavailable_method()",
  "class SasLogicalInterconnectGroups(Resource):\n    \"\"\"\n    SAS Logical Interconnect Groups API client.\n\n    Note:\n        This resource is only available on HPE Synergy.\n\n    \"\"\"\n    URI = '/rest/sas-logical-interconnect-groups'\n\n    DEFAULT_VALUES = {\n        '300': {'type': 'sas-logical-interconnect-group'},\n        '500': {'type': 'sas-logical-interconnect-group'},\n        '600': {'type': 'sas-logical-interconnect-groupV2'},\n        '800': {'type': 'sas-logical-interconnect-groupV2'},\n        '1000': {'type': 'sas-logical-interconnect-groupV2'},\n        '1200': {'type': 'sas-logical-interconnect-groupV2'},\n    }\n\n    def __init__(self, connection, data=None):\n        super(SasLogicalInterconnectGroups, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris='', query=''):\n        \"\"\"\n        Gets a paginated collection of SAS logical interconnect groups. The collection is based\n        on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            query (str):\n                 A general query string to narrow the list of resources returned.\n                 The default is no query - all resources are returned.\n\n        Returns:\n            list: A list of SAS logical interconnect groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort,\n                                    scope_uris=scope_uris, query=query)",
  "def __init__(self, connection, data=None):\n        super(SasLogicalInterconnectGroups, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris='', query=''):\n        \"\"\"\n        Gets a paginated collection of SAS logical interconnect groups. The collection is based\n        on optional sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n            query (str):\n                 A general query string to narrow the list of resources returned.\n                 The default is no query - all resources are returned.\n\n        Returns:\n            list: A list of SAS logical interconnect groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort,\n                                    scope_uris=scope_uris, query=query)",
  "class ServerHardwareTypes(Resource):\n    \"\"\"\n    The server hardware types resource is a representation/abstraction of a physical server managed by the appliance.\n    It defines capabilities and settings that can be used in a server profile.\n\n    \"\"\"\n    URI = '/rest/server-hardware-types'\n\n    def __init__(self, connection, data=None):\n        super(ServerHardwareTypes, self).__init__(connection, data)\n\n    @ensure_resource_client\n    def update(self, data, timeout=-1, force=False):\n        \"\"\"\n        Updates one or more attributes for a server hardware type resource.\n        Args:\n            data (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation.\n        Returns:\n            dict: Updated server hardware type.\n        \"\"\"\n        uri = self.data[\"uri\"]\n        self.data = self._helper.update(data, uri=uri, timeout=timeout, force=force)\n\n        return self",
  "def __init__(self, connection, data=None):\n        super(ServerHardwareTypes, self).__init__(connection, data)",
  "def update(self, data, timeout=-1, force=False):\n        \"\"\"\n        Updates one or more attributes for a server hardware type resource.\n        Args:\n            data (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation.\n        Returns:\n            dict: Updated server hardware type.\n        \"\"\"\n        uri = self.data[\"uri\"]\n        self.data = self._helper.update(data, uri=uri, timeout=timeout, force=force)\n\n        return self",
  "class ServerProfileTemplate(Resource, ResourcePatchMixin):\n    \"\"\"\n    The server profile template resource provides methods to create, retrieve, modify, and delete server\n    profile templates.\n\n    A server profile template serves as a structural reference when creating a server profile.\n    All of the configuration constructs of a server profile are present in the server profile template.\n    The server profile template serves as the initial and ongoing reference for the structure of a server profile.\n    The server profile template defines the centralized source for the configuration of firmware, connections,\n    local storage, SAN storage, boot, BIOS, profile affinity and hide unused flexNICs.\n\n    After being created from a server profile template, the server profile continues to maintain an association to its\n    server profile template. Any drift in configuration consistency between the server profile template and server\n    profile(s) is monitored and made visible on both the server profile template and the associated server profile(s).\n\n    \"\"\"\n\n    URI = '/rest/server-profile-templates'\n    TRANSFORMATION_PATH = \"/transformation/?serverHardwareTypeUri={server_hardware_type_uri}\" + \\\n                          \"&enclosureGroupUri={enclosure_group_uri}\"\n\n    DEFAULT_VALUES = {\n        '200': {'type': 'ServerProfileTemplateV1'},\n        '300': {'type': 'ServerProfileTemplateV2'},\n        '500': {'type': 'ServerProfileTemplateV3'},\n        '600': {'type': 'ServerProfileTemplateV4'},\n        '800': {'type': 'ServerProfileTemplateV5'},\n        '1000': {'type': 'ServerProfileTemplateV6'},\n        '1200': {'type': 'ServerProfileTemplateV7'},\n        '1600': {'type': 'ServerProfileTemplateV8'},\n        '1800': {'type': 'ServerProfileTemplateV8'}\n    }\n\n    def __init__(self, connection, data=None):\n        super(ServerProfileTemplate, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of server profile templates based on optional sorting and filtering and is constrained by start and\n        count parameters.\n\n        Args:\n            start: The first item to return, using 0-based indexing. If not specified, the default\n                is 0 - start with the first available item.\n            count: The number of resources to return. Providing a -1 for the count parameter will restrict\n                the result set size to 64 server profile templates. The maximum number of profile templates\n                is restricted to 256, that is, if user requests more than 256, this will be internally limited to 256.\n                The actual number of items in the response might differ from the\n                requested count if the sum of start and count exceeds the total number of items, or if returning the\n                requested number of items would take too long.\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no filter; all\n                resources are returned. Filters are supported for the name, description, affinity, macType, wwnType,\n                serialNumberType, status, serverHardwareTypeUri, enclosureGroupUri, and firmware.firmwareBaselineUri attributes.\n            sort: The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris: An expression to restrict the resources returned according to the scopes to which they are assigned.\n\n        Returns:\n            list: A list of server profile templates.\n\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, scope_uris=scope_uris)\n\n    def create(self, data=None, uri=None, timeout=-1, force=True):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        for key, value in default_values.items():\n            if not data.get(key):\n                data[key] = value\n\n        resource_data = self._helper.create(data, uri, timeout, force=force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource\n\n    @ensure_resource_client(update_data=True)\n    def update(self, data=None, timeout=-1, force=True):\n        \"\"\"Updates server profile template.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        self.data = self._helper.update(resource, uri, force, timeout)\n\n        return self\n\n    @ensure_resource_client\n    def get_new_profile(self):\n        \"\"\"\n        A profile object will be returned with the configuration based on this template. Specify the profile name and\n        server hardware to assign. If template has any fiber channel connection (which is specified as bootable) but no\n        boot target was defined, that connection will be instantiated as a non-bootable connection. So modify that\n        connection to change it to bootable and to specify the boot target.\n\n        Returns:\n            dict: The server profile resource.\n        \"\"\"\n        uri = \"{}/new-profile\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_transformation(self, server_hardware_type_uri, enclosure_group_uri):\n        \"\"\"\n        Transforms an existing profile template by supplying a new server hardware type and enclosure group or both.\n        A profile template will be returned with a new configuration based on the capabilities of the supplied\n        server hardware type and/or enclosure group. All configured connections will have their port assignments\n        set to 'Auto.'\n        The new profile template can subsequently be used in the update method, but is not guaranteed to pass\n        validation. Any incompatibilities will be flagged when the transformed server profile template is submitted.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            server_hardware_type_uri: The URI of the new server hardware type.\n            enclosure_group_uri: The URI of the new enclosure group.\n\n        Returns:\n            dict: The server profile template resource.\n        \"\"\"\n        query_params = self.TRANSFORMATION_PATH.format(**locals())\n        uri = \"{}{}\".format(self.data[\"uri\"], query_params)\n        return self._helper.do_get(uri)\n\n    def get_available_networks(self, **kwargs):\n        \"\"\"\n        Retrieves the list of Ethernet networks, Fibre Channel networks and network sets that are available\n        to a server profile template along with their respective ports. The scopeUris, serverHardwareTypeUri and\n        enclosureGroupUri parameters should be specified to get the available networks for a new server profile template.\n        The serverHardwareTypeUri, enclosureGroupUri, and profileTemplateUri should be specified to get available\n        networks for an existing server profile template.\n        The scopeUris parameter is ignored when the profileTemplateUri is specified.\n\n        Args:\n            enclosureGroupUri: The URI of the enclosure group is required when the serverHardwareTypeUri\n                specifies a blade server.\n            profileTemplateUri: If the URI of the server profile template is provided the list of available\n                networks will include only networks that share a scope with the server profile template.\n            scopeUris: An expression to restrict the resources returned according to the scopes\n                to which they are assigned.\n            serverHardwareTypeUri: If the server hardware type specifies a rack server, the list of\n                available network includes all networks that are applicable for the specified server hardware type.\n                If the server hardware type specifies a blade server, the enclosureGroupUri parameter must be\n                specified, and the list of available networks includes all networks that are applicable for the\n                specified server hardware type and all empty bays within the enclosure group that can support\n                the specified server hardware type.\n            view: The FunctionType (Ethernet or FibreChannel) to filter the list of networks returned.\n\n        Returns:\n            dict: Dictionary with available networks details.\n        \"\"\"\n        query_string = '&'.join('{}={}'.format(key, value)\n                                for key, value in kwargs.items() if value)\n        uri = self.URI + \"{}?{}\".format(\"/available-networks\", query_string)\n\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(ServerProfileTemplate, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of server profile templates based on optional sorting and filtering and is constrained by start and\n        count parameters.\n\n        Args:\n            start: The first item to return, using 0-based indexing. If not specified, the default\n                is 0 - start with the first available item.\n            count: The number of resources to return. Providing a -1 for the count parameter will restrict\n                the result set size to 64 server profile templates. The maximum number of profile templates\n                is restricted to 256, that is, if user requests more than 256, this will be internally limited to 256.\n                The actual number of items in the response might differ from the\n                requested count if the sum of start and count exceeds the total number of items, or if returning the\n                requested number of items would take too long.\n            filter (list or str): A general filter/query string to narrow the list of items returned. The default is no filter; all\n                resources are returned. Filters are supported for the name, description, affinity, macType, wwnType,\n                serialNumberType, status, serverHardwareTypeUri, enclosureGroupUri, and firmware.firmwareBaselineUri attributes.\n            sort: The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris: An expression to restrict the resources returned according to the scopes to which they are assigned.\n\n        Returns:\n            list: A list of server profile templates.\n\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, scope_uris=scope_uris)",
  "def create(self, data=None, uri=None, timeout=-1, force=True):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            uri: Resouce uri\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        for key, value in default_values.items():\n            if not data.get(key):\n                data[key] = value\n\n        resource_data = self._helper.create(data, uri, timeout, force=force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource",
  "def update(self, data=None, timeout=-1, force=True):\n        \"\"\"Updates server profile template.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        self.data = self._helper.update(resource, uri, force, timeout)\n\n        return self",
  "def get_new_profile(self):\n        \"\"\"\n        A profile object will be returned with the configuration based on this template. Specify the profile name and\n        server hardware to assign. If template has any fiber channel connection (which is specified as bootable) but no\n        boot target was defined, that connection will be instantiated as a non-bootable connection. So modify that\n        connection to change it to bootable and to specify the boot target.\n\n        Returns:\n            dict: The server profile resource.\n        \"\"\"\n        uri = \"{}/new-profile\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_transformation(self, server_hardware_type_uri, enclosure_group_uri):\n        \"\"\"\n        Transforms an existing profile template by supplying a new server hardware type and enclosure group or both.\n        A profile template will be returned with a new configuration based on the capabilities of the supplied\n        server hardware type and/or enclosure group. All configured connections will have their port assignments\n        set to 'Auto.'\n        The new profile template can subsequently be used in the update method, but is not guaranteed to pass\n        validation. Any incompatibilities will be flagged when the transformed server profile template is submitted.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            server_hardware_type_uri: The URI of the new server hardware type.\n            enclosure_group_uri: The URI of the new enclosure group.\n\n        Returns:\n            dict: The server profile template resource.\n        \"\"\"\n        query_params = self.TRANSFORMATION_PATH.format(**locals())\n        uri = \"{}{}\".format(self.data[\"uri\"], query_params)\n        return self._helper.do_get(uri)",
  "def get_available_networks(self, **kwargs):\n        \"\"\"\n        Retrieves the list of Ethernet networks, Fibre Channel networks and network sets that are available\n        to a server profile template along with their respective ports. The scopeUris, serverHardwareTypeUri and\n        enclosureGroupUri parameters should be specified to get the available networks for a new server profile template.\n        The serverHardwareTypeUri, enclosureGroupUri, and profileTemplateUri should be specified to get available\n        networks for an existing server profile template.\n        The scopeUris parameter is ignored when the profileTemplateUri is specified.\n\n        Args:\n            enclosureGroupUri: The URI of the enclosure group is required when the serverHardwareTypeUri\n                specifies a blade server.\n            profileTemplateUri: If the URI of the server profile template is provided the list of available\n                networks will include only networks that share a scope with the server profile template.\n            scopeUris: An expression to restrict the resources returned according to the scopes\n                to which they are assigned.\n            serverHardwareTypeUri: If the server hardware type specifies a rack server, the list of\n                available network includes all networks that are applicable for the specified server hardware type.\n                If the server hardware type specifies a blade server, the enclosureGroupUri parameter must be\n                specified, and the list of available networks includes all networks that are applicable for the\n                specified server hardware type and all empty bays within the enclosure group that can support\n                the specified server hardware type.\n            view: The FunctionType (Ethernet or FibreChannel) to filter the list of networks returned.\n\n        Returns:\n            dict: Dictionary with available networks details.\n        \"\"\"\n        query_string = '&'.join('{}={}'.format(key, value)\n                                for key, value in kwargs.items() if value)\n        uri = self.URI + \"{}?{}\".format(\"/available-networks\", query_string)\n\n        return self._helper.do_get(uri)",
  "class EnclosureGroups(Resource):\n    \"\"\"\n    Enclosure Groups API client.\n\n    \"\"\"\n    URI = '/rest/enclosure-groups'\n\n    def __init__(self, connection, data=None):\n        super(EnclosureGroups, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of enclosure groups.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of enclosure groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter,\n                                    sort=sort, scope_uris=scope_uris)\n\n    @ensure_resource_client\n    def get_script(self):\n        \"\"\"\n        Gets the configuration script of the enclosure-group resource with the specified URI.\n\n        Returns:\n            dict: Configuration script.\n        \"\"\"\n\n        uri = \"{}/script\".format(self.data['uri'])\n\n        return self._helper.do_get(uri)\n\n    def update_script(self, script_body):\n        \"\"\"\n        Updates the configuration script of the enclosure-group with the specified URI.\n\n        Args:\n            id_or_uri: Resource id or resource uri.\n            script_body:  Configuration script.\n\n        Returns:\n            dict: Updated enclosure group.\n        \"\"\"\n        uri = \"{}/script\".format(self.data['uri'])\n\n        return self._helper.update(script_body, uri=uri)",
  "def __init__(self, connection, data=None):\n        super(EnclosureGroups, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a list of enclosure groups.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of enclosure groups.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter,\n                                    sort=sort, scope_uris=scope_uris)",
  "def get_script(self):\n        \"\"\"\n        Gets the configuration script of the enclosure-group resource with the specified URI.\n\n        Returns:\n            dict: Configuration script.\n        \"\"\"\n\n        uri = \"{}/script\".format(self.data['uri'])\n\n        return self._helper.do_get(uri)",
  "def update_script(self, script_body):\n        \"\"\"\n        Updates the configuration script of the enclosure-group with the specified URI.\n\n        Args:\n            id_or_uri: Resource id or resource uri.\n            script_body:  Configuration script.\n\n        Returns:\n            dict: Updated enclosure group.\n        \"\"\"\n        uri = \"{}/script\".format(self.data['uri'])\n\n        return self._helper.update(script_body, uri=uri)",
  "class Connections(object):\n    \"\"\"\n    Connections API client.\n\n    \"\"\"\n\n    URI = '/rest/connections'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', view='', fields=''):\n        \"\"\"\n        Gets a paginated collection of connections based on optional sorting and filtering,\n        and constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            fields:\n                Specifies which fields should be returned in the result set.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by\n                 specifying the name of a predefined view. The default view is expand (show\n                 all attributes of the resource and all elements of collections of resources).\n\n        Returns:\n            list: A list of connections.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, view=view, fields=fields)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all connections that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of connections.\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Returns the connection with the specified ID or URI.\n\n        Args:\n            id: ID or URI of connection\n\n        Returns:\n            dict\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort='', view='', fields=''):\n        \"\"\"\n        Gets a paginated collection of connections based on optional sorting and filtering,\n        and constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            fields:\n                Specifies which fields should be returned in the result set.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by\n                 specifying the name of a predefined view. The default view is expand (show\n                 all attributes of the resource and all elements of collections of resources).\n\n        Returns:\n            list: A list of connections.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, view=view, fields=fields)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all connections that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: A list of connections.\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Returns the connection with the specified ID or URI.\n\n        Args:\n            id: ID or URI of connection\n\n        Returns:\n            dict\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "class ServerProfiles(ResourcePatchMixin, ResourceSchemaMixin, Resource):\n    \"\"\"\n    Server Profile API client.\n\n    \"\"\"\n    URI = '/rest/server-profiles'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"ServerProfileV5\"},\n        '300': {\"type\": \"ServerProfileV6\"},\n        '500': {\"type\": \"ServerProfileV7\"},\n        '600': {\"type\": \"ServerProfileV8\"},\n        '800': {\"type\": \"ServerProfileV9\"},\n        '1000': {\"type\": \"ServerProfileV10\"},\n        '1200': {\"type\": \"ServerProfileV11\"},\n        '1600': {\"type\": \"ServerProfileV12\"},\n        '1800': {\"type\": \"ServerProfileV12\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(ServerProfiles, self).__init__(connection, data)\n\n    def create(self, data=None, timeout=-1, force=''):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        for key, value in default_values.items():\n            if not data.get(key):\n                data[key] = value\n\n        resource_data = self._helper.create(data, timeout=timeout, force=force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource\n\n    @ensure_resource_client(update_data=True)\n    def update(self, data=None, timeout=-1, force=''):\n        \"\"\"Updates server profile template.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        # Removes related fields to serverHardware in case of unassign\n        if resource.get('serverHardwareUri') is None:\n            resource.pop('enclosureBay', None)\n            resource.pop('enclosureUri', None)\n\n        self.data = self._helper.update(resource, uri, force, timeout)\n\n        return self\n\n    def delete_all(self, filter, timeout=-1, force=False):\n        \"\"\"\n        Deletes all Server Profile objects from the appliance that match the provided filter.\n        Filters are supported only for the following profile attributes:  name, description, serialnumber, uuid,\n        mactype, wwntype, serialnumbertype, status, and state.\n\n\n        Examples:\n            >>> server_profile_client.delete_all(filter=\"name='Exchange Server'\")\n            # Remove all profiles that match the name \"Exchange Server\"\n\n            >>> server_profile_client.delete_all(filter=\"name matches'%25Database%25'\")\n            # Remove all profiles that have the word \"Database\" in its name\n\n        The filter function here operates similarly to the function defined for GET Server Profiles. It allows\n        for both actual and partial matches of data in the profile. Any requests that use a wildcard match\n        must include a %25 as illustrated in the previous example. This is how you encode that character for\n        transmission to the appliance.\n\n        Args:\n            filter (dict): Object to delete.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the server profile was successfully deleted.\n        \"\"\"\n        return self._helper.delete_all(filter=filter, force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def get_compliance_preview(self):\n        \"\"\"\n        Gets the preview of manual and automatic updates required to make the server profile\n        consistent with its template.\n\n        Returns:\n            dict: Server profile compliance preview.\n        \"\"\"\n        uri = '{}/compliance-preview'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def get_profile_ports(self, **kwargs):\n        \"\"\"\n        Retrieves the port model associated with a server or server hardware type and enclosure group.\n\n        Args:\n            enclosureGroupUri (str):\n                The URI of the enclosure group associated with the resource.\n            serverHardwareTypeUri (str):\n                The URI of the server hardware type associated with the resource.\n            serverHardwareUri (str):\n                The URI of the server hardware associated with the resource.\n\n        Returns:\n            dict: Profile port.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/profile-ports')\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_messages(self):\n        \"\"\"\n        Retrieves the error or status messages associated with the specified profile.\n\n        Returns:\n            dict: Server Profile Health.\n        \"\"\"\n        uri = '{}/messages'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_transformation(self, **kwargs):\n        \"\"\"\n\n        Transforms an existing profile by supplying a new server hardware type or enclosure group or both.\n        A profile will be returned with a new configuration based on the capabilities of the supplied server hardware\n        type or enclosure group or both. The port assignment for all deployed connections will be set to Auto.\n        Re-selection of the server hardware may also be required. The new profile can subsequently be used for updating\n        the server profile, but passing validation is not guaranteed. Any incompatibilities will be flagged when the\n        transformed server profile is submitted.\n\n        Args:\n            enclosureGroupUri (str):\n                The URI of the enclosure group associated with the resource.\n            serverHardwareTypeUri (str):\n                The URI of the server hardware type associated with the resource.\n            serverHardwareUri (str):\n                The URI of the server hardware associated with the resource.\n\n        Returns:\n            dict: Server Profile.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs,\n                                                       '/transformation',\n                                                       self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def get_available_networks(self, **kwargs):\n        \"\"\"\n        Retrieves the list of Ethernet networks, Fiber Channel networks, and network sets that are available to a\n        server profile, along with their respective ports.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           functionType (str): The FunctionType (Ethernet or FibreChannel) to filter the list of networks returned.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           serverHardwareUri (str): The URI of the server hardware associated with the resource.\n           view (str): Returns a specific subset of the attributes of the resource or collection, by\n               specifying the name of a predefined view. The default view is expand (show all attributes\n               of the resource and all elements of collections of resources).\n\n               Values:\n                   Ethernet\n                       Specifies that the connection is to an Ethernet network or a network set.\n                   FibreChannel\n                       Specifies that the connection is to a Fibre Channel network.\n           profileUri (str): If the URI of the server profile is provided the list of available networks will\n               include only networks that share a scope with the server profile.\n           scopeUris (str): An expression to restrict the resources returned according to the scopes\n               to which they are assigned\n\n        Returns:\n            list: Available networks.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-networks')\n        return self._helper.do_get(uri)\n\n    def get_available_servers(self, **kwargs):\n        \"\"\"\n        Retrieves the list of available servers.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           profileUri (str): The URI of the server profile resource.\n           scopeUris (str): An expression to restrict the resources returned according to\n               the scopes to which they are assigned.\n           filter (list or str): A general filter/query string to narrow the list of items returned.\n               The default is no filter, all resources are returned.\n        Returns:\n            list: Available servers.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-servers')\n        return self._helper.do_get(uri)\n\n    def get_available_storage_system(self, **kwargs):\n        \"\"\"\n        Retrieves a specific storage system and its associated volumes available to the server profile based\n        on the given server hardware type and enclosure group.\n\n        Args:\n           enclosureGroupUri (str):\n               The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str):\n               The URI of the server hardware type associated with the resource.\n           storageSystemId (str):\n               The storage system ID associated with the resource.\n\n        Returns:\n            dict: Available storage system.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-storage-system')\n        return self._helper.do_get(uri)\n\n    def get_available_storage_systems(self, start=0, count=-1, filter='', sort='', **kwargs):\n        \"\"\"\n        Retrieves the list of the storage systems and their associated volumes available to the server profile\n        based on the given server hardware type and enclosure group.\n\n        Args:\n           count:\n               The number of resources to return. A count of -1 requests all items. The actual number of items in\n               the response may differ from the requested count if the sum of start and count exceed the total\n               number of items.\n           start:\n               The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n               first available item.\n           filter (list or str):\n               A general filter/query string to narrow the list of items returned. The default is no filter; all\n               resources are returned.\n           sort:\n               The sort order of the returned data set. By default, the sort order is based on create time, with the\n               oldest entry first.\n           enclosureGroupUri (str):\n               The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str):\n               The URI of the server hardware type associated with the resource.\n\n        Returns:\n            list: Available storage systems.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-storage-systems')\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, uri=uri)\n\n    def get_available_targets(self, **kwargs):\n        \"\"\"\n        Retrieves a list of the target servers and empty device bays that are available for assignment to the server\n        profile.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           profileUri (str): The URI of the server profile associated with the resource.\n           scopeUris (str): An expression to restrict the resources returned according to\n               the scopes to which they are assigned.\n           filter (list or str): A general filter/query string to narrow the list of items returned.\n               The default is no filter, all resources are returned.\n\n        Returns:\n            list: List of available servers and bays.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-targets')\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_new_profile_template(self):\n        \"\"\"\n        Retrieves the profile template for a given server profile.\n\n        Returns:\n            dict: Server profile template.\n        \"\"\"\n        uri = '{}/new-profile-template'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(ServerProfiles, self).__init__(connection, data)",
  "def create(self, data=None, timeout=-1, force=''):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Flag to force the operation\n        Returns:\n            Created resource.\n        \"\"\"\n        if not data:\n            data = {}\n\n        default_values = self._get_default_values()\n        for key, value in default_values.items():\n            if not data.get(key):\n                data[key] = value\n\n        resource_data = self._helper.create(data, timeout=timeout, force=force)\n        new_resource = self.new(self._connection, resource_data)\n\n        return new_resource",
  "def update(self, data=None, timeout=-1, force=''):\n        \"\"\"Updates server profile template.\n\n        Args:\n            data: Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n        uri = self.data['uri']\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        # Removes related fields to serverHardware in case of unassign\n        if resource.get('serverHardwareUri') is None:\n            resource.pop('enclosureBay', None)\n            resource.pop('enclosureUri', None)\n\n        self.data = self._helper.update(resource, uri, force, timeout)\n\n        return self",
  "def delete_all(self, filter, timeout=-1, force=False):\n        \"\"\"\n        Deletes all Server Profile objects from the appliance that match the provided filter.\n        Filters are supported only for the following profile attributes:  name, description, serialnumber, uuid,\n        mactype, wwntype, serialnumbertype, status, and state.\n\n\n        Examples:\n            >>> server_profile_client.delete_all(filter=\"name='Exchange Server'\")\n            # Remove all profiles that match the name \"Exchange Server\"\n\n            >>> server_profile_client.delete_all(filter=\"name matches'%25Database%25'\")\n            # Remove all profiles that have the word \"Database\" in its name\n\n        The filter function here operates similarly to the function defined for GET Server Profiles. It allows\n        for both actual and partial matches of data in the profile. Any requests that use a wildcard match\n        must include a %25 as illustrated in the previous example. This is how you encode that character for\n        transmission to the appliance.\n\n        Args:\n            filter (dict): Object to delete.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the server profile was successfully deleted.\n        \"\"\"\n        return self._helper.delete_all(filter=filter, force=force, timeout=timeout)",
  "def get_compliance_preview(self):\n        \"\"\"\n        Gets the preview of manual and automatic updates required to make the server profile\n        consistent with its template.\n\n        Returns:\n            dict: Server profile compliance preview.\n        \"\"\"\n        uri = '{}/compliance-preview'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_profile_ports(self, **kwargs):\n        \"\"\"\n        Retrieves the port model associated with a server or server hardware type and enclosure group.\n\n        Args:\n            enclosureGroupUri (str):\n                The URI of the enclosure group associated with the resource.\n            serverHardwareTypeUri (str):\n                The URI of the server hardware type associated with the resource.\n            serverHardwareUri (str):\n                The URI of the server hardware associated with the resource.\n\n        Returns:\n            dict: Profile port.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/profile-ports')\n        return self._helper.do_get(uri)",
  "def get_messages(self):\n        \"\"\"\n        Retrieves the error or status messages associated with the specified profile.\n\n        Returns:\n            dict: Server Profile Health.\n        \"\"\"\n        uri = '{}/messages'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_transformation(self, **kwargs):\n        \"\"\"\n\n        Transforms an existing profile by supplying a new server hardware type or enclosure group or both.\n        A profile will be returned with a new configuration based on the capabilities of the supplied server hardware\n        type or enclosure group or both. The port assignment for all deployed connections will be set to Auto.\n        Re-selection of the server hardware may also be required. The new profile can subsequently be used for updating\n        the server profile, but passing validation is not guaranteed. Any incompatibilities will be flagged when the\n        transformed server profile is submitted.\n\n        Args:\n            enclosureGroupUri (str):\n                The URI of the enclosure group associated with the resource.\n            serverHardwareTypeUri (str):\n                The URI of the server hardware type associated with the resource.\n            serverHardwareUri (str):\n                The URI of the server hardware associated with the resource.\n\n        Returns:\n            dict: Server Profile.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs,\n                                                       '/transformation',\n                                                       self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_available_networks(self, **kwargs):\n        \"\"\"\n        Retrieves the list of Ethernet networks, Fiber Channel networks, and network sets that are available to a\n        server profile, along with their respective ports.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           functionType (str): The FunctionType (Ethernet or FibreChannel) to filter the list of networks returned.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           serverHardwareUri (str): The URI of the server hardware associated with the resource.\n           view (str): Returns a specific subset of the attributes of the resource or collection, by\n               specifying the name of a predefined view. The default view is expand (show all attributes\n               of the resource and all elements of collections of resources).\n\n               Values:\n                   Ethernet\n                       Specifies that the connection is to an Ethernet network or a network set.\n                   FibreChannel\n                       Specifies that the connection is to a Fibre Channel network.\n           profileUri (str): If the URI of the server profile is provided the list of available networks will\n               include only networks that share a scope with the server profile.\n           scopeUris (str): An expression to restrict the resources returned according to the scopes\n               to which they are assigned\n\n        Returns:\n            list: Available networks.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-networks')\n        return self._helper.do_get(uri)",
  "def get_available_servers(self, **kwargs):\n        \"\"\"\n        Retrieves the list of available servers.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           profileUri (str): The URI of the server profile resource.\n           scopeUris (str): An expression to restrict the resources returned according to\n               the scopes to which they are assigned.\n           filter (list or str): A general filter/query string to narrow the list of items returned.\n               The default is no filter, all resources are returned.\n        Returns:\n            list: Available servers.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-servers')\n        return self._helper.do_get(uri)",
  "def get_available_storage_system(self, **kwargs):\n        \"\"\"\n        Retrieves a specific storage system and its associated volumes available to the server profile based\n        on the given server hardware type and enclosure group.\n\n        Args:\n           enclosureGroupUri (str):\n               The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str):\n               The URI of the server hardware type associated with the resource.\n           storageSystemId (str):\n               The storage system ID associated with the resource.\n\n        Returns:\n            dict: Available storage system.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-storage-system')\n        return self._helper.do_get(uri)",
  "def get_available_storage_systems(self, start=0, count=-1, filter='', sort='', **kwargs):\n        \"\"\"\n        Retrieves the list of the storage systems and their associated volumes available to the server profile\n        based on the given server hardware type and enclosure group.\n\n        Args:\n           count:\n               The number of resources to return. A count of -1 requests all items. The actual number of items in\n               the response may differ from the requested count if the sum of start and count exceed the total\n               number of items.\n           start:\n               The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n               first available item.\n           filter (list or str):\n               A general filter/query string to narrow the list of items returned. The default is no filter; all\n               resources are returned.\n           sort:\n               The sort order of the returned data set. By default, the sort order is based on create time, with the\n               oldest entry first.\n           enclosureGroupUri (str):\n               The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str):\n               The URI of the server hardware type associated with the resource.\n\n        Returns:\n            list: Available storage systems.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-storage-systems')\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, uri=uri)",
  "def get_available_targets(self, **kwargs):\n        \"\"\"\n        Retrieves a list of the target servers and empty device bays that are available for assignment to the server\n        profile.\n\n        Args:\n           enclosureGroupUri (str): The URI of the enclosure group associated with the resource.\n           serverHardwareTypeUri (str): The URI of the server hardware type associated with the resource.\n           profileUri (str): The URI of the server profile associated with the resource.\n           scopeUris (str): An expression to restrict the resources returned according to\n               the scopes to which they are assigned.\n           filter (list or str): A general filter/query string to narrow the list of items returned.\n               The default is no filter, all resources are returned.\n\n        Returns:\n            list: List of available servers and bays.\n        \"\"\"\n        uri = self._helper.build_uri_with_query_string(kwargs, '/available-targets')\n        return self._helper.do_get(uri)",
  "def get_new_profile_template(self):\n        \"\"\"\n        Retrieves the profile template for a given server profile.\n\n        Returns:\n            dict: Server profile template.\n        \"\"\"\n        uri = '{}/new-profile-template'.format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "class ServerHardware(ResourcePatchMixin, ResourceUtilizationMixin, Resource):\n    \"\"\"\n    The server hardware resource is a representation of a physical server.\n    The server hardware resource provides methods for server management tasks such\n    as applying a profile, importing a server and managing an iLO.\n\n    \"\"\"\n    URI = '/rest/server-hardware'\n\n    def __init__(self, connection, data=None):\n        super(ServerHardware, self).__init__(connection, data)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack-mount server for management by the appliance. This API initiates the asynchronous addition of\n        supported server models.\n\n        Note: Servers in an enclosure are added by adding the enclosure resource. This is\n        only supported on appliances that support rack-mounted servers.\n\n        Args:\n            information (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created rack-mount server.\n        \"\"\"\n        return self.create(information, timeout=timeout)\n\n    def add_multiple_servers(self, information, timeout=-1):\n        \"\"\"\n        Adds multiple rack-mount servers for management by the appliance. This API initiates the asynchronous addition of\n        supported server models.\n\n        Note: Servers in an enclosure are added by adding the enclosure resource. This is\n        only supported on appliances that support rack-mounted servers.\n\n        This is only supported for api version 600\n\n        Args:\n            information (dict): Objects to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created rack-mount servers.\n        \"\"\"\n        uri = \"{}/discovery\".format(self.URI)\n        return self.create(information, uri=uri, timeout=timeout)\n\n    def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the rackserver with the specified URI.\n        Note: This operation is only supported on appliances that support rack-mounted servers.\n\n        Args:\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the resource was successfully removed.\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def get_bios(self):\n        \"\"\"\n        Gets the list of BIOS/UEFI values currently set on the physical server.\n\n        Returns:\n            dict: Dictionary of BIOS/UEFI values.\n        \"\"\"\n        uri = \"{}/bios\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_environmental_configuration(self):\n        \"\"\"\n        Gets the settings that describe the environmental configuration (supported feature set, calibrated minimum and\n        maximum power, location and dimensions, etc.) of the server hardware resource.\n\n        Returns:\n            dict: Environmental configuration settings.\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_environmental_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Sets the calibrated max power of an unmanaged or unsupported server hardware resource.\n\n        Args:\n            configuration (dict): Environmental configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Environmental configuration settings.\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_ilo_sso_url(self, ip=None):\n        \"\"\"\n        Retrieves the URL to launch a Single Sign-On (SSO) session for the iLO web interface. If the server hardware is\n        unsupported, the resulting URL will not use SSO and the iLO web interface will prompt for credentials.\n        This is not supported on G7/iLO3 or earlier servers.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/iloSsoUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)\n\n    def get_all_firmwares(self, filter='', start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Gets a list of firmware inventory across all servers. To filter the returned data, specify a filter\n        expression to select a particular server model, component name, and/or component firmware version.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default is no query; all resources\n                are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of firmware inventory.\n        \"\"\"\n        uri = self.URI + \"/*/firmware\"\n        return self._helper.get_all(start, count, filter, query, sort, '', '', uri)\n\n    @ensure_resource_client\n    def get_firmware(self):\n        \"\"\"\n        Get the firmware inventory of a server.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Returns:\n            dict: Server Hardware firmware.\n        \"\"\"\n        uri = \"{}/firmware\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_java_remote_console_url(self, ip=None):\n        \"\"\"\n        Generates a Single Sign-On (SSO) session for the iLO Java Applet console and returns the URL to launch it.\n        If the server hardware is unmanaged or unsupported, the resulting URL will not use SSO and the iLO Java Applet\n        will prompt for credentials. This is not supported on G7/iLO3 or earlier servers.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/javaRemoteConsoleUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_mp_firware_version(self, timeout=-1):\n        \"\"\"\n        Updates the iLO firmware on a physical server to a minimum ILO firmware version required by OneView to\n        manage the server.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/mpFirmwareVersion\".format(self.data[\"uri\"])\n        return self._helper.do_put(uri, None, timeout, None)\n\n    @ensure_resource_client\n    def update_power_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the server hardware to fix configuration issues.\n\n        Args:\n            configuration (dict): Power state configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/powerState\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri, timeout=timeout)\n\n    @ensure_resource_client\n    def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the server hardware to fix configuration issues.\n\n        Args:\n            configuration: Refresh state configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def get_remote_console_url(self, ip=None, consoleType=None):\n        \"\"\"\n        Generates a Single Sign-On (SSO) session for the iLO Integrated Remote Console Application (IRC) and returns the\n        URL to launch it. If the server hardware is unmanaged or unsupported, the resulting URL will not use SSO and the\n        IRC application will prompt for credentials. Use of this URL requires a previous installation of the iLO IRC and\n        is supported only on Windows clients.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n            consoleType: Type of console requested\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/remoteConsoleUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        elif consoleType:\n            uri = \"{}?consoleType={}\".format(uri, consoleType)\n\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_physical_server_hardware(self):\n        \"\"\"\n        Information describing an 'SDX' partition including a list of physical server blades represented by a server\n        hardware. Used with SDX enclosures only.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/physicalServerHardware\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_local_storage(self, ip=None):\n        \"\"\"\n        Gets the updated version 2 local storage resource for the server, including storage controllers,\n        drives, and volumes.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/localStorageV2\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)\n\n    def check_firmware_compliance(self, configuration, timeout=-1, custom_headers=None):\n        \"\"\"\n        Checks the firmware compliance of a server with the selected firmware baseline.\n        Returns the compliance status of each individual component as well as the overall\n        firmware compliance status of the server.\n\n        Args:\n            configuration: Firmware Compliance Configuration\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/firmware-compliance\".format(self.URI)\n        return self._helper.do_post(uri, configuration, timeout=timeout, custom_headers=custom_headers)\n\n    @ensure_resource_client\n    def validate_server_hardware_for_firmware_update(self):\n        \"\"\"\n        Performs a validation for the prerequisites before firmware update.\n        Checks if the server hardware is in powered off state, No server profile attached to server\n        hardware, server hardware model is Gen10 or above, server hardware has advanced ilo license type.\n\n        \"\"\"\n        state = self.data[\"state\"]\n        server_profile_uri = self.data[\"serverProfileUri\"]\n        power_state = self.data[\"powerState\"]\n        generation = self.data[\"mpModel\"]\n        license_type = self.data[\"mpLicenseType\"]\n\n        validation_error_list = []\n\n        matches = re.findall(\"\\d+$\", generation)\n        if int(matches[0]) < 5:\n            validation_error_list.append(SERVER_HARWARE_BELOW_GEN10)\n        if server_profile_uri:\n            validation_error_list.append(SERVER_PROFILE_ATTACHED)\n        if state == \"UpdatingFirmware\":\n            validation_error_list.append(ONGOING_FIRMWARE_UPDATE)\n        if power_state != \"Off\":\n            validation_error_list.append(SERVER_POWERED_ON)\n        if license_type != \"iLO Advanced\":\n            validation_error_list.append(ILO_ADVANCED_LICENSE_REQUIRED)\n\n        if len(validation_error_list) > 0:\n            raise ValueError(validation_error_list)\n        else:\n            return True\n\n    @ensure_resource_client\n    def perform_firmware_update(self, configuration, timeout=-1, custom_headers=None):\n        \"\"\"\n        Performs a specific patch operation on the firmware settings for the given server.\n        If the server supports the particular operation, the operation is performed and a response is\n        returned to the caller with the results.\n\n        Args:\n            configuration: Firmware Update Configuration\n\n        Returns:\n            Updated Resource\n        \"\"\"\n        uri = \"{}/firmware/settings\".format(self.data[\"uri\"])\n        if self.validate_server_hardware_for_firmware_update():\n            return self.patch_request(uri, configuration, timeout=timeout, custom_headers=custom_headers)",
  "def __init__(self, connection, data=None):\n        super(ServerHardware, self).__init__(connection, data)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack-mount server for management by the appliance. This API initiates the asynchronous addition of\n        supported server models.\n\n        Note: Servers in an enclosure are added by adding the enclosure resource. This is\n        only supported on appliances that support rack-mounted servers.\n\n        Args:\n            information (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created rack-mount server.\n        \"\"\"\n        return self.create(information, timeout=timeout)",
  "def add_multiple_servers(self, information, timeout=-1):\n        \"\"\"\n        Adds multiple rack-mount servers for management by the appliance. This API initiates the asynchronous addition of\n        supported server models.\n\n        Note: Servers in an enclosure are added by adding the enclosure resource. This is\n        only supported on appliances that support rack-mounted servers.\n\n        This is only supported for api version 600\n\n        Args:\n            information (dict): Objects to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created rack-mount servers.\n        \"\"\"\n        uri = \"{}/discovery\".format(self.URI)\n        return self.create(information, uri=uri, timeout=timeout)",
  "def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the rackserver with the specified URI.\n        Note: This operation is only supported on appliances that support rack-mounted servers.\n\n        Args:\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the resource was successfully removed.\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)",
  "def get_bios(self):\n        \"\"\"\n        Gets the list of BIOS/UEFI values currently set on the physical server.\n\n        Returns:\n            dict: Dictionary of BIOS/UEFI values.\n        \"\"\"\n        uri = \"{}/bios\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_environmental_configuration(self):\n        \"\"\"\n        Gets the settings that describe the environmental configuration (supported feature set, calibrated minimum and\n        maximum power, location and dimensions, etc.) of the server hardware resource.\n\n        Returns:\n            dict: Environmental configuration settings.\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def update_environmental_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Sets the calibrated max power of an unmanaged or unsupported server hardware resource.\n\n        Args:\n            configuration (dict): Environmental configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Environmental configuration settings.\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri, timeout=timeout)",
  "def get_ilo_sso_url(self, ip=None):\n        \"\"\"\n        Retrieves the URL to launch a Single Sign-On (SSO) session for the iLO web interface. If the server hardware is\n        unsupported, the resulting URL will not use SSO and the iLO web interface will prompt for credentials.\n        This is not supported on G7/iLO3 or earlier servers.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/iloSsoUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)",
  "def get_all_firmwares(self, filter='', start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Gets a list of firmware inventory across all servers. To filter the returned data, specify a filter\n        expression to select a particular server model, component name, and/or component firmware version.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default is no query; all resources\n                are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of firmware inventory.\n        \"\"\"\n        uri = self.URI + \"/*/firmware\"\n        return self._helper.get_all(start, count, filter, query, sort, '', '', uri)",
  "def get_firmware(self):\n        \"\"\"\n        Get the firmware inventory of a server.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Returns:\n            dict: Server Hardware firmware.\n        \"\"\"\n        uri = \"{}/firmware\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_java_remote_console_url(self, ip=None):\n        \"\"\"\n        Generates a Single Sign-On (SSO) session for the iLO Java Applet console and returns the URL to launch it.\n        If the server hardware is unmanaged or unsupported, the resulting URL will not use SSO and the iLO Java Applet\n        will prompt for credentials. This is not supported on G7/iLO3 or earlier servers.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/javaRemoteConsoleUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)",
  "def update_mp_firware_version(self, timeout=-1):\n        \"\"\"\n        Updates the iLO firmware on a physical server to a minimum ILO firmware version required by OneView to\n        manage the server.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/mpFirmwareVersion\".format(self.data[\"uri\"])\n        return self._helper.do_put(uri, None, timeout, None)",
  "def update_power_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the server hardware to fix configuration issues.\n\n        Args:\n            configuration (dict): Power state configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/powerState\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri, timeout=timeout)",
  "def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the server hardware to fix configuration issues.\n\n        Args:\n            configuration: Refresh state configuration.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data[\"uri\"])\n        return self._helper.update(configuration, uri=uri, timeout=timeout)",
  "def get_remote_console_url(self, ip=None, consoleType=None):\n        \"\"\"\n        Generates a Single Sign-On (SSO) session for the iLO Integrated Remote Console Application (IRC) and returns the\n        URL to launch it. If the server hardware is unmanaged or unsupported, the resulting URL will not use SSO and the\n        IRC application will prompt for credentials. Use of this URL requires a previous installation of the iLO IRC and\n        is supported only on Windows clients.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n            consoleType: Type of console requested\n\n        Returns:\n            URL\n        \"\"\"\n        uri = \"{}/remoteConsoleUrl\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        elif consoleType:\n            uri = \"{}?consoleType={}\".format(uri, consoleType)\n\n        return self._helper.do_get(uri)",
  "def get_physical_server_hardware(self):\n        \"\"\"\n        Information describing an 'SDX' partition including a list of physical server blades represented by a server\n        hardware. Used with SDX enclosures only.\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/physicalServerHardware\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_local_storage(self, ip=None):\n        \"\"\"\n        Gets the updated version 2 local storage resource for the server, including storage controllers,\n        drives, and volumes.\n\n        Args:\n            ip: IP address or host name of the server's iLO management processor\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/localStorageV2\".format(self.data[\"uri\"])\n\n        if ip:\n            uri = \"{}?ip={}\".format(uri, ip)\n\n        return self._helper.do_get(uri)",
  "def check_firmware_compliance(self, configuration, timeout=-1, custom_headers=None):\n        \"\"\"\n        Checks the firmware compliance of a server with the selected firmware baseline.\n        Returns the compliance status of each individual component as well as the overall\n        firmware compliance status of the server.\n\n        Args:\n            configuration: Firmware Compliance Configuration\n\n        Returns:\n            Resource\n        \"\"\"\n        uri = \"{}/firmware-compliance\".format(self.URI)\n        return self._helper.do_post(uri, configuration, timeout=timeout, custom_headers=custom_headers)",
  "def validate_server_hardware_for_firmware_update(self):\n        \"\"\"\n        Performs a validation for the prerequisites before firmware update.\n        Checks if the server hardware is in powered off state, No server profile attached to server\n        hardware, server hardware model is Gen10 or above, server hardware has advanced ilo license type.\n\n        \"\"\"\n        state = self.data[\"state\"]\n        server_profile_uri = self.data[\"serverProfileUri\"]\n        power_state = self.data[\"powerState\"]\n        generation = self.data[\"mpModel\"]\n        license_type = self.data[\"mpLicenseType\"]\n\n        validation_error_list = []\n\n        matches = re.findall(\"\\d+$\", generation)\n        if int(matches[0]) < 5:\n            validation_error_list.append(SERVER_HARWARE_BELOW_GEN10)\n        if server_profile_uri:\n            validation_error_list.append(SERVER_PROFILE_ATTACHED)\n        if state == \"UpdatingFirmware\":\n            validation_error_list.append(ONGOING_FIRMWARE_UPDATE)\n        if power_state != \"Off\":\n            validation_error_list.append(SERVER_POWERED_ON)\n        if license_type != \"iLO Advanced\":\n            validation_error_list.append(ILO_ADVANCED_LICENSE_REQUIRED)\n\n        if len(validation_error_list) > 0:\n            raise ValueError(validation_error_list)\n        else:\n            return True",
  "def perform_firmware_update(self, configuration, timeout=-1, custom_headers=None):\n        \"\"\"\n        Performs a specific patch operation on the firmware settings for the given server.\n        If the server supports the particular operation, the operation is performed and a response is\n        returned to the caller with the results.\n\n        Args:\n            configuration: Firmware Update Configuration\n\n        Returns:\n            Updated Resource\n        \"\"\"\n        uri = \"{}/firmware/settings\".format(self.data[\"uri\"])\n        if self.validate_server_hardware_for_firmware_update():\n            return self.patch_request(uri, configuration, timeout=timeout, custom_headers=custom_headers)",
  "class IdPoolsRanges(object):\n    \"\"\"\n    Base class for Id Pools Ranges API client.\n\n    Has common function used by: vMAC, vSN, vWWN\n    \"\"\"\n\n    def __init__(self, type, con):\n\n        uri = \"\"\n        if type == 'vmac':\n            uri = '/rest/id-pools/vmac/ranges'\n        elif type == 'vsn':\n            uri = '/rest/id-pools/vsn/ranges'\n        elif type == 'vwwn':\n            uri = '/rest/id-pools/vwwn/ranges'\n        else:\n            raise HPEOneViewValueError(\"Invalid type: {0}, types allowed: vmac, vsn, vwwn, \".format(type))\n\n        self._client = ResourceClient(con, uri)\n\n    def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates range.\n\n        Args:\n            resource (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created range.\n        \"\"\"\n        return self._client.create(resource, timeout=timeout)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets range.\n\n        Using the allocator and collector associated with the range, IDs may be allocated from or collected back to the\n        range.\n\n        Args:\n            id_or_uri: Can be either the range ID or URI.\n\n        Returns:\n            dict: Range\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def enable(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Enables or disables a range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: ID or URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n\n        uri = self._client.build_uri(id_or_uri)\n\n        return self._client.update(information, uri, timeout=timeout)\n\n    def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes range.\n\n        Args:\n            resource (dict):\n                Object to delete\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def get_allocated_fragments(self, id_or_uri, count=-1, start=0):\n        \"\"\"\n        Gets all fragments that have been allocated in range.\n\n        Args:\n            id_or_uri:\n                ID or URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the allocated fragements.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/allocated-fragments?start={0}&count={1}\".format(start, count)\n        return self._client.get_collection(uri)\n\n    def allocate(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n\n        The allocator returned contains the list of IDs successfully allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n            id_or_uri:\n                ID or URI of vSN range.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Allocator\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/allocator\"\n\n        return self._client.update(information, uri, timeout=timeout)\n\n    def collect(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Collects a set of IDs back to range.\n\n        The collector returned contains the list of IDs successfully collected.\n\n        Args:\n            information (dict):\n                The list of IDs to be collected\n            id_or_uri:\n                ID or URI of range\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/collector\"\n\n        return self._client.update(information, uri, timeout=timeout)\n\n    def get_free_fragments(self, id_or_uri, count=-1, start=0):\n        \"\"\"\n        Gets all free fragments in a vSN range.\n\n        Args:\n            id_or_uri:\n                ID or URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the free fragments.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/free-fragments?start={0}&count={1}\".format(start, count)\n        return self._client.get_collection(uri)",
  "def __init__(self, type, con):\n\n        uri = \"\"\n        if type == 'vmac':\n            uri = '/rest/id-pools/vmac/ranges'\n        elif type == 'vsn':\n            uri = '/rest/id-pools/vsn/ranges'\n        elif type == 'vwwn':\n            uri = '/rest/id-pools/vwwn/ranges'\n        else:\n            raise HPEOneViewValueError(\"Invalid type: {0}, types allowed: vmac, vsn, vwwn, \".format(type))\n\n        self._client = ResourceClient(con, uri)",
  "def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates range.\n\n        Args:\n            resource (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created range.\n        \"\"\"\n        return self._client.create(resource, timeout=timeout)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets range.\n\n        Using the allocator and collector associated with the range, IDs may be allocated from or collected back to the\n        range.\n\n        Args:\n            id_or_uri: Can be either the range ID or URI.\n\n        Returns:\n            dict: Range\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def enable(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Enables or disables a range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: ID or URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n\n        uri = self._client.build_uri(id_or_uri)\n\n        return self._client.update(information, uri, timeout=timeout)",
  "def delete(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes range.\n\n        Args:\n            resource (dict):\n                Object to delete\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def get_allocated_fragments(self, id_or_uri, count=-1, start=0):\n        \"\"\"\n        Gets all fragments that have been allocated in range.\n\n        Args:\n            id_or_uri:\n                ID or URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the allocated fragements.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/allocated-fragments?start={0}&count={1}\".format(start, count)\n        return self._client.get_collection(uri)",
  "def allocate(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n\n        The allocator returned contains the list of IDs successfully allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n            id_or_uri:\n                ID or URI of vSN range.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Allocator\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/allocator\"\n\n        return self._client.update(information, uri, timeout=timeout)",
  "def collect(self, information, id_or_uri, timeout=-1):\n        \"\"\"\n        Collects a set of IDs back to range.\n\n        The collector returned contains the list of IDs successfully collected.\n\n        Args:\n            information (dict):\n                The list of IDs to be collected\n            id_or_uri:\n                ID or URI of range\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/collector\"\n\n        return self._client.update(information, uri, timeout=timeout)",
  "def get_free_fragments(self, id_or_uri, count=-1, start=0):\n        \"\"\"\n        Gets all free fragments in a vSN range.\n\n        Args:\n            id_or_uri:\n                ID or URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the free fragments.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/free-fragments?start={0}&count={1}\".format(start, count)\n        return self._client.get_collection(uri)",
  "class IdPoolsIpv4Ranges(Resource, ResourceSchemaMixin):\n    \"\"\"\n    The ID pools IPv4 ranges resource provides a Client API for managing IPv4 ranges.\n    \"\"\"\n    URI = '/rest/id-pools/ipv4/ranges'\n\n    def __init__(self, connection, data=None):\n        super(IdPoolsIpv4Ranges, self).__init__(connection, data)\n        self.__default_values = {'type': 'Range'}\n\n    def enable(self, information, uri, timeout=-1):\n        \"\"\"\n        Enables or disables an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated IPv4 range.\n        \"\"\"\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def update_allocator(self, information, uri, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The allocator returned contains the list of IDs successfully allocated.\n        \"\"\"\n        uri = uri + \"/allocator\"\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def update_collector(self, information, uri, timeout=-1):\n        \"\"\"\n        Collects a set of IDs back to an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The collector returned contains the list of IDs successfully collected.\n        \"\"\"\n        uri = uri + \"/collector\"\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def get_allocated_fragments(self, uri, count=-1, start=0):\n        \"\"\"\n        Gets all fragments that have been allocated in range.\n\n        Args:\n            uri:\n                URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the allocated fragements.\n        \"\"\"\n        uri = uri + \"/allocated-fragments?start={0}&count={1}\".format(start, count)\n        return self._helper.get_collection(uri)\n\n    def get_free_fragments(self, uri, count=-1, start=0):\n        \"\"\"\n        Gets all free fragments in an IPv4 range.\n\n        Args:\n            uri:\n                URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the free fragments.\n        \"\"\"\n        uri = uri + \"/free-fragments?start={0}&count={1}\".format(start, count)\n        return self._helper.get_collection(uri)",
  "def __init__(self, connection, data=None):\n        super(IdPoolsIpv4Ranges, self).__init__(connection, data)\n        self.__default_values = {'type': 'Range'}",
  "def enable(self, information, uri, timeout=-1):\n        \"\"\"\n        Enables or disables an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated IPv4 range.\n        \"\"\"\n        return self._helper.update(information, uri, timeout=timeout)",
  "def update_allocator(self, information, uri, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The allocator returned contains the list of IDs successfully allocated.\n        \"\"\"\n        uri = uri + \"/allocator\"\n        return self._helper.update(information, uri, timeout=timeout)",
  "def update_collector(self, information, uri, timeout=-1):\n        \"\"\"\n        Collects a set of IDs back to an IPv4 range.\n\n        Args:\n            information (dict): Information to update.\n            id_or_uri: URI of range.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: The collector returned contains the list of IDs successfully collected.\n        \"\"\"\n        uri = uri + \"/collector\"\n        return self._helper.update(information, uri, timeout=timeout)",
  "def get_allocated_fragments(self, uri, count=-1, start=0):\n        \"\"\"\n        Gets all fragments that have been allocated in range.\n\n        Args:\n            uri:\n                URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the allocated fragements.\n        \"\"\"\n        uri = uri + \"/allocated-fragments?start={0}&count={1}\".format(start, count)\n        return self._helper.get_collection(uri)",
  "def get_free_fragments(self, uri, count=-1, start=0):\n        \"\"\"\n        Gets all free fragments in an IPv4 range.\n\n        Args:\n            uri:\n                URI of range.\n            count:\n                 The number of resources to return. A count of -1 requests all items. The actual number of items in\n                 the response may differ from the requested count if the sum of start and count exceed the total number\n                 of items.\n            start:\n                The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                first available item.\n\n        Returns:\n            list: A list with the free fragments.\n        \"\"\"\n        uri = uri + \"/free-fragments?start={0}&count={1}\".format(start, count)\n        return self._helper.get_collection(uri)",
  "class LogicalEnclosures(ResourcePatchMixin, Resource):\n    \"\"\"\n    The logical enclosure resource provides methods for managing one or more enclosures that are\n    linked or stacked with stacking links.\n\n    \"\"\"\n    URI = '/rest/logical-enclosures'\n\n    def __init__(self, connection, data=None):\n        super(LogicalEnclosures, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Returns a list of logical enclosures matching the specified filter. A maximum of 40 logical enclosures are\n        returned to the caller. Additional calls can be made to retrieve any other logical enclosures matching the\n        filter. Valid filter parameters include attributes of a Logical Enclosure resource.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of logical enclosures.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter,\n                                    sort=sort, scope_uris=scope_uris)\n\n    @ensure_resource_client\n    def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on enclosures for the logical enclosure by ID or URI. This includes\n        running the same configure steps that were performed as part of the enclosure add.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical enclosure.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        updated_configuration = self._helper.update(None, uri, timeout=timeout)\n        self.refresh()\n\n        return updated_configuration\n\n    @ensure_resource_client\n    def get_script(self):\n        \"\"\"\n        Gets the configuration script of the logical enclosure by ID or URI.\n\n        Return:\n            str: Configuration script.\n        \"\"\"\n        uri = \"{}/script\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_script(self, information, timeout=-1):\n        \"\"\"\n        Updates the configuration script of the logical enclosure and on all enclosures in the logical enclosure with\n        the specified ID.\n\n        Args:\n            information: Updated script.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Configuration script.\n        \"\"\"\n        uri = \"{}/script\".format(self.data[\"uri\"])\n        return self._helper.update(information, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def generate_support_dump(self, information, timeout=-1):\n        \"\"\"\n        Generates a support dump for the logical enclosure with the specified ID. A logical enclosure support dump\n        includes content for logical interconnects associated with that logical enclosure. By default, it also contains\n        appliance support dump content.\n\n        Args:\n            information (dict): Information to generate support dump.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Support dump.\n        \"\"\"\n        uri = \"{}/support-dumps\".format(self.data[\"uri\"])\n        return self._helper.create(information, uri=uri, timeout=timeout)\n\n    @ensure_resource_client\n    def update_from_group(self, data=None, timeout=-1):\n        \"\"\"\n        Use this action to make a logical enclosure consistent with the enclosure group when the logical enclosure is\n        in the Inconsistent state.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical enclosure.\n        \"\"\"\n        uri = \"{}/updateFromGroup\".format(self.data[\"uri\"])\n        return self._helper.update(data, uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(LogicalEnclosures, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Returns a list of logical enclosures matching the specified filter. A maximum of 40 logical enclosures are\n        returned to the caller. Additional calls can be made to retrieve any other logical enclosures matching the\n        filter. Valid filter parameters include attributes of a Logical Enclosure resource.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n            list: A list of logical enclosures.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter,\n                                    sort=sort, scope_uris=scope_uris)",
  "def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on enclosures for the logical enclosure by ID or URI. This includes\n        running the same configure steps that were performed as part of the enclosure add.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical enclosure.\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data[\"uri\"])\n        updated_configuration = self._helper.update(None, uri, timeout=timeout)\n        self.refresh()\n\n        return updated_configuration",
  "def get_script(self):\n        \"\"\"\n        Gets the configuration script of the logical enclosure by ID or URI.\n\n        Return:\n            str: Configuration script.\n        \"\"\"\n        uri = \"{}/script\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def update_script(self, information, timeout=-1):\n        \"\"\"\n        Updates the configuration script of the logical enclosure and on all enclosures in the logical enclosure with\n        the specified ID.\n\n        Args:\n            information: Updated script.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Configuration script.\n        \"\"\"\n        uri = \"{}/script\".format(self.data[\"uri\"])\n        return self._helper.update(information, uri=uri, timeout=timeout)",
  "def generate_support_dump(self, information, timeout=-1):\n        \"\"\"\n        Generates a support dump for the logical enclosure with the specified ID. A logical enclosure support dump\n        includes content for logical interconnects associated with that logical enclosure. By default, it also contains\n        appliance support dump content.\n\n        Args:\n            information (dict): Information to generate support dump.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Support dump.\n        \"\"\"\n        uri = \"{}/support-dumps\".format(self.data[\"uri\"])\n        return self._helper.create(information, uri=uri, timeout=timeout)",
  "def update_from_group(self, data=None, timeout=-1):\n        \"\"\"\n        Use this action to make a logical enclosure consistent with the enclosure group when the logical enclosure is\n        in the Inconsistent state.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Logical enclosure.\n        \"\"\"\n        uri = \"{}/updateFromGroup\".format(self.data[\"uri\"])\n        return self._helper.update(data, uri, timeout=timeout)",
  "class RackManager(ResourcePatchMixin, Resource):\n    \"\"\"\n    The rack manager resource provides methods for managing one or more rack managers and its components.\n\n    \"\"\"\n\n    URI = '/rest/rack-managers'\n\n    def __init__(self, connection, data=None):\n        super(RackManager, self).__init__(connection, data)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack manager for management by the appliance.\n\n        Args:\n            information (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created Rack Manager\n        \"\"\"\n        return self.create(information, timeout=timeout)\n\n    def get_all_chassis(self):\n        \"\"\"\n        Gets the list of chassis from all rack managers.\n\n        Returns: List of Chassis\n        \"\"\"\n        uri = self.URI + \"/chassis\"\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_associated_chassis(self):\n        \"\"\"\n        Gets the list of chassis that are part of a rack manager.\n\n        Returns: List of Chassis\n        \"\"\"\n        uri = \"{}/chassis\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def get_a_specific_resource(self, uri):\n        \"\"\"\n        Gets a specific resource that is part of a rack manager.\n\n        Returns:\n            dict: Resource\n        \"\"\"\n        return self._helper.do_get(uri)\n\n    def get_all_managers(self):\n        \"\"\"\n        Gets the list of manager resources from all rack managers.\n\n        Returns: list of managers\n        \"\"\"\n        uri = self.URI + \"/managers\"\n        return self._helper.do_get(uri)\n\n    def get_all_partitions(self):\n        \"\"\"\n        Gets the list of partition resources from all rack managers.\n\n        Returns: List of partitions\n        \"\"\"\n        uri = self.URI + \"/partitions\"\n        return self._helper.do_get(uri)\n\n    def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the rack manager with the specified URI.\n        Note: This operation is only supported on appliances that support rack managers.\n\n        Args:\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the resource was successfully removed.\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)\n\n    @ensure_resource_client\n    def get_environmental_configuration(self):\n        \"\"\"\n        Gets the environmental configuration of a rack manager.\n\n        Returns:\n            dict: Environmental confifuration\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_associated_managers(self):\n        \"\"\"\n        Gets the list of managers that are part of a rack manager.\n\n        Returns: List of Managers\n        \"\"\"\n        uri = \"{}/managers\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_associated_partitions(self):\n        \"\"\"\n        Gets the list of partitions that are part of a rack manager.\n\n        Returns: List of Partitions\n        \"\"\"\n        uri = \"{}/partitions\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def get_remote_support_settings(self):\n        \"\"\"\n        Gets the remote support settings of a rack manager.\n\n        Returns:\n            dict: Environmental confifuration\n        \"\"\"\n        uri = \"{}/remoteSupportSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(RackManager, self).__init__(connection, data)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack manager for management by the appliance.\n\n        Args:\n            information (dict): Object to create\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created Rack Manager\n        \"\"\"\n        return self.create(information, timeout=timeout)",
  "def get_all_chassis(self):\n        \"\"\"\n        Gets the list of chassis from all rack managers.\n\n        Returns: List of Chassis\n        \"\"\"\n        uri = self.URI + \"/chassis\"\n        return self._helper.do_get(uri)",
  "def get_associated_chassis(self):\n        \"\"\"\n        Gets the list of chassis that are part of a rack manager.\n\n        Returns: List of Chassis\n        \"\"\"\n        uri = \"{}/chassis\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_a_specific_resource(self, uri):\n        \"\"\"\n        Gets a specific resource that is part of a rack manager.\n\n        Returns:\n            dict: Resource\n        \"\"\"\n        return self._helper.do_get(uri)",
  "def get_all_managers(self):\n        \"\"\"\n        Gets the list of manager resources from all rack managers.\n\n        Returns: list of managers\n        \"\"\"\n        uri = self.URI + \"/managers\"\n        return self._helper.do_get(uri)",
  "def get_all_partitions(self):\n        \"\"\"\n        Gets the list of partition resources from all rack managers.\n\n        Returns: List of partitions\n        \"\"\"\n        uri = self.URI + \"/partitions\"\n        return self._helper.do_get(uri)",
  "def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the rack manager with the specified URI.\n        Note: This operation is only supported on appliances that support rack managers.\n\n        Args:\n            force (bool):\n                If set to true, the operation completes despite any problems with\n                network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the resource was successfully removed.\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)",
  "def get_environmental_configuration(self):\n        \"\"\"\n        Gets the environmental configuration of a rack manager.\n\n        Returns:\n            dict: Environmental confifuration\n        \"\"\"\n        uri = \"{}/environmentalConfiguration\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_associated_managers(self):\n        \"\"\"\n        Gets the list of managers that are part of a rack manager.\n\n        Returns: List of Managers\n        \"\"\"\n        uri = \"{}/managers\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_associated_partitions(self):\n        \"\"\"\n        Gets the list of partitions that are part of a rack manager.\n\n        Returns: List of Partitions\n        \"\"\"\n        uri = \"{}/partitions\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def get_remote_support_settings(self):\n        \"\"\"\n        Gets the remote support settings of a rack manager.\n\n        Returns:\n            dict: Environmental confifuration\n        \"\"\"\n        uri = \"{}/remoteSupportSettings\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "class MigratableVcDomains(object):\n    \"\"\"\n    The migratable VC domains resource provides methods for migrating Virtual Connect (VC)\n    enclosures into the appliance. The operations are testing compatibility of a VC\n    managed enclosure, retrieving a compatibility report, deleting a\n    compatibility report and migrating a VC managed enclosure into the appliance.\n\n    \"\"\"\n\n    URI = '/rest/migratable-vc-domains'\n\n    def __init__(self, connection):\n        self._connection = connection\n        self._client = ResourceClient(connection, self.URI)\n\n    @staticmethod\n    def make_migration_information(oaIpAddress, oaUsername, oaPassword, vcmUsername, vcmPassword,\n                                   iloLicenseType='OneView', enclosureGroupUri=None):\n        return {\n            'credentials': {\n                'oaIpAddress': oaIpAddress,\n                'oaUsername': oaUsername,\n                'oaPassword': oaPassword,\n                'vcmUsername': vcmUsername,\n                'vcmPassword': vcmPassword,\n                'type': 'EnclosureCredentials'\n            },\n            'iloLicenseType': iloLicenseType,\n            'enclosureGroupUri': enclosureGroupUri,\n            'type': 'migratable-vc-domains',\n            'category': 'migratable-vc-domains'\n        }\n\n    def test_compatibility(self, migrationInformation, timeout=-1):\n        \"\"\"\n        Creates a migration report for an enclosure with a Virtual Connect domain.\n\n        Args:\n           migrationInformation: A dict specifying the enclosure, OA username, OA password, VCM username, and VCM\n               password among other things.  Use make_migration_information to easily create this dict.\n           timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n               OneView; just stops waiting for its completion.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        return self._client.create(migrationInformation, timeout=timeout)\n\n    def get_migration_report(self, id_or_uri):\n        \"\"\"\n        Returns a migration report that has previously been generated.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        return self._client.get(id_or_uri)\n\n    def migrate(self, id_or_uri, timeout=-1):\n        \"\"\"\n        Initiates a migration of an enclosure specified by the ID or URI of a migration report.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n            timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n                OneView; just stops waiting for its completion.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        # create the special payload to tell the VC Migration Manager to migrate the VC domain\n        migrationInformation = {\n            'migrationState': 'Migrated',\n            'type': 'migratable-vc-domains',\n            'category': 'migratable-vc-domains'\n        }\n\n        # call build_uri manually since .update(...) doesn't do it and the URI is not to be included in the body when\n        # requesting a migration\n        complete_uri = self._client.build_uri(id_or_uri)\n\n        return self._client.update(migrationInformation, uri=complete_uri, timeout=timeout)\n\n    def delete(self, id_or_uri, timeout=-1):\n        \"\"\"\n        Deletes a migration report.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n            timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n                OneView; just stops waiting for its completion.\n\n        Returns: bool: Indicates if the migration report was successfully deleted.\n        \"\"\"\n\n        return self._client.delete(id_or_uri, timeout=timeout)",
  "def __init__(self, connection):\n        self._connection = connection\n        self._client = ResourceClient(connection, self.URI)",
  "def make_migration_information(oaIpAddress, oaUsername, oaPassword, vcmUsername, vcmPassword,\n                                   iloLicenseType='OneView', enclosureGroupUri=None):\n        return {\n            'credentials': {\n                'oaIpAddress': oaIpAddress,\n                'oaUsername': oaUsername,\n                'oaPassword': oaPassword,\n                'vcmUsername': vcmUsername,\n                'vcmPassword': vcmPassword,\n                'type': 'EnclosureCredentials'\n            },\n            'iloLicenseType': iloLicenseType,\n            'enclosureGroupUri': enclosureGroupUri,\n            'type': 'migratable-vc-domains',\n            'category': 'migratable-vc-domains'\n        }",
  "def test_compatibility(self, migrationInformation, timeout=-1):\n        \"\"\"\n        Creates a migration report for an enclosure with a Virtual Connect domain.\n\n        Args:\n           migrationInformation: A dict specifying the enclosure, OA username, OA password, VCM username, and VCM\n               password among other things.  Use make_migration_information to easily create this dict.\n           timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n               OneView; just stops waiting for its completion.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        return self._client.create(migrationInformation, timeout=timeout)",
  "def get_migration_report(self, id_or_uri):\n        \"\"\"\n        Returns a migration report that has previously been generated.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        return self._client.get(id_or_uri)",
  "def migrate(self, id_or_uri, timeout=-1):\n        \"\"\"\n        Initiates a migration of an enclosure specified by the ID or URI of a migration report.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n            timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n                OneView; just stops waiting for its completion.\n\n        Returns: dict: a migration report.\n        \"\"\"\n\n        # create the special payload to tell the VC Migration Manager to migrate the VC domain\n        migrationInformation = {\n            'migrationState': 'Migrated',\n            'type': 'migratable-vc-domains',\n            'category': 'migratable-vc-domains'\n        }\n\n        # call build_uri manually since .update(...) doesn't do it and the URI is not to be included in the body when\n        # requesting a migration\n        complete_uri = self._client.build_uri(id_or_uri)\n\n        return self._client.update(migrationInformation, uri=complete_uri, timeout=timeout)",
  "def delete(self, id_or_uri, timeout=-1):\n        \"\"\"\n        Deletes a migration report.\n\n        Args:\n            id_or_uri: ID or URI of the migration report.\n            timeout: Timeout in seconds.  Waits for task completion by default.  The timeout does not abort the task in\n                OneView; just stops waiting for its completion.\n\n        Returns: bool: Indicates if the migration report was successfully deleted.\n        \"\"\"\n\n        return self._client.delete(id_or_uri, timeout=timeout)",
  "class IdPoolsIpv4Subnets(Resource):\n    \"\"\"\n    The ID pools IPv4 subnets resource provides a Client API for managing IPv4 subnets.\n    \"\"\"\n\n    URI = '/rest/id-pools/ipv4/subnets'\n\n    def __init__(self, connection, data=None):\n        super(IdPoolsIpv4Subnets, self).__init__(connection, data)\n        self.__default_values = {'type': 'Subnet'}\n\n    def allocate(self, information, subnet_id, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n        The allocator returned contains the list of IDs successfully allocated.\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n            subnet_id:\n                IPv4 subnet id.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(subnet_id) + '/allocator'\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def collect(self, information, subnet_id, timeout=-1):\n        \"\"\"\n        Collects one or more IDs to be returned to a pool.\n        Args:\n            information (dict):\n                The list of IDs to be collected\n            subnet_id:\n                IPv4 subnet id\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._helper.build_uri(subnet_id) + '/collector'\n        return self._helper.update(information, uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(IdPoolsIpv4Subnets, self).__init__(connection, data)\n        self.__default_values = {'type': 'Subnet'}",
  "def allocate(self, information, subnet_id, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n        The allocator returned contains the list of IDs successfully allocated.\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n            subnet_id:\n                IPv4 subnet id.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(subnet_id) + '/allocator'\n        return self._helper.update(information, uri, timeout=timeout)",
  "def collect(self, information, subnet_id, timeout=-1):\n        \"\"\"\n        Collects one or more IDs to be returned to a pool.\n        Args:\n            information (dict):\n                The list of IDs to be collected\n            subnet_id:\n                IPv4 subnet id\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._helper.build_uri(subnet_id) + '/collector'\n        return self._helper.update(information, uri, timeout=timeout)",
  "class Enclosures(ResourcePatchMixin, ResourceZeroBodyMixin, ResourceUtilizationMixin, Resource):\n    \"\"\"\n    Enclosures API client.\n\n    \"\"\"\n    URI = '/rest/enclosures'\n\n    def __init__(self, connection, data=None):\n        super(Enclosures, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a paginated collection of Enclosures. The collection is based on optional sorting and filtering, and\n        constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Enclosures.\n        \"\"\"\n        result = self._helper.get_all(start=start,\n                                      count=count,\n                                      filter=filter,\n                                      sort=sort,\n                                      scope_uris=scope_uris)\n\n        return result\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        C7000:\n            Takes information about an enclosure (for example: IP address, username, password) and uses\n            it to claim/configure the enclosure and add its components to the appliance.\n\n        Synergy:\n            Adds a remote enclosure and all the enclosures linked to that enclosure by their frame link\n            modules. The remote enclosures' frame link modules must not be claimed by another appliance.\n            The IP used must be the frame link module's Link Local IPv6 address.\n\n        Args:\n            information: Enclosure information to add.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Enclosure.\n\n        \"\"\"\n        return self.create(data=information, timeout=timeout)\n\n    def remove(self, force=False):\n        \"\"\"\n        Remove enclosure\n        \"\"\"\n        self.delete(force=force)\n\n    def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on the enclosure. This includes running the same configure steps\n        that were performed as part of the enclosure add.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Enclosure\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data['uri'])\n        return self.update_with_zero_body(uri=uri, timeout=timeout)\n\n    def get_by_hostname(self, hostname):\n        \"\"\"Get enclosure by it's hostname\"\"\"\n        def filter_by_hostname(hostname, enclosure):\n            is_primary_ip = ('activeOaPreferredIP' in enclosure and enclosure['activeOaPreferredIP'] == hostname)\n            is_standby_ip = ('standbyOaPreferredIP' in enclosure and enclosure['standbyOaPreferredIP'] == hostname)\n            return is_primary_ip or is_standby_ip\n\n        enclosures = self.get_all()\n        result = [x for x in enclosures if filter_by_hostname(hostname, x)]\n\n        if result:\n            new_resource = self.new(self._connection, result[0])\n        else:\n            new_resource = None\n\n        return new_resource\n\n    @ensure_resource_client\n    def get_environmental_configuration(self):\n        \"\"\"\n        Gets the settings that describe the environmental configuration (supported feature set, calibrated minimum &\n        maximum power, location & dimensions, ...) of the enclosure resource.\n\n        Returns:\n            Settings that describe the environmental configuration.\n        \"\"\"\n        uri = '{}/environmentalConfiguration'.format(self.data['uri'])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def update_environmental_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Sets the calibrated max power of an unmanaged or unsupported enclosure.\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Settings that describe the environmental configuration.\n        \"\"\"\n        uri = '{}/environmentalConfiguration'.format(self.data['uri'])\n        return self._helper.do_put(uri, configuration, timeout, None)\n\n    @ensure_resource_client\n    def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the enclosure along with all of its components, including interconnects and servers. Any new\n        hardware is added and any hardware that is no longer present within the enclosure is removed. The\n        configuration dict must have the \"refreshState\" field set to \"Refreshing\" and optionally\n        provide information to re-claim the enclosure (for example: IP address, user name, password, etc.).\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Enclosure\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data['uri'])\n        return self._helper.do_put(uri, configuration, timeout, None)\n\n    @ensure_resource_client\n    def get_sso(self, role):\n        \"\"\"\n        Builds the SSO (Single Sign-On) URL parameters for the specified enclosure. This allows the user to\n        log in to the enclosure without providing credentials. This API is currently only supported by C7000 enclosures.\n\n        Args:\n            role: Role\n\n        Returns:\n            SSO (Single Sign-On) URL parameters.\n        \"\"\"\n        uri = \"{}/sso?role={}\".format(self.data['uri'], role)\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def generate_csr(self, csr_data, bay_number=None):\n        \"\"\"\n        Creates a Certificate Signing Request (CSR) for an enclosure.\n\n        Args:\n            csr_data: Dictionary with csr details.\n            bay_number: OA from which the CSR should be generated.\n\n        Returns:\n            Enclosure.\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        headers = {'Content-Type': 'application/json'}\n\n        return self._helper.do_post(uri, csr_data, -1, headers)\n\n    @ensure_resource_client\n    def get_csr(self, bay_number=None):\n        \"\"\"\n        Get an enclosure's Certificate Signing Request (CSR) that was generated by previous POST to the same URI.\n\n        Args:\n            bay_number: OA to retrieve the previously generated CSR.\n\n        Returns:\n            dict\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def import_certificate(self, certificate_data, bay_number=None):\n        \"\"\"\n        Imports a signed server certificate into the enclosure.\n\n        Args:\n            certificate_data: Dictionary with Signed certificate and type.\n            bay_number: OA to which the signed certificate will be imported.\n\n        Returns:\n            Enclosure.\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        headers = {'Content-Type': 'application/json'}\n        return self._helper.do_put(uri, certificate_data, -1, headers)",
  "def __init__(self, connection, data=None):\n        super(Enclosures, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', scope_uris=''):\n        \"\"\"\n        Gets a paginated collection of Enclosures. The collection is based on optional sorting and filtering, and\n        constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Enclosures.\n        \"\"\"\n        result = self._helper.get_all(start=start,\n                                      count=count,\n                                      filter=filter,\n                                      sort=sort,\n                                      scope_uris=scope_uris)\n\n        return result",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        C7000:\n            Takes information about an enclosure (for example: IP address, username, password) and uses\n            it to claim/configure the enclosure and add its components to the appliance.\n\n        Synergy:\n            Adds a remote enclosure and all the enclosures linked to that enclosure by their frame link\n            modules. The remote enclosures' frame link modules must not be claimed by another appliance.\n            The IP used must be the frame link module's Link Local IPv6 address.\n\n        Args:\n            information: Enclosure information to add.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Enclosure.\n\n        \"\"\"\n        return self.create(data=information, timeout=timeout)",
  "def remove(self, force=False):\n        \"\"\"\n        Remove enclosure\n        \"\"\"\n        self.delete(force=force)",
  "def update_configuration(self, timeout=-1):\n        \"\"\"\n        Reapplies the appliance's configuration on the enclosure. This includes running the same configure steps\n        that were performed as part of the enclosure add.\n\n        Args:\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Enclosure\n        \"\"\"\n        uri = \"{}/configuration\".format(self.data['uri'])\n        return self.update_with_zero_body(uri=uri, timeout=timeout)",
  "def get_by_hostname(self, hostname):\n        \"\"\"Get enclosure by it's hostname\"\"\"\n        def filter_by_hostname(hostname, enclosure):\n            is_primary_ip = ('activeOaPreferredIP' in enclosure and enclosure['activeOaPreferredIP'] == hostname)\n            is_standby_ip = ('standbyOaPreferredIP' in enclosure and enclosure['standbyOaPreferredIP'] == hostname)\n            return is_primary_ip or is_standby_ip\n\n        enclosures = self.get_all()\n        result = [x for x in enclosures if filter_by_hostname(hostname, x)]\n\n        if result:\n            new_resource = self.new(self._connection, result[0])\n        else:\n            new_resource = None\n\n        return new_resource",
  "def get_environmental_configuration(self):\n        \"\"\"\n        Gets the settings that describe the environmental configuration (supported feature set, calibrated minimum &\n        maximum power, location & dimensions, ...) of the enclosure resource.\n\n        Returns:\n            Settings that describe the environmental configuration.\n        \"\"\"\n        uri = '{}/environmentalConfiguration'.format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def update_environmental_configuration(self, configuration, timeout=-1):\n        \"\"\"\n        Sets the calibrated max power of an unmanaged or unsupported enclosure.\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Settings that describe the environmental configuration.\n        \"\"\"\n        uri = '{}/environmentalConfiguration'.format(self.data['uri'])\n        return self._helper.do_put(uri, configuration, timeout, None)",
  "def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes the enclosure along with all of its components, including interconnects and servers. Any new\n        hardware is added and any hardware that is no longer present within the enclosure is removed. The\n        configuration dict must have the \"refreshState\" field set to \"Refreshing\" and optionally\n        provide information to re-claim the enclosure (for example: IP address, user name, password, etc.).\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            Enclosure\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data['uri'])\n        return self._helper.do_put(uri, configuration, timeout, None)",
  "def get_sso(self, role):\n        \"\"\"\n        Builds the SSO (Single Sign-On) URL parameters for the specified enclosure. This allows the user to\n        log in to the enclosure without providing credentials. This API is currently only supported by C7000 enclosures.\n\n        Args:\n            role: Role\n\n        Returns:\n            SSO (Single Sign-On) URL parameters.\n        \"\"\"\n        uri = \"{}/sso?role={}\".format(self.data['uri'], role)\n        return self._helper.do_get(uri)",
  "def generate_csr(self, csr_data, bay_number=None):\n        \"\"\"\n        Creates a Certificate Signing Request (CSR) for an enclosure.\n\n        Args:\n            csr_data: Dictionary with csr details.\n            bay_number: OA from which the CSR should be generated.\n\n        Returns:\n            Enclosure.\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        headers = {'Content-Type': 'application/json'}\n\n        return self._helper.do_post(uri, csr_data, -1, headers)",
  "def get_csr(self, bay_number=None):\n        \"\"\"\n        Get an enclosure's Certificate Signing Request (CSR) that was generated by previous POST to the same URI.\n\n        Args:\n            bay_number: OA to retrieve the previously generated CSR.\n\n        Returns:\n            dict\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        return self._helper.do_get(uri)",
  "def import_certificate(self, certificate_data, bay_number=None):\n        \"\"\"\n        Imports a signed server certificate into the enclosure.\n\n        Args:\n            certificate_data: Dictionary with Signed certificate and type.\n            bay_number: OA to which the signed certificate will be imported.\n\n        Returns:\n            Enclosure.\n        \"\"\"\n        uri = \"{}/https/certificaterequest\".format(self.data['uri'])\n\n        if bay_number:\n            uri += \"?bayNumber=%d\" % (bay_number)\n\n        headers = {'Content-Type': 'application/json'}\n        return self._helper.do_put(uri, certificate_data, -1, headers)",
  "def filter_by_hostname(hostname, enclosure):\n            is_primary_ip = ('activeOaPreferredIP' in enclosure and enclosure['activeOaPreferredIP'] == hostname)\n            is_standby_ip = ('standbyOaPreferredIP' in enclosure and enclosure['standbyOaPreferredIP'] == hostname)\n            return is_primary_ip or is_standby_ip",
  "class IdPools(Resource, ResourceSchemaMixin):\n    \"\"\"\n    Class for Id Pools API client.\n    \"\"\"\n    URI = '/rest/id-pools'\n\n    def __init__(self, connection, data=None):\n        super(IdPools, self).__init__(connection, data)\n\n    def get_pool_type(self, pool_type):\n        \"\"\"\n        Gets a pool along with the list of ranges present in it\n\n        Args:\n          pool_type: Id pool type\n\n        Returns:\n          dict: List of ranges\n        \"\"\"\n        uri = self._helper.build_uri(pool_type)\n        return super(IdPools, self).get_by_uri(uri)\n\n    def update_pool_type(self, data, pool_type, timeout=-1):\n        \"\"\"\n        Enables or disables the pool\n\n        Args:\n          data: List of ID ranges\n          pool_type: Id pool type\n\n        Returns:\n            dict: Updated Resource.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type)\n        return self._helper.update(data, uri, timeout=timeout)\n\n    def validate_id_pool(self, pool_type, ids_pools):\n        \"\"\"\n        Validates an ID pool.\n\n        Args:\n            pool_type: Id pool type\n\n            ids_pools (list):\n                List of Id Pools.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/validate?idList=\" + \"&idList=\".join(ids_pools)\n        return super(IdPools, self).get_by_uri(uri)\n\n    def validate(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Validates a set of user specified IDs to reserve in the pool.\n\n        This API can be used to check if the specified IDs can be allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/validate\"\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def allocate(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n\n        The allocator returned contains the list of IDs successfully allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/allocator\"\n\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def collect(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Collects one or more IDs to be returned to a pool.\n\n        Args:\n            information (dict):\n                The list of IDs to be collected\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/collector\"\n\n        return self._helper.update(information, uri, timeout=timeout)\n\n    def get_check_range_availability(self, pool_type, ids_pools):\n        \"\"\"\n        Checks the range availability in the ID pool.\n\n        Args:\n            pool_type: Id pool type\n\n            ids_pools (list):\n                List of Id Pools.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/checkrangeavailability?idList=\" + \"&idList=\".join(ids_pools)\n        return super(IdPools, self).get_by_uri(uri)\n\n    def generate(self, pool_type):\n        \"\"\"\n        Generates and returns a random range.\n\n        Args:\n            pool_type: Id pool type\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/generate\"\n        return super(IdPools, self).get_by_uri(uri)",
  "def __init__(self, connection, data=None):\n        super(IdPools, self).__init__(connection, data)",
  "def get_pool_type(self, pool_type):\n        \"\"\"\n        Gets a pool along with the list of ranges present in it\n\n        Args:\n          pool_type: Id pool type\n\n        Returns:\n          dict: List of ranges\n        \"\"\"\n        uri = self._helper.build_uri(pool_type)\n        return super(IdPools, self).get_by_uri(uri)",
  "def update_pool_type(self, data, pool_type, timeout=-1):\n        \"\"\"\n        Enables or disables the pool\n\n        Args:\n          data: List of ID ranges\n          pool_type: Id pool type\n\n        Returns:\n            dict: Updated Resource.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type)\n        return self._helper.update(data, uri, timeout=timeout)",
  "def validate_id_pool(self, pool_type, ids_pools):\n        \"\"\"\n        Validates an ID pool.\n\n        Args:\n            pool_type: Id pool type\n\n            ids_pools (list):\n                List of Id Pools.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/validate?idList=\" + \"&idList=\".join(ids_pools)\n        return super(IdPools, self).get_by_uri(uri)",
  "def validate(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Validates a set of user specified IDs to reserve in the pool.\n\n        This API can be used to check if the specified IDs can be allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/validate\"\n        return self._helper.update(information, uri, timeout=timeout)",
  "def allocate(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Allocates a set of IDs from range.\n\n        The allocator returned contains the list of IDs successfully allocated.\n\n        Args:\n            information (dict):\n                Information to update. Can result in system specified IDs or the system reserving user-specified IDs.\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/allocator\"\n\n        return self._helper.update(information, uri, timeout=timeout)",
  "def collect(self, information, pool_type, timeout=-1):\n        \"\"\"\n        Collects one or more IDs to be returned to a pool.\n\n        Args:\n            information (dict):\n                The list of IDs to be collected\n\n            pool_type: Id pool type\n\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Collector containing list of collected IDs successfully collected.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/collector\"\n\n        return self._helper.update(information, uri, timeout=timeout)",
  "def get_check_range_availability(self, pool_type, ids_pools):\n        \"\"\"\n        Checks the range availability in the ID pool.\n\n        Args:\n            pool_type: Id pool type\n\n            ids_pools (list):\n                List of Id Pools.\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/checkrangeavailability?idList=\" + \"&idList=\".join(ids_pools)\n        return super(IdPools, self).get_by_uri(uri)",
  "def generate(self, pool_type):\n        \"\"\"\n        Generates and returns a random range.\n\n        Args:\n            pool_type: Id pool type\n\n        Returns:\n            dict: A dict containing a list with IDs.\n        \"\"\"\n        uri = self._helper.build_uri(pool_type) + \"/generate\"\n        return super(IdPools, self).get_by_uri(uri)",
  "class ApplianceSshAccess(Resource):\n    \"\"\"\n    ApplianceSshAccess API Client.\n    \"\"\"\n    URI = \"/rest/appliance/ssh-access\"\n\n    def __init__(self, connection, data=None):\n        super(ApplianceSshAccess, self).__init__(connection, data)\n        self.__default_values = {'type': 'SshAccess'}\n\n    def get_all(self):\n        return super(ApplianceSshAccess, self).get_by_uri(self.URI)",
  "def __init__(self, connection, data=None):\n        super(ApplianceSshAccess, self).__init__(connection, data)\n        self.__default_values = {'type': 'SshAccess'}",
  "def get_all(self):\n        return super(ApplianceSshAccess, self).get_by_uri(self.URI)",
  "class ApplianceNodeInformation(Resource):\n    \"\"\"\n    The nodeinfo resource manager provides REST APIs to\n    retrieve information about the nodes of the appliance.\n\n    \"\"\"\n    URI = '/rest/appliance/nodeinfo'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceNodeInformation, self).__init__(connection, data)\n\n    def get_status(self):\n        \"\"\"\n        Retrieves node's status information\n\n        Returns:\n            dict: Node's status information\n        \"\"\"\n        uri = self.URI + '/status'\n        return super(ApplianceNodeInformation, self).get_by_uri(uri)\n\n    def get_version(self):\n        \"\"\"\n        Retrieves node's version information\n\n        Returns:\n            dict: Node's version information\n        \"\"\"\n        uri = self.URI + '/version'\n        return super(ApplianceNodeInformation, self).get_by_uri(uri)",
  "def __init__(self, connection, data=None):\n        super(ApplianceNodeInformation, self).__init__(connection, data)",
  "def get_status(self):\n        \"\"\"\n        Retrieves node's status information\n\n        Returns:\n            dict: Node's status information\n        \"\"\"\n        uri = self.URI + '/status'\n        return super(ApplianceNodeInformation, self).get_by_uri(uri)",
  "def get_version(self):\n        \"\"\"\n        Retrieves node's version information\n\n        Returns:\n            dict: Node's version information\n        \"\"\"\n        uri = self.URI + '/version'\n        return super(ApplianceNodeInformation, self).get_by_uri(uri)",
  "class ApplianceDeviceSNMPv1TrapDestinations(Resource):\n    \"\"\"\n    ApplianceDeviceSNMPv1TrapDestinations API client.\n    The appliance has the ability to forward events received from monitored or managed\n    server hardware to the specified destinations as SNMPv1 traps.\n    \"\"\"\n    URI = '/rest/appliance/trap-destinations'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv1TrapDestinations, self).__init__(connection, data)\n\n    def get_by_name(self, destination_address):\n        \"\"\"Retrieves a resource by its destination.\n\n        Args:\n            destination_address: Resource destination address.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv1TrapDestinations, self).get_by_field('destination', destination_address)\n\n    def create_validation(self, destination, community_string, uri, timeout=-1):\n        \"\"\"\n        Validate whether a hostname or ip address is a valid trap destination.\n        If validation fails, it returns an error identifying the problem that occurred.\n\n        Args:\n            destination (str): destination ip address.\n            community_string (str) - community string for the snmpv1 trap\n            uri - uri of the snmpv1 trap destination\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            Returns error message if destination already exists.\n\n        \"\"\"\n        data = dict(\n            destination=destination,\n            communityString=community_string,\n            uri=uri\n        )\n        validation_uri = \"{}/validation\".format(self.URI)\n        return self._helper.create(data, uri=validation_uri, timeout=timeout)\n\n    def create(self, data, id=None, timeout=-1):\n        \"\"\"\n        Adds the specified trap forwarding destination.\n        The trap destination associated with the specified id will be created if trap destination with that id does not exists.\n        The id can only be an integer greater than 0.\n\n        Args:\n            data (dict): Object to create.\n            id: id of the resource to be created\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            dict: Created resource.\n\n        \"\"\"\n        if not id:\n            available_id = self.__get_first_available_id()\n            uri = '{}/{}'.format(self.URI, available_id)\n        else:\n            uri = '{}/{}'.format(self.URI, id)\n\n        self.create_validation(data['destination'], data['communityString'], uri)\n        return super(ApplianceDeviceSNMPv1TrapDestinations, self).create(data, uri=uri, timeout=timeout)\n\n    def __findFirstMissing(self, array, start, end):\n        \"\"\"\n        Find the smallest elements missing in a sorted array.\n\n        Args:\n            array - list if ids\n            start - starting index\n            end - ending index\n\n        Returns:\n            int: The smallest element missing.\n        \"\"\"\n        if (start > end):\n            return end + 1\n\n        if (start != array[start]):\n            return start\n\n        mid = int((start + end) / 2)\n\n        if (array[mid] == mid):\n            return self.__findFirstMissing(array, mid + 1, end)\n\n        return self.__findFirstMissing(array, start, mid)\n\n    def __get_first_available_id(self):\n        \"\"\"\n        Private method to get the first available id.\n        The id can only be an integer greater than 0.\n\n        Returns:\n            int: The first available id\n        \"\"\"\n        traps = self._helper.get_all()\n        if traps:\n            used_ids = [0]\n            for trap in traps:\n                used_uris = trap.get('uri')\n                used_ids.append(int(used_uris.split('/')[-1]))\n            used_ids.sort()\n            return self.__findFirstMissing(used_ids, 0, len(used_ids) - 1)\n        else:\n            return 1",
  "def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv1TrapDestinations, self).__init__(connection, data)",
  "def get_by_name(self, destination_address):\n        \"\"\"Retrieves a resource by its destination.\n\n        Args:\n            destination_address: Resource destination address.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv1TrapDestinations, self).get_by_field('destination', destination_address)",
  "def create_validation(self, destination, community_string, uri, timeout=-1):\n        \"\"\"\n        Validate whether a hostname or ip address is a valid trap destination.\n        If validation fails, it returns an error identifying the problem that occurred.\n\n        Args:\n            destination (str): destination ip address.\n            community_string (str) - community string for the snmpv1 trap\n            uri - uri of the snmpv1 trap destination\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            Returns error message if destination already exists.\n\n        \"\"\"\n        data = dict(\n            destination=destination,\n            communityString=community_string,\n            uri=uri\n        )\n        validation_uri = \"{}/validation\".format(self.URI)\n        return self._helper.create(data, uri=validation_uri, timeout=timeout)",
  "def create(self, data, id=None, timeout=-1):\n        \"\"\"\n        Adds the specified trap forwarding destination.\n        The trap destination associated with the specified id will be created if trap destination with that id does not exists.\n        The id can only be an integer greater than 0.\n\n        Args:\n            data (dict): Object to create.\n            id: id of the resource to be created\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            dict: Created resource.\n\n        \"\"\"\n        if not id:\n            available_id = self.__get_first_available_id()\n            uri = '{}/{}'.format(self.URI, available_id)\n        else:\n            uri = '{}/{}'.format(self.URI, id)\n\n        self.create_validation(data['destination'], data['communityString'], uri)\n        return super(ApplianceDeviceSNMPv1TrapDestinations, self).create(data, uri=uri, timeout=timeout)",
  "def __findFirstMissing(self, array, start, end):\n        \"\"\"\n        Find the smallest elements missing in a sorted array.\n\n        Args:\n            array - list if ids\n            start - starting index\n            end - ending index\n\n        Returns:\n            int: The smallest element missing.\n        \"\"\"\n        if (start > end):\n            return end + 1\n\n        if (start != array[start]):\n            return start\n\n        mid = int((start + end) / 2)\n\n        if (array[mid] == mid):\n            return self.__findFirstMissing(array, mid + 1, end)\n\n        return self.__findFirstMissing(array, start, mid)",
  "def __get_first_available_id(self):\n        \"\"\"\n        Private method to get the first available id.\n        The id can only be an integer greater than 0.\n\n        Returns:\n            int: The first available id\n        \"\"\"\n        traps = self._helper.get_all()\n        if traps:\n            used_ids = [0]\n            for trap in traps:\n                used_uris = trap.get('uri')\n                used_ids.append(int(used_uris.split('/')[-1]))\n            used_ids.sort()\n            return self.__findFirstMissing(used_ids, 0, len(used_ids) - 1)\n        else:\n            return 1",
  "class ApplianceTimeAndLocaleConfiguration(Resource):\n    \"\"\"\n    ApplianceTimeAndLocaleConfiguration API client.\n\n    \"\"\"\n    URI = '/rest/appliance/configuration/time-locale'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceTimeAndLocaleConfiguration, self).__init__(connection, data)\n        self.__default_values = {\n            \"type\": \"TimeAndLocale\"\n        }\n\n    def get_all(self):\n        return super(ApplianceTimeAndLocaleConfiguration, self).get_by_uri(self.URI)",
  "def __init__(self, connection, data=None):\n        super(ApplianceTimeAndLocaleConfiguration, self).__init__(connection, data)\n        self.__default_values = {\n            \"type\": \"TimeAndLocale\"\n        }",
  "def get_all(self):\n        return super(ApplianceTimeAndLocaleConfiguration, self).get_by_uri(self.URI)",
  "class FirmwareDrivers(ResourceSchemaMixin, Resource):\n    \"\"\"\n    The firmware drivers resource managers provides REST APIs to retrieve the firmware bundle inventory data.\n    Note: As per the API docs, 'type' field is not present in the firmware drivers POST call. So default values are not added.\n    \"\"\"\n    URI = '/rest/firmware-drivers'\n\n    def __init__(self, connection, data=None):\n        super(FirmwareDrivers, self).__init__(connection, data)\n\n    def get_by_name(self, name, version=None):\n        \"\"\"\n        Retrieves the specified firmware driver resource by name and version.\n\n        Args:\n            name: name of specified firmware driver resource\n            version: version of specified firmware driver resource (optional)\n\n        Return:\n            dict: Get response of specified firmware driver resource.\n        \"\"\"\n        results = super(FirmwareDrivers, self).get_all()\n\n        # filter by name and version(optional)\n        result = [item for item in results if item.get('name', \"\").lower() == name.lower()]\n        if version:\n            result = [item for item in result if str(item.get('version', \"\")).lower() == version.lower()]\n\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource",
  "def __init__(self, connection, data=None):\n        super(FirmwareDrivers, self).__init__(connection, data)",
  "def get_by_name(self, name, version=None):\n        \"\"\"\n        Retrieves the specified firmware driver resource by name and version.\n\n        Args:\n            name: name of specified firmware driver resource\n            version: version of specified firmware driver resource (optional)\n\n        Return:\n            dict: Get response of specified firmware driver resource.\n        \"\"\"\n        results = super(FirmwareDrivers, self).get_all()\n\n        # filter by name and version(optional)\n        result = [item for item in results if item.get('name', \"\").lower() == name.lower()]\n        if version:\n            result = [item for item in result if str(item.get('version', \"\")).lower() == version.lower()]\n\n        if result:\n            data = result[0]\n            new_resource = self.new(self._connection, data)\n        else:\n            new_resource = None\n        return new_resource",
  "class Versions(object):\n    \"\"\"\n    Version API client. It indicates the range of API versions supported by the appliance.\n\n    \"\"\"\n    URI = '/rest/version'\n\n    def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)\n\n    def get_version(self):\n        \"\"\"\n        Returns the range of possible API versions supported by the appliance.\n        The response contains the current version and the minimum version.\n        The current version is the recommended version to specify in the REST header.\n        The other versions are supported for backward compatibility, but might not support the most current features.\n\n        Returns:\n            dict: The minimum and maximum supported API versions.\n        \"\"\"\n        version = self._client.get(self.URI)\n        return version",
  "def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)",
  "def get_version(self):\n        \"\"\"\n        Returns the range of possible API versions supported by the appliance.\n        The response contains the current version and the minimum version.\n        The current version is the recommended version to specify in the REST header.\n        The other versions are supported for backward compatibility, but might not support the most current features.\n\n        Returns:\n            dict: The minimum and maximum supported API versions.\n        \"\"\"\n        version = self._client.get(self.URI)\n        return version",
  "class ApplianceHealthStatus(Resource):\n    \"\"\"\n    Retrieves the health information from the appliance.\n\n    \"\"\"\n    URI = '/rest/appliance/health-status'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceHealthStatus, self).__init__(connection, data)\n\n    def get_health_status(self):\n        \"\"\"\n        Retrieves appliance health status\n\n        Returns:\n            dict: appliance health status\n        \"\"\"\n        return super(ApplianceHealthStatus, self).get_by_uri(self.URI)",
  "def __init__(self, connection, data=None):\n        super(ApplianceHealthStatus, self).__init__(connection, data)",
  "def get_health_status(self):\n        \"\"\"\n        Retrieves appliance health status\n\n        Returns:\n            dict: appliance health status\n        \"\"\"\n        return super(ApplianceHealthStatus, self).get_by_uri(self.URI)",
  "class Licenses(object):\n    \"\"\"\n    Licenses. Gets a list of all license resources that are known by the appliance.\n\n    \"\"\"\n    URI = '/rest/licenses'\n\n    DEFAULT_VALUES = {\n        '200': {'type': 'LicenseList'},\n        '300': {\"type\": \"LicenseList\"},\n        '500': {\"type\": \"LicenseListV500\"},\n        '600': {\"type\": \"LicenseListV500\"}\n    }\n\n    def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)\n\n    def create(self, resource, timeout=-1):\n        \"\"\"\n        Add a license to the appliance.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n\n        \"\"\"\n        return self._client.create(resource, timeout=timeout, default_values=self.DEFAULT_VALUES)\n\n    def get_by_id(self, id_or_uri):\n        \"\"\"\n        Gets the License with the specified ID.\n\n        Args:\n            id_or_uri: ID or URI of License.\n\n        Returns:\n            dict: The License.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def delete(self, id_or_uri):\n        \"\"\"\n        Deletes a License.\n\n        Args:\n            resource: dict object to delete\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(id_or_uri)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets all the licenses loaded on the appliance. The collection is based on optional\n        sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Licenses.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)",
  "def create(self, resource, timeout=-1):\n        \"\"\"\n        Add a license to the appliance.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n\n        \"\"\"\n        return self._client.create(resource, timeout=timeout, default_values=self.DEFAULT_VALUES)",
  "def get_by_id(self, id_or_uri):\n        \"\"\"\n        Gets the License with the specified ID.\n\n        Args:\n            id_or_uri: ID or URI of License.\n\n        Returns:\n            dict: The License.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def delete(self, id_or_uri):\n        \"\"\"\n        Deletes a License.\n\n        Args:\n            resource: dict object to delete\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(id_or_uri)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets all the licenses loaded on the appliance. The collection is based on optional\n        sorting and filtering and is constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Licenses.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort)",
  "class ApplianceDeviceSNMPv3TrapDestinations(Resource):\n    \"\"\"\n    ApplianceDeviceSNMPv3TrapDestinations API client.\n    The appliance has the ability to forward events received from monitored or managed server hardware to the specified destinations as SNMPv3 traps.\n    \"\"\"\n    URI = '/rest/appliance/snmpv3-trap-forwarding/destinations'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv3TrapDestinations, self).__init__(connection, data)\n\n    def create_validation(self, destination_address, existing_destinations=None, timeout=-1):\n        \"\"\"\n        Validate whether a host name or IP address is valid and does not already exist.\n        Supplying invalid destination address results in failure.\n\n        Args:\n            destination_address (str): destination ip address.\n            existing_destinations (list) - An array of IP address or host name of the existing trap destinations.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            Returns error message if provides invalid destination address.\n\n        \"\"\"\n        data = dict(\n            destinationAddress=destination_address\n        )\n\n        if existing_destinations:\n            data['existingDestinations'] = existing_destinations\n\n        validation_uri = \"{}/validation\".format(self.URI)\n        return self._helper.create(data, uri=validation_uri, timeout=timeout)\n\n    def create(self, data, timeout=-1):\n        \"\"\"\n        Creates a new SNMPv3 trap forwarding destination.\n        Traps will be forwarded to this destination only if the SNMPv3 user is associated with it.\n        Only one user can be assigned to a destination at any time.\n\n        Args:\n            data (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            dict: Created resource.\n\n        \"\"\"\n        existing_destinations = data.pop('existingDestinations', None)\n        self.create_validation(data['destinationAddress'], existing_destinations)\n        return super(ApplianceDeviceSNMPv3TrapDestinations, self).create(data, uri=self.URI, timeout=timeout)\n\n    def get_by_name(self, destination_address):\n        \"\"\"Retrieves a resource by its DestinationAddress.\n\n        Args:\n            destination_address: Resource DestinationAddress.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv3TrapDestinations, self).get_by_field('destinationAddress', destination_address)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Retrieves all SNMPv3 trap forwarding destinations.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n\n        Returns:\n            list: A list of SNMPv3 Trap Destionations.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv3TrapDestinations, self).__init__(connection, data)",
  "def create_validation(self, destination_address, existing_destinations=None, timeout=-1):\n        \"\"\"\n        Validate whether a host name or IP address is valid and does not already exist.\n        Supplying invalid destination address results in failure.\n\n        Args:\n            destination_address (str): destination ip address.\n            existing_destinations (list) - An array of IP address or host name of the existing trap destinations.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            Returns error message if provides invalid destination address.\n\n        \"\"\"\n        data = dict(\n            destinationAddress=destination_address\n        )\n\n        if existing_destinations:\n            data['existingDestinations'] = existing_destinations\n\n        validation_uri = \"{}/validation\".format(self.URI)\n        return self._helper.create(data, uri=validation_uri, timeout=timeout)",
  "def create(self, data, timeout=-1):\n        \"\"\"\n        Creates a new SNMPv3 trap forwarding destination.\n        Traps will be forwarded to this destination only if the SNMPv3 user is associated with it.\n        Only one user can be assigned to a destination at any time.\n\n        Args:\n            data (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Return:\n            dict: Created resource.\n\n        \"\"\"\n        existing_destinations = data.pop('existingDestinations', None)\n        self.create_validation(data['destinationAddress'], existing_destinations)\n        return super(ApplianceDeviceSNMPv3TrapDestinations, self).create(data, uri=self.URI, timeout=timeout)",
  "def get_by_name(self, destination_address):\n        \"\"\"Retrieves a resource by its DestinationAddress.\n\n        Args:\n            destination_address: Resource DestinationAddress.\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv3TrapDestinations, self).get_by_field('destinationAddress', destination_address)",
  "def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Retrieves all SNMPv3 trap forwarding destinations.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n\n        Returns:\n            list: A list of SNMPv3 Trap Destionations.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query)",
  "class FirmwareBundles(ResourceFileHandlerMixin, Resource):\n    \"\"\"\n    The firmware-bundles resource provides REST APIs for uploading\n    firmware ServicePack files or hotfixes to the CI appliance.\n    \"\"\"\n    URI = '/rest/firmware-bundles'\n\n    def __init__(self, connection, data=None):\n        super(FirmwareBundles, self).__init__(connection, data)\n\n    def upload_compsig(self, file_path, timeout=-1):\n        \"\"\"\n        Upload a compsig file for Gen10 and above hotfixes to the appliance.\n        The uploaded signature file name will be encoded to a URI safe value.\n        The API supports upload of one compsig at a time into the system.\n        For the successful upload of a compsig, ensure its original name and extension are not altered.\n\n        Args:\n            file_path: Full path to compsig file.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n          dict: Information about the added compsig file.\n        \"\"\"\n        uri = self.URI + \"/addCompsig\"\n        return super(FirmwareBundles, self).upload(file_path, uri, timeout)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Retrieves the specified firmware bundle resource by name.\n\n        Args:\n            name: name of specified firmware bundle resource\n\n        Return:\n            dict: Get response of specified firmware bundle resource.\n        \"\"\"\n        filename = re.sub(r'\\.(\\d)', r'_\\1', basename(name))\n        name = filename.split('.')[0]\n\n        firmware = FirmwareDrivers(self._connection)\n        return firmware.get_by_field('resourceId', name)",
  "def __init__(self, connection, data=None):\n        super(FirmwareBundles, self).__init__(connection, data)",
  "def upload_compsig(self, file_path, timeout=-1):\n        \"\"\"\n        Upload a compsig file for Gen10 and above hotfixes to the appliance.\n        The uploaded signature file name will be encoded to a URI safe value.\n        The API supports upload of one compsig at a time into the system.\n        For the successful upload of a compsig, ensure its original name and extension are not altered.\n\n        Args:\n            file_path: Full path to compsig file.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n          dict: Information about the added compsig file.\n        \"\"\"\n        uri = self.URI + \"/addCompsig\"\n        return super(FirmwareBundles, self).upload(file_path, uri, timeout)",
  "def get_by_name(self, name):\n        \"\"\"\n        Retrieves the specified firmware bundle resource by name.\n\n        Args:\n            name: name of specified firmware bundle resource\n\n        Return:\n            dict: Get response of specified firmware bundle resource.\n        \"\"\"\n        filename = re.sub(r'\\.(\\d)', r'_\\1', basename(name))\n        name = filename.split('.')[0]\n\n        firmware = FirmwareDrivers(self._connection)\n        return firmware.get_by_field('resourceId', name)",
  "class ApplianceDeviceReadCommunity(object):\n    \"\"\"\n    ApplianceDeviceReadCommunity API client.\n    The device read community string is used by the appliance to establish SNMP communication with devices managed by the appliance.\n    \"\"\"\n    URI = '/rest/appliance/device-read-community-string'\n\n    def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)\n\n    def get(self):\n        \"\"\"\n        Retrieves the global community string.\n\n        Returns:\n            dict: ApplianceDeviceReadCommunity\n        \"\"\"\n        return self._client.get(self.URI)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Update the device read community string.\n        This results in an update of the community string on all servers being managed/monitored by this OneView instance.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated appliance SNMPv1 read community string.\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)",
  "def get(self):\n        \"\"\"\n        Retrieves the global community string.\n\n        Returns:\n            dict: ApplianceDeviceReadCommunity\n        \"\"\"\n        return self._client.get(self.URI)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Update the device read community string.\n        This results in an update of the community string on all servers being managed/monitored by this OneView instance.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated appliance SNMPv1 read community string.\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "class Restores(Resource):\n    \"\"\"\n    Restore API client for initiate a restore of an appliance and to get the status of the restore operation.\n    \"\"\"\n    URI = '/rest/restores'\n\n    DEFAULT_VALUES = {\n        '800': {\"type\": \"RESTORE\"},\n        '1000': {\"type\": \"RESTOREV1000\"},\n        '1200': {\"type\": \"RESTOREV1000\"},\n        '1600': {\"type\": \"RESTOREV1000\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(Restores, self).__init__(connection, data)\n\n    def get_failure(self):\n        \"\"\"\n        Retrieves the result of an appliance restore operation after it has completed.\n\n        The restore result remains valid until a user logs in. After a user logs in, the restore result will be reset.\n        This rest request will return only the valid result after restore has completed and before a user logs in.\n\n        Returns:\n            dict: Restore Result\n        \"\"\"\n        failure_uri = \"{0}/failure\".format(self.URI)\n        return self._helper.do_get(failure_uri)\n\n    def restore(self, resource, timeout=-1):\n        \"\"\"\n        Starts a restore operation with the specified backup file. The backup must be uploaded to the appliance\n        prior to running this command. Only one restore can run at a time.\n\n        Args:\n            resource (dict): Config to restore.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Restore.\n\n        \"\"\"\n        return super(Restores, self).create(resource, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(Restores, self).__init__(connection, data)",
  "def get_failure(self):\n        \"\"\"\n        Retrieves the result of an appliance restore operation after it has completed.\n\n        The restore result remains valid until a user logs in. After a user logs in, the restore result will be reset.\n        This rest request will return only the valid result after restore has completed and before a user logs in.\n\n        Returns:\n            dict: Restore Result\n        \"\"\"\n        failure_uri = \"{0}/failure\".format(self.URI)\n        return self._helper.do_get(failure_uri)",
  "def restore(self, resource, timeout=-1):\n        \"\"\"\n        Starts a restore operation with the specified backup file. The backup must be uploaded to the appliance\n        prior to running this command. Only one restore can run at a time.\n\n        Args:\n            resource (dict): Config to restore.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Restore.\n\n        \"\"\"\n        return super(Restores, self).create(resource, timeout=timeout)",
  "class Repositories(ResourcePatchMixin, Resource):\n    \"\"\"\n    Repositories API client.\n\n    \"\"\"\n\n    URI = '/rest/repositories'\n\n    def __init__(self, connection, data=None):\n        super(Repositories, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(Repositories, self).__init__(connection, data)",
  "def get_resources_associated_with_scope(connection, scope_uri):\n    index_resource = IndexResources(connection)\n    query_string = \"scopeUris='{}'\".format(scope_uri)\n    all_index_resources = index_resource.get_all(category=category_list, query=query_string)\n    response = [dict_response['uri'] for dict_response in all_index_resources]\n    return response",
  "class Scopes(Resource, ResourcePatchMixin):\n    \"\"\"\n    Scopes API client.\n\n    Note:\n        This resource is available for API version 300 or later.\n\n    \"\"\"\n    URI = '/rest/scopes'\n\n    DEFAULT_VALUES = {\n        '300': {\"type\": \"Scope\"},\n        '500': {\"type\": \"ScopeV2\"},\n        '800': {\"type\": \"ScopeV3\"},\n        '1000': {\"type\": \"ScopeV3\"},\n        '1200': {\"type\": \"ScopeV3\"},\n        '1600': {\"type\": \"ScopeV3\"},\n        '1800': {\"type\": \"ScopeV3\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(Scopes, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query='', view=''):\n        \"\"\"\n         Gets a list of scopes.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                A general query string to narrow the list of resources returned. The default\n                is no query - all resources are returned.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by\n                 specifying the name of a predefined view. The default view is expand (show all\n                 attributes of the resource and all elements of collections of resources).\n\n        Returns:\n            list: A list of scopes.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, view=view)\n\n    def get_by_uri(self, uri):\n        \"\"\"\n        Retrieves the specified scope resource by uri.\n\n        Args:\n            uri: Uri of specified scope resource\n\n        Return:\n            dict: Get response of specified scope resource.\n        \"\"\"\n        response = super(Scopes, self).get_by_uri(uri)\n        if response:\n            resource_list = get_resources_associated_with_scope(self._connection, response.data['uri'])\n            response.data['addedResourceUris'] = resource_list\n        return response\n\n    def get_by_name(self, name):\n        \"\"\"\n        Retrieves the specified scope resource by name.\n\n        Args:\n            name: name of specified scope resource\n\n        Return:\n            dict: Get response of specified scope resource.\n        \"\"\"\n        response = super(Scopes, self).get_by_name(name)\n        if response:\n            resource_list = get_resources_associated_with_scope(self._connection, response.data['uri'])\n            response.data['addedResourceUris'] = resource_list\n        return response\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates a scope.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated scope.\n\n        \"\"\"\n        headers = {'If-Match': resource.get('eTag', '*')}\n        return super(Scopes, self).update(resource, timeout=timeout, custom_headers=headers)\n\n    def delete(self, timeout=-1):\n        \"\"\"\n        Deletes a Scope.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return super(Scopes, self).delete(timeout=timeout, custom_headers=headers)\n\n    def get_scope_resource(self, resource_uri):\n        \"\"\"\n        Gets a resource's scope, containing a list of the scopes to which the resource is assigned.\n\n        Args:\n            resource_uri: Uri of the resource\n\n        Return:\n            dict: Gets the scope assignments for a specified resource.\n        \"\"\"\n        uri = \"{0}/resources{1}\".format(self.URI, resource_uri)\n        return super(Scopes, self).get_by_uri(uri)\n\n    # This function will work till API version 300\n    def update_resource_assignments(self, id_or_uri, resource_assignments, timeout=-1):\n        \"\"\"\n        Modifies scope membership by adding or removing resource assignments.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            resource_assignments (dict):\n                A dict object with a list of resource URIs to be added and a list of resource URIs to be removed.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        uri = self._helper.build_uri(id_or_uri) + \"/resource-assignments\"\n        return super(Scopes, self).patch_request(uri, resource_assignments, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(Scopes, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', query='', view=''):\n        \"\"\"\n         Gets a list of scopes.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                A general query string to narrow the list of resources returned. The default\n                is no query - all resources are returned.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by\n                 specifying the name of a predefined view. The default view is expand (show all\n                 attributes of the resource and all elements of collections of resources).\n\n        Returns:\n            list: A list of scopes.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, view=view)",
  "def get_by_uri(self, uri):\n        \"\"\"\n        Retrieves the specified scope resource by uri.\n\n        Args:\n            uri: Uri of specified scope resource\n\n        Return:\n            dict: Get response of specified scope resource.\n        \"\"\"\n        response = super(Scopes, self).get_by_uri(uri)\n        if response:\n            resource_list = get_resources_associated_with_scope(self._connection, response.data['uri'])\n            response.data['addedResourceUris'] = resource_list\n        return response",
  "def get_by_name(self, name):\n        \"\"\"\n        Retrieves the specified scope resource by name.\n\n        Args:\n            name: name of specified scope resource\n\n        Return:\n            dict: Get response of specified scope resource.\n        \"\"\"\n        response = super(Scopes, self).get_by_name(name)\n        if response:\n            resource_list = get_resources_associated_with_scope(self._connection, response.data['uri'])\n            response.data['addedResourceUris'] = resource_list\n        return response",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates a scope.\n\n        Args:\n            resource (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Updated scope.\n\n        \"\"\"\n        headers = {'If-Match': resource.get('eTag', '*')}\n        return super(Scopes, self).update(resource, timeout=timeout, custom_headers=headers)",
  "def delete(self, timeout=-1):\n        \"\"\"\n        Deletes a Scope.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return super(Scopes, self).delete(timeout=timeout, custom_headers=headers)",
  "def get_scope_resource(self, resource_uri):\n        \"\"\"\n        Gets a resource's scope, containing a list of the scopes to which the resource is assigned.\n\n        Args:\n            resource_uri: Uri of the resource\n\n        Return:\n            dict: Gets the scope assignments for a specified resource.\n        \"\"\"\n        uri = \"{0}/resources{1}\".format(self.URI, resource_uri)\n        return super(Scopes, self).get_by_uri(uri)",
  "def update_resource_assignments(self, id_or_uri, resource_assignments, timeout=-1):\n        \"\"\"\n        Modifies scope membership by adding or removing resource assignments.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n            resource_assignments (dict):\n                A dict object with a list of resource URIs to be added and a list of resource URIs to be removed.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        uri = self._helper.build_uri(id_or_uri) + \"/resource-assignments\"\n        return super(Scopes, self).patch_request(uri, resource_assignments, timeout=timeout)",
  "class ApplianceDeviceSNMPv3Users(Resource):\n    \"\"\"\n    ApplianceDeviceSNMPv3Users API client [Available only since API 600].\n\n    As part of SNMPv3 trap forwarding support, the appliance provides APIs for creating User-based Security Model (USM) and forwarding destinations.\n    The following protocols are supported while defining USM.\n\n    Authentication protocols: MD5 / SHA1 / SHA256 / SHA384 / SHA512\n    Privacy protocols: AES / DES\n    The security levels supported while defining USM are None, Authentication only and both Authentication and Privacy.\n\n    \"\"\"\n    URI = '/rest/appliance/snmpv3-trap-forwarding/users'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv3Users, self).__init__(connection, data)\n\n    def get_by_name(self, user_name):\n        \"\"\"Retrieves a resource by its username.\n        Args:\n            username: Resource username\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv3Users, self).get_by_field('userName', user_name)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Lists all SNMPv3 Users.\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of SNMPv3 Users.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def __init__(self, connection, data=None):\n        super(ApplianceDeviceSNMPv3Users, self).__init__(connection, data)",
  "def get_by_name(self, user_name):\n        \"\"\"Retrieves a resource by its username.\n        Args:\n            username: Resource username\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        return super(ApplianceDeviceSNMPv3Users, self).get_by_field('userName', user_name)",
  "def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Lists all SNMPv3 Users.\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of SNMPv3 Users.\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query)",
  "class Backups(object):\n    \"\"\"\n    Backups API client.\n    \"\"\"\n\n    URI = '/rest/backups'\n\n    def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self):\n        \"\"\"\n        Retrieves the details for any current appliance backup. Only one backup file is present on the appliance at any\n        time.\n\n        Returns:\n            list: A list of Backups.\n        \"\"\"\n        return self._client.get_collection(self.URI)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets the details of the specified backup.\n\n        Args:\n            id_or_uri: ID or URI of the backup\n\n        Returns:\n            dict: Details of the specified backup.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def create(self, timeout=-1):\n        \"\"\"\n        Starts backing up the appliance. After completion, the backup file must be downloaded and saved off-appliance.\n        Appliance backups can be started at any time, and do not require any special setup to prepare the appliance for\n        the backup.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Details of the created backup.\n\n        \"\"\"\n        return self._client.create_with_zero_body(timeout=timeout)\n\n    def download(self, id_or_uri, file_path):\n        \"\"\"\n        Downloads a backup archive previously created on the appliance. Uploaded backup files cannot be downloaded.\n\n        Args:\n            id_or_uri: ID or URI of the Artifact Bundle.\n            file_path(str): Destination file path.\n\n        Returns:\n            bool: Successfully downloaded.\n        \"\"\"\n        return self._client.download(id_or_uri, file_path)\n\n    def upload(self, file_path):\n        \"\"\"\n        Uploads an appliance backup file in preparation of a restore. Any existing backup on the appliance is removed.\n\n        After the backup file is uploaded and validated, its details are returned. The URI of the backup can be used to\n        start a restore.\n\n        Args:\n            file_path (str): The local backup filepath\n\n        Returns:\n            dict: Details of the uploaded backup.\n        \"\"\"\n        return self._client.upload(file_path, self.URI + '/archive')\n\n    def get_config(self):\n        \"\"\"\n        Retrieves the details of the backup configuration for the remote server and automatic backup schedule.\n\n        Args:\n            id_or_uri: ID or URI of the backup\n\n        Returns:\n            dict: Details of the backup configuration for the remote server and automatic backup schedule.\n        \"\"\"\n        return self._client.get('config')\n\n    def update_config(self, config, timeout=-1):\n        \"\"\"\n        Updates the remote server configuration and the automatic backup schedule for backup.\n\n        Args:\n            config (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Backup details.\n\n        \"\"\"\n        return self._client.update(config, uri=self.URI + \"/config\", timeout=timeout)\n\n    def update_remote_archive(self, save_uri, timeout=-1):\n        \"\"\"\n        Saves a backup of the appliance to a previously-configured remote location.\n\n        Args:\n            save_uri (dict): The URI for saving the backup to a previously configured location.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Backup details.\n\n        \"\"\"\n        return self._client.update_with_zero_body(uri=save_uri, timeout=timeout)",
  "def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self):\n        \"\"\"\n        Retrieves the details for any current appliance backup. Only one backup file is present on the appliance at any\n        time.\n\n        Returns:\n            list: A list of Backups.\n        \"\"\"\n        return self._client.get_collection(self.URI)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets the details of the specified backup.\n\n        Args:\n            id_or_uri: ID or URI of the backup\n\n        Returns:\n            dict: Details of the specified backup.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def create(self, timeout=-1):\n        \"\"\"\n        Starts backing up the appliance. After completion, the backup file must be downloaded and saved off-appliance.\n        Appliance backups can be started at any time, and do not require any special setup to prepare the appliance for\n        the backup.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Details of the created backup.\n\n        \"\"\"\n        return self._client.create_with_zero_body(timeout=timeout)",
  "def download(self, id_or_uri, file_path):\n        \"\"\"\n        Downloads a backup archive previously created on the appliance. Uploaded backup files cannot be downloaded.\n\n        Args:\n            id_or_uri: ID or URI of the Artifact Bundle.\n            file_path(str): Destination file path.\n\n        Returns:\n            bool: Successfully downloaded.\n        \"\"\"\n        return self._client.download(id_or_uri, file_path)",
  "def upload(self, file_path):\n        \"\"\"\n        Uploads an appliance backup file in preparation of a restore. Any existing backup on the appliance is removed.\n\n        After the backup file is uploaded and validated, its details are returned. The URI of the backup can be used to\n        start a restore.\n\n        Args:\n            file_path (str): The local backup filepath\n\n        Returns:\n            dict: Details of the uploaded backup.\n        \"\"\"\n        return self._client.upload(file_path, self.URI + '/archive')",
  "def get_config(self):\n        \"\"\"\n        Retrieves the details of the backup configuration for the remote server and automatic backup schedule.\n\n        Args:\n            id_or_uri: ID or URI of the backup\n\n        Returns:\n            dict: Details of the backup configuration for the remote server and automatic backup schedule.\n        \"\"\"\n        return self._client.get('config')",
  "def update_config(self, config, timeout=-1):\n        \"\"\"\n        Updates the remote server configuration and the automatic backup schedule for backup.\n\n        Args:\n            config (dict): Object to update.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Backup details.\n\n        \"\"\"\n        return self._client.update(config, uri=self.URI + \"/config\", timeout=timeout)",
  "def update_remote_archive(self, save_uri, timeout=-1):\n        \"\"\"\n        Saves a backup of the appliance to a previously-configured remote location.\n\n        Args:\n            save_uri (dict): The URI for saving the backup to a previously configured location.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Backup details.\n\n        \"\"\"\n        return self._client.update_with_zero_body(uri=save_uri, timeout=timeout)",
  "class HANodes(Resource, ResourcePatchMixin):\n    \"\"\"\n    HA Nodes resources represent the individual members used to provide\n    high-availability for the management appliance cluster.\n\n    \"\"\"\n    URI = '/rest/appliance/ha-nodes'\n\n    def __init__(self, connection, data=None):\n        super(HANodes, self).__init__(connection, data)\n\n    def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "def __init__(self, connection, data=None):\n        super(HANodes, self).__init__(connection, data)",
  "def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "class ApplianceNetworkInterfaces(Resource):\n    \"\"\"\n    ApplianceNetworkInterface API Client.\n\n    \"\"\"\n    URI = '/rest/appliance/network-interfaces'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceNetworkInterfaces, self).__init__(connection, data)\n\n    def get_all(self):\n        return super(ApplianceNetworkInterfaces, self).get_by_uri(self.URI)\n\n    def get_all_mac_address(self):\n        \"\"\"\n        Gets unconfigured network interfaces on the appliance.\n        Returns:\n            dict: Unconfigured network interfaces on the appliance.\n        \"\"\"\n        uri = self._helper.build_uri('mac-addresses')\n        mac_addresses = super(ApplianceNetworkInterfaces, self).get_by_uri(uri)\n        return mac_addresses.data['members']\n\n    def get_by_mac_address(self, mac_address):\n        \"\"\"\n        Gets the network interface by the macAddress.\n        Returns:\n            dict: Network interface with the given macAddress on the appliance.\n        \"\"\"\n\n        resources = self.get_all().data[\"applianceNetworks\"]\n        for resource in resources:\n            if resource['macAddress'].lower() == mac_address.lower():\n                new_resource = self.new(self._connection, resource)\n            else:\n                new_resource = None\n        return new_resource",
  "def __init__(self, connection, data=None):\n        super(ApplianceNetworkInterfaces, self).__init__(connection, data)",
  "def get_all(self):\n        return super(ApplianceNetworkInterfaces, self).get_by_uri(self.URI)",
  "def get_all_mac_address(self):\n        \"\"\"\n        Gets unconfigured network interfaces on the appliance.\n        Returns:\n            dict: Unconfigured network interfaces on the appliance.\n        \"\"\"\n        uri = self._helper.build_uri('mac-addresses')\n        mac_addresses = super(ApplianceNetworkInterfaces, self).get_by_uri(uri)\n        return mac_addresses.data['members']",
  "def get_by_mac_address(self, mac_address):\n        \"\"\"\n        Gets the network interface by the macAddress.\n        Returns:\n            dict: Network interface with the given macAddress on the appliance.\n        \"\"\"\n\n        resources = self.get_all().data[\"applianceNetworks\"]\n        for resource in resources:\n            if resource['macAddress'].lower() == mac_address.lower():\n                new_resource = self.new(self._connection, resource)\n            else:\n                new_resource = None\n        return new_resource",
  "class ApplianceConfigurationTimeconfig(Resource):\n    \"\"\"\n        ApplianceConfigurationTimeConfig API client.\n\n    \"\"\"\n    URI = '/rest/appliance/configuration/timeconfig/locales'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceConfigurationTimeconfig, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(ApplianceConfigurationTimeconfig, self).__init__(connection, data)",
  "class ApplianceProxyConfiguration(Resource, ResourceHelper):\n    \"\"\"\n    ApplianceProxyConfig API Client.\n\n    \"\"\"\n    URI = '/rest/appliance/proxy-config'\n\n    def __init__(self, connection, data=None):\n        super(ApplianceProxyConfiguration, self).__init__(connection, data)\n\n    def get_all(self):\n        return super(ApplianceProxyConfiguration, self).get_by_uri(self.URI)\n\n    def get_by_proxy(self, proxy_ip):\n        \"\"\"Retrieves a resource by proxy server ip.\n\n        Args:\n            proxy_ip: Ip address of the proxy\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        results = self.get_all().data\n        if results:\n            if str(results.get(\"server\", \"\")).lower() == proxy_ip.lower():\n                new_resource = self.new(self._connection, results)\n            else:\n                new_resource = None\n        return new_resource\n\n    def delete(self):\n        return self._helper.delete(self.URI)",
  "def __init__(self, connection, data=None):\n        super(ApplianceProxyConfiguration, self).__init__(connection, data)",
  "def get_all(self):\n        return super(ApplianceProxyConfiguration, self).get_by_uri(self.URI)",
  "def get_by_proxy(self, proxy_ip):\n        \"\"\"Retrieves a resource by proxy server ip.\n\n        Args:\n            proxy_ip: Ip address of the proxy\n\n        Returns:\n            Resource object or None if resource does not exist.\n        \"\"\"\n        results = self.get_all().data\n        if results:\n            if str(results.get(\"server\", \"\")).lower() == proxy_ip.lower():\n                new_resource = self.new(self._connection, results)\n            else:\n                new_resource = None\n        return new_resource",
  "def delete(self):\n        return self._helper.delete(self.URI)",
  "def get_resources_associated_with_label(connection, label):\n    index_resource = IndexResources(connection)\n    query_string = \"labels='{}'\".format(label)\n    all_index_resources = index_resource.get_all(category=category_list, query=query_string)\n    response = [dict_response['uri'] for dict_response in all_index_resources]\n    return response",
  "class Labels(Resource):\n    \"\"\"\n    Labels API client.\n\n    \"\"\"\n\n    URI = '/rest/labels'\n    RESOURCES_PATH = '/resources'\n\n    def __init__(self, connection, data=None):\n        super(Labels, self).__init__(connection, data)\n\n    def get_assigned_resources(self, name):\n        \"\"\"\n        Retrieves the assigned resource of a label by name.\n\n        Args:\n            name: name of the label.\n\n        Returns:\n          Dict:  Get assigned resources of specified label resource.\n        \"\"\"\n        response = super(Labels, self).get_by_name(name)\n        if response:\n            resources_list = get_resources_associated_with_label(self._connection, name)\n            assigned_resource = dict(name=name, assignedResourceUris=resources_list)\n        return assigned_resource\n\n    def create(self, resource, timeout=-1):\n        \"\"\"\n        Set all the labels for a resource.\n\n        Args:\n            resource: The object containing the resource URI and a list of labels\n\n        Returns:\n            dict: Resource Labels\n        \"\"\"\n        uri = self.URI + self.RESOURCES_PATH\n        return super(Labels, self).create(resource, uri=uri, timeout=timeout)\n\n    def get_by_resource(self, resource_uri):\n        \"\"\"\n        Gets all the labels for the specified resource\n\n        Args:\n            resource_uri: The resource URI\n\n        Returns:\n            dict: Resource Labels\n        \"\"\"\n        uri = self.URI + self.RESOURCES_PATH + '/' + resource_uri\n        return super(Labels, self).get_by_uri(uri)\n\n    def get_all(self, count=-1, sort='', start=0, view='', fields='', filter='', name_prefix='', category=[]):\n        \"\"\"\n        Gets all items according with the given arguments.\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n        Returns:\n             list: A list of items matching the specified filter.\n        \"\"\"\n        return self._helper.get_all(count=count, sort=sort, start=start, view=view, fields=fields, filter=filter, name_prefix=name_prefix, category=category)",
  "def __init__(self, connection, data=None):\n        super(Labels, self).__init__(connection, data)",
  "def get_assigned_resources(self, name):\n        \"\"\"\n        Retrieves the assigned resource of a label by name.\n\n        Args:\n            name: name of the label.\n\n        Returns:\n          Dict:  Get assigned resources of specified label resource.\n        \"\"\"\n        response = super(Labels, self).get_by_name(name)\n        if response:\n            resources_list = get_resources_associated_with_label(self._connection, name)\n            assigned_resource = dict(name=name, assignedResourceUris=resources_list)\n        return assigned_resource",
  "def create(self, resource, timeout=-1):\n        \"\"\"\n        Set all the labels for a resource.\n\n        Args:\n            resource: The object containing the resource URI and a list of labels\n\n        Returns:\n            dict: Resource Labels\n        \"\"\"\n        uri = self.URI + self.RESOURCES_PATH\n        return super(Labels, self).create(resource, uri=uri, timeout=timeout)",
  "def get_by_resource(self, resource_uri):\n        \"\"\"\n        Gets all the labels for the specified resource\n\n        Args:\n            resource_uri: The resource URI\n\n        Returns:\n            dict: Resource Labels\n        \"\"\"\n        uri = self.URI + self.RESOURCES_PATH + '/' + resource_uri\n        return super(Labels, self).get_by_uri(uri)",
  "def get_all(self, count=-1, sort='', start=0, view='', fields='', filter='', name_prefix='', category=[]):\n        \"\"\"\n        Gets all items according with the given arguments.\n        Args:\n            start: The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items (default).\n            sort: The sort order of the returned data set. By default, the sort order is based on create time with the\n                oldest entry first.\n            view:\n                Returns a specific subset of the attributes of the resource or collection by specifying the name of a\n                predefined view. The default view is expand (show all attributes of the resource and all elements of\n                the collections or resources).\n            fields:\n                Name of the fields.\n        Returns:\n             list: A list of items matching the specified filter.\n        \"\"\"\n        return self._helper.get_all(count=count, sort=sort, start=start, view=view, fields=fields, filter=filter, name_prefix=name_prefix, category=category)",
  "class IndexResources(Resource):\n    \"\"\"\n    Index Resources API client.\n\n    \"\"\"\n\n    URI = '/rest/index/resources'\n\n    def __init__(self, connection, data=None):\n        super(IndexResources, self).__init__(connection, data)\n\n    def get_all(self, category='', count=-1, fields='', filter='', padding=0, query='', reference_uri='',\n                sort='', start=0, user_query='', view=''):\n        \"\"\"\n        Gets a list of index resources based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            category (str or list):\n                 Category of resources. Multiple Category parameters are applied with OR condition.\n            count (int):\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            fields (str):\n                Specifies which fields should be returned in the result set.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            padding (int):\n                Number of resources to be returned before the reference URI resource.\n            query (str):\n                 A general query string to narrow the list of resources returned.\n                 The default is no query - all resources are returned.\n            reference_uri (str):\n                Load one page of resources, pagination is applied with reference to referenceUri provided.\n            sort (str):\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            start (int):\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            user_query (str):\n                Free text Query string to search the resources. This will match the string in any field that is indexed.\n            view (str):\n                Return a specific subset of the attributes of the resource or collection, by specifying the name of a predefined view.\n\n        Returns:\n            list: A list of index resources.\n        \"\"\"\n        uri = self.URI + '?'\n\n        uri += self.__list_or_str_to_query(category, 'category')\n        uri += self.__list_or_str_to_query(padding, 'padding')\n        uri += self.__list_or_str_to_query(reference_uri, 'referenceUri')\n        uri += self.__list_or_str_to_query(user_query, 'userQuery')\n\n        uri = uri.replace('?&', '?')\n\n        return self._helper.get_all(start=start, count=count, fields=fields, filter=filter, query=query, sort=sort, view=view, uri=uri)\n\n    def get_by_uri(self, resource_uri):\n        \"\"\"\n        Retrieves the index resources of specified resource.\n\n        Args:\n            resource_uri: Uri of specified resource\n\n        Return:\n            dict: index resources associated with specified resource\n        \"\"\"\n        uri = \"{0}{1}\".format(self.URI, resource_uri)\n        return super(IndexResources, self).get_by_uri(uri)\n\n    def get_aggregated(self, attribute, category, child_limit=6, filter='', query='', user_query='', attribute_query='', scope_query=''):\n        \"\"\"\n        Gets a list of index resources based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            attribute (list or str):\n                Attribute to pass in as query filter.\n            category (str):\n                Category of resources. Multiple Category parameters are applied with an OR condition.\n            child_limit (int):\n                Number of resources to be retrieved. Default=6.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query (str):\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            user_query (str):\n                Free text Query string to search the resources.\n                This will match the string in any field that is indexed.\n            attribute_query (list or str):\n                attributeQuery is used along with query parameter to filter out the details by attributes.\n                One or more attributeQuery should be used.\n            scope_query (str):\n                ScopeQuery is used to filter the dashboard view by scope.\n                ScopeQuery can be a single scope or a valid scope expression.\n\n        Returns:\n            list: An aggregated list of index resources.\n        \"\"\"\n        uri = self.URI + '/aggregated?'\n\n        # Add attribute to query\n        uri += self.__list_or_str_to_query(attribute, 'attribute')\n        uri += self.__list_or_str_to_query(category, 'category')\n        uri += self.__list_or_str_to_query(child_limit, 'childLimit')\n        uri += self.__list_or_str_to_query(filter, 'filter')\n        uri += self.__list_or_str_to_query(query, 'query')\n        uri += self.__list_or_str_to_query(user_query, 'userQuery')\n        uri += self.__list_or_str_to_query(attribute_query, 'attributeQuery')\n        uri += self.__list_or_str_to_query(scope_query, 'scopeQuery')\n\n        uri = uri.replace('?&', '?')\n\n        return super(IndexResources, self).get_by_uri(uri)\n\n    def __list_or_str_to_query(self, list_or_str, field_name):\n        formated_query = ''\n        if list_or_str:\n            if isinstance(list_or_str, list):\n                for f in list_or_str:\n                    formated_query = formated_query + \"&{0}=\".format(field_name) + ''.join(quote(str(f)))\n            else:\n                formated_query = \"&{0}=\".format(field_name) + str(list_or_str)\n        return formated_query",
  "def __init__(self, connection, data=None):\n        super(IndexResources, self).__init__(connection, data)",
  "def get_all(self, category='', count=-1, fields='', filter='', padding=0, query='', reference_uri='',\n                sort='', start=0, user_query='', view=''):\n        \"\"\"\n        Gets a list of index resources based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            category (str or list):\n                 Category of resources. Multiple Category parameters are applied with OR condition.\n            count (int):\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            fields (str):\n                Specifies which fields should be returned in the result set.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            padding (int):\n                Number of resources to be returned before the reference URI resource.\n            query (str):\n                 A general query string to narrow the list of resources returned.\n                 The default is no query - all resources are returned.\n            reference_uri (str):\n                Load one page of resources, pagination is applied with reference to referenceUri provided.\n            sort (str):\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            start (int):\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            user_query (str):\n                Free text Query string to search the resources. This will match the string in any field that is indexed.\n            view (str):\n                Return a specific subset of the attributes of the resource or collection, by specifying the name of a predefined view.\n\n        Returns:\n            list: A list of index resources.\n        \"\"\"\n        uri = self.URI + '?'\n\n        uri += self.__list_or_str_to_query(category, 'category')\n        uri += self.__list_or_str_to_query(padding, 'padding')\n        uri += self.__list_or_str_to_query(reference_uri, 'referenceUri')\n        uri += self.__list_or_str_to_query(user_query, 'userQuery')\n\n        uri = uri.replace('?&', '?')\n\n        return self._helper.get_all(start=start, count=count, fields=fields, filter=filter, query=query, sort=sort, view=view, uri=uri)",
  "def get_by_uri(self, resource_uri):\n        \"\"\"\n        Retrieves the index resources of specified resource.\n\n        Args:\n            resource_uri: Uri of specified resource\n\n        Return:\n            dict: index resources associated with specified resource\n        \"\"\"\n        uri = \"{0}{1}\".format(self.URI, resource_uri)\n        return super(IndexResources, self).get_by_uri(uri)",
  "def get_aggregated(self, attribute, category, child_limit=6, filter='', query='', user_query='', attribute_query='', scope_query=''):\n        \"\"\"\n        Gets a list of index resources based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            attribute (list or str):\n                Attribute to pass in as query filter.\n            category (str):\n                Category of resources. Multiple Category parameters are applied with an OR condition.\n            child_limit (int):\n                Number of resources to be retrieved. Default=6.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query (str):\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            user_query (str):\n                Free text Query string to search the resources.\n                This will match the string in any field that is indexed.\n            attribute_query (list or str):\n                attributeQuery is used along with query parameter to filter out the details by attributes.\n                One or more attributeQuery should be used.\n            scope_query (str):\n                ScopeQuery is used to filter the dashboard view by scope.\n                ScopeQuery can be a single scope or a valid scope expression.\n\n        Returns:\n            list: An aggregated list of index resources.\n        \"\"\"\n        uri = self.URI + '/aggregated?'\n\n        # Add attribute to query\n        uri += self.__list_or_str_to_query(attribute, 'attribute')\n        uri += self.__list_or_str_to_query(category, 'category')\n        uri += self.__list_or_str_to_query(child_limit, 'childLimit')\n        uri += self.__list_or_str_to_query(filter, 'filter')\n        uri += self.__list_or_str_to_query(query, 'query')\n        uri += self.__list_or_str_to_query(user_query, 'userQuery')\n        uri += self.__list_or_str_to_query(attribute_query, 'attributeQuery')\n        uri += self.__list_or_str_to_query(scope_query, 'scopeQuery')\n\n        uri = uri.replace('?&', '?')\n\n        return super(IndexResources, self).get_by_uri(uri)",
  "def __list_or_str_to_query(self, list_or_str, field_name):\n        formated_query = ''\n        if list_or_str:\n            if isinstance(list_or_str, list):\n                for f in list_or_str:\n                    formated_query = formated_query + \"&{0}=\".format(field_name) + ''.join(quote(str(f)))\n            else:\n                formated_query = \"&{0}=\".format(field_name) + str(list_or_str)\n        return formated_query",
  "class Racks(object):\n    \"\"\"\n    Racks API client.\n\n    \"\"\"\n    URI = '/rest/racks'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of rack resources according to the specified parameters. Filters can be used to get a specific set\n        of racks. With no filters specified, the API returns a potentially paginated list of all the racks subject\n        to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of racks.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a rack with the specified ID or URI.\n\n        Args:\n            id_or_uri:\n                Can be either the rack id or the rack uri.\n\n        Returns:\n            dict: The rack.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def get_device_topology(self, id_or_uri):\n        \"\"\"\n        Retrieves the topology information for the rack resource specified by ID or URI.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Return:\n            dict: Device topology.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/deviceTopology\"\n        return self._client.get(uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all racks that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of racks.\n\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Removes the specified rack.\n\n        Args:\n            resource (dict): Object to remove.\n            force:\n                 If set to true, the operation completes despite any problems with network connectivity or errors on the\n                 resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns: Result status.\n\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack resource based upon the attributes specified. All attributes without default values must be\n        specified in the POST body. The response contains the rack resource as added to the appliance with default and\n        assigned properties expanded. The id and uri are assigned by the management appliance and are used to uniquely\n        identify this particular resource.\n\n        Args:\n            information: Rack information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added rack.\n\n        \"\"\"\n        return self._client.create(information, timeout=timeout)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the specified rack resource. The properties that are omitted (not included as part of the request body)\n        are reset to their respective default values. The id and uuid properties are required and cannot be changed.\n        To update existing racks first perform a get() request to retrieve the current properties, update the desired\n        properties, and then update() the request body containing the new representation of the resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated rack.\n\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of rack resources according to the specified parameters. Filters can be used to get a specific set\n        of racks. With no filters specified, the API returns a potentially paginated list of all the racks subject\n        to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of racks.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a rack with the specified ID or URI.\n\n        Args:\n            id_or_uri:\n                Can be either the rack id or the rack uri.\n\n        Returns:\n            dict: The rack.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def get_device_topology(self, id_or_uri):\n        \"\"\"\n        Retrieves the topology information for the rack resource specified by ID or URI.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Return:\n            dict: Device topology.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/deviceTopology\"\n        return self._client.get(uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all racks that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of racks.\n\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Removes the specified rack.\n\n        Args:\n            resource (dict): Object to remove.\n            force:\n                 If set to true, the operation completes despite any problems with network connectivity or errors on the\n                 resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns: Result status.\n\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a rack resource based upon the attributes specified. All attributes without default values must be\n        specified in the POST body. The response contains the rack resource as added to the appliance with default and\n        assigned properties expanded. The id and uri are assigned by the management appliance and are used to uniquely\n        identify this particular resource.\n\n        Args:\n            information: Rack information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added rack.\n\n        \"\"\"\n        return self._client.create(information, timeout=timeout)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the specified rack resource. The properties that are omitted (not included as part of the request body)\n        are reset to their respective default values. The id and uuid properties are required and cannot be changed.\n        To update existing racks first perform a get() request to retrieve the current properties, update the desired\n        properties, and then update() the request body containing the new representation of the resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated rack.\n\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "class Datacenters(object):\n    \"\"\"\n    Datacenters API client.\n\n    \"\"\"\n    URI = '/rest/datacenters'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of data center resources according to the specified parameters. Filters can be used to get a specific\n        set of data centers.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of data centers.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a single data center resource based upon its ID or URI.\n\n        Args:\n            id_or_uri:\n                Can be either the data center id or the data center uri.\n\n        Returns:\n            dict: The data center.\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def get_visual_content(self, id_or_uri):\n        \"\"\"\n        Gets a list of visual content objects describing each rack within the data center. The response aggregates data\n        center and rack data with a specified metric (peak24HourTemp) to provide simplified access to display data for\n        the data center.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Return:\n            list: List of visual content objects.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/visualContent\"\n        return self._client.get(uri)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all data centers that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of data centers.\n\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified.\n\n        Args:\n            resource (dict): Object to remove.\n            force:\n                 If set to true, the operation completes despite any problems with network connectivity or errors on the\n                 resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns: Result status.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a data center resource based upon the attributes specified.\n\n        Args:\n            information: Data center information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added data center.\n        \"\"\"\n        return self._client.create(information, timeout=timeout)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the specified data center resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated data center.\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)\n\n    def remove_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of datacenters according to the specified parameters. A filter is required to identify the set\n        of resources to be deleted.\n\n        Args:\n            filter:\n                 A general filter/query string to narrow the list of items that will be removed.\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete_all(filter=filter, force=force, timeout=timeout)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of data center resources according to the specified parameters. Filters can be used to get a specific\n        set of data centers.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: List of data centers.\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a single data center resource based upon its ID or URI.\n\n        Args:\n            id_or_uri:\n                Can be either the data center id or the data center uri.\n\n        Returns:\n            dict: The data center.\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def get_visual_content(self, id_or_uri):\n        \"\"\"\n        Gets a list of visual content objects describing each rack within the data center. The response aggregates data\n        center and rack data with a specified metric (peak24HourTemp) to provide simplified access to display data for\n        the data center.\n\n        Args:\n            id_or_uri: Can be either the resource ID or the resource URI.\n\n        Return:\n            list: List of visual content objects.\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/visualContent\"\n        return self._client.get(uri)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all data centers that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of data centers.\n\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified.\n\n        Args:\n            resource (dict): Object to remove.\n            force:\n                 If set to true, the operation completes despite any problems with network connectivity or errors on the\n                 resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns: Result status.\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a data center resource based upon the attributes specified.\n\n        Args:\n            information: Data center information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Added data center.\n        \"\"\"\n        return self._client.create(information, timeout=timeout)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the specified data center resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated data center.\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "def remove_all(self, filter, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of datacenters according to the specified parameters. A filter is required to identify the set\n        of resources to be deleted.\n\n        Args:\n            filter:\n                 A general filter/query string to narrow the list of items that will be removed.\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                 Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                 in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete_all(filter=filter, force=force, timeout=timeout)",
  "class PowerDevices(object):\n    \"\"\"\n    Power Devices API client.\n\n    \"\"\"\n    URI = '/rest/power-devices'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of power delivery device resources according to the specified parameters. Filters can be used to get\n        a specific set of power delivery devices. With no filters specified, the API returns a potentially paginated\n        list of all the power delivery device resources subject to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n             list of power devices\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Gets a single power delivery device resource based upon its uri or id.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            dict: The power device\n        \"\"\"\n        return self._client.get(id_or_uri)\n\n    def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a power delivery device resource based upon the attributes specified. Use this method to create a\n        representation of power delivery devices that provide power to other resources but cannot otherwise be\n        discovered by the management appliance.\n\n        Args:\n            information:\n                power device information\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: added power device.\n        \"\"\"\n        return self._client.create(information, timeout=timeout)\n\n    def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of power-devices according to the specified parameters. A filter is required to identify the\n        set of resources to be deleted.\n\n        Args:\n            resource: dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)\n\n    def add_ipdu(self, information, timeout=-1):\n        \"\"\"\n        Add an HP iPDU and bring all components under management by discovery of its management module. Bring the\n        management module under exclusive management by the appliance, configure any management or data collection\n        settings, and create a private set of administrative credentials to enable ongoing communication and management\n        of the iPDU. Use \"force\" to claim the device, even if claimed by another management appliance\n\n        Args:\n            resource: power device information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: added power device.\n        \"\"\"\n        uri = self.URI + \"/discover\"\n        return self._client.create(information, uri=uri, timeout=timeout)\n\n    def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the resource for the specified {id}. The properties that are omitted (not included as part of the the\n        request body) are reset to their respective default values. The id and uuid properties are required and cannot\n        be changed.\n\n        Args:\n            resource (dict): Object to update\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated power device\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)\n\n    def get_power_state(self, id_or_uri):\n        \"\"\"\n        Gets the power state (on, off or unknown) of the specified power delivery device that supports power control.\n        The device must be an HP Intelligent Outlet.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/powerState\"\n        return self._client.get(uri)\n\n    def update_power_state(self, id_or_uri, power_state):\n        \"\"\"\n        Sets the power state of the specified power delivery device. The device must be an HP Intelligent Outlet.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            power_state:\n                {\"powerState\":\"On|Off\"}\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/powerState\"\n        return self._client.update(power_state, uri)\n\n    def update_refresh_state(self, id_or_uri, refresh_state_data):\n        \"\"\"\n        Refreshes a given intelligent power delivery device.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            refresh_state_data:\n                Power device refresh request\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/refreshState\"\n        return self._client.update(refresh_state_data, uri=uri)\n\n    def remove_synchronous(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified by {id} synchronously.\n\n        Args:\n            resource: dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: operation success\n        \"\"\"\n        uri = self._client.build_uri(resource['uri']) + \"/synchronous\"\n        remove_resource = {'uri': uri}\n        return self._client.delete(remove_resource, force=force, timeout=timeout)\n\n    def get_uid_state(self, id_or_uri):\n        \"\"\"\n        Retrieves the unit identification (UID) state (on, off, unknown) of the specified power outlet or extension bar\n        resource. The device must be an HP iPDU component with a locator light (HP Intelligent Load Segment,\n        HP AC Module, HP Intelligent Outlet Bar, or HP Intelligent Outlet).\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            str: unit identification (UID) state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/uidState\"\n        return self._client.get(uri)\n\n    def update_uid_state(self, id_or_uri, refresh_state_data):\n        \"\"\"\n        Sets the unit identification (UID) light state of the specified power delivery device. The device must be an\n        HP iPDU component with a locator light (HP Intelligent Load Segment, HP AC Module, HP Intelligent Outlet Bar,\n        or HP Intelligent Outlet)\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            refresh_state_data:\n                Power device refresh request\n\n        Returns:\n            str: The UID state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/uidState\"\n        return self._client.update(refresh_state_data, uri)\n\n    def get_utilization(self, id_or_uri, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"\n        Retrieves historical utilization data for the specified metrics and time span. The device must be a component\n        of an HPE iPDU.\n\n        Args:\n            id_or_uri:\n                The power device id or the resource uri\n            fields:\n                Name of the metric(s) to be retrieved in the format METRIC[,METRIC]...If unspecified, all metrics\n                supported are returned. Power delivery devices support the following utilization metrics:\n\n                    * AveragePower\n                        Average power consumption in Watts during this sample interval.\n                    * PeakPower\n                        Peak power consumption in Watts during this sample interval.\n\n            filter (list or str):\n                Filters should be in the format: FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n\n                For Example: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate:\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate:\n                    End date of requested starting time range in ISO 8601 format. When omitted the endDate includes the\n                    latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The caller\n                is responsible for comparing the returned sliceStartTime with the requested startTime in the response.\n                If the sliceStartTime is greater than the oldestSampleTime and the requested start time, the caller is\n                responsible for repeating the request with endTime set to sliceStartTime to obtain the next segment.\n                This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned, but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource does have, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh:\n                Specifies that if necessary, an additional request will be queued to obtain the most recent utilization\n                data from the enclosure. The response will not include any refreshed data. To track the availability\n                of the newly collected data, monitor the TaskResource identified by the refreshTaskUri property in\n                the response. If null, no refresh was queued.\n            view:\n                Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native (DEFAULT)\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the enclosure. Samples at this\n                    resolution are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict: Utilization data\n        \"\"\"\n\n        return self._client.get_utilization(id_or_uri, fields, filter, refresh, view)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all power devices that match the filter\n        The search is case-insensitive\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            dict: power devices\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a set of power delivery device resources according to the specified parameters. Filters can be used to get\n        a specific set of power delivery devices. With no filters specified, the API returns a potentially paginated\n        list of all the power delivery device resources subject to start/count/sort parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n             list of power devices\n        \"\"\"\n        return self._client.get_all(start, count, filter=filter, sort=sort, query=query)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Gets a single power delivery device resource based upon its uri or id.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            dict: The power device\n        \"\"\"\n        return self._client.get(id_or_uri)",
  "def add(self, information, timeout=-1):\n        \"\"\"\n        Adds a power delivery device resource based upon the attributes specified. Use this method to create a\n        representation of power delivery devices that provide power to other resources but cannot otherwise be\n        discovered by the management appliance.\n\n        Args:\n            information:\n                power device information\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: added power device.\n        \"\"\"\n        return self._client.create(information, timeout=timeout)",
  "def remove(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the set of power-devices according to the specified parameters. A filter is required to identify the\n        set of resources to be deleted.\n\n        Args:\n            resource: dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n             bool: operation success\n        \"\"\"\n        return self._client.delete(resource, force=force, timeout=timeout)",
  "def add_ipdu(self, information, timeout=-1):\n        \"\"\"\n        Add an HP iPDU and bring all components under management by discovery of its management module. Bring the\n        management module under exclusive management by the appliance, configure any management or data collection\n        settings, and create a private set of administrative credentials to enable ongoing communication and management\n        of the iPDU. Use \"force\" to claim the device, even if claimed by another management appliance\n\n        Args:\n            resource: power device information\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: added power device.\n        \"\"\"\n        uri = self.URI + \"/discover\"\n        return self._client.create(information, uri=uri, timeout=timeout)",
  "def update(self, resource, timeout=-1):\n        \"\"\"\n        Updates the resource for the specified {id}. The properties that are omitted (not included as part of the the\n        request body) are reset to their respective default values. The id and uuid properties are required and cannot\n        be changed.\n\n        Args:\n            resource (dict): Object to update\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated power device\n        \"\"\"\n        return self._client.update(resource, timeout=timeout)",
  "def get_power_state(self, id_or_uri):\n        \"\"\"\n        Gets the power state (on, off or unknown) of the specified power delivery device that supports power control.\n        The device must be an HP Intelligent Outlet.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/powerState\"\n        return self._client.get(uri)",
  "def update_power_state(self, id_or_uri, power_state):\n        \"\"\"\n        Sets the power state of the specified power delivery device. The device must be an HP Intelligent Outlet.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            power_state:\n                {\"powerState\":\"On|Off\"}\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/powerState\"\n        return self._client.update(power_state, uri)",
  "def update_refresh_state(self, id_or_uri, refresh_state_data):\n        \"\"\"\n        Refreshes a given intelligent power delivery device.\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            refresh_state_data:\n                Power device refresh request\n\n        Returns:\n            str: The power state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/refreshState\"\n        return self._client.update(refresh_state_data, uri=uri)",
  "def remove_synchronous(self, resource, force=False, timeout=-1):\n        \"\"\"\n        Deletes the resource specified by {id} synchronously.\n\n        Args:\n            resource: dict object to remove\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: operation success\n        \"\"\"\n        uri = self._client.build_uri(resource['uri']) + \"/synchronous\"\n        remove_resource = {'uri': uri}\n        return self._client.delete(remove_resource, force=force, timeout=timeout)",
  "def get_uid_state(self, id_or_uri):\n        \"\"\"\n        Retrieves the unit identification (UID) state (on, off, unknown) of the specified power outlet or extension bar\n        resource. The device must be an HP iPDU component with a locator light (HP Intelligent Load Segment,\n        HP AC Module, HP Intelligent Outlet Bar, or HP Intelligent Outlet).\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n\n        Returns:\n            str: unit identification (UID) state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/uidState\"\n        return self._client.get(uri)",
  "def update_uid_state(self, id_or_uri, refresh_state_data):\n        \"\"\"\n        Sets the unit identification (UID) light state of the specified power delivery device. The device must be an\n        HP iPDU component with a locator light (HP Intelligent Load Segment, HP AC Module, HP Intelligent Outlet Bar,\n        or HP Intelligent Outlet)\n\n        Args:\n            id_or_uri:\n                Can be either the power device id or the uri\n            refresh_state_data:\n                Power device refresh request\n\n        Returns:\n            str: The UID state\n        \"\"\"\n        uri = self._client.build_uri(id_or_uri) + \"/uidState\"\n        return self._client.update(refresh_state_data, uri)",
  "def get_utilization(self, id_or_uri, fields=None, filter=None, refresh=False, view=None):\n        \"\"\"\n        Retrieves historical utilization data for the specified metrics and time span. The device must be a component\n        of an HPE iPDU.\n\n        Args:\n            id_or_uri:\n                The power device id or the resource uri\n            fields:\n                Name of the metric(s) to be retrieved in the format METRIC[,METRIC]...If unspecified, all metrics\n                supported are returned. Power delivery devices support the following utilization metrics:\n\n                    * AveragePower\n                        Average power consumption in Watts during this sample interval.\n                    * PeakPower\n                        Peak power consumption in Watts during this sample interval.\n\n            filter (list or str):\n                Filters should be in the format: FILTER_NAME=VALUE[,FILTER_NAME=VALUE]...\n\n                For Example: 'startDate=2016-05-30T11:20:44.541Z,endDate=2016-05-30T19:20:44.541Z'\n\n                startDate:\n                    Start date of requested starting time range in ISO 8601 format. If omitted, the startDate is\n                    determined by the endDate minus 24 hours.\n                endDate:\n                    End date of requested starting time range in ISO 8601 format. When omitted the endDate includes the\n                    latest data sample available.\n\n                If an excessive number of samples would otherwise be returned, the results will be segmented. The caller\n                is responsible for comparing the returned sliceStartTime with the requested startTime in the response.\n                If the sliceStartTime is greater than the oldestSampleTime and the requested start time, the caller is\n                responsible for repeating the request with endTime set to sliceStartTime to obtain the next segment.\n                This process is repeated until the full data set is retrieved.\n\n                If the resource has no data, the UtilizationData is still returned, but will contain no samples and\n                sliceStartTime/sliceEndTime will be equal. oldestSampleTime/newestSampleTime will still be set\n                appropriately (null if no data is available). If the filter does not happen to overlap the data\n                that a resource does have, then the metric history service will return null sample values for any\n                missing samples.\n\n            refresh:\n                Specifies that if necessary, an additional request will be queued to obtain the most recent utilization\n                data from the enclosure. The response will not include any refreshed data. To track the availability\n                of the newly collected data, monitor the TaskResource identified by the refreshTaskUri property in\n                the response. If null, no refresh was queued.\n            view:\n                Specifies the resolution interval length of the samples to be retrieved. This is reflected in the\n                resolution in the returned response. Utilization data is automatically purged to stay within storage\n                space constraints. Supported views are listed below:\n\n                native (DEFAULT)\n                    Resolution of the samples returned will be one sample for each 5-minute time period. This is the\n                    default view and matches the resolution of the data returned by the enclosure. Samples at this\n                    resolution are retained up to one year.\n                hour\n                    Resolution of the samples returned will be one sample for each 60-minute time period. Samples are\n                    calculated by averaging the available 5-minute data samples that occurred within the hour, except\n                    for PeakPower which is calculated by reporting the peak observed 5-minute sample value data during\n                    the hour. Samples at this resolution are retained up to three years.\n                day\n                    Resolution of the samples returned will be one sample for each 24-hour time period. One day is a\n                    24-hour period that starts at midnight GMT regardless of the time zone in which the appliance or\n                    client is located. Samples are calculated by averaging the available 5-minute data samples that\n                    occurred during the day, except for PeakPower which is calculated by reporting the peak observed\n                    5-minute sample value data during the day. Samples at this resolution are retained up to three\n                    years.\n\n        Returns:\n            dict: Utilization data\n        \"\"\"\n\n        return self._client.get_utilization(id_or_uri, fields, filter, refresh, view)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all power devices that match the filter\n        The search is case-insensitive\n\n        Args:\n            field: field name to filter\n            value: value to filter\n\n        Returns:\n            dict: power devices\n        \"\"\"\n        return self._client.get_by(field, value)",
  "class MetricStreaming(object):\n    \"\"\"\n    Metrics API client.\n\n    Metrics can be relayed from OneView for managed resources at a specified interval. The following steps can be\n    followed to enable the metric relay in OneView:\n\n        * Get the list of resource types and metrics which can be configured for live streaming\n        * Configure the live metric stream in OneView\n        * Receive the stream of metric on MSMB\n\n    The list below describes the structure of message relayed to MSMB:\n        startTime (str):\n            The starting time of the metric collection.\n        sampleIntervalInSeconds (int):\n            Interval between samples.\n        numberOfSamples (int):\n            Number of samples in the list for each metric type.\n        resourceType (str):\n            Identifies the resource type.\n        resourceDataList (list):\n            Metric sample list.\n        uri (str):\n            Canonical URI of the resource.\n        category (str):\n            Identifies the category of resource. The supported devices are server-hardware, enclosures, and\n            power-devices.\n        created (timestamp):\n            Date and time when the resource was created.\n        modified (timestamp):\n            Date and time when the resource was last modified.\n        eTag (str):\n            Entity tag/version ID of the resource, the same value that is returned in the ETag header on a GET of the\n            resource.\n        type (str):\n            Uniquely identifies the type of the JSON object.\n\n    \"\"\"\n    URI = '/rest/metrics'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_capability(self):\n        \"\"\"\n        Fetches the list of resource types and supported metrics that OneView is capable of relaying.\n\n        Returns:\n            list: List of resource types and supported metrics.\n        \"\"\"\n        return self._client.get(self.URI + \"/capability\")\n\n    def get_configuration(self):\n        \"\"\"\n        Fetches the current configuration for which metrics are being relayed.\n\n        Returns:\n            list: List of objects which contain frequency, sample interval, and source type for each resource-type.\n\n        \"\"\"\n        return self._client.get(self.URI + \"/configuration\")\n\n    def update_configuration(self, configuration):\n        \"\"\"\n        Updates the metrics configuration with the new values. Overwrites the existing configuration.\n\n        Args:\n            configuration (dict):\n                Dictionary with a list of objects which contain frequency, sample interval, and source type for each\n                resource-type.\n\n        Returns:\n            dict: The current configuration for which metrics are being relayed.\n\n        \"\"\"\n        return self._client.update(configuration, uri=self.URI + \"/configuration\")",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_capability(self):\n        \"\"\"\n        Fetches the list of resource types and supported metrics that OneView is capable of relaying.\n\n        Returns:\n            list: List of resource types and supported metrics.\n        \"\"\"\n        return self._client.get(self.URI + \"/capability\")",
  "def get_configuration(self):\n        \"\"\"\n        Fetches the current configuration for which metrics are being relayed.\n\n        Returns:\n            list: List of objects which contain frequency, sample interval, and source type for each resource-type.\n\n        \"\"\"\n        return self._client.get(self.URI + \"/configuration\")",
  "def update_configuration(self, configuration):\n        \"\"\"\n        Updates the metrics configuration with the new values. Overwrites the existing configuration.\n\n        Args:\n            configuration (dict):\n                Dictionary with a list of objects which contain frequency, sample interval, and source type for each\n                resource-type.\n\n        Returns:\n            dict: The current configuration for which metrics are being relayed.\n\n        \"\"\"\n        return self._client.update(configuration, uri=self.URI + \"/configuration\")",
  "class StorageVolumeTemplates(Resource):\n    \"\"\"\n    Storage Volume Templates API client.\n\n    \"\"\"\n    URI = '/rest/storage-volume-templates'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"StorageVolumeTemplateV3\"},\n        '300': {\"type\": \"StorageVolumeTemplateV3\"}\n    }\n\n    def __init__(self, connection, data=None):\n        super(StorageVolumeTemplates, self).__init__(connection, data)\n\n    def get_connectable_volume_templates(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets the storage volume templates that are available on the specified networks based on the storage system\n        port's expected network connectivity. If there are no storage volume templates that meet the specified\n        connectivity criteria, an empty collection will be returned.\n\n        Returns:\n            list: Storage volume templates.\n        \"\"\"\n        uri = self.URI + \"/connectable-volume-templates\"\n\n        get_uri = self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                               query=query, sort=sort, uri=uri)\n        return self._helper.do_get(get_uri)\n\n    def get_reachable_volume_templates(self, start=0, count=-1, filter='', query='', sort='',\n                                       networks=None, scope_uris='', private_allowed_only=False):\n        \"\"\"\n        Gets the storage templates that are connected on the specified networks based on the storage system\n        port's expected network connectivity.\n\n        Returns:\n            list: Storage volume templates.\n        \"\"\"\n        uri = self.URI + \"/reachable-volume-templates\"\n\n        uri += \"?networks={}&privateAllowedOnly={}\".format(networks, private_allowed_only)\n\n        get_uri = self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                               query=query, sort=sort, uri=uri, scope_uris=scope_uris)\n        return self._helper.do_get(get_uri)\n\n    def get_compatible_systems(self):\n        \"\"\"\n        Retrieves a collection of all storage systems that is applicable to this storage volume template.\n\n        Returns:\n            list: Storage systems.\n        \"\"\"\n        uri = \"{}/compatible-systems\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def delete(self, force=False, timeout=-1):\n        \"\"\"\n        Deletes the specified storage volume template.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        custom_headers = {'Accept-Language': 'en_US', 'If-Match': '*'}\n        uri = self.data['uri']\n\n        return self._helper.delete(uri, force=force, timeout=timeout, custom_headers=custom_headers)",
  "def __init__(self, connection, data=None):\n        super(StorageVolumeTemplates, self).__init__(connection, data)",
  "def get_connectable_volume_templates(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets the storage volume templates that are available on the specified networks based on the storage system\n        port's expected network connectivity. If there are no storage volume templates that meet the specified\n        connectivity criteria, an empty collection will be returned.\n\n        Returns:\n            list: Storage volume templates.\n        \"\"\"\n        uri = self.URI + \"/connectable-volume-templates\"\n\n        get_uri = self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                               query=query, sort=sort, uri=uri)\n        return self._helper.do_get(get_uri)",
  "def get_reachable_volume_templates(self, start=0, count=-1, filter='', query='', sort='',\n                                       networks=None, scope_uris='', private_allowed_only=False):\n        \"\"\"\n        Gets the storage templates that are connected on the specified networks based on the storage system\n        port's expected network connectivity.\n\n        Returns:\n            list: Storage volume templates.\n        \"\"\"\n        uri = self.URI + \"/reachable-volume-templates\"\n\n        uri += \"?networks={}&privateAllowedOnly={}\".format(networks, private_allowed_only)\n\n        get_uri = self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                               query=query, sort=sort, uri=uri, scope_uris=scope_uris)\n        return self._helper.do_get(get_uri)",
  "def get_compatible_systems(self):\n        \"\"\"\n        Retrieves a collection of all storage systems that is applicable to this storage volume template.\n\n        Returns:\n            list: Storage systems.\n        \"\"\"\n        uri = \"{}/compatible-systems\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def delete(self, force=False, timeout=-1):\n        \"\"\"\n        Deletes the specified storage volume template.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n        \"\"\"\n        custom_headers = {'Accept-Language': 'en_US', 'If-Match': '*'}\n        uri = self.data['uri']\n\n        return self._helper.delete(uri, force=force, timeout=timeout, custom_headers=custom_headers)",
  "class StorageVolumeAttachments(Resource):\n    \"\"\"\n    Storage Volume Attachments API client.\n\n    \"\"\"\n\n    URI = '/rest/storage-volume-attachments'\n\n    def __init__(self, connection, data=None):\n        super(StorageVolumeAttachments, self).__init__(connection, data)\n\n    def get_extra_unmanaged_storage_volumes(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets the list of extra unmanaged storage volumes.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: Extra unmanaged storage volumes.\n        \"\"\"\n        uri = self.URI + \"/repair?alertFixType=ExtraUnmanagedStorageVolumes\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, uri=uri)\n\n    def remove_extra_presentations(self, resource, timeout=-1):\n        \"\"\"\n        Removes extra presentations from a specified server profile.\n\n        Args:\n            resource (dict):\n                Object to create\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: Associated storage attachment resource.\n        \"\"\"\n        uri = self.URI + \"/repair\"\n        custom_headers = {'Accept-Language': 'en_US'}\n        return self._helper.create(resource, uri=uri, timeout=timeout, custom_headers=custom_headers)\n\n    def get_paths(self, path_id=''):\n        \"\"\"\n        Gets all paths or a specific attachment path for the specified volume attachment.\n\n        Args:\n            path_id: path id\n\n        Returns:\n            dict: Paths.\n        \"\"\"\n        if path_id:\n            uri = \"{}/paths/{}\".format(self.data[\"uri\"], path_id)\n        else:\n            uri = \"{}/paths\".format(self.data[\"uri\"])\n\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(StorageVolumeAttachments, self).__init__(connection, data)",
  "def get_extra_unmanaged_storage_volumes(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets the list of extra unmanaged storage volumes.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: Extra unmanaged storage volumes.\n        \"\"\"\n        uri = self.URI + \"/repair?alertFixType=ExtraUnmanagedStorageVolumes\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, uri=uri)",
  "def remove_extra_presentations(self, resource, timeout=-1):\n        \"\"\"\n        Removes extra presentations from a specified server profile.\n\n        Args:\n            resource (dict):\n                Object to create\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n        Returns:\n            dict: Associated storage attachment resource.\n        \"\"\"\n        uri = self.URI + \"/repair\"\n        custom_headers = {'Accept-Language': 'en_US'}\n        return self._helper.create(resource, uri=uri, timeout=timeout, custom_headers=custom_headers)",
  "def get_paths(self, path_id=''):\n        \"\"\"\n        Gets all paths or a specific attachment path for the specified volume attachment.\n\n        Args:\n            path_id: path id\n\n        Returns:\n            dict: Paths.\n        \"\"\"\n        if path_id:\n            uri = \"{}/paths/{}\".format(self.data[\"uri\"], path_id)\n        else:\n            uri = \"{}/paths\".format(self.data[\"uri\"])\n\n        return self._helper.do_get(uri)",
  "class DriveEnclosures(Resource, ResourcePatchMixin):\n    \"\"\"\n    Drive Enclosures API client.\n\n    Note:\n        This resource is only available on HPE Synergy\n\n    \"\"\"\n    URI = '/rest/drive-enclosures'\n\n    def __init__(self, connection, data=None):\n        super(DriveEnclosures, self).__init__(connection, data)\n\n    @ensure_resource_client\n    def get_port_map(self):\n        \"\"\"\n        Use to get the drive enclosure I/O adapter port to SAS interconnect port connectivity.\n\n        Returns:\n            dict: Drive Enclosure Port Map\n        \"\"\"\n        uri = \"{}/port-map\".format(self.data['uri'])\n        return self._helper.do_get(uri)\n\n    @ensure_resource_client\n    def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes a drive enclosure.\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Drive Enclosure\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data['uri'])\n        return self._helper.update(resource=configuration, uri=uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(DriveEnclosures, self).__init__(connection, data)",
  "def get_port_map(self):\n        \"\"\"\n        Use to get the drive enclosure I/O adapter port to SAS interconnect port connectivity.\n\n        Returns:\n            dict: Drive Enclosure Port Map\n        \"\"\"\n        uri = \"{}/port-map\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def refresh_state(self, configuration, timeout=-1):\n        \"\"\"\n        Refreshes a drive enclosure.\n\n        Args:\n            configuration: Configuration\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Drive Enclosure\n        \"\"\"\n        uri = \"{}/refreshState\".format(self.data['uri'])\n        return self._helper.update(resource=configuration, uri=uri, timeout=timeout)",
  "class SasLogicalJbods(Resource, ResourcePatchMixin):\n    \"\"\"\n    SAS Logical JBODs API client.\n\n    Note:\n        This resource is only available on HPE Synergy\n\n    \"\"\"\n    URI = '/rest/sas-logical-jbods'\n\n    def __init__(self, connection, data=None):\n        super(SasLogicalJbods, self).__init__(connection, data)\n\n    @ensure_resource_client\n    def get_drives(self):\n        \"\"\"\n        Gets the list of drives allocated to this SAS logical JBOD.\n\n        Args:\n            id_or_uri: Can be either the SAS logical JBOD ID or the SAS logical JBOD URI.\n\n        Returns:\n            list: A list of Drives\n        \"\"\"\n        uri = \"{}/drives\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(SasLogicalJbods, self).__init__(connection, data)",
  "def get_drives(self):\n        \"\"\"\n        Gets the list of drives allocated to this SAS logical JBOD.\n\n        Args:\n            id_or_uri: Can be either the SAS logical JBOD ID or the SAS logical JBOD URI.\n\n        Returns:\n            list: A list of Drives\n        \"\"\"\n        uri = \"{}/drives\".format(self.data['uri'])\n        return self._helper.do_get(uri)",
  "class StorageSystems(Resource):\n    \"\"\"\n    Storage Systems API client.\n\n    \"\"\"\n    URI = '/rest/storage-systems'\n\n    def __init__(self, connection, data=None):\n        super(StorageSystems, self).__init__(connection, data)\n\n    def add(self, resource, timeout=-1):\n        \"\"\"\n        Adds a storage system for management by the appliance. The storage system resource created will be in a\n        Connected state and will not yet be available for further operations. Users are required to perform a PUT API\n        on the storage system resource to complete the management of the storage system resource. An asynchronous task\n        will be created as a result of this API call to discover available domains, target ports, and storage pools.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created storage system.\n        \"\"\"\n        return self.create(resource, timeout=timeout)\n\n    def get_host_types(self):\n        \"\"\"\n        Gets the list of supported host types.\n\n        Returns:\n            list: Host types.\n        \"\"\"\n        uri = self.URI + \"/host-types\"\n        return self._helper.do_get(uri)\n\n    def get_storage_pools(self):\n        \"\"\"\n        Gets a list of Storage pools. Returns a list of storage pools belonging to the storage system referred by the\n        Path property {ID} parameter or URI.\n\n        Returns:\n            dict: Host types.\n        \"\"\"\n        uri = \"{}/storage-pools\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)\n\n    def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the storage system from OneView.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return self.delete(force=force, timeout=timeout, custom_headers=headers)\n\n    def get_managed_ports(self, port_id_or_uri=''):\n        \"\"\"\n        Gets all ports or a specific managed target port for the specified storage system.\n\n        Args:\n            port_id_or_uri: Can be either the port id or the port uri.\n\n        Returns:\n            dict: Managed ports.\n        \"\"\"\n        if port_id_or_uri:\n            uri = self._helper.build_uri(port_id_or_uri)\n            if \"/managedPorts\" not in uri:\n                uri = \"{}/managedPorts/{}\".format(self.data[\"uri\"], port_id_or_uri)\n\n        else:\n            uri = \"{}/managedPorts\".format(self.data[\"uri\"])\n\n        return self._helper.get_collection(uri)\n\n    def get_by_ip_hostname(self, ip_hostname):\n        \"\"\"\n        Retrieve a storage system by its IP.\n\n        Works only with API version <= 300.\n\n        Args:\n            ip_hostname: Storage system IP or hostname.\n\n        Returns:\n            dict\n        \"\"\"\n        resources = self.get_all()\n\n        resources_filtered = [x for x in resources if x['credentials']['ip_hostname'] == ip_hostname]\n\n        if resources_filtered:\n            return self.new(self._connection, resources_filtered[0])\n        else:\n            return None\n\n    def get_by_hostname(self, hostname):\n        \"\"\"\n        Retrieve a storage system by its hostname.\n\n        Works only in API500 onwards.\n\n        Args:\n            hostname: Storage system hostname.\n\n        Returns:\n            dict\n        \"\"\"\n        resources = self.get_all()\n\n        resources_filtered = [x for x in resources if x['hostname'] == hostname]\n\n        if resources_filtered:\n            return self.new(self._connection, resources_filtered[0])\n        else:\n            return None\n\n    def get_reachable_ports(self, start=0, count=-1, filter='', query='', sort='', networks=[]):\n        \"\"\"\n        Gets the storage ports that are connected on the specified networks\n        based on the storage system port's expected network connectivity.\n\n        Returns:\n            list: Reachable Storage Port List.\n        \"\"\"\n        uri = \"{}/reachable-ports\".format(self.data[\"uri\"])\n\n        if networks:\n            elements = \"\\'\"\n            for n in networks:\n                elements += n + ','\n            elements = elements[:-1] + \"\\'\"\n            uri = uri + \"?networks=\" + elements\n\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter, query=query,\n                                                                sort=sort, uri=uri))\n\n    def get_templates(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a list of volume templates. Returns a list of storage templates belonging to the storage system.\n\n        Returns:\n            list: Storage Template List.\n        \"\"\"\n        uri = \"{}/templates\".format(self.data[\"uri\"])\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                                                query=query, sort=sort, uri=uri))",
  "def __init__(self, connection, data=None):\n        super(StorageSystems, self).__init__(connection, data)",
  "def add(self, resource, timeout=-1):\n        \"\"\"\n        Adds a storage system for management by the appliance. The storage system resource created will be in a\n        Connected state and will not yet be available for further operations. Users are required to perform a PUT API\n        on the storage system resource to complete the management of the storage system resource. An asynchronous task\n        will be created as a result of this API call to discover available domains, target ports, and storage pools.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created storage system.\n        \"\"\"\n        return self.create(resource, timeout=timeout)",
  "def get_host_types(self):\n        \"\"\"\n        Gets the list of supported host types.\n\n        Returns:\n            list: Host types.\n        \"\"\"\n        uri = self.URI + \"/host-types\"\n        return self._helper.do_get(uri)",
  "def get_storage_pools(self):\n        \"\"\"\n        Gets a list of Storage pools. Returns a list of storage pools belonging to the storage system referred by the\n        Path property {ID} parameter or URI.\n\n        Returns:\n            dict: Host types.\n        \"\"\"\n        uri = \"{}/storage-pools\".format(self.data[\"uri\"])\n        return self._helper.do_get(uri)",
  "def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the storage system from OneView.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return self.delete(force=force, timeout=timeout, custom_headers=headers)",
  "def get_managed_ports(self, port_id_or_uri=''):\n        \"\"\"\n        Gets all ports or a specific managed target port for the specified storage system.\n\n        Args:\n            port_id_or_uri: Can be either the port id or the port uri.\n\n        Returns:\n            dict: Managed ports.\n        \"\"\"\n        if port_id_or_uri:\n            uri = self._helper.build_uri(port_id_or_uri)\n            if \"/managedPorts\" not in uri:\n                uri = \"{}/managedPorts/{}\".format(self.data[\"uri\"], port_id_or_uri)\n\n        else:\n            uri = \"{}/managedPorts\".format(self.data[\"uri\"])\n\n        return self._helper.get_collection(uri)",
  "def get_by_ip_hostname(self, ip_hostname):\n        \"\"\"\n        Retrieve a storage system by its IP.\n\n        Works only with API version <= 300.\n\n        Args:\n            ip_hostname: Storage system IP or hostname.\n\n        Returns:\n            dict\n        \"\"\"\n        resources = self.get_all()\n\n        resources_filtered = [x for x in resources if x['credentials']['ip_hostname'] == ip_hostname]\n\n        if resources_filtered:\n            return self.new(self._connection, resources_filtered[0])\n        else:\n            return None",
  "def get_by_hostname(self, hostname):\n        \"\"\"\n        Retrieve a storage system by its hostname.\n\n        Works only in API500 onwards.\n\n        Args:\n            hostname: Storage system hostname.\n\n        Returns:\n            dict\n        \"\"\"\n        resources = self.get_all()\n\n        resources_filtered = [x for x in resources if x['hostname'] == hostname]\n\n        if resources_filtered:\n            return self.new(self._connection, resources_filtered[0])\n        else:\n            return None",
  "def get_reachable_ports(self, start=0, count=-1, filter='', query='', sort='', networks=[]):\n        \"\"\"\n        Gets the storage ports that are connected on the specified networks\n        based on the storage system port's expected network connectivity.\n\n        Returns:\n            list: Reachable Storage Port List.\n        \"\"\"\n        uri = \"{}/reachable-ports\".format(self.data[\"uri\"])\n\n        if networks:\n            elements = \"\\'\"\n            for n in networks:\n                elements += n + ','\n            elements = elements[:-1] + \"\\'\"\n            uri = uri + \"?networks=\" + elements\n\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter, query=query,\n                                                                sort=sort, uri=uri))",
  "def get_templates(self, start=0, count=-1, filter='', query='', sort=''):\n        \"\"\"\n        Gets a list of volume templates. Returns a list of storage templates belonging to the storage system.\n\n        Returns:\n            list: Storage Template List.\n        \"\"\"\n        uri = \"{}/templates\".format(self.data[\"uri\"])\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter,\n                                                                query=query, sort=sort, uri=uri))",
  "class StoragePools(Resource):\n    \"\"\"\n    Storage Pools API client.\n\n    \"\"\"\n    URI = '/rest/storage-pools'\n\n    def __init__(self, connection, data=None):\n        super(StoragePools, self).__init__(connection, data)\n\n    def add(self, resource, timeout=-1):\n        \"\"\"\n        Adds storage pool for management by the appliance.\n\n        Args:\n            resource (dict):\n                Object to create\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created storage pool.\n\n        \"\"\"\n        return self.create(resource, timeout=timeout)\n\n    def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes an imported storage pool from OneView.\n\n        Args:\n            resource (dict):\n                Object to remove.\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)\n\n    def get_reachable_storage_pools(self, start=0, count=-1, filter='', query='', sort='',\n                                    networks=None, scope_exclusions=None, scope_uris=''):\n        \"\"\"\n        Gets the storage pools that are connected on the specified networks\n        based on the storage system port's expected network connectivity.\n\n        Args:\n            start: The first item to return, using 0-based indexing. If not specified,\n                the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter: A general filter/query string to narrow the list of items returned.\n                The default is no filter - all resources are returned.\n            sort: The sort order of the returned data set. By default, the sort order\n                is based on create time with the oldest entry first.\n            query: A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            networks: Specifies the comma-separated list of network URIs used by the\n                reachable storage pools.\n            scope_exclusions: Specifies the comma-separated list of storage-pools URIs\n                that will be excluded from the scope validation checks.\n            scope_uris: Specifies the comma-separated list of scope URIs used by the\n                reachable storage pools.\n\n        Returns:\n            list: Reachable Storage Pools List.\n        \"\"\"\n        uri = self.URI + \"/reachable-storage-pools\"\n\n        if networks:\n            elements = \"\\'\"\n            for n in networks:\n                elements += n + ','\n            elements = elements[:-1] + \"\\'\"\n            uri = uri + \"?networks=\" + elements\n\n        if scope_exclusions:\n            storage_pools_uris = \",\".join(scope_exclusions)\n            uri = uri + \"?\" if \"?\" not in uri else uri + \"&\"\n            uri += \"scopeExclusions={}\".format(storage_pools_uris)\n\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter, query=query,\n                                                                sort=sort, uri=uri, scope_uris=scope_uris))",
  "def __init__(self, connection, data=None):\n        super(StoragePools, self).__init__(connection, data)",
  "def add(self, resource, timeout=-1):\n        \"\"\"\n        Adds storage pool for management by the appliance.\n\n        Args:\n            resource (dict):\n                Object to create\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Created storage pool.\n\n        \"\"\"\n        return self.create(resource, timeout=timeout)",
  "def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes an imported storage pool from OneView.\n\n        Args:\n            resource (dict):\n                Object to remove.\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n\n        \"\"\"\n        return self.delete(force=force, timeout=timeout)",
  "def get_reachable_storage_pools(self, start=0, count=-1, filter='', query='', sort='',\n                                    networks=None, scope_exclusions=None, scope_uris=''):\n        \"\"\"\n        Gets the storage pools that are connected on the specified networks\n        based on the storage system port's expected network connectivity.\n\n        Args:\n            start: The first item to return, using 0-based indexing. If not specified,\n                the default is 0 - start with the first available item.\n            count: The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter: A general filter/query string to narrow the list of items returned.\n                The default is no filter - all resources are returned.\n            sort: The sort order of the returned data set. By default, the sort order\n                is based on create time with the oldest entry first.\n            query: A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            networks: Specifies the comma-separated list of network URIs used by the\n                reachable storage pools.\n            scope_exclusions: Specifies the comma-separated list of storage-pools URIs\n                that will be excluded from the scope validation checks.\n            scope_uris: Specifies the comma-separated list of scope URIs used by the\n                reachable storage pools.\n\n        Returns:\n            list: Reachable Storage Pools List.\n        \"\"\"\n        uri = self.URI + \"/reachable-storage-pools\"\n\n        if networks:\n            elements = \"\\'\"\n            for n in networks:\n                elements += n + ','\n            elements = elements[:-1] + \"\\'\"\n            uri = uri + \"?networks=\" + elements\n\n        if scope_exclusions:\n            storage_pools_uris = \",\".join(scope_exclusions)\n            uri = uri + \"?\" if \"?\" not in uri else uri + \"&\"\n            uri += \"scopeExclusions={}\".format(storage_pools_uris)\n\n        return self._helper.do_get(self._helper.build_query_uri(start=start, count=count, filter=filter, query=query,\n                                                                sort=sort, uri=uri, scope_uris=scope_uris))",
  "class SasLogicalJbodAttachments(Resource):\n    \"\"\"\n    SAS Logical JBOD Attachments API client.\n\n    Note:\n        This resource is only available on HPE Synergy\n\n    \"\"\"\n    URI = '/rest/sas-logical-jbod-attachments'\n\n    def __init__(self, connection, data=None):\n        super(SasLogicalJbodAttachments, self).__init__(connection, data)",
  "def __init__(self, connection, data=None):\n        super(SasLogicalJbodAttachments, self).__init__(connection, data)",
  "class VolumeSnapshots(Resource):\n    \"\"\"\n    Volume snapshots API client.\n\n    \"\"\"\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"Snapshot\"},\n        '300': {\"type\": \"Snapshot\"},\n        '500': {}\n    }\n\n    def __init__(self, connection, data=None, volume_uri=None, snapshot_id=None):\n        self.URI = \"{}/snapshots/{}\".format(volume_uri, snapshot_id or '')\n        super(VolumeSnapshots, self).__init__(connection, data)\n\n    def create(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        super(VolumeSnapshots, self).create(data, timeout=timeout, custom_headers=custom_headers, force=force)\n        return self.get_by_name(data[\"name\"])\n\n    def delete(self, force=False, timeout=-1):\n        \"\"\"\n        Deletes a snapshot from OneView and the storage system.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated volume.\n\n        \"\"\"\n        headers = {'If-Match': '*'}\n        super(VolumeSnapshots, self).delete(force=force, timeout=timeout,\n                                            custom_headers=headers)",
  "class Volumes(Resource):\n    \"\"\"\n    Volumes API client.\n\n    \"\"\"\n    URI = '/rest/storage-volumes'\n\n    def __init__(self, connection, data=None):\n        super(Volumes, self).__init__(connection, data)\n        self._snapshots = None\n\n    def __get_snapshot_object(self):\n        if self.data and not self._snapshots:\n            self._snapshots = VolumeSnapshots(self._connection,\n                                              volume_uri=self.data[\"uri\"])\n\n    def add_from_existing(self, resource, timeout=-1):\n        \"\"\"\n        Adds a volume that already exists in the Storage system\n\n        Args:\n            resource (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Added resource.\n        \"\"\"\n        uri = self.URI + \"/from-existing\"\n        return self._helper.create(resource, uri=uri, timeout=timeout)\n\n    def create_from_snapshot(self, data, timeout=-1):\n        \"\"\"\n        Creates a new volume on the storage system from a snapshot of a volume.\n        A volume template must also be specified when creating a volume from a snapshot.\n\n        The global setting \"StorageVolumeTemplateRequired\" controls whether or\n        not root volume templates can be used to provision volumes.\n        The value of this setting defaults to \"false\".\n        If the value is set to \"true\", then only templates with an \"isRoot\" value of \"false\"\n        can be used to provision a volume.\n\n        Args:\n            data (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created data.\n        \"\"\"\n        uri = self.URI + \"/from-snapshot\"\n        return self._helper.create(data, uri=uri, timeout=timeout)\n\n    def delete(self, force=False, export_only=None, suppress_device_updates=None, timeout=-1):\n        \"\"\"\n        Deletes a managed volume.\n\n        Args:\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            export_only:\n                Valid prior to API500. By default, volumes will be deleted from OneView, and storage system.\n                To delete the volume from OneView only, you must set its value to True.\n                Setting its value to False has the same behavior as the default behavior.\n            suppress_device_updates:\n                Valid API500 onwards. By default, volumes will be deleted from OneView, and storage system.\n                To delete the volume from OneView only, you must set its value to True.\n                Setting its value to False has the same behavior as the default behavior.\n\n        Returns:\n            bool: Indicates if the volume was successfully deleted.\n        \"\"\"\n        custom_headers = {'If-Match': '*'}\n        uri = self.data[\"uri\"]\n        if suppress_device_updates:\n            uri += '?suppressDeviceUpdates=true'\n        if export_only:\n            custom_headers['exportOnly'] = True\n        return self._helper.delete(uri, force=force, timeout=timeout, custom_headers=custom_headers)\n\n    def get_snapshots(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets all snapshots of a volume. Returns a list of snapshots based on optional sorting and filtering, and\n        constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of snapshots.\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_all(start, count, filter=filter, sort=sort)\n\n    def create_snapshot(self, snapshot, timeout=-1):\n        \"\"\"\n        Creates a snapshot for the specified volume.\n\n        Args:\n            snapshot (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Storage volume.\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.create(snapshot, timeout=timeout)\n\n    def get_snapshot_by_name(self, name):\n        \"\"\"\n        Gets snapshot by name.\n\n        Args:\n            name: Snapshot name\n\n        Returns:\n            object: VolumeSnapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by_name(name)\n\n    def get_snapshot_by_uri(self, uri):\n        \"\"\"\n        Gets snapshot by uri.\n\n        Args:\n            uri: Snapshot uri\n\n        Returns:\n            object: VolumeSnapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by_uri(uri)\n\n    def get_snapshot_by(self, field, value):\n        \"\"\"\n        Gets all snapshots that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: Snapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by(field, value)\n\n    def get_extra_managed_storage_volume_paths(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets the list of extra managed storage volume paths.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of extra managed storage volume paths.\n        \"\"\"\n        uri = self.URI + '/repair?alertFixType=ExtraManagedStorageVolumePaths'\n        return self._helper.get_all(start, count, filter=filter, sort=sort, uri=uri)\n\n    def repair(self, timeout=-1):\n        \"\"\"\n        Removes extra presentations from a specified volume on the storage system.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Storage volume.\n        \"\"\"\n        data = {\n            \"type\": \"ExtraManagedStorageVolumePaths\",\n            \"resourceUri\": self.data[\"uri\"]\n        }\n        custom_headers = {'Accept-Language': 'en_US'}\n        uri = self.URI + '/repair'\n        return self._helper.create(data, uri=uri, timeout=timeout, custom_headers=custom_headers)\n\n    def get_attachable_volumes(self, start=0, count=-1, filter='', query='', sort='', scope_uris='', connections=''):\n        \"\"\"\n        Gets the volumes that are connected on the specified networks based on the storage system port's expected\n        network connectivity.\n\n        A volume is attachable if it satisfies either of the following conditions:\n            * The volume is shareable.\n            * The volume not shareable and not attached.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default\n                is no query; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            connections:\n                A list of dicts specifics the connections used by the attachable volumes. Needs network uri, initiatoer\n                name and optional proxy name\n            scope_uris:\n                A list specifics the list of scope uris used by the attachable volumed.\n\n        Returns:\n            list: A list of attachable volumes that the appliance manages.\n        \"\"\"\n        uri = self.URI + '/attachable-volumes'\n        if connections:\n            uri += str('?' + 'connections=' + connections.__str__())\n            uri = uri.replace(\" \", \"\")\n        return self._helper.get_all(start, count, filter=filter, query=query, sort=sort, uri=uri, scope_uris=scope_uris)",
  "def __init__(self, connection, data=None, volume_uri=None, snapshot_id=None):\n        self.URI = \"{}/snapshots/{}\".format(volume_uri, snapshot_id or '')\n        super(VolumeSnapshots, self).__init__(connection, data)",
  "def create(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"Makes a POST request to create a resource when a request body is required.\n\n        Args:\n            data: Additional fields can be passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows set specific HTTP headers.\n        Returns:\n            Created resource.\n        \"\"\"\n        super(VolumeSnapshots, self).create(data, timeout=timeout, custom_headers=custom_headers, force=force)\n        return self.get_by_name(data[\"name\"])",
  "def delete(self, force=False, timeout=-1):\n        \"\"\"\n        Deletes a snapshot from OneView and the storage system.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated volume.\n\n        \"\"\"\n        headers = {'If-Match': '*'}\n        super(VolumeSnapshots, self).delete(force=force, timeout=timeout,\n                                            custom_headers=headers)",
  "def __init__(self, connection, data=None):\n        super(Volumes, self).__init__(connection, data)\n        self._snapshots = None",
  "def __get_snapshot_object(self):\n        if self.data and not self._snapshots:\n            self._snapshots = VolumeSnapshots(self._connection,\n                                              volume_uri=self.data[\"uri\"])",
  "def add_from_existing(self, resource, timeout=-1):\n        \"\"\"\n        Adds a volume that already exists in the Storage system\n\n        Args:\n            resource (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Added resource.\n        \"\"\"\n        uri = self.URI + \"/from-existing\"\n        return self._helper.create(resource, uri=uri, timeout=timeout)",
  "def create_from_snapshot(self, data, timeout=-1):\n        \"\"\"\n        Creates a new volume on the storage system from a snapshot of a volume.\n        A volume template must also be specified when creating a volume from a snapshot.\n\n        The global setting \"StorageVolumeTemplateRequired\" controls whether or\n        not root volume templates can be used to provision volumes.\n        The value of this setting defaults to \"false\".\n        If the value is set to \"true\", then only templates with an \"isRoot\" value of \"false\"\n        can be used to provision a volume.\n\n        Args:\n            data (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created data.\n        \"\"\"\n        uri = self.URI + \"/from-snapshot\"\n        return self._helper.create(data, uri=uri, timeout=timeout)",
  "def delete(self, force=False, export_only=None, suppress_device_updates=None, timeout=-1):\n        \"\"\"\n        Deletes a managed volume.\n\n        Args:\n            force:\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            export_only:\n                Valid prior to API500. By default, volumes will be deleted from OneView, and storage system.\n                To delete the volume from OneView only, you must set its value to True.\n                Setting its value to False has the same behavior as the default behavior.\n            suppress_device_updates:\n                Valid API500 onwards. By default, volumes will be deleted from OneView, and storage system.\n                To delete the volume from OneView only, you must set its value to True.\n                Setting its value to False has the same behavior as the default behavior.\n\n        Returns:\n            bool: Indicates if the volume was successfully deleted.\n        \"\"\"\n        custom_headers = {'If-Match': '*'}\n        uri = self.data[\"uri\"]\n        if suppress_device_updates:\n            uri += '?suppressDeviceUpdates=true'\n        if export_only:\n            custom_headers['exportOnly'] = True\n        return self._helper.delete(uri, force=force, timeout=timeout, custom_headers=custom_headers)",
  "def get_snapshots(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets all snapshots of a volume. Returns a list of snapshots based on optional sorting and filtering, and\n        constrained by start and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of snapshots.\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_all(start, count, filter=filter, sort=sort)",
  "def create_snapshot(self, snapshot, timeout=-1):\n        \"\"\"\n        Creates a snapshot for the specified volume.\n\n        Args:\n            snapshot (dict):\n                Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Storage volume.\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.create(snapshot, timeout=timeout)",
  "def get_snapshot_by_name(self, name):\n        \"\"\"\n        Gets snapshot by name.\n\n        Args:\n            name: Snapshot name\n\n        Returns:\n            object: VolumeSnapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by_name(name)",
  "def get_snapshot_by_uri(self, uri):\n        \"\"\"\n        Gets snapshot by uri.\n\n        Args:\n            uri: Snapshot uri\n\n        Returns:\n            object: VolumeSnapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by_uri(uri)",
  "def get_snapshot_by(self, field, value):\n        \"\"\"\n        Gets all snapshots that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: Snapshots\n        \"\"\"\n        self.__get_snapshot_object()\n        return self._snapshots.get_by(field, value)",
  "def get_extra_managed_storage_volume_paths(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets the list of extra managed storage volume paths.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of extra managed storage volume paths.\n        \"\"\"\n        uri = self.URI + '/repair?alertFixType=ExtraManagedStorageVolumePaths'\n        return self._helper.get_all(start, count, filter=filter, sort=sort, uri=uri)",
  "def repair(self, timeout=-1):\n        \"\"\"\n        Removes extra presentations from a specified volume on the storage system.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Storage volume.\n        \"\"\"\n        data = {\n            \"type\": \"ExtraManagedStorageVolumePaths\",\n            \"resourceUri\": self.data[\"uri\"]\n        }\n        custom_headers = {'Accept-Language': 'en_US'}\n        uri = self.URI + '/repair'\n        return self._helper.create(data, uri=uri, timeout=timeout, custom_headers=custom_headers)",
  "def get_attachable_volumes(self, start=0, count=-1, filter='', query='', sort='', scope_uris='', connections=''):\n        \"\"\"\n        Gets the volumes that are connected on the specified networks based on the storage system port's expected\n        network connectivity.\n\n        A volume is attachable if it satisfies either of the following conditions:\n            * The volume is shareable.\n            * The volume not shareable and not attached.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned. The default\n                is no query; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            connections:\n                A list of dicts specifics the connections used by the attachable volumes. Needs network uri, initiatoer\n                name and optional proxy name\n            scope_uris:\n                A list specifics the list of scope uris used by the attachable volumed.\n\n        Returns:\n            list: A list of attachable volumes that the appliance manages.\n        \"\"\"\n        uri = self.URI + '/attachable-volumes'\n        if connections:\n            uri += str('?' + 'connections=' + connections.__str__())\n            uri = uri.replace(\" \", \"\")\n        return self._helper.get_all(start, count, filter=filter, query=query, sort=sort, uri=uri, scope_uris=scope_uris)",
  "class Events(object):\n    URI = '/rest/events'\n\n    DEFAULT_VALUES = {\n        '200': {\"type\": \"EventResourceV3\"},\n        '300': {\"type\": \"EventResourceV3\"}\n    }\n\n    def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Retrieve an event by its URI or ID.\n\n        Args:\n            id_or_uri: event ID or URI.\n\n        Returns:\n            dict: The event.\n\n        \"\"\"\n\n        event = self._client.get(id_or_uri)\n        return event\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets all the events based upon filters provided.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of events.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all events that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of events.\n\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates an Event.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n\n        \"\"\"\n        return self._client.create(resource, timeout=timeout, default_values=self.DEFAULT_VALUES)",
  "def __init__(self, con):\n        self._client = ResourceClient(con, self.URI)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Retrieve an event by its URI or ID.\n\n        Args:\n            id_or_uri: event ID or URI.\n\n        Returns:\n            dict: The event.\n\n        \"\"\"\n\n        event = self._client.get(id_or_uri)\n        return event",
  "def get_all(self, start=0, count=-1, filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets all the events based upon filters provided.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of events.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all events that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of events.\n\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def create(self, resource, timeout=-1):\n        \"\"\"\n        Creates an Event.\n\n        Args:\n            resource (dict): Object to create.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Created resource.\n\n        \"\"\"\n        return self._client.create(resource, timeout=timeout, default_values=self.DEFAULT_VALUES)",
  "class Tasks(ResourcePatchMixin, Resource):\n    \"\"\"\n    Tasks API client.\n\n    \"\"\"\n    URI = '/rest/tasks'\n\n    def __init__(self, connection, data=None):\n        super(Tasks, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view='', topCount=0, childLimit=0):\n        \"\"\"\n        Gets all the tasks based upon filters provided.\n\n        Note:\n            Filters are optional.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n            childLimit:\n                 Total number of associated resources in an aggregated manner. Default value is 10.\n            topCount:\n                 Total number of immediate children the task should send back. Otherwise, the task sends back the\n                 aggregated view of the tree. Default value is 3.\n\n        Returns:\n            list: A list of tasks.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields, childLimit=childLimit, topCount=topCount)\n\n    def patch(self, uri, timeout=-1):\n        \"\"\"\n        Sets the state of task to cancelling only if IsCancellable is set to true for the task and its children or\n        children are in terminal state.\n\n        Args:\n            uri: URI of task resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        resp, body = self._connection.do_http('PATCH', path=uri, body=None)\n\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n        elif resp.status == 304:\n            if body and not isinstance(body, dict):\n                try:\n                    body = json.loads(body)\n                except Exception:\n                    pass\n        elif resp.status == 202:\n            task = self._connection.__get_task_from_response(resp, body)\n            return self._task_monitor.wait_for_task(task, timeout)\n\n        return body",
  "def __init__(self, connection, data=None):\n        super(Tasks, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, fields='', filter='', query='', sort='', view='', topCount=0, childLimit=0):\n        \"\"\"\n        Gets all the tasks based upon filters provided.\n\n        Note:\n            Filters are optional.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            fields:\n                 Specifies which fields should be returned in the result set.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n            childLimit:\n                 Total number of associated resources in an aggregated manner. Default value is 10.\n            topCount:\n                 Total number of immediate children the task should send back. Otherwise, the task sends back the\n                 aggregated view of the tree. Default value is 3.\n\n        Returns:\n            list: A list of tasks.\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view,\n                                    fields=fields, childLimit=childLimit, topCount=topCount)",
  "def patch(self, uri, timeout=-1):\n        \"\"\"\n        Sets the state of task to cancelling only if IsCancellable is set to true for the task and its children or\n        children are in terminal state.\n\n        Args:\n            uri: URI of task resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated resource.\n        \"\"\"\n        resp, body = self._connection.do_http('PATCH', path=uri, body=None)\n\n        if resp.status >= 400:\n            raise HPEOneViewException(body)\n        elif resp.status == 304:\n            if body and not isinstance(body, dict):\n                try:\n                    body = json.loads(body)\n                except Exception:\n                    pass\n        elif resp.status == 202:\n            task = self._connection.__get_task_from_response(resp, body)\n            return self._task_monitor.wait_for_task(task, timeout)\n\n        return body",
  "class Alerts(object):\n    URI = '/rest/alerts'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get(self, id_or_uri):\n        \"\"\"\n        Retrieve an alert by its URI or ID.\n\n        Args:\n            id_or_uri: alert ID or URI.\n\n        Returns:\n            dict: The alert.\n\n        \"\"\"\n\n        alert = self._client.get(id_or_uri)\n        return alert\n\n    def get_all(self, start=0, count=-1, filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets all the alerts based upon filters provided.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of alerts.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view)\n\n    def get_by(self, field, value):\n        \"\"\"\n        Gets all alerts that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of alerts.\n\n        \"\"\"\n        return self._client.get_by(field, value)\n\n    def delete(self, resource):\n        \"\"\"\n        Deletes an alert.\n\n        Args:\n            resource: dict object to delete\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(resource)\n\n    def delete_all(self, filter, timeout=-1):\n        \"\"\"\n        Deletes all Alert objects from the appliance that match the provided filter.\n\n        Args:\n            filter (list or str):\n                 A general filter string to narrow the list of items to delete. The default is no filter; all\n                 resources are deleted.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the alerts were successfully deleted.\n        \"\"\"\n        return self._client.delete_all(filter=filter, timeout=timeout)\n\n    def update(self, resource, id_or_uri=None, timeout=-1):\n        \"\"\"\n        Updates the specified alert resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated alert.\n        \"\"\"\n        uri = resource.pop('uri', None)\n        if not uri:\n            if not id_or_uri:\n                raise ValueError(\"URI was not provided\")\n            uri = self._client.build_uri(id_or_uri)\n        return self._client.update(resource=resource, uri=uri, timeout=timeout)\n\n    def delete_alert_change_log(self, id_or_uri):\n        \"\"\"\n        Deletes alert change log by alert ID or URI.\n\n        Args:\n            id_or_uri: alert ID or URI.\n        \"\"\"\n        uri = self.URI + \"/AlertChangeLog/\" + extract_id_from_uri(id_or_uri)\n        resource = {\n            \"uri\": uri\n        }\n        self._client.delete(resource)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get(self, id_or_uri):\n        \"\"\"\n        Retrieve an alert by its URI or ID.\n\n        Args:\n            id_or_uri: alert ID or URI.\n\n        Returns:\n            dict: The alert.\n\n        \"\"\"\n\n        alert = self._client.get(id_or_uri)\n        return alert",
  "def get_all(self, start=0, count=-1, filter='', query='', sort='', view=''):\n        \"\"\"\n        Gets all the alerts based upon filters provided.\n\n        Args:\n            start:\n                 The first item to return, using 0-based indexing. If not specified, the default is 0 - start with the\n                 first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                 A general filter/query string to narrow the list of items returned. The default is no filter; all\n                 resources are returned.\n            query:\n                 A general query string to narrow the list of resources returned. The default is no query (all\n                 resources are returned).\n            sort:\n                The sort order of the returned data set. By default, the sort order is based on create time, with the\n                oldest entry first.\n            view:\n                 Returns a specific subset of the attributes of the resource or collection, by specifying the name of a\n                 predefined view. The default view is expand (show all attributes of the resource and all elements of\n                 collections of resources).\n\n        Returns:\n            list: A list of alerts.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, query=query, sort=sort, view=view)",
  "def get_by(self, field, value):\n        \"\"\"\n        Gets all alerts that match the filter.\n\n        The search is case-insensitive.\n\n        Args:\n            field: Field name to filter.\n            value: Value to filter.\n\n        Returns:\n            list: List of alerts.\n\n        \"\"\"\n        return self._client.get_by(field, value)",
  "def delete(self, resource):\n        \"\"\"\n        Deletes an alert.\n\n        Args:\n            resource: dict object to delete\n\n        Returns:\n            bool: Indicates if the resource was successfully deleted.\n\n        \"\"\"\n        return self._client.delete(resource)",
  "def delete_all(self, filter, timeout=-1):\n        \"\"\"\n        Deletes all Alert objects from the appliance that match the provided filter.\n\n        Args:\n            filter (list or str):\n                 A general filter string to narrow the list of items to delete. The default is no filter; all\n                 resources are deleted.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            bool: Indicates whether the alerts were successfully deleted.\n        \"\"\"\n        return self._client.delete_all(filter=filter, timeout=timeout)",
  "def update(self, resource, id_or_uri=None, timeout=-1):\n        \"\"\"\n        Updates the specified alert resource.\n\n        Args:\n            resource (dict): Object to update.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Updated alert.\n        \"\"\"\n        uri = resource.pop('uri', None)\n        if not uri:\n            if not id_or_uri:\n                raise ValueError(\"URI was not provided\")\n            uri = self._client.build_uri(id_or_uri)\n        return self._client.update(resource=resource, uri=uri, timeout=timeout)",
  "def delete_alert_change_log(self, id_or_uri):\n        \"\"\"\n        Deletes alert change log by alert ID or URI.\n\n        Args:\n            id_or_uri: alert ID or URI.\n        \"\"\"\n        uri = self.URI + \"/AlertChangeLog/\" + extract_id_from_uri(id_or_uri)\n        resource = {\n            \"uri\": uri\n        }\n        self._client.delete(resource)",
  "class CertificateRabbitMQ(object):\n    URI = '/rest/certificates/client/rabbitmq'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def generate(self, information, timeout=-1):\n        \"\"\"\n        Generates a self signed certificate or an internal CA signed certificate for RabbitMQ clients.\n\n        Args:\n            information (dict): Information to generate the certificate for RabbitMQ clients.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: RabbitMQ certificate generated\n        \"\"\"\n        return self._client.create(information, timeout=timeout)\n\n    def get(self, alias_name):\n        \"\"\"\n        Retrieves the base-64 encoded certificate associated with the RabbitMQ user.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        return self._client.get(alias_name)\n\n    def get_key_pair(self, alias_name):\n        \"\"\"\n        Retrieves the public and private key pair associated with the specified alias name.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        uri = self.URI + \"/keypair/\" + alias_name\n        return self._client.get(uri)\n\n    def get_keys(self, alias_name, key_format):\n        \"\"\"\n        Retrieves the contents of PKCS12 file in the format specified.\n        This PKCS12 formatted file contains both the certificate as well as the key file data.\n        Valid key formats are Base64 and PKCS12.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n            key_format: Valid key formats are Base64 and PKCS12.\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        uri = self.URI + \"/keys/\" + alias_name + \"?format=\" + key_format\n        return self._client.get(uri)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def generate(self, information, timeout=-1):\n        \"\"\"\n        Generates a self signed certificate or an internal CA signed certificate for RabbitMQ clients.\n\n        Args:\n            information (dict): Information to generate the certificate for RabbitMQ clients.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: RabbitMQ certificate generated\n        \"\"\"\n        return self._client.create(information, timeout=timeout)",
  "def get(self, alias_name):\n        \"\"\"\n        Retrieves the base-64 encoded certificate associated with the RabbitMQ user.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        return self._client.get(alias_name)",
  "def get_key_pair(self, alias_name):\n        \"\"\"\n        Retrieves the public and private key pair associated with the specified alias name.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        uri = self.URI + \"/keypair/\" + alias_name\n        return self._client.get(uri)",
  "def get_keys(self, alias_name, key_format):\n        \"\"\"\n        Retrieves the contents of PKCS12 file in the format specified.\n        This PKCS12 formatted file contains both the certificate as well as the key file data.\n        Valid key formats are Base64 and PKCS12.\n\n        Args:\n            alias_name: Key pair associated with the RabbitMQ\n            key_format: Valid key formats are Base64 and PKCS12.\n        Returns:\n            dict: RabbitMQ certificate\n        \"\"\"\n        uri = self.URI + \"/keys/\" + alias_name + \"?format=\" + key_format\n        return self._client.get(uri)",
  "class Roles(object):\n    \"\"\"\n    Roles API client.\n    \"\"\"\n\n    URI = '/rest/roles'\n    RESOURCES_PATH = '/resources'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of roles based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of roles.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, sort=sort)\n\n    def get(self, name_or_uri):\n        \"\"\"\n        Get the role by its URI or Name.\n\n        Args:\n            name_or_uri:\n                Can be either the Name or the URI.\n\n        Returns:\n            dict: Role\n        \"\"\"\n        name_or_uri = quote(name_or_uri)\n        return self._client.get(name_or_uri)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of roles based on optional sorting and filtering and is constrained by start\n        and count parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of roles.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, filter=filter, sort=sort)",
  "def get(self, name_or_uri):\n        \"\"\"\n        Get the role by its URI or Name.\n\n        Args:\n            name_or_uri:\n                Can be either the Name or the URI.\n\n        Returns:\n            dict: Role\n        \"\"\"\n        name_or_uri = quote(name_or_uri)\n        return self._client.get(name_or_uri)",
  "class Users(Resource):\n    \"\"\"\n    Users API client.\n\n    \"\"\"\n\n    URI = '/rest/users'\n\n    def __init__(self, connection, data=None):\n        super(Users, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'UserAndRoles'\n        }\n\n    def validate_user_name(self, user_name, timeout=-1):\n        \"\"\"\n        Verifies if a userName is already in use.\n\n        Args:\n            user_name (str):\n                The userName to be verified.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: True if user name is in use, False if it is not.\n        \"\"\"\n        uri = self.URI + '/validateLoginName/' + user_name\n        return self.create(uri=uri)\n\n    def validate_full_name(self, full_name, timeout=-1):\n        \"\"\"\n        Verifies if a fullName is already in use.\n\n        Args:\n            full_name (str):\n                The fullName to be verified.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: True if full name is in use, False if it is not.\n        \"\"\"\n        uri = self.URI + '/validateUserName/' + full_name\n        return self.create(uri=uri)\n\n    def change_password(self, resource):\n        \"\"\"\n        Change one's own password\n\n        Args:\n            resource (dict): Object to change password\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        \"\"\"\n        uri = self._helper.build_uri('changePassword')\n        return self._helper.create(resource, uri)\n\n    def get_role_associated_with_userName(self, userName):\n        \"\"\"\n        Gets a user by userName.\n\n        Args:\n            name (str): userName of the user.\n\n        Returns:\n            dict object: User\n        \"\"\"\n\n        users = self.get_all()\n\n        result = [x for x in users if x['userName'] == userName]\n        resource = result[0] if result else None\n        if resource:\n            uri = self.URI + '/role/' + userName\n            data = self.get_by_uri(uri).data\n            result = data['members']\n            return result\n        else:\n            return None\n\n    def get_by_userName(self, name):\n        \"\"\"\n        Gets a complete json body for username\n\n        Args:\n          name (str): userName of the user\n\n        Returns:\n           dict object: User\n        \"\"\"\n\n        uri = self._helper.build_uri(name)\n        try:\n            resource = self.get_by_uri(uri)\n        except HPEOneViewException:\n            resource = None\n\n        return resource\n\n    def get_user_by_role(self, rolename):\n        \"\"\"\n        Gets all the users associated with this role\n\n        Args:\n          rolename (str): rolename of the user\n\n        Returns:\n          list: User\n        \"\"\"\n\n        rolename = quote(rolename)\n        uri = self.URI + '/roles/users/' + rolename\n        data = self.get_by_uri(uri).data\n        result = []\n        for i in range(0, len(data['members'])):\n            result.append(data[\"members\"][i])\n\n        return result\n\n    def create_multiple_user(self, data):\n        \"\"\"\n        Create a multiple user\n\n        Agrs:\n          data (list): multiple user\n\n        Returns:\n          dict object: User\n        \"\"\"\n\n        uri = self.URI + '?multiResource=true'\n        return self.create(data, uri)\n\n    def update(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"\n        Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            data (dict): Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        self.data = self._helper.update(resource, self.URI, force, timeout, custom_headers)\n\n        return self\n\n    def add_role_to_userName(self, username, data):\n        \"\"\"\n        Add roles to a given user name\n\n        Args:\n          username (str): userName of the user\n          data (list): roles to be added\n\n        Returns:\n          dict object: User\n        \"\"\"\n\n        uri = self.URI + '/' + username + '/roles?multiResource=true'\n        return self.create(data, uri)\n\n    def update_role_to_userName(self, username, data):\n        \"\"\"\n        Update roles to a given user name\n\n        Agrs:\n          username (str): username of the user\n          data (list): roles to be updated\n\n        Return:\n          dict: User\n        \"\"\"\n\n        uri = self.URI + '/' + username + '/roles?multiResource=true'\n        return self._helper.update(data, uri)\n\n    def remove_role_from_username(self, username, data):\n        \"\"\"\n        Removes a specified role from the username\n\n        Args:\n          username (str): username of the user\n          data (str/list): list role to be removed from user\n\n        Return:\n          boolean\n        \"\"\"\n\n        rolelist_query = self.query_filter(data)\n        uri = self.URI + '/roles?filter' + '=\"userName=\\'{}\\'{}'.format(username, rolelist_query)\n        return self._helper.delete(uri)\n\n    def delete_multiple_user(self, data):\n        \"\"\"\n        Delete the multiple users\n\n        Args:\n          data (list): List of users to be deleted\n\n        Returns:\n          None\n        \"\"\"\n\n        uri = self.URI + '?query='\n\n        for i in range(0, len(data)):\n            uri = uri + '(loginname=\\'{}\\')'.format(data[i])\n            if i == len(data) - 1:\n                break\n            uri = uri + quote(' or ')\n        self._helper.delete(uri)\n\n    def query_filter(self, filters):\n\n        formated_filter = ''\n        base_query = \"\\\"&filter=\\\"roleName=\\'{}\\'\\\"\"\n        if isinstance(filters, list):\n            for role in filters:\n                formated_filter += base_query.format(quote(role))\n            return formated_filter\n\n        if isinstance(filters, str):\n            return base_query.format(quote(filters))",
  "def __init__(self, connection, data=None):\n        super(Users, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'UserAndRoles'\n        }",
  "def validate_user_name(self, user_name, timeout=-1):\n        \"\"\"\n        Verifies if a userName is already in use.\n\n        Args:\n            user_name (str):\n                The userName to be verified.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: True if user name is in use, False if it is not.\n        \"\"\"\n        uri = self.URI + '/validateLoginName/' + user_name\n        return self.create(uri=uri)",
  "def validate_full_name(self, full_name, timeout=-1):\n        \"\"\"\n        Verifies if a fullName is already in use.\n\n        Args:\n            full_name (str):\n                The fullName to be verified.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns: True if full name is in use, False if it is not.\n        \"\"\"\n        uri = self.URI + '/validateUserName/' + full_name\n        return self.create(uri=uri)",
  "def change_password(self, resource):\n        \"\"\"\n        Change one's own password\n\n        Args:\n            resource (dict): Object to change password\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        \"\"\"\n        uri = self._helper.build_uri('changePassword')\n        return self._helper.create(resource, uri)",
  "def get_role_associated_with_userName(self, userName):\n        \"\"\"\n        Gets a user by userName.\n\n        Args:\n            name (str): userName of the user.\n\n        Returns:\n            dict object: User\n        \"\"\"\n\n        users = self.get_all()\n\n        result = [x for x in users if x['userName'] == userName]\n        resource = result[0] if result else None\n        if resource:\n            uri = self.URI + '/role/' + userName\n            data = self.get_by_uri(uri).data\n            result = data['members']\n            return result\n        else:\n            return None",
  "def get_by_userName(self, name):\n        \"\"\"\n        Gets a complete json body for username\n\n        Args:\n          name (str): userName of the user\n\n        Returns:\n           dict object: User\n        \"\"\"\n\n        uri = self._helper.build_uri(name)\n        try:\n            resource = self.get_by_uri(uri)\n        except HPEOneViewException:\n            resource = None\n\n        return resource",
  "def get_user_by_role(self, rolename):\n        \"\"\"\n        Gets all the users associated with this role\n\n        Args:\n          rolename (str): rolename of the user\n\n        Returns:\n          list: User\n        \"\"\"\n\n        rolename = quote(rolename)\n        uri = self.URI + '/roles/users/' + rolename\n        data = self.get_by_uri(uri).data\n        result = []\n        for i in range(0, len(data['members'])):\n            result.append(data[\"members\"][i])\n\n        return result",
  "def create_multiple_user(self, data):\n        \"\"\"\n        Create a multiple user\n\n        Agrs:\n          data (list): multiple user\n\n        Returns:\n          dict object: User\n        \"\"\"\n\n        uri = self.URI + '?multiResource=true'\n        return self.create(data, uri)",
  "def update(self, data=None, timeout=-1, custom_headers=None, force=False):\n        \"\"\"\n        Makes a PUT request to update a resource when a request body is required.\n\n        Args:\n            data (dict): Data to update the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n            custom_headers: Allows to add custom HTTP headers.\n            force: Force the update operation.\n\n        Returns:\n            A dict with the updated resource data.\n        \"\"\"\n\n        resource = deepcopy(self.data)\n        resource.update(data)\n\n        self.data = self._helper.update(resource, self.URI, force, timeout, custom_headers)\n\n        return self",
  "def add_role_to_userName(self, username, data):\n        \"\"\"\n        Add roles to a given user name\n\n        Args:\n          username (str): userName of the user\n          data (list): roles to be added\n\n        Returns:\n          dict object: User\n        \"\"\"\n\n        uri = self.URI + '/' + username + '/roles?multiResource=true'\n        return self.create(data, uri)",
  "def update_role_to_userName(self, username, data):\n        \"\"\"\n        Update roles to a given user name\n\n        Agrs:\n          username (str): username of the user\n          data (list): roles to be updated\n\n        Return:\n          dict: User\n        \"\"\"\n\n        uri = self.URI + '/' + username + '/roles?multiResource=true'\n        return self._helper.update(data, uri)",
  "def remove_role_from_username(self, username, data):\n        \"\"\"\n        Removes a specified role from the username\n\n        Args:\n          username (str): username of the user\n          data (str/list): list role to be removed from user\n\n        Return:\n          boolean\n        \"\"\"\n\n        rolelist_query = self.query_filter(data)\n        uri = self.URI + '/roles?filter' + '=\"userName=\\'{}\\'{}'.format(username, rolelist_query)\n        return self._helper.delete(uri)",
  "def delete_multiple_user(self, data):\n        \"\"\"\n        Delete the multiple users\n\n        Args:\n          data (list): List of users to be deleted\n\n        Returns:\n          None\n        \"\"\"\n\n        uri = self.URI + '?query='\n\n        for i in range(0, len(data)):\n            uri = uri + '(loginname=\\'{}\\')'.format(data[i])\n            if i == len(data) - 1:\n                break\n            uri = uri + quote(' or ')\n        self._helper.delete(uri)",
  "def query_filter(self, filters):\n\n        formated_filter = ''\n        base_query = \"\\\"&filter=\\\"roleName=\\'{}\\'\\\"\"\n        if isinstance(filters, list):\n            for role in filters:\n                formated_filter += base_query.format(quote(role))\n            return formated_filter\n\n        if isinstance(filters, str):\n            return base_query.format(quote(filters))",
  "class CertificatesServer(Resource):\n    \"\"\"\n    The Certificates Servers resource provides REST APIs for configuration of device or\n    server certificates for the appliance to establish SSL communication with other managed network entities.\n\n    Import, Update and Delete APIs are asynchronous and GET API is synchronous.\n\n    \"\"\"\n    URI = '/rest/certificates'\n\n    def __init__(self, connection, data=None):\n        super(CertificatesServer, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'CertificateInfoV2'\n        }\n\n    def create(self, data=None, timeout=-1):\n        \"\"\"\n        Makes a POST request to create a server certificate resource.\n\n        Args:\n            data: Fields passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Created certificate resource.\n        \"\"\"\n        uri_create = \"{}/servers\".format(self.URI)\n        return super(CertificatesServer, self).create(data, uri=uri_create, timeout=timeout)\n\n    def get_remote(self, remote_address):\n        \"\"\"\n        Retrieves the device or server certificate and certificate chain of the specified device or server.\n\n        Args:\n            remote_address:\n                Address of remote server\n\n        Return:\n             dict: Certificate chain of remote server\n        \"\"\"\n        uri = \"{0}/https/remote/{1}\".format(self.URI, remote_address)\n        return super(CertificatesServer, self).get_by_uri(uri=uri)\n\n    def get_by_alias_name(self, alias_name):\n        \"\"\"\n        Retrieves the device or server certificate, already trusted in the appliance,\n        with the specified aliasName.\n\n        Args:\n            alias_name (str): Alias name.\n\n        Return:\n            dict: Certificate of trusted appliance\n        \"\"\"\n        uri = \"{0}/servers/{1}\".format(self.URI, alias_name)\n        try:\n            response = super(CertificatesServer, self).get_by_uri(uri=uri)\n        except HPEOneViewException:\n            response = None\n        return response",
  "def __init__(self, connection, data=None):\n        super(CertificatesServer, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'CertificateInfoV2'\n        }",
  "def create(self, data=None, timeout=-1):\n        \"\"\"\n        Makes a POST request to create a server certificate resource.\n\n        Args:\n            data: Fields passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Created certificate resource.\n        \"\"\"\n        uri_create = \"{}/servers\".format(self.URI)\n        return super(CertificatesServer, self).create(data, uri=uri_create, timeout=timeout)",
  "def get_remote(self, remote_address):\n        \"\"\"\n        Retrieves the device or server certificate and certificate chain of the specified device or server.\n\n        Args:\n            remote_address:\n                Address of remote server\n\n        Return:\n             dict: Certificate chain of remote server\n        \"\"\"\n        uri = \"{0}/https/remote/{1}\".format(self.URI, remote_address)\n        return super(CertificatesServer, self).get_by_uri(uri=uri)",
  "def get_by_alias_name(self, alias_name):\n        \"\"\"\n        Retrieves the device or server certificate, already trusted in the appliance,\n        with the specified aliasName.\n\n        Args:\n            alias_name (str): Alias name.\n\n        Return:\n            dict: Certificate of trusted appliance\n        \"\"\"\n        uri = \"{0}/servers/{1}\".format(self.URI, alias_name)\n        try:\n            response = super(CertificatesServer, self).get_by_uri(uri=uri)\n        except HPEOneViewException:\n            response = None\n        return response",
  "class CertificateAuthority(Resource):\n    \"\"\"\n    Certificate Authority API client.\n    \"\"\"\n\n    URI = '/rest/certificates/ca'\n\n    def __init__(self, connection, data=None):\n        super(CertificateAuthority, self).__init__(connection, data)\n\n    def create(self, data=None, parent_task='', timeout=-1):\n        \"\"\"\n        Imports an external CA root certificate or CA certificate chain into the appliance trust store.\n        Same CA certificate will not be allowed to be imported into the appliance trust store.\n\n        Args:\n            data: Fields passed to create the resource.\n            parent_task: The parentTask can be passed only if auth header has either a valid trusted token\n                         or a valid combined token consisting of a trusted token.\n            timeout: Timeout in seconds. Wait for task completion by default.\n\n        Returns:\n            dict: response body of imported CA Certificate.\n        \"\"\"\n        if parent_task:\n            uri_create = \"{}?parentTask={}\".format(self.URI, parent_task)\n        else:\n            uri_create = self.URI\n\n        return super(CertificateAuthority, self).create(data, uri=uri_create, timeout=timeout)\n\n    def get_all(self, filter='', cert_details=True):\n        \"\"\"\n        Retrieves all the CA certificates.\n\n        Args:\n            filter: Filter based on a specific value. Supported filter is filter=certType:INTERNAL\n            cert_details: If this is set to true the api returns all the CA certificates with full certificate details\n\n        Returns:\n            list: List of all CA Certificate.\n        \"\"\"\n        custom_headers = {'If-Req-CertDetails': cert_details}\n        return self._helper.get_all(filter=filter, custom_headers=custom_headers)\n\n    def get_crl(self):\n        \"\"\"\n        Retrieves the contents of the CRL file maintained by the internal CA; in Base-64 encoded format, in the form\n        of a string.\n\n        Returns:\n            str: The Certificate Revocation List\n        \"\"\"\n        uri_crl = self.URI + \"/crl\"\n        return super(CertificateAuthority, self).get_by_uri(uri_crl)\n\n    def get_by_aliasname(self, alias_name):\n        \"\"\"\n        Returns the collection having CA certificates\n\n        Args:\n            alias_name: alias name of CA certificate\n\n        Returns:\n            dict: The Certificate details by certificate authority alias name\n        \"\"\"\n        uri = \"{}/{}\".format(self.URI, alias_name)\n        return super(CertificateAuthority, self).get_by_uri(uri)\n\n    def get_crl_by_aliasname(self, alias_name):\n        \"\"\"\n        Downloads the CRL file associated with the given certificate authority alias name.\n\n        Args:\n            alias_name: alias name of CA certificate\n\n        Returns:\n            str: The Certificate Revocation List by certificate authority alias name\n        \"\"\"\n        uri = \"{}/{}/crl\".format(self.URI, alias_name)\n        return super(CertificateAuthority, self).get_by_uri(uri)",
  "def __init__(self, connection, data=None):\n        super(CertificateAuthority, self).__init__(connection, data)",
  "def create(self, data=None, parent_task='', timeout=-1):\n        \"\"\"\n        Imports an external CA root certificate or CA certificate chain into the appliance trust store.\n        Same CA certificate will not be allowed to be imported into the appliance trust store.\n\n        Args:\n            data: Fields passed to create the resource.\n            parent_task: The parentTask can be passed only if auth header has either a valid trusted token\n                         or a valid combined token consisting of a trusted token.\n            timeout: Timeout in seconds. Wait for task completion by default.\n\n        Returns:\n            dict: response body of imported CA Certificate.\n        \"\"\"\n        if parent_task:\n            uri_create = \"{}?parentTask={}\".format(self.URI, parent_task)\n        else:\n            uri_create = self.URI\n\n        return super(CertificateAuthority, self).create(data, uri=uri_create, timeout=timeout)",
  "def get_all(self, filter='', cert_details=True):\n        \"\"\"\n        Retrieves all the CA certificates.\n\n        Args:\n            filter: Filter based on a specific value. Supported filter is filter=certType:INTERNAL\n            cert_details: If this is set to true the api returns all the CA certificates with full certificate details\n\n        Returns:\n            list: List of all CA Certificate.\n        \"\"\"\n        custom_headers = {'If-Req-CertDetails': cert_details}\n        return self._helper.get_all(filter=filter, custom_headers=custom_headers)",
  "def get_crl(self):\n        \"\"\"\n        Retrieves the contents of the CRL file maintained by the internal CA; in Base-64 encoded format, in the form\n        of a string.\n\n        Returns:\n            str: The Certificate Revocation List\n        \"\"\"\n        uri_crl = self.URI + \"/crl\"\n        return super(CertificateAuthority, self).get_by_uri(uri_crl)",
  "def get_by_aliasname(self, alias_name):\n        \"\"\"\n        Returns the collection having CA certificates\n\n        Args:\n            alias_name: alias name of CA certificate\n\n        Returns:\n            dict: The Certificate details by certificate authority alias name\n        \"\"\"\n        uri = \"{}/{}\".format(self.URI, alias_name)\n        return super(CertificateAuthority, self).get_by_uri(uri)",
  "def get_crl_by_aliasname(self, alias_name):\n        \"\"\"\n        Downloads the CRL file associated with the given certificate authority alias name.\n\n        Args:\n            alias_name: alias name of CA certificate\n\n        Returns:\n            str: The Certificate Revocation List by certificate authority alias name\n        \"\"\"\n        uri = \"{}/{}/crl\".format(self.URI, alias_name)\n        return super(CertificateAuthority, self).get_by_uri(uri)",
  "class LoginDetails(object):\n    \"\"\"\n    list login details.\n\n    \"\"\"\n\n    URI = '/rest/logindetails'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_login_details(self):\n        \"\"\"\n        List the login details\n\n        Returns:\n            dict: login details.\n        \"\"\"\n        return self._client.get(self.URI)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_login_details(self):\n        \"\"\"\n        List the login details\n\n        Returns:\n            dict: login details.\n        \"\"\"\n        return self._client.get(self.URI)",
  "class ManagedSANs(Resource):\n    \"\"\"\n    Managed SANs API client.\n\n    \"\"\"\n    URI = '/rest/fc-sans/managed-sans'\n\n    def __init__(self, connection, data=None):\n        super(ManagedSANs, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Retrieves the list of registered Managed SANs\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Managed SANs\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, query=query, sort=sort)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Gets a Managed SAN by name.\n\n        Args:\n            name: Name of the Managed SAN\n\n        Returns:\n            dict: Managed SAN.\n        \"\"\"\n        managed_sans = self.get_all()\n        result = [x for x in managed_sans if x['name'] == name]\n\n        resource = result[0] if result else None\n        if resource:\n            resource = self.new(self._connection, resource)\n\n        return resource\n\n    def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()\n\n    def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()\n\n    @ensure_resource_client\n    def get_endpoints(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of endpoints in a SAN.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of endpoints.\n        \"\"\"\n        uri = \"{}/endpoints/\".format(self.data[\"uri\"])\n        return self._helper.get_all(start, count, filter=filter, sort=sort, uri=uri)\n\n    @ensure_resource_client\n    def create_endpoints_csv_file(self, timeout=-1):\n        \"\"\"\n        Creates an endpoints CSV file for a SAN.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Endpoint CSV File Response.\n        \"\"\"\n        uri = \"{}/endpoints/\".format(self.data[\"uri\"])\n        return self._helper.do_post(uri, {}, timeout, None)\n\n    @ensure_resource_client\n    def create_issues_report(self, timeout=-1):\n        \"\"\"\n        Creates an unexpected zoning report for a SAN.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            list: A list of FCIssueResponse dict.\n        \"\"\"\n        uri = \"{}/issues/\".format(self.data[\"uri\"])\n        return self._helper.create_report(uri, timeout)\n\n    def get_wwn(self, wwn):\n        \"\"\"\n        Retrieves a list of associations between provided WWNs and the SANs (if any) on which they reside.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            wwn (str): The WWN that may be associated with the SAN.\n\n        Returns:\n            list: Associations between provided WWNs and the SANs\n        \"\"\"\n        uri = '/rest/fc-sans/managed-sans?locate=' + wwn\n        return self._helper.do_get(uri)",
  "def __init__(self, connection, data=None):\n        super(ManagedSANs, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Retrieves the list of registered Managed SANs\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of Managed SANs\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, query=query, sort=sort)",
  "def get_by_name(self, name):\n        \"\"\"\n        Gets a Managed SAN by name.\n\n        Args:\n            name: Name of the Managed SAN\n\n        Returns:\n            dict: Managed SAN.\n        \"\"\"\n        managed_sans = self.get_all()\n        result = [x for x in managed_sans if x['name'] == name]\n\n        resource = result[0] if result else None\n        if resource:\n            resource = self.new(self._connection, resource)\n\n        return resource",
  "def create(self):\n        \"\"\"Create method is not available\"\"\"\n        unavailable_method()",
  "def delete(self):\n        \"\"\"Delete method is not available\"\"\"\n        unavailable_method()",
  "def get_endpoints(self, start=0, count=-1, filter='', sort=''):\n        \"\"\"\n        Gets a list of endpoints in a SAN.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of endpoints.\n        \"\"\"\n        uri = \"{}/endpoints/\".format(self.data[\"uri\"])\n        return self._helper.get_all(start, count, filter=filter, sort=sort, uri=uri)",
  "def create_endpoints_csv_file(self, timeout=-1):\n        \"\"\"\n        Creates an endpoints CSV file for a SAN.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            dict: Endpoint CSV File Response.\n        \"\"\"\n        uri = \"{}/endpoints/\".format(self.data[\"uri\"])\n        return self._helper.do_post(uri, {}, timeout, None)",
  "def create_issues_report(self, timeout=-1):\n        \"\"\"\n        Creates an unexpected zoning report for a SAN.\n\n        Args:\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation in\n                OneView, just stops waiting for its completion.\n\n        Returns:\n            list: A list of FCIssueResponse dict.\n        \"\"\"\n        uri = \"{}/issues/\".format(self.data[\"uri\"])\n        return self._helper.create_report(uri, timeout)",
  "def get_wwn(self, wwn):\n        \"\"\"\n        Retrieves a list of associations between provided WWNs and the SANs (if any) on which they reside.\n\n        Note:\n            This method is available for API version 300 or later.\n\n        Args:\n            wwn (str): The WWN that may be associated with the SAN.\n\n        Returns:\n            list: Associations between provided WWNs and the SANs\n        \"\"\"\n        uri = '/rest/fc-sans/managed-sans?locate=' + wwn\n        return self._helper.do_get(uri)",
  "class SanProviders(Resource):\n    \"\"\"\n    SAN Managers API client.\n\n    \"\"\"\n\n    URI = '/rest/fc-sans/providers'\n\n    def __init__(self, connection, data=None):\n        super(SanProviders, self).__init__(connection, data)\n\n    def add(self, resource, provider_uri_or_id, timeout=-1):\n        \"\"\"\n        Adds a Device Manager under the specified provider.\n\n        Args:\n            resource (dict): Object to add.\n            provider_uri_or_id: ID or URI of provider.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Added SAN Manager.\n        \"\"\"\n        uri = provider_uri_or_id + \"/device-managers\"\n\n        return self._helper.create(data=resource, uri=uri, timeout=timeout)\n\n    def get_provider_uri(self, provider_display_name):\n        \"\"\"\n        Gets uri for a specific provider.\n\n        Args:\n            provider_display_name: Display name of the provider.\n\n        Returns:\n            uri\n        \"\"\"\n        providers = self.get_by_field('displayName', provider_display_name)\n        return providers.data['uri'] if providers else None\n\n    def get_default_connection_info(self, provider_name):\n        \"\"\"\n        Gets default connection info for a specific provider.\n\n        Args:\n            provider_name: Name of the provider.\n\n        Returns:\n            dict: Default connection information.\n        \"\"\"\n        provider = self.get_by_field('displayName', provider_name)\n\n        if provider:\n            return provider.data['defaultConnectionInfo']\n        else:\n            return {}",
  "def __init__(self, connection, data=None):\n        super(SanProviders, self).__init__(connection, data)",
  "def add(self, resource, provider_uri_or_id, timeout=-1):\n        \"\"\"\n        Adds a Device Manager under the specified provider.\n\n        Args:\n            resource (dict): Object to add.\n            provider_uri_or_id: ID or URI of provider.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView, just stop waiting for its completion.\n\n        Returns:\n            dict: Added SAN Manager.\n        \"\"\"\n        uri = provider_uri_or_id + \"/device-managers\"\n\n        return self._helper.create(data=resource, uri=uri, timeout=timeout)",
  "def get_provider_uri(self, provider_display_name):\n        \"\"\"\n        Gets uri for a specific provider.\n\n        Args:\n            provider_display_name: Display name of the provider.\n\n        Returns:\n            uri\n        \"\"\"\n        providers = self.get_by_field('displayName', provider_display_name)\n        return providers.data['uri'] if providers else None",
  "def get_default_connection_info(self, provider_name):\n        \"\"\"\n        Gets default connection info for a specific provider.\n\n        Args:\n            provider_name: Name of the provider.\n\n        Returns:\n            dict: Default connection information.\n        \"\"\"\n        provider = self.get_by_field('displayName', provider_name)\n\n        if provider:\n            return provider.data['defaultConnectionInfo']\n        else:\n            return {}",
  "class SanManagers(Resource):\n    \"\"\"\n    SAN Managers API client.\n\n    \"\"\"\n    URI = '/rest/fc-sans/device-managers'\n\n    def __init__(self, connection, data=None):\n        super(SanManagers, self).__init__(connection, data)\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Retrieves the list of registered SAN Managers.\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of SAN managers.\n\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, query=query,)\n\n    def update(self, resource, id_or_uri):\n        \"\"\"\n        Updates a registered Device Manager.\n\n        Args:\n            resource (dict): Object to update.\n            id_or_uri: Can be either the Device manager ID or URI.\n\n        Returns:\n            dict: The device manager resource.\n        \"\"\"\n\n        return self._helper.update(resource=resource, uri=id_or_uri)\n\n    def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the  SAN Manager from OneView.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return self.delete(force=force, timeout=timeout, custom_headers=headers)\n\n    def get_by_name(self, name):\n        \"\"\"\n        Gets a SAN Manager by name.\n\n        Args:\n            name: Name of the SAN Manager\n\n        Returns:\n            SAN Manager.\n        \"\"\"\n        san_managers = self.get_all()\n        result = [x for x in san_managers if x['name'] == name]\n\n        return self.new(self._connection, result[0])if result else None",
  "def __init__(self, connection, data=None):\n        super(SanManagers, self).__init__(connection, data)",
  "def get_all(self, start=0, count=-1, filter='', sort='', query=''):\n        \"\"\"\n        Retrieves the list of registered SAN Managers.\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: A list of SAN managers.\n\n        \"\"\"\n        return self._helper.get_all(start=start, count=count, filter=filter, sort=sort, query=query,)",
  "def update(self, resource, id_or_uri):\n        \"\"\"\n        Updates a registered Device Manager.\n\n        Args:\n            resource (dict): Object to update.\n            id_or_uri: Can be either the Device manager ID or URI.\n\n        Returns:\n            dict: The device manager resource.\n        \"\"\"\n\n        return self._helper.update(resource=resource, uri=id_or_uri)",
  "def remove(self, force=False, timeout=-1):\n        \"\"\"\n        Removes the  SAN Manager from OneView.\n\n        Args:\n            force (bool):\n                 If set to true, the operation completes despite any problems with\n                 network connectivity or errors on the resource itself. The default is false.\n            timeout:\n                Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Returns:\n            dict: Details of associated resource.\n        \"\"\"\n        headers = {'If-Match': '*'}\n        return self.delete(force=force, timeout=timeout, custom_headers=headers)",
  "def get_by_name(self, name):\n        \"\"\"\n        Gets a SAN Manager by name.\n\n        Args:\n            name: Name of the SAN Manager\n\n        Returns:\n            SAN Manager.\n        \"\"\"\n        san_managers = self.get_all()\n        result = [x for x in san_managers if x['name'] == name]\n\n        return self.new(self._connection, result[0])if result else None",
  "class Endpoints(object):\n    \"\"\"\n    Endpoints API client.\n\n    \"\"\"\n    URI = '/rest/fc-sans/endpoints'\n\n    def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)\n\n    def get_all(self, start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Retrieves the list of endpoints known by the appliance.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: The endpoints known by the appliance.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, query=query, sort=sort)",
  "def __init__(self, con):\n        self._connection = con\n        self._client = ResourceClient(con, self.URI)",
  "def get_all(self, start=0, count=-1, query='', sort=''):\n        \"\"\"\n        Retrieves the list of endpoints known by the appliance.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items. The actual number of items in\n                the response may differ from the requested count if the sum of start and count exceed the total number\n                of items.\n            query:\n                A general query string to narrow the list of resources returned.\n                The default is no query - all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n\n        Returns:\n            list: The endpoints known by the appliance.\n        \"\"\"\n        return self._client.get_all(start=start, count=count, query=query, sort=sort)",
  "class HypervisorManagers(Resource):\n    \"\"\"\n    Hypervisor Managers API client.\n\n    \"\"\"\n    URI = '/rest/hypervisor-managers'\n\n    def __init__(self, connection, data=None):\n        super(HypervisorManagers, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'HypervisorManagerV2'\n        }\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query='', scope_uris=''):\n        \"\"\"\n        Gets a list of Hypervisor Managers based on optional sorting and filtering, and constrained by start and count\n        parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n             list: List of Hypervisor Managers\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, scope_uris=scope_uris)",
  "def __init__(self, connection, data=None):\n        super(HypervisorManagers, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'HypervisorManagerV2'\n        }",
  "def get_all(self, start=0, count=-1, filter='', sort='', query='', scope_uris=''):\n        \"\"\"\n        Gets a list of Hypervisor Managers based on optional sorting and filtering, and constrained by start and count\n        parameters.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Returns:\n             list: List of Hypervisor Managers\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, scope_uris=scope_uris)",
  "class HypervisorClusterProfiles(Resource):\n    \"\"\"\n    The cluster profile resource manager REST APIs to create, retrieve, modify and delete hypervisor cluster profiles.\n    \"\"\"\n    URI = '/rest/hypervisor-cluster-profiles'\n    DEFAULT_VALUES = {\n        '2200': {'type': 'HypervisorClusterProfileV4'}\n    }\n\n    def __init__(self, connection, data=None):\n        super(HypervisorClusterProfiles, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'HypervisorClusterProfileV3'\n        }\n\n    def get_all(self, start=0, count=-1, filter='', sort='', query='', scope_uris=''):\n        \"\"\"\n        Gets a list of hypervisor cluster profiles based on optional sorting and filtering,\n        and constrained by start and count parameters.\n\n        The maximum number of profiles is restricted to 100, i.e.,\n        if user requests more than 100, this will be internally limited to 100.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Return:\n             list: List of Hypervisor cluster profiles\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, scope_uris=scope_uris)\n\n    def create_virtual_switch_layout(self, data=None, timeout=-1):\n        \"\"\"Generates vSwitch layout using information specified in the request body.\n\n        Args:\n            data: Fields passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Created virtual switch layout.\n        \"\"\"\n        if not data:\n            data = {}\n\n        vswitch_uri = \"{}/virtualswitch-layout\".format(self.URI)\n        return self._helper.create(data, vswitch_uri, timeout)\n\n    def get_compliance_preview(self):\n        \"\"\"\n        Gets the preview of manual and automatic updates required to make the cluster profile consistent with its template.\n\n        Return:\n            cluster profile compliance preview\n        \"\"\"\n        compliance_uri = \"{0}/compliance-preview\".format(self.data[\"uri\"])\n        return self._helper.do_get(compliance_uri)\n\n    def delete(self, timeout=-1, soft_delete=False, force=False):\n        \"\"\"\n        Deletes a hypervisor cluster profile object from the appliance based on Hypervisor Cluster Profile UUID\n\n        Args:\n            force:\n                If set to true, the operation completes despite any probles with network\n                connectivity or errors on the resource itself. Default is false.\n            soft_delete:\n                If set to true, the hypervisor cluster profile and its hypervisor profiles\n                are removed from appliance only. If set to false, the associated cluster and\n                hosts are also removed in the hypervisor manager.\n\n        Return:\n            Boolean value. True for success and False for failure.\n        \"\"\"\n        uri = \"{}?softDelete={}\".format(self.data['uri'], soft_delete)\n\n        if force:\n            uri += '&force=True'\n\n        return self._helper.delete(uri, timeout=timeout)",
  "def __init__(self, connection, data=None):\n        super(HypervisorClusterProfiles, self).__init__(connection, data)\n        self.__default_values = {\n            'type': 'HypervisorClusterProfileV3'\n        }",
  "def get_all(self, start=0, count=-1, filter='', sort='', query='', scope_uris=''):\n        \"\"\"\n        Gets a list of hypervisor cluster profiles based on optional sorting and filtering,\n        and constrained by start and count parameters.\n\n        The maximum number of profiles is restricted to 100, i.e.,\n        if user requests more than 100, this will be internally limited to 100.\n\n        Args:\n            start:\n                The first item to return, using 0-based indexing.\n                If not specified, the default is 0 - start with the first available item.\n            count:\n                The number of resources to return. A count of -1 requests all items.\n                The actual number of items in the response might differ from the requested\n                count if the sum of start and count exceeds the total number of items.\n            filter (list or str):\n                A general filter/query string to narrow the list of items returned. The\n                default is no filter; all resources are returned.\n            sort:\n                The sort order of the returned data set. By default, the sort order is based\n                on create time with the oldest entry first.\n            query:\n                 A general query string to narrow the list of resources returned. The default\n                 is no query - all resources are returned.\n            scope_uris:\n                An expression to restrict the resources returned according to the scopes to\n                which they are assigned.\n\n        Return:\n             list: List of Hypervisor cluster profiles\n        \"\"\"\n        return self._helper.get_all(start, count, filter=filter, sort=sort, query=query, scope_uris=scope_uris)",
  "def create_virtual_switch_layout(self, data=None, timeout=-1):\n        \"\"\"Generates vSwitch layout using information specified in the request body.\n\n        Args:\n            data: Fields passed to create the resource.\n            timeout: Timeout in seconds. Wait for task completion by default. The timeout does not abort the operation\n                in OneView; it just stops waiting for its completion.\n\n        Return:\n            Created virtual switch layout.\n        \"\"\"\n        if not data:\n            data = {}\n\n        vswitch_uri = \"{}/virtualswitch-layout\".format(self.URI)\n        return self._helper.create(data, vswitch_uri, timeout)",
  "def get_compliance_preview(self):\n        \"\"\"\n        Gets the preview of manual and automatic updates required to make the cluster profile consistent with its template.\n\n        Return:\n            cluster profile compliance preview\n        \"\"\"\n        compliance_uri = \"{0}/compliance-preview\".format(self.data[\"uri\"])\n        return self._helper.do_get(compliance_uri)",
  "def delete(self, timeout=-1, soft_delete=False, force=False):\n        \"\"\"\n        Deletes a hypervisor cluster profile object from the appliance based on Hypervisor Cluster Profile UUID\n\n        Args:\n            force:\n                If set to true, the operation completes despite any probles with network\n                connectivity or errors on the resource itself. Default is false.\n            soft_delete:\n                If set to true, the hypervisor cluster profile and its hypervisor profiles\n                are removed from appliance only. If set to false, the associated cluster and\n                hosts are also removed in the hypervisor manager.\n\n        Return:\n            Boolean value. True for success and False for failure.\n        \"\"\"\n        uri = \"{}?softDelete={}\".format(self.data['uri'], soft_delete)\n\n        if force:\n            uri += '&force=True'\n\n        return self._helper.delete(uri, timeout=timeout)"
]