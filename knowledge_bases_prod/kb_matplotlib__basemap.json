[
  "def get_content(name, splitlines=False):\n    \"\"\"Return the file contents with project root as root folder.\"\"\"\n\n    here = os.path.abspath(os.path.dirname(__file__))\n    path = os.path.join(here, name)\n    with io.open(path, \"r\", encoding=\"utf-8\") as fd:\n        content = fd.read()\n    if splitlines:\n        content = [row for row in content.splitlines() if row]\n    return content",
  "def get_content(name, splitlines=False):\n    \"\"\"Return the file contents with project root as root folder.\"\"\"\n\n    here = os.path.abspath(os.path.dirname(__file__))\n    path = os.path.join(here, name)\n    with io.open(path, \"r\", encoding=\"utf-8\") as fd:\n        content = fd.read()\n    if splitlines:\n        content = [row for row in content.splitlines() if row]\n    return content",
  "def get_version(pkgname):\n    \"\"\"Return package version without importing the file.\"\"\"\n\n    here = os.path.abspath(os.path.dirname(__file__))\n    path = os.path.join(*[here, \"src\"] + pkgname.split(\".\") + [\"__init__.py\"])\n    with io.open(path, \"r\", encoding=\"utf-8\") as fd:\n        pattern = r\"\"\"\\n__version__[ ]*=[ ]*[\"']([^\"]+)[\"']\"\"\"\n        return re.search(pattern, fd.read()).group(1)",
  "def get_geos_install_prefix():\n    \"\"\"Return GEOS installation prefix or None if not found.\"\"\"\n\n    env_candidate = os.environ.get(\"GEOS_DIR\", None)\n    if env_candidate is not None:\n        candidates = [env_candidate]\n    else:\n        candidates = [os.path.expanduser(\"~/local\"), os.path.expanduser(\"~\"),\n                      \"/usr/local\", \"/usr\", \"/opt/local\", \"/opt\", \"/sw\"]\n\n    # Prepare filename pattern to find the GEOS library.\n    extensions = {\"win32\": \"dll\", \"cygwin\": \"dll\", \"darwin\": \"dylib\"}\n    libext = extensions.get(sys.platform, \"so*\")\n    libname = \"*geos_c*.{0}\".format(libext)\n    libdirs = [\"bin\", \"lib\", \"lib/x86_64-linux-gnu\", \"lib64\"]\n\n    for prefix in candidates:\n        libfiles = []\n        for libdir in libdirs:\n            libfiles.extend(glob.glob(os.path.join(prefix, libdir, libname)))\n        hfile = os.path.join(prefix, \"include\", \"geos_c.h\")\n        if os.path.isfile(hfile) and libfiles:\n            return prefix\n\n    # At this point, the GEOS library was not found, so we throw a warning if\n    # the user is trying to build the library.\n    build_cmds = (\"bdist_wheel\", \"build\", \"install\")\n    if any(cmd in sys.argv[1:] for cmd in build_cmds):\n        warnings.warn(\" \".join([\n            \"Cannot find GEOS library and/or headers in standard locations\",\n            \"('{0}'). Please install the corresponding packages using your\",\n            \"software management system or set the environment variable\",\n            \"GEOS_DIR to point to the location where GEOS is installed\",\n            \"(for example, if 'geos_c.h' is in '/usr/local/include'\",\n            \"and 'libgeos_c' is in '/usr/local/lib', then you need to\",\n            \"set GEOS_DIR to '/usr/local'\",\n        ]).format(\"', '\".join(candidates)), RuntimeWarning)\n    return None",
  "class basemap_sdist(sdist):\n    \"\"\"Custom `sdist` so that it will not pack DLLs on Windows if present.\"\"\"\n\n    def run(self):\n        \"\"\"Custom `run` command.\"\"\"\n\n        # Replace DLL data files and add GEOS build script.\n        orig_data_files = self.distribution.data_files\n        self.distribution.data_files = [\n            (\".\", glob.glob(os.path.join(\"utils\", \"*.py\")))]\n\n        # Run the original `run` method and leave `data_files` as it was found.\n        try:\n            sdist.run(self)\n        finally:\n            self.distribution.data_files = orig_data_files",
  "def run(self):\n        \"\"\"Custom `run` command.\"\"\"\n\n        # Replace DLL data files and add GEOS build script.\n        orig_data_files = self.distribution.data_files\n        self.distribution.data_files = [\n            (\".\", glob.glob(os.path.join(\"utils\", \"*.py\")))]\n\n        # Run the original `run` method and leave `data_files` as it was found.\n        try:\n            sdist.run(self)\n        finally:\n            self.distribution.data_files = orig_data_files",
  "def html():\n    os.system('sphinx-build -b html -d build/doctrees . build/html')",
  "def latex():\n    if sys.platform != 'win32':\n        # LaTeX format.\n        os.system('sphinx-build -b latex -d build/doctrees . build/latex')\n\n        # Produce pdf.\n        os.chdir('build/latex')\n\n        # Copying the makefile produced by sphinx...\n        os.system('pdflatex Basemap.tex')\n        os.system('pdflatex Basemap.tex')\n        os.system('makeindex -s python.ist Basemap.idx')\n        os.system('makeindex -s python.ist modBasemap.idx')\n        os.system('pdflatex Basemap.tex')\n\n        os.chdir('../..')\n    else:\n        print('latex build has not been tested on windows')",
  "def clean():\n    shutil.rmtree('build')",
  "def all():\n    html()\n    latex()",
  "def extrema(mat,mode='wrap',window=10):\n    \"\"\"find the indices of local extrema (min and max)\n    in the input array.\"\"\"\n    mn = minimum_filter(mat, size=window, mode=mode)\n    mx = maximum_filter(mat, size=window, mode=mode)\n    # (mat == mx) true if pixel is equal to the local max\n    # (mat == mn) true if pixel is equal to the local in\n    # Return the indices of the maxima, minima\n    return np.nonzero(mat == mn), np.nonzero(mat == mx)",
  "def proj4_version():\n    \"\"\"\n    Gives the proj.4 library's version number. (requires pyproj to be installed)\n\n    returns string, so proj.4 version 4.9.3 will return \"4.9.3\"\n    \"\"\"\n    import pyproj\n    try:\n        return pyproj.proj_version_str\n    except AttributeError:\n        # for pyproj versions 1.9.5.1 and before, this will run\n        # Get PROJ4 version in a floating point number\n        proj4_ver_num = pyproj.Proj(proj='latlong').proj_version\n\n        # reformats floating point number into string (4.90 becomes '4.9.0')\n        # Exploits single number version numbers for proj4,\n        return '.'.join( str(int(proj4_ver_num*100)) )",
  "def package_versions():\n    \"\"\"\n    Gives version information for dependent packages.\n\n    returns namedtuple BasemapPackageVersions\n    \"\"\"\n    from collections import namedtuple\n    from sys import version as sys_version\n\n    from matplotlib import __version__ as matplotlib_version\n    from numpy import __version__ as numpy_version\n    from pyproj import __version__ as pyproj_version\n    from shapefile import __version__ as pyshp_version\n\n    import _geoslib\n    from mpl_toolkits.basemap import __version__ as basemap_version\n\n    try:\n        # geodesic is a part of proj.4 library\n        # new variable in pyproj versions greater than 1.9.5.1\n        from pyproj import geodesic_version_str as geodesic_version\n    except ImportError:\n        geodesic_version = 'Unknown'\n\n    # import optional dependencies\n    try:\n        from OWSLib import __version__ as OWSLib_version\n    except ImportError:\n        OWSLib_version = 'not installed'\n\n    try:\n        from PIL import __version__ as pillow_version\n    except ImportError:\n        pillow_version = 'not installed'\n\n    BasemapPackageVersions = namedtuple(\n                               'BasemapPackageVersions',\n                               \"\"\"Python, basemap, matplotlib,\n                                  numpy, pyproj, pyshp, PROJ4, geodesic,\n                                  GEOS, OWSLib, Pillow\"\"\")\n\n    return BasemapPackageVersions(\n                   Python = sys_version,\n                   basemap = basemap_version,\n                   matplotlib = matplotlib_version,\n                   numpy = numpy_version,\n                   pyproj = pyproj_version,\n                   pyshp = pyshp_version,\n                   PROJ4 = proj4_version(),\n                   geodesic = geodesic_version,\n                   GEOS = _geoslib.__geos_version__,\n                   # optional dependencies below\n                   OWSLib = OWSLib_version,\n                   Pillow = pillow_version)",
  "def check_proj_inv_hammer(segfault_protection=True):\n    \"\"\"\n    Check if the inverse of the hammer projection is supported by installed\n    version of PROJ4.\n\n    segfault_protection   True (default) - test while protecting from segfault\n                          False -  testing that might cause Python to segfault.\n                                   BE CAREFUL setting this flag to False!\n                                   If it segfaults, this the inverse hammer is not supported.\n\n    returns True      - inverse hammer is supported\n            False     - inverse hammer is not supported\n            \"Unknown\" - support is Unknown\n    \"\"\"\n    from distutils.version import LooseVersion\n    from pyproj import __version__ as pyproj_version\n\n    if LooseVersion(proj4_version()) > LooseVersion('4.9.2'):\n        return True\n\n    if LooseVersion(pyproj_version) > LooseVersion('1.9.5.1') \\\n            or segfault_protection is False:\n        from pyproj import Proj\n        hammer = Proj(proj='hammer')\n\n        x, y = hammer(-30.0, 40.0)\n        try:\n            lon, lat = hammer(x, y, inverse=True)\n            return True\n        except RuntimeError:\n            return False\n\n    return 'Unknown'",
  "def _revcmap(data):\n    \"\"\"Return a reversed copy of a segment data dictionary.\"\"\"\n\n    data_r = {}\n    for key, val in data.items():\n        val = list(val)\n        valrev = val[::-1]\n        valnew = []\n        for xval, color0, color1 in valrev:\n            valnew.append((1.0 - xval, color0, color1))\n        data_r[key] = valnew\n    return data_r",
  "def _validated_ll(param, name, minval, maxval):\n    param = float(param)\n    if param > maxval or param < minval:\n        raise ValueError('%s must be between %f and %f degrees' %\n                                           (name, minval, maxval))\n    return param",
  "def _validated_or_none(param, name, minval, maxval):\n    if param is None:\n        return None\n    return _validated_ll(param, name, minval, maxval)",
  "def _insert_validated(d, param, name, minval, maxval):\n    if param is not None:\n        d[name] = _validated_ll(param, name, minval, maxval)",
  "def _transform(plotfunc):\n    # shift data and longitudes to map projection region, then compute\n    # transformation to map projection coordinates.\n    @functools.wraps(plotfunc)\n    def with_transform(self,x,y,data,*args,**kwargs):\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                x, data = self.shiftdata(x, data,\n                                         fix_wrap_around=plotfunc.__name__ not in [\"scatter\"])\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,data,*args,**kwargs)\n    return with_transform",
  "def _transform1d(plotfunc):\n    # shift data and longitudes to map projection region, then compute\n    # transformation to map projection coordinates.\n    @functools.wraps(plotfunc)\n    def with_transform(self,x,y,*args,**kwargs):\n        x = np.asarray(x)\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                if x.ndim == 1:\n                    x = self.shiftdata(x, fix_wrap_around=plotfunc.__name__ not in [\"scatter\"])\n                elif x.ndim == 0:\n                    if x > 180:\n                        x = x - 360.\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,*args,**kwargs)\n    return with_transform",
  "def _transformuv(plotfunc):\n    # shift data and longitudes to map projection region, then compute\n    # transformation to map projection coordinates. Works when call\n    # signature has two data arrays instead of one.\n    @functools.wraps(plotfunc)\n    def with_transform(self,x,y,u,v,*args,**kwargs):\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                x1, u = self.shiftdata(x, u)\n                x, v = self.shiftdata(x, v)\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,u,v,*args,**kwargs)\n    return with_transform",
  "class Basemap(object):\n\n    def __init__(self, llcrnrlon=None, llcrnrlat=None,\n                       urcrnrlon=None, urcrnrlat=None,\n                       llcrnrx=None, llcrnry=None,\n                       urcrnrx=None, urcrnry=None,\n                       width=None, height=None,\n                       projection='cyl', resolution='c',\n                       area_thresh=None, rsphere=6370997.0,\n                       ellps=None, lat_ts=None,\n                       lat_1=None, lat_2=None,\n                       lat_0=None, lon_0=None,\n                       lon_1=None, lon_2=None,\n                       o_lon_p=None, o_lat_p=None,\n                       k_0=None,\n                       no_rot=False,\n                       suppress_ticks=True,\n                       satellite_height=35786000,\n                       boundinglat=None,\n                       fix_aspect=True,\n                       anchor='C',\n                       celestial=False,\n                       round=False,\n                       epsg=None,\n                       ax=None):\n        # docstring is added after __init__ method definition\n\n        # set epsg code if given, set to 4326 for projection='cyl':\n        if epsg is not None:\n            self.epsg = epsg\n        elif projection == 'cyl':\n            self.epsg = 4326\n        # replace kwarg values with those implied by epsg code,\n        # if given.\n        if hasattr(self,'epsg'):\n            if str(self.epsg) not in epsg_dict:\n                raise ValueError('%s is not a supported EPSG code' %\n                        self.epsg)\n            epsg_params = epsg_dict[str(self.epsg)]\n            for k in epsg_params:\n                if k == 'projection':\n                    projection = epsg_params[k]\n                elif k == 'rsphere':\n                    rsphere = epsg_params[k]\n                elif k == 'ellps':\n                    ellps = epsg_params[k]\n                elif k == 'lat_1':\n                    lat_1 = epsg_params[k]\n                elif k == 'lat_2':\n                    lat_2 = epsg_params[k]\n                elif k == 'lon_0':\n                    lon_0 = epsg_params[k]\n                elif k == 'lat_0':\n                    lat_0 = epsg_params[k]\n                elif k == 'lat_ts':\n                    lat_ts = epsg_params[k]\n                elif k == 'k_0':\n                    k_0 = epsg_params[k]\n\n        # fix aspect to ratio to match aspect ratio of map projection\n        # region\n        self.fix_aspect = fix_aspect\n        # where to put plot in figure (default is 'C' or center)\n        self.anchor = anchor\n        # geographic or celestial coords?\n        self.celestial = celestial\n        # map projection.\n        self.projection = projection\n        # bounding lat (for pole-centered plots)\n        self.boundinglat = boundinglat\n        # is a round pole-centered plot desired?\n        self.round = round\n        # full disk projection?\n        self._fulldisk = False # default value\n\n        # set up projection parameter dict.\n        projparams = {}\n        projparams['proj'] = projection\n        # if ellps keyword specified, it over-rides rsphere.\n        if ellps is not None:\n            try:\n                elldict = pyproj.pj_ellps[ellps]\n            except KeyError:\n                raise ValueError(\n                'illegal ellps definition, allowed values are %s' %\n                pyproj.pj_ellps.keys())\n            projparams['a'] = elldict['a']\n            if 'b' in elldict:\n                projparams['b'] = elldict['b']\n            else:\n                projparams['b'] = projparams['a']*(1.0-(1.0/elldict['rf']))\n        else:\n            try:\n                if rsphere[0] > rsphere[1]:\n                    projparams['a'] = rsphere[0]\n                    projparams['b'] = rsphere[1]\n                else:\n                    projparams['a'] = rsphere[1]\n                    projparams['b'] = rsphere[0]\n            except:\n                if projection == 'tmerc':\n                # use bR_a instead of R because of obscure bug\n                # in proj4 for tmerc projection.\n                    projparams['bR_a'] = rsphere\n                else:\n                    projparams['R'] = rsphere\n        # set units to meters.\n        projparams['units']='m'\n        # check for sane values of lon_0, lat_0, lat_ts, lat_1, lat_2\n        lat_0 = _validated_or_none(lat_0, 'lat_0', -90, 90)\n        lat_1 = _validated_or_none(lat_1, 'lat_1', -90, 90)\n        lat_2 = _validated_or_none(lat_2, 'lat_2', -90, 90)\n        lat_ts = _validated_or_none(lat_ts, 'lat_ts', -90, 90)\n        lon_0 = _validated_or_none(lon_0, 'lon_0', -360, 720)\n        lon_1 = _validated_or_none(lon_1, 'lon_1', -360, 720)\n        lon_2 = _validated_or_none(lon_2, 'lon_2', -360, 720)\n        llcrnrlon = _validated_or_none(llcrnrlon, 'llcrnrlon', -360, 720)\n        urcrnrlon = _validated_or_none(urcrnrlon, 'urcrnrlon', -360, 720)\n        llcrnrlat = _validated_or_none(llcrnrlat, 'llcrnrlat', -90, 90)\n        urcrnrlat = _validated_or_none(urcrnrlat, 'urcrnrlat', -90, 90)\n\n        _insert_validated(projparams, lat_0, 'lat_0', -90, 90)\n        _insert_validated(projparams, lat_1, 'lat_1', -90, 90)\n        _insert_validated(projparams, lat_2, 'lat_2', -90, 90)\n        _insert_validated(projparams, lat_ts, 'lat_ts', -90, 90)\n        _insert_validated(projparams, lon_0, 'lon_0', -360, 720)\n        _insert_validated(projparams, lon_1, 'lon_1', -360, 720)\n        _insert_validated(projparams, lon_2, 'lon_2', -360, 720)\n        if projection in ['geos','nsper']:\n            projparams['h'] = satellite_height\n        # check for sane values of projection corners.\n        using_corners = (None not in [llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat])\n        if using_corners:\n            self.llcrnrlon = _validated_ll(llcrnrlon, 'llcrnrlon', -360, 720)\n            self.urcrnrlon = _validated_ll(urcrnrlon, 'urcrnrlon', -360, 720)\n            self.llcrnrlat = _validated_ll(llcrnrlat, 'llcrnrlat', -90, 90)\n            self.urcrnrlat = _validated_ll(urcrnrlat, 'urcrnrlat', -90, 90)\n\n        # for each of the supported projections,\n        # compute lat/lon of domain corners\n        # and set values in projparams dict as needed.\n\n        if projection in ['lcc', 'eqdc', 'aea']:\n            if projection == 'lcc' and k_0 is not None:\n                projparams['k_0']=k_0\n            # if lat_0 is given, but not lat_1,\n            # set lat_1=lat_0\n            if lat_1 is None and lat_0 is not None:\n                lat_1 = lat_0\n                projparams['lat_1'] = lat_1\n            if lat_1 is None or lon_0 is None:\n                raise ValueError('must specify lat_1 or lat_0 and lon_0 for %s basemap (lat_2 is optional)' % _projnames[projection])\n            if lat_2 is None:\n                projparams['lat_2'] = lat_1\n            if not using_corners:\n                using_cornersxy = (None not in [llcrnrx,llcrnry,urcrnrx,urcrnry])\n                if using_cornersxy:\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecornersllur(llcrnrx,llcrnry,urcrnrx,urcrnry,**projparams)\n                    self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                    self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n                else:\n                    if width is None or height is None:\n                        raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                    if lon_0 is None or lat_0 is None:\n                        raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                    self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                    self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'stere':\n            if k_0 is not None:\n                projparams['k_0']=k_0\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Stereographic basemap (lat_ts is optional)')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in ['spstere', 'npstere',\n                            'splaea', 'nplaea',\n                            'spaeqd', 'npaeqd']:\n            if (projection == 'splaea' and boundinglat >= 0) or\\\n               (projection == 'nplaea' and boundinglat <= 0):\n                raise ValueError('boundinglat cannot extend into opposite hemisphere')\n            if boundinglat is None or lon_0 is None:\n                raise ValueError('must specify boundinglat and lon_0 for %s basemap' % _projnames[projection])\n            if projection[0] == 's':\n                sgn = -1\n            else:\n                sgn = 1\n            rootproj = projection[2:]\n            projparams['proj'] = rootproj\n            if rootproj == 'stere':\n                projparams['lat_ts'] = sgn * 90.\n            projparams['lat_0'] = sgn * 90.\n            self.llcrnrlon = lon_0 - sgn*45.\n            self.urcrnrlon = lon_0 + sgn*135.\n            proj = pyproj.Proj(projparams)\n            x,y = proj(lon_0,boundinglat)\n            lon,self.llcrnrlat = proj(math.sqrt(2.)*y,0.,inverse=True)\n            self.urcrnrlat = self.llcrnrlat\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[projection])\n        elif projection == 'laea':\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Lambert Azimuthal basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in ['tmerc','gnom','cass','poly'] :\n            if projection == 'tmerc' and k_0 is not None:\n                projparams['k_0']=k_0\n            if projection == 'gnom' and 'R' not in projparams:\n                raise ValueError('gnomonic projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Transverse Mercator, Gnomonic, Cassini-Soldnerr and Polyconic basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'ortho':\n            if 'R' not in projparams:\n                raise ValueError('orthographic projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Orthographic basemap')\n            if (lat_0 == 90 or lat_0 == -90) and\\\n               None in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                # for ortho plot centered on pole, set boundinglat to equator.\n                # (so meridian labels can be drawn in this special case).\n                self.boundinglat = 0\n                self.round = True\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n            # FIXME: won't work for points exactly on equator??\n            if np.abs(lat_0) < 1.e-2: lat_0 = 1.e-2\n            projparams['lat_0'] = lat_0\n        elif projection == 'geos':\n            if lat_0 is not None and lat_0 != 0:\n                raise ValueError('lat_0 must be zero for Geostationary basemap')\n            if lon_0 is None:\n                raise ValueError('must specify lon_0 for Geostationary basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'nsper':\n            if 'R' not in projparams:\n                raise ValueError('near-sided perspective projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lon_0 and lat_0 for near-sided perspective Basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in _pseudocyl:\n            if lon_0 is None:\n                raise ValueError('must specify lon_0 for %s projection' % _projnames[self.projection])\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            llcrnrlon = lon_0-180.\n            llcrnrlat = -90.\n            urcrnrlon = lon_0+180\n            urcrnrlat = 90.\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'omerc':\n            if k_0 is not None:\n                projparams['k_0']=k_0\n            if lat_1 is None or lon_1 is None or lat_2 is None or lon_2 is None:\n                raise ValueError('must specify lat_1,lon_1 and lat_2,lon_2 for Oblique Mercator basemap')\n            projparams['lat_1'] = lat_1\n            projparams['lon_1'] = lon_1\n            projparams['lat_2'] = lat_2\n            projparams['lon_2'] = lon_2\n            projparams['lat_0'] = lat_0\n            if no_rot:\n                projparams['no_rot']=''\n            #if not using_corners:\n            #    raise ValueError, 'cannot specify map region with width and height keywords for this projection, please specify lat/lon values of corners'\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'aeqd':\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Azimuthal Equidistant basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    self._fulldisk = True\n                    llcrnrlon = -180.\n                    llcrnrlat = -90.\n                    urcrnrlon = 180\n                    urcrnrlat = 90.\n                else:\n                    self._fulldisk = False\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                if not self._fulldisk:\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in _cylproj:\n            if projection == 'merc' or projection == 'cea':\n                if lat_ts is None:\n                    lat_ts = 0.\n                    projparams['lat_ts'] = lat_ts\n            if not using_corners:\n                llcrnrlat = -90.\n                urcrnrlat = 90.\n                if lon_0 is not None:\n                    llcrnrlon = lon_0-180.\n                    urcrnrlon = lon_0+180.\n                else:\n                    llcrnrlon = -180.\n                    urcrnrlon = 180\n                if projection == 'merc':\n                    # clip plot region to be within -89.99S to 89.99N\n                    # (mercator is singular at poles)\n                    if llcrnrlat < -89.99: llcrnrlat = -89.99\n                    if llcrnrlat > 89.99: llcrnrlat = 89.99\n                    if urcrnrlat < -89.99: urcrnrlat = -89.99\n                    if urcrnrlat > 89.99: urcrnrlat = 89.99\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if lon_0 is not None:\n                projparams['lon_0'] = lon_0\n            else:\n                projparams['lon_0']=0.5*(llcrnrlon+urcrnrlon)\n        elif projection == 'rotpole':\n            if lon_0 is None or o_lon_p is None or o_lat_p is None:\n                raise ValueError('must specify lon_0,o_lat_p,o_lon_p for rotated pole Basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            projparams['lon_0']=lon_0\n            projparams['o_lon_p']=o_lon_p\n            projparams['o_lat_p']=o_lat_p\n            projparams['o_proj']='longlat'\n            projparams['proj']='ob_tran'\n            if not using_corners and None in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                raise ValueError('must specify lat/lon values of corners in degrees')\n            if None not in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                p = pyproj.Proj(projparams)\n                llcrnrx = _dg2rad*llcrnrx; llcrnry = _dg2rad*llcrnry\n                urcrnrx = _dg2rad*urcrnrx; urcrnry = _dg2rad*urcrnry\n                llcrnrlon, llcrnrlat = p(llcrnrx,llcrnry,inverse=True)\n                urcrnrlon, urcrnrlat = p(urcrnrx,urcrnry,inverse=True)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        else:\n            raise ValueError(_unsupported_projection % projection)\n\n        # initialize proj4\n        proj = Proj(projparams,self.llcrnrlon,self.llcrnrlat,self.urcrnrlon,self.urcrnrlat)\n\n        # make sure axis ticks are suppressed.\n        self.noticks = suppress_ticks\n        # map boundary not yet drawn.\n        self._mapboundarydrawn = False\n\n        # make Proj instance a Basemap instance variable.\n        self.projtran = proj\n        # copy some Proj attributes.\n        atts = ['rmajor','rminor','esq','flattening','ellipsoid','projparams']\n        for att in atts:\n            self.__dict__[att] = proj.__dict__[att]\n        # these only exist for geostationary projection.\n        if hasattr(proj,'_width'):\n            self.__dict__['_width'] = proj.__dict__['_width']\n        if hasattr(proj,'_height'):\n            self.__dict__['_height'] = proj.__dict__['_height']\n        # spatial reference string (useful for georeferencing output\n        # images with gdal_translate).\n        if hasattr(self,'_proj4'):\n            #self.srs = proj._proj4.srs\n            self.srs = proj._proj4.pjinitstring\n        else:\n            pjargs = []\n            for key,value in self.projparams.items():\n                # 'cyl' projection translates to 'eqc' in PROJ.4\n                if projection == 'cyl' and key == 'proj':\n                    value = 'eqc'\n                # ignore x_0 and y_0 settings for 'cyl' projection\n                # (they are not consistent with what PROJ.4 uses)\n                elif projection == 'cyl' and key in ['x_0','y_0']:\n                    continue\n                pjargs.append('+'+key+\"=\"+str(value)+' ')\n            self.srs = ''.join(pjargs)\n        self.proj4string = self.srs\n        # set instance variables defining map region.\n        self.xmin = proj.xmin\n        self.xmax = proj.xmax\n        self.ymin = proj.ymin\n        self.ymax = proj.ymax\n        if projection == 'cyl':\n            self.aspect = (self.urcrnrlat-self.llcrnrlat)/(self.urcrnrlon-self.llcrnrlon)\n        else:\n            self.aspect = (proj.ymax-proj.ymin)/(proj.xmax-proj.xmin)\n        if projection in ['geos','ortho','nsper'] and \\\n           None not in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n            self.llcrnrx = llcrnrx+0.5*proj.xmax\n            self.llcrnry = llcrnry+0.5*proj.ymax\n            self.urcrnrx = urcrnrx+0.5*proj.xmax\n            self.urcrnry = urcrnry+0.5*proj.ymax\n            self._fulldisk = False\n        else:\n            self.llcrnrx = proj.llcrnrx\n            self.llcrnry = proj.llcrnry\n            self.urcrnrx = proj.urcrnrx\n            self.urcrnry = proj.urcrnry\n\n        if self.projection == 'rotpole':\n            lon0,lat0 = self(0.5*(self.llcrnrx + self.urcrnrx),\\\n                             0.5*(self.llcrnry + self.urcrnry),\\\n                             inverse=True)\n            self.projparams['lat_0']=lat0\n\n        # if ax == None, pyplot.gca may be used.\n        self.ax = ax\n        self.lsmask = None\n        # This will record hashs of Axes instances.\n        self._initialized_axes = set()\n\n        # set defaults for area_thresh.\n        self.resolution = resolution\n        # celestial=True implies resolution=None (no coastlines).\n        if self.celestial:\n            self.resolution=None\n        if area_thresh is None and self.resolution is not None:\n            if resolution == 'c':\n                area_thresh = 10000.\n            elif resolution == 'l':\n                area_thresh = 1000.\n            elif resolution == 'i':\n                area_thresh = 100.\n            elif resolution == 'h':\n                area_thresh = 10.\n            elif resolution == 'f':\n                area_thresh = 1.\n            else:\n                raise ValueError(\"boundary resolution must be one of 'c','l','i','h' or 'f'\")\n        self.area_thresh = area_thresh\n        # define map boundary polygon (in lat/lon coordinates)\n        blons, blats, self._boundarypolyll, self._boundarypolyxy = self._getmapboundary()\n        self.boundarylats = blats\n        self.boundarylons = blons\n        # set min/max lats for projection domain.\n        if self.projection in _cylproj:\n            self.latmin = self.llcrnrlat\n            self.latmax = self.urcrnrlat\n            self.lonmin = self.llcrnrlon\n            self.lonmax = self.urcrnrlon\n        elif self.projection in ['ortho','geos','nsper'] + _pseudocyl:\n            self.latmin = -90.\n            self.latmax = 90.\n            self.lonmin = self.llcrnrlon\n            self.lonmax = self.urcrnrlon\n        else:\n            lons, lats = self.makegrid(1001,1001)\n            lats = ma.masked_where(lats > 1.e20,lats)\n            lons = ma.masked_where(lons > 1.e20,lons)\n            self.latmin = lats.min()\n            self.latmax = lats.max()\n            self.lonmin = lons.min()\n            self.lonmax = lons.max()\n            NPole = _geoslib.Point(self(0.,90.))\n            SPole = _geoslib.Point(self(0.,-90.))\n            if lat_0 is None:\n                lon_0, lat_0 =\\\n                self(0.5*(self.xmin+self.xmax),\n                     0.5*(self.ymin+self.ymax),inverse=True)\n            Dateline = _geoslib.Point(self(180.,lat_0))\n            Greenwich = _geoslib.Point(self(0.,lat_0))\n            hasNP = NPole.within(self._boundarypolyxy)\n            hasSP = SPole.within(self._boundarypolyxy)\n            hasPole = hasNP or hasSP\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            hasGreenwich = Greenwich.within(self._boundarypolyxy)\n            # projection crosses dateline (and not Greenwich or pole).\n            if not hasPole and hasDateline and not hasGreenwich:\n                if self.lonmin < 0 and self.lonmax > 0.:\n                    lons = np.where(lons < 0, lons+360, lons)\n                    self.lonmin = lons.min()\n                    self.lonmax = lons.max()\n        # read in coastline polygons, only keeping those that\n        # intersect map boundary polygon.\n        if self.resolution is not None:\n            self.coastsegs, self.coastpolygontypes =\\\n            self._readboundarydata('gshhs',as_polygons=True)\n            # reformat for use in matplotlib.patches.Polygon.\n            self.coastpolygons = []\n            for seg in self.coastsegs:\n                x, y = list(zip(*seg))\n                self.coastpolygons.append((x,y))\n            # replace coastsegs with line segments (instead of polygons)\n            self.coastsegs, types =\\\n            self._readboundarydata('gshhs',as_polygons=False)\n            self.coastsegs = [sg for sg in self.coastsegs if len(sg) > 0]\n        # create geos Polygon structures for land areas.\n        # currently only used in is_land method.\n        self.landpolygons=[]\n        self.lakepolygons=[]\n        if self.resolution is not None and len(self.coastpolygons) > 0:\n            #self.islandinlakepolygons=[]\n            #self.lakeinislandinlakepolygons=[]\n            x, y = list(zip(*self.coastpolygons))\n            for x,y,typ in zip(x,y,self.coastpolygontypes):\n                b = np.asarray([x,y]).T\n                if typ == 1: self.landpolygons.append(_geoslib.Polygon(b))\n                if typ == 2: self.lakepolygons.append(_geoslib.Polygon(b))\n                #if typ == 3: self.islandinlakepolygons.append(_geoslib.Polygon(b))\n                #if typ == 4: self.lakeinislandinlakepolygons.append(_geoslib.Polygon(b))\n\n    # set __init__'s docstring\n    __init__.__doc__ = _Basemap_init_doc\n\n    def __call__(self,x,y,inverse=False):\n        \"\"\"\n        Calling a Basemap class instance with the arguments lon, lat will\n        convert lon/lat (in degrees) to x/y map projection\n        coordinates (in meters).  If optional keyword ``inverse`` is\n        True (default is False), the inverse transformation from x/y\n        to lon/lat is performed.\n\n        For cylindrical equidistant projection (``cyl``), this\n        does nothing (i.e. x,y == lon,lat).\n\n        For non-cylindrical projections, the inverse transformation\n        always returns longitudes between -180 and 180 degrees. For\n        cylindrical projections (self.projection == ``cyl``,\n        ``cea``, ``mill``, ``gall`` or ``merc``)\n        the inverse transformation will return longitudes between\n        self.llcrnrlon and self.llcrnrlat.\n\n        Input arguments lon, lat can be either scalar floats,\n        sequences, or numpy arrays.\n        \"\"\"\n        if self.celestial:\n            # don't assume center of map is at greenwich\n            # (only relevant for cyl or pseudo-cyl projections)\n            if self.projection in _pseudocyl or self.projection in _cylproj:\n                lon_0=self.projparams['lon_0']\n            else:\n                lon_0 = 0.\n        if self.celestial and not inverse:\n            try:\n                x = 2.*lon_0-x\n            except TypeError:\n                x = [2*lon_0-xx for xx in x]\n        if self.projection == 'rotpole' and inverse:\n            try:\n                x = _dg2rad*x\n            except TypeError:\n                x = [_dg2rad*xx for xx in x]\n            try:\n                y = _dg2rad*y\n            except TypeError:\n                y = [_dg2rad*yy for yy in y]\n        xout,yout = self.projtran(x,y,inverse=inverse)\n        if self.celestial and inverse:\n            try:\n                xout = -2.*lon_0-xout\n            except:\n                xout = [-2.*lon_0-xx for xx in xout]\n        if self.projection == 'rotpole' and not inverse:\n            try:\n                xout = _rad2dg*xout\n                xout = np.where(xout < 0., xout+360, xout)\n            except TypeError:\n                xout = [_rad2dg*xx for xx in xout]\n                xout = [xx+360. if xx < 0 else xx for xx in xout]\n            try:\n                yout = _rad2dg*yout\n            except TypeError:\n                yout = [_rad2dg*yy for yy in yout]\n        return xout,yout\n\n    def makegrid(self,nx,ny,returnxy=False):\n        \"\"\"\n        return arrays of shape (ny,nx) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n\n        If ``returnxy = True``, the x,y values of the grid are returned also.\n        \"\"\"\n        return self.projtran.makegrid(nx,ny,returnxy=returnxy)\n\n    def _readboundarydata(self,name,as_polygons=False):\n        \"\"\"\n        read boundary data, clip to map projection region.\n        \"\"\"\n\n        # only gshhs coastlines can be polygons.\n        if name != 'gshhs': as_polygons=False\n        try:\n            bdatfile = open(os.path.join(basemap_datadir,name+'_'+self.resolution+'.dat'),'rb')\n            bdatmetafile = open(os.path.join(basemap_datadir,name+'meta_'+self.resolution+'.dat'),'r')\n        except:\n            raise IOError(\n                \"Unable to open boundary dataset file. Only the 'crude', 'low' \"\n                \"and 'intermediate' resolution datasets are installed by default. \"\n                \"If you are requesting a 'high' or 'full' resolution dataset, \"\n                \"you need to install the `basemap-data-hires` package\")\n        polygons = []\n        polygon_types = []\n        # coastlines are polygons, other boundaries are line segments.\n        if name == 'gshhs':\n            Shape = _geoslib.Polygon\n        else:\n            Shape = _geoslib.LineString\n        # see if map projection region polygon contains a pole.\n        NPole = _geoslib.Point(self(0.,90.))\n        SPole = _geoslib.Point(self(0.,-90.))\n        boundarypolyxy = self._boundarypolyxy\n        boundarypolyll = self._boundarypolyll\n        hasNP = NPole.within(boundarypolyxy)\n        hasSP = SPole.within(boundarypolyxy)\n        containsPole = hasNP or hasSP\n        # these projections cannot cross pole.\n        if containsPole and\\\n            self.projection in _cylproj + _pseudocyl + ['geos']:\n            raise ValueError('%s projection cannot cross pole'%(self.projection))\n        # make sure some projections have has containsPole=True\n        # we will compute the intersections in stereographic\n        # coordinates, then transform back. This is\n        # because these projections are only defined on a hemisphere, and\n        # some boundary features (like Eurasia) would be undefined otherwise.\n        tostere =\\\n        ['omerc','ortho','gnom','nsper','nplaea','npaeqd','splaea','spaeqd']\n        if self.projection in tostere and name == 'gshhs':\n            containsPole = True\n            lon_0=self.projparams['lon_0']\n            lat_0=self.projparams['lat_0']\n            re = self.projparams['R']\n            # center of stereographic projection restricted to be\n            # nearest one of 6 points on the sphere (every 90 deg lat/lon).\n            lon0 = 90.*(np.around(lon_0/90.))\n            lat0 = 90.*(np.around(lat_0/90.))\n            if np.abs(int(lat0)) == 90: lon0=0.\n            maptran = pyproj.Proj(proj='stere',lon_0=lon0,lat_0=lat0,R=re)\n            # boundary polygon for ortho/gnom/nsper projection\n            # in stereographic coordinates.\n            b = self._boundarypolyll.boundary\n            blons = b[:,0]; blats = b[:,1]\n            b[:,0], b[:,1] = maptran(blons, blats)\n            boundarypolyxy = _geoslib.Polygon(b)\n        for line in bdatmetafile:\n            linesplit = line.split()\n            area = float(linesplit[1])\n            south = float(linesplit[3])\n            north = float(linesplit[4])\n            crossdatelineE=False; crossdatelineW=False\n            if name == 'gshhs':\n                id = linesplit[7]\n                if id.endswith('E'):\n                    crossdatelineE = True\n                elif id.endswith('W'):\n                    crossdatelineW = True\n            # make sure south/north limits of dateline crossing polygons\n            # (Eurasia) are the same, since they will be merged into one.\n            # (this avoids having one filtered out and not the other).\n            if crossdatelineE:\n                south_save=south\n                north_save=north\n            if crossdatelineW:\n                south=south_save\n                north=north_save\n            if area < 0.: area = 1.e30\n            useit = self.latmax>=south and self.latmin<=north and area>self.area_thresh\n            if useit:\n                typ = int(linesplit[0])\n                npts = int(linesplit[2])\n                offsetbytes = int(linesplit[5])\n                bytecount = int(linesplit[6])\n                bdatfile.seek(offsetbytes,0)\n                # read in binary string convert into an npts by 2\n                # numpy array (first column is lons, second is lats).\n                polystring = bdatfile.read(bytecount)\n                # binary data is little endian.\n                b = np.array(np.frombuffer(polystring,dtype='<f4'),'f8')\n                b.shape = (npts,2)\n                b2 = b.copy()\n                # merge polygons that cross dateline.\n                poly = Shape(b)\n                # hack to try to avoid having Antartica filled polygon\n                # covering entire map (if skipAnart = False, this happens\n                # for ortho lon_0=-120, lat_0=60, for example).\n                skipAntart = self.projection in tostere and south < -89 and \\\n                 not hasSP\n                if crossdatelineE and not skipAntart:\n                    if not poly.is_valid(): poly=poly.fix()\n                    polyE = poly\n                    continue\n                elif crossdatelineW and not skipAntart:\n                    if not poly.is_valid(): poly=poly.fix()\n                    b = poly.boundary\n                    b[:,0] = b[:,0]+360.\n                    poly = Shape(b)\n                    poly = poly.union(polyE)\n                    if not poly.is_valid(): poly=poly.fix()\n                    b = poly.boundary\n                    b2 = b.copy()\n                    # fix Antartica.\n                    if name == 'gshhs' and south < -89:\n                        b = b[3:,:]\n                        b2 = b.copy()\n                        poly = Shape(b)\n                # if map boundary polygon is a valid one in lat/lon\n                # coordinates (i.e. it does not contain either pole),\n                # the intersections of the boundary geometries\n                # and the map projection region can be computed before\n                # transforming the boundary geometry to map projection\n                # coordinates (this saves time, especially for small map\n                # regions and high-resolution boundary geometries).\n                if not containsPole:\n                    # close Antarctica.\n                    if name == 'gshhs' and south < -89:\n                        lons2 = b[:,0]\n                        lats = b[:,1]\n                        lons1 = lons2 - 360.\n                        lons3 = lons2 + 360.\n                        lons = lons1.tolist()+lons2.tolist()+lons3.tolist()\n                        lats = lats.tolist()+lats.tolist()+lats.tolist()\n                        lonstart,latstart = lons[0], lats[0]\n                        lonend,latend = lons[-1], lats[-1]\n                        lons.insert(0,lonstart)\n                        lats.insert(0,-90.)\n                        lons.append(lonend)\n                        lats.append(-90.)\n                        b = np.empty((len(lons),2),np.float64)\n                        b[:,0] = lons; b[:,1] = lats\n                        poly = Shape(b)\n                        if not poly.is_valid(): poly=poly.fix()\n                        # if polygon instersects map projection\n                        # region, process it.\n                        if poly.intersects(boundarypolyll):\n                            if name != 'gshhs' or as_polygons:\n                                geoms = poly.intersection(boundarypolyll)\n                            else:\n                                # convert polygons to line segments\n                                poly = _geoslib.LineString(poly.boundary)\n                                geoms = poly.intersection(boundarypolyll)\n                            # iterate over geometries in intersection.\n                            for psub in geoms:\n                                b = psub.boundary\n                                blons = b[:,0]; blats = b[:,1]\n                                bx, by = self(blons, blats)\n                                polygons.append(list(zip(bx,by)))\n                                polygon_types.append(typ)\n                    else:\n                        # create duplicate polygons shifted by -360 and +360\n                        # (so as to properly treat polygons that cross\n                        # Greenwich meridian).\n                        b2[:,0] = b[:,0]-360\n                        poly1 = Shape(b2)\n                        b2[:,0] = b[:,0]+360\n                        poly2 = Shape(b2)\n                        polys = [poly1,poly,poly2]\n                        for poly in polys:\n                            # try to fix \"non-noded intersection\" errors.\n                            if not poly.is_valid(): poly=poly.fix()\n                            # if polygon instersects map projection\n                            # region, process it.\n                            if poly.intersects(boundarypolyll):\n                                if name != 'gshhs' or as_polygons:\n                                    geoms = poly.intersection(boundarypolyll)\n                                else:\n                                    # convert polygons to line segments\n                                    # note: use fix method here or Eurasia\n                                    # line segments sometimes disappear.\n                                    poly = _geoslib.LineString(poly.fix().boundary)\n                                    geoms = poly.intersection(boundarypolyll)\n                                # iterate over geometries in intersection.\n                                for psub in geoms:\n                                    b = psub.boundary\n                                    blons = b[:,0]; blats = b[:,1]\n                                    # transformation from lat/lon to\n                                    # map projection coordinates.\n                                    bx, by = self(blons, blats)\n                                    if not as_polygons or len(bx) > 4:\n                                        polygons.append(list(zip(bx,by)))\n                                        polygon_types.append(typ)\n                # if map boundary polygon is not valid in lat/lon\n                # coordinates, compute intersection between map\n                # projection region and boundary geometries in map\n                # projection coordinates.\n                else:\n                    # transform coordinates from lat/lon\n                    # to map projection coordinates.\n                    # special case for ortho/gnom/nsper, compute coastline polygon\n                    # vertices in stereographic coords.\n                    if name == 'gshhs' and as_polygons and self.projection in tostere:\n                        b[:,0], b[:,1] = maptran(b[:,0], b[:,1])\n                    else:\n                        b[:,0], b[:,1] = self(b[:,0], b[:,1])\n                    goodmask = np.logical_and(b[:,0]<1.e20,b[:,1]<1.e20)\n                    # if less than two points are valid in\n                    # map proj coords, skip this geometry.\n                    if np.sum(goodmask) <= 1: continue\n                    if name != 'gshhs' or (name == 'gshhs' and not as_polygons):\n                        # if not a polygon,\n                        # just remove parts of geometry that are undefined\n                        # in this map projection.\n                        bx = np.compress(goodmask, b[:,0])\n                        by = np.compress(goodmask, b[:,1])\n                        # split coastline segments that jump across entire plot.\n                        xd = (bx[1:]-bx[0:-1])**2\n                        yd = (by[1:]-by[0:-1])**2\n                        dist = np.sqrt(xd+yd)\n                        split = dist > 0.1*(self.xmax-self.xmin)\n                        if np.sum(split) and self.projection not in _cylproj:\n                            ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                            iprev = 0\n                            ind.append(len(xd))\n                            for i in ind:\n                                # don't add empty lists.\n                                if len(list(range(iprev,i))):\n                                    polygons.append(list(zip(bx[iprev:i],by[iprev:i])))\n                                iprev = i\n                        else:\n                            polygons.append(list(zip(bx,by)))\n                        polygon_types.append(typ)\n                        continue\n                    # create a GEOS geometry object.\n                    if name == 'gshhs' and not as_polygons:\n                        # convert polygons to line segments\n                        poly = _geoslib.LineString(poly.boundary)\n                    else:\n                        # this is a workaround to avoid\n                        # GEOS_ERROR: CGAlgorithmsDD::orientationIndex encountered NaN/Inf numbers\n                        b[np.isposinf(b)] = 1e20\n                        b[np.isneginf(b)] = -1e20\n                        poly = Shape(b)\n                    # this is a workaround to avoid\n                    # \"GEOS_ERROR: TopologyException:\n                    # found non-noded intersection between ...\"\n                    if not poly.is_valid(): poly=poly.fix()\n                    # if geometry instersects map projection\n                    # region, and doesn't have any invalid points, process it.\n                    if goodmask.all() and poly.intersects(boundarypolyxy):\n                        # if geometry intersection calculation fails,\n                        # just move on.\n                        try:\n                            geoms = poly.intersection(boundarypolyxy)\n                        except:\n                            continue\n                        # iterate over geometries in intersection.\n                        for psub in geoms:\n                            b = psub.boundary\n                            # if projection in ['ortho','gnom','nsper'],\n                            # transform polygon from stereographic\n                            # to ortho/gnom/nsper coordinates.\n                            if self.projection in tostere:\n                                # if coastline polygon covers more than 99%\n                                # of map region for fulldisk projection,\n                                # it's probably bogus, so skip it.\n                                #areafrac = psub.area()/boundarypolyxy.area()\n                                #if self.projection == ['ortho','nsper']:\n                                #    if name == 'gshhs' and\\\n                                #       self._fulldisk and\\\n                                #       areafrac > 0.99: continue\n                                # inverse transform from stereographic\n                                # to lat/lon.\n                                b[:,0], b[:,1] = maptran(b[:,0], b[:,1], inverse=True)\n                                # orthographic/gnomonic/nsper.\n                                b[:,0], b[:,1]= self(b[:,0], b[:,1])\n                            if not as_polygons or len(b) > 4:\n                                polygons.append(list(zip(b[:,0],b[:,1])))\n                                polygon_types.append(typ)\n        bdatfile.close()\n        bdatmetafile.close()\n        return polygons, polygon_types\n\n    def _getmapboundary(self):\n        \"\"\"\n        create map boundary polygon (in lat/lon and x/y coordinates)\n        \"\"\"\n        nx = 100; ny = 100\n        maptran = self\n        if self.projection in ['ortho','geos','nsper']:\n            # circular region.\n            thetas = np.linspace(0.,2.*np.pi,2*nx*ny)[:-1]\n            rminor = self._height\n            rmajor = self._width\n            x = rmajor*np.cos(thetas) + rmajor\n            y = rminor*np.sin(thetas) + rminor\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n            # compute proj instance for full disk, if necessary.\n            if not self._fulldisk:\n                projparms = self.projparams.copy()\n                del projparms['x_0']\n                del projparms['y_0']\n                if self.projection == 'ortho':\n                    llcrnrx = -self.rmajor\n                    llcrnry = -self.rmajor\n                    urcrnrx = -llcrnrx\n                    urcrnry = -llcrnry\n                else:\n                    llcrnrx = -self._width\n                    llcrnry = -self._height\n                    urcrnrx = -llcrnrx\n                    urcrnry = -llcrnry\n                projparms['x_0']=-llcrnrx\n                projparms['y_0']=-llcrnry\n                maptran = pyproj.Proj(projparms)\n        elif self.projection == 'aeqd' and self._fulldisk:\n            # circular region.\n            thetas = np.linspace(0.,2.*np.pi,2*nx*ny)[:-1]\n            rminor = self._height\n            rmajor = self._width\n            x = rmajor*np.cos(thetas) + rmajor\n            y = rminor*np.sin(thetas) + rminor\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        elif self.projection in _pseudocyl:\n            nx = 10*nx; ny = 10*ny\n            # quasi-elliptical region.\n            lon_0 = self.projparams['lon_0']\n            # left side\n            lats1 = np.linspace(-89.9999,89.9999,ny).tolist()\n            lons1 = len(lats1)*[lon_0-179.9]\n            # top.\n            lons2 = np.linspace(lon_0-179.9,lon_0+179.9,nx).tolist()\n            lats2 = len(lons2)*[89.9999]\n            # right side\n            lats3 = np.linspace(89.9999,-89.9999,ny).tolist()\n            lons3 = len(lats3)*[lon_0+179.9]\n            # bottom.\n            lons4 = np.linspace(lon_0+179.9,lon_0-179.9,nx).tolist()\n            lats4 = len(lons4)*[-89.9999]\n            lons = np.array(lons1+lons2+lons3+lons4,np.float64)\n            lats = np.array(lats1+lats2+lats3+lats4,np.float64)\n            x, y = maptran(lons,lats)\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        else: # all other projections are rectangular.\n            nx = 100*nx; ny = 100*ny\n            # left side (x = xmin, ymin <= y <= ymax)\n            yy = np.linspace(self.ymin, self.ymax, ny)[:-1]\n            x = len(yy)*[self.xmin]; y = yy.tolist()\n            # top (y = ymax, xmin <= x <= xmax)\n            xx = np.linspace(self.xmin, self.xmax, nx)[:-1]\n            x = x + xx.tolist()\n            y = y + len(xx)*[self.ymax]\n            # right side (x = xmax, ymin <= y <= ymax)\n            yy = np.linspace(self.ymax, self.ymin, ny)[:-1]\n            x = x + len(yy)*[self.xmax]; y = y + yy.tolist()\n            # bottom (y = ymin, xmin <= x <= xmax)\n            xx = np.linspace(self.xmax, self.xmin, nx)[:-1]\n            x = x + xx.tolist()\n            y = y + len(xx)*[self.ymin]\n            x = np.array(x,np.float64)\n            y = np.array(y,np.float64)\n            b = np.empty((4,2),np.float64)\n            b[:,0]=[self.xmin,self.xmin,self.xmax,self.xmax]\n            b[:,1]=[self.ymin,self.ymax,self.ymax,self.ymin]\n            boundaryxy = _geoslib.Polygon(b)\n        if self.projection in _cylproj:\n            # make sure map boundary doesn't quite include pole.\n            if self.urcrnrlat > 89.9999:\n                urcrnrlat = 89.9999\n            else:\n                urcrnrlat = self.urcrnrlat\n            if self.llcrnrlat < -89.9999:\n                llcrnrlat = -89.9999\n            else:\n                llcrnrlat = self.llcrnrlat\n            lons = [self.llcrnrlon, self.llcrnrlon, self.urcrnrlon, self.urcrnrlon]\n            lats = [llcrnrlat, urcrnrlat, urcrnrlat, llcrnrlat]\n            self.boundarylonmin = min(lons)\n            self.boundarylonmax = max(lons)\n            x, y = self(lons, lats)\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        else:\n            if self.projection not in _pseudocyl:\n                lons, lats = maptran(x,y,inverse=True)\n                # fix lons so there are no jumps.\n                n = 1\n                lonprev = lons[0]\n                for lon,lat in zip(lons[1:],lats[1:]):\n                    if np.abs(lon-lonprev) > 90.:\n                        if lonprev < 0:\n                            lon = lon - 360.\n                        else:\n                            lon = lon + 360\n                        lons[n] = lon\n                    lonprev = lon\n                    n = n + 1\n                self.boundarylonmin = lons.min()\n                self.boundarylonmax = lons.max()\n                # for circular full disk projections where boundary is\n                # a latitude circle, set boundarylonmax and boundarylonmin\n                # to cover entire world (so parallels will be drawn).\n                if self._fulldisk and \\\n                   np.abs(self.boundarylonmax-self.boundarylonmin) < 1.:\n                   self.boundarylonmin = -180.\n                   self.boundarylonmax = 180.\n        b = np.empty((len(lons),2),np.float64)\n        b[:,0] = lons; b[:,1] = lats\n        boundaryll = _geoslib.Polygon(b)\n        return lons, lats, boundaryll, boundaryxy\n\n    def drawmapboundary(self,color='k',linewidth=1.0,fill_color=None,\\\n                        zorder=None,ax=None):\n        \"\"\"\n        draw boundary around map projection region, optionally\n        filling interior of region.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        line width for boundary (default 1.)\n        color            color of boundary line (default black)\n        fill_color       fill the map region background with this\n                         color (default is to fill with axis\n                         background color). If set to the string\n                         'none', no filling is done.\n        zorder           sets the zorder for filling map background\n                         (default 0).\n        ax               axes instance to use\n                         (default None, use default axes instance).\n        ==============   ====================================================\n\n        returns matplotlib.collections.PatchCollection representing map boundary.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # if no fill_color given, use axes background color.\n        # if fill_color is string 'none', really don't fill.\n        if fill_color is None:\n            mpl_version = tuple(map(int, mpl.__version__.split(\".\")[:2]))\n            if mpl_version >= (2, 0):\n                fill_color = ax.get_facecolor()\n            else:\n                fill_color = ax.get_axis_bgcolor()\n        elif fill_color == 'none' or fill_color == 'None':\n            fill_color = None\n        limb = None\n        if self.projection in ['ortho','geos','nsper'] or (self.projection=='aeqd' and\\\n           self._fulldisk):\n            limb = Ellipse((self._width,self._height),2.*self._width,2.*self._height)\n        if self.projection in ['ortho','geos','nsper','aeqd'] and self._fulldisk:\n            # elliptical region.\n            ax.set_frame_on(False)\n        elif self.projection in _pseudocyl:  # elliptical region.\n            ax.set_frame_on(False)\n            nx = 100; ny = 100\n            if self.projection == 'vandg':\n                nx = 10*nx; ny = 10*ny\n            # quasi-elliptical region.\n            lon_0 = self.projparams['lon_0']\n            # left side\n            lats1 = np.linspace(-89.9999,89.99999,ny).tolist()\n            lons1 = len(lats1)*[lon_0-179.9]\n            # top.\n            lons2 = np.linspace(lon_0-179.9999,lon_0+179.9999,nx).tolist()\n            lats2 = len(lons2)*[89.9999]\n            # right side\n            lats3 = np.linspace(89.9999,-89.9999,ny).tolist()\n            lons3 = len(lats3)*[lon_0+179.9999]\n            # bottom.\n            lons4 = np.linspace(lon_0+179.9999,lon_0-179.9999,nx).tolist()\n            lats4 = len(lons4)*[-89.9999]\n            lons = np.array(lons1+lons2+lons3+lons4,np.float64)\n            lats = np.array(lats1+lats2+lats3+lats4,np.float64)\n            x, y = self(lons,lats)\n            xy = list(zip(x,y))\n            limb = Polygon(xy)\n        elif self.round:\n            ax.set_frame_on(False)\n            limb = Circle((0.5*(self.xmax+self.xmin),0.5*(self.ymax+self.ymin)),\n                    radius=0.5*(self.xmax-self.xmin),fc='none')\n        else: # all other projections are rectangular.\n            ax.set_frame_on(True)\n            for spine in ax.spines.values():\n                spine.set_linewidth(linewidth)\n                spine.set_edgecolor(color)\n                if zorder is not None:\n                    spine.set_zorder(zorder)\n            if self.projection not in ['geos','ortho','nsper']:\n                limb = ax.patch\n\n        if limb is not None:\n            if limb is not ax.patch:\n                ax.add_patch(limb)\n            self._mapboundarydrawn = limb\n            if fill_color is None:\n                limb.set_fill(False)\n            else:\n                limb.set_facecolor(fill_color)\n                limb.set_zorder(0)\n            limb.set_edgecolor(color)\n            limb.set_linewidth(linewidth)\n            if zorder is not None:\n                limb.set_zorder(zorder)\n            limb.set_clip_on(True)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        return limb\n\n    def fillcontinents(self,color='0.8',lake_color=None,ax=None,zorder=None,alpha=None):\n        \"\"\"\n        Fill continents.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to fill continents (default gray).\n        lake_color       color to fill inland lakes (default axes background).\n        ax               axes instance (overrides default axes instance).\n        zorder           sets the zorder for the continent polygons (if not\n                         specified, uses default zorder for a Polygon patch).\n                         Set to zero if you want to paint over the filled\n                         continents).\n        alpha            sets alpha transparency for continent polygons\n        ==============   ====================================================\n\n        After filling continents, lakes are re-filled with\n        axis background color.\n\n        returns a list of matplotlib.patches.Polygon objects.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # get axis background color.\n        mpl_version = tuple(map(int, mpl.__version__.split(\".\")[:2]))\n        if mpl_version >= (2, 0):\n            axisbgc = ax.get_facecolor()\n        else:\n            axisbgc = ax.get_axis_bgcolor()\n        npoly = 0\n        polys = []\n        for x,y in self.coastpolygons:\n            xa = np.array(x,np.float32)\n            ya = np.array(y,np.float32)\n        # check to see if all four corners of domain in polygon (if so,\n        # don't draw since it will just fill in the whole map).\n        # ** turn this off for now since it prevents continents that\n        # fill the whole map from being filled **\n            #delx = 10; dely = 10\n            #if self.projection in ['cyl']:\n            #    delx = 0.1\n            #    dely = 0.1\n            #test1 = np.fabs(xa-self.urcrnrx) < delx\n            #test2 = np.fabs(xa-self.llcrnrx) < delx\n            #test3 = np.fabs(ya-self.urcrnry) < dely\n            #test4 = np.fabs(ya-self.llcrnry) < dely\n            #hasp1 = np.sum(test1*test3)\n            #hasp2 = np.sum(test2*test3)\n            #hasp4 = np.sum(test2*test4)\n            #hasp3 = np.sum(test1*test4)\n            #if not hasp1 or not hasp2 or not hasp3 or not hasp4:\n            if 1:\n                xy = list(zip(xa.tolist(),ya.tolist()))\n                if self.coastpolygontypes[npoly] not in [2,4]:\n                    poly = Polygon(xy,facecolor=color,edgecolor=color,linewidth=0)\n                else: # lakes filled with background color by default\n                    if lake_color is None:\n                        poly = Polygon(xy,facecolor=axisbgc,edgecolor=axisbgc,linewidth=0)\n                    else:\n                        poly = Polygon(xy,facecolor=lake_color,edgecolor=lake_color,linewidth=0)\n                if zorder is not None:\n                    poly.set_zorder(zorder)\n                if alpha is not None:\n                    poly.set_alpha(alpha)\n                ax.add_patch(poly)\n                polys.append(poly)\n            npoly = npoly + 1\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip continent polygons to map limbs\n        polys,c = self._cliplimb(ax,polys)\n        return polys\n\n    def _cliplimb(self,ax,coll):\n        if not self._mapboundarydrawn:\n            return coll, None\n        c = self._mapboundarydrawn\n        if c not in ax.patches:\n            p = ax.add_patch(c)\n            #p.set_clip_on(False)\n        try:\n            coll.set_clip_path(c)\n        except:\n            for item in coll:\n                item.set_clip_path(c)\n        return coll,c\n\n    def drawcoastlines(self,linewidth=1.,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw coastlines.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        coastline width (default 1.)\n        linestyle        coastline linestyle (default solid)\n        color            coastline color (default black)\n        antialiased      antialiasing switch for coastlines (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the coastlines (if not specified,\n                         uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        coastlines = LineCollection(self.coastsegs,antialiaseds=(antialiased,))\n        coastlines.set_color(color)\n        coastlines.set_linestyle(linestyle)\n        coastlines.set_linewidth(linewidth)\n        coastlines.set_label('_nolabel_')\n        if zorder is not None:\n            coastlines.set_zorder(zorder)\n        ax.add_collection(coastlines)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        coastlines,c = self._cliplimb(ax,coastlines)\n        return coastlines\n\n    def drawcountries(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw country boundaries.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        country boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            country boundary line color (default black)\n        antialiased      antialiasing switch for country boundaries (default\n                         True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the country boundaries (if not\n                         specified uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in country line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'cntrysegs'):\n            self.cntrysegs, types = self._readboundarydata('countries')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        countries = LineCollection(self.cntrysegs,antialiaseds=(antialiased,))\n        countries.set_color(color)\n        countries.set_linestyle(linestyle)\n        countries.set_linewidth(linewidth)\n        countries.set_label('_nolabel_')\n        if zorder is not None:\n            countries.set_zorder(zorder)\n        ax.add_collection(countries)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip countries to map limbs\n        countries,c = self._cliplimb(ax,countries)\n        return countries\n\n    def drawstates(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw state boundaries in Americas.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        state boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            state boundary line color (default black)\n        antialiased      antialiasing switch for state boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the state boundaries (if not\n                         specified, uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in state line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'statesegs'):\n            self.statesegs, types = self._readboundarydata('states')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        states = LineCollection(self.statesegs,antialiaseds=(antialiased,))\n        states.set_color(color)\n        states.set_linestyle(linestyle)\n        states.set_linewidth(linewidth)\n        states.set_label('_nolabel_')\n        if zorder is not None:\n            states.set_zorder(zorder)\n        ax.add_collection(states)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip states to map limbs\n        states,c = self._cliplimb(ax,states)\n        return states\n\n    def drawcounties(self,linewidth=0.1,linestyle='solid',color='k',antialiased=1,\n                     facecolor='none',ax=None,zorder=None,drawbounds=False):\n        \"\"\"\n        Draw county boundaries in US. The county boundary shapefile\n        originates with the NOAA Coastal Geospatial Data Project\n        (http://coastalgeospatial.noaa.gov/data_gis.html).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        county boundary line width (default 0.1)\n        linestyle        coastline linestyle (default solid)\n        color            county boundary line color (default black)\n        facecolor        fill color of county (default is no fill)\n        antialiased      antialiasing switch for county boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the county boundaries (if not\n                         specified, uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        ax = ax or self._check_ax()\n        gis_file = os.path.join(basemap_datadir,'UScounties')\n        county_info = self.readshapefile(gis_file,'counties',\\\n                      default_encoding='latin-1',drawbounds=drawbounds)\n        counties = [coords for coords in self.counties]\n        counties = PolyCollection(counties)\n        counties.set_linestyle(linestyle)\n        counties.set_linewidth(linewidth)\n        counties.set_edgecolor(color)\n        counties.set_facecolor(facecolor)\n        counties.set_label('counties')\n        if zorder:\n            counties.set_zorder(zorder)\n        ax.add_collection(counties)\n        return counties\n\n    def drawrivers(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw major rivers.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        river boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            river boundary line color (default black)\n        antialiased      antialiasing switch for river boundaries (default\n                         True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the rivers (if not\n                         specified uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in river line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'riversegs'):\n            self.riversegs, types = self._readboundarydata('rivers')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        rivers = LineCollection(self.riversegs,antialiaseds=(antialiased,))\n        rivers.set_color(color)\n        rivers.set_linestyle(linestyle)\n        rivers.set_linewidth(linewidth)\n        rivers.set_label('_nolabel_')\n        if zorder is not None:\n            rivers.set_zorder(zorder)\n        ax.add_collection(rivers)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip rivers to map limbs\n        rivers,c = self._cliplimb(ax,rivers)\n        return rivers\n\n    def is_land(self,xpt,ypt):\n        \"\"\"\n        Returns True if the given x,y point (in projection coordinates) is\n        over land, False otherwise.  The definition of land is based upon\n        the GSHHS coastline polygons associated with the class instance.\n        Points over lakes inside land regions are not counted as land points.\n        \"\"\"\n        if self.resolution is None: return None\n        landpt = False\n        for poly in self.landpolygons:\n            landpt = _geoslib.Point((xpt,ypt)).within(poly)\n            if landpt: break\n        lakept = False\n        for poly in self.lakepolygons:\n            lakept = _geoslib.Point((xpt,ypt)).within(poly)\n            if lakept: break\n        return landpt and not lakept\n\n    def readshapefile(self,shapefile,name,drawbounds=True,zorder=None,\n                      linewidth=0.5,color='k',antialiased=1,ax=None,\n                      default_encoding='utf-8',encoding_errors='strict'):\n        \"\"\"\n        Read in shape file, optionally draw boundaries on map.\n\n        .. note::\n          - Assumes shapes are 2D\n          - only works for Point, MultiPoint, Polyline and Polygon shapes.\n          - vertices/points must be in geographic (lat/lon) coordinates.\n\n        Mandatory Arguments:\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Argument         Description\n        ==============   ====================================================\n        shapefile        path to shapefile components.  Example:\n                         shapefile='/home/jeff/esri/world_borders' assumes\n                         that world_borders.shp, world_borders.shx and\n                         world_borders.dbf live in /home/jeff/esri.\n        name             name for Basemap attribute to hold the shapefile\n                         vertices or points in map projection\n                         coordinates. Class attribute name+'_info' is a list\n                         of dictionaries, one for each shape, containing\n                         attributes of each shape from dbf file, For\n                         example, if name='counties', self.counties\n                         will be a list of x,y vertices for each shape in\n                         map projection  coordinates and self.counties_info\n                         will be a list of dictionaries with shape\n                         attributes.  Rings in individual Polygon\n                         shapes are split out into separate polygons, and\n                         additional keys 'RINGNUM' and 'SHAPENUM' are added\n                         to the shape attribute dictionary.\n        ==============   ====================================================\n\n        The following optional keyword arguments are only relevant for Polyline\n        and Polygon shape types, for Point and MultiPoint shapes they are\n        ignored.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        drawbounds       draw boundaries of shapes (default True).\n        zorder           shape boundary zorder (if not specified,\n                         default for mathplotlib.lines.LineCollection\n                         is used).\n        linewidth        shape boundary line width (default 0.5)\n        color            shape boundary line color (default black)\n        antialiased      antialiasing switch for shape boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        default_encoding encoding used to parse properties from .dbf files\n                         (default utf-8)\n        encoding_errors  encoding error handling (default strict), other\n                         possible values: ignore, replace and backslashreplace\n        ==============   ====================================================\n\n        A tuple (num_shapes, type, min, max) containing shape file info\n        is returned.\n        num_shapes is the number of shapes, type is the type code (one of\n        the SHPT* constants defined in the shapelib module, see\n        http://shapelib.maptools.org/shp_api.html) and min and\n        max are 4-element lists with the minimum and maximum values of the\n        vertices. If ``drawbounds=True`` a\n        matplotlib.patches.LineCollection object is appended to the tuple.\n        \"\"\"\n        import shapefile as shp\n        from shapefile import Reader\n        shp.default_encoding = default_encoding\n        if not os.path.exists('%s.shp'%shapefile):\n            raise IOError('cannot locate %s.shp'%shapefile)\n        if not os.path.exists('%s.shx'%shapefile):\n            raise IOError('cannot locate %s.shx'%shapefile)\n        if not os.path.exists('%s.dbf'%shapefile):\n            raise IOError('cannot locate %s.dbf'%shapefile)\n        # open shapefile, read vertices for each object, convert\n        # to map projection coordinates (only works for 2D shape types).\n        try:\n            shf = Reader(shapefile, encoding=default_encoding,\n                         encodingErrors=encoding_errors)\n        except:\n            raise IOError('error reading shapefile %s.shp' % shapefile)\n        fields = shf.fields\n        coords = []; attributes = []\n        msg = \" \".join([\n            \"shapefile must have lat/lon vertices - it looks like this one\",\n            \"has vertices in map projection coordinates. You can convert the\",\n            \"shapefile to geographic coordinates using the shpproj utility\",\n            \"from the shapelib tools (http://shapelib.maptools.org/shapelib-tools.html)\"])\n        shptype = shf.shapes()[0].shapeType\n        bbox = shf.bbox.tolist()\n        info = (shf.numRecords,shptype,bbox[0:2]+[0.,0.],bbox[2:]+[0.,0.])\n        npoly = 0\n        for shprec in shf.shapeRecords():\n            shp = shprec.shape; rec = shprec.record\n            npoly = npoly + 1\n            if shptype != shp.shapeType:\n                raise ValueError('readshapefile can only handle a single shape type per file')\n            if shptype not in [1,3,5,8]:\n                raise ValueError('readshapefile can only handle 2D shape types')\n            verts = shp.points\n            if shptype in [1,8]: # a Point or MultiPoint shape.\n                lons, lats = list(zip(*verts))\n                if max(lons) > 721. or min(lons) < -721. or max(lats) > 90.01 or min(lats) < -90.01:\n                    raise ValueError(msg)\n                # if latitude is slightly greater than 90, truncate to 90\n                lats = [max(min(lat, 90.0), -90.0) for lat in lats]\n                if len(verts) > 1: # MultiPoint\n                    x,y = self(lons, lats)\n                    coords.append(list(zip(x,y)))\n                else: # single Point\n                    x,y = self(lons[0], lats[0])\n                    coords.append((x,y))\n                attdict={}\n                for r,key in zip(rec,fields[1:]):\n                    attdict[key[0]]=r\n                attributes.append(attdict)\n            else: # a Polyline or Polygon shape.\n                parts = shp.parts.tolist()\n                ringnum = 0\n                for indx1,indx2 in zip(parts,parts[1:]+[len(verts)]):\n                    ringnum = ringnum + 1\n                    lons, lats = list(zip(*verts[indx1:indx2]))\n                    if max(lons) > 721. or min(lons) < -721. or max(lats) > 90.01 or min(lats) < -90.01:\n                        raise ValueError(msg)\n                    # if latitude is slightly greater than 90, truncate to 90\n                    lats = [max(min(lat, 90.0), -90.0) for lat in lats]\n                    x, y = self(lons, lats)\n                    coords.append(list(zip(x,y)))\n                    attdict={}\n                    for r,key in zip(rec,fields[1:]):\n                        attdict[key[0]]=r\n                    # add information about ring number to dictionary.\n                    attdict['RINGNUM'] = ringnum\n                    attdict['SHAPENUM'] = npoly\n                    attributes.append(attdict)\n        # draw shape boundaries for polylines, polygons  using LineCollection.\n        if shptype not in [1,8] and drawbounds:\n            # get current axes instance (if none specified).\n            ax = ax or self._check_ax()\n            # make LineCollections for each polygon.\n            lines = LineCollection(coords,antialiaseds=(1,))\n            lines.set_color(color)\n            lines.set_linewidth(linewidth)\n            lines.set_label('_nolabel_')\n            if zorder is not None:\n               lines.set_zorder(zorder)\n            ax.add_collection(lines)\n            # set axes limits to fit map region.\n            self.set_axes_limits(ax=ax)\n            # clip boundaries to map limbs\n            lines,c = self._cliplimb(ax,lines)\n            info = info + (lines,)\n        self.__dict__[name]=coords\n        self.__dict__[name+'_info']=attributes\n        return info\n\n    def drawparallels(self,circles,color='k',textcolor='k',linewidth=1.,zorder=None, \\\n                      dashes=[1,1],labels=[0,0,0,0],labelstyle=None, \\\n                      fmt='%g',xoffset=None,yoffset=None,ax=None,latmax=None,\n                      **text_kwargs):\n        \"\"\"\n        Draw and label parallels (latitude lines) for values (in degrees)\n        given in the sequence ``circles``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to draw parallels (default black).\n        textcolor        color to draw labels (default black).\n        linewidth        line width for parallels (default 1.)\n        zorder           sets the zorder for parallels (if not specified,\n                         uses default zorder for matplotlib.lines.Line2D\n                         objects).\n        dashes           dash pattern for parallels (default [1,1], i.e.\n                         1 pixel on, 1 pixel off).\n        labels           list of 4 values (default [0,0,0,0]) that control\n                         whether parallels are labelled where they intersect\n                         the left, right, top or bottom of the plot. For\n                         example labels=[1,0,0,1] will cause parallels\n                         to be labelled where they intersect the left and\n                         and bottom of the plot, but not the right and top.\n        labelstyle       if set to \"+/-\", north and south latitudes are\n                         labelled with \"+\" and \"-\", otherwise they are\n                         labelled with \"N\" and \"S\".\n        fmt              a format string to format the parallel labels\n                         (default '%g') **or** a function that takes a\n                         latitude value in degrees as it's only argument\n                         and returns a formatted string.\n        xoffset          label offset from edge of map in x-direction\n                         (default is 0.01 times width of map in map\n                         projection coordinates).\n        yoffset          label offset from edge of map in y-direction\n                         (default is 0.01 times height of map in map\n                         projection coordinates).\n        ax               axes instance (overrides default axes instance)\n        latmax           absolute value of latitude to which meridians are drawn\n                         (default is 80).\n        \\**text_kwargs   additional keyword arguments controlling text\n                         for labels that are passed on to\n                         the text method of the axes instance (see\n                         matplotlib.pyplot.text documentation).\n        ==============   ====================================================\n\n        returns a dictionary whose keys are the parallel values, and\n        whose values are tuples containing lists of the\n        matplotlib.lines.Line2D and matplotlib.text.Text instances\n        associated with each parallel. Deleting an item from the\n        dictionary removes the corresponding parallel from the plot.\n        \"\"\"\n        text_kwargs['color']=textcolor # pass textcolor kwarg on to ax.text\n        # if celestial=True, don't use \"N\" and \"S\" labels.\n        if labelstyle is None and self.celestial:\n            labelstyle=\"+/-\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # don't draw meridians past latmax, always draw parallel at latmax.\n        if latmax is None: latmax = 80.\n        # offset for labels.\n        if yoffset is None:\n            yoffset = (self.urcrnry-self.llcrnry)/100.\n            if self.aspect > 1:\n                yoffset = self.aspect*yoffset\n            else:\n                yoffset = yoffset/self.aspect\n        if xoffset is None:\n            xoffset = (self.urcrnrx-self.llcrnrx)/100.\n\n        if self.projection in _cylproj + _pseudocyl:\n            lons = np.linspace(self.llcrnrlon, self.urcrnrlon, 10001)\n        elif self.projection in ['tmerc']:\n            lon_0 = self.projparams['lon_0']\n            # tmerc only defined within +/- 90 degrees of lon_0\n            lons = np.linspace(lon_0-90,lon_0+90,100001)\n        else:\n            lonmin = self.boundarylonmin; lonmax = self.boundarylonmax\n            lons = np.linspace(lonmin, lonmax, 10001)\n        # make sure latmax degree parallel is drawn if projection not merc or cyl or miller\n        try:\n            circlesl = list(circles)\n        except:\n            circlesl = circles\n        if self.projection not in _cylproj + _pseudocyl:\n            if max(circlesl) > 0 and latmax not in circlesl:\n                circlesl.append(latmax)\n            if min(circlesl) < 0 and -latmax not in circlesl:\n                circlesl.append(-latmax)\n        xdelta = 0.01*(self.xmax-self.xmin)\n        ydelta = 0.01*(self.ymax-self.ymin)\n        linecolls = {}\n        for circ in circlesl:\n            lats = circ*np.ones(len(lons),np.float32)\n            x,y = self(lons,lats)\n            # remove points outside domain.\n            # leave a little slop around edges (3*xdelta)\n            # don't really know why, but this appears to be needed to\n            # or lines sometimes don't reach edge of plot.\n            testx = np.logical_and(x>=self.xmin-3*xdelta,x<=self.xmax+3*xdelta)\n            x = np.compress(testx, x)\n            y = np.compress(testx, y)\n            testy = np.logical_and(y>=self.ymin-3*ydelta,y<=self.ymax+3*ydelta)\n            x = np.compress(testy, x)\n            y = np.compress(testy, y)\n            lines = []\n            if len(x) > 1 and len(y) > 1:\n                # split into separate line segments if necessary.\n                # (not necessary for cylindrical or pseudocylindricl projections)\n                xd = (x[1:]-x[0:-1])**2\n                yd = (y[1:]-y[0:-1])**2\n                dist = np.sqrt(xd+yd)\n                if self.projection not in ['cyl','rotpole']:\n                    split = dist > self.rmajor/10.\n                else:\n                    split = dist > 1.\n                if np.sum(split) and self.projection not in _cylproj:\n                    ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                    xl = []\n                    yl = []\n                    iprev = 0\n                    ind.append(len(xd))\n                    for i in ind:\n                        xl.append(x[iprev:i])\n                        yl.append(y[iprev:i])\n                        iprev = i\n                else:\n                    xl = [x]\n                    yl = [y]\n                # draw each line segment.\n                for x,y in zip(xl,yl):\n                    # skip if only a point.\n                    if len(x) > 1 and len(y) > 1:\n                        l = Line2D(x,y,linewidth=linewidth)\n                        l.set_color(color)\n                        l.set_dashes(dashes)\n                        l.set_label('_nolabel_')\n                        if zorder is not None:\n                            l.set_zorder(zorder)\n                        ax.add_line(l)\n                        lines.append(l)\n            linecolls[circ] = (lines,[])\n        # draw labels for parallels\n        # parallels not labelled for fulldisk orthographic or geostationary\n        if self.projection in ['ortho','geos','nsper','vandg','aeqd'] and max(labels):\n            if self.projection == 'vandg' or self._fulldisk:\n                sys.stdout.write('Warning: Cannot label parallels on %s basemap' % _projnames[self.projection])\n                labels = [0,0,0,0]\n        # search along edges of map to see if parallels intersect.\n        # if so, find x,y location of intersection and draw a label there.\n        dx = (self.xmax-self.xmin)/1000.\n        dy = (self.ymax-self.ymin)/1000.\n        if self.projection in _pseudocyl:\n            lon_0 = self.projparams['lon_0']\n        for dolab,side in zip(labels,['l','r','t','b']):\n            if not dolab: continue\n            # for cylindrical projections, don't draw parallels on top or bottom.\n            if self.projection in _cylproj + _pseudocyl and side in ['t','b']: continue\n            if side in ['l','r']:\n                nmax = int((self.ymax-self.ymin)/dy+1)\n                yy = np.linspace(self.llcrnry,self.urcrnry,nmax)\n                if side == 'l':\n                    if self.projection in _pseudocyl:\n                        lats = np.linspace(-89.99,89,99,nmax)\n                        if self.celestial:\n                            lons = (self.projparams['lon_0']+180.)*np.ones(len(lats),lats.dtype)\n                        else:\n                            lons = (self.projparams['lon_0']-180.)*np.ones(len(lats),lats.dtype)\n                        xx, yy = self(lons, lats)\n                    else:\n                        xx = self.llcrnrx*np.ones(yy.shape,yy.dtype)\n                        lons,lats = self(xx,yy,inverse=True)\n                        lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    if self.projection in _pseudocyl:\n                        lats = np.linspace(-89.99,89,99,nmax)\n                        if self.celestial:\n                           lons = (self.projparams['lon_0']-180.)*np.ones(len(lats),lats.dtype)\n                        else:\n                           lons = (self.projparams['lon_0']+180.)*np.ones(len(lats),lats.dtype)\n                        xx, yy = self(lons, lats)\n                    else:\n                        xx = self.urcrnrx*np.ones(yy.shape,yy.dtype)\n                        lons,lats = self(xx,yy,inverse=True)\n                        lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            else:\n                nmax = int((self.xmax-self.xmin)/dx+1)\n                xx = np.linspace(self.llcrnrx,self.urcrnrx,nmax)\n                if side == 'b':\n                    lons,lats = self(xx,self.llcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(xx,self.urcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            for lat in circles:\n                # don't label parallels for round polar plots\n                if self.round: continue\n                # find index of parallel (there may be two, so\n                # search from left and right).\n                nl = _searchlist(lats,lat)\n                nr = _searchlist(lats[::-1],lat)\n                if nr != -1: nr = len(lons)-nr-1\n                latlab = _setlatlab(fmt,lat,labelstyle)\n                # parallels can intersect each map edge twice.\n                for i,n in enumerate([nl,nr]):\n                    # don't bother if close to the first label.\n                    if i and abs(nr-nl) < 100: continue\n                    if n >= 0:\n                        t = None\n                        if side == 'l':\n                            if self.projection in _pseudocyl:\n                                if self.celestial:\n                                    xlab,ylab = self(lon_0+179.9,lat)\n                                else:\n                                    xlab,ylab = self(lon_0-179.9,lat)\n                            else:\n                                xlab = self.llcrnrx\n                            xlab = xlab-xoffset\n                            if self.projection in _pseudocyl:\n                                if lat>0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='bottom',**text_kwargs)\n                                elif lat<0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='top',**text_kwargs)\n                                else:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                            else:\n                               t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                        elif side == 'r':\n                            if self.projection in _pseudocyl:\n                                if self.celestial:\n                                   xlab,ylab = self(lon_0-179.9,lat)\n                                else:\n                                   xlab,ylab = self(lon_0+179.9,lat)\n                            else:\n                                xlab = self.urcrnrx\n                            xlab = xlab+xoffset\n                            if self.projection in _pseudocyl:\n                                if lat>0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='bottom',**text_kwargs)\n                                elif lat<0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='top',**text_kwargs)\n                                else:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                            else:\n                               t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                        elif side == 'b':\n                            t = ax.text(xx[n],self.llcrnry-yoffset,latlab,horizontalalignment='center',verticalalignment='top',**text_kwargs)\n                        else:\n                            t = ax.text(xx[n],self.urcrnry+yoffset,latlab,horizontalalignment='center',verticalalignment='bottom',**text_kwargs)\n                        if t is not None: linecolls[lat][1].append(t)\n\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        keys = list(linecolls.keys()); vals = list(linecolls.values())\n        for k,v in zip(keys,vals):\n            if v == ([], []):\n                del linecolls[k]\n            # add a remove method to each tuple.\n            else:\n                linecolls[k] = _tup(linecolls[k])\n        # override __delitem__ in dict to call remove() on values.\n        pardict = _dict(linecolls)\n        # clip parallels for round polar plots (and delete labels).\n        for lines, _ in pardict.values():\n            self._cliplimb(ax, lines)\n        return pardict\n\n    def drawmeridians(self,meridians,color='k',textcolor='k',linewidth=1., zorder=None,\\\n                      dashes=[1,1],labels=[0,0,0,0],labelstyle=None,\\\n                      fmt='%g',xoffset=None,yoffset=None,ax=None,latmax=None,\n                      **text_kwargs):\n        \"\"\"\n        Draw and label meridians (longitude lines) for values (in degrees)\n        given in the sequence ``meridians``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to draw meridians (default black).\n        textcolor        color to draw labels (default black).\n        linewidth        line width for meridians (default 1.)\n        zorder           sets the zorder for meridians (if not specified,\n                         uses default zorder for matplotlib.lines.Line2D\n                         objects).\n        dashes           dash pattern for meridians (default [1,1], i.e.\n                         1 pixel on, 1 pixel off).\n        labels           list of 4 values (default [0,0,0,0]) that control\n                         whether meridians are labelled where they intersect\n                         the left, right, top or bottom of the plot. For\n                         example labels=[1,0,0,1] will cause meridians\n                         to be labelled where they intersect the left and\n                         and bottom of the plot, but not the right and top.\n        labelstyle       if set to \"+/-\", east and west longitudes are\n                         labelled with \"+\" and \"-\", otherwise they are\n                         labelled with \"E\" and \"W\".\n        fmt              a format string to format the meridian labels\n                         (default '%g') **or** a function that takes a\n                         longitude value in degrees as it's only argument\n                         and returns a formatted string.\n        xoffset          label offset from edge of map in x-direction\n                         (default is 0.01 times width of map in map\n                         projection coordinates).\n        yoffset          label offset from edge of map in y-direction\n                         (default is 0.01 times height of map in map\n                         projection coordinates).\n        ax               axes instance (overrides default axes instance)\n        latmax           absolute value of latitude to which meridians are drawn\n                         (default is 80).\n        \\**text_kwargs   additional keyword arguments controlling text\n                         for labels that are passed on to\n                         the text method of the axes instance (see\n                         matplotlib.pyplot.text documentation).\n        ==============   ====================================================\n\n        returns a dictionary whose keys are the meridian values, and\n        whose values are tuples containing lists of the\n        matplotlib.lines.Line2D and matplotlib.text.Text instances\n        associated with each meridian. Deleting an item from the\n        dictionary removes the correpsonding meridian from the plot.\n        \"\"\"\n        text_kwargs['color']=textcolor # pass textcolor kwarg on to ax.text\n        # for cylindrical projections, try to handle wraparound (i.e. if\n        # projection is defined in -180 to 0 and user asks for meridians from\n        # 180 to 360 to be drawn, it should work)\n        if self.projection in _cylproj or self.projection in _pseudocyl:\n            def addlon(meridians,madd):\n                minside = (madd >= self.llcrnrlon and madd <= self.urcrnrlon)\n                if minside and madd not in meridians: meridians.append(madd)\n                return meridians\n            merids = list(meridians)\n            meridians = []\n            for m in merids:\n                meridians = addlon(meridians,m)\n                meridians = addlon(meridians,m+360)\n                meridians = addlon(meridians,m-360)\n            meridians.sort()\n        # if celestial=True, don't use \"E\" and \"W\" labels.\n        if labelstyle is None and self.celestial:\n            labelstyle=\"+/-\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # don't draw meridians past latmax, always draw parallel at latmax.\n        if latmax is None: latmax = 80. # unused w/ cyl, merc or miller proj.\n        # offset for labels.\n        if yoffset is None:\n            yoffset = (self.urcrnry-self.llcrnry)/100.\n            if self.aspect > 1:\n                yoffset = self.aspect*yoffset\n            else:\n                yoffset = yoffset/self.aspect\n        if xoffset is None:\n            xoffset = (self.urcrnrx-self.llcrnrx)/100.\n\n        lats = np.linspace(self.latmin,self.latmax,10001)\n        if self.projection not in _cylproj + _pseudocyl:\n            testlat = np.logical_and(lats>-latmax,lats<latmax)\n            lats = np.compress(testlat,lats)\n\n        xdelta = 0.01*(self.xmax-self.xmin)\n        ydelta = 0.01*(self.ymax-self.ymin)\n        linecolls = {}\n        for merid in meridians:\n            lons = merid*np.ones(len(lats),np.float32)\n            x,y = self(lons,lats)\n            # remove points outside domain.\n            # leave a little slop around edges (3*xdelta)\n            # don't really know why, but this appears to be needed to\n            # or lines sometimes don't reach edge of plot.\n            testx = np.logical_and(x>=self.xmin-3*xdelta,x<=self.xmax+3*xdelta)\n            x = np.compress(testx, x)\n            y = np.compress(testx, y)\n            testy = np.logical_and(y>=self.ymin-3*ydelta,y<=self.ymax+3*ydelta)\n            x = np.compress(testy, x)\n            y = np.compress(testy, y)\n            lines = []\n            if len(x) > 1 and len(y) > 1:\n                # split into separate line segments if necessary.\n                # (not necessary for mercator or cylindrical or miller).\n                xd = (x[1:]-x[0:-1])**2\n                yd = (y[1:]-y[0:-1])**2\n                dist = np.sqrt(xd+yd)\n                if self.projection not in ['cyl','rotpole']:\n                    split = dist > self.rmajor/10.\n                else:\n                    split = dist > 1.\n                if np.sum(split) and self.projection not in _cylproj:\n                    ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                    xl = []\n                    yl = []\n                    iprev = 0\n                    ind.append(len(xd))\n                    for i in ind:\n                        xl.append(x[iprev:i])\n                        yl.append(y[iprev:i])\n                        iprev = i\n                else:\n                    xl = [x]\n                    yl = [y]\n                # draw each line segment.\n                for x,y in zip(xl,yl):\n                    # skip if only a point.\n                    if len(x) > 1 and len(y) > 1:\n                        l = Line2D(x,y,linewidth=linewidth)\n                        l.set_color(color)\n                        l.set_dashes(dashes)\n                        l.set_label('_nolabel_')\n                        if zorder is not None:\n                            l.set_zorder(zorder)\n                        ax.add_line(l)\n                        lines.append(l)\n            linecolls[merid] = (lines,[])\n        # draw labels for meridians.\n        # meridians not labelled for sinusoidal, hammer, mollweide,\n        # VanDerGrinten or full-disk orthographic/geostationary.\n        if self.projection in ['sinu','moll','hammer','vandg'] and max(labels):\n            sys.stdout.write('Warning: Cannot label meridians on %s basemap' % _projnames[self.projection])\n            labels = [0,0,0,0]\n        if self.projection in ['ortho','geos','nsper','aeqd'] and max(labels):\n            if self._fulldisk and self.boundinglat is None:\n                sys.stdout.write(\" \".join([\n                    \"Warning: Cannot label meridians on full-disk Geostationary,\"\n                    \"Orthographic or Azimuthal equidistant basemap\"]))\n                labels = [0,0,0,0]\n        # search along edges of map to see if parallels intersect.\n        # if so, find x,y location of intersection and draw a label there.\n        dx = (self.xmax-self.xmin)/1000.\n        dy = (self.ymax-self.ymin)/1000.\n        if self.projection in _pseudocyl:\n            lon_0 = self.projparams['lon_0']\n            xmin,ymin = self(lon_0-179.9,-90)\n            xmax,ymax = self(lon_0+179.9,90)\n        for dolab,side in zip(labels,['l','r','t','b']):\n            if not dolab or self.round: continue\n            # for cylindrical projections, don't draw meridians on left or right.\n            if self.projection in _cylproj + _pseudocyl and side in ['l','r']: continue\n            if side in ['l','r']:\n                nmax = int((self.ymax-self.ymin)/dy+1)\n                yy = np.linspace(self.llcrnry,self.urcrnry,nmax)\n                if side == 'l':\n                    lons,lats = self(self.llcrnrx*np.ones(yy.shape,np.float32),yy,inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(self.urcrnrx*np.ones(yy.shape,np.float32),yy,inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            else:\n                nmax = int((self.xmax-self.xmin)/dx+1)\n                if self.projection in _pseudocyl:\n                    xx = np.linspace(xmin,xmax,nmax)\n                else:\n                    xx = np.linspace(self.llcrnrx,self.urcrnrx,nmax)\n                if side == 'b':\n                    lons,lats = self(xx,self.llcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(xx,self.urcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            for lon in meridians:\n                # adjust so 0 <= lon < 360\n                lon2 = (lon+360) % 360\n                # find index of meridian (there may be two, so\n                # search from left and right).\n                nl = _searchlist(lons,lon2)\n                nr = _searchlist(lons[::-1],lon2)\n                if nr != -1: nr = len(lons)-nr-1\n                lonlab = _setlonlab(fmt,lon2,labelstyle)\n                # meridians can intersect each map edge twice.\n                for i,n in enumerate([nl,nr]):\n                    lat = lats[n]/100.\n                    # no meridians > latmax for projections other than merc,cyl,miller.\n                    if self.projection not in _cylproj and lat > latmax: continue\n                    # don't bother if close to the first label.\n                    if i and abs(nr-nl) < 100: continue\n                    if n >= 0:\n                        t = None\n                        if side == 'l':\n                            t = ax.text(self.llcrnrx-xoffset,yy[n],lonlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                        elif side == 'r':\n                            t = ax.text(self.urcrnrx+xoffset,yy[n],lonlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                        elif side == 'b':\n                            t = ax.text(xx[n],self.llcrnry-yoffset,lonlab,horizontalalignment='center',verticalalignment='top',**text_kwargs)\n                        else:\n                            t = ax.text(xx[n],self.urcrnry+yoffset,lonlab,horizontalalignment='center',verticalalignment='bottom',**text_kwargs)\n\n                        if t is not None: linecolls[lon][1].append(t)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # remove empty values from linecolls dictionary\n        keys = list(linecolls.keys()); vals = list(linecolls.values())\n        for k,v in zip(keys,vals):\n            if v == ([], []):\n                del linecolls[k]\n            else:\n            # add a remove method to each tuple.\n                linecolls[k] = _tup(linecolls[k])\n        # override __delitem__ in dict to call remove() on values.\n        meridict = _dict(linecolls)\n        # for round polar plots, clip meridian lines and label them.\n        if self.round:\n            # label desired?\n            label = False\n            for lab in labels:\n                if lab: label = True\n            for merid in meridict:\n                if not label: continue\n                # label\n                lonlab = _setlonlab(fmt,merid,labelstyle)\n                x,y = self(merid,self.boundinglat)\n                r = np.sqrt((x-0.5*(self.xmin+self.xmax))**2+\n                            (y-0.5*(self.ymin+self.ymax))**2)\n                r = r + np.sqrt(xoffset**2+yoffset**2)\n                if self.projection.startswith('np'):\n                    pole = 1\n                elif self.projection.startswith('sp'):\n                    pole = -1\n                elif self.projection == 'ortho' and self.round:\n                    pole = 1\n                if pole == 1:\n                    theta = (np.pi/180.)*(merid-self.projparams['lon_0']-90)\n                    if self.projection == 'ortho' and\\\n                       self.projparams['lat_0'] == -90:\n                        theta = (np.pi/180.)*(-merid+self.projparams['lon_0']+90)\n                    x = r*np.cos(theta)+0.5*(self.xmin+self.xmax)\n                    y = r*np.sin(theta)+0.5*(self.ymin+self.ymax)\n                    if x > 0.5*(self.xmin+self.xmax)+xoffset:\n                        horizalign = 'left'\n                    elif x < 0.5*(self.xmin+self.xmax)-xoffset:\n                        horizalign = 'right'\n                    else:\n                        horizalign = 'center'\n                    if y > 0.5*(self.ymin+self.ymax)+yoffset:\n                        vertalign = 'bottom'\n                    elif y < 0.5*(self.ymin+self.ymax)-yoffset:\n                        vertalign = 'top'\n                    else:\n                        vertalign = 'center'\n                    # labels [l,r,t,b]\n                    if labels[0] and not labels[1] and x >= 0.5*(self.xmin+self.xmax)+xoffset: continue\n                    if labels[1] and not labels[0] and x <= 0.5*(self.xmin+self.xmax)-xoffset: continue\n                    if labels[2] and not labels[3] and y <= 0.5*(self.ymin+self.ymax)-yoffset: continue\n                    if labels[3] and not labels[2]and y >= 0.5*(self.ymin+self.ymax)+yoffset: continue\n                elif pole == -1:\n                    theta = (np.pi/180.)*(-merid+self.projparams['lon_0']+90)\n                    x = r*np.cos(theta)+0.5*(self.xmin+self.xmax)\n                    y = r*np.sin(theta)+0.5*(self.ymin+self.ymax)\n                    if x > 0.5*(self.xmin+self.xmax)-xoffset:\n                        horizalign = 'right'\n                    elif x < 0.5*(self.xmin+self.xmax)+xoffset:\n                        horizalign = 'left'\n                    else:\n                        horizalign = 'center'\n                    if y > 0.5*(self.ymin+self.ymax)-yoffset:\n                        vertalign = 'top'\n                    elif y < 0.5*(self.ymin+self.ymax)+yoffset:\n                        vertalign = 'bottom'\n                    else:\n                        vertalign = 'center'\n                    # labels [l,r,t,b]\n                    if labels[0] and not labels[1] and x <=  0.5*(self.xmin+self.xmax)+xoffset: continue\n                    if labels[1] and not labels[0] and x >=  0.5*(self.xmin+self.xmax)-xoffset: continue\n                    if labels[2] and not labels[3] and y >=  0.5*(self.ymin+self.ymax)-yoffset: continue\n                    if labels[3] and not labels[2] and y <=  0.5*(self.ymin+self.ymax)+yoffset: continue\n                t=ax.text(x,y,lonlab,horizontalalignment=horizalign,verticalalignment=vertalign,**text_kwargs)\n                meridict[merid][1].append(t)\n        for lines, _ in meridict.values():\n            self._cliplimb(ax, lines)\n        return meridict\n\n    def tissot(self,lon_0,lat_0,radius_deg,npts,ax=None,**kwargs):\n        \"\"\"\n        Draw a polygon centered at ``lon_0,lat_0``.  The polygon\n        approximates a circle on the surface of the earth with radius\n        ``radius_deg`` degrees latitude along longitude ``lon_0``,\n        made up of ``npts`` vertices.\n        The polygon represents a Tissot's indicatrix\n        (http://en.wikipedia.org/wiki/Tissot's_Indicatrix),\n        which when drawn on a map shows the distortion\n        inherent in the map projection.\n\n        .. note::\n         Cannot handle situations in which the polygon intersects\n         the edge of the map projection domain, and then re-enters the domain.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.patches.Polygon.\n\n        returns a matplotlib.patches.Polygon object.\"\"\"\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        g = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = g.inv(lon_0,lat_0,lon_0,lat_0+radius_deg)\n        seg = [self(lon_0,lat_0+radius_deg)]\n        delaz = 360./npts\n        az = az12\n        for n in range(npts):\n            az = az+delaz\n            lon, lat, az21 = g.fwd(lon_0, lat_0, az, dist)\n            x,y = self(lon,lat)\n            # add segment if it is in the map projection region.\n            if x < 1.e20 and y < 1.e20:\n                seg.append((x,y))\n        poly = Polygon(seg,**kwargs)\n        ax.add_patch(poly)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip polygons to map limbs\n        poly,c = self._cliplimb(ax,poly)\n        return poly\n\n    def gcpoints(self,lon1,lat1,lon2,lat2,npoints):\n        \"\"\"\n        compute ``points`` points along a great circle with endpoints\n        ``(lon1,lat1)`` and ``(lon2,lat2)``.\n\n        Returns arrays x,y with map projection coordinates.\n        \"\"\"\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        lonlats = gc.npts(lon1,lat1,lon2,lat2,npoints-2)\n        lons=[lon1];lats=[lat1]\n        for lon,lat in lonlats:\n            lons.append(lon); lats.append(lat)\n        lons.append(lon2); lats.append(lat2)\n        x, y = self(lons, lats)\n        return x,y\n\n    def drawgreatcircle(self,lon1,lat1,lon2,lat2,del_s=100.,**kwargs):\n        \"\"\"\n        Draw a great circle on the map from the longitude-latitude\n        pair ``lon1,lat1`` to ``lon2,lat2``\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   =======================================================\n        Keyword          Description\n        ==============   =======================================================\n        del_s            points on great circle computed every del_s kilometers\n                         (default 100).\n        \\**kwargs        other keyword arguments are passed on to :meth:`plot`\n                         method of Basemap instance.\n        ==============   =======================================================\n\n        Returns a list with a single ``matplotlib.lines.Line2D`` object like a\n        call to ``pyplot.plot()``.\n        \"\"\"\n        # use great circle formula for a perfect sphere.\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = gc.inv(lon1,lat1,lon2,lat2)\n        npoints = int((dist+0.5*1000.*del_s)/(1000.*del_s))\n        lonlats = gc.npts(lon1,lat1,lon2,lat2,npoints)\n        lons = [lon1]; lats = [lat1]\n        for lon, lat in lonlats:\n            lons.append(lon)\n            lats.append(lat)\n        lons.append(lon2); lats.append(lat2)\n        x, y = self(lons, lats)\n\n        # Correct wrap around effect of great circles\n\n        # get points\n        _p = self.plot(x,y,**kwargs)\n        p = _p[0].get_path()\n\n        # since we know the difference between any two points, we can use this to find wrap arounds on the plot\n        max_dist = 1000*del_s*2\n\n        # calculate distances and compare with max allowable distance\n        dists = np.abs(np.diff(p.vertices[:,0]))\n        cuts = np.where( dists > max_dist )[0]\n\n        # if there are any cut points, cut them and begin again at the next point\n        for i,k in enumerate(cuts):\n            # vertex to cut at\n            cut_point = cuts[i]\n\n            # create new vertices with a nan inbetween and set those as the path's vertices\n            verts = np.concatenate(\n                                       [p.vertices[:cut_point, :],\n                                        [[np.nan, np.nan]],\n                                        p.vertices[cut_point+1:, :]]\n                                       )\n            p.codes = None\n            p.vertices = verts\n\n        return _p\n\n    def transform_scalar(self,datin,lons,lats,nx,ny,returnxy=False,checkbounds=False,order=1,masked=False):\n        \"\"\"\n        Interpolate a scalar field (``datin``) from a lat/lon grid with\n        longitudes = ``lons`` and latitudes = ``lats`` to a ``ny`` by ``nx``\n        map projection grid.  Typically used to transform data to\n        map projection coordinates for plotting on a map with\n        the :meth:`imshow`.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Argument         Description\n        ==============   ====================================================\n        datin            input data on a lat/lon grid.\n        lons, lats       rank-1 arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cea``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        nx, ny           The size of the output regular grid in map\n                         projection coordinates\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        returnxy         If True, the x and y values of the map\n                         projection grid are also returned (Default False).\n        checkbounds      If True, values of lons and lats are checked to see\n                         that they lie within the map projection region.\n                         Default is False, and data outside map projection\n                         region is clipped to values on boundary.\n        masked           If True, interpolated data is returned as a masked\n                         array with values outside map projection region\n                         masked (Default False).\n        order            0 for nearest-neighbor interpolation, 1 for\n                         bilinear, 3 for cubic spline (Default 1).\n                         Cubic spline interpolation requires scipy.ndimage.\n        ==============   ====================================================\n\n        Returns ``datout`` (data on map projection grid).\n        If returnxy=True, returns ``data,x,y``.\n        \"\"\"\n        # check that lons, lats increasing\n        delon = lons[1:]-lons[0:-1]\n        delat = lats[1:]-lats[0:-1]\n        if min(delon) < 0. or min(delat) < 0.:\n            raise ValueError('lons and lats must be increasing!')\n        # check that lons in -180,180 for non-cylindrical projections.\n        if self.projection not in _cylproj:\n            lonsa = np.array(lons)\n            count = np.sum(lonsa < -180.00001) + np.sum(lonsa > 180.00001)\n            if count > 1:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n            # allow for wraparound point to be outside.\n            elif count == 1 and math.fabs(lons[-1]-lons[0]-360.) > 1.e-4:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n        if returnxy:\n            lonsout, latsout, x, y = self.makegrid(nx,ny,returnxy=True)\n        else:\n            lonsout, latsout = self.makegrid(nx,ny)\n        datout = interp(datin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        if returnxy:\n            return datout, x, y\n        else:\n            return datout\n\n    def transform_vector(self,uin,vin,lons,lats,nx,ny,returnxy=False,checkbounds=False,order=1,masked=False):\n        \"\"\"\n        Rotate and interpolate a vector field (``uin,vin``) from a\n        lat/lon grid with longitudes = ``lons`` and latitudes = ``lats``\n        to a ``ny`` by ``nx`` map projection grid.\n\n        The input vector field is defined in spherical coordinates (it\n        has eastward and northward components) while the output\n        vector field is rotated to map projection coordinates (relative\n        to x and y). The magnitude of the vector is preserved.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        uin, vin         input vector field on a lat/lon grid.\n        lons, lats       rank-1 arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cea``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        nx, ny           The size of the output regular grid in map\n                         projection coordinates\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        returnxy         If True, the x and y values of the map\n                         projection grid are also returned (Default False).\n        checkbounds      If True, values of lons and lats are checked to see\n                         that they lie within the map projection region.\n                         Default is False, and data outside map projection\n                         region is clipped to values on boundary.\n        masked           If True, interpolated data is returned as a masked\n                         array with values outside map projection region\n                         masked (Default False).\n        order            0 for nearest-neighbor interpolation, 1 for\n                         bilinear, 3 for cubic spline (Default 1).\n                         Cubic spline interpolation requires scipy.ndimage.\n        ==============   ====================================================\n\n        Returns ``uout, vout`` (vector field on map projection grid).\n        If returnxy=True, returns ``uout,vout,x,y``.\n        \"\"\"\n        # check that lons, lats increasing\n        delon = lons[1:]-lons[0:-1]\n        delat = lats[1:]-lats[0:-1]\n        if min(delon) < 0. or min(delat) < 0.:\n            raise ValueError('lons and lats must be increasing!')\n        # check that lons in -180,180 for non-cylindrical projections.\n        if self.projection not in _cylproj:\n            lonsa = np.array(lons)\n            count = np.sum(lonsa < -180.00001) + np.sum(lonsa > 180.00001)\n            if count > 1:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n            # allow for wraparound point to be outside.\n            elif count == 1 and math.fabs(lons[-1]-lons[0]-360.) > 1.e-4:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n        lonsout, latsout, x, y = self.makegrid(nx,ny,returnxy=True)\n        # interpolate to map projection coordinates.\n        uin = interp(uin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        vin = interp(vin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        # rotate from geographic to map coordinates.\n        return self.rotate_vector(uin,vin,lonsout,latsout,returnxy=returnxy)\n\n    def rotate_vector(self,uin,vin,lons,lats,returnxy=False):\n        \"\"\"\n        Rotate a vector field (``uin,vin``) on a rectilinear grid\n        with longitudes = ``lons`` and latitudes = ``lats`` from\n        geographical (lat/lon) into map projection (x/y) coordinates.\n\n        Differs from transform_vector in that no interpolation is done.\n        The vector is returned on the same grid, but rotated into\n        x,y coordinates.\n\n        The input vector field is defined in spherical coordinates (it\n        has eastward and northward components) while the output\n        vector field is rotated to map projection coordinates (relative\n        to x and y). The magnitude of the vector is preserved.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        uin, vin         input vector field on a lat/lon grid.\n        lons, lats       Arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cyl``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        ==============   ====================================================\n\n        Returns ``uout, vout`` (rotated vector field).\n        If the optional keyword argument\n        ``returnxy`` is True (default is False),\n        returns ``uout,vout,x,y`` (where ``x,y`` are the map projection\n        coordinates of the grid defined by ``lons,lats``).\n        \"\"\"\n        # if lons,lats are 1d and uin,vin are 2d, and\n        # lats describes 1st dim of uin,vin, and\n        # lons describes 2nd dim of uin,vin, make lons,lats 2d\n        # with meshgrid.\n        if lons.ndim == lats.ndim == 1 and uin.ndim == vin.ndim == 2 and\\\n           uin.shape[1] == vin.shape[1] == lons.shape[0] and\\\n           uin.shape[0] == vin.shape[0] == lats.shape[0]:\n            lons, lats = np.meshgrid(lons, lats)\n        else:\n            if not lons.shape == lats.shape == uin.shape == vin.shape:\n                raise TypeError(\"shapes of lons,lats and uin,vin don't match\")\n        x, y = self(lons, lats)\n        # rotate from geographic to map coordinates.\n        if ma.isMaskedArray(uin):\n            mask = ma.getmaskarray(uin)\n            masked = True\n            uin = uin.filled(1)\n            vin = vin.filled(1)\n        else:\n            masked = False\n\n        # Map the (lon, lat) vector in the complex plane.\n        uvc = uin + 1j*vin\n        uvmag = np.abs(uvc)\n        theta = np.angle(uvc)\n\n        # Define a displacement (dlon, dlat) that moves all\n        # positions (lons, lats) a small distance in the\n        # direction of the original vector.\n        dc = 1E-5 * np.exp(theta*1j)\n        dlat = dc.imag * np.cos(np.radians(lats))\n        dlon = dc.real\n\n        # Deal with displacements that overshoot the North or South Pole.\n        farnorth = np.abs(lats+dlat) >= 90.0\n        somenorth = farnorth.any()\n        if somenorth:\n            dlon[farnorth] *= -1.0\n            dlat[farnorth] *= -1.0\n\n        # Add displacement to original location and find the native coordinates.\n        lon1 = lons + dlon\n        lat1 = lats + dlat\n        xn, yn = self(lon1, lat1)\n\n        # Determine the angle of the displacement in the native coordinates.\n        vecangle = np.arctan2(yn-y, xn-x)\n        if somenorth:\n            vecangle[farnorth] += np.pi\n\n        # Compute the x-y components of the original vector.\n        uvcout = uvmag * np.exp(1j*vecangle)\n        uout = uvcout.real\n        vout = uvcout.imag\n\n        if masked:\n            uout = ma.array(uout, mask=mask)\n            vout = ma.array(vout, mask=mask)\n        if returnxy:\n            return uout,vout,x,y\n        else:\n            return uout,vout\n\n    def set_axes_limits(self,ax=None):\n        \"\"\"\n        Final step in Basemap method wrappers of Axes plotting methods:\n\n        Set axis limits, fix aspect ratio for map domain using current\n        or specified axes instance.  This is done only once per axes\n        instance.\n\n        In interactive mode, this method always calls draw_if_interactive\n        before returning.\n\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n\n        # If we have already set the axes limits, and if the user\n        # has not defeated this by turning autoscaling back on,\n        # then all we need to do is plot if interactive.\n        if (hash(ax) in self._initialized_axes\n                                 and not ax.get_autoscalex_on()\n                                 and not ax.get_autoscaley_on()):\n            if mpl.is_interactive():\n                import matplotlib.pyplot as plt\n                plt.draw_if_interactive()\n            return\n\n        self._initialized_axes.add(hash(ax))\n        # Take control of axis scaling:\n        ax.set_autoscale_on(False)\n        # update data limits for map domain.\n        corners = ((self.llcrnrx, self.llcrnry), (self.urcrnrx, self.urcrnry))\n        ax.update_datalim(corners)\n        ax.set_xlim((self.llcrnrx, self.urcrnrx))\n        ax.set_ylim((self.llcrnry, self.urcrnry))\n        # if map boundary not yet drawn for elliptical maps, draw it with default values.\n        if not self._mapboundarydrawn or self._mapboundarydrawn not in ax.patches:\n            # elliptical map, draw boundary manually.\n            if ((self.projection in ['ortho', 'geos', 'nsper', 'aeqd'] and\n                    self._fulldisk) or self.round or\n                    self.projection in _pseudocyl):\n                # first draw boundary, no fill\n                limb1 = self.drawmapboundary(fill_color='none', ax=ax)\n                # draw another filled patch, with no boundary.\n                limb2 = self.drawmapboundary(linewidth=0, ax=ax)\n                self._mapboundarydrawn = limb2\n        # for elliptical map, always turn off axis_frame.\n        if ((self.projection in ['ortho', 'geos', 'nsper', 'aeqd'] and\n                self._fulldisk) or self.round or\n                self.projection in _pseudocyl):\n            # turn off axes frame.\n            ax.set_frame_on(False)\n        # make sure aspect ratio of map preserved.\n        # plot is re-centered in bounding rectangle.\n        # (anchor instance var determines where plot is placed)\n        if self.fix_aspect:\n            ax.set_aspect('equal',anchor=self.anchor)\n        else:\n            ax.set_aspect('auto',anchor=self.anchor)\n        # make sure axis ticks are turned off.\n        if self.noticks:\n            ax.set_xticks([])\n            ax.set_yticks([])\n        # force draw if in interactive mode.\n        if mpl.is_interactive():\n            import matplotlib.pyplot as plt\n            plt.draw_if_interactive()\n\n    def _save_use_hold(self, ax, kwargs):\n        h = kwargs.pop('hold', None)\n        if hasattr(ax, '_hold'):\n            self._tmp_hold = ax._hold\n            if h is not None:\n                ax._hold = h\n\n    def _restore_hold(self, ax):\n        if hasattr(ax, '_hold'):\n            ax._hold = self._tmp_hold\n\n    @_transform1d\n    def scatter(self, *args, **kwargs):\n        \"\"\"\n        Plot points with markers on the map\n        (see matplotlib.pyplot.scatter documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axes instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.scatter.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.scatter(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret\n\n    @_transform1d\n    def plot(self, *args, **kwargs):\n        \"\"\"\n        Draw lines and/or markers on the map\n        (see matplotlib.pyplot.plot documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.plot.\n        \"\"\"\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.plot(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret\n\n    def imshow(self, *args, **kwargs):\n        \"\"\"\n        Display an image over the map\n        (see matplotlib.pyplot.imshow documentation).\n\n        ``extent`` and ``origin`` keywords set automatically so image\n        will be drawn over map region.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.plot.\n\n        returns an matplotlib.image.AxesImage instance.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        kwargs['extent']=(self.llcrnrx,self.urcrnrx,self.llcrnry,self.urcrnry)\n        # use origin='lower', unless overridden.\n        if 'origin' not in kwargs:\n            kwargs['origin']='lower'\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.imshow(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip image to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret\n\n    @_transform\n    def pcolor(self,x,y,data,**kwargs):\n        \"\"\"\n        Make a pseudo-color plot over the map\n        (see matplotlib.pyplot.pcolor documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        If x or y are outside projection limb (i.e. they have values > 1.e20)\n        they will be convert to masked arrays with those values masked.\n        As a result, those values will not be plotted.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tripcolor is used.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.pcolor (or tripcolor if\n        ``tri=True``).\n\n        Note: (taken from matplotlib.pyplot.pcolor documentation)\n        Ideally the dimensions of x and y should be one greater than those of data;\n        if the dimensions are the same, then the last row and column of data will be ignored.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.pop('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<1.e20,y<1.e20)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    ret = ax.tripcolor(triang,data,**kwargs)\n                else:\n                    ret = ax.tripcolor(x,y,data,**kwargs)\n            else:\n                # make x,y masked arrays\n                # (masked where data is outside of projection limb)\n                x = ma.masked_values(np.where(x > 1.e20,1.e20,x), 1.e20)\n                y = ma.masked_values(np.where(y > 1.e20,1.e20,y), 1.e20)\n                ret = ax.pcolor(x,y,data,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        if self.round:\n            # for some reason, frame gets turned on.\n            ax.set_frame_on(False)\n        return ret\n\n    @_transform\n    def pcolormesh(self,x,y,data,**kwargs):\n        \"\"\"\n        Make a pseudo-color plot over the map\n        (see matplotlib.pyplot.pcolormesh documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.pcolormesh.\n\n        Note: (taken from matplotlib.pyplot.pcolor documentation)\n        Ideally the dimensions of x and y should be one greater than those of data;\n        if the dimensions are the same, then the last row and column of data will be ignored.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        # fix for invalid grid points\n        if ((np.any(x > 1e20) or np.any(y > 1e20)) and\n            x.ndim == 2 and y.ndim == 2):\n            if x.shape != y.shape:\n                raise ValueError('pcolormesh: x and y need same dimension')\n            nx,ny = x.shape\n            if nx < data.shape[0] or ny < data.shape[1]:\n                raise ValueError('pcolormesh: data dimension needs to be at least that of x and y.')\n            mask = (\n                (x[:-1,:-1] > 1e20) |\n                (x[1:,:-1] > 1e20) |\n                (x[:-1,1:] > 1e20) |\n                (x[1:,1:] > 1e20) |\n                (y[:-1,:-1] > 1e20) |\n                (y[1:,:-1] > 1e20) |\n                (y[:-1,1:] > 1e20) |\n                (y[1:,1:] > 1e20)\n                )\n            # we do not want to overwrite original array\n            data = data[:nx-1,:ny-1].copy()\n            data[mask] = np.nan\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.pcolormesh(x,y,data,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        if self.round:\n            # for some reason, frame gets turned on.\n            ax.set_frame_on(False)\n        return ret\n\n    def hexbin(self,x,y,**kwargs):\n        \"\"\"\n        Make a hexagonal binning plot of x versus y, where x, y are 1-D\n        sequences of the same length, N. If C is None (the default), this is a\n        histogram of the number of occurences of the observations at\n        (x[i],y[i]).\n\n        If C is specified, it specifies values at the coordinate (x[i],y[i]).\n        These values are accumulated for each hexagonal bin and then reduced\n        according to reduce_C_function, which defaults to the numpy mean function\n        (np.mean). (If C is specified, it must also be a 1-D sequence of the\n        same length as x and y.)\n\n        x, y and/or C may be masked arrays, in which case only unmasked points\n        will be plotted.\n\n        (see matplotlib.pyplot.hexbin documentation).\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.hexbin\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            # make x,y masked arrays\n            # (masked where data is outside of projection limb)\n            x = ma.masked_values(np.where(x > 1.e20,1.e20,x), 1.e20)\n            y = ma.masked_values(np.where(y > 1.e20,1.e20,y), 1.e20)\n            ret = ax.hexbin(x,y,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret\n\n    @_transform\n    def contour(self,x,y,data,*args,**kwargs):\n        \"\"\"\n        Make a contour plot over the map\n        (see matplotlib.pyplot.contour documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tricontour is used.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.contour\n        (or tricontour if ``tri=True``).\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.pop('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<self.xmin,y<self.xmin) +\\\n                       np.logical_or(x>self.xmax,y>self.xmax)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    CS = ax.tricontour(triang,data,*args,**kwargs)\n                else:\n                    CS = ax.tricontour(x,y,data,*args,**kwargs)\n            else:\n                # make sure x is monotonically increasing - if not,\n                # print warning suggesting that the data be shifted in longitude\n                # with the shiftgrid function.\n                # only do this check for global projections.\n                if self.projection in _cylproj + _pseudocyl:\n                    xx = x[x.shape[0]//2,:]\n                    condition = (xx >= self.xmin) & (xx <= self.xmax)\n                    xl = xx.compress(condition).tolist()\n                    xs = xl[:]\n                    xs.sort()\n                    if xl != xs:\n                        sys.stdout.write(\" \".join([\n                            \"WARNING: x coordinate not montonically increasing\",\n                            \"- contour plot may not be what you expect. If it\",\n                            \"looks odd, you can either adjust the map projection\",\n                            \"region to be consistent with your data, or (if your\",\n                            \"data is on a global lat/lon grid) use the shiftdata\",\n                            \"method to adjust the data to be consistent with the\",\n                            \"map projection region (see examples/shiftdata.py)\"]))\n                # mask for points more than one grid length outside projection limb.\n                xx = ma.masked_where(x > 1.e20, x)\n                yy = ma.masked_where(y > 1.e20, y)\n                epsx = np.abs(xx[:,1:]-xx[:,0:-1]).max()\n                epsy = np.abs(yy[1:,:]-yy[0:-1,:]).max()\n                xymask = \\\n                np.logical_or(np.greater(x,self.xmax+epsx),np.greater(y,self.ymax+epsy))\n                xymask = xymask + \\\n                np.logical_or(np.less(x,self.xmin-epsx),np.less(y,self.ymin-epsy))\n                data = ma.asarray(data)\n                # combine with data mask.\n                mask = np.logical_or(ma.getmaskarray(data),xymask)\n                data = ma.masked_array(data,mask=mask)\n                CS = ax.contour(x,y,data,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt and CS.get_array() is not None:\n            plt.sci(CS)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS\n\n    @_transform\n    def contourf(self,x,y,data,*args,**kwargs):\n        \"\"\"\n        Make a filled contour plot over the map\n        (see matplotlib.pyplot.contourf documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        If x or y are outside projection limb (i.e. they have values > 1.e20),\n        the corresponing data elements will be masked.\n\n        Extra keyword 'ax' can be used to override the default axis instance.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tricontourf is used.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.contourf\n        (or tricontourf if ``tri=True``).\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.get('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<1.e20,y<1.e20)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    CS = ax.tricontourf(triang,data,*args,**kwargs)\n                else:\n                    CS = ax.tricontourf(x,y,data,*args,**kwargs)\n            else:\n                # make sure x is monotonically increasing - if not,\n                # print warning suggesting that the data be shifted in longitude\n                # with the shiftgrid function.\n                # only do this check for global projections.\n                if self.projection in _cylproj + _pseudocyl:\n                    xx = x[x.shape[0]//2,:]\n                    condition = (xx >= self.xmin) & (xx <= self.xmax)\n                    xl = xx.compress(condition).tolist()\n                    xs = xl[:]\n                    xs.sort()\n                    if xl != xs:\n                        sys.stdout.write(\" \".join([\n                            \"WARNING: x coordinate not montonically increasing\",\n                            \"- contour plot may not be what you expect. If it\",\n                            \"looks odd, you can either adjust the map projection\",\n                            \"region to be consistent with your data, or (if your\",\n                            \"data is on a global lat/lon grid) use the shiftgrid\",\n                            \"function to adjust the data to be consistent with the\",\n                            \"map projection region (see examples/contour_demo.py)\"]))\n                # mask for points more than one grid length outside projection limb.\n                xx = ma.masked_where(x > 1.e20, x)\n                yy = ma.masked_where(y > 1.e20, y)\n                if self.projection != 'omerc':\n                    epsx = np.abs(xx[:,1:]-xx[:,0:-1]).max()\n                    epsy = np.abs(yy[1:,:]-yy[0:-1,:]).max()\n                else: # doesn't work for omerc (FIXME)\n                    epsx = 0.; epsy = 0\n                xymask = \\\n                np.logical_or(np.greater(x,self.xmax+epsx),np.greater(y,self.ymax+epsy))\n                xymask = xymask + \\\n                np.logical_or(np.less(x,self.xmin-epsx),np.less(y,self.ymin-epsy))\n                data = ma.asarray(data)\n                # combine with data mask.\n                mask = np.logical_or(ma.getmaskarray(data),xymask)\n                data = ma.masked_array(data,mask=mask)\n                CS = ax.contourf(x,y,data,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt and CS.get_array() is not None:\n            plt.sci(CS)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS\n\n    @_transformuv\n    def quiver(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Make a vector plot (u, v) with arrows on the map.\n\n        Arguments may be 1-D or 2-D arrays or sequences\n        (see matplotlib.pyplot.quiver documentation for details).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.quiver.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.quiver(x,y,u,v,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        if plt is not None and ret.get_array() is not None:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret\n\n    @_transformuv\n    def streamplot(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Draws streamlines of a vector flow.\n        (see matplotlib.pyplot.streamplot documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.streamplot.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.streamplot(x,y,u,v,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        if plt is not None and ret.lines.get_array() is not None:\n            plt.sci(ret.lines)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret.lines,c = self._cliplimb(ax,ret.lines)\n        ret.arrows,c = self._cliplimb(ax,ret.arrows)\n        # streamplot arrows not returned in matplotlib 1.1.1, so clip all\n        # FancyArrow patches attached to axes instance.\n        if c is not None:\n            for p in ax.patches:\n                if isinstance(p,FancyArrowPatch): p.set_clip_path(c)\n        return ret\n\n    @_transformuv\n    def barbs(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Make a wind barb plot (u, v) with on the map.\n        (see matplotlib.pyplot.barbs documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.barbs\n\n        Returns two matplotlib.axes.Barbs instances, one for the Northern\n        Hemisphere and one for the Southern Hemisphere.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        lons, lats = self(x, y, inverse=True)\n        unh = ma.masked_where(lats <= 0, u)\n        vnh = ma.masked_where(lats <= 0, v)\n        ush = ma.masked_where(lats > 0, u)\n        vsh = ma.masked_where(lats > 0, v)\n        self._save_use_hold(ax, kwargs)\n        try:\n            retnh =  ax.barbs(x,y,unh,vnh,*args,**kwargs)\n            kwargs['flip_barb']=True\n            retsh =  ax.barbs(x,y,ush,vsh,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # Because there are two collections returned in general,\n        # we can't set the current image...\n        #if plt is not None and ret.get_array() is not None:\n        #    plt.sci(retnh)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        retnh,c = self._cliplimb(ax,retnh)\n        retsh,c = self._cliplimb(ax,retsh)\n\n        return retnh,retsh\n\n    def drawlsmask(self,land_color=\"0.8\",ocean_color=\"w\",lsmask=None,\n                   lsmask_lons=None,lsmask_lats=None,lakes=True,resolution='l',grid=5,**kwargs):\n        \"\"\"\n        Draw land-sea mask image.\n\n        .. note::\n         The land-sea mask image cannot be overlaid on top\n         of other images, due to limitations in matplotlib image handling\n         (you can't specify the zorder of an image).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        land_color       desired land color (color name or rgba tuple).\n                         Default gray (\"0.8\").\n        ocean_color      desired water color (color name or rgba tuple).\n                         Default white.\n        lsmask           An array of 0's for ocean pixels, 1's for\n                         land pixels and 2's for lake/pond pixels.\n                         Default is None\n                         (default 5-minute resolution land-sea mask is used).\n        lakes            Plot lakes and ponds (Default True)\n        lsmask_lons      1d array of longitudes for lsmask (ignored\n                         if lsmask is None). Longitudes must be ordered\n                         from -180 W eastward.\n        lsmask_lats      1d array of latitudes for lsmask (ignored\n                         if lsmask is None). Latitudes must be ordered\n                         from -90 S northward.\n        resolution       gshhs coastline resolution used to define land/sea\n                         mask (default 'l', available 'c','l','i','h' or 'f')\n        grid             land/sea mask grid spacing in minutes (Default 5;\n                         10, 2.5 and 1.25 are also available).\n        \\**kwargs        extra keyword arguments passed on to\n                         :meth:`imshow`\n        ==============   ====================================================\n\n        If any of the lsmask, lsmask_lons or lsmask_lats keywords are not\n        set, the built in GSHHS land-sea mask datasets are used.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        # convert land and water colors to integer rgba tuples with\n        # values between 0 and 255.\n        from matplotlib.colors import ColorConverter\n        c = ColorConverter()\n        # if conversion fails, assume it's because the color\n        # given is already an rgba tuple with values between 0 and 255.\n        try:\n            cl = c.to_rgba(land_color)\n            rgba_land = tuple([int(255*x) for x in cl])\n        except:\n            rgba_land = land_color\n        try:\n            co = c.to_rgba(ocean_color)\n            rgba_ocean = tuple([int(255*x) for x in co])\n        except:\n            rgba_ocean = ocean_color\n        # look for axes instance (as keyword, an instance variable\n        # or from plt.gca().\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # Clear saved lsmask if new lsmask is passed\n        if lsmask is not None or lsmask_lons is not None \\\n                or lsmask_lats is not None:\n            # Make sure passed lsmask is not the same as cached mask\n            if lsmask is not self.lsmask:\n                self.lsmask = None\n        # if lsmask,lsmask_lons,lsmask_lats keywords not given,\n        # read default land-sea mask in from file.\n        if lsmask is None or lsmask_lons is None or lsmask_lats is None:\n            # if lsmask instance variable already set, data already\n            # read in.\n            if self.lsmask is None:\n                # read in land/sea mask.\n                lsmask_lons, lsmask_lats, lsmask =\\\n                _readlsmask(lakes=lakes,resolution=resolution,grid=grid)\n                # instance variable lsmask is set on first invocation,\n                # it contains the land-sea mask interpolated to the native\n                # projection grid.  Further calls to drawlsmask will not\n                # redo the interpolation (unless a new land-sea mask is passed\n                # in via the lsmask, lsmask_lons, lsmask_lats keywords).\n\n                # is it a cylindrical projection whose limits lie\n                # outside the limits of the image?\n                cylproj =  self.projection in _cylproj and \\\n                          (self.urcrnrlon > lsmask_lons[-1] or \\\n                           self.llcrnrlon < lsmask_lons[0])\n                if cylproj:\n                    # stack grids side-by-side (in longitiudinal direction), so\n                    # any range of longitudes may be plotted on a world map.\n                    # in versions of NumPy later than 1.10.0, concatenate will\n                    # not stack these arrays as expected. If axis 1 is outside\n                    # the dimensions of the array, concatenate will now raise\n                    # an IndexError. Using hstack instead.\n                    lsmask_lons = \\\n                            np.hstack((lsmask_lons,lsmask_lons[1:] + 360))\n                    lsmask = \\\n                            np.hstack((lsmask,lsmask[:,1:]))\n        else:\n            if lakes: lsmask = np.where(lsmask==2,np.array(0,np.uint8),lsmask)\n\n        # transform mask to nx x ny regularly spaced native projection grid\n        # nx and ny chosen to have roughly the same horizontal\n        # resolution as mask.\n        if self.lsmask is None:\n            nlons = len(lsmask_lons)\n            nlats = len(lsmask_lats)\n            if self.projection == 'cyl':\n                dx = lsmask_lons[1]-lsmask_lons[0]\n            else:\n                dx = (np.pi/180.)*(lsmask_lons[1]-lsmask_lons[0])*self.rmajor\n            nx = int((self.xmax-self.xmin)/dx)+1; ny = int((self.ymax-self.ymin)/dx)+1\n        # interpolate rgba values from proj='cyl' (geographic coords)\n        # to a rectangular map projection grid.\n            mask,x,y = self.transform_scalar(lsmask,lsmask_lons,\\\n                       lsmask_lats,nx,ny,returnxy=True,order=0,masked=255)\n            lsmask_lats.dtype\n            # for these projections, points outside the projection\n            # limb have to be set to transparent manually.\n            if self.projection in _pseudocyl:\n                lons, lats = self(x, y, inverse=True)\n                lon_0 = self.projparams['lon_0']\n                lats = lats[:,nx//2]\n                lons1 = (lon_0+180.)*np.ones(lons.shape[0],np.float64)\n                lons2 = (lon_0-180.)*np.ones(lons.shape[0],np.float64)\n                xmax,ytmp = self(lons1,lats)\n                xmin,ytmp = self(lons2,lats)\n                for j in range(lats.shape[0]):\n                    xx = x[j,:]\n                    mask[j,:]=np.where(np.logical_or(xx<xmin[j],xx>xmax[j]),\\\n                                        255,mask[j,:])\n            self.lsmask = mask\n        ny, nx = self.lsmask.shape\n        rgba = np.ones((ny,nx,4),np.uint8)\n        rgba_land = np.array(rgba_land,np.uint8)\n        rgba_ocean = np.array(rgba_ocean,np.uint8)\n        for k in range(4):\n            rgba[:,:,k] = np.where(self.lsmask,rgba_land[k],rgba_ocean[k])\n        # make points outside projection limb transparent.\n        rgba[:,:,3] = np.where(self.lsmask==255,0,rgba[:,:,3])\n        # plot mask as rgba image.\n        im = self.imshow(rgba,interpolation='nearest',ax=ax,**kwargs)\n        # clip to map limbs.\n        im,c = self._cliplimb(ax,im)\n        return im\n\n    def bluemarble(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display blue marble image (from http://visibleearth.nasa.gov)\n        as map background.\n        Default image size is 5400x2700, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 2700x1350).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='bluemarble',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='bluemarble',scale=scale,**kwargs)\n\n    def shadedrelief(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display shaded relief image (from http://www.shadedrelief.com)\n        as map background.\n        Default image size is 10800x5400, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 5400x2700).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='shadedrelief',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='shadedrelief',scale=scale,**kwargs)\n\n    def etopo(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display etopo relief image (from\n        http://www.ngdc.noaa.gov/mgg/global/global.html)\n        as map background.\n        Default image size is 5400x2700, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 5400x2700).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='etopo',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='etopo',scale=scale,**kwargs)\n\n    def warpimage(self,image=\"bluemarble\",scale=None,**kwargs):\n        \"\"\"\n        Display an image (filename given by ``image`` keyword) as a map background.\n        If image is a URL (starts with 'http'), it is downloaded to a temp\n        file using urllib.urlretrieve.\n\n        Default (if ``image`` not specified) is to display\n        'blue marble next generation' image from http://visibleearth.nasa.gov/.\n\n        Specified image must have pixels covering the whole globe in a regular\n        lat/lon grid, starting and -180W and the South Pole.\n        Works with the global images from\n        http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php.\n\n        The ``scale`` keyword can be used to downsample (rescale) the image.\n        Values less than 1.0 will speed things up at the expense of image\n        resolution.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n\n        # fix PIL import on some versions of OSX and scipy\n        try:\n            from PIL import Image\n        except ImportError:\n            try:\n                import Image\n            except ImportError:\n                raise ImportError(\"warpimage method requires PIL \"\n                                  \"(http://pillow.readthedocs.io)\")\n\n        from matplotlib.image import pil_to_array\n        if self.celestial:\n            raise ValueError(\"warpimage does not work in celestial coordinates\")\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # default image file is blue marble next generation\n        # from NASA (http://visibleearth.nasa.gov).\n        if image == \"bluemarble\":\n            file = os.path.join(basemap_datadir,'bmng.jpg')\n        # display shaded relief image (from\n        # http://www.shadedreliefdata.com)\n        elif image == \"shadedrelief\":\n            file = os.path.join(basemap_datadir,'shadedrelief.jpg')\n        # display etopo image (from\n        # http://www.ngdc.noaa.gov/mgg/image/globalimages.html)\n        elif image == \"etopo\":\n            file = os.path.join(basemap_datadir,'etopo1.jpg')\n        else:\n            file = image\n        # if image is same as previous invocation, used cached data.\n        # if not, regenerate rgba data.\n        if not hasattr(self,'_bm_file') or self._bm_file != file:\n            newfile = True\n        else:\n            newfile = False\n        if file.startswith('http'):\n            self._bm_file, headers = urlretrieve(file)\n        else:\n            self._bm_file = file\n        # bmproj is True if map projection region is same as\n        # image region.\n        bmproj = self.projection == 'cyl' and \\\n                 self.llcrnrlon == -180 and self.urcrnrlon == 180 and \\\n                 self.llcrnrlat == -90 and self.urcrnrlat == 90\n        # read in jpeg image to rgba array of normalized floats.\n        if not hasattr(self,'_bm_rgba') or newfile:\n            pilImage = Image.open(self._bm_file)\n            if scale is not None:\n                w, h = pilImage.size\n                width = int(np.round(w*scale))\n                height = int(np.round(h*scale))\n                pilImage = pilImage.resize((width,height),Image.LANCZOS)\n            # orientation of arrays returned by pil_to_array changed in\n            # matplotlib 1.2 (https://github.com/matplotlib/matplotlib/pull/616)\n            self._bm_rgba = pil_to_array(pilImage)[::-1,:]\n            # define lat/lon grid that image spans.\n            nlons = self._bm_rgba.shape[1]; nlats = self._bm_rgba.shape[0]\n            delta = 360./float(nlons)\n            self._bm_lons = np.arange(-180.+0.5*delta,180.,delta)\n            self._bm_lats = np.arange(-90.+0.5*delta,90.,delta)\n            # is it a cylindrical projection whose limits lie\n            # outside the limits of the image?\n            cylproj =  self.projection in _cylproj and \\\n                      (self.urcrnrlon > self._bm_lons[-1] or \\\n                       self.llcrnrlon < self._bm_lons[0])\n            # if pil_to_array returns a 2D array, it's a grayscale image.\n            # create an RGB image, with R==G==B.\n            if self._bm_rgba.ndim == 2:\n                tmp = np.empty(self._bm_rgba.shape+(3,),np.uint8)\n                for k in range(3):\n                    tmp[:,:,k] = self._bm_rgba\n                self._bm_rgba = tmp\n            if cylproj and not bmproj:\n                # stack grids side-by-side (in longitiudinal direction), so\n                # any range of longitudes may be plotted on a world map.\n                self._bm_lons = \\\n                np.concatenate((self._bm_lons,self._bm_lons+360),0)\n                self._bm_rgba = \\\n                np.concatenate((self._bm_rgba,self._bm_rgba),1)\n            # convert to normalized floats.\n            self._bm_rgba = self._bm_rgba.astype(np.float32)/255.\n        if not bmproj: # interpolation necessary.\n            if newfile or not hasattr(self,'_bm_rgba_warped'):\n                # transform to nx x ny regularly spaced native\n                # projection grid.\n                # nx and ny chosen to have roughly the\n                # same horizontal res as original image.\n                if self.projection != 'cyl':\n                    dx = 2.*np.pi*self.rmajor/float(nlons)\n                    nx = int((self.xmax-self.xmin)/dx)+1\n                    ny = int((self.ymax-self.ymin)/dx)+1\n                else:\n                    dx = 360./float(nlons)\n                    nx = int((self.urcrnrlon-self.llcrnrlon)/dx)+1\n                    ny = int((self.urcrnrlat-self.llcrnrlat)/dx)+1\n                self._bm_rgba_warped = np.ones((ny,nx,4),np.float64)\n                # interpolate rgba values from geographic coords (proj='cyl')\n                # to map projection coords.\n                # if masked=True, values outside of\n                # projection limb will be masked.\n                for k in range(self._bm_rgba.shape[2]):\n                    self._bm_rgba_warped[:,:,k],x,y = \\\n                    self.transform_scalar(self._bm_rgba[:,:,k],\\\n                    self._bm_lons,self._bm_lats,nx,ny,returnxy=True)\n                # for ortho,geos mask pixels outside projection limb.\n                if self.projection in ['geos','ortho','nsper'] or \\\n                   (self.projection == 'aeqd' and self._fulldisk):\n                    lonsr,latsr = self(x,y,inverse=True)\n                    mask = ma.zeros((ny,nx,4),np.int8)\n                    mask[:,:,0] = np.logical_or(lonsr>1.e20,latsr>1.e30)\n                    for k in range(1,4):\n                        mask[:,:,k] = mask[:,:,0]\n                    self._bm_rgba_warped = \\\n                    ma.masked_array(self._bm_rgba_warped,mask=mask)\n                    # make points outside projection limb transparent.\n                    self._bm_rgba_warped = self._bm_rgba_warped.filled(0.)\n                # treat pseudo-cyl projections such as mollweide, robinson and sinusoidal.\n                elif self.projection in _pseudocyl and \\\n                     self.projection != 'hammer':\n                    lonsr,latsr = self(x,y,inverse=True)\n                    mask = ma.zeros((ny,nx,4),np.int8)\n                    lon_0 = self.projparams['lon_0']\n                    lonright = lon_0+180.\n                    lonleft = lon_0-180.\n                    x1 = np.array(ny*[0.5*(self.xmax + self.xmin)],np.float)\n                    y1 = np.linspace(self.ymin, self.ymax, ny)\n                    lons1, lats1 = self(x1,y1,inverse=True)\n                    lats1 = np.where(lats1 < -89.999999, -89.999999, lats1)\n                    lats1 = np.where(lats1 > 89.999999, 89.999999, lats1)\n                    for j,lat in enumerate(lats1):\n                        xmax,ymax = self(lonright,lat)\n                        xmin,ymin = self(lonleft,lat)\n                        mask[j,:,0] = np.logical_or(x[j,:]>xmax,x[j,:]<xmin)\n                    for k in range(1,4):\n                        mask[:,:,k] = mask[:,:,0]\n                    self._bm_rgba_warped = \\\n                    ma.masked_array(self._bm_rgba_warped,mask=mask)\n                    # make points outside projection limb transparent.\n                    # FIXME: Probably not needed anymore\n                    self._bm_rgba_warped = self._bm_rgba_warped.filled(0.)\n            # plot warped rgba image.\n            im = self.imshow(self._bm_rgba_warped,ax=ax,**kwargs)\n            # for hammer projection, use clip path defined by\n            # projection limb (patch created in drawmapboundary).\n            # FIXME: Is this now redundant?\n            if self.projection == 'hammer':\n                if not self._mapboundarydrawn:\n                    self.drawmapboundary(color='none',linewidth=None)\n                im.set_clip_path(self._mapboundarydrawn)\n        else:\n            # bmproj True, no interpolation necessary.\n            im = self.imshow(self._bm_rgba,ax=ax,**kwargs)\n        # clip to map limbs\n        im,c = self._cliplimb(ax,im)\n        return im\n\n    def arcgisimage(self,server='http://server.arcgisonline.com/ArcGIS',\\\n                 service='World_Imagery',xpixels=400,ypixels=None,\\\n                 dpi=96,cachedir=None,verbose=False,**kwargs):\n        \"\"\"\n        Retrieve an image using the ArcGIS Server REST API and display it on\n        the map. In order to use this method, the Basemap instance must be\n        created using the ``epsg`` keyword to define the map projection, unless\n        the ``cyl`` projection is used (in which case the epsg code 4326 is\n        assumed).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        server           web map server URL (default\n                         http://server.arcgisonline.com/ArcGIS).\n        service          service (image type) hosted on server (default\n                         'World_Imagery', which is NASA 'Blue Marble'\n                         image).\n        xpixels          requested number of image pixels in x-direction\n                         (default 400).\n        ypixels          requested number of image pixels in y-direction.\n                         Default (None) is to infer the number from\n                         from xpixels and the aspect ratio of the\n                         map projection region.\n        dpi              The device resolution of the exported image (dots per\n                         inch, default 96).\n        cachedir         An optional directory to use as cache folder for the retrieved images.\n        verbose          if True, print URL used to retrieve image (default\n                         False).\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n\n        # fix PIL import on some versions of OSX and scipy\n        try:\n            from PIL import Image\n        except ImportError:\n            try:\n                import Image\n            except ImportError:\n                raise ImportError(\"arcgisimage method requires PIL \"\n                                  \"(http://pillow.readthedocs.io)\")\n\n        if not hasattr(self,'epsg'):\n            raise ValueError(\"the Basemap instance must be created using \"\n                             \"an EPSG code (http://spatialreference.org) \"\n                             \"in order to use the wmsmap method\")\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # find the x,y values at the corner points.\n        p = pyproj.Proj(init=\"epsg:%s\" % self.epsg, preserve_units=True)\n        xmin,ymin = p(self.llcrnrlon,self.llcrnrlat)\n        xmax,ymax = p(self.urcrnrlon,self.urcrnrlat)\n        if self.projection in _cylproj:\n            Dateline =\\\n            _geoslib.Point(self(180.,0.5*(self.llcrnrlat+self.urcrnrlat)))\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            if hasDateline:\n                raise ValueError(\"arcgisimage cannot handle images that cross \"\n                                 \"the dateline for cylindrical projections\")\n        # ypixels not given, find by scaling xpixels by the map aspect ratio.\n        if ypixels is None:\n            ypixels = int(self.aspect*xpixels)\n        # construct a URL using the ArcGIS Server REST API.\n        basemap_url = \\\n\"%s/rest/services/%s/MapServer/export?\\\nbbox=%s,%s,%s,%s&\\\nbboxSR=%s&\\\nimageSR=%s&\\\nsize=%s,%s&\\\ndpi=%s&\\\nformat=png32&\\\ntransparent=true&\\\nf=image\" %\\\n(server,service,xmin,ymin,xmax,ymax,self.epsg,self.epsg,xpixels,ypixels,dpi)\n        # print URL?\n        if verbose: print(basemap_url)\n\n        if cachedir != None:\n            # Generate a filename for the cached file.\n            filename = \"%s-bbox-%s-%s-%s-%s-bboxsr%s-imagesr%s-size-%s-%s-dpi%s.png\" %\\\n            (service,xmin,ymin,xmax,ymax,self.epsg,self.epsg,xpixels,ypixels,dpi)\n\n             # Check if the cache directory exists, if not create it.\n            if not os.path.exists(cachedir):\n                os.makedirs(cachedir)\n\n            # Check if the image is already in the cachedir folder.\n            cache_path = cachedir + filename\n\n            if os.path.isfile(cache_path):\n                print('Image already in cache')\n                img = Image.open(cache_path)\n                return basemap.imshow(img, ax=ax, origin='upper')\n            else:\n                # Retrieve and save image\n                img = Image.open(urlopen(basemap_url))\n                img.save(cache_path)\n        else:\n            img = Image.open(urlopen(basemap_url))\n\n        # return AxesImage instance.\n        return self.imshow(img, ax=ax, origin='upper')\n\n    def wmsimage(self,server,\\\n                 xpixels=400,ypixels=None,\\\n                 format='png',alpha=None,verbose=False,**kwargs):\n        \"\"\"\n        Retrieve an image using from a WMS server using the\n        Open Geospatial Consortium (OGC) standard interface\n        and display on the map. Requires OWSLib\n        (http://pypi.python.org/pypi/OWSLib).\n        In order to use this method, the Basemap instance must be\n        created using the ``epsg`` keyword to define the map projection, unless\n        the ``cyl`` projection is used (in which case the epsg code 4326 is\n        assumed).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        server           WMS server URL.\n        xpixels          requested number of image pixels in x-direction\n                         (default 400).\n        ypixels          requested number of image pixels in y-direction.\n                         Default (None) is to infer the number from\n                         from xpixels and the aspect ratio of the\n                         map projection region.\n        format           desired image format (default 'png')\n        alpha            The alpha blending value,\n                         between 0 (transparent) and 1 (opaque) (default None)\n        verbose          if True, print WMS server info (default\n                         False).\n        \\**kwargs        extra keyword arguments passed on to\n                         OWSLib.wms.WebMapService.getmap.\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError('OWSLib required to use wmsimage method')\n        import io\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        if not hasattr(self,'epsg'):\n            raise ValueError(\"the Basemap instance must be created using \"\n                             \"an EPSG code (http://spatialreference.org) \"\n                             \"in order to use the wmsmap method\")\n        if 'layers' not in kwargs:\n            raise ValueError('no layers specified')\n        # find the x,y values at the corner points.\n        p = pyproj.Proj(init=\"epsg:%s\" % self.epsg, preserve_units=True)\n        xmin,ymin = p(self.llcrnrlon,self.llcrnrlat)\n        xmax,ymax = p(self.urcrnrlon,self.urcrnrlat)\n        if self.projection in _cylproj:\n            Dateline =\\\n            _geoslib.Point(self(180.,0.5*(self.llcrnrlat+self.urcrnrlat)))\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            if hasDateline:\n                raise ValueError(\"wmsimage cannot handle images that cross \"\n                                 \"the dateline for cylindrical projections\")\n        if self.projection == 'cyl':\n            xmin = (180./np.pi)*xmin; xmax = (180./np.pi)*xmax\n            ymin = (180./np.pi)*ymin; ymax = (180./np.pi)*ymax\n        # ypixels not given, find by scaling xpixels by the map aspect ratio.\n        if ypixels is None:\n            ypixels = int(self.aspect*xpixels)\n        if verbose: print(server)\n        wms = WebMapService(server)\n        if verbose:\n            print('id: %s, version: %s' %\n            (wms.identification.type,wms.identification.version))\n            print('title: %s, abstract: %s' %\n            (wms.identification.title,wms.identification.abstract))\n            print('available layers:')\n            print(list(wms.contents))\n            print('projection options:')\n            print(wms[kwargs['layers'][0]].crsOptions)\n        # remove keys from kwargs that are over-ridden\n        for k in ['format','bbox','service','size','srs']:\n            if 'format' in kwargs: del kwargs['format']\n        img = wms.getmap(service='wms',bbox=(xmin,ymin,xmax,ymax),\n                         size=(xpixels,ypixels),format='image/%s'%format,\n                         srs='EPSG:%s' % self.epsg, **kwargs)\n        # return AxesImage instance.\n        # this works for png and jpeg.\n        return self.imshow(imread(io.BytesIO(img.read()),\n                           format=format),origin='upper',alpha=alpha,ax=ax)\n\n    def drawmapscale(self,lon,lat,lon0,lat0,length,barstyle='simple',\\\n                     units='km',fontsize=9,yoffset=None,labelstyle='simple',\\\n                     fontcolor='k',fillcolor1='w',fillcolor2='k',ax=None,\\\n                     format='%d',zorder=None,linecolor=None,linewidth=None):\n        \"\"\"\n        Draw a map scale at ``lon,lat`` of length ``length``\n        representing distance in the map\n        projection coordinates at ``lon0,lat0``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        units            the units of the length argument (Default km).\n        barstyle         ``simple`` or ``fancy`` (roughly corresponding\n                         to the styles provided by Generic Mapping Tools).\n                         Default ``simple``.\n        fontsize         for map scale annotations, default 9.\n        fontcolor            for map scale annotations, default black.\n        labelstyle       ``simple`` (default) or ``fancy``.  For\n                         ``fancy`` the map scale factor (ratio betwee\n                         the actual distance and map projection distance\n                         at lon0,lat0) and the value of lon0,lat0 are also\n                         displayed on the top of the scale bar. For\n                         ``simple``, just the units are display on top\n                         and the distance below the scale bar.\n                         If equal to False, plot an empty label.\n        format           a string formatter to format numeric values\n        yoffset          yoffset controls how tall the scale bar is,\n                         and how far the annotations are offset from the\n                         scale bar.  Default is 0.02 times the height of\n                         the map (0.02*(self.ymax-self.ymin)).\n        fillcolor1(2)    colors of the alternating filled regions\n                         (default white and black).  Only relevant for\n                         'fancy' barstyle.\n        zorder           sets the zorder for the map scale.\n        linecolor        sets the color of the scale, by default, fontcolor\n                         is used\n        linewidth        linewidth for scale and ticks\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # not valid for cylindrical projection\n        if self.projection == 'cyl':\n            raise ValueError(\"cannot draw map scale for projection='cyl'\")\n        # convert length to meters\n        lenlab = length\n        if units == 'km':\n            length = length*1000\n        elif units == 'mi':\n            length = length*1609.344\n        elif units == 'nmi':\n            length = length*1852\n        elif units == 'ft':\n            length = length*0.3048\n        elif units != 'm':\n            raise KeyError(\"units must be 'm' (meters), 'km' (kilometers), \"\n                           \"'mi' (miles), 'nmi' (nautical miles), or 'ft' (feet)\")\n        # reference point and center of scale.\n        x0,y0 = self(lon0,lat0)\n        xc,yc = self(lon,lat)\n        # make sure lon_0 between -180 and 180\n        lon_0 = ((lon0+360) % 360) - 360\n        if lat0>0:\n            if lon>0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}N, %g\\N{DEGREE SIGN}E' % (lat0,lon_0)\n            elif lon<0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}N, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n            else:\n                lonlatstr = u'%g\\N{DEGREE SIGN}, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n        else:\n            if lon>0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}E' % (lat0,lon_0)\n            elif lon<0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n            else:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}' % (lat0,lon_0)\n        # left edge of scale\n        lon1,lat1 = self(x0-length/2,y0,inverse=True)\n        x1,y1 = self(lon1,lat1)\n        # right edge of scale\n        lon4,lat4 = self(x0+length/2,y0,inverse=True)\n        x4,y4 = self(lon4,lat4)\n        x1 = x1-x0+xc; y1 = y1-y0+yc\n        x4 = x4-x0+xc; y4 = y4-y0+yc\n        if x1 > 1.e20 or x4 > 1.e20 or y1 > 1.e20 or y4 > 1.e20:\n            raise ValueError(\"scale bar positioned outside projection limb\")\n        # scale factor for true distance\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = gc.inv(lon1,lat1,lon4,lat4)\n        scalefact = dist/length\n        # label to put on top of scale bar.\n        if labelstyle=='simple':\n            labelstr = units\n        elif labelstyle == 'fancy':\n            labelstr = units+\" (scale factor %4.2f at %s)\"%(scalefact,lonlatstr)\n        elif labelstyle == False:\n            labelstr = ''\n        else:\n            raise KeyError(\"labelstyle must be 'simple' or 'fancy'\")\n        # default y offset is 2 percent of map height.\n        if yoffset is None: yoffset = 0.02*(self.ymax-self.ymin)\n        rets = [] # will hold all plot objects generated.\n        # set linecolor\n        if linecolor is None:\n            linecolor = fontcolor\n        # 'fancy' style\n        if barstyle == 'fancy':\n            #we need 5 sets of x coordinates (in map units)\n            #quarter scale\n            lon2,lat2 = self(x0-length/4,y0,inverse=True)\n            x2,y2 = self(lon2,lat2)\n            x2 = x2-x0+xc; y2 = y2-y0+yc\n            #three quarter scale\n            lon3,lat3 = self(x0+length/4,y0,inverse=True)\n            x3,y3 = self(lon3,lat3)\n            x3 = x3-x0+xc; y3 = y3-y0+yc\n            #plot top line\n            ytop = yc+yoffset/2\n            ybottom = yc-yoffset/2\n            ytick = ybottom - yoffset/2\n            ytext = ytick - yoffset/2\n            rets.append(self.plot([x1,x4],[ytop,ytop],color=linecolor, linewidth=linewidth)[0])\n            #plot bottom line\n            rets.append(self.plot([x1,x4],[ybottom,ybottom],color=linecolor, linewidth=linewidth)[0])\n            #plot left edge\n            rets.append(self.plot([x1,x1],[ybottom,ytop],color=linecolor, linewidth=linewidth)[0])\n            #plot right edge\n            rets.append(self.plot([x4,x4],[ybottom,ytop],color=linecolor, linewidth=linewidth)[0])\n            #make a filled black box from left edge to 1/4 way across\n            rets.append(ax.fill([x1,x2,x2,x1,x1],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor1)[0])\n            #make a filled white box from 1/4 way across to 1/2 way across\n            rets.append(ax.fill([x2,xc,xc,x2,x2],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor2)[0])\n            #make a filled white box from 1/2 way across to 3/4 way across\n            rets.append(ax.fill([xc,x3,x3,xc,xc],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor1)[0])\n            #make a filled white box from 3/4 way across to end\n            rets.append(ax.fill([x3,x4,x4,x3,x3],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor2)[0])\n            #plot 3 tick marks at left edge, center, and right edge\n            rets.append(self.plot([x1,x1],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([xc,xc],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x4,x4],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            #label 3 tick marks\n            rets.append(ax.text(x1,ytext,format % (0),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            rets.append(ax.text(xc,ytext,format % (0.5*lenlab),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            rets.append(ax.text(x4,ytext,format % (lenlab),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            #put units, scale factor on top\n            rets.append(ax.text(xc,ytop+yoffset/2,labelstr,\\\n            horizontalalignment='center',\\\n            verticalalignment='bottom',\\\n            fontsize=fontsize,color=fontcolor))\n        # 'simple' style\n        elif barstyle == 'simple':\n            rets.append(self.plot([x1,x4],[yc,yc],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x1,x1],[yc-yoffset,yc+yoffset],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x4,x4],[yc-yoffset,yc+yoffset],color=linecolor, linewidth=linewidth)[0])\n            rets.append(ax.text(xc,yc-yoffset,format % lenlab,\\\n            verticalalignment='top',horizontalalignment='center',\\\n            fontsize=fontsize,color=fontcolor))\n            #put units, scale factor on top\n            rets.append(ax.text(xc,yc+yoffset,labelstr,\\\n            horizontalalignment='center',\\\n            verticalalignment='bottom',\\\n            fontsize=fontsize,color=fontcolor))\n        else:\n            raise KeyError(\"barstyle must be 'simple' or 'fancy'\")\n        if zorder is not None:\n            for ret in rets:\n                try:\n                    ret.set_zorder(zorder)\n                except:\n                    pass\n        return rets\n\n    def colorbar(self,mappable=None,location='right',size=\"5%\",pad='2%',fig=None,ax=None,**kwargs):\n        \"\"\"\n        Add colorbar to axes associated with a map.\n        The colorbar axes instance is created using the axes_grid toolkit.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        mappable         the Image, ContourSet, etc. to which the colorbar\n                         applies.  Default None, matplotlib.pyplot.gci() is\n                         used to retrieve the current image mappable.\n        location         where to put colorbar ('top','bottom','left','right')\n                         Default 'right'.\n        size             width of colorbar axes (string 'N%', where N is\n                         an integer describing the fractional width of the parent\n                         axes). Default '5%'.\n        pad              Padding between parent axes and colorbar axes in\n                         same units as size. Default '2%'.\n        fig              Figure instance the map axes instance is associated\n                         with. Default None, and matplotlib.pyplot.gcf() is used\n                         to retrieve the current active figure instance.\n        ax               The axes instance which the colorbar will be\n                         associated with.  Default None, searches for self.ax,\n                         and if None uses matplotlib.pyplot.gca().\n        \\**kwargs        extra keyword arguments passed on to\n                         colorbar method of the figure instance.\n        ==============   ====================================================\n\n        Returns a matplotlib colorbar instance.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # get current figure instance (if none specified).\n        if fig is None or mappable is None:\n            import matplotlib.pyplot as plt\n        if fig is None:\n            fig = plt.gcf()\n        # get current mappable if none specified.\n        if mappable is None:\n            mappable = plt.gci()\n        # create colorbar axes uses axes_grid toolkit.\n        divider = make_axes_locatable(ax)\n        if location in ['left','right']:\n            orientation = 'vertical'\n        elif location in ['top','bottom']:\n            orientation = 'horizontal'\n        else:\n            raise ValueError('location must be top,bottom,left or right')\n        cax = divider.append_axes(location, size=size, pad=pad)\n        # create colorbar.\n        cb = fig.colorbar(mappable,orientation=orientation,cax=cax,**kwargs)\n        fig.sca(ax) # reset parent axes as current axes.\n        return cb\n\n    def nightshade(self,date,color=\"k\",delta=0.25,alpha=0.5,ax=None,zorder=2):\n        \"\"\"\n        Shade the regions of the map that are in darkness at the time\n        specifed by ``date``.  ``date`` is a datetime instance,\n        assumed to be UTC.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        color            color to shade night regions (default black).\n        delta            day/night terminator is computed with a\n                         a resolution of ``delta`` degrees (default 0.25).\n        alpha            alpha transparency for shading (default 0.5, so\n                         map background shows through).\n        zorder           zorder for shading (default 2).\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.contour.ContourSet instance.\n        \"\"\"\n        from .solar import daynight_grid\n        # make sure date is UTC, or naive with repect to time zones\n        if date.utcoffset():\n            raise ValueError('datetime instance must be UTC, not {0}'.format(date.tzname()))\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # create grid of day=0, night=1\n        lons,lats,daynight = daynight_grid(date,delta,self.lonmin,self.lonmax)\n        x,y = self(lons,lats)\n        # contour the day-night grid, coloring the night area\n        # with the specified color and transparency.\n        CS = self.contourf(x,y,daynight,1,colors=[color],alpha=alpha,ax=ax)\n        # set zorder on ContourSet collections show night shading\n        # is on top.\n        for c in CS.collections:\n            c.set_zorder(zorder)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS\n\n    def _check_ax(self):\n        \"\"\"\n        Returns the axis on which to draw.\n        Returns self.ax, or if self.ax=None returns plt.gca().\n        \"\"\"\n        if self.ax is None:\n            try:\n                ax = plt.gca()\n            except:\n                import matplotlib.pyplot as plt\n                ax = plt.gca()\n            # associate an axes instance with this Basemap instance\n            # the first time this method is called.\n            #self.ax = ax\n        else:\n            ax = self.ax\n        return ax\n\n    def _ax_plt_from_kw(self, kw):\n        \"\"\"\n        Return (ax, plt), where ax is the current axes, and plt is\n        None or a reference to the pyplot module.\n\n        plt will be None if ax was popped from kw or taken from self.ax;\n        otherwise, pyplot was used and is returned.\n        \"\"\"\n        plt = None\n        _ax = kw.pop('ax', None)\n        if _ax is None:\n            _ax = self.ax\n            if _ax is None:\n                import matplotlib.pyplot as plt\n                _ax = plt.gca()\n        return _ax, plt\n\n    def shiftdata(self,lonsin,datain=None,lon_0=None,fix_wrap_around=True):\n        \"\"\"\n        Shift longitudes (and optionally data) so that they match map projection region.\n        Only valid for cylindrical/pseudo-cylindrical global projections and data\n        on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d\n        it is assumed longitudes are 2nd (rightmost) dimension.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        lonsin           original 1-d or 2-d longitudes.\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        datain           original 1-d or 2-d data. Default None.\n        lon_0            center of map projection region. Defaut None,\n                         given by current map projection.\n        fix_wrap_around  if True reindex (if required) longitudes (and data) to\n                         avoid jumps caused by remapping of longitudes of\n                         points from outside of the [lon_0-180, lon_0+180]\n                         interval back into the interval.\n                         If False do not reindex longitudes and data, but do\n                         make sure that longitudes are in the\n                         [lon_0-180, lon_0+180] range.\n        ==============   ====================================================\n\n        if datain given, returns ``dataout,lonsout`` (data and longitudes shifted to fit in interval\n        [lon_0-180,lon_0+180]), otherwise just returns longitudes.  If\n        transformed longitudes lie outside map projection region, data is\n        masked and longitudes are set to 1.e30.\n        \"\"\"\n        if lon_0 is None and 'lon_0' not in self.projparams:\n            raise ValueError('lon_0 keyword must be provided')\n        lonsin = np.asarray(lonsin)\n        if lonsin.ndim not in [1,2]:\n            raise ValueError('1-d or 2-d longitudes required')\n        if datain is not None:\n            # if it's a masked array, leave it alone.\n            if not ma.isMA(datain): datain = np.asarray(datain)\n            if datain.ndim not in [1,2]:\n                raise ValueError('1-d or 2-d data required')\n        if lon_0 is None:\n            lon_0 = self.projparams['lon_0']\n        # 2-d data.\n        if lonsin.ndim == 2:\n            nlats = lonsin.shape[0]\n            nlons = lonsin.shape[1]\n            lonsin1 = lonsin[0,:]\n            lonsin1 = np.where(lonsin1 > lon_0+180, lonsin1-360 ,lonsin1)\n            lonsin1 = np.where(lonsin1 < lon_0-180, lonsin1+360 ,lonsin1)\n            if nlons > 1:\n                londiff = np.abs(lonsin1[0:-1]-lonsin1[1:])\n                londiff_sort = np.sort(londiff)\n                thresh = 360.-londiff_sort[-2] if nlons > 2 else 360.-londiff_sort[-1]\n                itemindex = nlons-np.where(londiff>=thresh)[0]\n            else:\n                lonsin[0, :] = lonsin1\n                itemindex = 0\n\n            # if no shift necessary, itemindex will be\n            # empty, so don't do anything\n            if fix_wrap_around and itemindex:\n                # check to see if cyclic (wraparound) point included\n                # if so, remove it.\n                if np.abs(lonsin1[0]-lonsin1[-1]) < 1.e-4:\n                    hascyclic = True\n                    lonsin_save = lonsin.copy()\n                    lonsin = lonsin[:,1:]\n                    if datain is not None:\n                       datain_save = datain.copy()\n                       datain = datain[:,1:]\n                else:\n                    hascyclic = False\n                lonsin = np.where(lonsin > lon_0+180, lonsin-360 ,lonsin)\n                lonsin = np.where(lonsin < lon_0-180, lonsin+360 ,lonsin)\n                lonsin = np.roll(lonsin,itemindex-1,axis=1)\n                if datain is not None:\n                    # np.roll works on ndarrays and on masked arrays\n                    datain = np.roll(datain,itemindex-1,axis=1)\n                # add cyclic point back at beginning.\n                if hascyclic:\n                    lonsin_save[:,1:] = lonsin\n                    lonsin_save[:,0] = lonsin[:,-1]-360.\n                    lonsin = lonsin_save\n                    if datain is not None:\n                        datain_save[:,1:] = datain\n                        datain_save[:,0] = datain[:,-1]\n                        datain = datain_save\n\n        # 1-d data.\n        elif lonsin.ndim == 1:\n            nlons = len(lonsin)\n            lonsin = np.where(lonsin > lon_0+180, lonsin-360 ,lonsin)\n            lonsin = np.where(lonsin < lon_0-180, lonsin+360 ,lonsin)\n\n            if nlons > 1:\n                londiff = np.abs(lonsin[0:-1]-lonsin[1:])\n                londiff_sort = np.sort(londiff)\n                thresh = 360.-londiff_sort[-2] if nlons > 2 else 360.0 - londiff_sort[-1]\n                itemindex = len(lonsin)-np.where(londiff>=thresh)[0]\n            else:\n                itemindex = 0\n\n            if fix_wrap_around and itemindex:\n                # check to see if cyclic (wraparound) point included\n                # if so, remove it.\n                if np.abs(lonsin[0]-lonsin[-1]) < 1.e-4:\n                    hascyclic = True\n                    lonsin_save = lonsin.copy()\n                    lonsin = lonsin[1:]\n                    if datain is not None:\n                        datain_save = datain.copy()\n                        datain = datain[1:]\n                else:\n                    hascyclic = False\n                lonsin = np.roll(lonsin,itemindex-1)\n                if datain is not None:\n                    datain = np.roll(datain,itemindex-1)\n                # add cyclic point back at beginning.\n                if hascyclic:\n                    lonsin_save[1:] = lonsin\n                    lonsin_save[0] = lonsin[-1]-360.\n                    lonsin = lonsin_save\n                    if datain is not None:\n                        datain_save[1:] = datain\n                        datain_save[0] = datain[-1]\n                        datain = datain_save\n\n        # mask points outside\n        # map region so they don't wrap back in the domain.\n        mask = np.logical_or(lonsin<lon_0-180,lonsin>lon_0+180)\n        lonsin = np.where(mask,1.e30,lonsin)\n        if datain is not None and mask.any():\n            datain = ma.masked_where(mask, datain)\n\n        if datain is not None:\n            return lonsin, datain\n        else:\n            return lonsin",
  "def _searchlist(a,x):\n    \"\"\"\n    like bisect, but works for lists that are not sorted,\n    and are not in increasing order.\n    returns -1 if x does not fall between any two elements\"\"\"\n    # make sure x is a float (and not an array scalar)\n    x = float(x)\n    itemprev = a[0]\n    nslot = -1\n    eps = 180.\n    for n,item in enumerate(a[1:]):\n        if item < itemprev:\n            if itemprev-item>eps:\n                if ((x>itemprev and x<=360.) or (x<item and x>=0.)):\n                    nslot = n+1\n                    break\n            elif x <= itemprev and x > item and itemprev:\n                nslot = n+1\n                break\n        else:\n            if item-itemprev>eps:\n                if ((x<itemprev and x>=0.) or (x>item and x<=360.)):\n                    nslot = n+1\n                    break\n            elif x >= itemprev and x < item:\n                nslot = n+1\n                break\n        itemprev = item\n    return nslot",
  "def interp(datain,xin,yin,xout,yout,checkbounds=False,masked=False,order=1):\n    \"\"\"\n    Interpolate data (``datain``) on a rectilinear grid (with x = ``xin``\n    y = ``yin``) to a grid with x = ``xout``, y= ``yout``.\n\n    .. tabularcolumns:: |l|L|\n\n    ==============   ====================================================\n    Arguments        Description\n    ==============   ====================================================\n    datain           a rank-2 array with 1st dimension corresponding to\n                     y, 2nd dimension x.\n    xin, yin         rank-1 arrays containing x and y of\n                     datain grid in increasing order.\n    xout, yout       rank-2 arrays containing x and y of desired output grid.\n    ==============   ====================================================\n\n    .. tabularcolumns:: |l|L|\n\n    ==============   ====================================================\n    Keywords         Description\n    ==============   ====================================================\n    checkbounds      If True, values of xout and yout are checked to see\n                     that they lie within the range specified by xin\n                     and xin.\n                     If False, and xout,yout are outside xin,yin,\n                     interpolated values will be clipped to values on\n                     boundary of input grid (xin,yin)\n                     Default is False.\n    masked           If True, points outside the range of xin and yin\n                     are masked (in a masked array).\n                     If masked is set to a number, then\n                     points outside the range of xin and yin will be\n                     set to that number. Default False.\n    order            0 for nearest-neighbor interpolation, 1 for\n                     bilinear interpolation, 3 for cublic spline\n                     (default 1). order=3 requires scipy.ndimage.\n    ==============   ====================================================\n\n    .. note::\n     If datain is a masked array and order=1 (bilinear interpolation) is\n     used, elements of dataout will be masked if any of the four surrounding\n     points in datain are masked.  To avoid this, do the interpolation in two\n     passes, first with order=1 (producing dataout1), then with order=0\n     (producing dataout2).  Then replace all the masked values in dataout1\n     with the corresponding elements in dataout2 (using numpy.where).\n     This effectively uses nearest neighbor interpolation if any of the\n     four surrounding points in datain are masked, and bilinear interpolation\n     otherwise.\n\n    Returns ``dataout``, the interpolated data on the grid ``xout, yout``.\n    \"\"\"\n    # xin and yin must be monotonically increasing.\n    if xin[-1]-xin[0] < 0 or yin[-1]-yin[0] < 0:\n        raise ValueError('xin and yin must be increasing!')\n    if xout.shape != yout.shape:\n        raise ValueError('xout and yout must have same shape!')\n    # check that xout,yout are\n    # within region defined by xin,yin.\n    if checkbounds:\n        if xout.min() < xin.min() or \\\n           xout.max() > xin.max() or \\\n           yout.min() < yin.min() or \\\n           yout.max() > yin.max():\n            raise ValueError('yout or xout outside range of yin or xin')\n    # compute grid coordinates of output grid.\n    delx = xin[1:]-xin[0:-1]\n    dely = yin[1:]-yin[0:-1]\n    if max(delx)-min(delx) < 1.e-4 and max(dely)-min(dely) < 1.e-4:\n        # regular input grid.\n        xcoords = (len(xin)-1)*(xout-xin[0])/(xin[-1]-xin[0])\n        ycoords = (len(yin)-1)*(yout-yin[0])/(yin[-1]-yin[0])\n    else:\n        # irregular (but still rectilinear) input grid.\n        xoutflat = xout.flatten(); youtflat = yout.flatten()\n        ix = (np.searchsorted(xin,xoutflat)-1).tolist()\n        iy = (np.searchsorted(yin,youtflat)-1).tolist()\n        xoutflat = xoutflat.tolist(); xin = xin.tolist()\n        youtflat = youtflat.tolist(); yin = yin.tolist()\n        xcoords = []; ycoords = []\n        for n,i in enumerate(ix):\n            if i < 0:\n                xcoords.append(-1) # outside of range on xin (lower end)\n            elif i >= len(xin)-1:\n                xcoords.append(len(xin)) # outside range on upper end.\n            else:\n                xcoords.append(float(i)+(xoutflat[n]-xin[i])/(xin[i+1]-xin[i]))\n        for m,j in enumerate(iy):\n            if j < 0:\n                ycoords.append(-1) # outside of range of yin (on lower end)\n            elif j >= len(yin)-1:\n                ycoords.append(len(yin)) # outside range on upper end\n            else:\n                ycoords.append(float(j)+(youtflat[m]-yin[j])/(yin[j+1]-yin[j]))\n        xcoords = np.reshape(xcoords,xout.shape)\n        ycoords = np.reshape(ycoords,yout.shape)\n    # data outside range xin,yin will be clipped to\n    # values on boundary.\n    if masked:\n        xmask = np.logical_or(np.less(xcoords,0),np.greater(xcoords,len(xin)-1))\n        ymask = np.logical_or(np.less(ycoords,0),np.greater(ycoords,len(yin)-1))\n        xymask = np.logical_or(xmask,ymask)\n    xcoords = np.clip(xcoords,0,len(xin)-1)\n    ycoords = np.clip(ycoords,0,len(yin)-1)\n    # interpolate to output grid using bilinear interpolation.\n    if order == 1:\n        xi = xcoords.astype(np.int32)\n        yi = ycoords.astype(np.int32)\n        xip1 = xi+1\n        yip1 = yi+1\n        xip1 = np.clip(xip1,0,len(xin)-1)\n        yip1 = np.clip(yip1,0,len(yin)-1)\n        delx = xcoords-xi.astype(np.float32)\n        dely = ycoords-yi.astype(np.float32)\n        dataout = (1.-delx)*(1.-dely)*datain[yi,xi] + \\\n                  delx*dely*datain[yip1,xip1] + \\\n                  (1.-delx)*dely*datain[yip1,xi] + \\\n                  delx*(1.-dely)*datain[yi,xip1]\n    elif order == 0:\n        xcoordsi = np.around(xcoords).astype(np.int32)\n        ycoordsi = np.around(ycoords).astype(np.int32)\n        dataout = datain[ycoordsi,xcoordsi]\n    elif order == 3:\n        try:\n            from scipy.ndimage import map_coordinates\n        except ImportError:\n            raise ValueError('scipy.ndimage must be installed if order=3')\n        coords = [ycoords,xcoords]\n        dataout = map_coordinates(datain,coords,order=3,mode='nearest')\n    else:\n        raise ValueError('order keyword must be 0, 1 or 3')\n    if masked:\n        newmask = ma.mask_or(ma.getmask(dataout), xymask)\n        dataout = ma.masked_array(dataout, mask=newmask)\n        if not isinstance(masked, bool):\n            dataout = dataout.filled(masked)\n    return dataout",
  "def shiftgrid(lon0,datain,lonsin,start=True,cyclic=360.0):\n    \"\"\"\n    Shift global lat/lon grid east or west.\n\n    .. tabularcolumns:: |l|L|\n\n    ==============   ====================================================\n    Arguments        Description\n    ==============   ====================================================\n    lon0             starting longitude for shifted grid\n                     (ending longitude if start=False). lon0 must be on\n                     input grid (within the range of lonsin).\n    datain           original data with longitude the right-most\n                     dimension.\n    lonsin           original longitudes.\n    ==============   ====================================================\n\n    .. tabularcolumns:: |l|L|\n\n    ==============   ====================================================\n    Keywords         Description\n    ==============   ====================================================\n    start            if True, lon0 represents the starting longitude\n                     of the new grid. if False, lon0 is the ending\n                     longitude. Default True.\n    cyclic           width of periodic domain (default 360)\n    ==============   ====================================================\n\n    returns ``dataout,lonsout`` (data and longitudes on shifted grid).\n    \"\"\"\n    if np.fabs(lonsin[-1]-lonsin[0]-cyclic) > 1.e-4:\n        # Use all data instead of raise ValueError, 'cyclic point not included'\n        start_idx = 0\n    else:\n        # If cyclic, remove the duplicate point\n        start_idx = 1\n    if lon0 < lonsin[0] or lon0 > lonsin[-1]:\n        raise ValueError('lon0 outside of range of lonsin')\n    i0 = np.argmin(np.fabs(lonsin-lon0))\n    i0_shift = len(lonsin)-i0\n    if ma.isMA(datain):\n        dataout  = ma.zeros(datain.shape,datain.dtype)\n    else:\n        dataout  = np.zeros(datain.shape,datain.dtype)\n    if ma.isMA(lonsin):\n        lonsout = ma.zeros(lonsin.shape,lonsin.dtype)\n    else:\n        lonsout = np.zeros(lonsin.shape,lonsin.dtype)\n    if start:\n        lonsout[0:i0_shift] = lonsin[i0:]\n    else:\n        lonsout[0:i0_shift] = lonsin[i0:]-cyclic\n    dataout[...,0:i0_shift] = datain[...,i0:]\n    if start:\n        lonsout[i0_shift:] = lonsin[start_idx:i0+start_idx]+cyclic\n    else:\n        lonsout[i0_shift:] = lonsin[start_idx:i0+start_idx]\n    dataout[...,i0_shift:] = datain[...,start_idx:i0+start_idx]\n    return dataout,lonsout",
  "def addcyclic(*arr,**kwargs):\n    \"\"\"\n    Adds cyclic (wraparound) points in longitude to one or several arrays,\n    the last array being longitudes in degrees. e.g.\n\n   ``data1out, data2out, lonsout = addcyclic(data1,data2,lons)``\n\n    ==============   ====================================================\n    Keywords         Description\n    ==============   ====================================================\n    axis             the dimension representing longitude (default -1,\n                     or right-most)\n    cyclic           width of periodic domain (default 360)\n    ==============   ====================================================\n    \"\"\"\n    # get (default) keyword arguments\n    axis = kwargs.get('axis',-1)\n    cyclic = kwargs.get('cyclic',360)\n    # define functions\n    def _addcyclic(a):\n        \"\"\"addcyclic function for a single data array\"\"\"\n        npsel = np.ma if np.ma.is_masked(a) else np\n        slicer = [slice(None)] * np.ndim(a)\n        try:\n            slicer[axis] = slice(0, 1)\n        except IndexError:\n            raise ValueError('The specified axis does not correspond to an '\n                    'array dimension.')\n        return npsel.concatenate((a,a[tuple(slicer)]),axis=axis)\n    def _addcyclic_lon(a):\n        \"\"\"addcyclic function for a single longitude array\"\"\"\n        # select the right numpy functions\n        npsel = np.ma if np.ma.is_masked(a) else np\n        # get cyclic longitudes\n        clon = (np.take(a,[0],axis=axis)\n                + cyclic * np.sign(np.diff(np.take(a,[0,-1],axis=axis),axis=axis)))\n        # ensure the values do not exceed cyclic\n        clonmod = npsel.where(clon<=cyclic,clon,np.mod(clon,cyclic))\n        return npsel.concatenate((a,clonmod),axis=axis)\n    # process array(s)\n    if len(arr) == 1:\n        return _addcyclic_lon(arr[-1])\n    else:\n        return list(map(_addcyclic,arr[:-1])) + [_addcyclic_lon(arr[-1])]",
  "def _choosecorners(width,height,**kwargs):\n    \"\"\"\n    private function to determine lat/lon values of projection region corners,\n    given width and height of projection region in meters.\n    \"\"\"\n    p = pyproj.Proj(kwargs)\n    urcrnrlon, urcrnrlat = p(0.5*width,0.5*height, inverse=True)\n    llcrnrlon, llcrnrlat = p(-0.5*width,-0.5*height, inverse=True)\n    corners = llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat\n    # test for invalid projection points on output\n    if llcrnrlon > 1.e20 or urcrnrlon > 1.e20:\n        raise ValueError('width and/or height too large for this projection, try smaller values')\n    else:\n        return corners",
  "def _choosecornersllur(llcrnrx, llcrnry, urcrnrx, urcrnry,**kwargs):\n    \"\"\"\n    private function to determine lat/lon values of projection region corners,\n    given width and height of projection region in meters.\n    \"\"\"\n    p = pyproj.Proj(kwargs)\n    urcrnrlon, urcrnrlat = p(urcrnrx, urcrnry, inverse=True)\n    llcrnrlon, llcrnrlat = p(llcrnrx, llcrnry, inverse=True)\n    corners = llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat\n    # test for invalid projection points on output\n    if llcrnrlon > 1.e20 or urcrnrlon > 1.e20:\n        raise ValueError('width and/or height too large for this projection, try smaller values')\n    else:\n        return corners",
  "def maskoceans(lonsin,latsin,datain,inlands=True,resolution='l',grid=5):\n    \"\"\"\n    mask data (``datain``), defined on a grid with latitudes ``latsin``\n    longitudes ``lonsin`` so that points over water will not be plotted.\n\n    .. tabularcolumns:: |l|L|\n\n    ==============   ====================================================\n    Arguments        Description\n    ==============   ====================================================\n    lonsin, latsin   rank-2 arrays containing longitudes and latitudes of\n                     grid.\n    datain           rank-2 input array on grid defined by ``lonsin`` and\n                     ``latsin``.\n    inlands          if False, masked only ocean points and not inland\n                     lakes (Default True).\n    resolution       gshhs coastline resolution used to define land/sea\n                     mask (default 'l', available 'c','l','i','h' or 'f')\n    grid             land/sea mask grid spacing in minutes (Default 5;\n                     10, 2.5 and 1.25 are also available).\n    ==============   ====================================================\n\n    returns a masked array the same shape as datain with \"wet\" points masked.\n    \"\"\"\n    # read in land/sea mask.\n    lsmask_lons, lsmask_lats, lsmask =\\\n    _readlsmask(lakes=inlands,resolution=resolution,grid=grid)\n    # nearest-neighbor interpolation to output grid.\n    lsmasko = interp(lsmask,lsmask_lons,lsmask_lats,lonsin,latsin,masked=True,order=0)\n    # mask input data.\n    mask = lsmasko == 0\n    return ma.masked_array(datain,mask=mask)",
  "def _readlsmask(lakes=True,resolution='l',grid=5):\n    # read in land/sea mask.\n    if grid == 10:\n        nlons = 2160\n    elif grid == 5:\n        nlons = 4320\n    elif grid == 2.5:\n        nlons = 8640\n    elif grid == 1.25:\n        nlons = 17280\n    else:\n        raise ValueError('grid for land/sea mask must be 10,5,2.5 or 1.25')\n    nlats = nlons//2\n    import gzip\n    lsmaskf =\\\n    gzip.open(os.path.join(basemap_datadir,'lsmask_%smin_%s.bin' %\\\n        (grid,resolution)), 'rb')\n    lsmask =\\\n    np.reshape(np.frombuffer(lsmaskf.read(),dtype=np.uint8),(nlats,nlons))\n    if lakes:\n        lsmask =\\\n        np.where(lsmask==2,np.array(0,dtype=np.uint8),lsmask)\n    lsmaskf.close()\n    delta = 360./nlons\n    lsmask_lons = np.linspace(-180+0.5*delta,180-0.5*delta,nlons).astype(np.float32)\n    lsmask_lats = np.linspace(-90+0.5*delta,90-0.5*delta,nlats).astype(np.float32)\n    return lsmask_lons, lsmask_lats, lsmask",
  "class _tup(tuple):\n    # tuple with an added remove method.\n    # used for objects returned by drawparallels and drawmeridians.\n    def remove(self):\n        for item in self:\n            for x in item:\n                x.remove()",
  "class _dict(dict):\n    # override __delitem__ to first call remove method on values.\n    def __delitem__(self,key):\n        self[key].remove()\n        super(_dict, self).__delitem__(key)",
  "def _setlonlab(fmt,lon,labelstyle):\n    # set lon label string (called by Basemap.drawmeridians)\n    try: # fmt is a function that returns a formatted string\n        lonlab = fmt(lon)\n    except: # fmt is a format string.\n        if lon>180:\n            if mpl.rcParams['text.usetex']:\n                if labelstyle=='+/-':\n                    lonlabstr = r'${\\/-%s\\/^{\\circ}}$'%fmt\n                else:\n                    lonlabstr = r'${%s\\/^{\\circ}\\/W}$'%fmt\n            else:\n                if labelstyle=='+/-':\n                    lonlabstr = u'-%s\\N{DEGREE SIGN}'%fmt\n                else:\n                    lonlabstr = u'%s\\N{DEGREE SIGN}W'%fmt\n            lonlab = lonlabstr%np.fabs(lon-360)\n        elif lon<180 and lon != 0:\n            if mpl.rcParams['text.usetex']:\n                if labelstyle=='+/-':\n                    lonlabstr = r'${\\/+%s\\/^{\\circ}}$'%fmt\n                else:\n                    lonlabstr = r'${%s\\/^{\\circ}\\/E}$'%fmt\n            else:\n                if labelstyle=='+/-':\n                    lonlabstr = u'+%s\\N{DEGREE SIGN}'%fmt\n                else:\n                    lonlabstr = u'%s\\N{DEGREE SIGN}E'%fmt\n            lonlab = lonlabstr%lon\n        else:\n            if mpl.rcParams['text.usetex']:\n                lonlabstr = r'${%s\\/^{\\circ}}$'%fmt\n            else:\n                lonlabstr = u'%s\\N{DEGREE SIGN}'%fmt\n            lonlab = lonlabstr%lon\n    return lonlab",
  "def _setlatlab(fmt,lat,labelstyle):\n    # set lat label string (called by Basemap.drawparallels)\n    try: # fmt is a function that returns a formatted string\n           latlab = fmt(lat)\n    except: # fmt is a format string.\n        if lat<0:\n            if mpl.rcParams['text.usetex']:\n                if labelstyle=='+/-':\n                    latlabstr = r'${\\/-%s\\/^{\\circ}}$'%fmt\n                else:\n                    latlabstr = r'${%s\\/^{\\circ}\\/S}$'%fmt\n            else:\n                if labelstyle=='+/-':\n                    latlabstr = u'-%s\\N{DEGREE SIGN}'%fmt\n                else:\n                    latlabstr = u'%s\\N{DEGREE SIGN}S'%fmt\n            latlab = latlabstr%np.fabs(lat)\n        elif lat>0:\n            if mpl.rcParams['text.usetex']:\n                if labelstyle=='+/-':\n                    latlabstr = r'${\\/+%s\\/^{\\circ}}$'%fmt\n                else:\n                    latlabstr = r'${%s\\/^{\\circ}\\/N}$'%fmt\n            else:\n                if labelstyle=='+/-':\n                    latlabstr = u'+%s\\N{DEGREE SIGN}'%fmt\n                else:\n                    latlabstr = u'%s\\N{DEGREE SIGN}N'%fmt\n            latlab = latlabstr%lat\n        else:\n            if mpl.rcParams['text.usetex']:\n                latlabstr = r'${%s\\/^{\\circ}}$'%fmt\n            else:\n                latlabstr = u'%s\\N{DEGREE SIGN}'%fmt\n            latlab = latlabstr%lat\n    return latlab",
  "def with_transform(self,x,y,data,*args,**kwargs):\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                x, data = self.shiftdata(x, data,\n                                         fix_wrap_around=plotfunc.__name__ not in [\"scatter\"])\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,data,*args,**kwargs)",
  "def with_transform(self,x,y,*args,**kwargs):\n        x = np.asarray(x)\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                if x.ndim == 1:\n                    x = self.shiftdata(x, fix_wrap_around=plotfunc.__name__ not in [\"scatter\"])\n                elif x.ndim == 0:\n                    if x > 180:\n                        x = x - 360.\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,*args,**kwargs)",
  "def with_transform(self,x,y,u,v,*args,**kwargs):\n        # input coordinates are latitude/longitude, not map projection coords.\n        if kwargs.pop('latlon', latlon_default):\n            # shift data to map projection region for\n            # cylindrical and pseudo-cylindrical projections.\n            if self.projection in _cylproj or self.projection in _pseudocyl:\n                x1, u = self.shiftdata(x, u)\n                x, v = self.shiftdata(x, v)\n            # convert lat/lon coords to map projection coords.\n            x, y = self(x,y)\n        return plotfunc(self,x,y,u,v,*args,**kwargs)",
  "def __init__(self, llcrnrlon=None, llcrnrlat=None,\n                       urcrnrlon=None, urcrnrlat=None,\n                       llcrnrx=None, llcrnry=None,\n                       urcrnrx=None, urcrnry=None,\n                       width=None, height=None,\n                       projection='cyl', resolution='c',\n                       area_thresh=None, rsphere=6370997.0,\n                       ellps=None, lat_ts=None,\n                       lat_1=None, lat_2=None,\n                       lat_0=None, lon_0=None,\n                       lon_1=None, lon_2=None,\n                       o_lon_p=None, o_lat_p=None,\n                       k_0=None,\n                       no_rot=False,\n                       suppress_ticks=True,\n                       satellite_height=35786000,\n                       boundinglat=None,\n                       fix_aspect=True,\n                       anchor='C',\n                       celestial=False,\n                       round=False,\n                       epsg=None,\n                       ax=None):\n        # docstring is added after __init__ method definition\n\n        # set epsg code if given, set to 4326 for projection='cyl':\n        if epsg is not None:\n            self.epsg = epsg\n        elif projection == 'cyl':\n            self.epsg = 4326\n        # replace kwarg values with those implied by epsg code,\n        # if given.\n        if hasattr(self,'epsg'):\n            if str(self.epsg) not in epsg_dict:\n                raise ValueError('%s is not a supported EPSG code' %\n                        self.epsg)\n            epsg_params = epsg_dict[str(self.epsg)]\n            for k in epsg_params:\n                if k == 'projection':\n                    projection = epsg_params[k]\n                elif k == 'rsphere':\n                    rsphere = epsg_params[k]\n                elif k == 'ellps':\n                    ellps = epsg_params[k]\n                elif k == 'lat_1':\n                    lat_1 = epsg_params[k]\n                elif k == 'lat_2':\n                    lat_2 = epsg_params[k]\n                elif k == 'lon_0':\n                    lon_0 = epsg_params[k]\n                elif k == 'lat_0':\n                    lat_0 = epsg_params[k]\n                elif k == 'lat_ts':\n                    lat_ts = epsg_params[k]\n                elif k == 'k_0':\n                    k_0 = epsg_params[k]\n\n        # fix aspect to ratio to match aspect ratio of map projection\n        # region\n        self.fix_aspect = fix_aspect\n        # where to put plot in figure (default is 'C' or center)\n        self.anchor = anchor\n        # geographic or celestial coords?\n        self.celestial = celestial\n        # map projection.\n        self.projection = projection\n        # bounding lat (for pole-centered plots)\n        self.boundinglat = boundinglat\n        # is a round pole-centered plot desired?\n        self.round = round\n        # full disk projection?\n        self._fulldisk = False # default value\n\n        # set up projection parameter dict.\n        projparams = {}\n        projparams['proj'] = projection\n        # if ellps keyword specified, it over-rides rsphere.\n        if ellps is not None:\n            try:\n                elldict = pyproj.pj_ellps[ellps]\n            except KeyError:\n                raise ValueError(\n                'illegal ellps definition, allowed values are %s' %\n                pyproj.pj_ellps.keys())\n            projparams['a'] = elldict['a']\n            if 'b' in elldict:\n                projparams['b'] = elldict['b']\n            else:\n                projparams['b'] = projparams['a']*(1.0-(1.0/elldict['rf']))\n        else:\n            try:\n                if rsphere[0] > rsphere[1]:\n                    projparams['a'] = rsphere[0]\n                    projparams['b'] = rsphere[1]\n                else:\n                    projparams['a'] = rsphere[1]\n                    projparams['b'] = rsphere[0]\n            except:\n                if projection == 'tmerc':\n                # use bR_a instead of R because of obscure bug\n                # in proj4 for tmerc projection.\n                    projparams['bR_a'] = rsphere\n                else:\n                    projparams['R'] = rsphere\n        # set units to meters.\n        projparams['units']='m'\n        # check for sane values of lon_0, lat_0, lat_ts, lat_1, lat_2\n        lat_0 = _validated_or_none(lat_0, 'lat_0', -90, 90)\n        lat_1 = _validated_or_none(lat_1, 'lat_1', -90, 90)\n        lat_2 = _validated_or_none(lat_2, 'lat_2', -90, 90)\n        lat_ts = _validated_or_none(lat_ts, 'lat_ts', -90, 90)\n        lon_0 = _validated_or_none(lon_0, 'lon_0', -360, 720)\n        lon_1 = _validated_or_none(lon_1, 'lon_1', -360, 720)\n        lon_2 = _validated_or_none(lon_2, 'lon_2', -360, 720)\n        llcrnrlon = _validated_or_none(llcrnrlon, 'llcrnrlon', -360, 720)\n        urcrnrlon = _validated_or_none(urcrnrlon, 'urcrnrlon', -360, 720)\n        llcrnrlat = _validated_or_none(llcrnrlat, 'llcrnrlat', -90, 90)\n        urcrnrlat = _validated_or_none(urcrnrlat, 'urcrnrlat', -90, 90)\n\n        _insert_validated(projparams, lat_0, 'lat_0', -90, 90)\n        _insert_validated(projparams, lat_1, 'lat_1', -90, 90)\n        _insert_validated(projparams, lat_2, 'lat_2', -90, 90)\n        _insert_validated(projparams, lat_ts, 'lat_ts', -90, 90)\n        _insert_validated(projparams, lon_0, 'lon_0', -360, 720)\n        _insert_validated(projparams, lon_1, 'lon_1', -360, 720)\n        _insert_validated(projparams, lon_2, 'lon_2', -360, 720)\n        if projection in ['geos','nsper']:\n            projparams['h'] = satellite_height\n        # check for sane values of projection corners.\n        using_corners = (None not in [llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat])\n        if using_corners:\n            self.llcrnrlon = _validated_ll(llcrnrlon, 'llcrnrlon', -360, 720)\n            self.urcrnrlon = _validated_ll(urcrnrlon, 'urcrnrlon', -360, 720)\n            self.llcrnrlat = _validated_ll(llcrnrlat, 'llcrnrlat', -90, 90)\n            self.urcrnrlat = _validated_ll(urcrnrlat, 'urcrnrlat', -90, 90)\n\n        # for each of the supported projections,\n        # compute lat/lon of domain corners\n        # and set values in projparams dict as needed.\n\n        if projection in ['lcc', 'eqdc', 'aea']:\n            if projection == 'lcc' and k_0 is not None:\n                projparams['k_0']=k_0\n            # if lat_0 is given, but not lat_1,\n            # set lat_1=lat_0\n            if lat_1 is None and lat_0 is not None:\n                lat_1 = lat_0\n                projparams['lat_1'] = lat_1\n            if lat_1 is None or lon_0 is None:\n                raise ValueError('must specify lat_1 or lat_0 and lon_0 for %s basemap (lat_2 is optional)' % _projnames[projection])\n            if lat_2 is None:\n                projparams['lat_2'] = lat_1\n            if not using_corners:\n                using_cornersxy = (None not in [llcrnrx,llcrnry,urcrnrx,urcrnry])\n                if using_cornersxy:\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecornersllur(llcrnrx,llcrnry,urcrnrx,urcrnry,**projparams)\n                    self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                    self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n                else:\n                    if width is None or height is None:\n                        raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                    if lon_0 is None or lat_0 is None:\n                        raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                    self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                    self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'stere':\n            if k_0 is not None:\n                projparams['k_0']=k_0\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Stereographic basemap (lat_ts is optional)')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in ['spstere', 'npstere',\n                            'splaea', 'nplaea',\n                            'spaeqd', 'npaeqd']:\n            if (projection == 'splaea' and boundinglat >= 0) or\\\n               (projection == 'nplaea' and boundinglat <= 0):\n                raise ValueError('boundinglat cannot extend into opposite hemisphere')\n            if boundinglat is None or lon_0 is None:\n                raise ValueError('must specify boundinglat and lon_0 for %s basemap' % _projnames[projection])\n            if projection[0] == 's':\n                sgn = -1\n            else:\n                sgn = 1\n            rootproj = projection[2:]\n            projparams['proj'] = rootproj\n            if rootproj == 'stere':\n                projparams['lat_ts'] = sgn * 90.\n            projparams['lat_0'] = sgn * 90.\n            self.llcrnrlon = lon_0 - sgn*45.\n            self.urcrnrlon = lon_0 + sgn*135.\n            proj = pyproj.Proj(projparams)\n            x,y = proj(lon_0,boundinglat)\n            lon,self.llcrnrlat = proj(math.sqrt(2.)*y,0.,inverse=True)\n            self.urcrnrlat = self.llcrnrlat\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[projection])\n        elif projection == 'laea':\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Lambert Azimuthal basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in ['tmerc','gnom','cass','poly'] :\n            if projection == 'tmerc' and k_0 is not None:\n                projparams['k_0']=k_0\n            if projection == 'gnom' and 'R' not in projparams:\n                raise ValueError('gnomonic projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Transverse Mercator, Gnomonic, Cassini-Soldnerr and Polyconic basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'ortho':\n            if 'R' not in projparams:\n                raise ValueError('orthographic projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Orthographic basemap')\n            if (lat_0 == 90 or lat_0 == -90) and\\\n               None in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                # for ortho plot centered on pole, set boundinglat to equator.\n                # (so meridian labels can be drawn in this special case).\n                self.boundinglat = 0\n                self.round = True\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n            # FIXME: won't work for points exactly on equator??\n            if np.abs(lat_0) < 1.e-2: lat_0 = 1.e-2\n            projparams['lat_0'] = lat_0\n        elif projection == 'geos':\n            if lat_0 is not None and lat_0 != 0:\n                raise ValueError('lat_0 must be zero for Geostationary basemap')\n            if lon_0 is None:\n                raise ValueError('must specify lon_0 for Geostationary basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'nsper':\n            if 'R' not in projparams:\n                raise ValueError('near-sided perspective projection only works for perfect spheres - not ellipsoids')\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lon_0 and lat_0 for near-sided perspective Basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if not using_corners:\n                llcrnrlon = -180.\n                llcrnrlat = -90.\n                urcrnrlon = 180\n                urcrnrlat = 90.\n                self._fulldisk = True\n            else:\n                self._fulldisk = False\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in _pseudocyl:\n            if lon_0 is None:\n                raise ValueError('must specify lon_0 for %s projection' % _projnames[self.projection])\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            llcrnrlon = lon_0-180.\n            llcrnrlat = -90.\n            urcrnrlon = lon_0+180\n            urcrnrlat = 90.\n            self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n            self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'omerc':\n            if k_0 is not None:\n                projparams['k_0']=k_0\n            if lat_1 is None or lon_1 is None or lat_2 is None or lon_2 is None:\n                raise ValueError('must specify lat_1,lon_1 and lat_2,lon_2 for Oblique Mercator basemap')\n            projparams['lat_1'] = lat_1\n            projparams['lon_1'] = lon_1\n            projparams['lat_2'] = lat_2\n            projparams['lon_2'] = lon_2\n            projparams['lat_0'] = lat_0\n            if no_rot:\n                projparams['no_rot']=''\n            #if not using_corners:\n            #    raise ValueError, 'cannot specify map region with width and height keywords for this projection, please specify lat/lon values of corners'\n            if not using_corners:\n                if width is None or height is None:\n                    raise ValueError('must either specify lat/lon values of corners (llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat) in degrees or width and height in meters')\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection == 'aeqd':\n            if lat_0 is None or lon_0 is None:\n                raise ValueError('must specify lat_0 and lon_0 for Azimuthal Equidistant basemap')\n            if not using_corners:\n                if width is None or height is None:\n                    self._fulldisk = True\n                    llcrnrlon = -180.\n                    llcrnrlat = -90.\n                    urcrnrlon = 180\n                    urcrnrlat = 90.\n                else:\n                    self._fulldisk = False\n                if lon_0 is None or lat_0 is None:\n                    raise ValueError('must specify lon_0 and lat_0 when using width, height to specify projection region')\n                if not self._fulldisk:\n                    llcrnrlon,llcrnrlat,urcrnrlon,urcrnrlat = _choosecorners(width,height,**projparams)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        elif projection in _cylproj:\n            if projection == 'merc' or projection == 'cea':\n                if lat_ts is None:\n                    lat_ts = 0.\n                    projparams['lat_ts'] = lat_ts\n            if not using_corners:\n                llcrnrlat = -90.\n                urcrnrlat = 90.\n                if lon_0 is not None:\n                    llcrnrlon = lon_0-180.\n                    urcrnrlon = lon_0+180.\n                else:\n                    llcrnrlon = -180.\n                    urcrnrlon = 180\n                if projection == 'merc':\n                    # clip plot region to be within -89.99S to 89.99N\n                    # (mercator is singular at poles)\n                    if llcrnrlat < -89.99: llcrnrlat = -89.99\n                    if llcrnrlat > 89.99: llcrnrlat = 89.99\n                    if urcrnrlat < -89.99: urcrnrlat = -89.99\n                    if urcrnrlat > 89.99: urcrnrlat = 89.99\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            if lon_0 is not None:\n                projparams['lon_0'] = lon_0\n            else:\n                projparams['lon_0']=0.5*(llcrnrlon+urcrnrlon)\n        elif projection == 'rotpole':\n            if lon_0 is None or o_lon_p is None or o_lat_p is None:\n                raise ValueError('must specify lon_0,o_lat_p,o_lon_p for rotated pole Basemap')\n            if width is not None or height is not None:\n                sys.stdout.write('warning: width and height keywords ignored for %s projection' % _projnames[self.projection])\n            projparams['lon_0']=lon_0\n            projparams['o_lon_p']=o_lon_p\n            projparams['o_lat_p']=o_lat_p\n            projparams['o_proj']='longlat'\n            projparams['proj']='ob_tran'\n            if not using_corners and None in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                raise ValueError('must specify lat/lon values of corners in degrees')\n            if None not in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n                p = pyproj.Proj(projparams)\n                llcrnrx = _dg2rad*llcrnrx; llcrnry = _dg2rad*llcrnry\n                urcrnrx = _dg2rad*urcrnrx; urcrnry = _dg2rad*urcrnry\n                llcrnrlon, llcrnrlat = p(llcrnrx,llcrnry,inverse=True)\n                urcrnrlon, urcrnrlat = p(urcrnrx,urcrnry,inverse=True)\n                self.llcrnrlon = llcrnrlon; self.llcrnrlat = llcrnrlat\n                self.urcrnrlon = urcrnrlon; self.urcrnrlat = urcrnrlat\n        else:\n            raise ValueError(_unsupported_projection % projection)\n\n        # initialize proj4\n        proj = Proj(projparams,self.llcrnrlon,self.llcrnrlat,self.urcrnrlon,self.urcrnrlat)\n\n        # make sure axis ticks are suppressed.\n        self.noticks = suppress_ticks\n        # map boundary not yet drawn.\n        self._mapboundarydrawn = False\n\n        # make Proj instance a Basemap instance variable.\n        self.projtran = proj\n        # copy some Proj attributes.\n        atts = ['rmajor','rminor','esq','flattening','ellipsoid','projparams']\n        for att in atts:\n            self.__dict__[att] = proj.__dict__[att]\n        # these only exist for geostationary projection.\n        if hasattr(proj,'_width'):\n            self.__dict__['_width'] = proj.__dict__['_width']\n        if hasattr(proj,'_height'):\n            self.__dict__['_height'] = proj.__dict__['_height']\n        # spatial reference string (useful for georeferencing output\n        # images with gdal_translate).\n        if hasattr(self,'_proj4'):\n            #self.srs = proj._proj4.srs\n            self.srs = proj._proj4.pjinitstring\n        else:\n            pjargs = []\n            for key,value in self.projparams.items():\n                # 'cyl' projection translates to 'eqc' in PROJ.4\n                if projection == 'cyl' and key == 'proj':\n                    value = 'eqc'\n                # ignore x_0 and y_0 settings for 'cyl' projection\n                # (they are not consistent with what PROJ.4 uses)\n                elif projection == 'cyl' and key in ['x_0','y_0']:\n                    continue\n                pjargs.append('+'+key+\"=\"+str(value)+' ')\n            self.srs = ''.join(pjargs)\n        self.proj4string = self.srs\n        # set instance variables defining map region.\n        self.xmin = proj.xmin\n        self.xmax = proj.xmax\n        self.ymin = proj.ymin\n        self.ymax = proj.ymax\n        if projection == 'cyl':\n            self.aspect = (self.urcrnrlat-self.llcrnrlat)/(self.urcrnrlon-self.llcrnrlon)\n        else:\n            self.aspect = (proj.ymax-proj.ymin)/(proj.xmax-proj.xmin)\n        if projection in ['geos','ortho','nsper'] and \\\n           None not in [llcrnrx,llcrnry,urcrnrx,urcrnry]:\n            self.llcrnrx = llcrnrx+0.5*proj.xmax\n            self.llcrnry = llcrnry+0.5*proj.ymax\n            self.urcrnrx = urcrnrx+0.5*proj.xmax\n            self.urcrnry = urcrnry+0.5*proj.ymax\n            self._fulldisk = False\n        else:\n            self.llcrnrx = proj.llcrnrx\n            self.llcrnry = proj.llcrnry\n            self.urcrnrx = proj.urcrnrx\n            self.urcrnry = proj.urcrnry\n\n        if self.projection == 'rotpole':\n            lon0,lat0 = self(0.5*(self.llcrnrx + self.urcrnrx),\\\n                             0.5*(self.llcrnry + self.urcrnry),\\\n                             inverse=True)\n            self.projparams['lat_0']=lat0\n\n        # if ax == None, pyplot.gca may be used.\n        self.ax = ax\n        self.lsmask = None\n        # This will record hashs of Axes instances.\n        self._initialized_axes = set()\n\n        # set defaults for area_thresh.\n        self.resolution = resolution\n        # celestial=True implies resolution=None (no coastlines).\n        if self.celestial:\n            self.resolution=None\n        if area_thresh is None and self.resolution is not None:\n            if resolution == 'c':\n                area_thresh = 10000.\n            elif resolution == 'l':\n                area_thresh = 1000.\n            elif resolution == 'i':\n                area_thresh = 100.\n            elif resolution == 'h':\n                area_thresh = 10.\n            elif resolution == 'f':\n                area_thresh = 1.\n            else:\n                raise ValueError(\"boundary resolution must be one of 'c','l','i','h' or 'f'\")\n        self.area_thresh = area_thresh\n        # define map boundary polygon (in lat/lon coordinates)\n        blons, blats, self._boundarypolyll, self._boundarypolyxy = self._getmapboundary()\n        self.boundarylats = blats\n        self.boundarylons = blons\n        # set min/max lats for projection domain.\n        if self.projection in _cylproj:\n            self.latmin = self.llcrnrlat\n            self.latmax = self.urcrnrlat\n            self.lonmin = self.llcrnrlon\n            self.lonmax = self.urcrnrlon\n        elif self.projection in ['ortho','geos','nsper'] + _pseudocyl:\n            self.latmin = -90.\n            self.latmax = 90.\n            self.lonmin = self.llcrnrlon\n            self.lonmax = self.urcrnrlon\n        else:\n            lons, lats = self.makegrid(1001,1001)\n            lats = ma.masked_where(lats > 1.e20,lats)\n            lons = ma.masked_where(lons > 1.e20,lons)\n            self.latmin = lats.min()\n            self.latmax = lats.max()\n            self.lonmin = lons.min()\n            self.lonmax = lons.max()\n            NPole = _geoslib.Point(self(0.,90.))\n            SPole = _geoslib.Point(self(0.,-90.))\n            if lat_0 is None:\n                lon_0, lat_0 =\\\n                self(0.5*(self.xmin+self.xmax),\n                     0.5*(self.ymin+self.ymax),inverse=True)\n            Dateline = _geoslib.Point(self(180.,lat_0))\n            Greenwich = _geoslib.Point(self(0.,lat_0))\n            hasNP = NPole.within(self._boundarypolyxy)\n            hasSP = SPole.within(self._boundarypolyxy)\n            hasPole = hasNP or hasSP\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            hasGreenwich = Greenwich.within(self._boundarypolyxy)\n            # projection crosses dateline (and not Greenwich or pole).\n            if not hasPole and hasDateline and not hasGreenwich:\n                if self.lonmin < 0 and self.lonmax > 0.:\n                    lons = np.where(lons < 0, lons+360, lons)\n                    self.lonmin = lons.min()\n                    self.lonmax = lons.max()\n        # read in coastline polygons, only keeping those that\n        # intersect map boundary polygon.\n        if self.resolution is not None:\n            self.coastsegs, self.coastpolygontypes =\\\n            self._readboundarydata('gshhs',as_polygons=True)\n            # reformat for use in matplotlib.patches.Polygon.\n            self.coastpolygons = []\n            for seg in self.coastsegs:\n                x, y = list(zip(*seg))\n                self.coastpolygons.append((x,y))\n            # replace coastsegs with line segments (instead of polygons)\n            self.coastsegs, types =\\\n            self._readboundarydata('gshhs',as_polygons=False)\n            self.coastsegs = [sg for sg in self.coastsegs if len(sg) > 0]\n        # create geos Polygon structures for land areas.\n        # currently only used in is_land method.\n        self.landpolygons=[]\n        self.lakepolygons=[]\n        if self.resolution is not None and len(self.coastpolygons) > 0:\n            #self.islandinlakepolygons=[]\n            #self.lakeinislandinlakepolygons=[]\n            x, y = list(zip(*self.coastpolygons))\n            for x,y,typ in zip(x,y,self.coastpolygontypes):\n                b = np.asarray([x,y]).T\n                if typ == 1: self.landpolygons.append(_geoslib.Polygon(b))\n                if typ == 2: self.lakepolygons.append(_geoslib.Polygon(b))",
  "def __call__(self,x,y,inverse=False):\n        \"\"\"\n        Calling a Basemap class instance with the arguments lon, lat will\n        convert lon/lat (in degrees) to x/y map projection\n        coordinates (in meters).  If optional keyword ``inverse`` is\n        True (default is False), the inverse transformation from x/y\n        to lon/lat is performed.\n\n        For cylindrical equidistant projection (``cyl``), this\n        does nothing (i.e. x,y == lon,lat).\n\n        For non-cylindrical projections, the inverse transformation\n        always returns longitudes between -180 and 180 degrees. For\n        cylindrical projections (self.projection == ``cyl``,\n        ``cea``, ``mill``, ``gall`` or ``merc``)\n        the inverse transformation will return longitudes between\n        self.llcrnrlon and self.llcrnrlat.\n\n        Input arguments lon, lat can be either scalar floats,\n        sequences, or numpy arrays.\n        \"\"\"\n        if self.celestial:\n            # don't assume center of map is at greenwich\n            # (only relevant for cyl or pseudo-cyl projections)\n            if self.projection in _pseudocyl or self.projection in _cylproj:\n                lon_0=self.projparams['lon_0']\n            else:\n                lon_0 = 0.\n        if self.celestial and not inverse:\n            try:\n                x = 2.*lon_0-x\n            except TypeError:\n                x = [2*lon_0-xx for xx in x]\n        if self.projection == 'rotpole' and inverse:\n            try:\n                x = _dg2rad*x\n            except TypeError:\n                x = [_dg2rad*xx for xx in x]\n            try:\n                y = _dg2rad*y\n            except TypeError:\n                y = [_dg2rad*yy for yy in y]\n        xout,yout = self.projtran(x,y,inverse=inverse)\n        if self.celestial and inverse:\n            try:\n                xout = -2.*lon_0-xout\n            except:\n                xout = [-2.*lon_0-xx for xx in xout]\n        if self.projection == 'rotpole' and not inverse:\n            try:\n                xout = _rad2dg*xout\n                xout = np.where(xout < 0., xout+360, xout)\n            except TypeError:\n                xout = [_rad2dg*xx for xx in xout]\n                xout = [xx+360. if xx < 0 else xx for xx in xout]\n            try:\n                yout = _rad2dg*yout\n            except TypeError:\n                yout = [_rad2dg*yy for yy in yout]\n        return xout,yout",
  "def makegrid(self,nx,ny,returnxy=False):\n        \"\"\"\n        return arrays of shape (ny,nx) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n\n        If ``returnxy = True``, the x,y values of the grid are returned also.\n        \"\"\"\n        return self.projtran.makegrid(nx,ny,returnxy=returnxy)",
  "def _readboundarydata(self,name,as_polygons=False):\n        \"\"\"\n        read boundary data, clip to map projection region.\n        \"\"\"\n\n        # only gshhs coastlines can be polygons.\n        if name != 'gshhs': as_polygons=False\n        try:\n            bdatfile = open(os.path.join(basemap_datadir,name+'_'+self.resolution+'.dat'),'rb')\n            bdatmetafile = open(os.path.join(basemap_datadir,name+'meta_'+self.resolution+'.dat'),'r')\n        except:\n            raise IOError(\n                \"Unable to open boundary dataset file. Only the 'crude', 'low' \"\n                \"and 'intermediate' resolution datasets are installed by default. \"\n                \"If you are requesting a 'high' or 'full' resolution dataset, \"\n                \"you need to install the `basemap-data-hires` package\")\n        polygons = []\n        polygon_types = []\n        # coastlines are polygons, other boundaries are line segments.\n        if name == 'gshhs':\n            Shape = _geoslib.Polygon\n        else:\n            Shape = _geoslib.LineString\n        # see if map projection region polygon contains a pole.\n        NPole = _geoslib.Point(self(0.,90.))\n        SPole = _geoslib.Point(self(0.,-90.))\n        boundarypolyxy = self._boundarypolyxy\n        boundarypolyll = self._boundarypolyll\n        hasNP = NPole.within(boundarypolyxy)\n        hasSP = SPole.within(boundarypolyxy)\n        containsPole = hasNP or hasSP\n        # these projections cannot cross pole.\n        if containsPole and\\\n            self.projection in _cylproj + _pseudocyl + ['geos']:\n            raise ValueError('%s projection cannot cross pole'%(self.projection))\n        # make sure some projections have has containsPole=True\n        # we will compute the intersections in stereographic\n        # coordinates, then transform back. This is\n        # because these projections are only defined on a hemisphere, and\n        # some boundary features (like Eurasia) would be undefined otherwise.\n        tostere =\\\n        ['omerc','ortho','gnom','nsper','nplaea','npaeqd','splaea','spaeqd']\n        if self.projection in tostere and name == 'gshhs':\n            containsPole = True\n            lon_0=self.projparams['lon_0']\n            lat_0=self.projparams['lat_0']\n            re = self.projparams['R']\n            # center of stereographic projection restricted to be\n            # nearest one of 6 points on the sphere (every 90 deg lat/lon).\n            lon0 = 90.*(np.around(lon_0/90.))\n            lat0 = 90.*(np.around(lat_0/90.))\n            if np.abs(int(lat0)) == 90: lon0=0.\n            maptran = pyproj.Proj(proj='stere',lon_0=lon0,lat_0=lat0,R=re)\n            # boundary polygon for ortho/gnom/nsper projection\n            # in stereographic coordinates.\n            b = self._boundarypolyll.boundary\n            blons = b[:,0]; blats = b[:,1]\n            b[:,0], b[:,1] = maptran(blons, blats)\n            boundarypolyxy = _geoslib.Polygon(b)\n        for line in bdatmetafile:\n            linesplit = line.split()\n            area = float(linesplit[1])\n            south = float(linesplit[3])\n            north = float(linesplit[4])\n            crossdatelineE=False; crossdatelineW=False\n            if name == 'gshhs':\n                id = linesplit[7]\n                if id.endswith('E'):\n                    crossdatelineE = True\n                elif id.endswith('W'):\n                    crossdatelineW = True\n            # make sure south/north limits of dateline crossing polygons\n            # (Eurasia) are the same, since they will be merged into one.\n            # (this avoids having one filtered out and not the other).\n            if crossdatelineE:\n                south_save=south\n                north_save=north\n            if crossdatelineW:\n                south=south_save\n                north=north_save\n            if area < 0.: area = 1.e30\n            useit = self.latmax>=south and self.latmin<=north and area>self.area_thresh\n            if useit:\n                typ = int(linesplit[0])\n                npts = int(linesplit[2])\n                offsetbytes = int(linesplit[5])\n                bytecount = int(linesplit[6])\n                bdatfile.seek(offsetbytes,0)\n                # read in binary string convert into an npts by 2\n                # numpy array (first column is lons, second is lats).\n                polystring = bdatfile.read(bytecount)\n                # binary data is little endian.\n                b = np.array(np.frombuffer(polystring,dtype='<f4'),'f8')\n                b.shape = (npts,2)\n                b2 = b.copy()\n                # merge polygons that cross dateline.\n                poly = Shape(b)\n                # hack to try to avoid having Antartica filled polygon\n                # covering entire map (if skipAnart = False, this happens\n                # for ortho lon_0=-120, lat_0=60, for example).\n                skipAntart = self.projection in tostere and south < -89 and \\\n                 not hasSP\n                if crossdatelineE and not skipAntart:\n                    if not poly.is_valid(): poly=poly.fix()\n                    polyE = poly\n                    continue\n                elif crossdatelineW and not skipAntart:\n                    if not poly.is_valid(): poly=poly.fix()\n                    b = poly.boundary\n                    b[:,0] = b[:,0]+360.\n                    poly = Shape(b)\n                    poly = poly.union(polyE)\n                    if not poly.is_valid(): poly=poly.fix()\n                    b = poly.boundary\n                    b2 = b.copy()\n                    # fix Antartica.\n                    if name == 'gshhs' and south < -89:\n                        b = b[3:,:]\n                        b2 = b.copy()\n                        poly = Shape(b)\n                # if map boundary polygon is a valid one in lat/lon\n                # coordinates (i.e. it does not contain either pole),\n                # the intersections of the boundary geometries\n                # and the map projection region can be computed before\n                # transforming the boundary geometry to map projection\n                # coordinates (this saves time, especially for small map\n                # regions and high-resolution boundary geometries).\n                if not containsPole:\n                    # close Antarctica.\n                    if name == 'gshhs' and south < -89:\n                        lons2 = b[:,0]\n                        lats = b[:,1]\n                        lons1 = lons2 - 360.\n                        lons3 = lons2 + 360.\n                        lons = lons1.tolist()+lons2.tolist()+lons3.tolist()\n                        lats = lats.tolist()+lats.tolist()+lats.tolist()\n                        lonstart,latstart = lons[0], lats[0]\n                        lonend,latend = lons[-1], lats[-1]\n                        lons.insert(0,lonstart)\n                        lats.insert(0,-90.)\n                        lons.append(lonend)\n                        lats.append(-90.)\n                        b = np.empty((len(lons),2),np.float64)\n                        b[:,0] = lons; b[:,1] = lats\n                        poly = Shape(b)\n                        if not poly.is_valid(): poly=poly.fix()\n                        # if polygon instersects map projection\n                        # region, process it.\n                        if poly.intersects(boundarypolyll):\n                            if name != 'gshhs' or as_polygons:\n                                geoms = poly.intersection(boundarypolyll)\n                            else:\n                                # convert polygons to line segments\n                                poly = _geoslib.LineString(poly.boundary)\n                                geoms = poly.intersection(boundarypolyll)\n                            # iterate over geometries in intersection.\n                            for psub in geoms:\n                                b = psub.boundary\n                                blons = b[:,0]; blats = b[:,1]\n                                bx, by = self(blons, blats)\n                                polygons.append(list(zip(bx,by)))\n                                polygon_types.append(typ)\n                    else:\n                        # create duplicate polygons shifted by -360 and +360\n                        # (so as to properly treat polygons that cross\n                        # Greenwich meridian).\n                        b2[:,0] = b[:,0]-360\n                        poly1 = Shape(b2)\n                        b2[:,0] = b[:,0]+360\n                        poly2 = Shape(b2)\n                        polys = [poly1,poly,poly2]\n                        for poly in polys:\n                            # try to fix \"non-noded intersection\" errors.\n                            if not poly.is_valid(): poly=poly.fix()\n                            # if polygon instersects map projection\n                            # region, process it.\n                            if poly.intersects(boundarypolyll):\n                                if name != 'gshhs' or as_polygons:\n                                    geoms = poly.intersection(boundarypolyll)\n                                else:\n                                    # convert polygons to line segments\n                                    # note: use fix method here or Eurasia\n                                    # line segments sometimes disappear.\n                                    poly = _geoslib.LineString(poly.fix().boundary)\n                                    geoms = poly.intersection(boundarypolyll)\n                                # iterate over geometries in intersection.\n                                for psub in geoms:\n                                    b = psub.boundary\n                                    blons = b[:,0]; blats = b[:,1]\n                                    # transformation from lat/lon to\n                                    # map projection coordinates.\n                                    bx, by = self(blons, blats)\n                                    if not as_polygons or len(bx) > 4:\n                                        polygons.append(list(zip(bx,by)))\n                                        polygon_types.append(typ)\n                # if map boundary polygon is not valid in lat/lon\n                # coordinates, compute intersection between map\n                # projection region and boundary geometries in map\n                # projection coordinates.\n                else:\n                    # transform coordinates from lat/lon\n                    # to map projection coordinates.\n                    # special case for ortho/gnom/nsper, compute coastline polygon\n                    # vertices in stereographic coords.\n                    if name == 'gshhs' and as_polygons and self.projection in tostere:\n                        b[:,0], b[:,1] = maptran(b[:,0], b[:,1])\n                    else:\n                        b[:,0], b[:,1] = self(b[:,0], b[:,1])\n                    goodmask = np.logical_and(b[:,0]<1.e20,b[:,1]<1.e20)\n                    # if less than two points are valid in\n                    # map proj coords, skip this geometry.\n                    if np.sum(goodmask) <= 1: continue\n                    if name != 'gshhs' or (name == 'gshhs' and not as_polygons):\n                        # if not a polygon,\n                        # just remove parts of geometry that are undefined\n                        # in this map projection.\n                        bx = np.compress(goodmask, b[:,0])\n                        by = np.compress(goodmask, b[:,1])\n                        # split coastline segments that jump across entire plot.\n                        xd = (bx[1:]-bx[0:-1])**2\n                        yd = (by[1:]-by[0:-1])**2\n                        dist = np.sqrt(xd+yd)\n                        split = dist > 0.1*(self.xmax-self.xmin)\n                        if np.sum(split) and self.projection not in _cylproj:\n                            ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                            iprev = 0\n                            ind.append(len(xd))\n                            for i in ind:\n                                # don't add empty lists.\n                                if len(list(range(iprev,i))):\n                                    polygons.append(list(zip(bx[iprev:i],by[iprev:i])))\n                                iprev = i\n                        else:\n                            polygons.append(list(zip(bx,by)))\n                        polygon_types.append(typ)\n                        continue\n                    # create a GEOS geometry object.\n                    if name == 'gshhs' and not as_polygons:\n                        # convert polygons to line segments\n                        poly = _geoslib.LineString(poly.boundary)\n                    else:\n                        # this is a workaround to avoid\n                        # GEOS_ERROR: CGAlgorithmsDD::orientationIndex encountered NaN/Inf numbers\n                        b[np.isposinf(b)] = 1e20\n                        b[np.isneginf(b)] = -1e20\n                        poly = Shape(b)\n                    # this is a workaround to avoid\n                    # \"GEOS_ERROR: TopologyException:\n                    # found non-noded intersection between ...\"\n                    if not poly.is_valid(): poly=poly.fix()\n                    # if geometry instersects map projection\n                    # region, and doesn't have any invalid points, process it.\n                    if goodmask.all() and poly.intersects(boundarypolyxy):\n                        # if geometry intersection calculation fails,\n                        # just move on.\n                        try:\n                            geoms = poly.intersection(boundarypolyxy)\n                        except:\n                            continue\n                        # iterate over geometries in intersection.\n                        for psub in geoms:\n                            b = psub.boundary\n                            # if projection in ['ortho','gnom','nsper'],\n                            # transform polygon from stereographic\n                            # to ortho/gnom/nsper coordinates.\n                            if self.projection in tostere:\n                                # if coastline polygon covers more than 99%\n                                # of map region for fulldisk projection,\n                                # it's probably bogus, so skip it.\n                                #areafrac = psub.area()/boundarypolyxy.area()\n                                #if self.projection == ['ortho','nsper']:\n                                #    if name == 'gshhs' and\\\n                                #       self._fulldisk and\\\n                                #       areafrac > 0.99: continue\n                                # inverse transform from stereographic\n                                # to lat/lon.\n                                b[:,0], b[:,1] = maptran(b[:,0], b[:,1], inverse=True)\n                                # orthographic/gnomonic/nsper.\n                                b[:,0], b[:,1]= self(b[:,0], b[:,1])\n                            if not as_polygons or len(b) > 4:\n                                polygons.append(list(zip(b[:,0],b[:,1])))\n                                polygon_types.append(typ)\n        bdatfile.close()\n        bdatmetafile.close()\n        return polygons, polygon_types",
  "def _getmapboundary(self):\n        \"\"\"\n        create map boundary polygon (in lat/lon and x/y coordinates)\n        \"\"\"\n        nx = 100; ny = 100\n        maptran = self\n        if self.projection in ['ortho','geos','nsper']:\n            # circular region.\n            thetas = np.linspace(0.,2.*np.pi,2*nx*ny)[:-1]\n            rminor = self._height\n            rmajor = self._width\n            x = rmajor*np.cos(thetas) + rmajor\n            y = rminor*np.sin(thetas) + rminor\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n            # compute proj instance for full disk, if necessary.\n            if not self._fulldisk:\n                projparms = self.projparams.copy()\n                del projparms['x_0']\n                del projparms['y_0']\n                if self.projection == 'ortho':\n                    llcrnrx = -self.rmajor\n                    llcrnry = -self.rmajor\n                    urcrnrx = -llcrnrx\n                    urcrnry = -llcrnry\n                else:\n                    llcrnrx = -self._width\n                    llcrnry = -self._height\n                    urcrnrx = -llcrnrx\n                    urcrnry = -llcrnry\n                projparms['x_0']=-llcrnrx\n                projparms['y_0']=-llcrnry\n                maptran = pyproj.Proj(projparms)\n        elif self.projection == 'aeqd' and self._fulldisk:\n            # circular region.\n            thetas = np.linspace(0.,2.*np.pi,2*nx*ny)[:-1]\n            rminor = self._height\n            rmajor = self._width\n            x = rmajor*np.cos(thetas) + rmajor\n            y = rminor*np.sin(thetas) + rminor\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        elif self.projection in _pseudocyl:\n            nx = 10*nx; ny = 10*ny\n            # quasi-elliptical region.\n            lon_0 = self.projparams['lon_0']\n            # left side\n            lats1 = np.linspace(-89.9999,89.9999,ny).tolist()\n            lons1 = len(lats1)*[lon_0-179.9]\n            # top.\n            lons2 = np.linspace(lon_0-179.9,lon_0+179.9,nx).tolist()\n            lats2 = len(lons2)*[89.9999]\n            # right side\n            lats3 = np.linspace(89.9999,-89.9999,ny).tolist()\n            lons3 = len(lats3)*[lon_0+179.9]\n            # bottom.\n            lons4 = np.linspace(lon_0+179.9,lon_0-179.9,nx).tolist()\n            lats4 = len(lons4)*[-89.9999]\n            lons = np.array(lons1+lons2+lons3+lons4,np.float64)\n            lats = np.array(lats1+lats2+lats3+lats4,np.float64)\n            x, y = maptran(lons,lats)\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        else: # all other projections are rectangular.\n            nx = 100*nx; ny = 100*ny\n            # left side (x = xmin, ymin <= y <= ymax)\n            yy = np.linspace(self.ymin, self.ymax, ny)[:-1]\n            x = len(yy)*[self.xmin]; y = yy.tolist()\n            # top (y = ymax, xmin <= x <= xmax)\n            xx = np.linspace(self.xmin, self.xmax, nx)[:-1]\n            x = x + xx.tolist()\n            y = y + len(xx)*[self.ymax]\n            # right side (x = xmax, ymin <= y <= ymax)\n            yy = np.linspace(self.ymax, self.ymin, ny)[:-1]\n            x = x + len(yy)*[self.xmax]; y = y + yy.tolist()\n            # bottom (y = ymin, xmin <= x <= xmax)\n            xx = np.linspace(self.xmax, self.xmin, nx)[:-1]\n            x = x + xx.tolist()\n            y = y + len(xx)*[self.ymin]\n            x = np.array(x,np.float64)\n            y = np.array(y,np.float64)\n            b = np.empty((4,2),np.float64)\n            b[:,0]=[self.xmin,self.xmin,self.xmax,self.xmax]\n            b[:,1]=[self.ymin,self.ymax,self.ymax,self.ymin]\n            boundaryxy = _geoslib.Polygon(b)\n        if self.projection in _cylproj:\n            # make sure map boundary doesn't quite include pole.\n            if self.urcrnrlat > 89.9999:\n                urcrnrlat = 89.9999\n            else:\n                urcrnrlat = self.urcrnrlat\n            if self.llcrnrlat < -89.9999:\n                llcrnrlat = -89.9999\n            else:\n                llcrnrlat = self.llcrnrlat\n            lons = [self.llcrnrlon, self.llcrnrlon, self.urcrnrlon, self.urcrnrlon]\n            lats = [llcrnrlat, urcrnrlat, urcrnrlat, llcrnrlat]\n            self.boundarylonmin = min(lons)\n            self.boundarylonmax = max(lons)\n            x, y = self(lons, lats)\n            b = np.empty((len(x),2),np.float64)\n            b[:,0]=x; b[:,1]=y\n            boundaryxy = _geoslib.Polygon(b)\n        else:\n            if self.projection not in _pseudocyl:\n                lons, lats = maptran(x,y,inverse=True)\n                # fix lons so there are no jumps.\n                n = 1\n                lonprev = lons[0]\n                for lon,lat in zip(lons[1:],lats[1:]):\n                    if np.abs(lon-lonprev) > 90.:\n                        if lonprev < 0:\n                            lon = lon - 360.\n                        else:\n                            lon = lon + 360\n                        lons[n] = lon\n                    lonprev = lon\n                    n = n + 1\n                self.boundarylonmin = lons.min()\n                self.boundarylonmax = lons.max()\n                # for circular full disk projections where boundary is\n                # a latitude circle, set boundarylonmax and boundarylonmin\n                # to cover entire world (so parallels will be drawn).\n                if self._fulldisk and \\\n                   np.abs(self.boundarylonmax-self.boundarylonmin) < 1.:\n                   self.boundarylonmin = -180.\n                   self.boundarylonmax = 180.\n        b = np.empty((len(lons),2),np.float64)\n        b[:,0] = lons; b[:,1] = lats\n        boundaryll = _geoslib.Polygon(b)\n        return lons, lats, boundaryll, boundaryxy",
  "def drawmapboundary(self,color='k',linewidth=1.0,fill_color=None,\\\n                        zorder=None,ax=None):\n        \"\"\"\n        draw boundary around map projection region, optionally\n        filling interior of region.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        line width for boundary (default 1.)\n        color            color of boundary line (default black)\n        fill_color       fill the map region background with this\n                         color (default is to fill with axis\n                         background color). If set to the string\n                         'none', no filling is done.\n        zorder           sets the zorder for filling map background\n                         (default 0).\n        ax               axes instance to use\n                         (default None, use default axes instance).\n        ==============   ====================================================\n\n        returns matplotlib.collections.PatchCollection representing map boundary.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # if no fill_color given, use axes background color.\n        # if fill_color is string 'none', really don't fill.\n        if fill_color is None:\n            mpl_version = tuple(map(int, mpl.__version__.split(\".\")[:2]))\n            if mpl_version >= (2, 0):\n                fill_color = ax.get_facecolor()\n            else:\n                fill_color = ax.get_axis_bgcolor()\n        elif fill_color == 'none' or fill_color == 'None':\n            fill_color = None\n        limb = None\n        if self.projection in ['ortho','geos','nsper'] or (self.projection=='aeqd' and\\\n           self._fulldisk):\n            limb = Ellipse((self._width,self._height),2.*self._width,2.*self._height)\n        if self.projection in ['ortho','geos','nsper','aeqd'] and self._fulldisk:\n            # elliptical region.\n            ax.set_frame_on(False)\n        elif self.projection in _pseudocyl:  # elliptical region.\n            ax.set_frame_on(False)\n            nx = 100; ny = 100\n            if self.projection == 'vandg':\n                nx = 10*nx; ny = 10*ny\n            # quasi-elliptical region.\n            lon_0 = self.projparams['lon_0']\n            # left side\n            lats1 = np.linspace(-89.9999,89.99999,ny).tolist()\n            lons1 = len(lats1)*[lon_0-179.9]\n            # top.\n            lons2 = np.linspace(lon_0-179.9999,lon_0+179.9999,nx).tolist()\n            lats2 = len(lons2)*[89.9999]\n            # right side\n            lats3 = np.linspace(89.9999,-89.9999,ny).tolist()\n            lons3 = len(lats3)*[lon_0+179.9999]\n            # bottom.\n            lons4 = np.linspace(lon_0+179.9999,lon_0-179.9999,nx).tolist()\n            lats4 = len(lons4)*[-89.9999]\n            lons = np.array(lons1+lons2+lons3+lons4,np.float64)\n            lats = np.array(lats1+lats2+lats3+lats4,np.float64)\n            x, y = self(lons,lats)\n            xy = list(zip(x,y))\n            limb = Polygon(xy)\n        elif self.round:\n            ax.set_frame_on(False)\n            limb = Circle((0.5*(self.xmax+self.xmin),0.5*(self.ymax+self.ymin)),\n                    radius=0.5*(self.xmax-self.xmin),fc='none')\n        else: # all other projections are rectangular.\n            ax.set_frame_on(True)\n            for spine in ax.spines.values():\n                spine.set_linewidth(linewidth)\n                spine.set_edgecolor(color)\n                if zorder is not None:\n                    spine.set_zorder(zorder)\n            if self.projection not in ['geos','ortho','nsper']:\n                limb = ax.patch\n\n        if limb is not None:\n            if limb is not ax.patch:\n                ax.add_patch(limb)\n            self._mapboundarydrawn = limb\n            if fill_color is None:\n                limb.set_fill(False)\n            else:\n                limb.set_facecolor(fill_color)\n                limb.set_zorder(0)\n            limb.set_edgecolor(color)\n            limb.set_linewidth(linewidth)\n            if zorder is not None:\n                limb.set_zorder(zorder)\n            limb.set_clip_on(True)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        return limb",
  "def fillcontinents(self,color='0.8',lake_color=None,ax=None,zorder=None,alpha=None):\n        \"\"\"\n        Fill continents.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to fill continents (default gray).\n        lake_color       color to fill inland lakes (default axes background).\n        ax               axes instance (overrides default axes instance).\n        zorder           sets the zorder for the continent polygons (if not\n                         specified, uses default zorder for a Polygon patch).\n                         Set to zero if you want to paint over the filled\n                         continents).\n        alpha            sets alpha transparency for continent polygons\n        ==============   ====================================================\n\n        After filling continents, lakes are re-filled with\n        axis background color.\n\n        returns a list of matplotlib.patches.Polygon objects.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # get axis background color.\n        mpl_version = tuple(map(int, mpl.__version__.split(\".\")[:2]))\n        if mpl_version >= (2, 0):\n            axisbgc = ax.get_facecolor()\n        else:\n            axisbgc = ax.get_axis_bgcolor()\n        npoly = 0\n        polys = []\n        for x,y in self.coastpolygons:\n            xa = np.array(x,np.float32)\n            ya = np.array(y,np.float32)\n        # check to see if all four corners of domain in polygon (if so,\n        # don't draw since it will just fill in the whole map).\n        # ** turn this off for now since it prevents continents that\n        # fill the whole map from being filled **\n            #delx = 10; dely = 10\n            #if self.projection in ['cyl']:\n            #    delx = 0.1\n            #    dely = 0.1\n            #test1 = np.fabs(xa-self.urcrnrx) < delx\n            #test2 = np.fabs(xa-self.llcrnrx) < delx\n            #test3 = np.fabs(ya-self.urcrnry) < dely\n            #test4 = np.fabs(ya-self.llcrnry) < dely\n            #hasp1 = np.sum(test1*test3)\n            #hasp2 = np.sum(test2*test3)\n            #hasp4 = np.sum(test2*test4)\n            #hasp3 = np.sum(test1*test4)\n            #if not hasp1 or not hasp2 or not hasp3 or not hasp4:\n            if 1:\n                xy = list(zip(xa.tolist(),ya.tolist()))\n                if self.coastpolygontypes[npoly] not in [2,4]:\n                    poly = Polygon(xy,facecolor=color,edgecolor=color,linewidth=0)\n                else: # lakes filled with background color by default\n                    if lake_color is None:\n                        poly = Polygon(xy,facecolor=axisbgc,edgecolor=axisbgc,linewidth=0)\n                    else:\n                        poly = Polygon(xy,facecolor=lake_color,edgecolor=lake_color,linewidth=0)\n                if zorder is not None:\n                    poly.set_zorder(zorder)\n                if alpha is not None:\n                    poly.set_alpha(alpha)\n                ax.add_patch(poly)\n                polys.append(poly)\n            npoly = npoly + 1\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip continent polygons to map limbs\n        polys,c = self._cliplimb(ax,polys)\n        return polys",
  "def _cliplimb(self,ax,coll):\n        if not self._mapboundarydrawn:\n            return coll, None\n        c = self._mapboundarydrawn\n        if c not in ax.patches:\n            p = ax.add_patch(c)\n            #p.set_clip_on(False)\n        try:\n            coll.set_clip_path(c)\n        except:\n            for item in coll:\n                item.set_clip_path(c)\n        return coll,c",
  "def drawcoastlines(self,linewidth=1.,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw coastlines.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        coastline width (default 1.)\n        linestyle        coastline linestyle (default solid)\n        color            coastline color (default black)\n        antialiased      antialiasing switch for coastlines (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the coastlines (if not specified,\n                         uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        coastlines = LineCollection(self.coastsegs,antialiaseds=(antialiased,))\n        coastlines.set_color(color)\n        coastlines.set_linestyle(linestyle)\n        coastlines.set_linewidth(linewidth)\n        coastlines.set_label('_nolabel_')\n        if zorder is not None:\n            coastlines.set_zorder(zorder)\n        ax.add_collection(coastlines)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        coastlines,c = self._cliplimb(ax,coastlines)\n        return coastlines",
  "def drawcountries(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw country boundaries.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        country boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            country boundary line color (default black)\n        antialiased      antialiasing switch for country boundaries (default\n                         True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the country boundaries (if not\n                         specified uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in country line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'cntrysegs'):\n            self.cntrysegs, types = self._readboundarydata('countries')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        countries = LineCollection(self.cntrysegs,antialiaseds=(antialiased,))\n        countries.set_color(color)\n        countries.set_linestyle(linestyle)\n        countries.set_linewidth(linewidth)\n        countries.set_label('_nolabel_')\n        if zorder is not None:\n            countries.set_zorder(zorder)\n        ax.add_collection(countries)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip countries to map limbs\n        countries,c = self._cliplimb(ax,countries)\n        return countries",
  "def drawstates(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw state boundaries in Americas.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        state boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            state boundary line color (default black)\n        antialiased      antialiasing switch for state boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the state boundaries (if not\n                         specified, uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in state line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'statesegs'):\n            self.statesegs, types = self._readboundarydata('states')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        states = LineCollection(self.statesegs,antialiaseds=(antialiased,))\n        states.set_color(color)\n        states.set_linestyle(linestyle)\n        states.set_linewidth(linewidth)\n        states.set_label('_nolabel_')\n        if zorder is not None:\n            states.set_zorder(zorder)\n        ax.add_collection(states)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip states to map limbs\n        states,c = self._cliplimb(ax,states)\n        return states",
  "def drawcounties(self,linewidth=0.1,linestyle='solid',color='k',antialiased=1,\n                     facecolor='none',ax=None,zorder=None,drawbounds=False):\n        \"\"\"\n        Draw county boundaries in US. The county boundary shapefile\n        originates with the NOAA Coastal Geospatial Data Project\n        (http://coastalgeospatial.noaa.gov/data_gis.html).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        county boundary line width (default 0.1)\n        linestyle        coastline linestyle (default solid)\n        color            county boundary line color (default black)\n        facecolor        fill color of county (default is no fill)\n        antialiased      antialiasing switch for county boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the county boundaries (if not\n                         specified, uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        ax = ax or self._check_ax()\n        gis_file = os.path.join(basemap_datadir,'UScounties')\n        county_info = self.readshapefile(gis_file,'counties',\\\n                      default_encoding='latin-1',drawbounds=drawbounds)\n        counties = [coords for coords in self.counties]\n        counties = PolyCollection(counties)\n        counties.set_linestyle(linestyle)\n        counties.set_linewidth(linewidth)\n        counties.set_edgecolor(color)\n        counties.set_facecolor(facecolor)\n        counties.set_label('counties')\n        if zorder:\n            counties.set_zorder(zorder)\n        ax.add_collection(counties)\n        return counties",
  "def drawrivers(self,linewidth=0.5,linestyle='solid',color='k',antialiased=1,ax=None,zorder=None):\n        \"\"\"\n        Draw major rivers.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        linewidth        river boundary line width (default 0.5)\n        linestyle        coastline linestyle (default solid)\n        color            river boundary line color (default black)\n        antialiased      antialiasing switch for river boundaries (default\n                         True).\n        ax               axes instance (overrides default axes instance)\n        zorder           sets the zorder for the rivers (if not\n                         specified uses default zorder for\n                         matplotlib.patches.LineCollections).\n        ==============   ====================================================\n\n        returns a matplotlib.patches.LineCollection object.\n        \"\"\"\n        if self.resolution is None:\n            raise AttributeError('there are no boundary datasets associated with this Basemap instance')\n        # read in river line segments, only keeping those that\n        # intersect map boundary polygon.\n        if not hasattr(self,'riversegs'):\n            self.riversegs, types = self._readboundarydata('rivers')\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        rivers = LineCollection(self.riversegs,antialiaseds=(antialiased,))\n        rivers.set_color(color)\n        rivers.set_linestyle(linestyle)\n        rivers.set_linewidth(linewidth)\n        rivers.set_label('_nolabel_')\n        if zorder is not None:\n            rivers.set_zorder(zorder)\n        ax.add_collection(rivers)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip rivers to map limbs\n        rivers,c = self._cliplimb(ax,rivers)\n        return rivers",
  "def is_land(self,xpt,ypt):\n        \"\"\"\n        Returns True if the given x,y point (in projection coordinates) is\n        over land, False otherwise.  The definition of land is based upon\n        the GSHHS coastline polygons associated with the class instance.\n        Points over lakes inside land regions are not counted as land points.\n        \"\"\"\n        if self.resolution is None: return None\n        landpt = False\n        for poly in self.landpolygons:\n            landpt = _geoslib.Point((xpt,ypt)).within(poly)\n            if landpt: break\n        lakept = False\n        for poly in self.lakepolygons:\n            lakept = _geoslib.Point((xpt,ypt)).within(poly)\n            if lakept: break\n        return landpt and not lakept",
  "def readshapefile(self,shapefile,name,drawbounds=True,zorder=None,\n                      linewidth=0.5,color='k',antialiased=1,ax=None,\n                      default_encoding='utf-8',encoding_errors='strict'):\n        \"\"\"\n        Read in shape file, optionally draw boundaries on map.\n\n        .. note::\n          - Assumes shapes are 2D\n          - only works for Point, MultiPoint, Polyline and Polygon shapes.\n          - vertices/points must be in geographic (lat/lon) coordinates.\n\n        Mandatory Arguments:\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Argument         Description\n        ==============   ====================================================\n        shapefile        path to shapefile components.  Example:\n                         shapefile='/home/jeff/esri/world_borders' assumes\n                         that world_borders.shp, world_borders.shx and\n                         world_borders.dbf live in /home/jeff/esri.\n        name             name for Basemap attribute to hold the shapefile\n                         vertices or points in map projection\n                         coordinates. Class attribute name+'_info' is a list\n                         of dictionaries, one for each shape, containing\n                         attributes of each shape from dbf file, For\n                         example, if name='counties', self.counties\n                         will be a list of x,y vertices for each shape in\n                         map projection  coordinates and self.counties_info\n                         will be a list of dictionaries with shape\n                         attributes.  Rings in individual Polygon\n                         shapes are split out into separate polygons, and\n                         additional keys 'RINGNUM' and 'SHAPENUM' are added\n                         to the shape attribute dictionary.\n        ==============   ====================================================\n\n        The following optional keyword arguments are only relevant for Polyline\n        and Polygon shape types, for Point and MultiPoint shapes they are\n        ignored.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        drawbounds       draw boundaries of shapes (default True).\n        zorder           shape boundary zorder (if not specified,\n                         default for mathplotlib.lines.LineCollection\n                         is used).\n        linewidth        shape boundary line width (default 0.5)\n        color            shape boundary line color (default black)\n        antialiased      antialiasing switch for shape boundaries\n                         (default True).\n        ax               axes instance (overrides default axes instance)\n        default_encoding encoding used to parse properties from .dbf files\n                         (default utf-8)\n        encoding_errors  encoding error handling (default strict), other\n                         possible values: ignore, replace and backslashreplace\n        ==============   ====================================================\n\n        A tuple (num_shapes, type, min, max) containing shape file info\n        is returned.\n        num_shapes is the number of shapes, type is the type code (one of\n        the SHPT* constants defined in the shapelib module, see\n        http://shapelib.maptools.org/shp_api.html) and min and\n        max are 4-element lists with the minimum and maximum values of the\n        vertices. If ``drawbounds=True`` a\n        matplotlib.patches.LineCollection object is appended to the tuple.\n        \"\"\"\n        import shapefile as shp\n        from shapefile import Reader\n        shp.default_encoding = default_encoding\n        if not os.path.exists('%s.shp'%shapefile):\n            raise IOError('cannot locate %s.shp'%shapefile)\n        if not os.path.exists('%s.shx'%shapefile):\n            raise IOError('cannot locate %s.shx'%shapefile)\n        if not os.path.exists('%s.dbf'%shapefile):\n            raise IOError('cannot locate %s.dbf'%shapefile)\n        # open shapefile, read vertices for each object, convert\n        # to map projection coordinates (only works for 2D shape types).\n        try:\n            shf = Reader(shapefile, encoding=default_encoding,\n                         encodingErrors=encoding_errors)\n        except:\n            raise IOError('error reading shapefile %s.shp' % shapefile)\n        fields = shf.fields\n        coords = []; attributes = []\n        msg = \" \".join([\n            \"shapefile must have lat/lon vertices - it looks like this one\",\n            \"has vertices in map projection coordinates. You can convert the\",\n            \"shapefile to geographic coordinates using the shpproj utility\",\n            \"from the shapelib tools (http://shapelib.maptools.org/shapelib-tools.html)\"])\n        shptype = shf.shapes()[0].shapeType\n        bbox = shf.bbox.tolist()\n        info = (shf.numRecords,shptype,bbox[0:2]+[0.,0.],bbox[2:]+[0.,0.])\n        npoly = 0\n        for shprec in shf.shapeRecords():\n            shp = shprec.shape; rec = shprec.record\n            npoly = npoly + 1\n            if shptype != shp.shapeType:\n                raise ValueError('readshapefile can only handle a single shape type per file')\n            if shptype not in [1,3,5,8]:\n                raise ValueError('readshapefile can only handle 2D shape types')\n            verts = shp.points\n            if shptype in [1,8]: # a Point or MultiPoint shape.\n                lons, lats = list(zip(*verts))\n                if max(lons) > 721. or min(lons) < -721. or max(lats) > 90.01 or min(lats) < -90.01:\n                    raise ValueError(msg)\n                # if latitude is slightly greater than 90, truncate to 90\n                lats = [max(min(lat, 90.0), -90.0) for lat in lats]\n                if len(verts) > 1: # MultiPoint\n                    x,y = self(lons, lats)\n                    coords.append(list(zip(x,y)))\n                else: # single Point\n                    x,y = self(lons[0], lats[0])\n                    coords.append((x,y))\n                attdict={}\n                for r,key in zip(rec,fields[1:]):\n                    attdict[key[0]]=r\n                attributes.append(attdict)\n            else: # a Polyline or Polygon shape.\n                parts = shp.parts.tolist()\n                ringnum = 0\n                for indx1,indx2 in zip(parts,parts[1:]+[len(verts)]):\n                    ringnum = ringnum + 1\n                    lons, lats = list(zip(*verts[indx1:indx2]))\n                    if max(lons) > 721. or min(lons) < -721. or max(lats) > 90.01 or min(lats) < -90.01:\n                        raise ValueError(msg)\n                    # if latitude is slightly greater than 90, truncate to 90\n                    lats = [max(min(lat, 90.0), -90.0) for lat in lats]\n                    x, y = self(lons, lats)\n                    coords.append(list(zip(x,y)))\n                    attdict={}\n                    for r,key in zip(rec,fields[1:]):\n                        attdict[key[0]]=r\n                    # add information about ring number to dictionary.\n                    attdict['RINGNUM'] = ringnum\n                    attdict['SHAPENUM'] = npoly\n                    attributes.append(attdict)\n        # draw shape boundaries for polylines, polygons  using LineCollection.\n        if shptype not in [1,8] and drawbounds:\n            # get current axes instance (if none specified).\n            ax = ax or self._check_ax()\n            # make LineCollections for each polygon.\n            lines = LineCollection(coords,antialiaseds=(1,))\n            lines.set_color(color)\n            lines.set_linewidth(linewidth)\n            lines.set_label('_nolabel_')\n            if zorder is not None:\n               lines.set_zorder(zorder)\n            ax.add_collection(lines)\n            # set axes limits to fit map region.\n            self.set_axes_limits(ax=ax)\n            # clip boundaries to map limbs\n            lines,c = self._cliplimb(ax,lines)\n            info = info + (lines,)\n        self.__dict__[name]=coords\n        self.__dict__[name+'_info']=attributes\n        return info",
  "def drawparallels(self,circles,color='k',textcolor='k',linewidth=1.,zorder=None, \\\n                      dashes=[1,1],labels=[0,0,0,0],labelstyle=None, \\\n                      fmt='%g',xoffset=None,yoffset=None,ax=None,latmax=None,\n                      **text_kwargs):\n        \"\"\"\n        Draw and label parallels (latitude lines) for values (in degrees)\n        given in the sequence ``circles``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to draw parallels (default black).\n        textcolor        color to draw labels (default black).\n        linewidth        line width for parallels (default 1.)\n        zorder           sets the zorder for parallels (if not specified,\n                         uses default zorder for matplotlib.lines.Line2D\n                         objects).\n        dashes           dash pattern for parallels (default [1,1], i.e.\n                         1 pixel on, 1 pixel off).\n        labels           list of 4 values (default [0,0,0,0]) that control\n                         whether parallels are labelled where they intersect\n                         the left, right, top or bottom of the plot. For\n                         example labels=[1,0,0,1] will cause parallels\n                         to be labelled where they intersect the left and\n                         and bottom of the plot, but not the right and top.\n        labelstyle       if set to \"+/-\", north and south latitudes are\n                         labelled with \"+\" and \"-\", otherwise they are\n                         labelled with \"N\" and \"S\".\n        fmt              a format string to format the parallel labels\n                         (default '%g') **or** a function that takes a\n                         latitude value in degrees as it's only argument\n                         and returns a formatted string.\n        xoffset          label offset from edge of map in x-direction\n                         (default is 0.01 times width of map in map\n                         projection coordinates).\n        yoffset          label offset from edge of map in y-direction\n                         (default is 0.01 times height of map in map\n                         projection coordinates).\n        ax               axes instance (overrides default axes instance)\n        latmax           absolute value of latitude to which meridians are drawn\n                         (default is 80).\n        \\**text_kwargs   additional keyword arguments controlling text\n                         for labels that are passed on to\n                         the text method of the axes instance (see\n                         matplotlib.pyplot.text documentation).\n        ==============   ====================================================\n\n        returns a dictionary whose keys are the parallel values, and\n        whose values are tuples containing lists of the\n        matplotlib.lines.Line2D and matplotlib.text.Text instances\n        associated with each parallel. Deleting an item from the\n        dictionary removes the corresponding parallel from the plot.\n        \"\"\"\n        text_kwargs['color']=textcolor # pass textcolor kwarg on to ax.text\n        # if celestial=True, don't use \"N\" and \"S\" labels.\n        if labelstyle is None and self.celestial:\n            labelstyle=\"+/-\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # don't draw meridians past latmax, always draw parallel at latmax.\n        if latmax is None: latmax = 80.\n        # offset for labels.\n        if yoffset is None:\n            yoffset = (self.urcrnry-self.llcrnry)/100.\n            if self.aspect > 1:\n                yoffset = self.aspect*yoffset\n            else:\n                yoffset = yoffset/self.aspect\n        if xoffset is None:\n            xoffset = (self.urcrnrx-self.llcrnrx)/100.\n\n        if self.projection in _cylproj + _pseudocyl:\n            lons = np.linspace(self.llcrnrlon, self.urcrnrlon, 10001)\n        elif self.projection in ['tmerc']:\n            lon_0 = self.projparams['lon_0']\n            # tmerc only defined within +/- 90 degrees of lon_0\n            lons = np.linspace(lon_0-90,lon_0+90,100001)\n        else:\n            lonmin = self.boundarylonmin; lonmax = self.boundarylonmax\n            lons = np.linspace(lonmin, lonmax, 10001)\n        # make sure latmax degree parallel is drawn if projection not merc or cyl or miller\n        try:\n            circlesl = list(circles)\n        except:\n            circlesl = circles\n        if self.projection not in _cylproj + _pseudocyl:\n            if max(circlesl) > 0 and latmax not in circlesl:\n                circlesl.append(latmax)\n            if min(circlesl) < 0 and -latmax not in circlesl:\n                circlesl.append(-latmax)\n        xdelta = 0.01*(self.xmax-self.xmin)\n        ydelta = 0.01*(self.ymax-self.ymin)\n        linecolls = {}\n        for circ in circlesl:\n            lats = circ*np.ones(len(lons),np.float32)\n            x,y = self(lons,lats)\n            # remove points outside domain.\n            # leave a little slop around edges (3*xdelta)\n            # don't really know why, but this appears to be needed to\n            # or lines sometimes don't reach edge of plot.\n            testx = np.logical_and(x>=self.xmin-3*xdelta,x<=self.xmax+3*xdelta)\n            x = np.compress(testx, x)\n            y = np.compress(testx, y)\n            testy = np.logical_and(y>=self.ymin-3*ydelta,y<=self.ymax+3*ydelta)\n            x = np.compress(testy, x)\n            y = np.compress(testy, y)\n            lines = []\n            if len(x) > 1 and len(y) > 1:\n                # split into separate line segments if necessary.\n                # (not necessary for cylindrical or pseudocylindricl projections)\n                xd = (x[1:]-x[0:-1])**2\n                yd = (y[1:]-y[0:-1])**2\n                dist = np.sqrt(xd+yd)\n                if self.projection not in ['cyl','rotpole']:\n                    split = dist > self.rmajor/10.\n                else:\n                    split = dist > 1.\n                if np.sum(split) and self.projection not in _cylproj:\n                    ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                    xl = []\n                    yl = []\n                    iprev = 0\n                    ind.append(len(xd))\n                    for i in ind:\n                        xl.append(x[iprev:i])\n                        yl.append(y[iprev:i])\n                        iprev = i\n                else:\n                    xl = [x]\n                    yl = [y]\n                # draw each line segment.\n                for x,y in zip(xl,yl):\n                    # skip if only a point.\n                    if len(x) > 1 and len(y) > 1:\n                        l = Line2D(x,y,linewidth=linewidth)\n                        l.set_color(color)\n                        l.set_dashes(dashes)\n                        l.set_label('_nolabel_')\n                        if zorder is not None:\n                            l.set_zorder(zorder)\n                        ax.add_line(l)\n                        lines.append(l)\n            linecolls[circ] = (lines,[])\n        # draw labels for parallels\n        # parallels not labelled for fulldisk orthographic or geostationary\n        if self.projection in ['ortho','geos','nsper','vandg','aeqd'] and max(labels):\n            if self.projection == 'vandg' or self._fulldisk:\n                sys.stdout.write('Warning: Cannot label parallels on %s basemap' % _projnames[self.projection])\n                labels = [0,0,0,0]\n        # search along edges of map to see if parallels intersect.\n        # if so, find x,y location of intersection and draw a label there.\n        dx = (self.xmax-self.xmin)/1000.\n        dy = (self.ymax-self.ymin)/1000.\n        if self.projection in _pseudocyl:\n            lon_0 = self.projparams['lon_0']\n        for dolab,side in zip(labels,['l','r','t','b']):\n            if not dolab: continue\n            # for cylindrical projections, don't draw parallels on top or bottom.\n            if self.projection in _cylproj + _pseudocyl and side in ['t','b']: continue\n            if side in ['l','r']:\n                nmax = int((self.ymax-self.ymin)/dy+1)\n                yy = np.linspace(self.llcrnry,self.urcrnry,nmax)\n                if side == 'l':\n                    if self.projection in _pseudocyl:\n                        lats = np.linspace(-89.99,89,99,nmax)\n                        if self.celestial:\n                            lons = (self.projparams['lon_0']+180.)*np.ones(len(lats),lats.dtype)\n                        else:\n                            lons = (self.projparams['lon_0']-180.)*np.ones(len(lats),lats.dtype)\n                        xx, yy = self(lons, lats)\n                    else:\n                        xx = self.llcrnrx*np.ones(yy.shape,yy.dtype)\n                        lons,lats = self(xx,yy,inverse=True)\n                        lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    if self.projection in _pseudocyl:\n                        lats = np.linspace(-89.99,89,99,nmax)\n                        if self.celestial:\n                           lons = (self.projparams['lon_0']-180.)*np.ones(len(lats),lats.dtype)\n                        else:\n                           lons = (self.projparams['lon_0']+180.)*np.ones(len(lats),lats.dtype)\n                        xx, yy = self(lons, lats)\n                    else:\n                        xx = self.urcrnrx*np.ones(yy.shape,yy.dtype)\n                        lons,lats = self(xx,yy,inverse=True)\n                        lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            else:\n                nmax = int((self.xmax-self.xmin)/dx+1)\n                xx = np.linspace(self.llcrnrx,self.urcrnrx,nmax)\n                if side == 'b':\n                    lons,lats = self(xx,self.llcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(xx,self.urcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            for lat in circles:\n                # don't label parallels for round polar plots\n                if self.round: continue\n                # find index of parallel (there may be two, so\n                # search from left and right).\n                nl = _searchlist(lats,lat)\n                nr = _searchlist(lats[::-1],lat)\n                if nr != -1: nr = len(lons)-nr-1\n                latlab = _setlatlab(fmt,lat,labelstyle)\n                # parallels can intersect each map edge twice.\n                for i,n in enumerate([nl,nr]):\n                    # don't bother if close to the first label.\n                    if i and abs(nr-nl) < 100: continue\n                    if n >= 0:\n                        t = None\n                        if side == 'l':\n                            if self.projection in _pseudocyl:\n                                if self.celestial:\n                                    xlab,ylab = self(lon_0+179.9,lat)\n                                else:\n                                    xlab,ylab = self(lon_0-179.9,lat)\n                            else:\n                                xlab = self.llcrnrx\n                            xlab = xlab-xoffset\n                            if self.projection in _pseudocyl:\n                                if lat>0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='bottom',**text_kwargs)\n                                elif lat<0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='top',**text_kwargs)\n                                else:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                            else:\n                               t=ax.text(xlab,yy[n],latlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                        elif side == 'r':\n                            if self.projection in _pseudocyl:\n                                if self.celestial:\n                                   xlab,ylab = self(lon_0-179.9,lat)\n                                else:\n                                   xlab,ylab = self(lon_0+179.9,lat)\n                            else:\n                                xlab = self.urcrnrx\n                            xlab = xlab+xoffset\n                            if self.projection in _pseudocyl:\n                                if lat>0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='bottom',**text_kwargs)\n                                elif lat<0:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='top',**text_kwargs)\n                                else:\n                                   t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                            else:\n                               t=ax.text(xlab,yy[n],latlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                        elif side == 'b':\n                            t = ax.text(xx[n],self.llcrnry-yoffset,latlab,horizontalalignment='center',verticalalignment='top',**text_kwargs)\n                        else:\n                            t = ax.text(xx[n],self.urcrnry+yoffset,latlab,horizontalalignment='center',verticalalignment='bottom',**text_kwargs)\n                        if t is not None: linecolls[lat][1].append(t)\n\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        keys = list(linecolls.keys()); vals = list(linecolls.values())\n        for k,v in zip(keys,vals):\n            if v == ([], []):\n                del linecolls[k]\n            # add a remove method to each tuple.\n            else:\n                linecolls[k] = _tup(linecolls[k])\n        # override __delitem__ in dict to call remove() on values.\n        pardict = _dict(linecolls)\n        # clip parallels for round polar plots (and delete labels).\n        for lines, _ in pardict.values():\n            self._cliplimb(ax, lines)\n        return pardict",
  "def drawmeridians(self,meridians,color='k',textcolor='k',linewidth=1., zorder=None,\\\n                      dashes=[1,1],labels=[0,0,0,0],labelstyle=None,\\\n                      fmt='%g',xoffset=None,yoffset=None,ax=None,latmax=None,\n                      **text_kwargs):\n        \"\"\"\n        Draw and label meridians (longitude lines) for values (in degrees)\n        given in the sequence ``meridians``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        color            color to draw meridians (default black).\n        textcolor        color to draw labels (default black).\n        linewidth        line width for meridians (default 1.)\n        zorder           sets the zorder for meridians (if not specified,\n                         uses default zorder for matplotlib.lines.Line2D\n                         objects).\n        dashes           dash pattern for meridians (default [1,1], i.e.\n                         1 pixel on, 1 pixel off).\n        labels           list of 4 values (default [0,0,0,0]) that control\n                         whether meridians are labelled where they intersect\n                         the left, right, top or bottom of the plot. For\n                         example labels=[1,0,0,1] will cause meridians\n                         to be labelled where they intersect the left and\n                         and bottom of the plot, but not the right and top.\n        labelstyle       if set to \"+/-\", east and west longitudes are\n                         labelled with \"+\" and \"-\", otherwise they are\n                         labelled with \"E\" and \"W\".\n        fmt              a format string to format the meridian labels\n                         (default '%g') **or** a function that takes a\n                         longitude value in degrees as it's only argument\n                         and returns a formatted string.\n        xoffset          label offset from edge of map in x-direction\n                         (default is 0.01 times width of map in map\n                         projection coordinates).\n        yoffset          label offset from edge of map in y-direction\n                         (default is 0.01 times height of map in map\n                         projection coordinates).\n        ax               axes instance (overrides default axes instance)\n        latmax           absolute value of latitude to which meridians are drawn\n                         (default is 80).\n        \\**text_kwargs   additional keyword arguments controlling text\n                         for labels that are passed on to\n                         the text method of the axes instance (see\n                         matplotlib.pyplot.text documentation).\n        ==============   ====================================================\n\n        returns a dictionary whose keys are the meridian values, and\n        whose values are tuples containing lists of the\n        matplotlib.lines.Line2D and matplotlib.text.Text instances\n        associated with each meridian. Deleting an item from the\n        dictionary removes the correpsonding meridian from the plot.\n        \"\"\"\n        text_kwargs['color']=textcolor # pass textcolor kwarg on to ax.text\n        # for cylindrical projections, try to handle wraparound (i.e. if\n        # projection is defined in -180 to 0 and user asks for meridians from\n        # 180 to 360 to be drawn, it should work)\n        if self.projection in _cylproj or self.projection in _pseudocyl:\n            def addlon(meridians,madd):\n                minside = (madd >= self.llcrnrlon and madd <= self.urcrnrlon)\n                if minside and madd not in meridians: meridians.append(madd)\n                return meridians\n            merids = list(meridians)\n            meridians = []\n            for m in merids:\n                meridians = addlon(meridians,m)\n                meridians = addlon(meridians,m+360)\n                meridians = addlon(meridians,m-360)\n            meridians.sort()\n        # if celestial=True, don't use \"E\" and \"W\" labels.\n        if labelstyle is None and self.celestial:\n            labelstyle=\"+/-\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # don't draw meridians past latmax, always draw parallel at latmax.\n        if latmax is None: latmax = 80. # unused w/ cyl, merc or miller proj.\n        # offset for labels.\n        if yoffset is None:\n            yoffset = (self.urcrnry-self.llcrnry)/100.\n            if self.aspect > 1:\n                yoffset = self.aspect*yoffset\n            else:\n                yoffset = yoffset/self.aspect\n        if xoffset is None:\n            xoffset = (self.urcrnrx-self.llcrnrx)/100.\n\n        lats = np.linspace(self.latmin,self.latmax,10001)\n        if self.projection not in _cylproj + _pseudocyl:\n            testlat = np.logical_and(lats>-latmax,lats<latmax)\n            lats = np.compress(testlat,lats)\n\n        xdelta = 0.01*(self.xmax-self.xmin)\n        ydelta = 0.01*(self.ymax-self.ymin)\n        linecolls = {}\n        for merid in meridians:\n            lons = merid*np.ones(len(lats),np.float32)\n            x,y = self(lons,lats)\n            # remove points outside domain.\n            # leave a little slop around edges (3*xdelta)\n            # don't really know why, but this appears to be needed to\n            # or lines sometimes don't reach edge of plot.\n            testx = np.logical_and(x>=self.xmin-3*xdelta,x<=self.xmax+3*xdelta)\n            x = np.compress(testx, x)\n            y = np.compress(testx, y)\n            testy = np.logical_and(y>=self.ymin-3*ydelta,y<=self.ymax+3*ydelta)\n            x = np.compress(testy, x)\n            y = np.compress(testy, y)\n            lines = []\n            if len(x) > 1 and len(y) > 1:\n                # split into separate line segments if necessary.\n                # (not necessary for mercator or cylindrical or miller).\n                xd = (x[1:]-x[0:-1])**2\n                yd = (y[1:]-y[0:-1])**2\n                dist = np.sqrt(xd+yd)\n                if self.projection not in ['cyl','rotpole']:\n                    split = dist > self.rmajor/10.\n                else:\n                    split = dist > 1.\n                if np.sum(split) and self.projection not in _cylproj:\n                    ind = (np.compress(split,np.squeeze(split*np.indices(xd.shape)))+1).tolist()\n                    xl = []\n                    yl = []\n                    iprev = 0\n                    ind.append(len(xd))\n                    for i in ind:\n                        xl.append(x[iprev:i])\n                        yl.append(y[iprev:i])\n                        iprev = i\n                else:\n                    xl = [x]\n                    yl = [y]\n                # draw each line segment.\n                for x,y in zip(xl,yl):\n                    # skip if only a point.\n                    if len(x) > 1 and len(y) > 1:\n                        l = Line2D(x,y,linewidth=linewidth)\n                        l.set_color(color)\n                        l.set_dashes(dashes)\n                        l.set_label('_nolabel_')\n                        if zorder is not None:\n                            l.set_zorder(zorder)\n                        ax.add_line(l)\n                        lines.append(l)\n            linecolls[merid] = (lines,[])\n        # draw labels for meridians.\n        # meridians not labelled for sinusoidal, hammer, mollweide,\n        # VanDerGrinten or full-disk orthographic/geostationary.\n        if self.projection in ['sinu','moll','hammer','vandg'] and max(labels):\n            sys.stdout.write('Warning: Cannot label meridians on %s basemap' % _projnames[self.projection])\n            labels = [0,0,0,0]\n        if self.projection in ['ortho','geos','nsper','aeqd'] and max(labels):\n            if self._fulldisk and self.boundinglat is None:\n                sys.stdout.write(\" \".join([\n                    \"Warning: Cannot label meridians on full-disk Geostationary,\"\n                    \"Orthographic or Azimuthal equidistant basemap\"]))\n                labels = [0,0,0,0]\n        # search along edges of map to see if parallels intersect.\n        # if so, find x,y location of intersection and draw a label there.\n        dx = (self.xmax-self.xmin)/1000.\n        dy = (self.ymax-self.ymin)/1000.\n        if self.projection in _pseudocyl:\n            lon_0 = self.projparams['lon_0']\n            xmin,ymin = self(lon_0-179.9,-90)\n            xmax,ymax = self(lon_0+179.9,90)\n        for dolab,side in zip(labels,['l','r','t','b']):\n            if not dolab or self.round: continue\n            # for cylindrical projections, don't draw meridians on left or right.\n            if self.projection in _cylproj + _pseudocyl and side in ['l','r']: continue\n            if side in ['l','r']:\n                nmax = int((self.ymax-self.ymin)/dy+1)\n                yy = np.linspace(self.llcrnry,self.urcrnry,nmax)\n                if side == 'l':\n                    lons,lats = self(self.llcrnrx*np.ones(yy.shape,np.float32),yy,inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(self.urcrnrx*np.ones(yy.shape,np.float32),yy,inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            else:\n                nmax = int((self.xmax-self.xmin)/dx+1)\n                if self.projection in _pseudocyl:\n                    xx = np.linspace(xmin,xmax,nmax)\n                else:\n                    xx = np.linspace(self.llcrnrx,self.urcrnrx,nmax)\n                if side == 'b':\n                    lons,lats = self(xx,self.llcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                else:\n                    lons,lats = self(xx,self.urcrnry*np.ones(xx.shape,np.float32),inverse=True)\n                    lons = lons.tolist(); lats = lats.tolist()\n                if max(lons) > 1.e20 or max(lats) > 1.e20:\n                    raise ValueError('inverse transformation undefined - please adjust the map projection region')\n                # adjust so 0 <= lons < 360\n                lons = [(lon+360) % 360 for lon in lons]\n            for lon in meridians:\n                # adjust so 0 <= lon < 360\n                lon2 = (lon+360) % 360\n                # find index of meridian (there may be two, so\n                # search from left and right).\n                nl = _searchlist(lons,lon2)\n                nr = _searchlist(lons[::-1],lon2)\n                if nr != -1: nr = len(lons)-nr-1\n                lonlab = _setlonlab(fmt,lon2,labelstyle)\n                # meridians can intersect each map edge twice.\n                for i,n in enumerate([nl,nr]):\n                    lat = lats[n]/100.\n                    # no meridians > latmax for projections other than merc,cyl,miller.\n                    if self.projection not in _cylproj and lat > latmax: continue\n                    # don't bother if close to the first label.\n                    if i and abs(nr-nl) < 100: continue\n                    if n >= 0:\n                        t = None\n                        if side == 'l':\n                            t = ax.text(self.llcrnrx-xoffset,yy[n],lonlab,horizontalalignment='right',verticalalignment='center',**text_kwargs)\n                        elif side == 'r':\n                            t = ax.text(self.urcrnrx+xoffset,yy[n],lonlab,horizontalalignment='left',verticalalignment='center',**text_kwargs)\n                        elif side == 'b':\n                            t = ax.text(xx[n],self.llcrnry-yoffset,lonlab,horizontalalignment='center',verticalalignment='top',**text_kwargs)\n                        else:\n                            t = ax.text(xx[n],self.urcrnry+yoffset,lonlab,horizontalalignment='center',verticalalignment='bottom',**text_kwargs)\n\n                        if t is not None: linecolls[lon][1].append(t)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # remove empty values from linecolls dictionary\n        keys = list(linecolls.keys()); vals = list(linecolls.values())\n        for k,v in zip(keys,vals):\n            if v == ([], []):\n                del linecolls[k]\n            else:\n            # add a remove method to each tuple.\n                linecolls[k] = _tup(linecolls[k])\n        # override __delitem__ in dict to call remove() on values.\n        meridict = _dict(linecolls)\n        # for round polar plots, clip meridian lines and label them.\n        if self.round:\n            # label desired?\n            label = False\n            for lab in labels:\n                if lab: label = True\n            for merid in meridict:\n                if not label: continue\n                # label\n                lonlab = _setlonlab(fmt,merid,labelstyle)\n                x,y = self(merid,self.boundinglat)\n                r = np.sqrt((x-0.5*(self.xmin+self.xmax))**2+\n                            (y-0.5*(self.ymin+self.ymax))**2)\n                r = r + np.sqrt(xoffset**2+yoffset**2)\n                if self.projection.startswith('np'):\n                    pole = 1\n                elif self.projection.startswith('sp'):\n                    pole = -1\n                elif self.projection == 'ortho' and self.round:\n                    pole = 1\n                if pole == 1:\n                    theta = (np.pi/180.)*(merid-self.projparams['lon_0']-90)\n                    if self.projection == 'ortho' and\\\n                       self.projparams['lat_0'] == -90:\n                        theta = (np.pi/180.)*(-merid+self.projparams['lon_0']+90)\n                    x = r*np.cos(theta)+0.5*(self.xmin+self.xmax)\n                    y = r*np.sin(theta)+0.5*(self.ymin+self.ymax)\n                    if x > 0.5*(self.xmin+self.xmax)+xoffset:\n                        horizalign = 'left'\n                    elif x < 0.5*(self.xmin+self.xmax)-xoffset:\n                        horizalign = 'right'\n                    else:\n                        horizalign = 'center'\n                    if y > 0.5*(self.ymin+self.ymax)+yoffset:\n                        vertalign = 'bottom'\n                    elif y < 0.5*(self.ymin+self.ymax)-yoffset:\n                        vertalign = 'top'\n                    else:\n                        vertalign = 'center'\n                    # labels [l,r,t,b]\n                    if labels[0] and not labels[1] and x >= 0.5*(self.xmin+self.xmax)+xoffset: continue\n                    if labels[1] and not labels[0] and x <= 0.5*(self.xmin+self.xmax)-xoffset: continue\n                    if labels[2] and not labels[3] and y <= 0.5*(self.ymin+self.ymax)-yoffset: continue\n                    if labels[3] and not labels[2]and y >= 0.5*(self.ymin+self.ymax)+yoffset: continue\n                elif pole == -1:\n                    theta = (np.pi/180.)*(-merid+self.projparams['lon_0']+90)\n                    x = r*np.cos(theta)+0.5*(self.xmin+self.xmax)\n                    y = r*np.sin(theta)+0.5*(self.ymin+self.ymax)\n                    if x > 0.5*(self.xmin+self.xmax)-xoffset:\n                        horizalign = 'right'\n                    elif x < 0.5*(self.xmin+self.xmax)+xoffset:\n                        horizalign = 'left'\n                    else:\n                        horizalign = 'center'\n                    if y > 0.5*(self.ymin+self.ymax)-yoffset:\n                        vertalign = 'top'\n                    elif y < 0.5*(self.ymin+self.ymax)+yoffset:\n                        vertalign = 'bottom'\n                    else:\n                        vertalign = 'center'\n                    # labels [l,r,t,b]\n                    if labels[0] and not labels[1] and x <=  0.5*(self.xmin+self.xmax)+xoffset: continue\n                    if labels[1] and not labels[0] and x >=  0.5*(self.xmin+self.xmax)-xoffset: continue\n                    if labels[2] and not labels[3] and y >=  0.5*(self.ymin+self.ymax)-yoffset: continue\n                    if labels[3] and not labels[2] and y <=  0.5*(self.ymin+self.ymax)+yoffset: continue\n                t=ax.text(x,y,lonlab,horizontalalignment=horizalign,verticalalignment=vertalign,**text_kwargs)\n                meridict[merid][1].append(t)\n        for lines, _ in meridict.values():\n            self._cliplimb(ax, lines)\n        return meridict",
  "def tissot(self,lon_0,lat_0,radius_deg,npts,ax=None,**kwargs):\n        \"\"\"\n        Draw a polygon centered at ``lon_0,lat_0``.  The polygon\n        approximates a circle on the surface of the earth with radius\n        ``radius_deg`` degrees latitude along longitude ``lon_0``,\n        made up of ``npts`` vertices.\n        The polygon represents a Tissot's indicatrix\n        (http://en.wikipedia.org/wiki/Tissot's_Indicatrix),\n        which when drawn on a map shows the distortion\n        inherent in the map projection.\n\n        .. note::\n         Cannot handle situations in which the polygon intersects\n         the edge of the map projection domain, and then re-enters the domain.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.patches.Polygon.\n\n        returns a matplotlib.patches.Polygon object.\"\"\"\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        g = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = g.inv(lon_0,lat_0,lon_0,lat_0+radius_deg)\n        seg = [self(lon_0,lat_0+radius_deg)]\n        delaz = 360./npts\n        az = az12\n        for n in range(npts):\n            az = az+delaz\n            lon, lat, az21 = g.fwd(lon_0, lat_0, az, dist)\n            x,y = self(lon,lat)\n            # add segment if it is in the map projection region.\n            if x < 1.e20 and y < 1.e20:\n                seg.append((x,y))\n        poly = Polygon(seg,**kwargs)\n        ax.add_patch(poly)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip polygons to map limbs\n        poly,c = self._cliplimb(ax,poly)\n        return poly",
  "def gcpoints(self,lon1,lat1,lon2,lat2,npoints):\n        \"\"\"\n        compute ``points`` points along a great circle with endpoints\n        ``(lon1,lat1)`` and ``(lon2,lat2)``.\n\n        Returns arrays x,y with map projection coordinates.\n        \"\"\"\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        lonlats = gc.npts(lon1,lat1,lon2,lat2,npoints-2)\n        lons=[lon1];lats=[lat1]\n        for lon,lat in lonlats:\n            lons.append(lon); lats.append(lat)\n        lons.append(lon2); lats.append(lat2)\n        x, y = self(lons, lats)\n        return x,y",
  "def drawgreatcircle(self,lon1,lat1,lon2,lat2,del_s=100.,**kwargs):\n        \"\"\"\n        Draw a great circle on the map from the longitude-latitude\n        pair ``lon1,lat1`` to ``lon2,lat2``\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   =======================================================\n        Keyword          Description\n        ==============   =======================================================\n        del_s            points on great circle computed every del_s kilometers\n                         (default 100).\n        \\**kwargs        other keyword arguments are passed on to :meth:`plot`\n                         method of Basemap instance.\n        ==============   =======================================================\n\n        Returns a list with a single ``matplotlib.lines.Line2D`` object like a\n        call to ``pyplot.plot()``.\n        \"\"\"\n        # use great circle formula for a perfect sphere.\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = gc.inv(lon1,lat1,lon2,lat2)\n        npoints = int((dist+0.5*1000.*del_s)/(1000.*del_s))\n        lonlats = gc.npts(lon1,lat1,lon2,lat2,npoints)\n        lons = [lon1]; lats = [lat1]\n        for lon, lat in lonlats:\n            lons.append(lon)\n            lats.append(lat)\n        lons.append(lon2); lats.append(lat2)\n        x, y = self(lons, lats)\n\n        # Correct wrap around effect of great circles\n\n        # get points\n        _p = self.plot(x,y,**kwargs)\n        p = _p[0].get_path()\n\n        # since we know the difference between any two points, we can use this to find wrap arounds on the plot\n        max_dist = 1000*del_s*2\n\n        # calculate distances and compare with max allowable distance\n        dists = np.abs(np.diff(p.vertices[:,0]))\n        cuts = np.where( dists > max_dist )[0]\n\n        # if there are any cut points, cut them and begin again at the next point\n        for i,k in enumerate(cuts):\n            # vertex to cut at\n            cut_point = cuts[i]\n\n            # create new vertices with a nan inbetween and set those as the path's vertices\n            verts = np.concatenate(\n                                       [p.vertices[:cut_point, :],\n                                        [[np.nan, np.nan]],\n                                        p.vertices[cut_point+1:, :]]\n                                       )\n            p.codes = None\n            p.vertices = verts\n\n        return _p",
  "def transform_scalar(self,datin,lons,lats,nx,ny,returnxy=False,checkbounds=False,order=1,masked=False):\n        \"\"\"\n        Interpolate a scalar field (``datin``) from a lat/lon grid with\n        longitudes = ``lons`` and latitudes = ``lats`` to a ``ny`` by ``nx``\n        map projection grid.  Typically used to transform data to\n        map projection coordinates for plotting on a map with\n        the :meth:`imshow`.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Argument         Description\n        ==============   ====================================================\n        datin            input data on a lat/lon grid.\n        lons, lats       rank-1 arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cea``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        nx, ny           The size of the output regular grid in map\n                         projection coordinates\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        returnxy         If True, the x and y values of the map\n                         projection grid are also returned (Default False).\n        checkbounds      If True, values of lons and lats are checked to see\n                         that they lie within the map projection region.\n                         Default is False, and data outside map projection\n                         region is clipped to values on boundary.\n        masked           If True, interpolated data is returned as a masked\n                         array with values outside map projection region\n                         masked (Default False).\n        order            0 for nearest-neighbor interpolation, 1 for\n                         bilinear, 3 for cubic spline (Default 1).\n                         Cubic spline interpolation requires scipy.ndimage.\n        ==============   ====================================================\n\n        Returns ``datout`` (data on map projection grid).\n        If returnxy=True, returns ``data,x,y``.\n        \"\"\"\n        # check that lons, lats increasing\n        delon = lons[1:]-lons[0:-1]\n        delat = lats[1:]-lats[0:-1]\n        if min(delon) < 0. or min(delat) < 0.:\n            raise ValueError('lons and lats must be increasing!')\n        # check that lons in -180,180 for non-cylindrical projections.\n        if self.projection not in _cylproj:\n            lonsa = np.array(lons)\n            count = np.sum(lonsa < -180.00001) + np.sum(lonsa > 180.00001)\n            if count > 1:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n            # allow for wraparound point to be outside.\n            elif count == 1 and math.fabs(lons[-1]-lons[0]-360.) > 1.e-4:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n        if returnxy:\n            lonsout, latsout, x, y = self.makegrid(nx,ny,returnxy=True)\n        else:\n            lonsout, latsout = self.makegrid(nx,ny)\n        datout = interp(datin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        if returnxy:\n            return datout, x, y\n        else:\n            return datout",
  "def transform_vector(self,uin,vin,lons,lats,nx,ny,returnxy=False,checkbounds=False,order=1,masked=False):\n        \"\"\"\n        Rotate and interpolate a vector field (``uin,vin``) from a\n        lat/lon grid with longitudes = ``lons`` and latitudes = ``lats``\n        to a ``ny`` by ``nx`` map projection grid.\n\n        The input vector field is defined in spherical coordinates (it\n        has eastward and northward components) while the output\n        vector field is rotated to map projection coordinates (relative\n        to x and y). The magnitude of the vector is preserved.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        uin, vin         input vector field on a lat/lon grid.\n        lons, lats       rank-1 arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cea``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        nx, ny           The size of the output regular grid in map\n                         projection coordinates\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keyword          Description\n        ==============   ====================================================\n        returnxy         If True, the x and y values of the map\n                         projection grid are also returned (Default False).\n        checkbounds      If True, values of lons and lats are checked to see\n                         that they lie within the map projection region.\n                         Default is False, and data outside map projection\n                         region is clipped to values on boundary.\n        masked           If True, interpolated data is returned as a masked\n                         array with values outside map projection region\n                         masked (Default False).\n        order            0 for nearest-neighbor interpolation, 1 for\n                         bilinear, 3 for cubic spline (Default 1).\n                         Cubic spline interpolation requires scipy.ndimage.\n        ==============   ====================================================\n\n        Returns ``uout, vout`` (vector field on map projection grid).\n        If returnxy=True, returns ``uout,vout,x,y``.\n        \"\"\"\n        # check that lons, lats increasing\n        delon = lons[1:]-lons[0:-1]\n        delat = lats[1:]-lats[0:-1]\n        if min(delon) < 0. or min(delat) < 0.:\n            raise ValueError('lons and lats must be increasing!')\n        # check that lons in -180,180 for non-cylindrical projections.\n        if self.projection not in _cylproj:\n            lonsa = np.array(lons)\n            count = np.sum(lonsa < -180.00001) + np.sum(lonsa > 180.00001)\n            if count > 1:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n            # allow for wraparound point to be outside.\n            elif count == 1 and math.fabs(lons[-1]-lons[0]-360.) > 1.e-4:\n                raise ValueError('grid must be shifted so that lons are monotonically increasing and fit in range -180,+180 (see shiftgrid function)')\n        lonsout, latsout, x, y = self.makegrid(nx,ny,returnxy=True)\n        # interpolate to map projection coordinates.\n        uin = interp(uin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        vin = interp(vin,lons,lats,lonsout,latsout,checkbounds=checkbounds,order=order,masked=masked)\n        # rotate from geographic to map coordinates.\n        return self.rotate_vector(uin,vin,lonsout,latsout,returnxy=returnxy)",
  "def rotate_vector(self,uin,vin,lons,lats,returnxy=False):\n        \"\"\"\n        Rotate a vector field (``uin,vin``) on a rectilinear grid\n        with longitudes = ``lons`` and latitudes = ``lats`` from\n        geographical (lat/lon) into map projection (x/y) coordinates.\n\n        Differs from transform_vector in that no interpolation is done.\n        The vector is returned on the same grid, but rotated into\n        x,y coordinates.\n\n        The input vector field is defined in spherical coordinates (it\n        has eastward and northward components) while the output\n        vector field is rotated to map projection coordinates (relative\n        to x and y). The magnitude of the vector is preserved.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        uin, vin         input vector field on a lat/lon grid.\n        lons, lats       Arrays containing longitudes and latitudes\n                         (in degrees) of input data in increasing order.\n                         For non-cylindrical projections (those other than\n                         ``cyl``, ``merc``, ``cyl``, ``gall`` and ``mill``) lons\n                         must fit within range -180 to 180.\n        ==============   ====================================================\n\n        Returns ``uout, vout`` (rotated vector field).\n        If the optional keyword argument\n        ``returnxy`` is True (default is False),\n        returns ``uout,vout,x,y`` (where ``x,y`` are the map projection\n        coordinates of the grid defined by ``lons,lats``).\n        \"\"\"\n        # if lons,lats are 1d and uin,vin are 2d, and\n        # lats describes 1st dim of uin,vin, and\n        # lons describes 2nd dim of uin,vin, make lons,lats 2d\n        # with meshgrid.\n        if lons.ndim == lats.ndim == 1 and uin.ndim == vin.ndim == 2 and\\\n           uin.shape[1] == vin.shape[1] == lons.shape[0] and\\\n           uin.shape[0] == vin.shape[0] == lats.shape[0]:\n            lons, lats = np.meshgrid(lons, lats)\n        else:\n            if not lons.shape == lats.shape == uin.shape == vin.shape:\n                raise TypeError(\"shapes of lons,lats and uin,vin don't match\")\n        x, y = self(lons, lats)\n        # rotate from geographic to map coordinates.\n        if ma.isMaskedArray(uin):\n            mask = ma.getmaskarray(uin)\n            masked = True\n            uin = uin.filled(1)\n            vin = vin.filled(1)\n        else:\n            masked = False\n\n        # Map the (lon, lat) vector in the complex plane.\n        uvc = uin + 1j*vin\n        uvmag = np.abs(uvc)\n        theta = np.angle(uvc)\n\n        # Define a displacement (dlon, dlat) that moves all\n        # positions (lons, lats) a small distance in the\n        # direction of the original vector.\n        dc = 1E-5 * np.exp(theta*1j)\n        dlat = dc.imag * np.cos(np.radians(lats))\n        dlon = dc.real\n\n        # Deal with displacements that overshoot the North or South Pole.\n        farnorth = np.abs(lats+dlat) >= 90.0\n        somenorth = farnorth.any()\n        if somenorth:\n            dlon[farnorth] *= -1.0\n            dlat[farnorth] *= -1.0\n\n        # Add displacement to original location and find the native coordinates.\n        lon1 = lons + dlon\n        lat1 = lats + dlat\n        xn, yn = self(lon1, lat1)\n\n        # Determine the angle of the displacement in the native coordinates.\n        vecangle = np.arctan2(yn-y, xn-x)\n        if somenorth:\n            vecangle[farnorth] += np.pi\n\n        # Compute the x-y components of the original vector.\n        uvcout = uvmag * np.exp(1j*vecangle)\n        uout = uvcout.real\n        vout = uvcout.imag\n\n        if masked:\n            uout = ma.array(uout, mask=mask)\n            vout = ma.array(vout, mask=mask)\n        if returnxy:\n            return uout,vout,x,y\n        else:\n            return uout,vout",
  "def set_axes_limits(self,ax=None):\n        \"\"\"\n        Final step in Basemap method wrappers of Axes plotting methods:\n\n        Set axis limits, fix aspect ratio for map domain using current\n        or specified axes instance.  This is done only once per axes\n        instance.\n\n        In interactive mode, this method always calls draw_if_interactive\n        before returning.\n\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n\n        # If we have already set the axes limits, and if the user\n        # has not defeated this by turning autoscaling back on,\n        # then all we need to do is plot if interactive.\n        if (hash(ax) in self._initialized_axes\n                                 and not ax.get_autoscalex_on()\n                                 and not ax.get_autoscaley_on()):\n            if mpl.is_interactive():\n                import matplotlib.pyplot as plt\n                plt.draw_if_interactive()\n            return\n\n        self._initialized_axes.add(hash(ax))\n        # Take control of axis scaling:\n        ax.set_autoscale_on(False)\n        # update data limits for map domain.\n        corners = ((self.llcrnrx, self.llcrnry), (self.urcrnrx, self.urcrnry))\n        ax.update_datalim(corners)\n        ax.set_xlim((self.llcrnrx, self.urcrnrx))\n        ax.set_ylim((self.llcrnry, self.urcrnry))\n        # if map boundary not yet drawn for elliptical maps, draw it with default values.\n        if not self._mapboundarydrawn or self._mapboundarydrawn not in ax.patches:\n            # elliptical map, draw boundary manually.\n            if ((self.projection in ['ortho', 'geos', 'nsper', 'aeqd'] and\n                    self._fulldisk) or self.round or\n                    self.projection in _pseudocyl):\n                # first draw boundary, no fill\n                limb1 = self.drawmapboundary(fill_color='none', ax=ax)\n                # draw another filled patch, with no boundary.\n                limb2 = self.drawmapboundary(linewidth=0, ax=ax)\n                self._mapboundarydrawn = limb2\n        # for elliptical map, always turn off axis_frame.\n        if ((self.projection in ['ortho', 'geos', 'nsper', 'aeqd'] and\n                self._fulldisk) or self.round or\n                self.projection in _pseudocyl):\n            # turn off axes frame.\n            ax.set_frame_on(False)\n        # make sure aspect ratio of map preserved.\n        # plot is re-centered in bounding rectangle.\n        # (anchor instance var determines where plot is placed)\n        if self.fix_aspect:\n            ax.set_aspect('equal',anchor=self.anchor)\n        else:\n            ax.set_aspect('auto',anchor=self.anchor)\n        # make sure axis ticks are turned off.\n        if self.noticks:\n            ax.set_xticks([])\n            ax.set_yticks([])\n        # force draw if in interactive mode.\n        if mpl.is_interactive():\n            import matplotlib.pyplot as plt\n            plt.draw_if_interactive()",
  "def _save_use_hold(self, ax, kwargs):\n        h = kwargs.pop('hold', None)\n        if hasattr(ax, '_hold'):\n            self._tmp_hold = ax._hold\n            if h is not None:\n                ax._hold = h",
  "def _restore_hold(self, ax):\n        if hasattr(ax, '_hold'):\n            ax._hold = self._tmp_hold",
  "def scatter(self, *args, **kwargs):\n        \"\"\"\n        Plot points with markers on the map\n        (see matplotlib.pyplot.scatter documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axes instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.scatter.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.scatter(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret",
  "def plot(self, *args, **kwargs):\n        \"\"\"\n        Draw lines and/or markers on the map\n        (see matplotlib.pyplot.plot documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.plot.\n        \"\"\"\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.plot(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret",
  "def imshow(self, *args, **kwargs):\n        \"\"\"\n        Display an image over the map\n        (see matplotlib.pyplot.imshow documentation).\n\n        ``extent`` and ``origin`` keywords set automatically so image\n        will be drawn over map region.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.plot.\n\n        returns an matplotlib.image.AxesImage instance.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        kwargs['extent']=(self.llcrnrx,self.urcrnrx,self.llcrnry,self.urcrnry)\n        # use origin='lower', unless overridden.\n        if 'origin' not in kwargs:\n            kwargs['origin']='lower'\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.imshow(*args, **kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip image to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret",
  "def pcolor(self,x,y,data,**kwargs):\n        \"\"\"\n        Make a pseudo-color plot over the map\n        (see matplotlib.pyplot.pcolor documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        If x or y are outside projection limb (i.e. they have values > 1.e20)\n        they will be convert to masked arrays with those values masked.\n        As a result, those values will not be plotted.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tripcolor is used.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.pcolor (or tripcolor if\n        ``tri=True``).\n\n        Note: (taken from matplotlib.pyplot.pcolor documentation)\n        Ideally the dimensions of x and y should be one greater than those of data;\n        if the dimensions are the same, then the last row and column of data will be ignored.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.pop('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<1.e20,y<1.e20)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    ret = ax.tripcolor(triang,data,**kwargs)\n                else:\n                    ret = ax.tripcolor(x,y,data,**kwargs)\n            else:\n                # make x,y masked arrays\n                # (masked where data is outside of projection limb)\n                x = ma.masked_values(np.where(x > 1.e20,1.e20,x), 1.e20)\n                y = ma.masked_values(np.where(y > 1.e20,1.e20,y), 1.e20)\n                ret = ax.pcolor(x,y,data,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        if self.round:\n            # for some reason, frame gets turned on.\n            ax.set_frame_on(False)\n        return ret",
  "def pcolormesh(self,x,y,data,**kwargs):\n        \"\"\"\n        Make a pseudo-color plot over the map\n        (see matplotlib.pyplot.pcolormesh documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.pcolormesh.\n\n        Note: (taken from matplotlib.pyplot.pcolor documentation)\n        Ideally the dimensions of x and y should be one greater than those of data;\n        if the dimensions are the same, then the last row and column of data will be ignored.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        # fix for invalid grid points\n        if ((np.any(x > 1e20) or np.any(y > 1e20)) and\n            x.ndim == 2 and y.ndim == 2):\n            if x.shape != y.shape:\n                raise ValueError('pcolormesh: x and y need same dimension')\n            nx,ny = x.shape\n            if nx < data.shape[0] or ny < data.shape[1]:\n                raise ValueError('pcolormesh: data dimension needs to be at least that of x and y.')\n            mask = (\n                (x[:-1,:-1] > 1e20) |\n                (x[1:,:-1] > 1e20) |\n                (x[:-1,1:] > 1e20) |\n                (x[1:,1:] > 1e20) |\n                (y[:-1,:-1] > 1e20) |\n                (y[1:,:-1] > 1e20) |\n                (y[:-1,1:] > 1e20) |\n                (y[1:,1:] > 1e20)\n                )\n            # we do not want to overwrite original array\n            data = data[:nx-1,:ny-1].copy()\n            data[mask] = np.nan\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.pcolormesh(x,y,data,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        if self.round:\n            # for some reason, frame gets turned on.\n            ax.set_frame_on(False)\n        return ret",
  "def hexbin(self,x,y,**kwargs):\n        \"\"\"\n        Make a hexagonal binning plot of x versus y, where x, y are 1-D\n        sequences of the same length, N. If C is None (the default), this is a\n        histogram of the number of occurences of the observations at\n        (x[i],y[i]).\n\n        If C is specified, it specifies values at the coordinate (x[i],y[i]).\n        These values are accumulated for each hexagonal bin and then reduced\n        according to reduce_C_function, which defaults to the numpy mean function\n        (np.mean). (If C is specified, it must also be a 1-D sequence of the\n        same length as x and y.)\n\n        x, y and/or C may be masked arrays, in which case only unmasked points\n        will be plotted.\n\n        (see matplotlib.pyplot.hexbin documentation).\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\**kwargs passed on to matplotlib.pyplot.hexbin\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            # make x,y masked arrays\n            # (masked where data is outside of projection limb)\n            x = ma.masked_values(np.where(x > 1.e20,1.e20,x), 1.e20)\n            y = ma.masked_values(np.where(y > 1.e20,1.e20,y), 1.e20)\n            ret = ax.hexbin(x,y,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret",
  "def contour(self,x,y,data,*args,**kwargs):\n        \"\"\"\n        Make a contour plot over the map\n        (see matplotlib.pyplot.contour documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tricontour is used.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.contour\n        (or tricontour if ``tri=True``).\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.pop('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<self.xmin,y<self.xmin) +\\\n                       np.logical_or(x>self.xmax,y>self.xmax)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    CS = ax.tricontour(triang,data,*args,**kwargs)\n                else:\n                    CS = ax.tricontour(x,y,data,*args,**kwargs)\n            else:\n                # make sure x is monotonically increasing - if not,\n                # print warning suggesting that the data be shifted in longitude\n                # with the shiftgrid function.\n                # only do this check for global projections.\n                if self.projection in _cylproj + _pseudocyl:\n                    xx = x[x.shape[0]//2,:]\n                    condition = (xx >= self.xmin) & (xx <= self.xmax)\n                    xl = xx.compress(condition).tolist()\n                    xs = xl[:]\n                    xs.sort()\n                    if xl != xs:\n                        sys.stdout.write(\" \".join([\n                            \"WARNING: x coordinate not montonically increasing\",\n                            \"- contour plot may not be what you expect. If it\",\n                            \"looks odd, you can either adjust the map projection\",\n                            \"region to be consistent with your data, or (if your\",\n                            \"data is on a global lat/lon grid) use the shiftdata\",\n                            \"method to adjust the data to be consistent with the\",\n                            \"map projection region (see examples/shiftdata.py)\"]))\n                # mask for points more than one grid length outside projection limb.\n                xx = ma.masked_where(x > 1.e20, x)\n                yy = ma.masked_where(y > 1.e20, y)\n                epsx = np.abs(xx[:,1:]-xx[:,0:-1]).max()\n                epsy = np.abs(yy[1:,:]-yy[0:-1,:]).max()\n                xymask = \\\n                np.logical_or(np.greater(x,self.xmax+epsx),np.greater(y,self.ymax+epsy))\n                xymask = xymask + \\\n                np.logical_or(np.less(x,self.xmin-epsx),np.less(y,self.ymin-epsy))\n                data = ma.asarray(data)\n                # combine with data mask.\n                mask = np.logical_or(ma.getmaskarray(data),xymask)\n                data = ma.masked_array(data,mask=mask)\n                CS = ax.contour(x,y,data,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt and CS.get_array() is not None:\n            plt.sci(CS)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS",
  "def contourf(self,x,y,data,*args,**kwargs):\n        \"\"\"\n        Make a filled contour plot over the map\n        (see matplotlib.pyplot.contourf documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        If x or y are outside projection limb (i.e. they have values > 1.e20),\n        the corresponing data elements will be masked.\n\n        Extra keyword 'ax' can be used to override the default axis instance.\n\n        If ``tri`` is set to ``True``, an unstructured grid is assumed\n        (x,y,data must be 1-d) and matplotlib.pyplot.tricontourf is used.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.contourf\n        (or tricontourf if ``tri=True``).\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            if kwargs.get('tri', False):\n                import matplotlib.tri as tri\n                # for unstructured grids, toss out points outside\n                # projection limb (don't use those points in triangulation).\n                if ma.isMA(data):\n                    data = data.filled(fill_value=1.e30)\n                    masked=True\n                else:\n                    masked=False\n                mask = np.logical_or(x<1.e20,y<1.e20)\n                x = np.compress(mask,x)\n                y = np.compress(mask,y)\n                data = np.compress(mask,data)\n                if masked:\n                    triang = tri.Triangulation(x, y)\n                    z = data[triang.triangles]\n                    mask = (z > 1.e20).sum(axis=-1)\n                    triang.set_mask(mask)\n                    CS = ax.tricontourf(triang,data,*args,**kwargs)\n                else:\n                    CS = ax.tricontourf(x,y,data,*args,**kwargs)\n            else:\n                # make sure x is monotonically increasing - if not,\n                # print warning suggesting that the data be shifted in longitude\n                # with the shiftgrid function.\n                # only do this check for global projections.\n                if self.projection in _cylproj + _pseudocyl:\n                    xx = x[x.shape[0]//2,:]\n                    condition = (xx >= self.xmin) & (xx <= self.xmax)\n                    xl = xx.compress(condition).tolist()\n                    xs = xl[:]\n                    xs.sort()\n                    if xl != xs:\n                        sys.stdout.write(\" \".join([\n                            \"WARNING: x coordinate not montonically increasing\",\n                            \"- contour plot may not be what you expect. If it\",\n                            \"looks odd, you can either adjust the map projection\",\n                            \"region to be consistent with your data, or (if your\",\n                            \"data is on a global lat/lon grid) use the shiftgrid\",\n                            \"function to adjust the data to be consistent with the\",\n                            \"map projection region (see examples/contour_demo.py)\"]))\n                # mask for points more than one grid length outside projection limb.\n                xx = ma.masked_where(x > 1.e20, x)\n                yy = ma.masked_where(y > 1.e20, y)\n                if self.projection != 'omerc':\n                    epsx = np.abs(xx[:,1:]-xx[:,0:-1]).max()\n                    epsy = np.abs(yy[1:,:]-yy[0:-1,:]).max()\n                else: # doesn't work for omerc (FIXME)\n                    epsx = 0.; epsy = 0\n                xymask = \\\n                np.logical_or(np.greater(x,self.xmax+epsx),np.greater(y,self.ymax+epsy))\n                xymask = xymask + \\\n                np.logical_or(np.less(x,self.xmin-epsx),np.less(y,self.ymin-epsy))\n                data = ma.asarray(data)\n                # combine with data mask.\n                mask = np.logical_or(ma.getmaskarray(data),xymask)\n                data = ma.masked_array(data,mask=mask)\n                CS = ax.contourf(x,y,data,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # reset current active image (only if pyplot is imported).\n        if plt and CS.get_array() is not None:\n            plt.sci(CS)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS",
  "def quiver(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Make a vector plot (u, v) with arrows on the map.\n\n        Arguments may be 1-D or 2-D arrays or sequences\n        (see matplotlib.pyplot.quiver documentation for details).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.quiver.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.quiver(x,y,u,v,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        if plt is not None and ret.get_array() is not None:\n            plt.sci(ret)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret,c = self._cliplimb(ax,ret)\n        return ret",
  "def streamplot(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Draws streamlines of a vector flow.\n        (see matplotlib.pyplot.streamplot documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.streamplot.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        self._save_use_hold(ax, kwargs)\n        try:\n            ret =  ax.streamplot(x,y,u,v,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        if plt is not None and ret.lines.get_array() is not None:\n            plt.sci(ret.lines)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        ret.lines,c = self._cliplimb(ax,ret.lines)\n        ret.arrows,c = self._cliplimb(ax,ret.arrows)\n        # streamplot arrows not returned in matplotlib 1.1.1, so clip all\n        # FancyArrow patches attached to axes instance.\n        if c is not None:\n            for p in ax.patches:\n                if isinstance(p,FancyArrowPatch): p.set_clip_path(c)\n        return ret",
  "def barbs(self, x, y, u, v, *args, **kwargs):\n        \"\"\"\n        Make a wind barb plot (u, v) with on the map.\n        (see matplotlib.pyplot.barbs documentation).\n\n        If ``latlon`` keyword is set to True, x,y are intrepreted as\n        longitude and latitude in degrees.  Data and longitudes are\n        automatically shifted to match map projection region for cylindrical\n        and pseudocylindrical projections, and x,y are transformed to map\n        projection coordinates. If ``latlon`` is False (default), x and y\n        are assumed to be map projection coordinates.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        Other \\*args and \\**kwargs passed on to matplotlib.pyplot.barbs\n\n        Returns two matplotlib.axes.Barbs instances, one for the Northern\n        Hemisphere and one for the Southern Hemisphere.\n        \"\"\"\n        ax, plt = self._ax_plt_from_kw(kwargs)\n        lons, lats = self(x, y, inverse=True)\n        unh = ma.masked_where(lats <= 0, u)\n        vnh = ma.masked_where(lats <= 0, v)\n        ush = ma.masked_where(lats > 0, u)\n        vsh = ma.masked_where(lats > 0, v)\n        self._save_use_hold(ax, kwargs)\n        try:\n            retnh =  ax.barbs(x,y,unh,vnh,*args,**kwargs)\n            kwargs['flip_barb']=True\n            retsh =  ax.barbs(x,y,ush,vsh,*args,**kwargs)\n        finally:\n            self._restore_hold(ax)\n        # Because there are two collections returned in general,\n        # we can't set the current image...\n        #if plt is not None and ret.get_array() is not None:\n        #    plt.sci(retnh)\n        # set axes limits to fit map region.\n        self.set_axes_limits(ax=ax)\n        # clip to map limbs\n        retnh,c = self._cliplimb(ax,retnh)\n        retsh,c = self._cliplimb(ax,retsh)\n\n        return retnh,retsh",
  "def drawlsmask(self,land_color=\"0.8\",ocean_color=\"w\",lsmask=None,\n                   lsmask_lons=None,lsmask_lats=None,lakes=True,resolution='l',grid=5,**kwargs):\n        \"\"\"\n        Draw land-sea mask image.\n\n        .. note::\n         The land-sea mask image cannot be overlaid on top\n         of other images, due to limitations in matplotlib image handling\n         (you can't specify the zorder of an image).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        land_color       desired land color (color name or rgba tuple).\n                         Default gray (\"0.8\").\n        ocean_color      desired water color (color name or rgba tuple).\n                         Default white.\n        lsmask           An array of 0's for ocean pixels, 1's for\n                         land pixels and 2's for lake/pond pixels.\n                         Default is None\n                         (default 5-minute resolution land-sea mask is used).\n        lakes            Plot lakes and ponds (Default True)\n        lsmask_lons      1d array of longitudes for lsmask (ignored\n                         if lsmask is None). Longitudes must be ordered\n                         from -180 W eastward.\n        lsmask_lats      1d array of latitudes for lsmask (ignored\n                         if lsmask is None). Latitudes must be ordered\n                         from -90 S northward.\n        resolution       gshhs coastline resolution used to define land/sea\n                         mask (default 'l', available 'c','l','i','h' or 'f')\n        grid             land/sea mask grid spacing in minutes (Default 5;\n                         10, 2.5 and 1.25 are also available).\n        \\**kwargs        extra keyword arguments passed on to\n                         :meth:`imshow`\n        ==============   ====================================================\n\n        If any of the lsmask, lsmask_lons or lsmask_lats keywords are not\n        set, the built in GSHHS land-sea mask datasets are used.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        # convert land and water colors to integer rgba tuples with\n        # values between 0 and 255.\n        from matplotlib.colors import ColorConverter\n        c = ColorConverter()\n        # if conversion fails, assume it's because the color\n        # given is already an rgba tuple with values between 0 and 255.\n        try:\n            cl = c.to_rgba(land_color)\n            rgba_land = tuple([int(255*x) for x in cl])\n        except:\n            rgba_land = land_color\n        try:\n            co = c.to_rgba(ocean_color)\n            rgba_ocean = tuple([int(255*x) for x in co])\n        except:\n            rgba_ocean = ocean_color\n        # look for axes instance (as keyword, an instance variable\n        # or from plt.gca().\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # Clear saved lsmask if new lsmask is passed\n        if lsmask is not None or lsmask_lons is not None \\\n                or lsmask_lats is not None:\n            # Make sure passed lsmask is not the same as cached mask\n            if lsmask is not self.lsmask:\n                self.lsmask = None\n        # if lsmask,lsmask_lons,lsmask_lats keywords not given,\n        # read default land-sea mask in from file.\n        if lsmask is None or lsmask_lons is None or lsmask_lats is None:\n            # if lsmask instance variable already set, data already\n            # read in.\n            if self.lsmask is None:\n                # read in land/sea mask.\n                lsmask_lons, lsmask_lats, lsmask =\\\n                _readlsmask(lakes=lakes,resolution=resolution,grid=grid)\n                # instance variable lsmask is set on first invocation,\n                # it contains the land-sea mask interpolated to the native\n                # projection grid.  Further calls to drawlsmask will not\n                # redo the interpolation (unless a new land-sea mask is passed\n                # in via the lsmask, lsmask_lons, lsmask_lats keywords).\n\n                # is it a cylindrical projection whose limits lie\n                # outside the limits of the image?\n                cylproj =  self.projection in _cylproj and \\\n                          (self.urcrnrlon > lsmask_lons[-1] or \\\n                           self.llcrnrlon < lsmask_lons[0])\n                if cylproj:\n                    # stack grids side-by-side (in longitiudinal direction), so\n                    # any range of longitudes may be plotted on a world map.\n                    # in versions of NumPy later than 1.10.0, concatenate will\n                    # not stack these arrays as expected. If axis 1 is outside\n                    # the dimensions of the array, concatenate will now raise\n                    # an IndexError. Using hstack instead.\n                    lsmask_lons = \\\n                            np.hstack((lsmask_lons,lsmask_lons[1:] + 360))\n                    lsmask = \\\n                            np.hstack((lsmask,lsmask[:,1:]))\n        else:\n            if lakes: lsmask = np.where(lsmask==2,np.array(0,np.uint8),lsmask)\n\n        # transform mask to nx x ny regularly spaced native projection grid\n        # nx and ny chosen to have roughly the same horizontal\n        # resolution as mask.\n        if self.lsmask is None:\n            nlons = len(lsmask_lons)\n            nlats = len(lsmask_lats)\n            if self.projection == 'cyl':\n                dx = lsmask_lons[1]-lsmask_lons[0]\n            else:\n                dx = (np.pi/180.)*(lsmask_lons[1]-lsmask_lons[0])*self.rmajor\n            nx = int((self.xmax-self.xmin)/dx)+1; ny = int((self.ymax-self.ymin)/dx)+1\n        # interpolate rgba values from proj='cyl' (geographic coords)\n        # to a rectangular map projection grid.\n            mask,x,y = self.transform_scalar(lsmask,lsmask_lons,\\\n                       lsmask_lats,nx,ny,returnxy=True,order=0,masked=255)\n            lsmask_lats.dtype\n            # for these projections, points outside the projection\n            # limb have to be set to transparent manually.\n            if self.projection in _pseudocyl:\n                lons, lats = self(x, y, inverse=True)\n                lon_0 = self.projparams['lon_0']\n                lats = lats[:,nx//2]\n                lons1 = (lon_0+180.)*np.ones(lons.shape[0],np.float64)\n                lons2 = (lon_0-180.)*np.ones(lons.shape[0],np.float64)\n                xmax,ytmp = self(lons1,lats)\n                xmin,ytmp = self(lons2,lats)\n                for j in range(lats.shape[0]):\n                    xx = x[j,:]\n                    mask[j,:]=np.where(np.logical_or(xx<xmin[j],xx>xmax[j]),\\\n                                        255,mask[j,:])\n            self.lsmask = mask\n        ny, nx = self.lsmask.shape\n        rgba = np.ones((ny,nx,4),np.uint8)\n        rgba_land = np.array(rgba_land,np.uint8)\n        rgba_ocean = np.array(rgba_ocean,np.uint8)\n        for k in range(4):\n            rgba[:,:,k] = np.where(self.lsmask,rgba_land[k],rgba_ocean[k])\n        # make points outside projection limb transparent.\n        rgba[:,:,3] = np.where(self.lsmask==255,0,rgba[:,:,3])\n        # plot mask as rgba image.\n        im = self.imshow(rgba,interpolation='nearest',ax=ax,**kwargs)\n        # clip to map limbs.\n        im,c = self._cliplimb(ax,im)\n        return im",
  "def bluemarble(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display blue marble image (from http://visibleearth.nasa.gov)\n        as map background.\n        Default image size is 5400x2700, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 2700x1350).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='bluemarble',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='bluemarble',scale=scale,**kwargs)",
  "def shadedrelief(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display shaded relief image (from http://www.shadedrelief.com)\n        as map background.\n        Default image size is 10800x5400, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 5400x2700).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='shadedrelief',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='shadedrelief',scale=scale,**kwargs)",
  "def etopo(self,ax=None,scale=None,**kwargs):\n        \"\"\"\n        display etopo relief image (from\n        http://www.ngdc.noaa.gov/mgg/global/global.html)\n        as map background.\n        Default image size is 5400x2700, which can be quite slow and\n        use quite a bit of memory.  The ``scale`` keyword can be used\n        to downsample the image (``scale=0.5`` downsamples to 5400x2700).\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        if ax is not None:\n            return self.warpimage(image='etopo',ax=ax,scale=scale,**kwargs)\n        else:\n            return self.warpimage(image='etopo',scale=scale,**kwargs)",
  "def warpimage(self,image=\"bluemarble\",scale=None,**kwargs):\n        \"\"\"\n        Display an image (filename given by ``image`` keyword) as a map background.\n        If image is a URL (starts with 'http'), it is downloaded to a temp\n        file using urllib.urlretrieve.\n\n        Default (if ``image`` not specified) is to display\n        'blue marble next generation' image from http://visibleearth.nasa.gov/.\n\n        Specified image must have pixels covering the whole globe in a regular\n        lat/lon grid, starting and -180W and the South Pole.\n        Works with the global images from\n        http://earthobservatory.nasa.gov/Features/BlueMarble/BlueMarble_monthlies.php.\n\n        The ``scale`` keyword can be used to downsample (rescale) the image.\n        Values less than 1.0 will speed things up at the expense of image\n        resolution.\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        \\**kwargs passed on to :meth:`imshow`.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n\n        # fix PIL import on some versions of OSX and scipy\n        try:\n            from PIL import Image\n        except ImportError:\n            try:\n                import Image\n            except ImportError:\n                raise ImportError(\"warpimage method requires PIL \"\n                                  \"(http://pillow.readthedocs.io)\")\n\n        from matplotlib.image import pil_to_array\n        if self.celestial:\n            raise ValueError(\"warpimage does not work in celestial coordinates\")\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # default image file is blue marble next generation\n        # from NASA (http://visibleearth.nasa.gov).\n        if image == \"bluemarble\":\n            file = os.path.join(basemap_datadir,'bmng.jpg')\n        # display shaded relief image (from\n        # http://www.shadedreliefdata.com)\n        elif image == \"shadedrelief\":\n            file = os.path.join(basemap_datadir,'shadedrelief.jpg')\n        # display etopo image (from\n        # http://www.ngdc.noaa.gov/mgg/image/globalimages.html)\n        elif image == \"etopo\":\n            file = os.path.join(basemap_datadir,'etopo1.jpg')\n        else:\n            file = image\n        # if image is same as previous invocation, used cached data.\n        # if not, regenerate rgba data.\n        if not hasattr(self,'_bm_file') or self._bm_file != file:\n            newfile = True\n        else:\n            newfile = False\n        if file.startswith('http'):\n            self._bm_file, headers = urlretrieve(file)\n        else:\n            self._bm_file = file\n        # bmproj is True if map projection region is same as\n        # image region.\n        bmproj = self.projection == 'cyl' and \\\n                 self.llcrnrlon == -180 and self.urcrnrlon == 180 and \\\n                 self.llcrnrlat == -90 and self.urcrnrlat == 90\n        # read in jpeg image to rgba array of normalized floats.\n        if not hasattr(self,'_bm_rgba') or newfile:\n            pilImage = Image.open(self._bm_file)\n            if scale is not None:\n                w, h = pilImage.size\n                width = int(np.round(w*scale))\n                height = int(np.round(h*scale))\n                pilImage = pilImage.resize((width,height),Image.LANCZOS)\n            # orientation of arrays returned by pil_to_array changed in\n            # matplotlib 1.2 (https://github.com/matplotlib/matplotlib/pull/616)\n            self._bm_rgba = pil_to_array(pilImage)[::-1,:]\n            # define lat/lon grid that image spans.\n            nlons = self._bm_rgba.shape[1]; nlats = self._bm_rgba.shape[0]\n            delta = 360./float(nlons)\n            self._bm_lons = np.arange(-180.+0.5*delta,180.,delta)\n            self._bm_lats = np.arange(-90.+0.5*delta,90.,delta)\n            # is it a cylindrical projection whose limits lie\n            # outside the limits of the image?\n            cylproj =  self.projection in _cylproj and \\\n                      (self.urcrnrlon > self._bm_lons[-1] or \\\n                       self.llcrnrlon < self._bm_lons[0])\n            # if pil_to_array returns a 2D array, it's a grayscale image.\n            # create an RGB image, with R==G==B.\n            if self._bm_rgba.ndim == 2:\n                tmp = np.empty(self._bm_rgba.shape+(3,),np.uint8)\n                for k in range(3):\n                    tmp[:,:,k] = self._bm_rgba\n                self._bm_rgba = tmp\n            if cylproj and not bmproj:\n                # stack grids side-by-side (in longitiudinal direction), so\n                # any range of longitudes may be plotted on a world map.\n                self._bm_lons = \\\n                np.concatenate((self._bm_lons,self._bm_lons+360),0)\n                self._bm_rgba = \\\n                np.concatenate((self._bm_rgba,self._bm_rgba),1)\n            # convert to normalized floats.\n            self._bm_rgba = self._bm_rgba.astype(np.float32)/255.\n        if not bmproj: # interpolation necessary.\n            if newfile or not hasattr(self,'_bm_rgba_warped'):\n                # transform to nx x ny regularly spaced native\n                # projection grid.\n                # nx and ny chosen to have roughly the\n                # same horizontal res as original image.\n                if self.projection != 'cyl':\n                    dx = 2.*np.pi*self.rmajor/float(nlons)\n                    nx = int((self.xmax-self.xmin)/dx)+1\n                    ny = int((self.ymax-self.ymin)/dx)+1\n                else:\n                    dx = 360./float(nlons)\n                    nx = int((self.urcrnrlon-self.llcrnrlon)/dx)+1\n                    ny = int((self.urcrnrlat-self.llcrnrlat)/dx)+1\n                self._bm_rgba_warped = np.ones((ny,nx,4),np.float64)\n                # interpolate rgba values from geographic coords (proj='cyl')\n                # to map projection coords.\n                # if masked=True, values outside of\n                # projection limb will be masked.\n                for k in range(self._bm_rgba.shape[2]):\n                    self._bm_rgba_warped[:,:,k],x,y = \\\n                    self.transform_scalar(self._bm_rgba[:,:,k],\\\n                    self._bm_lons,self._bm_lats,nx,ny,returnxy=True)\n                # for ortho,geos mask pixels outside projection limb.\n                if self.projection in ['geos','ortho','nsper'] or \\\n                   (self.projection == 'aeqd' and self._fulldisk):\n                    lonsr,latsr = self(x,y,inverse=True)\n                    mask = ma.zeros((ny,nx,4),np.int8)\n                    mask[:,:,0] = np.logical_or(lonsr>1.e20,latsr>1.e30)\n                    for k in range(1,4):\n                        mask[:,:,k] = mask[:,:,0]\n                    self._bm_rgba_warped = \\\n                    ma.masked_array(self._bm_rgba_warped,mask=mask)\n                    # make points outside projection limb transparent.\n                    self._bm_rgba_warped = self._bm_rgba_warped.filled(0.)\n                # treat pseudo-cyl projections such as mollweide, robinson and sinusoidal.\n                elif self.projection in _pseudocyl and \\\n                     self.projection != 'hammer':\n                    lonsr,latsr = self(x,y,inverse=True)\n                    mask = ma.zeros((ny,nx,4),np.int8)\n                    lon_0 = self.projparams['lon_0']\n                    lonright = lon_0+180.\n                    lonleft = lon_0-180.\n                    x1 = np.array(ny*[0.5*(self.xmax + self.xmin)],np.float)\n                    y1 = np.linspace(self.ymin, self.ymax, ny)\n                    lons1, lats1 = self(x1,y1,inverse=True)\n                    lats1 = np.where(lats1 < -89.999999, -89.999999, lats1)\n                    lats1 = np.where(lats1 > 89.999999, 89.999999, lats1)\n                    for j,lat in enumerate(lats1):\n                        xmax,ymax = self(lonright,lat)\n                        xmin,ymin = self(lonleft,lat)\n                        mask[j,:,0] = np.logical_or(x[j,:]>xmax,x[j,:]<xmin)\n                    for k in range(1,4):\n                        mask[:,:,k] = mask[:,:,0]\n                    self._bm_rgba_warped = \\\n                    ma.masked_array(self._bm_rgba_warped,mask=mask)\n                    # make points outside projection limb transparent.\n                    # FIXME: Probably not needed anymore\n                    self._bm_rgba_warped = self._bm_rgba_warped.filled(0.)\n            # plot warped rgba image.\n            im = self.imshow(self._bm_rgba_warped,ax=ax,**kwargs)\n            # for hammer projection, use clip path defined by\n            # projection limb (patch created in drawmapboundary).\n            # FIXME: Is this now redundant?\n            if self.projection == 'hammer':\n                if not self._mapboundarydrawn:\n                    self.drawmapboundary(color='none',linewidth=None)\n                im.set_clip_path(self._mapboundarydrawn)\n        else:\n            # bmproj True, no interpolation necessary.\n            im = self.imshow(self._bm_rgba,ax=ax,**kwargs)\n        # clip to map limbs\n        im,c = self._cliplimb(ax,im)\n        return im",
  "def arcgisimage(self,server='http://server.arcgisonline.com/ArcGIS',\\\n                 service='World_Imagery',xpixels=400,ypixels=None,\\\n                 dpi=96,cachedir=None,verbose=False,**kwargs):\n        \"\"\"\n        Retrieve an image using the ArcGIS Server REST API and display it on\n        the map. In order to use this method, the Basemap instance must be\n        created using the ``epsg`` keyword to define the map projection, unless\n        the ``cyl`` projection is used (in which case the epsg code 4326 is\n        assumed).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        server           web map server URL (default\n                         http://server.arcgisonline.com/ArcGIS).\n        service          service (image type) hosted on server (default\n                         'World_Imagery', which is NASA 'Blue Marble'\n                         image).\n        xpixels          requested number of image pixels in x-direction\n                         (default 400).\n        ypixels          requested number of image pixels in y-direction.\n                         Default (None) is to infer the number from\n                         from xpixels and the aspect ratio of the\n                         map projection region.\n        dpi              The device resolution of the exported image (dots per\n                         inch, default 96).\n        cachedir         An optional directory to use as cache folder for the retrieved images.\n        verbose          if True, print URL used to retrieve image (default\n                         False).\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n\n        # fix PIL import on some versions of OSX and scipy\n        try:\n            from PIL import Image\n        except ImportError:\n            try:\n                import Image\n            except ImportError:\n                raise ImportError(\"arcgisimage method requires PIL \"\n                                  \"(http://pillow.readthedocs.io)\")\n\n        if not hasattr(self,'epsg'):\n            raise ValueError(\"the Basemap instance must be created using \"\n                             \"an EPSG code (http://spatialreference.org) \"\n                             \"in order to use the wmsmap method\")\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        # find the x,y values at the corner points.\n        p = pyproj.Proj(init=\"epsg:%s\" % self.epsg, preserve_units=True)\n        xmin,ymin = p(self.llcrnrlon,self.llcrnrlat)\n        xmax,ymax = p(self.urcrnrlon,self.urcrnrlat)\n        if self.projection in _cylproj:\n            Dateline =\\\n            _geoslib.Point(self(180.,0.5*(self.llcrnrlat+self.urcrnrlat)))\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            if hasDateline:\n                raise ValueError(\"arcgisimage cannot handle images that cross \"\n                                 \"the dateline for cylindrical projections\")\n        # ypixels not given, find by scaling xpixels by the map aspect ratio.\n        if ypixels is None:\n            ypixels = int(self.aspect*xpixels)\n        # construct a URL using the ArcGIS Server REST API.\n        basemap_url = \\\n\"%s/rest/services/%s/MapServer/export?\\\nbbox=%s,%s,%s,%s&\\\nbboxSR=%s&\\\nimageSR=%s&\\\nsize=%s,%s&\\\ndpi=%s&\\\nformat=png32&\\\ntransparent=true&\\\nf=image\" %\\\n(server,service,xmin,ymin,xmax,ymax,self.epsg,self.epsg,xpixels,ypixels,dpi)\n        # print URL?\n        if verbose: print(basemap_url)\n\n        if cachedir != None:\n            # Generate a filename for the cached file.\n            filename = \"%s-bbox-%s-%s-%s-%s-bboxsr%s-imagesr%s-size-%s-%s-dpi%s.png\" %\\\n            (service,xmin,ymin,xmax,ymax,self.epsg,self.epsg,xpixels,ypixels,dpi)\n\n             # Check if the cache directory exists, if not create it.\n            if not os.path.exists(cachedir):\n                os.makedirs(cachedir)\n\n            # Check if the image is already in the cachedir folder.\n            cache_path = cachedir + filename\n\n            if os.path.isfile(cache_path):\n                print('Image already in cache')\n                img = Image.open(cache_path)\n                return basemap.imshow(img, ax=ax, origin='upper')\n            else:\n                # Retrieve and save image\n                img = Image.open(urlopen(basemap_url))\n                img.save(cache_path)\n        else:\n            img = Image.open(urlopen(basemap_url))\n\n        # return AxesImage instance.\n        return self.imshow(img, ax=ax, origin='upper')",
  "def wmsimage(self,server,\\\n                 xpixels=400,ypixels=None,\\\n                 format='png',alpha=None,verbose=False,**kwargs):\n        \"\"\"\n        Retrieve an image using from a WMS server using the\n        Open Geospatial Consortium (OGC) standard interface\n        and display on the map. Requires OWSLib\n        (http://pypi.python.org/pypi/OWSLib).\n        In order to use this method, the Basemap instance must be\n        created using the ``epsg`` keyword to define the map projection, unless\n        the ``cyl`` projection is used (in which case the epsg code 4326 is\n        assumed).\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        server           WMS server URL.\n        xpixels          requested number of image pixels in x-direction\n                         (default 400).\n        ypixels          requested number of image pixels in y-direction.\n                         Default (None) is to infer the number from\n                         from xpixels and the aspect ratio of the\n                         map projection region.\n        format           desired image format (default 'png')\n        alpha            The alpha blending value,\n                         between 0 (transparent) and 1 (opaque) (default None)\n        verbose          if True, print WMS server info (default\n                         False).\n        \\**kwargs        extra keyword arguments passed on to\n                         OWSLib.wms.WebMapService.getmap.\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.image.AxesImage instance.\n        \"\"\"\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError('OWSLib required to use wmsimage method')\n        import io\n        ax = kwargs.pop('ax', None) or self._check_ax()\n        if not hasattr(self,'epsg'):\n            raise ValueError(\"the Basemap instance must be created using \"\n                             \"an EPSG code (http://spatialreference.org) \"\n                             \"in order to use the wmsmap method\")\n        if 'layers' not in kwargs:\n            raise ValueError('no layers specified')\n        # find the x,y values at the corner points.\n        p = pyproj.Proj(init=\"epsg:%s\" % self.epsg, preserve_units=True)\n        xmin,ymin = p(self.llcrnrlon,self.llcrnrlat)\n        xmax,ymax = p(self.urcrnrlon,self.urcrnrlat)\n        if self.projection in _cylproj:\n            Dateline =\\\n            _geoslib.Point(self(180.,0.5*(self.llcrnrlat+self.urcrnrlat)))\n            hasDateline = Dateline.within(self._boundarypolyxy)\n            if hasDateline:\n                raise ValueError(\"wmsimage cannot handle images that cross \"\n                                 \"the dateline for cylindrical projections\")\n        if self.projection == 'cyl':\n            xmin = (180./np.pi)*xmin; xmax = (180./np.pi)*xmax\n            ymin = (180./np.pi)*ymin; ymax = (180./np.pi)*ymax\n        # ypixels not given, find by scaling xpixels by the map aspect ratio.\n        if ypixels is None:\n            ypixels = int(self.aspect*xpixels)\n        if verbose: print(server)\n        wms = WebMapService(server)\n        if verbose:\n            print('id: %s, version: %s' %\n            (wms.identification.type,wms.identification.version))\n            print('title: %s, abstract: %s' %\n            (wms.identification.title,wms.identification.abstract))\n            print('available layers:')\n            print(list(wms.contents))\n            print('projection options:')\n            print(wms[kwargs['layers'][0]].crsOptions)\n        # remove keys from kwargs that are over-ridden\n        for k in ['format','bbox','service','size','srs']:\n            if 'format' in kwargs: del kwargs['format']\n        img = wms.getmap(service='wms',bbox=(xmin,ymin,xmax,ymax),\n                         size=(xpixels,ypixels),format='image/%s'%format,\n                         srs='EPSG:%s' % self.epsg, **kwargs)\n        # return AxesImage instance.\n        # this works for png and jpeg.\n        return self.imshow(imread(io.BytesIO(img.read()),\n                           format=format),origin='upper',alpha=alpha,ax=ax)",
  "def drawmapscale(self,lon,lat,lon0,lat0,length,barstyle='simple',\\\n                     units='km',fontsize=9,yoffset=None,labelstyle='simple',\\\n                     fontcolor='k',fillcolor1='w',fillcolor2='k',ax=None,\\\n                     format='%d',zorder=None,linecolor=None,linewidth=None):\n        \"\"\"\n        Draw a map scale at ``lon,lat`` of length ``length``\n        representing distance in the map\n        projection coordinates at ``lon0,lat0``.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        units            the units of the length argument (Default km).\n        barstyle         ``simple`` or ``fancy`` (roughly corresponding\n                         to the styles provided by Generic Mapping Tools).\n                         Default ``simple``.\n        fontsize         for map scale annotations, default 9.\n        fontcolor            for map scale annotations, default black.\n        labelstyle       ``simple`` (default) or ``fancy``.  For\n                         ``fancy`` the map scale factor (ratio betwee\n                         the actual distance and map projection distance\n                         at lon0,lat0) and the value of lon0,lat0 are also\n                         displayed on the top of the scale bar. For\n                         ``simple``, just the units are display on top\n                         and the distance below the scale bar.\n                         If equal to False, plot an empty label.\n        format           a string formatter to format numeric values\n        yoffset          yoffset controls how tall the scale bar is,\n                         and how far the annotations are offset from the\n                         scale bar.  Default is 0.02 times the height of\n                         the map (0.02*(self.ymax-self.ymin)).\n        fillcolor1(2)    colors of the alternating filled regions\n                         (default white and black).  Only relevant for\n                         'fancy' barstyle.\n        zorder           sets the zorder for the map scale.\n        linecolor        sets the color of the scale, by default, fontcolor\n                         is used\n        linewidth        linewidth for scale and ticks\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # not valid for cylindrical projection\n        if self.projection == 'cyl':\n            raise ValueError(\"cannot draw map scale for projection='cyl'\")\n        # convert length to meters\n        lenlab = length\n        if units == 'km':\n            length = length*1000\n        elif units == 'mi':\n            length = length*1609.344\n        elif units == 'nmi':\n            length = length*1852\n        elif units == 'ft':\n            length = length*0.3048\n        elif units != 'm':\n            raise KeyError(\"units must be 'm' (meters), 'km' (kilometers), \"\n                           \"'mi' (miles), 'nmi' (nautical miles), or 'ft' (feet)\")\n        # reference point and center of scale.\n        x0,y0 = self(lon0,lat0)\n        xc,yc = self(lon,lat)\n        # make sure lon_0 between -180 and 180\n        lon_0 = ((lon0+360) % 360) - 360\n        if lat0>0:\n            if lon>0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}N, %g\\N{DEGREE SIGN}E' % (lat0,lon_0)\n            elif lon<0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}N, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n            else:\n                lonlatstr = u'%g\\N{DEGREE SIGN}, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n        else:\n            if lon>0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}E' % (lat0,lon_0)\n            elif lon<0:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}W' % (lat0,lon_0)\n            else:\n                lonlatstr = u'%g\\N{DEGREE SIGN}S, %g\\N{DEGREE SIGN}' % (lat0,lon_0)\n        # left edge of scale\n        lon1,lat1 = self(x0-length/2,y0,inverse=True)\n        x1,y1 = self(lon1,lat1)\n        # right edge of scale\n        lon4,lat4 = self(x0+length/2,y0,inverse=True)\n        x4,y4 = self(lon4,lat4)\n        x1 = x1-x0+xc; y1 = y1-y0+yc\n        x4 = x4-x0+xc; y4 = y4-y0+yc\n        if x1 > 1.e20 or x4 > 1.e20 or y1 > 1.e20 or y4 > 1.e20:\n            raise ValueError(\"scale bar positioned outside projection limb\")\n        # scale factor for true distance\n        gc = pyproj.Geod(a=self.rmajor,b=self.rminor)\n        az12,az21,dist = gc.inv(lon1,lat1,lon4,lat4)\n        scalefact = dist/length\n        # label to put on top of scale bar.\n        if labelstyle=='simple':\n            labelstr = units\n        elif labelstyle == 'fancy':\n            labelstr = units+\" (scale factor %4.2f at %s)\"%(scalefact,lonlatstr)\n        elif labelstyle == False:\n            labelstr = ''\n        else:\n            raise KeyError(\"labelstyle must be 'simple' or 'fancy'\")\n        # default y offset is 2 percent of map height.\n        if yoffset is None: yoffset = 0.02*(self.ymax-self.ymin)\n        rets = [] # will hold all plot objects generated.\n        # set linecolor\n        if linecolor is None:\n            linecolor = fontcolor\n        # 'fancy' style\n        if barstyle == 'fancy':\n            #we need 5 sets of x coordinates (in map units)\n            #quarter scale\n            lon2,lat2 = self(x0-length/4,y0,inverse=True)\n            x2,y2 = self(lon2,lat2)\n            x2 = x2-x0+xc; y2 = y2-y0+yc\n            #three quarter scale\n            lon3,lat3 = self(x0+length/4,y0,inverse=True)\n            x3,y3 = self(lon3,lat3)\n            x3 = x3-x0+xc; y3 = y3-y0+yc\n            #plot top line\n            ytop = yc+yoffset/2\n            ybottom = yc-yoffset/2\n            ytick = ybottom - yoffset/2\n            ytext = ytick - yoffset/2\n            rets.append(self.plot([x1,x4],[ytop,ytop],color=linecolor, linewidth=linewidth)[0])\n            #plot bottom line\n            rets.append(self.plot([x1,x4],[ybottom,ybottom],color=linecolor, linewidth=linewidth)[0])\n            #plot left edge\n            rets.append(self.plot([x1,x1],[ybottom,ytop],color=linecolor, linewidth=linewidth)[0])\n            #plot right edge\n            rets.append(self.plot([x4,x4],[ybottom,ytop],color=linecolor, linewidth=linewidth)[0])\n            #make a filled black box from left edge to 1/4 way across\n            rets.append(ax.fill([x1,x2,x2,x1,x1],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor1)[0])\n            #make a filled white box from 1/4 way across to 1/2 way across\n            rets.append(ax.fill([x2,xc,xc,x2,x2],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor2)[0])\n            #make a filled white box from 1/2 way across to 3/4 way across\n            rets.append(ax.fill([xc,x3,x3,xc,xc],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor1)[0])\n            #make a filled white box from 3/4 way across to end\n            rets.append(ax.fill([x3,x4,x4,x3,x3],[ytop,ytop,ybottom,ybottom,ytop],\\\n                        ec=fontcolor,fc=fillcolor2)[0])\n            #plot 3 tick marks at left edge, center, and right edge\n            rets.append(self.plot([x1,x1],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([xc,xc],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x4,x4],[ytick,ybottom],color=linecolor, linewidth=linewidth)[0])\n            #label 3 tick marks\n            rets.append(ax.text(x1,ytext,format % (0),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            rets.append(ax.text(xc,ytext,format % (0.5*lenlab),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            rets.append(ax.text(x4,ytext,format % (lenlab),\\\n            horizontalalignment='center',\\\n            verticalalignment='top',\\\n            fontsize=fontsize,color=fontcolor))\n            #put units, scale factor on top\n            rets.append(ax.text(xc,ytop+yoffset/2,labelstr,\\\n            horizontalalignment='center',\\\n            verticalalignment='bottom',\\\n            fontsize=fontsize,color=fontcolor))\n        # 'simple' style\n        elif barstyle == 'simple':\n            rets.append(self.plot([x1,x4],[yc,yc],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x1,x1],[yc-yoffset,yc+yoffset],color=linecolor, linewidth=linewidth)[0])\n            rets.append(self.plot([x4,x4],[yc-yoffset,yc+yoffset],color=linecolor, linewidth=linewidth)[0])\n            rets.append(ax.text(xc,yc-yoffset,format % lenlab,\\\n            verticalalignment='top',horizontalalignment='center',\\\n            fontsize=fontsize,color=fontcolor))\n            #put units, scale factor on top\n            rets.append(ax.text(xc,yc+yoffset,labelstr,\\\n            horizontalalignment='center',\\\n            verticalalignment='bottom',\\\n            fontsize=fontsize,color=fontcolor))\n        else:\n            raise KeyError(\"barstyle must be 'simple' or 'fancy'\")\n        if zorder is not None:\n            for ret in rets:\n                try:\n                    ret.set_zorder(zorder)\n                except:\n                    pass\n        return rets",
  "def colorbar(self,mappable=None,location='right',size=\"5%\",pad='2%',fig=None,ax=None,**kwargs):\n        \"\"\"\n        Add colorbar to axes associated with a map.\n        The colorbar axes instance is created using the axes_grid toolkit.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        mappable         the Image, ContourSet, etc. to which the colorbar\n                         applies.  Default None, matplotlib.pyplot.gci() is\n                         used to retrieve the current image mappable.\n        location         where to put colorbar ('top','bottom','left','right')\n                         Default 'right'.\n        size             width of colorbar axes (string 'N%', where N is\n                         an integer describing the fractional width of the parent\n                         axes). Default '5%'.\n        pad              Padding between parent axes and colorbar axes in\n                         same units as size. Default '2%'.\n        fig              Figure instance the map axes instance is associated\n                         with. Default None, and matplotlib.pyplot.gcf() is used\n                         to retrieve the current active figure instance.\n        ax               The axes instance which the colorbar will be\n                         associated with.  Default None, searches for self.ax,\n                         and if None uses matplotlib.pyplot.gca().\n        \\**kwargs        extra keyword arguments passed on to\n                         colorbar method of the figure instance.\n        ==============   ====================================================\n\n        Returns a matplotlib colorbar instance.\n        \"\"\"\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # get current figure instance (if none specified).\n        if fig is None or mappable is None:\n            import matplotlib.pyplot as plt\n        if fig is None:\n            fig = plt.gcf()\n        # get current mappable if none specified.\n        if mappable is None:\n            mappable = plt.gci()\n        # create colorbar axes uses axes_grid toolkit.\n        divider = make_axes_locatable(ax)\n        if location in ['left','right']:\n            orientation = 'vertical'\n        elif location in ['top','bottom']:\n            orientation = 'horizontal'\n        else:\n            raise ValueError('location must be top,bottom,left or right')\n        cax = divider.append_axes(location, size=size, pad=pad)\n        # create colorbar.\n        cb = fig.colorbar(mappable,orientation=orientation,cax=cax,**kwargs)\n        fig.sca(ax) # reset parent axes as current axes.\n        return cb",
  "def nightshade(self,date,color=\"k\",delta=0.25,alpha=0.5,ax=None,zorder=2):\n        \"\"\"\n        Shade the regions of the map that are in darkness at the time\n        specifed by ``date``.  ``date`` is a datetime instance,\n        assumed to be UTC.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        color            color to shade night regions (default black).\n        delta            day/night terminator is computed with a\n                         a resolution of ``delta`` degrees (default 0.25).\n        alpha            alpha transparency for shading (default 0.5, so\n                         map background shows through).\n        zorder           zorder for shading (default 2).\n        ==============   ====================================================\n\n        Extra keyword ``ax`` can be used to override the default axis instance.\n\n        returns a matplotlib.contour.ContourSet instance.\n        \"\"\"\n        from .solar import daynight_grid\n        # make sure date is UTC, or naive with repect to time zones\n        if date.utcoffset():\n            raise ValueError('datetime instance must be UTC, not {0}'.format(date.tzname()))\n        # get current axes instance (if none specified).\n        ax = ax or self._check_ax()\n        # create grid of day=0, night=1\n        lons,lats,daynight = daynight_grid(date,delta,self.lonmin,self.lonmax)\n        x,y = self(lons,lats)\n        # contour the day-night grid, coloring the night area\n        # with the specified color and transparency.\n        CS = self.contourf(x,y,daynight,1,colors=[color],alpha=alpha,ax=ax)\n        # set zorder on ContourSet collections show night shading\n        # is on top.\n        for c in CS.collections:\n            c.set_zorder(zorder)\n        # clip to map limbs\n        CS.collections,c = self._cliplimb(ax,CS.collections)\n        return CS",
  "def _check_ax(self):\n        \"\"\"\n        Returns the axis on which to draw.\n        Returns self.ax, or if self.ax=None returns plt.gca().\n        \"\"\"\n        if self.ax is None:\n            try:\n                ax = plt.gca()\n            except:\n                import matplotlib.pyplot as plt\n                ax = plt.gca()\n            # associate an axes instance with this Basemap instance\n            # the first time this method is called.\n            #self.ax = ax\n        else:\n            ax = self.ax\n        return ax",
  "def _ax_plt_from_kw(self, kw):\n        \"\"\"\n        Return (ax, plt), where ax is the current axes, and plt is\n        None or a reference to the pyplot module.\n\n        plt will be None if ax was popped from kw or taken from self.ax;\n        otherwise, pyplot was used and is returned.\n        \"\"\"\n        plt = None\n        _ax = kw.pop('ax', None)\n        if _ax is None:\n            _ax = self.ax\n            if _ax is None:\n                import matplotlib.pyplot as plt\n                _ax = plt.gca()\n        return _ax, plt",
  "def shiftdata(self,lonsin,datain=None,lon_0=None,fix_wrap_around=True):\n        \"\"\"\n        Shift longitudes (and optionally data) so that they match map projection region.\n        Only valid for cylindrical/pseudo-cylindrical global projections and data\n        on regular lat/lon grids. longitudes and data can be 1-d or 2-d, if 2-d\n        it is assumed longitudes are 2nd (rightmost) dimension.\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Arguments        Description\n        ==============   ====================================================\n        lonsin           original 1-d or 2-d longitudes.\n        ==============   ====================================================\n\n        .. tabularcolumns:: |l|L|\n\n        ==============   ====================================================\n        Keywords         Description\n        ==============   ====================================================\n        datain           original 1-d or 2-d data. Default None.\n        lon_0            center of map projection region. Defaut None,\n                         given by current map projection.\n        fix_wrap_around  if True reindex (if required) longitudes (and data) to\n                         avoid jumps caused by remapping of longitudes of\n                         points from outside of the [lon_0-180, lon_0+180]\n                         interval back into the interval.\n                         If False do not reindex longitudes and data, but do\n                         make sure that longitudes are in the\n                         [lon_0-180, lon_0+180] range.\n        ==============   ====================================================\n\n        if datain given, returns ``dataout,lonsout`` (data and longitudes shifted to fit in interval\n        [lon_0-180,lon_0+180]), otherwise just returns longitudes.  If\n        transformed longitudes lie outside map projection region, data is\n        masked and longitudes are set to 1.e30.\n        \"\"\"\n        if lon_0 is None and 'lon_0' not in self.projparams:\n            raise ValueError('lon_0 keyword must be provided')\n        lonsin = np.asarray(lonsin)\n        if lonsin.ndim not in [1,2]:\n            raise ValueError('1-d or 2-d longitudes required')\n        if datain is not None:\n            # if it's a masked array, leave it alone.\n            if not ma.isMA(datain): datain = np.asarray(datain)\n            if datain.ndim not in [1,2]:\n                raise ValueError('1-d or 2-d data required')\n        if lon_0 is None:\n            lon_0 = self.projparams['lon_0']\n        # 2-d data.\n        if lonsin.ndim == 2:\n            nlats = lonsin.shape[0]\n            nlons = lonsin.shape[1]\n            lonsin1 = lonsin[0,:]\n            lonsin1 = np.where(lonsin1 > lon_0+180, lonsin1-360 ,lonsin1)\n            lonsin1 = np.where(lonsin1 < lon_0-180, lonsin1+360 ,lonsin1)\n            if nlons > 1:\n                londiff = np.abs(lonsin1[0:-1]-lonsin1[1:])\n                londiff_sort = np.sort(londiff)\n                thresh = 360.-londiff_sort[-2] if nlons > 2 else 360.-londiff_sort[-1]\n                itemindex = nlons-np.where(londiff>=thresh)[0]\n            else:\n                lonsin[0, :] = lonsin1\n                itemindex = 0\n\n            # if no shift necessary, itemindex will be\n            # empty, so don't do anything\n            if fix_wrap_around and itemindex:\n                # check to see if cyclic (wraparound) point included\n                # if so, remove it.\n                if np.abs(lonsin1[0]-lonsin1[-1]) < 1.e-4:\n                    hascyclic = True\n                    lonsin_save = lonsin.copy()\n                    lonsin = lonsin[:,1:]\n                    if datain is not None:\n                       datain_save = datain.copy()\n                       datain = datain[:,1:]\n                else:\n                    hascyclic = False\n                lonsin = np.where(lonsin > lon_0+180, lonsin-360 ,lonsin)\n                lonsin = np.where(lonsin < lon_0-180, lonsin+360 ,lonsin)\n                lonsin = np.roll(lonsin,itemindex-1,axis=1)\n                if datain is not None:\n                    # np.roll works on ndarrays and on masked arrays\n                    datain = np.roll(datain,itemindex-1,axis=1)\n                # add cyclic point back at beginning.\n                if hascyclic:\n                    lonsin_save[:,1:] = lonsin\n                    lonsin_save[:,0] = lonsin[:,-1]-360.\n                    lonsin = lonsin_save\n                    if datain is not None:\n                        datain_save[:,1:] = datain\n                        datain_save[:,0] = datain[:,-1]\n                        datain = datain_save\n\n        # 1-d data.\n        elif lonsin.ndim == 1:\n            nlons = len(lonsin)\n            lonsin = np.where(lonsin > lon_0+180, lonsin-360 ,lonsin)\n            lonsin = np.where(lonsin < lon_0-180, lonsin+360 ,lonsin)\n\n            if nlons > 1:\n                londiff = np.abs(lonsin[0:-1]-lonsin[1:])\n                londiff_sort = np.sort(londiff)\n                thresh = 360.-londiff_sort[-2] if nlons > 2 else 360.0 - londiff_sort[-1]\n                itemindex = len(lonsin)-np.where(londiff>=thresh)[0]\n            else:\n                itemindex = 0\n\n            if fix_wrap_around and itemindex:\n                # check to see if cyclic (wraparound) point included\n                # if so, remove it.\n                if np.abs(lonsin[0]-lonsin[-1]) < 1.e-4:\n                    hascyclic = True\n                    lonsin_save = lonsin.copy()\n                    lonsin = lonsin[1:]\n                    if datain is not None:\n                        datain_save = datain.copy()\n                        datain = datain[1:]\n                else:\n                    hascyclic = False\n                lonsin = np.roll(lonsin,itemindex-1)\n                if datain is not None:\n                    datain = np.roll(datain,itemindex-1)\n                # add cyclic point back at beginning.\n                if hascyclic:\n                    lonsin_save[1:] = lonsin\n                    lonsin_save[0] = lonsin[-1]-360.\n                    lonsin = lonsin_save\n                    if datain is not None:\n                        datain_save[1:] = datain\n                        datain_save[0] = datain[-1]\n                        datain = datain_save\n\n        # mask points outside\n        # map region so they don't wrap back in the domain.\n        mask = np.logical_or(lonsin<lon_0-180,lonsin>lon_0+180)\n        lonsin = np.where(mask,1.e30,lonsin)\n        if datain is not None and mask.any():\n            datain = ma.masked_where(mask, datain)\n\n        if datain is not None:\n            return lonsin, datain\n        else:\n            return lonsin",
  "def _addcyclic(a):\n        \"\"\"addcyclic function for a single data array\"\"\"\n        npsel = np.ma if np.ma.is_masked(a) else np\n        slicer = [slice(None)] * np.ndim(a)\n        try:\n            slicer[axis] = slice(0, 1)\n        except IndexError:\n            raise ValueError('The specified axis does not correspond to an '\n                    'array dimension.')\n        return npsel.concatenate((a,a[tuple(slicer)]),axis=axis)",
  "def _addcyclic_lon(a):\n        \"\"\"addcyclic function for a single longitude array\"\"\"\n        # select the right numpy functions\n        npsel = np.ma if np.ma.is_masked(a) else np\n        # get cyclic longitudes\n        clon = (np.take(a,[0],axis=axis)\n                + cyclic * np.sign(np.diff(np.take(a,[0,-1],axis=axis),axis=axis)))\n        # ensure the values do not exceed cyclic\n        clonmod = npsel.where(clon<=cyclic,clon,np.mod(clon,cyclic))\n        return npsel.concatenate((a,clonmod),axis=axis)",
  "def remove(self):\n        for item in self:\n            for x in item:\n                x.remove()",
  "def __delitem__(self,key):\n        self[key].remove()\n        super(_dict, self).__delitem__(key)",
  "def addlon(meridians,madd):\n                minside = (madd >= self.llcrnrlon and madd <= self.urcrnrlon)\n                if minside and madd not in meridians: meridians.append(madd)\n                return meridians",
  "class Proj(object):\n    \"\"\"\n    peforms cartographic transformations (converts from longitude,latitude\n    to native map projection x,y coordinates and vice versa) using proj\n    (http://proj.maptools.org/)\n    Uses a pyrex generated C-interface to libproj.\n\n    __init__ method sets up projection information.\n    __call__ method compute transformations.\n    See docstrings for __init__ and __call__ for details.\n\n    Contact: Jeff Whitaker <jeffrey.s.whitaker@noaa.gov>\n    \"\"\"\n\n    def __init__(self,projparams,llcrnrlon,llcrnrlat,\n                      urcrnrlon,urcrnrlat,urcrnrislatlon=True):\n        \"\"\"\n        initialize a Proj class instance.\n\n        Input 'projparams' is a dictionary containing proj map\n        projection control parameter key/value pairs.\n        See the proj documentation (http://www.remotesensing.org/proj/)\n        for details.\n\n        llcrnrlon,llcrnrlat are lon and lat (in degrees) of lower\n        left hand corner of projection region.\n\n        urcrnrlon,urcrnrlat are lon and lat (in degrees) of upper\n        right hand corner of projection region if urcrnrislatlon=True\n        (default). Otherwise, urcrnrlon,urcrnrlat are x,y in projection\n        coordinates (units meters), assuming the lower left corner is x=0,y=0.\n        \"\"\"\n        self.projparams = projparams\n        self.projection = projparams['proj']\n        # rmajor is the semi-major axis.\n        # rminor is the semi-minor axis.\n        # esq is eccentricity squared.\n        try:\n            self.rmajor = projparams['a']\n            self.rminor = projparams['b']\n        except:\n            try:\n                self.rmajor = projparams['R']\n            except:\n                self.rmajor = projparams['bR_a']\n            self.rminor = self.rmajor\n        if self.rmajor == self.rminor:\n            self.ellipsoid = False\n        else:\n            self.ellipsoid = True\n        self.flattening = (self.rmajor-self.rminor)/self.rmajor\n        self.esq = (self.rmajor**2 - self.rminor**2)/self.rmajor**2\n        self.llcrnrlon = llcrnrlon\n        self.llcrnrlat = llcrnrlat\n        if self.projection == 'cyl':\n            llcrnrx = llcrnrlon\n            llcrnry = llcrnrlat\n        elif self.projection == 'ob_tran':\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnrx,llcrnry = self(llcrnrlon,llcrnrlat)\n            llcrnrx = _rad2dg*llcrnrx; llcrnry = _rad2dg*llcrnry\n            if llcrnrx < 0: llcrnrx = llcrnrx + 360\n        elif self.projection in 'ortho':\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                self._proj4 = pyproj.Proj(projparams)\n                llcrnrx = -self.rmajor\n                llcrnry = -self.rmajor\n                self._width = 0.5*(self.rmajor+self.rminor)\n                self._height = 0.5*(self.rmajor+self.rminor)\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                self._proj4 = pyproj.Proj(projparams)\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection == 'aeqd' and\\\n             (llcrnrlon == -180 and llcrnrlat == -90  and urcrnrlon == 180 and\\\n             urcrnrlat == 90):\n            self._fulldisk = True\n            self._proj4 = pyproj.Proj(projparams)\n            # raise an exception for ellipsoids - there appears to be a bug\n            # in proj4 that causes the inverse transform to fail for points\n            # more than 90 degrees of arc away from center point for ellipsoids\n            # (works fine for spheres) - below is an example\n            #from pyproj import Proj\n            #p1 = Proj(proj='aeqd',a=6378137.00,b=6356752.3142,lat_0=0,lon_0=0)\n            #x,y= p1(91,0)\n            #lon,lat = p1(x,y,inverse=True) # lon is 89 instead of 91\n            if self.ellipsoid:\n                raise ValueError(\n                    \"full disk (whole world) Azimuthal Equidistant projection \"\n                    \"can only be drawn for a perfect sphere\")\n            llcrnrx = -np.pi*self.rmajor\n            llcrnry = -np.pi*self.rmajor\n            self._width = -llcrnrx\n            self._height = -llcrnry\n            urcrnrx = -llcrnrx\n            urcrnry = -llcrnry\n        elif self.projection == 'geos':\n            self._proj4 = pyproj.Proj(projparams)\n            # find major and minor axes of ellipse defining map proj region.\n            # h is measured from surface of earth at equator.\n            h = projparams['h'] + self.rmajor\n            # latitude of horizon on central meridian\n            lonmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # longitude of horizon on equator\n            latmax = 90.-(180./np.pi)*np.arcsin(self.rminor/h)\n            # truncate to nearest hundredth of a degree (to make sure\n            # they aren't slightly over the horizon)\n            latmax = int(100*latmax)/100.\n            lonmax = int(100*lonmax)/100.\n            # width and height of visible projection\n            P = pyproj.Proj(proj='geos',a=self.rmajor,\\\n                            b=self.rminor,lat_0=0,lon_0=0,h=projparams['h'])\n            x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)\n            width = x2; height = y1\n            self._height = height\n            self._width = width\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                llcrnrx = -width\n                llcrnry = -height\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection == 'nsper':\n            self._proj4 = pyproj.Proj(projparams)\n            # find major and minor axes of ellipse defining map proj region.\n            # h is measured from surface of earth at equator.\n            h = projparams['h'] + self.rmajor\n            # latitude of horizon on central meridian\n            lonmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # longitude of horizon on equator\n            latmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # truncate to nearest hundredth of a degree (to make sure\n            # they aren't slightly over the horizon)\n            latmax = int(100*latmax)/100.\n            lonmax = int(100*lonmax)/100.\n            # width and height of visible projection\n            P = pyproj.Proj(proj='nsper',a=self.rmajor,\\\n                            b=self.rminor,lat_0=0,lon_0=0,h=projparams['h'])\n            x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)\n            width = x2; height = y1\n            self._height = height\n            self._width = width\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                llcrnrx = -width\n                llcrnry = -height\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection in _pseudocyl:\n            self._proj4 = pyproj.Proj(projparams)\n            xtmp,urcrnry = self(projparams['lon_0'],90.)\n            urcrnrx,xtmp = self(projparams['lon_0']+180.,0)\n            llcrnrx = -urcrnrx\n            llcrnry = -urcrnry\n            if self.ellipsoid and self.projection in ['kav7','eck4','mbtfpq']:\n                msg = \"this projection can only be drawn for a perfect sphere\"\n                raise ValueError(msg)\n        else:\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n            if self.projection == 'aeqd': self._fulldisk=False\n        # compute x_0, y_0 so ll corner of domain is x=0,y=0.\n        # note that for 'cyl' x,y == lon,lat\n        if self.projection != 'ob_tran':\n            self.projparams['x_0']=-llcrnrx\n            self.projparams['y_0']=-llcrnry\n        # reset with x_0, y_0.\n        if self.projection not in ['cyl','ob_tran']:\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnry = 0.\n            llcrnrx = 0.\n        elif self.projection != 'ob_tran':\n            llcrnrx = llcrnrlon\n            llcrnry = llcrnrlat\n        if urcrnrislatlon:\n            self.urcrnrlon = urcrnrlon\n            self.urcrnrlat = urcrnrlat\n            if self.projection not in ['ortho','geos','nsper','aeqd'] + _pseudocyl:\n                urcrnrx,urcrnry = self(urcrnrlon,urcrnrlat)\n                if self.projection == 'ob_tran':\n                    urcrnrx = _rad2dg*urcrnrx; urcrnry = _rad2dg*urcrnry\n                    if urcrnrx < 0: urcrnrx = urcrnrx + 360\n            elif self.projection in ['ortho','geos','nsper','aeqd']:\n                if self._fulldisk:\n                    urcrnrx = 2.*self._width\n                    urcrnry = 2.*self._height\n                else:\n                    urcrnrx,urcrnry = self(urcrnrlon,urcrnrlat)\n                    if urcrnrx > 1.e20 or urcrnry > 1.e20:\n                        raise ValueError(_upper_right_out_of_bounds)\n            elif self.projection in _pseudocyl:\n                xtmp,urcrnry = self(projparams['lon_0'],90.)\n                urcrnrx,xtmp = self(projparams['lon_0']+180.,0)\n        else:\n            urcrnrx = urcrnrlon\n            urcrnry = urcrnrlat\n            urcrnrlon, urcrnrlat = self(urcrnrx, urcrnry, inverse=True)\n            self.urcrnrlon = urcrnrlon\n            self.urcrnrlat = urcrnrlat\n\n        # corners of domain.\n        self.llcrnrx = llcrnrx\n        self.llcrnry = llcrnry\n        self.urcrnrx = urcrnrx\n        self.urcrnry = urcrnry\n        if urcrnrx > llcrnrx:\n            self.xmin = llcrnrx\n            self.xmax = urcrnrx\n        else:\n            self.xmax = llcrnrx\n            self.xmin = urcrnrx\n        if urcrnry > llcrnry:\n            self.ymin = llcrnry\n            self.ymax = urcrnry\n        else:\n            self.ymax = llcrnry\n            self.ymin = urcrnry\n\n    def __call__(self, *args, **kw):\n        # x,y,inverse=False):\n        \"\"\"\n        Calling a Proj class instance with the arguments lon, lat will\n        convert lon/lat (in degrees) to x/y native map projection\n        coordinates (in meters).  If optional keyword 'inverse' is\n        True (default is False), the inverse transformation from x/y\n        to lon/lat is performed.\n\n        For cylindrical equidistant projection ('cyl'), this\n        does nothing (i.e. x,y == lon,lat).\n\n        lon,lat can be either scalar floats or N arrays.\n        \"\"\"\n        if len(args) == 1:\n            xy = args[0]\n            onearray = True\n        else:\n            x,y = args\n            onearray = False\n        if self.projection == 'cyl': # for cyl x,y == lon,lat\n            if onearray:\n                return xy\n            else:\n                return x,y\n        inverse = kw.get('inverse', False)\n        if onearray:\n            outxy = self._proj4(xy, inverse=inverse)\n        else:\n            outx,outy = self._proj4(x, y, inverse=inverse)\n        if inverse:\n            if self.projection in ['merc','mill','gall']:\n                if self.projection == 'merc':\n                    coslat = math.cos(math.radians(self.projparams['lat_ts']))\n                    sinlat = math.sin(math.radians(self.projparams['lat_ts']))\n                else:\n                    coslat = 1.\n                    sinlat = 0.\n                # radius of curvature of the ellipse perpendicular to\n                # the plane of the meridian.\n                rcurv = self.rmajor*coslat/math.sqrt(1.-self.esq*sinlat**2)\n                if onearray:\n                    outxy[:,0] = _rad2dg*(xy[:,0]/rcurv) + self.llcrnrlon\n                else:\n                    try: # x a scalar or an array\n                        outx = _rad2dg*(x/rcurv) + self.llcrnrlon\n                    except: # x a sequence\n                        outx = [_rad2dg*(xi/rcurv) + self.llcrnrlon for xi in x]\n        else:\n            if self.projection in ['merc','mill','gall']:\n                if self.projection == 'merc':\n                    coslat = math.cos(math.radians(self.projparams['lat_ts']))\n                    sinlat = math.sin(math.radians(self.projparams['lat_ts']))\n                else:\n                    coslat = 1.\n                    sinlat = 0.\n                # radius of curvature of the ellipse perpendicular to\n                # the plane of the meridian.\n                rcurv = self.rmajor*coslat/math.sqrt(1.-self.esq*sinlat**2)\n                if onearray:\n                    outxy[:,0] = rcurv*_dg2rad*(xy[:,0]-self.llcrnrlon)\n                else:\n                    try: # x is a scalar or an array\n                        outx = rcurv*_dg2rad*(x-self.llcrnrlon)\n                    except: # x is a sequence.\n                        outx = [rcurv*_dg2rad*(xi-self.llcrnrlon) for xi in x]\n        if onearray:\n            return outxy\n        else:\n            return outx, outy\n\n    def makegrid(self,nx,ny,returnxy=False):\n        \"\"\"\n        return arrays of shape (ny,nx) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n        if returnxy=True, the x,y values of the grid are returned also.\n        \"\"\"\n        dx = (self.urcrnrx-self.llcrnrx)/(nx-1)\n        dy = (self.urcrnry-self.llcrnry)/(ny-1)\n        x = self.llcrnrx+dx*np.indices((ny,nx),np.float32)[1,:,:]\n        y = self.llcrnry+dy*np.indices((ny,nx),np.float32)[0,:,:]\n        lons, lats = self(x, y, inverse=True)\n        if returnxy:\n            return lons, lats, x, y\n        else:\n            return lons, lats\n\n    def makegrid3d(self,nx,ny,returnxy=False):\n        \"\"\"\n        return array of shape (ny,nx, 2) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n        if returnxy=True, the x,y values of the grid are returned also.\n        \"\"\"\n        dx = (self.urcrnrx-self.llcrnrx)/(nx-1)\n        dy = (self.urcrnry-self.llcrnry)/(ny-1)\n        xy = np.empty((ny,nx,2), np.float64)\n        xy[...,0] = self.llcrnrx+dx*np.indices((ny,nx),np.float32)[1,:,:]\n        xy[...,1] = self.llcrnry+dy*np.indices((ny,nx),np.float32)[0,:,:]\n        lonlat = self(xy, inverse=True)\n        if returnxy:\n            return lonlat, xy\n        else:\n            return lonlat",
  "def __init__(self,projparams,llcrnrlon,llcrnrlat,\n                      urcrnrlon,urcrnrlat,urcrnrislatlon=True):\n        \"\"\"\n        initialize a Proj class instance.\n\n        Input 'projparams' is a dictionary containing proj map\n        projection control parameter key/value pairs.\n        See the proj documentation (http://www.remotesensing.org/proj/)\n        for details.\n\n        llcrnrlon,llcrnrlat are lon and lat (in degrees) of lower\n        left hand corner of projection region.\n\n        urcrnrlon,urcrnrlat are lon and lat (in degrees) of upper\n        right hand corner of projection region if urcrnrislatlon=True\n        (default). Otherwise, urcrnrlon,urcrnrlat are x,y in projection\n        coordinates (units meters), assuming the lower left corner is x=0,y=0.\n        \"\"\"\n        self.projparams = projparams\n        self.projection = projparams['proj']\n        # rmajor is the semi-major axis.\n        # rminor is the semi-minor axis.\n        # esq is eccentricity squared.\n        try:\n            self.rmajor = projparams['a']\n            self.rminor = projparams['b']\n        except:\n            try:\n                self.rmajor = projparams['R']\n            except:\n                self.rmajor = projparams['bR_a']\n            self.rminor = self.rmajor\n        if self.rmajor == self.rminor:\n            self.ellipsoid = False\n        else:\n            self.ellipsoid = True\n        self.flattening = (self.rmajor-self.rminor)/self.rmajor\n        self.esq = (self.rmajor**2 - self.rminor**2)/self.rmajor**2\n        self.llcrnrlon = llcrnrlon\n        self.llcrnrlat = llcrnrlat\n        if self.projection == 'cyl':\n            llcrnrx = llcrnrlon\n            llcrnry = llcrnrlat\n        elif self.projection == 'ob_tran':\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnrx,llcrnry = self(llcrnrlon,llcrnrlat)\n            llcrnrx = _rad2dg*llcrnrx; llcrnry = _rad2dg*llcrnry\n            if llcrnrx < 0: llcrnrx = llcrnrx + 360\n        elif self.projection in 'ortho':\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                self._proj4 = pyproj.Proj(projparams)\n                llcrnrx = -self.rmajor\n                llcrnry = -self.rmajor\n                self._width = 0.5*(self.rmajor+self.rminor)\n                self._height = 0.5*(self.rmajor+self.rminor)\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                self._proj4 = pyproj.Proj(projparams)\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection == 'aeqd' and\\\n             (llcrnrlon == -180 and llcrnrlat == -90  and urcrnrlon == 180 and\\\n             urcrnrlat == 90):\n            self._fulldisk = True\n            self._proj4 = pyproj.Proj(projparams)\n            # raise an exception for ellipsoids - there appears to be a bug\n            # in proj4 that causes the inverse transform to fail for points\n            # more than 90 degrees of arc away from center point for ellipsoids\n            # (works fine for spheres) - below is an example\n            #from pyproj import Proj\n            #p1 = Proj(proj='aeqd',a=6378137.00,b=6356752.3142,lat_0=0,lon_0=0)\n            #x,y= p1(91,0)\n            #lon,lat = p1(x,y,inverse=True) # lon is 89 instead of 91\n            if self.ellipsoid:\n                raise ValueError(\n                    \"full disk (whole world) Azimuthal Equidistant projection \"\n                    \"can only be drawn for a perfect sphere\")\n            llcrnrx = -np.pi*self.rmajor\n            llcrnry = -np.pi*self.rmajor\n            self._width = -llcrnrx\n            self._height = -llcrnry\n            urcrnrx = -llcrnrx\n            urcrnry = -llcrnry\n        elif self.projection == 'geos':\n            self._proj4 = pyproj.Proj(projparams)\n            # find major and minor axes of ellipse defining map proj region.\n            # h is measured from surface of earth at equator.\n            h = projparams['h'] + self.rmajor\n            # latitude of horizon on central meridian\n            lonmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # longitude of horizon on equator\n            latmax = 90.-(180./np.pi)*np.arcsin(self.rminor/h)\n            # truncate to nearest hundredth of a degree (to make sure\n            # they aren't slightly over the horizon)\n            latmax = int(100*latmax)/100.\n            lonmax = int(100*lonmax)/100.\n            # width and height of visible projection\n            P = pyproj.Proj(proj='geos',a=self.rmajor,\\\n                            b=self.rminor,lat_0=0,lon_0=0,h=projparams['h'])\n            x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)\n            width = x2; height = y1\n            self._height = height\n            self._width = width\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                llcrnrx = -width\n                llcrnry = -height\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection == 'nsper':\n            self._proj4 = pyproj.Proj(projparams)\n            # find major and minor axes of ellipse defining map proj region.\n            # h is measured from surface of earth at equator.\n            h = projparams['h'] + self.rmajor\n            # latitude of horizon on central meridian\n            lonmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # longitude of horizon on equator\n            latmax = 90.-(180./np.pi)*np.arcsin(self.rmajor/h)\n            # truncate to nearest hundredth of a degree (to make sure\n            # they aren't slightly over the horizon)\n            latmax = int(100*latmax)/100.\n            lonmax = int(100*lonmax)/100.\n            # width and height of visible projection\n            P = pyproj.Proj(proj='nsper',a=self.rmajor,\\\n                            b=self.rminor,lat_0=0,lon_0=0,h=projparams['h'])\n            x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)\n            width = x2; height = y1\n            self._height = height\n            self._width = width\n            if (llcrnrlon == -180 and llcrnrlat == -90 and\n                urcrnrlon == 180 and urcrnrlat == 90):\n                self._fulldisk = True\n                llcrnrx = -width\n                llcrnry = -height\n                urcrnrx = -llcrnrx\n                urcrnry = -llcrnry\n            else:\n                self._fulldisk = False\n                llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n                if llcrnrx > 1.e20 or llcrnry > 1.e20:\n                    raise ValueError(_lower_left_out_of_bounds)\n        elif self.projection in _pseudocyl:\n            self._proj4 = pyproj.Proj(projparams)\n            xtmp,urcrnry = self(projparams['lon_0'],90.)\n            urcrnrx,xtmp = self(projparams['lon_0']+180.,0)\n            llcrnrx = -urcrnrx\n            llcrnry = -urcrnry\n            if self.ellipsoid and self.projection in ['kav7','eck4','mbtfpq']:\n                msg = \"this projection can only be drawn for a perfect sphere\"\n                raise ValueError(msg)\n        else:\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnrx, llcrnry = self(llcrnrlon,llcrnrlat)\n            if self.projection == 'aeqd': self._fulldisk=False\n        # compute x_0, y_0 so ll corner of domain is x=0,y=0.\n        # note that for 'cyl' x,y == lon,lat\n        if self.projection != 'ob_tran':\n            self.projparams['x_0']=-llcrnrx\n            self.projparams['y_0']=-llcrnry\n        # reset with x_0, y_0.\n        if self.projection not in ['cyl','ob_tran']:\n            self._proj4 = pyproj.Proj(projparams)\n            llcrnry = 0.\n            llcrnrx = 0.\n        elif self.projection != 'ob_tran':\n            llcrnrx = llcrnrlon\n            llcrnry = llcrnrlat\n        if urcrnrislatlon:\n            self.urcrnrlon = urcrnrlon\n            self.urcrnrlat = urcrnrlat\n            if self.projection not in ['ortho','geos','nsper','aeqd'] + _pseudocyl:\n                urcrnrx,urcrnry = self(urcrnrlon,urcrnrlat)\n                if self.projection == 'ob_tran':\n                    urcrnrx = _rad2dg*urcrnrx; urcrnry = _rad2dg*urcrnry\n                    if urcrnrx < 0: urcrnrx = urcrnrx + 360\n            elif self.projection in ['ortho','geos','nsper','aeqd']:\n                if self._fulldisk:\n                    urcrnrx = 2.*self._width\n                    urcrnry = 2.*self._height\n                else:\n                    urcrnrx,urcrnry = self(urcrnrlon,urcrnrlat)\n                    if urcrnrx > 1.e20 or urcrnry > 1.e20:\n                        raise ValueError(_upper_right_out_of_bounds)\n            elif self.projection in _pseudocyl:\n                xtmp,urcrnry = self(projparams['lon_0'],90.)\n                urcrnrx,xtmp = self(projparams['lon_0']+180.,0)\n        else:\n            urcrnrx = urcrnrlon\n            urcrnry = urcrnrlat\n            urcrnrlon, urcrnrlat = self(urcrnrx, urcrnry, inverse=True)\n            self.urcrnrlon = urcrnrlon\n            self.urcrnrlat = urcrnrlat\n\n        # corners of domain.\n        self.llcrnrx = llcrnrx\n        self.llcrnry = llcrnry\n        self.urcrnrx = urcrnrx\n        self.urcrnry = urcrnry\n        if urcrnrx > llcrnrx:\n            self.xmin = llcrnrx\n            self.xmax = urcrnrx\n        else:\n            self.xmax = llcrnrx\n            self.xmin = urcrnrx\n        if urcrnry > llcrnry:\n            self.ymin = llcrnry\n            self.ymax = urcrnry\n        else:\n            self.ymax = llcrnry\n            self.ymin = urcrnry",
  "def __call__(self, *args, **kw):\n        # x,y,inverse=False):\n        \"\"\"\n        Calling a Proj class instance with the arguments lon, lat will\n        convert lon/lat (in degrees) to x/y native map projection\n        coordinates (in meters).  If optional keyword 'inverse' is\n        True (default is False), the inverse transformation from x/y\n        to lon/lat is performed.\n\n        For cylindrical equidistant projection ('cyl'), this\n        does nothing (i.e. x,y == lon,lat).\n\n        lon,lat can be either scalar floats or N arrays.\n        \"\"\"\n        if len(args) == 1:\n            xy = args[0]\n            onearray = True\n        else:\n            x,y = args\n            onearray = False\n        if self.projection == 'cyl': # for cyl x,y == lon,lat\n            if onearray:\n                return xy\n            else:\n                return x,y\n        inverse = kw.get('inverse', False)\n        if onearray:\n            outxy = self._proj4(xy, inverse=inverse)\n        else:\n            outx,outy = self._proj4(x, y, inverse=inverse)\n        if inverse:\n            if self.projection in ['merc','mill','gall']:\n                if self.projection == 'merc':\n                    coslat = math.cos(math.radians(self.projparams['lat_ts']))\n                    sinlat = math.sin(math.radians(self.projparams['lat_ts']))\n                else:\n                    coslat = 1.\n                    sinlat = 0.\n                # radius of curvature of the ellipse perpendicular to\n                # the plane of the meridian.\n                rcurv = self.rmajor*coslat/math.sqrt(1.-self.esq*sinlat**2)\n                if onearray:\n                    outxy[:,0] = _rad2dg*(xy[:,0]/rcurv) + self.llcrnrlon\n                else:\n                    try: # x a scalar or an array\n                        outx = _rad2dg*(x/rcurv) + self.llcrnrlon\n                    except: # x a sequence\n                        outx = [_rad2dg*(xi/rcurv) + self.llcrnrlon for xi in x]\n        else:\n            if self.projection in ['merc','mill','gall']:\n                if self.projection == 'merc':\n                    coslat = math.cos(math.radians(self.projparams['lat_ts']))\n                    sinlat = math.sin(math.radians(self.projparams['lat_ts']))\n                else:\n                    coslat = 1.\n                    sinlat = 0.\n                # radius of curvature of the ellipse perpendicular to\n                # the plane of the meridian.\n                rcurv = self.rmajor*coslat/math.sqrt(1.-self.esq*sinlat**2)\n                if onearray:\n                    outxy[:,0] = rcurv*_dg2rad*(xy[:,0]-self.llcrnrlon)\n                else:\n                    try: # x is a scalar or an array\n                        outx = rcurv*_dg2rad*(x-self.llcrnrlon)\n                    except: # x is a sequence.\n                        outx = [rcurv*_dg2rad*(xi-self.llcrnrlon) for xi in x]\n        if onearray:\n            return outxy\n        else:\n            return outx, outy",
  "def makegrid(self,nx,ny,returnxy=False):\n        \"\"\"\n        return arrays of shape (ny,nx) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n        if returnxy=True, the x,y values of the grid are returned also.\n        \"\"\"\n        dx = (self.urcrnrx-self.llcrnrx)/(nx-1)\n        dy = (self.urcrnry-self.llcrnry)/(ny-1)\n        x = self.llcrnrx+dx*np.indices((ny,nx),np.float32)[1,:,:]\n        y = self.llcrnry+dy*np.indices((ny,nx),np.float32)[0,:,:]\n        lons, lats = self(x, y, inverse=True)\n        if returnxy:\n            return lons, lats, x, y\n        else:\n            return lons, lats",
  "def makegrid3d(self,nx,ny,returnxy=False):\n        \"\"\"\n        return array of shape (ny,nx, 2) containing lon,lat coordinates of\n        an equally spaced native projection grid.\n        if returnxy=True, the x,y values of the grid are returned also.\n        \"\"\"\n        dx = (self.urcrnrx-self.llcrnrx)/(nx-1)\n        dy = (self.urcrnry-self.llcrnry)/(ny-1)\n        xy = np.empty((ny,nx,2), np.float64)\n        xy[...,0] = self.llcrnrx+dx*np.indices((ny,nx),np.float32)[1,:,:]\n        xy[...,1] = self.llcrnry+dy*np.indices((ny,nx),np.float32)[0,:,:]\n        lonlat = self(xy, inverse=True)\n        if returnxy:\n            return lonlat, xy\n        else:\n            return lonlat",
  "def JulianDayFromDate(date,calendar='standard'):\n\n    \"\"\"\ncreates a Julian Day from a 'datetime-like' object.  Returns the fractional\nJulian Day (resolution 1 second).\n\nif calendar='standard' or 'gregorian' (default), Julian day follows Julian\nCalendar on and before 1582-10-5, Gregorian calendar after 1582-10-15.\n\nif calendar='proleptic_gregorian', Julian Day follows gregorian calendar.\n\nif calendar='julian', Julian Day follows julian calendar.\n\nAlgorithm:\n\nMeeus, Jean (1998) Astronomical Algorithms (2nd Edition). Willmann-Bell,\nVirginia. p. 63\n    \"\"\"\n    # based on redate.py by David Finlayson.\n    year=date.year; month=date.month; day=date.day\n    hour=date.hour; minute=date.minute; second=date.second\n    # Convert time to fractions of a day\n    day = day + hour/24.0 + minute/1440.0 + second/86400.0\n    # Start Meeus algorithm (variables are in his notation)\n    if (month < 3):\n        month = month + 12\n        year = year - 1\n    A = int(year/100)\n    jd = int(365.25 * (year + 4716)) + int(30.6001 * (month + 1)) + \\\n         day - 1524.5\n    # optionally adjust the jd for the switch from\n    # the Julian to Gregorian Calendar\n    # here assumed to have occurred the day after 1582 October 4\n    if calendar in ['standard','gregorian']:\n        if jd >= 2299170.5:\n            # 1582 October 15 (Gregorian Calendar)\n            B = 2 - A + int(A/4)\n        elif jd < 2299160.5:\n            # 1582 October 5 (Julian Calendar)\n            B = 0\n        else:\n            raise ValueError('impossible date (falls in gap between end of Julian calendar and beginning of Gregorian calendar')\n    elif calendar == 'proleptic_gregorian':\n        B = 2 - A + int(A/4)\n    elif calendar == 'julian':\n        B = 0\n    else:\n        raise ValueError('unknown calendar, must be one of julian,standard,gregorian,proleptic_gregorian, got %s' % calendar)\n    # adjust for Julian calendar if necessary\n    jd = jd + B\n    return jd",
  "def epem(date):\n    \"\"\"\n    input: date - datetime object (assumed UTC)\n    ouput: gha - Greenwich hour angle, the angle between the Greenwich\n           meridian and the meridian containing the subsolar point.\n           dec - solar declination.\n    \"\"\"\n    dg2rad = np.pi/180.\n    rad2dg = 1./dg2rad\n    # compute julian day from UTC datetime object.\n    # datetime objects use proleptic gregorian calendar.\n    jday = JulianDayFromDate(date,calendar='proleptic_gregorian')\n    jd = np.floor(jday) # truncate to integer.\n    # utc hour.\n    ut = date.hour + date.minute/60. + date.second/3600.\n    # calculate number of centuries from J2000\n    t = (jd + (ut/24.) - 2451545.0) / 36525.\n    # mean longitude corrected for aberration\n    l = (280.460 + 36000.770 * t) % 360\n    # mean anomaly\n    g = 357.528 + 35999.050 * t\n    # ecliptic longitude\n    lm = l + 1.915 * np.sin(g*dg2rad) + 0.020 * np.sin(2*g*dg2rad)\n    # obliquity of the ecliptic\n    ep = 23.4393 - 0.01300 * t\n    # equation of time\n    eqtime = -1.915*np.sin(g*dg2rad) - 0.020*np.sin(2*g*dg2rad) \\\n            + 2.466*np.sin(2*lm*dg2rad) - 0.053*np.sin(4*lm*dg2rad)\n    # Greenwich hour angle\n    gha = 15*ut - 180 + eqtime\n    # declination of sun\n    dec = np.arcsin(np.sin(ep*dg2rad) * np.sin(lm*dg2rad)) * rad2dg\n    return gha, dec",
  "def daynight_terminator(date, delta, lonmin, lonmax):\n    \"\"\"\n    date is datetime object (assumed UTC).\n    nlons is # of longitudes used to compute terminator.\"\"\"\n    dg2rad = np.pi/180.\n    lons = np.arange(lonmin,lonmax+0.5*delta,delta,dtype=np.float32)\n    # compute greenwich hour angle and solar declination\n    # from datetime object (assumed UTC).\n    tau, dec = epem(date)\n    # compute day/night terminator from hour angle, declination.\n    longitude = lons + tau\n    lats = np.arctan(-np.cos(longitude*dg2rad)/np.tan(dec*dg2rad))/dg2rad\n    return lons, lats, tau, dec",
  "def daynight_grid(date, delta, lonmin, lonmax):\n    \"\"\"\n    date is datetime object (assumed UTC).\n    delta is the grid interval (in degrees) used to compute terminator.\"\"\"\n    lons, lats, tau, dec = daynight_terminator(date, delta, lonmin, lonmax)\n    # create day/night grid (1 for night, 0 for day)\n    lats2 = np.arange(-90,90+0.5*delta,delta,dtype=np.float32)\n    nlons = len(lons); nlats = len(lats2)\n    lons2, lats2 = np.meshgrid(lons,lats2)\n    lats = lats[np.newaxis,:]*np.ones((nlats,nlons),dtype=np.float32)\n    daynight = np.ones(lons2.shape, np.int8)\n    if dec > 0: # NH summer\n        daynight = np.where(lats2>lats,0,daynight)\n    else: # NH winter\n        daynight = np.where(lats2<lats,0,daynight)\n    daynight = ma.array(daynight,mask=1-daynight) # mask day areas.\n    return lons2,lats2,daynight",
  "class TestRotateVector(TestCase):\n\n    def make_array(self):\n        lat = np.array([0, 45, 75, 90])\n        lon = np.array([0,90,180,270])\n        u = np.ones((len(lat), len(lon)))\n        v = np.zeros((len(lat), len(lon)))\n        return u,v,lat,lon\n\n    def test_cylindrical(self):\n        # Cylindrical case\n        B = Basemap()\n        u,v,lat,lon=self.make_array()\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        # Check that the vectors are identical.\n        assert_almost_equal(ru, u)\n        assert_almost_equal(rv, v)\n\n    def test_nan(self):\n        B = Basemap()\n        u,v,lat,lon=self.make_array()\n        # Set one element to 0, so that the vector magnitude is 0.\n        u[1,1] = 0.\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        assert not np.isnan(ru).any()\n        assert_almost_equal(u, ru)\n        assert_almost_equal(v, rv)\n\n    def test_npstere(self):\n        # NP Stereographic case\n        B=Basemap(projection='npstere', boundinglat=50., lon_0=0.)\n        u,v,lat,lon=self.make_array()\n        v = np.ones((len(lat), len(lon)))\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        assert_almost_equal(ru[2, :],[1,-1,-1,1], 6)\n        assert_almost_equal(rv[2, :],[1,1,-1,-1], 6)",
  "class TestShiftGrid(TestCase):\n\n    def make_data_cyc(self):\n        loncyc  =  np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300,\\\n            330, 360],dtype=np.float)\n        gridcyc = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,  10,\\\n            11,   0]],dtype=np.float)\n        lonoutcyc  =  np.array([-180, -150, -120, -90, -60, -30, 0, 30,60,90,\\\n            120, 150, 180],dtype=np.float)\n        gridoutcyc = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,3,\\\n            4,   5,   6]],dtype=np.float)\n        return loncyc, gridcyc, lonoutcyc, gridoutcyc\n\n    def make_data_nocyc(self):\n        lonnocyc  =  np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270,\\\n            300, 330],dtype=np.float)\n        gridnocyc = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,\\\n            10,  11]],dtype=np.float)\n        lonoutnocyc  =  np.array([-180, -150, -120, -90, -60, -30, 0, 30, 60,\\\n            90, 120, 150],dtype=np.float)\n        gridoutnocyc = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,\\\n            3,   4,   5]],dtype=np.float)\n        return lonnocyc, gridnocyc, lonoutnocyc, gridoutnocyc\n\n    def make_data_nocyc2(self):\n        lonnocyc2  =  np.array([15, 45, 75, 105, 135, 165, 195, 225, 255, 285,\\\n            315, 345],dtype=np.float)\n        gridnocyc2 = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,\\\n            10,  11]],dtype=np.float)\n        lonoutnocyc2  =  np.array([-165, -135, -105, -75, -45, -15, 15,45,75,\\\n            105, 135, 165],dtype=np.float)\n        gridoutnocyc2 = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,\\\n            3,   4,   5]],dtype=np.float)\n        return lonnocyc2, gridnocyc2, lonoutnocyc2, gridoutnocyc2\n\n    def test_cyc(self):\n        lonin, gridin, lonout, gridout = self.make_data_cyc()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()\n\n    def test_no_cyc(self):\n        lonin, gridin, lonout, gridout = self.make_data_nocyc()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()\n\n    def test_no_cyc2(self):\n        lonin, gridin, lonout, gridout = self.make_data_nocyc2()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()",
  "class TestShiftdata(TestCase):\n\n    def _get_2d_lons(self, lons1d):\n        \"\"\"\n        Generate a 2d grid\n        \"\"\"\n        lats = [10, ] * len(lons1d)\n        return np.meshgrid(lons1d, lats)[0]\n\n    def test_non_monotonous_longitudes(self):\n        \"\"\"\n        when called for scatter, the longitudes passed to shiftdata are\n        not necessarily monotonous...\n        \"\"\"\n        lons = [179, 180, 180, 0, 290, 10, 320, -150, 350, -250, 250]\n        bm = Basemap(lon_0=0)\n\n        # before, having several break points would cause the exception,\n        # inside the shiftdata method called from scatter method.\n        self.assertRaises(ValueError, bm.shiftdata, lons, fix_wrap_around=True)\n\n        lons_new = bm.shiftdata(lons, fix_wrap_around=False)\n\n        # Check if the modified longitudes are inside of the projection region\n        for lon in lons_new:\n            assert lon >= bm.projparams[\"lon_0\"] - 180\n            assert lon <= bm.projparams[\"lon_0\"] + 180\n\n    def test_shiftdata_on_monotonous_lons(self):\n        \"\"\"\n        Test that shiftdata with fix_wrap_around keyword added works as before,\n        when it is True\n        \"\"\"\n\n        bm = Basemap(lon_0=0)\n\n        lons_in = [120, 140, 160, 180, 200, 220]\n        lons_out_expect = [-160, -140,  120,  140,  160,  180]\n        lons_out = bm.shiftdata(lons_in, fix_wrap_around=True)\n\n        assert_almost_equal(lons_out, lons_out_expect)\n\n    def test_2_points_should_work(self):\n        \"\"\"\n        Shiftdata should work with 2 points\n        \"\"\"\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n\n        lons_expected = [10, 15, 20]\n        lonsout = bm.shiftdata(lons_expected[:])\n        assert_almost_equal(lons_expected, lonsout)\n\n        lonsout_expected = bm.shiftdata([10, 361, 362])\n        lonsout = bm.shiftdata([10, 361])\n        assert_almost_equal(lonsout_expected[:len(lonsout)], lonsout)\n\n    def test_1_point_should_work(self):\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n\n        # should not fail\n        lonsout = bm.shiftdata([361])\n        assert_almost_equal(lonsout, [1.0,])\n\n        lonsout = bm.shiftdata([10])\n        assert_almost_equal(lonsout, [10.0,])\n\n        lonsin = np.array([361.0])\n        lonsin.shape = (1, 1)\n        lonsout = bm.shiftdata(lonsin[:])\n        assert_almost_equal(lonsout.squeeze(), [1.0,])\n\n    def test_less_than_n_by_3_points_should_work(self):\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n        lons_expected = self._get_2d_lons([10, 15, 20])\n\n        # nothing should change\n        lonsout = bm.shiftdata(lons_expected)\n        assert_almost_equal(lons_expected, lonsout)\n\n        # shift n x 3 and n x 2 grids and compare results over overlapping region\n        lonsin = self._get_2d_lons([10, 361, 362])\n        lonsout_expected = bm.shiftdata(lonsin[:])[:, :2]\n        lonsout = bm.shiftdata(lonsin[:, :2])\n        assert_almost_equal(lonsout_expected, lonsout)",
  "class TestProjectCoords(TestCase):\n    def get_data(self):\n        lons, lats = np.arange(-180, 180, 20), np.arange(-90, 90, 10)\n        lats, lons = np.meshgrid(lats, lons)\n        lons, lats = lons.copy(order=\"F\"), lats.copy(order=\"F\")\n        return lons, lats, Basemap(projection=\"sinu\", lon_0=0)\n\n    def test_convert(self):\n        \"\"\"\n        Should not fail on C non-contiguous arrays\n        \"\"\"\n        lons, lats, bmp = self.get_data()\n        assert not lons.flags['C_CONTIGUOUS']\n        assert isinstance(lons, np.ndarray)\n        assert isinstance(bmp, Basemap)\n\n        xx1, yy1 = bmp(lons, lats)\n\n    def test_results_should_be_same_for_c_and_f_order_arrays(self):\n        lons, lats, bmp = self.get_data()\n\n        xx1, yy1 = bmp(lons.copy(order=\"C\"), lats.copy(order=\"C\"))\n        xx2, yy2 = bmp(lons.copy(order=\"F\"), lats.copy(order=\"F\"))\n\n        assert_almost_equal(xx1, xx2)\n        assert_almost_equal(yy1, yy2)",
  "class TestInputValidation(TestCase):\n    def test_optional_casting(self):\n        # Test for the bug reported in gh:#260\n        d = {'llcrnrlat': 28.979408, 'urcrnrlat': 35.19622,\n             'llcrnrlon': -95.614105, 'urcrnrlon': -77.554749,\n             'lon_0': -87.0, 'resolution': 'c', 'lat_0': 32.070374,\n             'projection': 'lcc'}\n        bmap1 = Basemap(lat_1=30.0, **d)\n        bmap2 = Basemap(lat_1=np.array([30.0], dtype='float32'), **d)\n        assert bmap1.proj4string == bmap2.proj4string",
  "class TestOrthoProjPolygons(TestCase):\n    def test_basemapcreation_should_not_fail(self):\n        # different resolutions should work\n        for r in ['c', 'l', 'i', 'h', 'f']:\n            m = Basemap(projection='ortho',resolution=r,lat_1=45.,lat_2=55,lat_0=50,lon_0=-107.)\n        pass",
  "class TestArcgisimage(TestCase):\n\tdef test_cyl_proj_should_not_fail(self):\n\t\tm = Basemap(projection='cyl',\n\t\t\t\t\tllcrnrlon=-90,llcrnrlat=30,\n\t\t\t\t\turcrnrlon=-60,urcrnrlat=60)\n\t\tm.arcgisimage(verbose=True)",
  "def test():\n    \"\"\"\n    Run some tests.\n    \"\"\"\n    import unittest\n    from . import test\n    runner = unittest.TextTestRunner()\n    suite = unittest.findTestCases(test)\n    runner.run(suite)",
  "def make_array(self):\n        lat = np.array([0, 45, 75, 90])\n        lon = np.array([0,90,180,270])\n        u = np.ones((len(lat), len(lon)))\n        v = np.zeros((len(lat), len(lon)))\n        return u,v,lat,lon",
  "def test_cylindrical(self):\n        # Cylindrical case\n        B = Basemap()\n        u,v,lat,lon=self.make_array()\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        # Check that the vectors are identical.\n        assert_almost_equal(ru, u)\n        assert_almost_equal(rv, v)",
  "def test_nan(self):\n        B = Basemap()\n        u,v,lat,lon=self.make_array()\n        # Set one element to 0, so that the vector magnitude is 0.\n        u[1,1] = 0.\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        assert not np.isnan(ru).any()\n        assert_almost_equal(u, ru)\n        assert_almost_equal(v, rv)",
  "def test_npstere(self):\n        # NP Stereographic case\n        B=Basemap(projection='npstere', boundinglat=50., lon_0=0.)\n        u,v,lat,lon=self.make_array()\n        v = np.ones((len(lat), len(lon)))\n        ru, rv = B.rotate_vector(u,v, lon, lat)\n        assert_almost_equal(ru[2, :],[1,-1,-1,1], 6)\n        assert_almost_equal(rv[2, :],[1,1,-1,-1], 6)",
  "def make_data_cyc(self):\n        loncyc  =  np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300,\\\n            330, 360],dtype=np.float)\n        gridcyc = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,  10,\\\n            11,   0]],dtype=np.float)\n        lonoutcyc  =  np.array([-180, -150, -120, -90, -60, -30, 0, 30,60,90,\\\n            120, 150, 180],dtype=np.float)\n        gridoutcyc = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,3,\\\n            4,   5,   6]],dtype=np.float)\n        return loncyc, gridcyc, lonoutcyc, gridoutcyc",
  "def make_data_nocyc(self):\n        lonnocyc  =  np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270,\\\n            300, 330],dtype=np.float)\n        gridnocyc = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,\\\n            10,  11]],dtype=np.float)\n        lonoutnocyc  =  np.array([-180, -150, -120, -90, -60, -30, 0, 30, 60,\\\n            90, 120, 150],dtype=np.float)\n        gridoutnocyc = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,\\\n            3,   4,   5]],dtype=np.float)\n        return lonnocyc, gridnocyc, lonoutnocyc, gridoutnocyc",
  "def make_data_nocyc2(self):\n        lonnocyc2  =  np.array([15, 45, 75, 105, 135, 165, 195, 225, 255, 285,\\\n            315, 345],dtype=np.float)\n        gridnocyc2 = np.array([[0,  1,  2,  3,   4,   5,   6,   7,   8,   9,\\\n            10,  11]],dtype=np.float)\n        lonoutnocyc2  =  np.array([-165, -135, -105, -75, -45, -15, 15,45,75,\\\n            105, 135, 165],dtype=np.float)\n        gridoutnocyc2 = np.array([[   6,    7,   8,    9,  10,  11, 0,  1,  2,\\\n            3,   4,   5]],dtype=np.float)\n        return lonnocyc2, gridnocyc2, lonoutnocyc2, gridoutnocyc2",
  "def test_cyc(self):\n        lonin, gridin, lonout, gridout = self.make_data_cyc()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()",
  "def test_no_cyc(self):\n        lonin, gridin, lonout, gridout = self.make_data_nocyc()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()",
  "def test_no_cyc2(self):\n        lonin, gridin, lonout, gridout = self.make_data_nocyc2()\n        grid, lon = shiftgrid(lonin[len(lonin)//2], gridin, lonin, start=False)\n        assert (lon==lonout).all()\n        assert (grid==gridout).all()",
  "def _get_2d_lons(self, lons1d):\n        \"\"\"\n        Generate a 2d grid\n        \"\"\"\n        lats = [10, ] * len(lons1d)\n        return np.meshgrid(lons1d, lats)[0]",
  "def test_non_monotonous_longitudes(self):\n        \"\"\"\n        when called for scatter, the longitudes passed to shiftdata are\n        not necessarily monotonous...\n        \"\"\"\n        lons = [179, 180, 180, 0, 290, 10, 320, -150, 350, -250, 250]\n        bm = Basemap(lon_0=0)\n\n        # before, having several break points would cause the exception,\n        # inside the shiftdata method called from scatter method.\n        self.assertRaises(ValueError, bm.shiftdata, lons, fix_wrap_around=True)\n\n        lons_new = bm.shiftdata(lons, fix_wrap_around=False)\n\n        # Check if the modified longitudes are inside of the projection region\n        for lon in lons_new:\n            assert lon >= bm.projparams[\"lon_0\"] - 180\n            assert lon <= bm.projparams[\"lon_0\"] + 180",
  "def test_shiftdata_on_monotonous_lons(self):\n        \"\"\"\n        Test that shiftdata with fix_wrap_around keyword added works as before,\n        when it is True\n        \"\"\"\n\n        bm = Basemap(lon_0=0)\n\n        lons_in = [120, 140, 160, 180, 200, 220]\n        lons_out_expect = [-160, -140,  120,  140,  160,  180]\n        lons_out = bm.shiftdata(lons_in, fix_wrap_around=True)\n\n        assert_almost_equal(lons_out, lons_out_expect)",
  "def test_2_points_should_work(self):\n        \"\"\"\n        Shiftdata should work with 2 points\n        \"\"\"\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n\n        lons_expected = [10, 15, 20]\n        lonsout = bm.shiftdata(lons_expected[:])\n        assert_almost_equal(lons_expected, lonsout)\n\n        lonsout_expected = bm.shiftdata([10, 361, 362])\n        lonsout = bm.shiftdata([10, 361])\n        assert_almost_equal(lonsout_expected[:len(lonsout)], lonsout)",
  "def test_1_point_should_work(self):\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n\n        # should not fail\n        lonsout = bm.shiftdata([361])\n        assert_almost_equal(lonsout, [1.0,])\n\n        lonsout = bm.shiftdata([10])\n        assert_almost_equal(lonsout, [10.0,])\n\n        lonsin = np.array([361.0])\n        lonsin.shape = (1, 1)\n        lonsout = bm.shiftdata(lonsin[:])\n        assert_almost_equal(lonsout.squeeze(), [1.0,])",
  "def test_less_than_n_by_3_points_should_work(self):\n        bm = Basemap(llcrnrlon=0, llcrnrlat=-80, urcrnrlon=360, urcrnrlat=80, projection='mill')\n        lons_expected = self._get_2d_lons([10, 15, 20])\n\n        # nothing should change\n        lonsout = bm.shiftdata(lons_expected)\n        assert_almost_equal(lons_expected, lonsout)\n\n        # shift n x 3 and n x 2 grids and compare results over overlapping region\n        lonsin = self._get_2d_lons([10, 361, 362])\n        lonsout_expected = bm.shiftdata(lonsin[:])[:, :2]\n        lonsout = bm.shiftdata(lonsin[:, :2])\n        assert_almost_equal(lonsout_expected, lonsout)",
  "def get_data(self):\n        lons, lats = np.arange(-180, 180, 20), np.arange(-90, 90, 10)\n        lats, lons = np.meshgrid(lats, lons)\n        lons, lats = lons.copy(order=\"F\"), lats.copy(order=\"F\")\n        return lons, lats, Basemap(projection=\"sinu\", lon_0=0)",
  "def test_convert(self):\n        \"\"\"\n        Should not fail on C non-contiguous arrays\n        \"\"\"\n        lons, lats, bmp = self.get_data()\n        assert not lons.flags['C_CONTIGUOUS']\n        assert isinstance(lons, np.ndarray)\n        assert isinstance(bmp, Basemap)\n\n        xx1, yy1 = bmp(lons, lats)",
  "def test_results_should_be_same_for_c_and_f_order_arrays(self):\n        lons, lats, bmp = self.get_data()\n\n        xx1, yy1 = bmp(lons.copy(order=\"C\"), lats.copy(order=\"C\"))\n        xx2, yy2 = bmp(lons.copy(order=\"F\"), lats.copy(order=\"F\"))\n\n        assert_almost_equal(xx1, xx2)\n        assert_almost_equal(yy1, yy2)",
  "def test_optional_casting(self):\n        # Test for the bug reported in gh:#260\n        d = {'llcrnrlat': 28.979408, 'urcrnrlat': 35.19622,\n             'llcrnrlon': -95.614105, 'urcrnrlon': -77.554749,\n             'lon_0': -87.0, 'resolution': 'c', 'lat_0': 32.070374,\n             'projection': 'lcc'}\n        bmap1 = Basemap(lat_1=30.0, **d)\n        bmap2 = Basemap(lat_1=np.array([30.0], dtype='float32'), **d)\n        assert bmap1.proj4string == bmap2.proj4string",
  "def test_basemapcreation_should_not_fail(self):\n        # different resolutions should work\n        for r in ['c', 'l', 'i', 'h', 'f']:\n            m = Basemap(projection='ortho',resolution=r,lat_1=45.,lat_2=55,lat_0=50,lon_0=-107.)\n        pass",
  "def test_cyl_proj_should_not_fail(self):\n\t\tm = Basemap(projection='cyl',\n\t\t\t\t\tllcrnrlon=-90,llcrnrlat=30,\n\t\t\t\t\turcrnrlon=-60,urcrnrlat=60)\n\t\tm.arcgisimage(verbose=True)",
  "class GeosLibrary(object):\n    \"\"\"Helper class to download, build and install GEOS.\"\"\"\n\n    def __init__(self, version, root=None):\n        \"\"\"Initialise a new :class:`GeosLibrary` instance.\"\"\"\n\n        self.version_tuple = tuple(map(int, version.split(\".\")))\n\n        if root is None:\n            self.temp = True\n            self.root = tempfile.mkdtemp(prefix=\"tmp_geoslibrary_\")\n        else:\n            self.temp = False\n            self.root = root\n            try:\n                os.makedirs(self.root)\n            except OSError:\n                pass\n\n    def __del__(self):\n        \"\"\"Clean up after :class:`GeosLibrary` destruction.\"\"\"\n\n        if self.temp:\n            try:\n                shutil.rmtree(self.root)\n            except OSError:\n                pass\n\n    @property\n    def version(self):\n        \"\"\"GEOS library version in string format.\"\"\"\n\n        return \".\".join(map(str, self.version_tuple))\n\n    def download(self):\n        \"\"\"Download GEOS zip source code into :class:`GeosLibrary` root.\"\"\"\n\n        # Define download link.\n        link = \"{0}/{1}.zip\".format(GEOS_BASEURL, self.version)\n        suffix = os.path.splitext(link)[-1]\n\n        # Define output path.\n        zipname = \"geos-{0}\".format(link.rsplit(\"/\", 1)[-1])\n        zippath = os.path.join(self.root, zipname)\n\n        # Handle creation of the HTTP request.\n        kwargs = {}\n        if hasattr(ssl, \"SSLContext\") and hasattr(ssl, \"PROTOCOL_TLSv1_2\"):\n            kwargs.update(context=ssl.SSLContext(ssl.PROTOCOL_TLSv1_2))\n        try:\n            conn = urlopen(link, **kwargs)\n        except TypeError:\n            # Fallback if `urlopen` does not accept context.\n            conn = urlopen(link)\n\n        with contextlib.closing(conn):\n            # Try to get the file timestamp from the HTTP request header.\n            date = conn.headers.get(\"Last-Modified\")\n            if date is not None:\n                date = dt.datetime.strptime(date, URL_DATETIME_FMT)\n                date = date.replace(tzinfo=dt.timezone.utc)\n                date = date.timestamp()\n            with tempfile.NamedTemporaryFile(suffix=suffix) as tmpzipobj:\n                # Copy the buffer into a temporary file.\n                shutil.copyfileobj(conn, tmpzipobj)\n                # Move the file descriptor pointer to the beginning and\n                # simply copy it to the final destination.\n                tmpzipobj.seek(0)\n                with open(zippath, \"wb\") as zipobj:\n                    shutil.copyfileobj(tmpzipobj, zipobj)\n            # Assign the timestamps to the final file if available.\n            if date is not None:\n                os.utime(zippath, (date, date))\n\n    def extract(self, overwrite=True):\n        \"\"\"Decompress GEOS zip source code into :class:`GeosLibrary` root.\"\"\"\n\n        # Download zip file if not present.\n        zippath = os.path.join(self.root, \"geos-{0}.zip\".format(self.version))\n        if not os.path.exists(zippath):\n            self.download()\n\n        # Remove destination folder if present and requested.\n        zipfold = os.path.join(self.root, \"geos-{0}\".format(self.version))\n        if os.path.exists(zipfold):\n            if not overwrite:\n                raise OSError(\"folder '{0}' already exists\".format(zipfold))\n            shutil.rmtree(zipfold)\n\n        # Decompress zip file.\n        with contextlib.closing(ZipFile(zippath, \"r\")) as fd:\n            fd.extractall(self.root)\n\n        # Ensure that GEOS internal sh scripts can be executed.\n        for path in sorted(glob.glob(os.path.join(zipfold, \"tools\", \"*.sh\"))):\n            os.chmod(path, 0o755)\n\n        # Apply specific patches for GEOS < 3.6.0.\n        if self.version_tuple < (3, 6, 0):\n            # The SVN revision file is not created on the fly before 3.6.0.\n            svn_hfile = os.path.join(zipfold, \"geos_svn_revision.h\")\n            if not os.path.exists(svn_hfile):\n                with io.open(svn_hfile, \"wb\") as fd:\n                    text = \"#define GEOS_SVN_REVISION 0\"\n                    fd.write(text.encode())\n            # Reduce warnings when compiling with `nmake` on Windows.\n            cmakefile = os.path.join(zipfold, \"CMakeLists.txt\")\n            if os.path.exists(cmakefile):\n                with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n                    lines = fd.readlines()\n                with io.open(cmakefile, \"wb\") as fd:\n                    oldtext = 'string(REGEX REPLACE \"/W[0-9]\" \"/W4\"'\n                    newtext = oldtext.replace(\"W4\", \"W1\")\n                    for line in lines:\n                        fd.write(line.replace(oldtext, newtext).encode())\n\n        # Apply specific patches for 3.6.0 <= GEOS < 3.7.0 on Windows.\n        if (3, 6, 0) <= self.version_tuple < (3, 7, 0) and os.name == \"nt\":\n            autogen_file = os.path.join(zipfold, \"autogen.bat\")\n            subprocess.call([autogen_file], cwd=zipfold)\n            cppfile = os.path.join(zipfold, \"src\", \"geomgraph\", \"DirectedEdgeStar.cpp\")\n            with io.open(cppfile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(cppfile, \"wb\") as fd:\n                oldtext = \"DirectedEdgeStar::print() const\"\n                newtext = oldtext.replace(\" const\", \"\")\n                for line in lines:\n                    fd.write(line.replace(oldtext, newtext).encode())\n            hfile = os.path.join(zipfold, \"include\", \"geos\", \"geomgraph\", \"DirectedEdgeStar.h\")\n            with io.open(hfile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(hfile, \"wb\") as fd:\n                oldtext = \"virtual std::string print() const;\"\n                newtext = oldtext.replace(\" const\", \"\")\n                for line in lines:\n                    fd.write(line.replace(oldtext, newtext).encode())\n\n        # Patch CMakeLists to link shared geos_c with static geos.\n        if self.version_tuple < (3, 8, 0):\n            cmakefile = os.path.join(zipfold, \"capi\", \"CMakeLists.txt\")\n            oldtext = \"target_link_libraries(geos_c geos)\"\n            newtext = \"target_link_libraries(geos_c geos-static)\"\n        else:\n            cmakefile = os.path.join(zipfold, \"CMakeLists.txt\")\n            oldtext = 'add_library(geos \"\")'\n            newtext = 'add_library(geos STATIC \"\")'\n        with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n            lines = fd.readlines()\n        with io.open(cmakefile, \"wb\") as fd:\n            found_sharedline = False\n            shared_oldtext = \"if(BUILD_SHARED_LIBS)\"\n            shared_newtext = \"if(FALSE)\"\n            for line in lines:\n                if not found_sharedline and shared_oldtext in line:\n                    line = line.replace(shared_oldtext, shared_newtext)\n                    found_sharedline = True\n                fd.write(line.replace(oldtext, newtext).encode())\n\n        # Patch doc CMakeLists in GEOS 3.8.x series.\n        if (3, 8, 0) <= self.version_tuple < (3, 9, 0):\n            cmakefile = os.path.join(zipfold, \"doc\", \"CMakeLists.txt\")\n            oldtext1 = \"target_include_directories(test_geos_unit\\n\"\n            newtext1 = \"if(BUILD_TESTING)\\n    {0}\".format(oldtext1)\n            oldtext2 = \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)\\n\"\n            newtext2 = \"{0}endif()\\n\".format(oldtext2)\n            with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(cmakefile, \"wb\") as fd:\n                for line in lines:\n                    line = line.replace(oldtext1, newtext1)\n                    line = line.replace(oldtext2, newtext2)\n                    fd.write(line.encode())\n\n    def build(self, installdir=None, toolset=None, njobs=1):\n        \"\"\"Build and install GEOS from source.\"\"\"\n\n        # Download and extract zip file if not present.\n        zipfold = os.path.join(self.root, \"geos-{0}\".format(self.version))\n        self.extract(overwrite=True)\n        version = self.version_tuple\n\n        # Define build and install directory.\n        builddir = os.path.join(zipfold, \"build\")\n        if installdir is None:\n            installdir = os.path.expanduser(\"~/.local/share/libgeos\")\n        installdir = os.path.abspath(installdir)\n\n        # Define generic configure and build options.\n        config_opts = [\n            \"-DCMAKE_BUILD_TYPE=Release\",\n            \"-DCMAKE_INSTALL_PREFIX={0}\".format(installdir),\n            \"-D{0}=OFF\".format(\"GEOS_ENABLE_TESTS\" if version < (3, 8, 0)\n                               else \"BUILD_TESTING\")\n        ]\n        build_opts = [\n            \"--config\", \"Release\",\n            \"--target\", \"install\",\n        ]\n        build_env = os.environ.copy()\n\n        # Define custom configure and build options.\n        if os.name == \"nt\":\n            win64 = (8 * struct.calcsize(\"P\") == 64)\n            config_opts += [\"-DCMAKE_CXX_FLAGS='/wd4251 /wd4355 /wd4458 /wd4530 /EHsc'\"]\n            if version >= (3, 6, 0) and sys.version_info[:2] >= (3, 3):\n                config_opts = [\"-A\", \"x64\" if win64 else \"Win32\"] + config_opts\n                if toolset is not None:\n                    try:\n                        msvc = \"v{0:d}\".format(int(float(toolset) * 10))\n                    except (TypeError, ValueError):\n                        msvc = toolset\n                    config_opts += [\"-DCMAKE_GENERATOR_TOOLSET={0}\".format(msvc)]\n                build_opts = [\"-j\", \"{0:d}\".format(njobs)] + build_opts\n            else:\n                config_opts = [\"-G\", \"NMake Makefiles\"] + config_opts\n                build_opts.extend([\n                    \"--\",\n                    \"WIN64={0}\".format(\"YES\" if win64 else \"NO\"),\n                    \"BUILD_BATCH={0}\".format(\"YES\" if njobs > 1 else \"NO\"),\n                ])\n                if sys.version_info[:2] < (3, 3):\n                    build_opts += [\"MSVC_VER=1500\"]\n        else:\n            build_env[\"MAKEFLAGS\"] = \"-j {0:d}\".format(njobs)\n            if version >= (3, 7, 0):\n                config_opts += [\"-DCMAKE_CXX_FLAGS='-fPIC'\"]\n\n        # Call cmake configure after ensuring that the build directory exists.\n        try:\n            os.makedirs(builddir)\n        except OSError:\n            pass\n        subprocess.call([\"cmake\", \"..\"] + config_opts, cwd=builddir)\n\n        # Call cmake build after ensuring that the install directory exists.\n        try:\n            os.makedirs(installdir)\n        except OSError:\n            pass\n        subprocess.call([\"cmake\", \"--build\", \".\"] + build_opts,\n                        cwd=builddir, env=build_env)",
  "def __init__(self, version, root=None):\n        \"\"\"Initialise a new :class:`GeosLibrary` instance.\"\"\"\n\n        self.version_tuple = tuple(map(int, version.split(\".\")))\n\n        if root is None:\n            self.temp = True\n            self.root = tempfile.mkdtemp(prefix=\"tmp_geoslibrary_\")\n        else:\n            self.temp = False\n            self.root = root\n            try:\n                os.makedirs(self.root)\n            except OSError:\n                pass",
  "def __del__(self):\n        \"\"\"Clean up after :class:`GeosLibrary` destruction.\"\"\"\n\n        if self.temp:\n            try:\n                shutil.rmtree(self.root)\n            except OSError:\n                pass",
  "def version(self):\n        \"\"\"GEOS library version in string format.\"\"\"\n\n        return \".\".join(map(str, self.version_tuple))",
  "def download(self):\n        \"\"\"Download GEOS zip source code into :class:`GeosLibrary` root.\"\"\"\n\n        # Define download link.\n        link = \"{0}/{1}.zip\".format(GEOS_BASEURL, self.version)\n        suffix = os.path.splitext(link)[-1]\n\n        # Define output path.\n        zipname = \"geos-{0}\".format(link.rsplit(\"/\", 1)[-1])\n        zippath = os.path.join(self.root, zipname)\n\n        # Handle creation of the HTTP request.\n        kwargs = {}\n        if hasattr(ssl, \"SSLContext\") and hasattr(ssl, \"PROTOCOL_TLSv1_2\"):\n            kwargs.update(context=ssl.SSLContext(ssl.PROTOCOL_TLSv1_2))\n        try:\n            conn = urlopen(link, **kwargs)\n        except TypeError:\n            # Fallback if `urlopen` does not accept context.\n            conn = urlopen(link)\n\n        with contextlib.closing(conn):\n            # Try to get the file timestamp from the HTTP request header.\n            date = conn.headers.get(\"Last-Modified\")\n            if date is not None:\n                date = dt.datetime.strptime(date, URL_DATETIME_FMT)\n                date = date.replace(tzinfo=dt.timezone.utc)\n                date = date.timestamp()\n            with tempfile.NamedTemporaryFile(suffix=suffix) as tmpzipobj:\n                # Copy the buffer into a temporary file.\n                shutil.copyfileobj(conn, tmpzipobj)\n                # Move the file descriptor pointer to the beginning and\n                # simply copy it to the final destination.\n                tmpzipobj.seek(0)\n                with open(zippath, \"wb\") as zipobj:\n                    shutil.copyfileobj(tmpzipobj, zipobj)\n            # Assign the timestamps to the final file if available.\n            if date is not None:\n                os.utime(zippath, (date, date))",
  "def extract(self, overwrite=True):\n        \"\"\"Decompress GEOS zip source code into :class:`GeosLibrary` root.\"\"\"\n\n        # Download zip file if not present.\n        zippath = os.path.join(self.root, \"geos-{0}.zip\".format(self.version))\n        if not os.path.exists(zippath):\n            self.download()\n\n        # Remove destination folder if present and requested.\n        zipfold = os.path.join(self.root, \"geos-{0}\".format(self.version))\n        if os.path.exists(zipfold):\n            if not overwrite:\n                raise OSError(\"folder '{0}' already exists\".format(zipfold))\n            shutil.rmtree(zipfold)\n\n        # Decompress zip file.\n        with contextlib.closing(ZipFile(zippath, \"r\")) as fd:\n            fd.extractall(self.root)\n\n        # Ensure that GEOS internal sh scripts can be executed.\n        for path in sorted(glob.glob(os.path.join(zipfold, \"tools\", \"*.sh\"))):\n            os.chmod(path, 0o755)\n\n        # Apply specific patches for GEOS < 3.6.0.\n        if self.version_tuple < (3, 6, 0):\n            # The SVN revision file is not created on the fly before 3.6.0.\n            svn_hfile = os.path.join(zipfold, \"geos_svn_revision.h\")\n            if not os.path.exists(svn_hfile):\n                with io.open(svn_hfile, \"wb\") as fd:\n                    text = \"#define GEOS_SVN_REVISION 0\"\n                    fd.write(text.encode())\n            # Reduce warnings when compiling with `nmake` on Windows.\n            cmakefile = os.path.join(zipfold, \"CMakeLists.txt\")\n            if os.path.exists(cmakefile):\n                with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n                    lines = fd.readlines()\n                with io.open(cmakefile, \"wb\") as fd:\n                    oldtext = 'string(REGEX REPLACE \"/W[0-9]\" \"/W4\"'\n                    newtext = oldtext.replace(\"W4\", \"W1\")\n                    for line in lines:\n                        fd.write(line.replace(oldtext, newtext).encode())\n\n        # Apply specific patches for 3.6.0 <= GEOS < 3.7.0 on Windows.\n        if (3, 6, 0) <= self.version_tuple < (3, 7, 0) and os.name == \"nt\":\n            autogen_file = os.path.join(zipfold, \"autogen.bat\")\n            subprocess.call([autogen_file], cwd=zipfold)\n            cppfile = os.path.join(zipfold, \"src\", \"geomgraph\", \"DirectedEdgeStar.cpp\")\n            with io.open(cppfile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(cppfile, \"wb\") as fd:\n                oldtext = \"DirectedEdgeStar::print() const\"\n                newtext = oldtext.replace(\" const\", \"\")\n                for line in lines:\n                    fd.write(line.replace(oldtext, newtext).encode())\n            hfile = os.path.join(zipfold, \"include\", \"geos\", \"geomgraph\", \"DirectedEdgeStar.h\")\n            with io.open(hfile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(hfile, \"wb\") as fd:\n                oldtext = \"virtual std::string print() const;\"\n                newtext = oldtext.replace(\" const\", \"\")\n                for line in lines:\n                    fd.write(line.replace(oldtext, newtext).encode())\n\n        # Patch CMakeLists to link shared geos_c with static geos.\n        if self.version_tuple < (3, 8, 0):\n            cmakefile = os.path.join(zipfold, \"capi\", \"CMakeLists.txt\")\n            oldtext = \"target_link_libraries(geos_c geos)\"\n            newtext = \"target_link_libraries(geos_c geos-static)\"\n        else:\n            cmakefile = os.path.join(zipfold, \"CMakeLists.txt\")\n            oldtext = 'add_library(geos \"\")'\n            newtext = 'add_library(geos STATIC \"\")'\n        with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n            lines = fd.readlines()\n        with io.open(cmakefile, \"wb\") as fd:\n            found_sharedline = False\n            shared_oldtext = \"if(BUILD_SHARED_LIBS)\"\n            shared_newtext = \"if(FALSE)\"\n            for line in lines:\n                if not found_sharedline and shared_oldtext in line:\n                    line = line.replace(shared_oldtext, shared_newtext)\n                    found_sharedline = True\n                fd.write(line.replace(oldtext, newtext).encode())\n\n        # Patch doc CMakeLists in GEOS 3.8.x series.\n        if (3, 8, 0) <= self.version_tuple < (3, 9, 0):\n            cmakefile = os.path.join(zipfold, \"doc\", \"CMakeLists.txt\")\n            oldtext1 = \"target_include_directories(test_geos_unit\\n\"\n            newtext1 = \"if(BUILD_TESTING)\\n    {0}\".format(oldtext1)\n            oldtext2 = \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)\\n\"\n            newtext2 = \"{0}endif()\\n\".format(oldtext2)\n            with io.open(cmakefile, \"r\", encoding=\"utf-8\") as fd:\n                lines = fd.readlines()\n            with io.open(cmakefile, \"wb\") as fd:\n                for line in lines:\n                    line = line.replace(oldtext1, newtext1)\n                    line = line.replace(oldtext2, newtext2)\n                    fd.write(line.encode())",
  "def build(self, installdir=None, toolset=None, njobs=1):\n        \"\"\"Build and install GEOS from source.\"\"\"\n\n        # Download and extract zip file if not present.\n        zipfold = os.path.join(self.root, \"geos-{0}\".format(self.version))\n        self.extract(overwrite=True)\n        version = self.version_tuple\n\n        # Define build and install directory.\n        builddir = os.path.join(zipfold, \"build\")\n        if installdir is None:\n            installdir = os.path.expanduser(\"~/.local/share/libgeos\")\n        installdir = os.path.abspath(installdir)\n\n        # Define generic configure and build options.\n        config_opts = [\n            \"-DCMAKE_BUILD_TYPE=Release\",\n            \"-DCMAKE_INSTALL_PREFIX={0}\".format(installdir),\n            \"-D{0}=OFF\".format(\"GEOS_ENABLE_TESTS\" if version < (3, 8, 0)\n                               else \"BUILD_TESTING\")\n        ]\n        build_opts = [\n            \"--config\", \"Release\",\n            \"--target\", \"install\",\n        ]\n        build_env = os.environ.copy()\n\n        # Define custom configure and build options.\n        if os.name == \"nt\":\n            win64 = (8 * struct.calcsize(\"P\") == 64)\n            config_opts += [\"-DCMAKE_CXX_FLAGS='/wd4251 /wd4355 /wd4458 /wd4530 /EHsc'\"]\n            if version >= (3, 6, 0) and sys.version_info[:2] >= (3, 3):\n                config_opts = [\"-A\", \"x64\" if win64 else \"Win32\"] + config_opts\n                if toolset is not None:\n                    try:\n                        msvc = \"v{0:d}\".format(int(float(toolset) * 10))\n                    except (TypeError, ValueError):\n                        msvc = toolset\n                    config_opts += [\"-DCMAKE_GENERATOR_TOOLSET={0}\".format(msvc)]\n                build_opts = [\"-j\", \"{0:d}\".format(njobs)] + build_opts\n            else:\n                config_opts = [\"-G\", \"NMake Makefiles\"] + config_opts\n                build_opts.extend([\n                    \"--\",\n                    \"WIN64={0}\".format(\"YES\" if win64 else \"NO\"),\n                    \"BUILD_BATCH={0}\".format(\"YES\" if njobs > 1 else \"NO\"),\n                ])\n                if sys.version_info[:2] < (3, 3):\n                    build_opts += [\"MSVC_VER=1500\"]\n        else:\n            build_env[\"MAKEFLAGS\"] = \"-j {0:d}\".format(njobs)\n            if version >= (3, 7, 0):\n                config_opts += [\"-DCMAKE_CXX_FLAGS='-fPIC'\"]\n\n        # Call cmake configure after ensuring that the build directory exists.\n        try:\n            os.makedirs(builddir)\n        except OSError:\n            pass\n        subprocess.call([\"cmake\", \"..\"] + config_opts, cwd=builddir)\n\n        # Call cmake build after ensuring that the install directory exists.\n        try:\n            os.makedirs(installdir)\n        except OSError:\n            pass\n        subprocess.call([\"cmake\", \"--build\", \".\"] + build_opts,\n                        cwd=builddir, env=build_env)",
  "def get_content(name, splitlines=False):\n    \"\"\"Return the file contents with project root as root folder.\"\"\"\n\n    here = os.path.abspath(os.path.dirname(__file__))\n    path = os.path.join(here, name)\n    with io.open(path, \"r\", encoding=\"utf-8\") as fd:\n        content = fd.read()\n    if splitlines:\n        content = [row for row in content.splitlines() if row]\n    return content",
  "def quantize(data,least_significant_digit):\n    \"\"\"\n    Quantize data to improve compression. data is quantized using\n    around(scale*data)/scale, where scale is 2**bits, and bits is determined\n    from the least_significant_digit. For example, if\n    least_significant_digit=1, bits will be 4.\n\n    This function is pure python.\n    \"\"\"\n    precision = pow(10.,-least_significant_digit)\n    exp = np.log10(precision)\n    if exp < 0:\n        exp = int(np.floor(exp))\n    else:\n        exp = int(np.ceil(exp))\n    bits = np.ceil(np.log2(pow(10.,-exp)))\n    scale = pow(2.,bits)\n    return np.around(scale*data)/scale",
  "def interpolate_long_segments(coords, resolution):\n    lookup_thresh = {'c': 0.5, 'l':0.3, 'i':0.2, 'h':0.1, 'f':0.05}\n    thresh = lookup_thresh[resolution]\n    spacing = thresh / 5.0\n\n    lons, lats = coords.T\n    dist = np.hypot(np.diff(lons), np.diff(lats))\n\n    if np.all(dist <= thresh):\n        return coords\n\n    out_lon, out_lat = [], []\n    for i in np.arange(len(dist)):\n        if dist[i] <= thresh:\n            out_lon.append(lons[i])\n            out_lat.append(lats[i])\n        else:\n            x = [0, dist[i]]\n            new_x = np.arange(0, dist[i], spacing)\n            out_lon.extend(np.interp(new_x, x, lons[i:i+2]))\n            out_lat.extend(np.interp(new_x, x, lats[i:i+2]))\n\n    out_lon.append(lons[-1])\n    out_lat.append(lats[-1])\n    return np.column_stack([out_lon, out_lat]).astype(coords.dtype)",
  "def get_coast_polygons(coastfile):\n    polymeta = []; polybounds = []\n    lats = []; lons = []\n    for line in open(coastfile):\n        if line.startswith('#'):\n            continue\n        linesplit = line.strip().split()\n        if line.startswith('>'):\n            area, west, east, south, north = map(float, linesplit[5:10])\n            poly_id = linesplit[-1]\n            level = linesplit[3]\n            polymeta.append([level,area,south,north,poly_id])\n            if lons:\n                #lons.append(lons[0]); lats.append(lats[0])\n                b = np.empty((len(lons),2),np.float32)\n                b[:,0] = lons; b[:,1] = lats\n                if lsd is not None:\n                    b = quantize(b,lsd)\n                polybounds.append(b)\n            lats = []; lons = []\n            continue\n        lon = float(linesplit[0])\n        lat = float(linesplit[1])\n        lons.append(lon); lats.append(lat)\n    #lons.append(lons[0]); lats.append(lats[0])\n    b = np.empty((len(lons),2),np.float32)\n    b[:,0] = lons; b[:,1] = lats\n    if lsd is not None:\n        b = quantize(b,lsd)\n    polybounds.append(b)\n    polymeta2 = []\n    for meta,bounds in zip(polymeta,polybounds):\n        npts = bounds.shape[0]\n        polymeta2.append(meta[:-1] + [npts] + [meta[-1]])\n    return polybounds, polymeta2",
  "def get_boundary_lines(bdatfile, resolution):\n    lons = []; lats = []; polybounds = []\n    for line in open(bdatfile):\n        if line.startswith('#'): continue\n        linesplit = line.split()\n        if line.startswith('>'):\n           if lons:\n               b = np.empty((len(lons),2),np.float32)\n               b[:,0] = lons; b[:,1] = lats\n               b = interpolate_long_segments(b, resolution)\n               if lsd is not None:\n                   b = quantize(b,lsd)\n               polybounds.append(b)\n           lons = []; lats = []\n           continue\n        lon, lat = [float(val) for val in linesplit]\n        lats.append(lat); lons.append(lon)\n    b = np.empty((len(lons),2),np.float32)\n    b[:,0] = lons; b[:,1] = lats\n    b = interpolate_long_segments(b, resolution)\n    if lsd is not None:\n        b = quantize(b,lsd)\n    polybounds.append(b)\n    polymeta = []\n    polybounds2 = []\n    for bounds in polybounds:\n        npts = bounds.shape[0]\n        if npts == 2 and\\\n           bounds[0,0] == bounds[1,0] and\\\n           bounds[0,1] == bounds[1,1]: continue\n        polybounds2.append(bounds)\n        south = bounds[:,1].min()\n        north = bounds[:,1].max()\n        polymeta.append((south,north,npts))\n    return polybounds2, polymeta"
]