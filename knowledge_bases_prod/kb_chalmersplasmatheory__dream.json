[
  "class OtherQuantityList(ListTable, Directive):\n    \n    option_spec = {\n        'source': directives.path,\n        'groups': directives.unchanged\n    }\n\n\n    def run(self):\n        \"\"\"\n        Generate the list of other quantities.\n        \"\"\"\n        source = self.options.get('source', '../../../../../src/OtherQuantityHandler.cpp')\n        groups = self.options.get('groups', 'no').lower() == 'yes'\n\n        table_data = []\n\n        #col_widths = self.get_column_widths(2)\n        col_widths = [1, 2]\n        header_rows = 1\n        stub_columns = 0\n\n        table_data = []\n        # Add header\n        if groups:\n            table_data.append([nodes.paragraph(text='Name'), nodes.paragraph(text='Included quantities')])\n        else:\n            table_data.append([nodes.paragraph(text='Name'), nodes.paragraph(text='Description')])\n\n        if groups:\n            qd = self.load_groups(source)\n        else:\n            qd = self.load_quantities(source)\n\n        # Add rows to table\n        for row in qd:\n            if type(row[1]) == str:\n                table_data.append([nodes.literal(text=row[0]), nodes.paragraph(text=row[1])])\n            else:\n                table_data.append([nodes.literal(text=row[0]), row[1]])\n\n        # Construct the table node\n        table_node = self.build_table_from_list(\n            table_data, col_widths, header_rows, stub_columns\n        )\n\n        return [table_node]\n\n\n    def load_string(self, s):\n        \"\"\"\n        Load the next string (i.e. text in quotation marks) from\n        the given line 's'.\n        \"\"\"\n        n = len(s)\n\n        # Locate beginning quotation mark\n        i = 0\n        while i < n and s[i] != '\"': i += 1\n\n        if i == n:\n            return None, None\n\n        # Load string\n        i += 1\n        j = 0\n\n        while i+j < n and s[i+j] != '\"' and s[i+j-1] != '\\\\':\n            j += 1\n\n        S = s[i:(i+j)]\n\n        return S, i+j+1\n\n\n    def load_groups(self, source):\n        \"\"\"\n        Load the list of other quantity groups and their descriptions from the\n        DREAM source code.\n        \"\"\"\n        with open(os.path.abspath(source), 'r') as f:\n            src = f.readlines()\n\n        grps = []\n        match = 'this->groups['\n        I = 0\n        nLines = len(src)\n        while I < nLines:\n            l = src[I].strip()\n\n            if l.startswith(match):\n                i = len(match)\n                group, _ = self.load_string(l[i:])\n\n                # Load quantities included in the group\n                q = ''\n                if l[-1] == '{':\n                    q = []\n                    I += 1\n                    while I < nLines:\n                        l = src[I].strip()\n\n                        # End of list of quantities?\n                        if l.startswith('};'):\n                            break\n\n                        # Otherwise, load the list of quantities\n                        i = 0\n                        s, j = self.load_string(l)\n                        while s is not None:\n                            #ln = nodes.line()\n                            #ln.append(nodes.literal(text=s))\n                            q.append(s)\n                            i += j\n\n                            s, j = self.load_string(l[i:])\n\n                        I += 1\n\n                    # Sort q\n                    q.sort(key=lambda x : x.lower())\n\n                    # Convert q into list of lines\n                    Q = []\n                    for quant in q:\n                        ln = nodes.line()\n                        ln.append(nodes.literal(text=quant))\n                        Q.append(ln)\n\n                    #grps.append([group, ', '.join(q)])\n                    #grps.append([group, pg])\n                    grps.append([group, Q])\n                else:\n                    q = \"All quantities starting with ``{}/``.\".format(group)\n\n            I += 1\n\n        return grps\n\n\n    def load_quantities(self, source):\n        \"\"\"\n        Load the list of other quantities and descriptions from the DREAM\n        source code.\n        \"\"\"\n        with open(os.path.abspath(source), 'r') as f:\n            src = f.readlines()\n\n        quants = []\n        for line in src:\n            l = line.strip()\n            \n            # Does this line contain an OtherQuantity definition?\n            if l.startswith('DEF_'):\n                i = len('DEF_')\n                name, j = self.load_string(l[i:])\n                desc, _ = self.load_string(l[(i+j):])\n\n                quants.append([name, desc])\n\n        # Sort list (based on name)\n        quants.sort(key=lambda x : x[0].lower())\n        return quants",
  "def setup(app):\n    app.add_directive(\"otherquantitylist\", OtherQuantityList)\n\n    return {\n        'version': '1.0',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True\n    }",
  "def run(self):\n        \"\"\"\n        Generate the list of other quantities.\n        \"\"\"\n        source = self.options.get('source', '../../../../../src/OtherQuantityHandler.cpp')\n        groups = self.options.get('groups', 'no').lower() == 'yes'\n\n        table_data = []\n\n        #col_widths = self.get_column_widths(2)\n        col_widths = [1, 2]\n        header_rows = 1\n        stub_columns = 0\n\n        table_data = []\n        # Add header\n        if groups:\n            table_data.append([nodes.paragraph(text='Name'), nodes.paragraph(text='Included quantities')])\n        else:\n            table_data.append([nodes.paragraph(text='Name'), nodes.paragraph(text='Description')])\n\n        if groups:\n            qd = self.load_groups(source)\n        else:\n            qd = self.load_quantities(source)\n\n        # Add rows to table\n        for row in qd:\n            if type(row[1]) == str:\n                table_data.append([nodes.literal(text=row[0]), nodes.paragraph(text=row[1])])\n            else:\n                table_data.append([nodes.literal(text=row[0]), row[1]])\n\n        # Construct the table node\n        table_node = self.build_table_from_list(\n            table_data, col_widths, header_rows, stub_columns\n        )\n\n        return [table_node]",
  "def load_string(self, s):\n        \"\"\"\n        Load the next string (i.e. text in quotation marks) from\n        the given line 's'.\n        \"\"\"\n        n = len(s)\n\n        # Locate beginning quotation mark\n        i = 0\n        while i < n and s[i] != '\"': i += 1\n\n        if i == n:\n            return None, None\n\n        # Load string\n        i += 1\n        j = 0\n\n        while i+j < n and s[i+j] != '\"' and s[i+j-1] != '\\\\':\n            j += 1\n\n        S = s[i:(i+j)]\n\n        return S, i+j+1",
  "def load_groups(self, source):\n        \"\"\"\n        Load the list of other quantity groups and their descriptions from the\n        DREAM source code.\n        \"\"\"\n        with open(os.path.abspath(source), 'r') as f:\n            src = f.readlines()\n\n        grps = []\n        match = 'this->groups['\n        I = 0\n        nLines = len(src)\n        while I < nLines:\n            l = src[I].strip()\n\n            if l.startswith(match):\n                i = len(match)\n                group, _ = self.load_string(l[i:])\n\n                # Load quantities included in the group\n                q = ''\n                if l[-1] == '{':\n                    q = []\n                    I += 1\n                    while I < nLines:\n                        l = src[I].strip()\n\n                        # End of list of quantities?\n                        if l.startswith('};'):\n                            break\n\n                        # Otherwise, load the list of quantities\n                        i = 0\n                        s, j = self.load_string(l)\n                        while s is not None:\n                            #ln = nodes.line()\n                            #ln.append(nodes.literal(text=s))\n                            q.append(s)\n                            i += j\n\n                            s, j = self.load_string(l[i:])\n\n                        I += 1\n\n                    # Sort q\n                    q.sort(key=lambda x : x.lower())\n\n                    # Convert q into list of lines\n                    Q = []\n                    for quant in q:\n                        ln = nodes.line()\n                        ln.append(nodes.literal(text=quant))\n                        Q.append(ln)\n\n                    #grps.append([group, ', '.join(q)])\n                    #grps.append([group, pg])\n                    grps.append([group, Q])\n                else:\n                    q = \"All quantities starting with ``{}/``.\".format(group)\n\n            I += 1\n\n        return grps",
  "def load_quantities(self, source):\n        \"\"\"\n        Load the list of other quantities and descriptions from the DREAM\n        source code.\n        \"\"\"\n        with open(os.path.abspath(source), 'r') as f:\n            src = f.readlines()\n\n        quants = []\n        for line in src:\n            l = line.strip()\n            \n            # Does this line contain an OtherQuantity definition?\n            if l.startswith('DEF_'):\n                i = len('DEF_')\n                name, j = self.load_string(l[i:])\n                desc, _ = self.load_string(l[(i+j):])\n\n                quants.append([name, desc])\n\n        # Sort list (based on name)\n        quants.sort(key=lambda x : x[0].lower())\n        return quants",
  "def get(reverse=False, N=256):\n    \"\"\"\n    Returns the 'GeriMap' colormap.\n    \"\"\"\n    gm = [(0, 0, 0), (.15, .15, .5), (.3, .15, .75),\n          (.6, .2, .50), (1, .25, .15), (.9, .5, 0),\n          (.9, .75, .1), (.9, .9, .5), (1, 1, 1)]\n\n    if reverse:\n        return LinearSegmentedColormap.from_list('GeriMap_r', gm[::-1], N=N)\n    else:\n        return LinearSegmentedColormap.from_list('GeriMap', gm, N=N)",
  "def register():\n    \"\"\"\n    Register the perceptually uniform colormap 'GeriMap' with matplotlib.\n    \"\"\"\n    plt.register_cmap(cmap=get(False))\n    plt.register_cmap(cmap=get(True))",
  "def LoadHDF5AsDict(filename, path='', returnhandle=False, returnsize=False, lazy=True):\n    \"\"\"\n    Loads the given HDF5 file as a dict.\n\n    :param str filename:      Name of HDF5 file to load.\n    :param str path:          Path to subset of HDF5 file to load.\n    :param bool returnhandle: If ``True``, also returns the HDF5 file handled\n                              used to open the file (always ``None`` if ``lazy==False``).\n    :param bool returnsize:   If ``True``, also returns the file size.\n    :param bool lazy:         If ``True``, loads data as ``DataObject``, which\n                              allows lazy (on-demand) reading of data. The\n                              default is to immediately load all data from the\n                              file.\n    \"\"\"\n    global SSHSUPPORT\n    data = None\n    size = 0\n    f = None\n\n    user, host, port, rpath = None, None, 22, None\n    if SSHSUPPORT:\n        m1 = re.search('(\\w+://)(.+@)*([\\w\\-\\_\\d\\.]+)(:[\\d]+){0,1}/*(.*)', filename)\n        m2 = re.search('(.+@)*([\\w\\-\\_\\d\\.]+):(.*)', filename)\n\n        if m1 is not None:\n            user = m1.group(2)\n            host = m1.group(3)\n            prtt = m1.group(4)\n            rpath = m1.group(5)\n\n            # Remove '@' in username (if given)\n            if user is not None:\n                user = user[:-1]\n\n            if prtt is not None:\n                port = int(prtt[1:])\n            else:\n                rpath = rpath[1:]\n\n        elif m2 is not None:\n            user = m2.group(1)\n            host = m2.group(2)\n            rpath = m2.group(3)\n\n            # Remove '@' in username (if given)\n            if user is not None:\n                user = user[:-1]\n\n    if host is not None and rpath is not None:\n        client = paramiko.SSHClient()\n        client.load_system_host_keys()\n\n        config = paramiko.config.SSHConfig()\n        try:\n            config.parse(open(\"{}/.ssh/config\".format(str(Path.home()))))\n\n            conf = config.lookup(host)\n            host = conf['hostname']\n\n            if 'user' in conf:\n                user = conf['user']\n            if 'port' in conf:\n                port = conf['port']\n\n        except: pass\n\n        try:\n            client.connect(host, port=port, username=user)\n        except paramiko.ssh_exception.PasswordRequiredException as ex:\n            pw = getpass.getpass(prompt=f\"{user}@{host}'s password: \")\n            client.connect(host, port=port, username=user, password=pw)\n\n        # Open SFTP stream\n        sftp = client.open_sftp()\n        size = sftp.stat(rpath).st_size\n        \n        if lazy:\n            fo = sftp.open(rpath, 'r')\n            f  = h5py.File(fo, 'r')\n            data = h52dict(f, path, lazy=True)\n            # Close neither connection nor HDF5 file to allow lazy reading...\n        else:\n            with sftp.open(rpath, 'r') as fo:\n                with h5py.File(fo, 'r') as f:\n                    data = h52dict(f, path, lazy=False)\n            client.close()\n    else:\n        size = os.path.getsize(filename)\n        if lazy:\n            f = h5py.File(filename, 'r')\n            data = h52dict(f, path, lazy=True)\n            # Don't close HDF5 file to allow lazy reading...\n        else:\n            with h5py.File(filename, 'r') as f:\n                data = h52dict(f, path, lazy=False)\n\n    ret = (data, )\n    if returnhandle:\n        if lazy:\n            ret += (f,)\n        else:\n            ret += (None,)\n    if returnsize: ret += (size,)\n\n    if len(ret) > 1:\n        return ret\n    else:\n        return data",
  "def SaveDictAsHDF5(filename, data):\n    \"\"\"\n    Stores the given dict into an HDF5 file.\n\n    filename: Name of HDF5 file to create and write to.\n    data:     Dictionary containing the data to write.\n    \"\"\"\n    with h5py.File(filename, 'w') as f:\n        dict2h5(f, data)",
  "def dict2h5(f, data, path=''):\n    \"\"\"\n    Writes the given data on the HDF5 file handle 'f'.\n\n    f:    HDF5 file handle to write on.\n    data: Data to write.\n    path: Path in HDF5 file to write data to.\n    \"\"\"\n\n    for key in data:\n        d = data[key]\n        if type(d) == DataObject:\n            d = d[:]\n\n        if type(d) == dict:\n            o = f.create_group(key)\n            dict2h5(o, d, path=path+'/'+key)\n        elif type(d) == float or type(d) == np.float64:\n            f.create_dataset(key, (1,), data=d)\n        elif type(d) == int:\n            f.create_dataset(key, (1,), data=d, dtype='i8')\n        elif type(d) == bool:\n            v = 1 if d else 0\n            f.create_dataset(key, (1,), data=v, dtype='i4')\n        elif type(d) == str:\n            l = len(d)\n\n            # From h5py version 2.10.0 an on there is support for storing\n            # UTF-8 strings. To allow this, but still remain backwards\n            # compatible, we choose how to store strings depending on the\n            # version of h5py.\n            if version.parse(h5py.version.version) >= version.parse('2.10.0'):\n                dt = h5py.string_dtype()\n                dset = f.create_dataset(key, (1,), dtype=dt)\n                dset[0:l] = d\n            else:   # h5py < 2.10.0\n                dset = f.create_dataset(key, (1,), dtype='S'+str(l))\n                dset[0:l] = np.string_(d)\n        elif type(d) == list:\n            f.create_dataset(key, (len(d),), data=d)\n        elif type(d) == np.ndarray:\n            f.create_dataset(key, d.shape, data=d)\n        else:\n            raise DREAMIOException(\"Unrecognized data type of entry '{}/{}': {}.\".format(path, key, type(d)))",
  "def h52dict(f, path='', lazy=False):\n    \"\"\"\n    Loads data from the given HDF5 file handle 'f'.\n\n    f:    HDF5 file handle to use for reading.\n    path: Path in HDF5 file to read data from.\n    lazy: Load data lazily, i.e. return a DataObject rather than\n          the actual data.\n    \"\"\"\n    d = {}\n    for key in f.keys():\n        if type(f[key]) == h5py.Group:\n            d[key] = h52dict(f[key], path=path+'/'+key, lazy=lazy)\n        elif type(f[key]) == h5py.Dataset:\n            if lazy:\n                d[key] = DataObject(f[key])\n            else:\n                d[key] = getData(f, key)\n\n            # Get attributes (cannot be loaded lazily)\n            if len(f[key].attrs) > 0:\n                n = key+'@@'\n                if n not in d:\n                    d[n] = {}\n\n                for a in f[key].attrs:\n                    d[key+'@@'][a] = getData(f[key].attrs, a)\n        else:\n            raise DREAMIOException(\"Unrecognized HDF5 data structure for key: '{}'.\".format(path+'/'+key))\n\n    return d",
  "def getData(f, key):\n    \"\"\"\n    Returns data from an h5py.File object, correctly transforming\n    it (in case it is a string for example).\n    \"\"\"\n    if (f[key].dtype == 'S1') or (str(f[key].dtype).startswith('|S')):  # Regular strings\n        return f[key][:].tostring().decode('utf-8')\n    elif f[key].dtype == 'object':  # New strings\n        if f[key].shape == ():\n            return f[key][()].decode()\n        elif type(f[key][:][0]) == str:\n            return f[key][:][0]\n        else:\n            return f[key][:][0].decode()\n    else:\n        return f[key][:]",
  "def unlazy(s):\n    \"\"\"\n    Iterate through the given 'dict' consisting of 'DataObject's to load\n    in the actual data (and make it \"not lazy loaded\").\n    \"\"\"\n    S = {}\n    for key in s.keys():\n        if type(s[key]) == dict:\n            S[key] = unlazy(s[key])\n        else:\n            S[key] = s[key][:]\n\n    return S",
  "class DREAMIOException(Exception):\n    def __init__(self, msg):\n        super(Exception, self).__init__(msg)",
  "def __init__(self, msg):\n        super(Exception, self).__init__(msg)",
  "def collect_single(name, output):\n    \"\"\"\n    Collect data for the unknown quantity named 'name' from the list\n    of DREAMOutput objects 'output'.\n    \"\"\"\n    data = []\n    for do in output:\n        v = do.eqsys[name].data[0,:]\n\n        data.append(v)\n\n    return np.array(data)",
  "def load_quantities(directory, timestep, outputobject=DREAMOutput):\n    \"\"\"\n    Load debug output from the named directory and assemble into a single\n    DREAMOutput object.\n    \n    :param pattern: String with the format\n    \"\"\"\n    pattern = f'{directory}/debugout_{{}}_{{}}.h5'\n\n    do = outputobject(pattern.format(timestep, 1), loadsettings=True)\n\n    # Load all output objects\n    dos = [do]\n    iteration = 1\n    while os.path.exists(pattern.format(timestep, iteration)):\n        dos.append(outputobject(pattern.format(timestep, iteration), loadsettings=False))\n        iteration += 1\n\n    # Extend main output object\n    do.grid.t = np.array(range(len(dos))) + 1\n    for variable, uqn in do.eqsys.unknowns.items():\n        data = collect_single(variable, dos)\n\n        attr = {'description': uqn.description, 'equation': uqn.description_eqn}\n        do.eqsys.setUnknown(name=variable, data=data, attr=attr)\n\n    # Close inputs (except 'do', which is index 0)\n    for i in range(1, len(dos)):\n        dos[i].close()\n\n    return do",
  "def plotConvergenceOutput(do):\n    \"\"\"\n    Plot the convergence of the unknowns in the given DREAMOutput object.\n    \"\"\"\n    fig, ax = plt.subplots(1,1)\n\n    lines = []\n    for uname, u in do.eqsys.unknowns.items():\n        reltol = do.settings.solver.tolerance.getRelTol(uname)\n\n        if np.all(u.data==0):\n            continue\n\n        Delta = np.abs((u.data[:]/ u.data[-1,:])-1)\n\n        v = np.sum(Delta, axis=tuple(range(1,u.data.ndim))) / reltol\n        l, = ax.semilogy(do.grid.t, v, label=uname)\n        lines.append(l)\n\n    ax.plot([1, do.grid.t.size], [1, 1], 'k--')\n    ax.set_xlim([1, do.grid.t.size])\n\n    annot = ax.annotate(\"\", xy=(0,0), xytext=(-20,20), textcoords=\"offset points\", bbox={'boxstyle': 'round', 'fc':'w'}, arrowprops={'arrowstyle':'->'})\n    annot.set_visible(False)\n\n    def update_annot(line, ind):\n        x, y = line.get_data()\n        annot.xy = (x[ind['ind'][0]], y[ind['ind'][0]])\n        #annot.set(backgroundcolor=line.get_color())\n        annot.set(bbox={'boxstyle':'round', 'fc': 'w', 'ec': line.get_color()})\n        annot.set_text(line.get_label())\n    \n    def hover(event):\n        if event.inaxes == ax:\n            found = False\n            for line in lines:\n                cont, ind = line.contains(event)\n\n                if cont:\n                    update_annot(line, ind)\n                    annot.set_visible(True)\n                    fig.canvas.draw_idle()\n                    found = True\n                    break\n\n            if not found and annot.get_visible():\n                annot.set_visible(False)\n                fig.canvas.draw_idle()\n\n    fig.canvas.mpl_connect('motion_notify_event', hover)\n\n    plt.show(block=False)",
  "def plotConvergenceUnknown(u):\n    \"\"\"\n    Plot the convergence of the given unknown quantity.\n    \"\"\"\n    pass",
  "def plotConvergence(u=None):\n    \"\"\"\n    Plot the convergence of a given unknown quantity of DREAMOutput object.\n    \"\"\"\n    if u == None:\n        u = glob['do']\n    \n    if isinstance(u, type(UnknownQuantity)):\n        plotConvergenceUnknown(u)\n    else:\n        plotConvergenceOutput(u)",
  "def create_argparser():\n    parser = argparse.ArgumentParser(description=\"DREAM Debug Output CLI\")\n\n    parser.add_argument('-t', '--timestep', help=\"Timestep index to load\", type=int, default=0)\n    parser.add_argument('directory', help=\"Name of directory containing debug output files to load\", nargs='?', type=str, default=\".\")\n\n    return parser.parse_args()",
  "def determine_timestep(directory):\n    \"\"\"\n    Determine which time step to load from the named directory.\n    \"\"\"\n    pattern = f'{directory}/debugout_{{}}_{{}}.h5'\n    files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]\n\n    for f in os.listdir(directory):\n        if f.startswith('debugout_') and f.endswith('.h5'):\n            return int(f.split('_')[1])\n\n    raise Exception(\"Failed to automatically determine which time step to load.\")",
  "def main(glob=None, outputobject=DREAMOutput):\n    if glob is None:\n        glob = globals()\n\n    args = create_argparser()\n\n    if args.timestep <= 0:\n        timestep = determine_timestep(args.directory)\n        print(f'Loading time step {timestep}')\n    else:\n        timestep = args.timestep\n\n    do = load_quantities(args.directory, timestep, outputobject=outputobject)\n    globals()['glob'] = glob\n    setup_interactive(do, glob=glob)",
  "def update_annot(line, ind):\n        x, y = line.get_data()\n        annot.xy = (x[ind['ind'][0]], y[ind['ind'][0]])\n        #annot.set(backgroundcolor=line.get_color())\n        annot.set(bbox={'boxstyle':'round', 'fc': 'w', 'ec': line.get_color()})\n        annot.set_text(line.get_label())",
  "def hover(event):\n        if event.inaxes == ax:\n            found = False\n            for line in lines:\n                cont, ind = line.contains(event)\n\n                if cont:\n                    update_annot(line, ind)\n                    annot.set_visible(True)\n                    fig.canvas.draw_idle()\n                    found = True\n                    break\n\n            if not found and annot.get_visible():\n                annot.set_visible(False)\n                fig.canvas.draw_idle()",
  "class DREAMSettings:\n    \n\n    def __init__(self, filename=None, path=\"\", chain=True, keepignore=False):\n        \"\"\"\n        Construct a new DREAMSettings object. If 'filename' is given,\n        the object is read from the (HDF5) file with that name.\n        If 'path' is also given, this is used to locate the group\n        in the file which contains the settings. \n\n        :param str filename:    Name of the file to load settings from.\n        :param str path:        Path to group in HDF5 file containing the settings.\n        :param bool chain:      If ``True``, sets the newly created ``DREAMSettings`` object \n                                to take the output of the simulation defined by 'filename' \n                                as input (i.e. calls :py:method:`fromOutput`).\n        :param bool keepignore: If ``True``, keeps the list of unknown quantities to ignore\n                                when initializing from a previous simulation (and ``chain=True``).\n        \"\"\"\n\n        # Defaults\n        self.settings = {}\n        self.init = {}\n\n        self.addSetting('collisions', CollisionHandler())\n        self.addSetting('hottailgrid', MomentumGrid('hottailgrid'))\n        self.addSetting('other', OtherQuantities())\n        self.addSetting('output', Output())\n        self.addSetting('radialgrid', RadialGrid())\n        self.addSetting('runawaygrid', MomentumGrid('runawaygrid'))\n        self.addSetting('solver', Solver())\n        self.addSetting('timestep', TimeStepper())\n        self.addSetting('atomic', Atomics())\n\n        # Should be defined last as it may need access to the\n        # objects created above...\n        self.addSetting('eqsys', EquationSystem(settings=self))\n\n        if filename is not None:\n            if type(filename) == str:\n                self.load(filename, path=path, lazy=False)\n            elif type(filename) == dict:\n                # We first generate an empty settings object so that we\n                # get all default values in a dict...\n                self.hottailgrid.setEnabled(False)\n                self.runawaygrid.setEnabled(False)\n                dct = self.todict(verify=False)\n                s = merge_dicts(dct, filename)\n\n                self.fromdict(s)\n\n                if chain:\n                    if 'output' in s and 'filename' in s['output']:\n                        self.fromOutput(s['output']['filename'])\n                        self.output.setFilename('output.h5')\n\n                        if not keepignore:\n                            self.clearIgnore()\n            elif type(filename) == DREAMSettings:\n                self.fromdict(filename.todict())\n\n                if chain:\n                    self.fromOutput(filename.output.filename)\n                    self.output.setFilename('output.h5')\n\n                    if not keepignore:\n                        self.clearIgnore()\n\n    \n    def __contains__(self, item):\n        \"\"\"\n        Overriding the Python 'in' keyword.\n        \"\"\"\n        return (item in self.settings)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Retrieves a parameter by name.\n        \"\"\"\n        return self.settings[index]\n\n\n    def addSetting(self, name, obj):\n        \"\"\"\n        Add a setting to this object. This adds the setting to\n        the 'settings' list, in addition to making it accessible\n        through usual \"dot\" notation (i.e. you can access it either\n        as \"self.mySetting\" or \"self.settings['mySetting']\")\n\n        name: Name of settings object to add.\n        obj:  Settings object to add.\n        \"\"\"\n        setattr(self, name, obj)\n        self.settings[name] = obj\n\n\n    def fromdict(self, data, filename='<dictionary>'):\n        sets  = list(self.settings.keys())\n        other = ['init']\n\n        # Settings to remove first\n        special = ['hottailgrid', 'runawaygrid']\n\n        datakeys = list(data.keys())\n        for k in special:\n            datakeys.remove(k)\n\n        for key in special+datakeys:\n            # Warn about unrecognized settings\n            if key in sets:\n                # Remove from list of not-found settings\n                sets.remove(key)\n                # Set settings\n                if type(self.settings[key]) == MomentumGrid:\n                    self.settings[key].fromdict(key, data[key])\n                else:\n                    self.settings[key].fromdict(data[key])\n            elif key in other:\n                # Remove from list of not found\n                other.remove(key)\n\n                # Set settings\n                setattr(self, key, data[key])\n            else:\n                print(\"WARNING: Unrecognized setting '{}' found in '{}'.\".format(key, filename))\n                continue\n\n        # Convert 'eqsysignore' to a list of strings\n        if 'eqsysignore' in self.init:\n            self.init['eqsysignore'] = self.init['eqsysignore'].split(';')\n\n        # Warn about missing settings\n        missing = sets+other\n        if len(missing) > 0:\n            for s in missing:\n                print(\"WARNING: Setting '{}' not specified in '{}'.\".format(s, filename))\n\n\n    def clearIgnore(self):\n        \"\"\"\n        Clear the list of quantities to ignore when initializing from previous\n        simulation.\n        \"\"\"\n        self.init['eqsysignore'] = []\n\n\n    def fromOutput(self, filename, relpath=False, ignore=list(), timeindex=-1):\n        \"\"\"\n        Specify that the simulation should be initialized from the\n        DREAM output stored in the named file. Some unknown quantities\n        can be ignored and initialized conventionally by adding them\n        to the 'ignore' list.\n\n        filename:  Name of file to load output from.\n        relpath:   If 'True', forces the path to 'filename' to be encoded\n                   as a relative path. Otherwise, the absolute path to the\n                   named file will be calculated and given to the settings\n                   object. (default: False)\n        ignore:    List of unknown quantities to initialize as usual, and\n                   thus NOT from the specified output file.\n        timeindex: Index of time point to use for initializing the simulation.\n        \"\"\"\n        # Input as relative or absolute path?\n        if relpath:\n            fname = filename\n        else:\n            fname = os.path.abspath(filename)\n\n        if type(ignore) == str:\n            ignore = [ignore]\n        elif type(ignore) != list:\n            raise DREAMException(\"Unrecognized type of argument 'ignore'. Expected list of strings.\")\n\n        self.init['fromfile']   = fname\n        self.init['eqsysignore'] = ignore\n        self.init['timeindex']  = timeindex\n\n\n    def load(self, filename, path=\"\", lazy=False):\n        \"\"\"\n        Load a DREAMSettings object from the named HDF5 file.\n        'path' specifies the path within the HDF5 file where\n        the DREAMSettings object is stored.\n        \"\"\"\n        data = DREAMIO.LoadHDF5AsDict(filename, path=path, lazy=lazy)\n        self.fromdict(data, filename=filename)\n\n\n    def save(self, filename):\n        \"\"\"\n        Save this settings object to the specified file.\n\n        filename: Name of file to save settings to (the file will\n                  be overwritten if it exists).\n        \"\"\"\n        DREAMIO.SaveDictAsHDF5(filename, self.todict())\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns the settings in this object as a Python dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {}\n        for key, setting in self.settings.items():\n            data[key] = setting.todict(verify=False)\n\n        data['init'] = {}\n\n        if ('eqsysignore' in self.init) and (len(self.init['eqsysignore']) > 0):\n            data['init']['eqsysignore'] = ';'.join(self.init['eqsysignore'])\n\n        if 'timeindex' in self.init:\n            data['init']['filetimeindex'] = self.init['timeindex']\n        if 'fromfile' in self.init:\n            data['init']['fromfile'] = self.init['fromfile']\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the DREAM run has been correctly configured\n        and that all settings are consistent.\n        \"\"\"\n        for _, setting in self.settings.items():\n            setting.verifySettings()\n\n        if ('fromfile' in self.init) and (self.init['fromfile'] != ''):\n            # Verify that the file exists...\n            if not os.path.exists(self.init['fromfile']):\n                print(\"WARNING: The output file from which to initialize '{}' does not exist.\".format(self.init['fromfile']))",
  "def __init__(self, filename=None, path=\"\", chain=True, keepignore=False):\n        \"\"\"\n        Construct a new DREAMSettings object. If 'filename' is given,\n        the object is read from the (HDF5) file with that name.\n        If 'path' is also given, this is used to locate the group\n        in the file which contains the settings. \n\n        :param str filename:    Name of the file to load settings from.\n        :param str path:        Path to group in HDF5 file containing the settings.\n        :param bool chain:      If ``True``, sets the newly created ``DREAMSettings`` object \n                                to take the output of the simulation defined by 'filename' \n                                as input (i.e. calls :py:method:`fromOutput`).\n        :param bool keepignore: If ``True``, keeps the list of unknown quantities to ignore\n                                when initializing from a previous simulation (and ``chain=True``).\n        \"\"\"\n\n        # Defaults\n        self.settings = {}\n        self.init = {}\n\n        self.addSetting('collisions', CollisionHandler())\n        self.addSetting('hottailgrid', MomentumGrid('hottailgrid'))\n        self.addSetting('other', OtherQuantities())\n        self.addSetting('output', Output())\n        self.addSetting('radialgrid', RadialGrid())\n        self.addSetting('runawaygrid', MomentumGrid('runawaygrid'))\n        self.addSetting('solver', Solver())\n        self.addSetting('timestep', TimeStepper())\n        self.addSetting('atomic', Atomics())\n\n        # Should be defined last as it may need access to the\n        # objects created above...\n        self.addSetting('eqsys', EquationSystem(settings=self))\n\n        if filename is not None:\n            if type(filename) == str:\n                self.load(filename, path=path, lazy=False)\n            elif type(filename) == dict:\n                # We first generate an empty settings object so that we\n                # get all default values in a dict...\n                self.hottailgrid.setEnabled(False)\n                self.runawaygrid.setEnabled(False)\n                dct = self.todict(verify=False)\n                s = merge_dicts(dct, filename)\n\n                self.fromdict(s)\n\n                if chain:\n                    if 'output' in s and 'filename' in s['output']:\n                        self.fromOutput(s['output']['filename'])\n                        self.output.setFilename('output.h5')\n\n                        if not keepignore:\n                            self.clearIgnore()\n            elif type(filename) == DREAMSettings:\n                self.fromdict(filename.todict())\n\n                if chain:\n                    self.fromOutput(filename.output.filename)\n                    self.output.setFilename('output.h5')\n\n                    if not keepignore:\n                        self.clearIgnore()",
  "def __contains__(self, item):\n        \"\"\"\n        Overriding the Python 'in' keyword.\n        \"\"\"\n        return (item in self.settings)",
  "def __getitem__(self, index):\n        \"\"\"\n        Retrieves a parameter by name.\n        \"\"\"\n        return self.settings[index]",
  "def addSetting(self, name, obj):\n        \"\"\"\n        Add a setting to this object. This adds the setting to\n        the 'settings' list, in addition to making it accessible\n        through usual \"dot\" notation (i.e. you can access it either\n        as \"self.mySetting\" or \"self.settings['mySetting']\")\n\n        name: Name of settings object to add.\n        obj:  Settings object to add.\n        \"\"\"\n        setattr(self, name, obj)\n        self.settings[name] = obj",
  "def fromdict(self, data, filename='<dictionary>'):\n        sets  = list(self.settings.keys())\n        other = ['init']\n\n        # Settings to remove first\n        special = ['hottailgrid', 'runawaygrid']\n\n        datakeys = list(data.keys())\n        for k in special:\n            datakeys.remove(k)\n\n        for key in special+datakeys:\n            # Warn about unrecognized settings\n            if key in sets:\n                # Remove from list of not-found settings\n                sets.remove(key)\n                # Set settings\n                if type(self.settings[key]) == MomentumGrid:\n                    self.settings[key].fromdict(key, data[key])\n                else:\n                    self.settings[key].fromdict(data[key])\n            elif key in other:\n                # Remove from list of not found\n                other.remove(key)\n\n                # Set settings\n                setattr(self, key, data[key])\n            else:\n                print(\"WARNING: Unrecognized setting '{}' found in '{}'.\".format(key, filename))\n                continue\n\n        # Convert 'eqsysignore' to a list of strings\n        if 'eqsysignore' in self.init:\n            self.init['eqsysignore'] = self.init['eqsysignore'].split(';')\n\n        # Warn about missing settings\n        missing = sets+other\n        if len(missing) > 0:\n            for s in missing:\n                print(\"WARNING: Setting '{}' not specified in '{}'.\".format(s, filename))",
  "def clearIgnore(self):\n        \"\"\"\n        Clear the list of quantities to ignore when initializing from previous\n        simulation.\n        \"\"\"\n        self.init['eqsysignore'] = []",
  "def fromOutput(self, filename, relpath=False, ignore=list(), timeindex=-1):\n        \"\"\"\n        Specify that the simulation should be initialized from the\n        DREAM output stored in the named file. Some unknown quantities\n        can be ignored and initialized conventionally by adding them\n        to the 'ignore' list.\n\n        filename:  Name of file to load output from.\n        relpath:   If 'True', forces the path to 'filename' to be encoded\n                   as a relative path. Otherwise, the absolute path to the\n                   named file will be calculated and given to the settings\n                   object. (default: False)\n        ignore:    List of unknown quantities to initialize as usual, and\n                   thus NOT from the specified output file.\n        timeindex: Index of time point to use for initializing the simulation.\n        \"\"\"\n        # Input as relative or absolute path?\n        if relpath:\n            fname = filename\n        else:\n            fname = os.path.abspath(filename)\n\n        if type(ignore) == str:\n            ignore = [ignore]\n        elif type(ignore) != list:\n            raise DREAMException(\"Unrecognized type of argument 'ignore'. Expected list of strings.\")\n\n        self.init['fromfile']   = fname\n        self.init['eqsysignore'] = ignore\n        self.init['timeindex']  = timeindex",
  "def load(self, filename, path=\"\", lazy=False):\n        \"\"\"\n        Load a DREAMSettings object from the named HDF5 file.\n        'path' specifies the path within the HDF5 file where\n        the DREAMSettings object is stored.\n        \"\"\"\n        data = DREAMIO.LoadHDF5AsDict(filename, path=path, lazy=lazy)\n        self.fromdict(data, filename=filename)",
  "def save(self, filename):\n        \"\"\"\n        Save this settings object to the specified file.\n\n        filename: Name of file to save settings to (the file will\n                  be overwritten if it exists).\n        \"\"\"\n        DREAMIO.SaveDictAsHDF5(filename, self.todict())",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns the settings in this object as a Python dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {}\n        for key, setting in self.settings.items():\n            data[key] = setting.todict(verify=False)\n\n        data['init'] = {}\n\n        if ('eqsysignore' in self.init) and (len(self.init['eqsysignore']) > 0):\n            data['init']['eqsysignore'] = ';'.join(self.init['eqsysignore'])\n\n        if 'timeindex' in self.init:\n            data['init']['filetimeindex'] = self.init['timeindex']\n        if 'fromfile' in self.init:\n            data['init']['fromfile'] = self.init['fromfile']\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the DREAM run has been correctly configured\n        and that all settings are consistent.\n        \"\"\"\n        for _, setting in self.settings.items():\n            setting.verifySettings()\n\n        if ('fromfile' in self.init) and (self.init['fromfile'] != ''):\n            # Verify that the file exists...\n            if not os.path.exists(self.init['fromfile']):\n                print(\"WARNING: The output file from which to initialize '{}' does not exist.\".format(self.init['fromfile']))",
  "class DREAMException(Exception):\n    \n    def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "def setup_interactive(do, glob):\n    \"\"\"\n    Sets up an interactive session by defining all unknowns as \n    global variables and assigning to them from the given\n    DREAM output. 'do' may be either a 'DREAMOutput' object, or\n    a string giving the name of the DREAM output to load.\n\n    do:   DREAMOutput object or name of file to load.\n    glob: Global environment seen by the caller (this should\n          literally be 'globals()')\n    \"\"\"\n    global _wholist\n\n    if type(do) == str:\n        do = DREAMOutput(do)\n    elif not isinstance(do, DREAMOutput):\n        raise DREAMException(\"Unrecognized type of input parameter. Type: {}\".format(type(do)))\n\n    _wholist = list(do.eqsys.keys())\n\n    # Declare unknowns\n    for uqn in do.eqsys.keys():\n        glob[uqn]   = do.eqsys[uqn]\n\n    # Declare other useful stuff\n    glob['grid']  = do.grid\n    glob['other'] = do.other\n    glob['solver'] = do.solver\n    glob['do'] = do\n\n    print('Loaded {} unknowns ({})'.format(len(do.eqsys.keys()), do.getFileSize_s()))\n    print(do.grid)\n    who()",
  "def who():\n    \"\"\"\n    Print a list of variables defined in the loaded DREAMOutput object.\n    \"\"\"\n    global _wholist\n    print('Unknowns:')\n    _wholist.sort(key=str.casefold)\n    for i in range(0, len(_wholist)):\n        if i == 0:\n            print('   {}'.format(_wholist[i]), end=\"\")\n        else:\n            print(', {}'.format(_wholist[i]), end=\"\")\n\n    print(\"\")",
  "def locatedream():\n    global DREAMPATH\n\n    try:\n        DREAMPATH = os.environ['DREAMPATH']\n\n        if DREAMPATH[-1] == '/':\n            DREAMPATH = DREAMPATH[:-1]\n\n    except KeyError: pass\n\n    if DREAMPATH is None:\n        DREAMPATH = (pathlib.Path(__file__).parent / '..' / '..').resolve().absolute()\n\n        if not os.path.isfile('{}/build/iface/dreami'.format(DREAMPATH)):\n            #raise DREAMException(\"Unable to locate the DREAMi executable. Try to set the 'DREAMPATH' environment variable.\")\n            print(\"WARNING: Unable to locate the DREAMi executable. Try to set the 'DREAMPATH' environment variable.\")",
  "def runiface(settings, outfile=None, quiet=False, timeout=None):\n    \"\"\"\n    Run 'dreami' with the specified settings (which may be either\n    a 'DREAMSettings' object or the name of a file containing the\n    settings).\n\n    settings: 'DREAMSettings' object or name of file containing settings.\n    outfile:  Name of file to write output to (default: 'output.h5')\n    \"\"\"\n    global DREAMPATH\n\n    deleteOutput = False\n    if outfile is None:\n        deleteOutput = True\n        outfile = next(tempfile._get_candidate_names())+'.h5'\n\n    infile = None\n    if isinstance(settings, DREAMSettings):\n        infile = next(tempfile._get_candidate_names())+'.h5'\n        settings.output.setFilename(outfile)\n        settings.save(infile)\n    else:\n        infile = settings\n\n    errorOnExit = 0\n    p = None\n    obj = None\n    stderr_data = None\n    try:\n        if quiet:\n            p = subprocess.Popen(['{}/build/iface/dreami'.format(DREAMPATH), infile], stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n        else:\n            p = subprocess.Popen(['{}/build/iface/dreami'.format(DREAMPATH), infile], stderr=subprocess.PIPE)\n\n        try:\n            stderr_data = p.communicate(timeout=timeout)[1].decode('utf-8')\n\n            if p.returncode != 0:\n                errorOnExit = 1\n            else:\n                obj = DREAMOutput(outfile)\n\n                if deleteOutput:\n                    os.remove(outfile)\n        except TimeoutExpired:\n            p.kill()\n            errorOnExit = 3\n    except KeyboardInterrupt:\n        errorOnExit = 2\n    finally:\n        os.remove(infile)\n\n    if errorOnExit == 1:\n        print(stderr_data)\n        raise DREAMException(\"DREAMi exited with a non-zero exit code: {}\".format(p.returncode))\n    elif errorOnExit == 2:\n        raise DREAMException(\"DREAMi simulation was cancelled by the user.\")\n    elif errorOnExit == 3:\n        raise DREAMException(\"DREAMi simulation was killed due to timeout.\")\n    else:\n        return obj",
  "class ConvergenceScanPlot:\n    \n    def __init__(self, scan=None):\n        \"\"\"\n        Constructor.\n\n        :param ConvergenceScan scan: ConvergenceScan objec to plot results from.\n        \"\"\"\n        self.result = None\n        self.outputParameters = None\n        \n        self.loadResult(scan)\n\n\n    def loadResult(self, scan):\n        \"\"\"\n        Load a ConvergenceScan result to analyse.\n\n        :param scan: Either a ConvergenceScan object or a string. If the former, the result of that scan is loaded. Otherwise, the result is assumed to be stored in the file with the name given by the string.\n        \"\"\"\n        if type(scan) is ConvergenceScan:\n            self.result = scan.result\n            self.outputParameters = scan.getOutputParameters()\n        elif type(scan) is str:\n            d = DREAMIO.LoadHDF5AsDict(scan)\n            self.result = d['result']\n            self.outputParameters = d['outputParameters']\n        else:\n            print(\"WARNING: Input 'scan' parameter has an unrecognized type. Ignoring...\")\n\n        \n    def isConverged(self, yesno=True, runIndex=0):\n        \"\"\"\n        Checks whether the ConvergenceScan result is converged\n        in all output parameters with respect to the scan parameter\n        'scanParameter'. If 'scanParameter' is 'None', all scan\n        parameters are returned.\n\n        :param bool yesno: If ``True``, returns a single scalar value declaring whether or not all scans are converged.\n\n        :return: If ``yesno`` is ``False``, returns a dict of scan parameters, each of which in turn contains dicts of output parameters, which are either ``True`` or ``False`` depending on if the scan was converged in that output parameter or not.\n        :rtype: dict\n        \"\"\"\n\n        conv = {}\n        allConverged = True\n        for scanParameter in self.result:\n            conv[scanParameter] = {}\n\n            for outParameter, op in self.result[scanParameter].items():\n                i0 = np.where(op['index'] == runIndex)\n\n                # We prefer to compare to a more well-resolved result\n                i1 = None\n                try: i1 = np.where(op['index'] == runIndex+1)\n                except ValueError: pass\n\n                # If a more well-resolved result is not available, try a\n                # less resolved result\n                if i1 is None:\n                    i1 = np.where(op['index'] == runIndex-1)\n\n                v0 = op['outval'][i0]\n                v1 = op['outval'][i1]\n                        \n                reltol = self.outputParameters[outParameter]['reltol'][0]\n\n                Delta = 1\n                if v1 == 0:\n                    Delta = np.abs(v0)\n                else:\n                    Delta = np.abs(v0/v1-1)\n\n                converged = Delta < reltol\n                conv[scanParameter][outParameter] = converged\n\n                allConverged = allConverged and converged\n\n        if yesno:\n            return allConverged\n        else:\n            return conv\n\n\n    def plot(self, plotShape=None, subplot=True, combineOutput=True, normalized=False):\n        \"\"\"\n        Plots the result of the convergence scan.\n\n        :param tuple plotShape:    If ``subplot`` is ``True``, sets the shape of the subplot to create (i.e. a tuple with two integer values). The product of the elements of this tuple must be greater than or equal to the number of scan parameters (times the number of output parameters if 'combineOutput' is False).\n        :param bool subplot:       If ``True``, plots everything in a single window (but on separate axes).\n        :param bool combineOutput: If ``True``, plots the convergence of all output parameters on the same axes. This forces ``normalized = True`` (but only if there are several output parameters).\n        :param bool normalized:    If ``True``, plots relative error in the parameter (compared to the most well-resolved run). Otherwise, the output parameters are plotted in absolute units.  (This parameter is automatically forced to True if ``combineOutput`` is ``True``).\n        \"\"\"\n        if self.result is None:\n            print(\"WARNING: No result has been loaded.\")\n            return\n\n        # Verify plot shape\n        nscan = len(list(self.result.keys()))\n        nout  = len(list(self.outputParameters.keys()))\n        m, n  = None, None\n\n        # If there's only one output parameter, 'combineOutput'\n        # doesn't make much sense, so to avoid confusing the user\n        # with the behaviour of 'normalized' when 'combineOutput = True',\n        # we disable 'combineOutput' here.\n        if nout == 1:\n            combineOutput = False\n\n        colormap = GeriMap.get()\n\n        if plotShape is None:\n            if combineOutput:\n                m = int(np.ceil(np.sqrt(nscan)))\n                n = int(np.ceil(nscan / m))\n                plotShape = (m, n)\n            else:\n                m = nscan\n                n = nout\n                plotShape = (nout, nscan)\n        else:\n            x = plotShape[0]*plotShape[1]\n\n            if (combineOutput and x < nscan) or (not combineOutput and x < nscan*nout):\n                raise ConvergenceScanException(\"The specified sub-plot shape is not capable of holding all plots.\")\n\n        figsize  = (m*4, n*3)\n\n        # Create figure and axes\n        fig, axes = plt.subplots(plotShape[0], plotShape[1], figsize=figsize)\n        if plotShape[0] == 1:\n            axes = [axes]\n        if plotShape[1] == 1:\n            axes = [[ax] for ax in axes]\n\n        # Generate plots\n        scanParameters = list(self.result.keys())\n        outputParameters = list(self.outputParameters.keys())\n\n        for i in range(0, nscan):\n            idx = 0\n            if combineOutput:\n                (I,J) = np.unravel_index(i, plotShape)\n                ax = axes[I][J]\n\n                for j in range(0, nout):\n                    self.__plotParameter(ax, scanParameters[i], outputParameters[j], normalized=True, ylabel='Relative error', color=colormap(j/(nout+1) * 255))\n            else:\n                for j in range(0, nout):\n                    (I,J) = np.unravel_index(i*nout + j, plotShape)\n                    ax = axes[I][J]\n\n                    self.__plotParameter(ax, scanParameters[i], outputParameters[j], normalized=normalized, ylabel=outputParameters[j], color=colormap(0) * 255)\n\n        # Hide remaining axes\n        for i in range(nscan*nout, m*n):\n            (I, J) = np.unravel_index(i, plotShape)\n            fig.delaxes(axes[I][J])\n\n        plt.tight_layout()\n        plt.show()\n\n\n    def __plotParameter(self, ax, scanParameter, outParameter, normalized, ylabel, color):\n        \"\"\"\n        Plot a single scan for an individual output parameter.\n\n        ax:            matplotlib axes object to plot on.\n        scanParameter: Name of scan parameter to plot.\n        outParameter:  Name of output parameter to plot.\n        normalized:    Whether or not to plot relative error rather\n                       than actual value of parameter.\n        \"\"\"\n        i = self.result[scanParameter][outParameter]['index']\n        l = [str(x) for x in self.result[scanParameter][outParameter]['scanval']]\n        v = self.result[scanParameter][outParameter]['outval']\n\n        if normalized:\n            if v[-1] != 0:\n                v = (v/v[-1] - 1) * 100\n                ylabel += r' (\\%)'\n\n        #ax.plot(i, v, linewidth=2, marker='s', markersize=6, color=color)\n        ax.plot(i, v, linewidth=2, marker='s', markersize=6)\n        ax.set_xlabel(scanParameter)\n        ax.set_ylabel(ylabel)\n        ax.set_xticks(i)\n        ax.set_xticklabels(l)",
  "def __init__(self, scan=None):\n        \"\"\"\n        Constructor.\n\n        :param ConvergenceScan scan: ConvergenceScan objec to plot results from.\n        \"\"\"\n        self.result = None\n        self.outputParameters = None\n        \n        self.loadResult(scan)",
  "def loadResult(self, scan):\n        \"\"\"\n        Load a ConvergenceScan result to analyse.\n\n        :param scan: Either a ConvergenceScan object or a string. If the former, the result of that scan is loaded. Otherwise, the result is assumed to be stored in the file with the name given by the string.\n        \"\"\"\n        if type(scan) is ConvergenceScan:\n            self.result = scan.result\n            self.outputParameters = scan.getOutputParameters()\n        elif type(scan) is str:\n            d = DREAMIO.LoadHDF5AsDict(scan)\n            self.result = d['result']\n            self.outputParameters = d['outputParameters']\n        else:\n            print(\"WARNING: Input 'scan' parameter has an unrecognized type. Ignoring...\")",
  "def isConverged(self, yesno=True, runIndex=0):\n        \"\"\"\n        Checks whether the ConvergenceScan result is converged\n        in all output parameters with respect to the scan parameter\n        'scanParameter'. If 'scanParameter' is 'None', all scan\n        parameters are returned.\n\n        :param bool yesno: If ``True``, returns a single scalar value declaring whether or not all scans are converged.\n\n        :return: If ``yesno`` is ``False``, returns a dict of scan parameters, each of which in turn contains dicts of output parameters, which are either ``True`` or ``False`` depending on if the scan was converged in that output parameter or not.\n        :rtype: dict\n        \"\"\"\n\n        conv = {}\n        allConverged = True\n        for scanParameter in self.result:\n            conv[scanParameter] = {}\n\n            for outParameter, op in self.result[scanParameter].items():\n                i0 = np.where(op['index'] == runIndex)\n\n                # We prefer to compare to a more well-resolved result\n                i1 = None\n                try: i1 = np.where(op['index'] == runIndex+1)\n                except ValueError: pass\n\n                # If a more well-resolved result is not available, try a\n                # less resolved result\n                if i1 is None:\n                    i1 = np.where(op['index'] == runIndex-1)\n\n                v0 = op['outval'][i0]\n                v1 = op['outval'][i1]\n                        \n                reltol = self.outputParameters[outParameter]['reltol'][0]\n\n                Delta = 1\n                if v1 == 0:\n                    Delta = np.abs(v0)\n                else:\n                    Delta = np.abs(v0/v1-1)\n\n                converged = Delta < reltol\n                conv[scanParameter][outParameter] = converged\n\n                allConverged = allConverged and converged\n\n        if yesno:\n            return allConverged\n        else:\n            return conv",
  "def plot(self, plotShape=None, subplot=True, combineOutput=True, normalized=False):\n        \"\"\"\n        Plots the result of the convergence scan.\n\n        :param tuple plotShape:    If ``subplot`` is ``True``, sets the shape of the subplot to create (i.e. a tuple with two integer values). The product of the elements of this tuple must be greater than or equal to the number of scan parameters (times the number of output parameters if 'combineOutput' is False).\n        :param bool subplot:       If ``True``, plots everything in a single window (but on separate axes).\n        :param bool combineOutput: If ``True``, plots the convergence of all output parameters on the same axes. This forces ``normalized = True`` (but only if there are several output parameters).\n        :param bool normalized:    If ``True``, plots relative error in the parameter (compared to the most well-resolved run). Otherwise, the output parameters are plotted in absolute units.  (This parameter is automatically forced to True if ``combineOutput`` is ``True``).\n        \"\"\"\n        if self.result is None:\n            print(\"WARNING: No result has been loaded.\")\n            return\n\n        # Verify plot shape\n        nscan = len(list(self.result.keys()))\n        nout  = len(list(self.outputParameters.keys()))\n        m, n  = None, None\n\n        # If there's only one output parameter, 'combineOutput'\n        # doesn't make much sense, so to avoid confusing the user\n        # with the behaviour of 'normalized' when 'combineOutput = True',\n        # we disable 'combineOutput' here.\n        if nout == 1:\n            combineOutput = False\n\n        colormap = GeriMap.get()\n\n        if plotShape is None:\n            if combineOutput:\n                m = int(np.ceil(np.sqrt(nscan)))\n                n = int(np.ceil(nscan / m))\n                plotShape = (m, n)\n            else:\n                m = nscan\n                n = nout\n                plotShape = (nout, nscan)\n        else:\n            x = plotShape[0]*plotShape[1]\n\n            if (combineOutput and x < nscan) or (not combineOutput and x < nscan*nout):\n                raise ConvergenceScanException(\"The specified sub-plot shape is not capable of holding all plots.\")\n\n        figsize  = (m*4, n*3)\n\n        # Create figure and axes\n        fig, axes = plt.subplots(plotShape[0], plotShape[1], figsize=figsize)\n        if plotShape[0] == 1:\n            axes = [axes]\n        if plotShape[1] == 1:\n            axes = [[ax] for ax in axes]\n\n        # Generate plots\n        scanParameters = list(self.result.keys())\n        outputParameters = list(self.outputParameters.keys())\n\n        for i in range(0, nscan):\n            idx = 0\n            if combineOutput:\n                (I,J) = np.unravel_index(i, plotShape)\n                ax = axes[I][J]\n\n                for j in range(0, nout):\n                    self.__plotParameter(ax, scanParameters[i], outputParameters[j], normalized=True, ylabel='Relative error', color=colormap(j/(nout+1) * 255))\n            else:\n                for j in range(0, nout):\n                    (I,J) = np.unravel_index(i*nout + j, plotShape)\n                    ax = axes[I][J]\n\n                    self.__plotParameter(ax, scanParameters[i], outputParameters[j], normalized=normalized, ylabel=outputParameters[j], color=colormap(0) * 255)\n\n        # Hide remaining axes\n        for i in range(nscan*nout, m*n):\n            (I, J) = np.unravel_index(i, plotShape)\n            fig.delaxes(axes[I][J])\n\n        plt.tight_layout()\n        plt.show()",
  "def __plotParameter(self, ax, scanParameter, outParameter, normalized, ylabel, color):\n        \"\"\"\n        Plot a single scan for an individual output parameter.\n\n        ax:            matplotlib axes object to plot on.\n        scanParameter: Name of scan parameter to plot.\n        outParameter:  Name of output parameter to plot.\n        normalized:    Whether or not to plot relative error rather\n                       than actual value of parameter.\n        \"\"\"\n        i = self.result[scanParameter][outParameter]['index']\n        l = [str(x) for x in self.result[scanParameter][outParameter]['scanval']]\n        v = self.result[scanParameter][outParameter]['outval']\n\n        if normalized:\n            if v[-1] != 0:\n                v = (v/v[-1] - 1) * 100\n                ylabel += r' (\\%)'\n\n        #ax.plot(i, v, linewidth=2, marker='s', markersize=6, color=color)\n        ax.plot(i, v, linewidth=2, marker='s', markersize=6)\n        ax.set_xlabel(scanParameter)\n        ax.set_ylabel(ylabel)\n        ax.set_xticks(i)\n        ax.set_xticklabels(l)",
  "class DREAMOutput:\n    \n\n    def __init__(self, filename=None, path=\"\", lazy=True, loadsettings=True):\n        \"\"\"\n        Construct a new ``DREAMOutput`` object. If ``filename`` is given, the\n        object is read from the (HDF5) file with that name. If ``path`` is also\n        given, this is used to locate the group in the file which contains the\n        output.\n\n        :param str filename:      Name of file to load output from.\n        :param str path:          Path to group in HDF5 file containing the output.\n        :param bool lazy:         If ``True``, allows the file to be read lazily (on-demand) by return h5py DataSet objects instead of the actual data (wrapped in a DREAM.DataObject).  This can greatly reduce load times, but may complicate typing slightly. Note also that the HDF5 file will be locked for as long as the Python interpreter is running.\n        :param bool loadsettings: If ``True``, load the settings stored in the output object.\n        \"\"\"\n\n        # Default\n        self.eqsys = None\n        self.grid = None\n        self.ionmeta = None\n        self.other = None\n        self.settings = None\n        self.solver = None\n        self.timings = None\n\n        self.filename = None\n        self.filesize = 0\n        self.h5handle = None\n\n        if filename is not None:\n            self.load(filename=filename, path=path, lazy=lazy, loadsettings=loadsettings)\n\n\n    def __contains__(self, item):\n        \"\"\"\n        Overriding the Python ``in`` operator and allows to check for the\n        existence of properties of this object.\n        \"\"\"\n        return (item in self.__dict__)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Retrieves a parameter by name.\n        \"\"\"\n        return self.__dict__[index]\n\n\n    def close(self):\n        \"\"\"\n        Close the associated HDF5 File object.\n        \"\"\"\n        if self.h5handle is not None:\n            self.h5handle.close()\n\n\n    def _getsolver(self, solverdata, output):\n        if 'type' in solverdata:\n            if solverdata['type'] == SettingsSolver.LINEAR_IMPLICIT:\n                return SolverLinear(solverdata, output)\n            elif solverdata['type'] == SettingsSolver.NONLINEAR:\n                return SolverNonLinear(solverdata, output)\n        else:\n            print('WARNING: Invalid solver data given.')\n            return None\n\n\n    def load(self, filename, path=\"\", lazy=True, loadsettings=True):\n        \"\"\"\n        Loads DREAM output from the specified file. If 'path' is\n        given, this indicates which group path in the file to load\n        the output from.\n\n        :param str filename:      Name of file to load output from.\n        :param str path:          Path to subsect of HDF5 file containing DREAM output.\n        :param bool lazy:         If ``True``, allows the file to be read lazily (on-demand) by return h5py DataSet objects instead of the actual data (wrapped in a DREAM.DataObject).  This can greatly reduce load times, but may complicate typing slightly. Note also that the HDF5 file will be locked for as long as the Python interpreter is running.\n        :param bool loadsettings: If ``True``, load the settings stored in the output object.\n        \"\"\"\n        self.filename = filename\n\n        od, self.h5handle, self.filesize = DREAMIO.LoadHDF5AsDict(filename, path=path, returnhandle=True, returnsize=True, lazy=lazy)\n\n        if 'grid' in od:\n            self.grid = Grid(od['grid'])\n        else:\n            print(\"WARNING: No grid found in '{}'.\".format(filename))\n        \n        if 'ionmeta' in od:\n            self.ionmeta = IonMetaData(od['ionmeta'])\n        else:\n            print(\"WARNING: No ion meta data found in '{}'.\".format(filename))\n\n        # Equation system should be loaded last, because it\n        # may depend on previously loaded sections\n        if 'eqsys' in od:\n            self.eqsys = EquationSystem(od['eqsys'], grid=self.grid, output=self)\n        else:\n            print(\"WARNING: No equation system found in '{}'.\".format(filename))\n            \n        \n        # Load \"other\" quantities (i.e. quantities which are not part of\n        # the equation system, but may still be interesting to know the\n        # evolution of; this include collision frequencies, bounce averages\n        # and more)\n        if 'other' in od:\n            self.other = OtherQuantityHandler(od['other'], grid=self.grid, output=self)\n\n        # Load settings for the run\n        if 'settings' in od and loadsettings:\n            s = od['settings']\n            if lazy:\n                # Actually read all settings\n                # (yes, we explicitly ignore the lazy loading request since\n                # much of the settings interface has been created without lazy\n                # loading in mind, and since settings are typically *very* small\n                # compared to full-blown DREAM output)\n                s = DREAMIO.unlazy(s)\n\n            self.settings = DREAMSettings(s)\n\n        # Solver statistics\n        if 'solver' in od:\n            self.solver = self._getsolver(od['solver'], output=self)\n\n        # Timing information\n        if 'timings' in od:\n            self.timings = Timings(od['timings'], output=self)\n\n        return od\n\n\n    def getFileSize(self):\n        \"\"\"\n        Returns the size in bytes of the output file.\n        \"\"\"\n        return self.filesize\n\n\n    def getFileSize_s(self, includeBytes=False):\n        \"\"\"\n        Returns the size in bytes of the output file as a\n        nicely formatted string.\n        \"\"\"\n        # Ensure functionality of future super-sized DREAM runs...\n        unit = ['B', 'kiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n\n        i = 0\n        fs = self.filesize\n        while fs > 1024:\n            fs /= 1024\n            i += 1\n\n        s = '{:.2f} {}'.format(fs, unit[i])\n\n        if includeBytes and i > 0:\n            s += ' ({} bytes)'.format(self.filesize)\n\n        return s",
  "def __init__(self, filename=None, path=\"\", lazy=True, loadsettings=True):\n        \"\"\"\n        Construct a new ``DREAMOutput`` object. If ``filename`` is given, the\n        object is read from the (HDF5) file with that name. If ``path`` is also\n        given, this is used to locate the group in the file which contains the\n        output.\n\n        :param str filename:      Name of file to load output from.\n        :param str path:          Path to group in HDF5 file containing the output.\n        :param bool lazy:         If ``True``, allows the file to be read lazily (on-demand) by return h5py DataSet objects instead of the actual data (wrapped in a DREAM.DataObject).  This can greatly reduce load times, but may complicate typing slightly. Note also that the HDF5 file will be locked for as long as the Python interpreter is running.\n        :param bool loadsettings: If ``True``, load the settings stored in the output object.\n        \"\"\"\n\n        # Default\n        self.eqsys = None\n        self.grid = None\n        self.ionmeta = None\n        self.other = None\n        self.settings = None\n        self.solver = None\n        self.timings = None\n\n        self.filename = None\n        self.filesize = 0\n        self.h5handle = None\n\n        if filename is not None:\n            self.load(filename=filename, path=path, lazy=lazy, loadsettings=loadsettings)",
  "def __contains__(self, item):\n        \"\"\"\n        Overriding the Python ``in`` operator and allows to check for the\n        existence of properties of this object.\n        \"\"\"\n        return (item in self.__dict__)",
  "def __getitem__(self, index):\n        \"\"\"\n        Retrieves a parameter by name.\n        \"\"\"\n        return self.__dict__[index]",
  "def close(self):\n        \"\"\"\n        Close the associated HDF5 File object.\n        \"\"\"\n        if self.h5handle is not None:\n            self.h5handle.close()",
  "def _getsolver(self, solverdata, output):\n        if 'type' in solverdata:\n            if solverdata['type'] == SettingsSolver.LINEAR_IMPLICIT:\n                return SolverLinear(solverdata, output)\n            elif solverdata['type'] == SettingsSolver.NONLINEAR:\n                return SolverNonLinear(solverdata, output)\n        else:\n            print('WARNING: Invalid solver data given.')\n            return None",
  "def load(self, filename, path=\"\", lazy=True, loadsettings=True):\n        \"\"\"\n        Loads DREAM output from the specified file. If 'path' is\n        given, this indicates which group path in the file to load\n        the output from.\n\n        :param str filename:      Name of file to load output from.\n        :param str path:          Path to subsect of HDF5 file containing DREAM output.\n        :param bool lazy:         If ``True``, allows the file to be read lazily (on-demand) by return h5py DataSet objects instead of the actual data (wrapped in a DREAM.DataObject).  This can greatly reduce load times, but may complicate typing slightly. Note also that the HDF5 file will be locked for as long as the Python interpreter is running.\n        :param bool loadsettings: If ``True``, load the settings stored in the output object.\n        \"\"\"\n        self.filename = filename\n\n        od, self.h5handle, self.filesize = DREAMIO.LoadHDF5AsDict(filename, path=path, returnhandle=True, returnsize=True, lazy=lazy)\n\n        if 'grid' in od:\n            self.grid = Grid(od['grid'])\n        else:\n            print(\"WARNING: No grid found in '{}'.\".format(filename))\n        \n        if 'ionmeta' in od:\n            self.ionmeta = IonMetaData(od['ionmeta'])\n        else:\n            print(\"WARNING: No ion meta data found in '{}'.\".format(filename))\n\n        # Equation system should be loaded last, because it\n        # may depend on previously loaded sections\n        if 'eqsys' in od:\n            self.eqsys = EquationSystem(od['eqsys'], grid=self.grid, output=self)\n        else:\n            print(\"WARNING: No equation system found in '{}'.\".format(filename))\n            \n        \n        # Load \"other\" quantities (i.e. quantities which are not part of\n        # the equation system, but may still be interesting to know the\n        # evolution of; this include collision frequencies, bounce averages\n        # and more)\n        if 'other' in od:\n            self.other = OtherQuantityHandler(od['other'], grid=self.grid, output=self)\n\n        # Load settings for the run\n        if 'settings' in od and loadsettings:\n            s = od['settings']\n            if lazy:\n                # Actually read all settings\n                # (yes, we explicitly ignore the lazy loading request since\n                # much of the settings interface has been created without lazy\n                # loading in mind, and since settings are typically *very* small\n                # compared to full-blown DREAM output)\n                s = DREAMIO.unlazy(s)\n\n            self.settings = DREAMSettings(s)\n\n        # Solver statistics\n        if 'solver' in od:\n            self.solver = self._getsolver(od['solver'], output=self)\n\n        # Timing information\n        if 'timings' in od:\n            self.timings = Timings(od['timings'], output=self)\n\n        return od",
  "def getFileSize(self):\n        \"\"\"\n        Returns the size in bytes of the output file.\n        \"\"\"\n        return self.filesize",
  "def getFileSize_s(self, includeBytes=False):\n        \"\"\"\n        Returns the size in bytes of the output file as a\n        nicely formatted string.\n        \"\"\"\n        # Ensure functionality of future super-sized DREAM runs...\n        unit = ['B', 'kiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n\n        i = 0\n        fs = self.filesize\n        while fs > 1024:\n            fs /= 1024\n            i += 1\n\n        s = '{:.2f} {}'.format(fs, unit[i])\n\n        if includeBytes and i > 0:\n            s += ' ({} bytes)'.format(self.filesize)\n\n        return s",
  "class ConvergenceScan:\n\n\n    def __init__(self, settings, inparams=None, outparams=None, scanUntilConvergence=False,\n                 verbose=True):\n        \"\"\"\n        Creates a new ConvergenceScan object with 'settings' representing\n        the settings for the baseline scenario.\n\n        :param DREAMSettings settings:    Baseline ``DREAMSettings`` object to base all convergence runs on.\n        :param list inparams:             Either a string (or a list of strings), specifying the set(s) of parameters to scan, or ``None``, which sets no parameters (and they must then be explicitly set using ``addScanParameter()`` later).\n        :param list outparams:            Either a string (or a list of strings), specifying the set(s) of parameters to measure for convergence. Alternatively, ``None`` clears all output parameters (which must then be explicitly set using ``addOutputParameter()`` later).\n        :param bool scanUntilConvergence: If ``True``, does not limit the number of runs to do and updates the value of each parameter until the output parameter changes less than the given tolerance.\n        :param bool verbose:              If ``True``, prints progress message to stdout when running.\n        \"\"\"\n        self.settings = settings\n        self.scanParameters = dict()\n        self.outputParameters = dict()\n\n        self.result = {}\n        self.baselineOutput = None\n        self.verbose = verbose\n\n        # Maximum number of iterations if running scan adaptively\n        self.NMAX = 10\n\n        # Set scan parameters\n        arr = inparams\n        if type(inparams) is not list:\n            arr = [inparams]\n            \n        for inparam in arr:\n            if inparam == 'hottail':\n                self.addScanParameter(name='hottailgrid.pgrid.np',  f=_CS_setiHottailNp,  baselineValue=settings.hottailgrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n                self.addScanParameter(name='hottailgrid.xigrid.nxi', f=_CS_setiHottailNxi, baselineValue=settings.hottailgrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runaway':\n                self.addScanParameter(name='runawaygrid.pgrid.np',  f=_CS_setiRunawayNp,  baselineValue=settings.runawaygrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n                self.addScanParameter(name='runawaygrid.xigrid.nxi', f=_CS_setiRunawayNxi, baselineValue=settings.runawaygrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'hottailgrid.np':\n                self.addScanParameter(name='hottailgrid.pgrid.np',  f=_CS_setiHottailNp,  baselineValue=settings.hottailgrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'hottailgrid.nxi':\n                self.addScanParameter(name='hottailgrid.xigrid.nxi', f=_CS_setiHottailNxi, baselineValue=settings.hottailgrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runawaygrid.np':\n                self.addScanParameter(name='runawaygrid.pgrid.np',  f=_CS_setiRunawayNp,  baselineValue=settings.runawaygrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runawaygrid.nxi':\n                self.addScanParameter(name='runawaygrid.xigrid.nxi', f=_CS_setiRunawayNxi, baselineValue=settings.runawaygrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'nr':\n                self.addScanParameter(name='radialgrid.nr', f=_CS_setiNr, baselineValue=settings.radialgrid.nr, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'nt':\n                self.addScanParameter(name='timestep.nt', f=_CS_setiNt, baselineValue=settings.timestep.nt, scanUntilConvergence=scanUntilConvergence)\n            elif inparam is None: continue\n            else:\n                self.addScanParameter(name=inparam, scanUntilConvergence=scanUntilConvergence)\n                #raise ConvergenceScanException(\"Unrecognized scan parameter set: '{}'.\".format(inparam))\n\n        # Set output parameters\n        arr = outparams\n        if type(outparams) is not list:\n            arr = [outparams]\n\n        for outparam in arr:\n            if outparam is None: continue\n            else:\n                self.addOutputParameter(name=outparam)\n\n\n    def addOutputParameter(self, name: str, f=None, reltol=1e-2):\n        \"\"\"\n        Adds an output parameter to check convergence for.\n\n        :param str name:     Name of output parameter (used as an identifier, but does not have to correspond to the parameter's actual name in DREAM).\n        :param function f:   A function which, given a DREAMOutput object, returns a single float value corresponding to this output parameter.\n        :param float reltol: Relative tolerance to demand if 'scanUntilConvergence' is ``True`` for any of the scan parameters.\n        \"\"\"\n        if f is None:\n            # Try to get parameter by name\n            f = lambda do : _CS_getoByName(do, name)\n\n        self.outputParameters[name] = {'f': f, 'reltol': reltol}\n\n\n    def addScanParameter(self, name: str, f=None, baselineValue=None, scanUntilConvergence=False, nvalues=3, startindex=-1):\n        \"\"\"\n        Adds an input parameter to scan in.\n\n        :param str name:                  Name of parameter (used as an identifier, but does not have to correspond to the parameter's actual name in DREAM).\n        :param function f:                A function which, given an index, a ``DREAMSettings`` object and a baseline value, updates the scan parameter in the settings object. The index can take both positive and negative values, with ``0`` corresponding to the baseline value (negative values thus correspond to *lower resolution* while positive values correspond to *higher resolution*). The function should return a tuple consisting of the modified settings object (which may be the same as the input object) and the value representing the changes made to the ``DREAMSettings`` object (for identification purposes in plots).\n        :param baselineValue:             Baseline value of the parameter (for passing on to ``f``).\n        :param bool scanUntilConvergence: If ``True``, does not limit the number of runs to do and updates the value of each parameter until the output parameter changes less than the given tolerance.\n        :param int nvalues:               Number of values to scan over. Ignored if ``scanUntilConvergence = True``.\n        :param int startindex:            First index to run from. Default: ``-1`` (so that runs are ``-1``, ``0``, ``1``, ..., ``nvalues-2``)\n        \"\"\"\n        if f is None:\n            f = lambda idx, ds, v : _CS_setiByName(idx, ds, v, name)\n        if baselineValue is None:\n            baselineValue = self._getBaselineValue(name)\n\n        self.scanParameters[name] = {'f': f, 'baseline': baselineValue, 'scanUntilConvergence': scanUntilConvergence, 'nvalues': int(nvalues), 'startindex': int(startindex)}\n        self.result[name] = {}\n\n\n    def _getBaselineValue(self, name):\n        \"\"\"\n        Returns the baseline value for the named input parameter.\n        \"\"\"\n        obj = _CS_getObjectByName(self.settings, name)\n\n        if np.isscalar(obj):\n            return obj\n        else:\n            raise ConvergenceScanException(\"Unrecognized type of input parameter '{}': {}.\".format(name, type(obj)))\n\n\n    def getOutputParameters(self):\n        \"\"\"\n        Get a dictionary containing details about the output parameters used in the scan.\n\n        :return: A dict which specifies the settings for the output parameters to consider as measures of convergence.\n        :rtype: dict\n        \"\"\"\n        oparams = {}\n        for opname, op in self.outputParameters.items():\n            oparams[opname] = {'reltol': op['reltol']}\n\n        return oparams\n\n\n    def _processOutput(self, index, scanParameter, scanValue, output):\n        \"\"\"\n        Process the output of a single simulation.\n\n        index:         Index of run.\n        scanParameter: Name of scan parameter settings specifying the scan.\n        output:        DREAMOutput object resulting from the simulation.\n\n        RETURNS False if the relative variation in any output parameter,\n        compared to the previous (or next) index, exceeds its relative\n        tolerance, or if there is no previous or next scan index.\n        Otherwise, returns True (meaning that the parameter is converged).\n        \"\"\"\n        sp = self.scanParameters[scanParameter]\n        converged = True\n\n        if scanParameter not in self.result:\n            self.result[scanParameter] = {}\n\n        for opname, op in self.outputParameters.items():\n            f = op['f']\n            oval = f(output)\n\n            # Store output value in result\n            if opname not in self.result[scanParameter]:\n                self.result[scanParameter][opname] = {'index': [], 'scanval': [], 'outval': []}\n\n            if not np.isscalar(scanValue):\n                scanValue = scanValue[0]\n\n            self.result[scanParameter][opname]['index'].append(index)\n            self.result[scanParameter][opname]['scanval'].append(scanValue)\n            self.result[scanParameter][opname]['outval'].append(oval)\n\n            # Check if simulation is converged\n            if len(self.result[scanParameter][opname]['outval']) == 1:\n                converged = False\n            else:\n                v = self.result[scanParameter][opname]['outval'][-2:]\n                reltol = op['reltol']\n\n                # We should really have an absolute tolerance for this...\n                cv = False\n                Delta = 1\n                if v[1] == 0:\n                    Delta = np.abs(v[0]) \n                    cv = (Delta < reltol)\n                else:\n                    Delta = np.abs(v[0]/v[1] - 1)\n                    cv = (Delta < reltol)\n\n                converged = converged and cv\n                self._status('Output parameter {} {} converged in scan parameter {} (Delta = {})'.format(opname, 'is' if cv else 'is not', scanParameter, Delta))\n\n        return converged\n\n\n    def run(self):\n        \"\"\"\n        Run the convergence scan.\n        \"\"\"\n        self.result = {}\n\n        # Run baseline case\n        self._status(':: Running baseline case...')\n        self.baselineOutput = runiface.runiface(self.settings, quiet=not self.verbose)\n\n        # Iterate over scan parameters\n        for scanParameter, sp in self.scanParameters.items():\n            s = sp['startindex']\n\n            if sp['scanUntilConvergence']:\n                n = self.NMAX + s\n                i = s\n                converged = False\n\n                while i < n and not converged:\n                    output, scanValue = self._runScan(i, scanParameter)\n                    converged = self._processOutput(i, scanParameter, scanValue, output)\n                    i += 1\n            else:\n                n = sp['nvalues']\n                for i in range(s, n+s):\n                    output, scanValue = self._runScan(i, scanParameter)\n                    self._processOutput(i, scanParameter, scanValue, output)\n                    \n\n    def _runScan(self, index, scanParameter):\n        \"\"\"\n        Run an individual DREAM simulation corresponding to index\n        'index' in the scan parameter 'scanParameter'.\n\n        index:         Index in scan of this simulation.\n        scanParameter: Name of scan parameter settings specifying the scan.\n        \"\"\"\n        sp = self.scanParameters[scanParameter]\n        self._status(':: Scan {} ({}/{}) in parameter {}'.format(index, index-sp['startindex']+1, sp['nvalues'], scanParameter))\n\n        # Skip the baseline case\n        if index == 0:\n            self._status(':: Skipping baseline case')\n            return self.baselineOutput, sp['baseline']\n\n        f = sp['f']\n        # Copy DREAMSettings object\n        ns = DREAMSettings(self.settings, chain=False)\n\n        # Modify the settings\n        ns, scanValue = f(index, ns, sp['baseline'])\n\n        return runiface.runiface(ns), scanValue\n\n\n    def save(self, filename):\n        \"\"\"\n        Saves this convergence scan to an HDF5 file.\n\n        :param str filename: Name of file to save scan results to.\n        \"\"\"\n        d = self.todict()\n        DREAMIO.SaveDictAsHDF5(filename=filename, data=d)\n\n\n    def setVerbose(self, verbose=True):\n        \"\"\"\n        If verbose is ``True``, the scan will print progress messages to stdout when running.\n\n        :param bool verbose: Value to set verbosity to.\n        \"\"\"\n        self.verbose = verbose\n\n\n    def _status(self, msg):\n        if self.verbose:\n            print(msg)\n\n\n    def todict(self):\n        \"\"\"\n        Converts the results of this scan to a dictionary object which can easily be saved to file.\n        \"\"\"\n        oparams = self.getOutputParameters()\n        \n        return {\n            'result': self.result,\n            'outputParameters': oparams\n        }",
  "class ConvergenceScanException(Exception):\n    def __init__(self, msg):\n        super(Exception, self).__init__(msg)",
  "def _CS_getObjectByName(do, name, paramType='input'):\n    lst = []\n    if '.' in name: lst = name.split('.')\n    else: lst = [name]\n\n    obj = do\n    for o in lst:\n        print('o = {}, obj = {}'.format(o, obj))\n        if o in obj:\n            obj = obj[o]\n        else:\n            raise ConvergenceScanException(\"Unrecognized {} parameter specified: '{}'.\".format(paramType, o))\n\n    return obj",
  "def _CS_setObjectByName(ds, name, val, paramType='input'):\n    lst = []\n    if '.' in name: lst = name.split('.')\n    else: lst = [name]\n\n    obj = ds\n    for o in lst[:-1]:\n        if o in obj:\n            obj = obj[o]\n        else:\n            raise ConvergenceScanException(\"Unrecognized {} parameter specified: '{}'.\".format(paramType, name))\n\n    if not np.isscalar(obj[lst[-1]]):\n        raise ConvergenceScanException(\"The input parameter '{}' is of an unrecognized type: {}.\".format(name, type(obj)))\n\n    obj.__dict__[lst[-1]] = val",
  "def _CS_setiByName(index: int, settings: DREAMSettings, baseline, name: str):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    _CS_setObjectByName(settings, name, val, 'input')\n    return settings, val",
  "def _CS_setiHottailNp(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.hottailgrid.setNp(val)\n    return settings, val",
  "def _CS_setiHottailNxi(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.hottailgrid.setNxi(val)\n    return settings, val",
  "def _CS_setiRunawayNp(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.runawaygrid.setNp(val)\n    return settings, val",
  "def _CS_setiRunawayNxi(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.runawaygrid.setNxi(val)\n    return settings, val",
  "def _CS_setiNr(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.radialgrid.setNr(val)\n    return settings, val",
  "def _CS_setiNt(index: int, settings: DREAMSettings, baseline):\n    val = max(1,int(np.round(baseline * np.float_power(2, index))))\n    settings.timestep.setNt(val)\n    return settings, val",
  "def _CS_getoByName(do: DREAMOutput, param: str) -> float:\n    obj = _CS_getObjectByName(do, param, 'output')\n\n    # Get last element of array (this makes most\n    # sense for time-evolving scalar data, as this\n    # selection then corresponds to the final value\n    # of the scalar parameter)\n    arr = obj[:]\n    slc = tuple([-1] * arr.ndim)\n\n    return arr[slc]",
  "def __init__(self, settings, inparams=None, outparams=None, scanUntilConvergence=False,\n                 verbose=True):\n        \"\"\"\n        Creates a new ConvergenceScan object with 'settings' representing\n        the settings for the baseline scenario.\n\n        :param DREAMSettings settings:    Baseline ``DREAMSettings`` object to base all convergence runs on.\n        :param list inparams:             Either a string (or a list of strings), specifying the set(s) of parameters to scan, or ``None``, which sets no parameters (and they must then be explicitly set using ``addScanParameter()`` later).\n        :param list outparams:            Either a string (or a list of strings), specifying the set(s) of parameters to measure for convergence. Alternatively, ``None`` clears all output parameters (which must then be explicitly set using ``addOutputParameter()`` later).\n        :param bool scanUntilConvergence: If ``True``, does not limit the number of runs to do and updates the value of each parameter until the output parameter changes less than the given tolerance.\n        :param bool verbose:              If ``True``, prints progress message to stdout when running.\n        \"\"\"\n        self.settings = settings\n        self.scanParameters = dict()\n        self.outputParameters = dict()\n\n        self.result = {}\n        self.baselineOutput = None\n        self.verbose = verbose\n\n        # Maximum number of iterations if running scan adaptively\n        self.NMAX = 10\n\n        # Set scan parameters\n        arr = inparams\n        if type(inparams) is not list:\n            arr = [inparams]\n            \n        for inparam in arr:\n            if inparam == 'hottail':\n                self.addScanParameter(name='hottailgrid.pgrid.np',  f=_CS_setiHottailNp,  baselineValue=settings.hottailgrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n                self.addScanParameter(name='hottailgrid.xigrid.nxi', f=_CS_setiHottailNxi, baselineValue=settings.hottailgrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runaway':\n                self.addScanParameter(name='runawaygrid.pgrid.np',  f=_CS_setiRunawayNp,  baselineValue=settings.runawaygrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n                self.addScanParameter(name='runawaygrid.xigrid.nxi', f=_CS_setiRunawayNxi, baselineValue=settings.runawaygrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'hottailgrid.np':\n                self.addScanParameter(name='hottailgrid.pgrid.np',  f=_CS_setiHottailNp,  baselineValue=settings.hottailgrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'hottailgrid.nxi':\n                self.addScanParameter(name='hottailgrid.xigrid.nxi', f=_CS_setiHottailNxi, baselineValue=settings.hottailgrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runawaygrid.np':\n                self.addScanParameter(name='runawaygrid.pgrid.np',  f=_CS_setiRunawayNp,  baselineValue=settings.runawaygrid.pgrid.np, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'runawaygrid.nxi':\n                self.addScanParameter(name='runawaygrid.xigrid.nxi', f=_CS_setiRunawayNxi, baselineValue=settings.runawaygrid.xigrid.nxi, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'nr':\n                self.addScanParameter(name='radialgrid.nr', f=_CS_setiNr, baselineValue=settings.radialgrid.nr, scanUntilConvergence=scanUntilConvergence)\n            elif inparam == 'nt':\n                self.addScanParameter(name='timestep.nt', f=_CS_setiNt, baselineValue=settings.timestep.nt, scanUntilConvergence=scanUntilConvergence)\n            elif inparam is None: continue\n            else:\n                self.addScanParameter(name=inparam, scanUntilConvergence=scanUntilConvergence)\n                #raise ConvergenceScanException(\"Unrecognized scan parameter set: '{}'.\".format(inparam))\n\n        # Set output parameters\n        arr = outparams\n        if type(outparams) is not list:\n            arr = [outparams]\n\n        for outparam in arr:\n            if outparam is None: continue\n            else:\n                self.addOutputParameter(name=outparam)",
  "def addOutputParameter(self, name: str, f=None, reltol=1e-2):\n        \"\"\"\n        Adds an output parameter to check convergence for.\n\n        :param str name:     Name of output parameter (used as an identifier, but does not have to correspond to the parameter's actual name in DREAM).\n        :param function f:   A function which, given a DREAMOutput object, returns a single float value corresponding to this output parameter.\n        :param float reltol: Relative tolerance to demand if 'scanUntilConvergence' is ``True`` for any of the scan parameters.\n        \"\"\"\n        if f is None:\n            # Try to get parameter by name\n            f = lambda do : _CS_getoByName(do, name)\n\n        self.outputParameters[name] = {'f': f, 'reltol': reltol}",
  "def addScanParameter(self, name: str, f=None, baselineValue=None, scanUntilConvergence=False, nvalues=3, startindex=-1):\n        \"\"\"\n        Adds an input parameter to scan in.\n\n        :param str name:                  Name of parameter (used as an identifier, but does not have to correspond to the parameter's actual name in DREAM).\n        :param function f:                A function which, given an index, a ``DREAMSettings`` object and a baseline value, updates the scan parameter in the settings object. The index can take both positive and negative values, with ``0`` corresponding to the baseline value (negative values thus correspond to *lower resolution* while positive values correspond to *higher resolution*). The function should return a tuple consisting of the modified settings object (which may be the same as the input object) and the value representing the changes made to the ``DREAMSettings`` object (for identification purposes in plots).\n        :param baselineValue:             Baseline value of the parameter (for passing on to ``f``).\n        :param bool scanUntilConvergence: If ``True``, does not limit the number of runs to do and updates the value of each parameter until the output parameter changes less than the given tolerance.\n        :param int nvalues:               Number of values to scan over. Ignored if ``scanUntilConvergence = True``.\n        :param int startindex:            First index to run from. Default: ``-1`` (so that runs are ``-1``, ``0``, ``1``, ..., ``nvalues-2``)\n        \"\"\"\n        if f is None:\n            f = lambda idx, ds, v : _CS_setiByName(idx, ds, v, name)\n        if baselineValue is None:\n            baselineValue = self._getBaselineValue(name)\n\n        self.scanParameters[name] = {'f': f, 'baseline': baselineValue, 'scanUntilConvergence': scanUntilConvergence, 'nvalues': int(nvalues), 'startindex': int(startindex)}\n        self.result[name] = {}",
  "def _getBaselineValue(self, name):\n        \"\"\"\n        Returns the baseline value for the named input parameter.\n        \"\"\"\n        obj = _CS_getObjectByName(self.settings, name)\n\n        if np.isscalar(obj):\n            return obj\n        else:\n            raise ConvergenceScanException(\"Unrecognized type of input parameter '{}': {}.\".format(name, type(obj)))",
  "def getOutputParameters(self):\n        \"\"\"\n        Get a dictionary containing details about the output parameters used in the scan.\n\n        :return: A dict which specifies the settings for the output parameters to consider as measures of convergence.\n        :rtype: dict\n        \"\"\"\n        oparams = {}\n        for opname, op in self.outputParameters.items():\n            oparams[opname] = {'reltol': op['reltol']}\n\n        return oparams",
  "def _processOutput(self, index, scanParameter, scanValue, output):\n        \"\"\"\n        Process the output of a single simulation.\n\n        index:         Index of run.\n        scanParameter: Name of scan parameter settings specifying the scan.\n        output:        DREAMOutput object resulting from the simulation.\n\n        RETURNS False if the relative variation in any output parameter,\n        compared to the previous (or next) index, exceeds its relative\n        tolerance, or if there is no previous or next scan index.\n        Otherwise, returns True (meaning that the parameter is converged).\n        \"\"\"\n        sp = self.scanParameters[scanParameter]\n        converged = True\n\n        if scanParameter not in self.result:\n            self.result[scanParameter] = {}\n\n        for opname, op in self.outputParameters.items():\n            f = op['f']\n            oval = f(output)\n\n            # Store output value in result\n            if opname not in self.result[scanParameter]:\n                self.result[scanParameter][opname] = {'index': [], 'scanval': [], 'outval': []}\n\n            if not np.isscalar(scanValue):\n                scanValue = scanValue[0]\n\n            self.result[scanParameter][opname]['index'].append(index)\n            self.result[scanParameter][opname]['scanval'].append(scanValue)\n            self.result[scanParameter][opname]['outval'].append(oval)\n\n            # Check if simulation is converged\n            if len(self.result[scanParameter][opname]['outval']) == 1:\n                converged = False\n            else:\n                v = self.result[scanParameter][opname]['outval'][-2:]\n                reltol = op['reltol']\n\n                # We should really have an absolute tolerance for this...\n                cv = False\n                Delta = 1\n                if v[1] == 0:\n                    Delta = np.abs(v[0]) \n                    cv = (Delta < reltol)\n                else:\n                    Delta = np.abs(v[0]/v[1] - 1)\n                    cv = (Delta < reltol)\n\n                converged = converged and cv\n                self._status('Output parameter {} {} converged in scan parameter {} (Delta = {})'.format(opname, 'is' if cv else 'is not', scanParameter, Delta))\n\n        return converged",
  "def run(self):\n        \"\"\"\n        Run the convergence scan.\n        \"\"\"\n        self.result = {}\n\n        # Run baseline case\n        self._status(':: Running baseline case...')\n        self.baselineOutput = runiface.runiface(self.settings, quiet=not self.verbose)\n\n        # Iterate over scan parameters\n        for scanParameter, sp in self.scanParameters.items():\n            s = sp['startindex']\n\n            if sp['scanUntilConvergence']:\n                n = self.NMAX + s\n                i = s\n                converged = False\n\n                while i < n and not converged:\n                    output, scanValue = self._runScan(i, scanParameter)\n                    converged = self._processOutput(i, scanParameter, scanValue, output)\n                    i += 1\n            else:\n                n = sp['nvalues']\n                for i in range(s, n+s):\n                    output, scanValue = self._runScan(i, scanParameter)\n                    self._processOutput(i, scanParameter, scanValue, output)",
  "def _runScan(self, index, scanParameter):\n        \"\"\"\n        Run an individual DREAM simulation corresponding to index\n        'index' in the scan parameter 'scanParameter'.\n\n        index:         Index in scan of this simulation.\n        scanParameter: Name of scan parameter settings specifying the scan.\n        \"\"\"\n        sp = self.scanParameters[scanParameter]\n        self._status(':: Scan {} ({}/{}) in parameter {}'.format(index, index-sp['startindex']+1, sp['nvalues'], scanParameter))\n\n        # Skip the baseline case\n        if index == 0:\n            self._status(':: Skipping baseline case')\n            return self.baselineOutput, sp['baseline']\n\n        f = sp['f']\n        # Copy DREAMSettings object\n        ns = DREAMSettings(self.settings, chain=False)\n\n        # Modify the settings\n        ns, scanValue = f(index, ns, sp['baseline'])\n\n        return runiface.runiface(ns), scanValue",
  "def save(self, filename):\n        \"\"\"\n        Saves this convergence scan to an HDF5 file.\n\n        :param str filename: Name of file to save scan results to.\n        \"\"\"\n        d = self.todict()\n        DREAMIO.SaveDictAsHDF5(filename=filename, data=d)",
  "def setVerbose(self, verbose=True):\n        \"\"\"\n        If verbose is ``True``, the scan will print progress messages to stdout when running.\n\n        :param bool verbose: Value to set verbosity to.\n        \"\"\"\n        self.verbose = verbose",
  "def _status(self, msg):\n        if self.verbose:\n            print(msg)",
  "def todict(self):\n        \"\"\"\n        Converts the results of this scan to a dictionary object which can easily be saved to file.\n        \"\"\"\n        oparams = self.getOutputParameters()\n        \n        return {\n            'result': self.result,\n            'outputParameters': oparams\n        }",
  "def __init__(self, msg):\n        super(Exception, self).__init__(msg)",
  "def merge_dicts(old, new):\n    \"\"\"\n    Update entries in the dictionary 'old' with the corresponding\n    values in the dictionary 'new'. This function operates recursively.\n    \"\"\"\n    d = old.copy()\n    for k in new:\n        if type(new[k]) == dict:\n            if k not in d:\n                d[k] = {}\n\n            d[k] = merge_dicts(d[k], new[k])\n        else:\n            d[k] = new[k]\n\n    return d",
  "def safeTeXstring(s):\n    mappings = {\n        '#': r'\\#',\n        '_': r'\\_'\n    }\n\n    for key, val in mappings.items():\n        s = s.replace(key, val)\n    \n    return s",
  "class DataObject:\n    \n    def __init__(self, obj):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.data = obj\n\n        if type(obj) == np.ndarray:\n            self.type  = DATA_TYPE_ARRAY\n            self.shape = obj.shape\n            self.ndim  = obj.ndim\n        elif type(obj) == h5py.Dataset:\n            if obj.dtype == 'S1' or str(obj.dtype).startswith('|S') or obj.dtype == 'object':\n                self.type = DATA_TYPE_H5STRING\n                self.shape = (len(self[:]),)\n                self.ndim  = 1\n            else:\n                self.type  = DATA_TYPE_HDF5\n                self.shape = obj.shape\n                self.ndim  = obj.ndim\n        elif type(obj) == str:\n            self.type  = DATA_TYPE_STRING\n            self.shape = (len(obj),)\n            self.ndim  = 1\n        else:\n            raise Exception(\"Unrecognized data type of object: '{}'.\".format(type(obj)))\n\n        self.size = np.prod(self.shape)\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Test for equality between this object and the given\n        object.\n        \"\"\"\n        if self.type in [DATA_TYPE_ARRAY, DATA_TYPE_STRING]:\n            return (self.data == other)\n        else:\n            return (self.data[:] == other)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Access data.\n        \"\"\"\n        if self.type == DATA_TYPE_H5STRING:\n            # Convert string properly\n            return self._getstring()[index]\n        elif self.type == DATA_TYPE_HDF5:\n            if type(index) == tuple and None in index:\n                return self.data[:][index]\n            else:\n                return self.data[index]\n        else:\n            return self.data[index]\n\n\n    def __int__(self):\n        if self.type == DATA_TYPE_ARRAY:\n            return int(self.data)\n        else:\n            return int(self[:])\n    \n\n    def __len__(self):\n        \"\"\"\n        Return the number of elements in this dataset.\n        \"\"\"\n        return self.size\n\n\n    def __repr__(self):\n        \"\"\"\n        String representation of this object.\n        \"\"\"\n        if self.type == DATA_TYPE_STRING:\n            return self.data.__repr__()\n        elif self.type == DATA_TYPE_H5STRING:\n            return self._getstring().__repr__()\n        elif self.type == DATA_TYPE_ARRAY:\n            return self.data.__repr__()\n        else:\n            return self.data[:].__repr__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this data object into a string.\n        \"\"\"\n        if self.type == DATA_TYPE_ARRAY:\n            return str(self.data)\n        else:\n            return str(self[:])\n\n\n    def _getstring(self):\n        \"\"\"\n        Convert an H5STRING to a Python string.\n        \"\"\"\n        if self.type == DATA_TYPE_H5STRING:\n            # Convert string properly\n            if (self.data.dtype == 'S1') or (str(self.data.dtype).startswith('|S')):  # Regular strings\n                return self.data[:].tostring().decode('utf-8')\n            elif self.data.dtype == 'object':  # New strings\n                if type(self.data[:][0]) == str:\n                    return self.data[:][0]\n                else:\n                    return self.data[:][0].decode()\n        elif self.type == DATA_TYPE_STRING:\n            return self.data\n        else:\n            raise Exception(\"The '_getstring()' method is only intended for HDF5 strings.\")\n\n\n    def __array__(self, dtype=None):\n        \"\"\"\n        Convert to numpy array.\n        \"\"\"\n        return np.asarray(self[:], dtype=dtype)\n\n\n    \"\"\"\n    ARITHMETIC OPERATIONS\n    \"\"\"\n    def _lop(self, op, f):\n        \"\"\"\n        Binary operator where self is the left operand.\n        \"\"\"\n        if np.isscalar(op):\n            return f(self.data[:], op)\n        else:\n            return f(self.data[:], op[:])\n\n\n    def __add__(self, other): return self._lop(other, lambda o1, o2 : o1+o2)\n\n\n    def __sub__(self, other): return self._lop(other, lambda o1, o2 : o1-o2)\n\n\n    def __mul__(self, other): return self._lop(other, lambda o1, o2 : o1*o2)\n\n\n    def __truediv__(self, other): return self._lop(other, lambda o1, o2 : o1.__truediv__(o2))\n\n\n    def __pow__(self, other): return self._lop(other, lambda o1, o2 : o1**o2)\n\n\n    def __and__(self, other): return self._lop(other, lambda o1, o2 : o1 and o2)\n\n\n    def __or__(self, other): return self._lop(other, lambda o1, o2 : o1 or p2)\n\n\n    def __neg__(self): return -self.data[:]\n\n\n    def __pos__(self): return +self.data[:]\n\n\n    def __abs__(self): return abs(self.data[:])\n\n\n    def __invert__(self): return ~self.data[:]",
  "def __init__(self, obj):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.data = obj\n\n        if type(obj) == np.ndarray:\n            self.type  = DATA_TYPE_ARRAY\n            self.shape = obj.shape\n            self.ndim  = obj.ndim\n        elif type(obj) == h5py.Dataset:\n            if obj.dtype == 'S1' or str(obj.dtype).startswith('|S') or obj.dtype == 'object':\n                self.type = DATA_TYPE_H5STRING\n                self.shape = (len(self[:]),)\n                self.ndim  = 1\n            else:\n                self.type  = DATA_TYPE_HDF5\n                self.shape = obj.shape\n                self.ndim  = obj.ndim\n        elif type(obj) == str:\n            self.type  = DATA_TYPE_STRING\n            self.shape = (len(obj),)\n            self.ndim  = 1\n        else:\n            raise Exception(\"Unrecognized data type of object: '{}'.\".format(type(obj)))\n\n        self.size = np.prod(self.shape)",
  "def __eq__(self, other):\n        \"\"\"\n        Test for equality between this object and the given\n        object.\n        \"\"\"\n        if self.type in [DATA_TYPE_ARRAY, DATA_TYPE_STRING]:\n            return (self.data == other)\n        else:\n            return (self.data[:] == other)",
  "def __getitem__(self, index):\n        \"\"\"\n        Access data.\n        \"\"\"\n        if self.type == DATA_TYPE_H5STRING:\n            # Convert string properly\n            return self._getstring()[index]\n        elif self.type == DATA_TYPE_HDF5:\n            if type(index) == tuple and None in index:\n                return self.data[:][index]\n            else:\n                return self.data[index]\n        else:\n            return self.data[index]",
  "def __int__(self):\n        if self.type == DATA_TYPE_ARRAY:\n            return int(self.data)\n        else:\n            return int(self[:])",
  "def __len__(self):\n        \"\"\"\n        Return the number of elements in this dataset.\n        \"\"\"\n        return self.size",
  "def __repr__(self):\n        \"\"\"\n        String representation of this object.\n        \"\"\"\n        if self.type == DATA_TYPE_STRING:\n            return self.data.__repr__()\n        elif self.type == DATA_TYPE_H5STRING:\n            return self._getstring().__repr__()\n        elif self.type == DATA_TYPE_ARRAY:\n            return self.data.__repr__()\n        else:\n            return self.data[:].__repr__()",
  "def __str__(self):\n        \"\"\"\n        Convert this data object into a string.\n        \"\"\"\n        if self.type == DATA_TYPE_ARRAY:\n            return str(self.data)\n        else:\n            return str(self[:])",
  "def _getstring(self):\n        \"\"\"\n        Convert an H5STRING to a Python string.\n        \"\"\"\n        if self.type == DATA_TYPE_H5STRING:\n            # Convert string properly\n            if (self.data.dtype == 'S1') or (str(self.data.dtype).startswith('|S')):  # Regular strings\n                return self.data[:].tostring().decode('utf-8')\n            elif self.data.dtype == 'object':  # New strings\n                if type(self.data[:][0]) == str:\n                    return self.data[:][0]\n                else:\n                    return self.data[:][0].decode()\n        elif self.type == DATA_TYPE_STRING:\n            return self.data\n        else:\n            raise Exception(\"The '_getstring()' method is only intended for HDF5 strings.\")",
  "def __array__(self, dtype=None):\n        \"\"\"\n        Convert to numpy array.\n        \"\"\"\n        return np.asarray(self[:], dtype=dtype)",
  "def _lop(self, op, f):\n        \"\"\"\n        Binary operator where self is the left operand.\n        \"\"\"\n        if np.isscalar(op):\n            return f(self.data[:], op)\n        else:\n            return f(self.data[:], op[:])",
  "def __add__(self, other): return self._lop(other, lambda o1, o2 : o1+o2)",
  "def __sub__(self, other): return self._lop(other, lambda o1, o2 : o1-o2)",
  "def __mul__(self, other): return self._lop(other, lambda o1, o2 : o1*o2)",
  "def __truediv__(self, other): return self._lop(other, lambda o1, o2 : o1.__truediv__(o2))",
  "def __pow__(self, other): return self._lop(other, lambda o1, o2 : o1**o2)",
  "def __and__(self, other): return self._lop(other, lambda o1, o2 : o1 and o2)",
  "def __or__(self, other): return self._lop(other, lambda o1, o2 : o1 or p2)",
  "def __neg__(self): return -self.data[:]",
  "def __pos__(self): return +self.data[:]",
  "def __abs__(self): return abs(self.data[:])",
  "def __invert__(self): return ~self.data[:]",
  "class UnknownQuantity:\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        name:   Name of unknown.\n        data:   Data of unknown.\n        attr:   List of attributes of this unknown.\n        grid:   Grid used for the DREAM simulation.\n        output: Parent DREAMOutput object.\n        \"\"\"\n        self.name = name\n        self.data = data\n        self.grid = grid\n        self.output = output\n\n        if 'description' in attr:\n            self.description = attr['description']\n        if 'equation' in attr:\n            self.description_eqn = attr['equation']\n\n\n    def __getitem__(self, key):\n        \"\"\"\n        Direct access to 'data' dict.\n        \"\"\"\n        return self.data[key]\n\n\n    def __add__(self, other): return self.add(other, type(self))\n    def __mul__(self, other): return self.mul(other, type(self))\n    def __sub__(self, other): return self.sub(other, type(self))\n    def __truediv__(self, other): return self.div(other, type(self))\n    def __pow__(self, other): return self.pow(other, type(self))\n\n    def __radd__(self, other): return self.add(other, type(self), reverse=True)\n    def __rmul__(self, other): return self.mul(other, type(self), reverse=True)\n    def __rsub__(self, other): return self.sub(other, type(self), reverse=True)\n    def __rtruediv__(self, other): return self.div(other, type(self), reverse=True)\n    def __rpow__(self, other): return self.pow(other, type(self), reverse=True)\n\n\n    def add(self, other, qty=None, reverse=False):\n        \"\"\"Add value or other UnknownQuantity to this object.\"\"\"\n        return self._operate(lambda a,b: a+b, other, qty, reverse, '+')\n\n\n    def div(self, other, qty=None, reverse=False):\n        \"\"\"Divide UnknownQuantity by value or other UnknownQuantity.\"\"\"\n        return self._operate(lambda a,b: a/b, other, qty, reverse, '/')\n\n    \n    def mul(self, other, qty=None, reverse=False):\n        \"\"\"Multiply value or other UnknownQuantity to this object.\"\"\"\n        return self._operate(lambda a,b: a*b, other, qty, reverse, '*')\n\n\n    def pow(self, other, qty=None, reverse=False):\n        \"\"\"Exponentiate UnknownQuantity to the given value or other UnknownQuantity.\"\"\"\n        return self._operate(lambda a,b: a**b, other, qty, reverse, '^')\n\n\n    def sub(self, other, qty=None, reverse=False):\n        \"\"\"Subtract value or other UnknownQuantity to this obejct.\"\"\"\n        return self._operate(lambda a,b: a-b, other, qty, reverse, '-')\n\n\n    def _operate(self, operation, other, qty=None, reverse=False, opname=None):\n        \"\"\"\n        Execute the 'operation' on 'self' and 'other'. Return\n        the result as a new object of type 'qty'.\n\n        operation: Function executing the desired operation on the two\n                   operands.\n        other:     Second operand of addition.\n        qty:       Type of object to generate (default: UnknownQuantity).\n        reverse:   If 'True', reverses the order of the operands passed to\n                   'operation'.\n        opname:    Name of operation.\n        \"\"\"\n        op = lambda a,b: operation(b, a) if reverse else operation(a, b)\n\n        # Perform operation\n        v = None\n        otherName = 'const'\n        data = self.data[:]\n        if type(other) == float or type(other) == int:\n            v = op(data, other)\n            otherName = str(other)\n        elif type(other) == np.ndarray:\n            if self.data.shape != other.shape:\n                raise OutputException(\"Mismatching dimensions of operands: {} and {}.\".format(self.data.shape, other.shape))\n            \n            v = op(data, other)\n        elif self.data.shape == other.data.shape or (np.isscalar(data) or np.isscalar(other.data)):\n            v = op(data, other.data)\n\n            # If different types, we locate the closest\n            # common ancestor and convert to that type\n            if type(other) != qty:\n                classes = [type(self).mro(), type(other).mro()]\n                for x in classes[0]:\n                    if all(x in mro for mro in classes):\n                        qty = x\n                        break\n\n                print('Closest ancestor: {}'.format(type(qty)))\n\n\n            otherName = other.name\n        else:\n            raise OutputException(\"Unsupported type of operand: {}\".format(type(other)))\n\n        # Determine new name\n        def nametransform(n):\n            if ' ' in n: return '('+n+')'\n            else: return n\n\n        name1 = nametransform(self.name)\n        name2 = nametransform(otherName)\n\n        if reverse:\n            name1, name2 = name2, name1\n\n        newname = self.name\n        if opname is not None:\n            if type(opname) == str:\n                newname = '{} {} {}'.format(name1, opname, name2)\n            else:\n                newname = opname(self.name, otherName)\n\n        # Construct new object\n        if qty is None:\n            return UnknownQuantity(name=newname, data=v, grid=self.grid, output=self.output, attr={'description': '', 'equation': newname})\n        else:\n            return qty(name=newname, data=v, grid=self.grid, output=self.output, attr={'description': '', 'equation': newname})\n\n\n    def getName(self): return self.name\n\n\n    def getData(self): return self.data[:]\n    \n\n    def getTeXName(self):\n        return self.name.replace('_', r'\\_')\n\n\n    def getTeXIntegralName(self):\n        return 'Integrated '+self.getTeXName()",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        name:   Name of unknown.\n        data:   Data of unknown.\n        attr:   List of attributes of this unknown.\n        grid:   Grid used for the DREAM simulation.\n        output: Parent DREAMOutput object.\n        \"\"\"\n        self.name = name\n        self.data = data\n        self.grid = grid\n        self.output = output\n\n        if 'description' in attr:\n            self.description = attr['description']\n        if 'equation' in attr:\n            self.description_eqn = attr['equation']",
  "def __getitem__(self, key):\n        \"\"\"\n        Direct access to 'data' dict.\n        \"\"\"\n        return self.data[key]",
  "def __add__(self, other): return self.add(other, type(self))",
  "def __mul__(self, other): return self.mul(other, type(self))",
  "def __sub__(self, other): return self.sub(other, type(self))",
  "def __truediv__(self, other): return self.div(other, type(self))",
  "def __pow__(self, other): return self.pow(other, type(self))",
  "def __radd__(self, other): return self.add(other, type(self), reverse=True)",
  "def __rmul__(self, other): return self.mul(other, type(self), reverse=True)",
  "def __rsub__(self, other): return self.sub(other, type(self), reverse=True)",
  "def __rtruediv__(self, other): return self.div(other, type(self), reverse=True)",
  "def __rpow__(self, other): return self.pow(other, type(self), reverse=True)",
  "def add(self, other, qty=None, reverse=False):\n        \"\"\"Add value or other UnknownQuantity to this object.\"\"\"\n        return self._operate(lambda a,b: a+b, other, qty, reverse, '+')",
  "def div(self, other, qty=None, reverse=False):\n        \"\"\"Divide UnknownQuantity by value or other UnknownQuantity.\"\"\"\n        return self._operate(lambda a,b: a/b, other, qty, reverse, '/')",
  "def mul(self, other, qty=None, reverse=False):\n        \"\"\"Multiply value or other UnknownQuantity to this object.\"\"\"\n        return self._operate(lambda a,b: a*b, other, qty, reverse, '*')",
  "def pow(self, other, qty=None, reverse=False):\n        \"\"\"Exponentiate UnknownQuantity to the given value or other UnknownQuantity.\"\"\"\n        return self._operate(lambda a,b: a**b, other, qty, reverse, '^')",
  "def sub(self, other, qty=None, reverse=False):\n        \"\"\"Subtract value or other UnknownQuantity to this obejct.\"\"\"\n        return self._operate(lambda a,b: a-b, other, qty, reverse, '-')",
  "def _operate(self, operation, other, qty=None, reverse=False, opname=None):\n        \"\"\"\n        Execute the 'operation' on 'self' and 'other'. Return\n        the result as a new object of type 'qty'.\n\n        operation: Function executing the desired operation on the two\n                   operands.\n        other:     Second operand of addition.\n        qty:       Type of object to generate (default: UnknownQuantity).\n        reverse:   If 'True', reverses the order of the operands passed to\n                   'operation'.\n        opname:    Name of operation.\n        \"\"\"\n        op = lambda a,b: operation(b, a) if reverse else operation(a, b)\n\n        # Perform operation\n        v = None\n        otherName = 'const'\n        data = self.data[:]\n        if type(other) == float or type(other) == int:\n            v = op(data, other)\n            otherName = str(other)\n        elif type(other) == np.ndarray:\n            if self.data.shape != other.shape:\n                raise OutputException(\"Mismatching dimensions of operands: {} and {}.\".format(self.data.shape, other.shape))\n            \n            v = op(data, other)\n        elif self.data.shape == other.data.shape or (np.isscalar(data) or np.isscalar(other.data)):\n            v = op(data, other.data)\n\n            # If different types, we locate the closest\n            # common ancestor and convert to that type\n            if type(other) != qty:\n                classes = [type(self).mro(), type(other).mro()]\n                for x in classes[0]:\n                    if all(x in mro for mro in classes):\n                        qty = x\n                        break\n\n                print('Closest ancestor: {}'.format(type(qty)))\n\n\n            otherName = other.name\n        else:\n            raise OutputException(\"Unsupported type of operand: {}\".format(type(other)))\n\n        # Determine new name\n        def nametransform(n):\n            if ' ' in n: return '('+n+')'\n            else: return n\n\n        name1 = nametransform(self.name)\n        name2 = nametransform(otherName)\n\n        if reverse:\n            name1, name2 = name2, name1\n\n        newname = self.name\n        if opname is not None:\n            if type(opname) == str:\n                newname = '{} {} {}'.format(name1, opname, name2)\n            else:\n                newname = opname(self.name, otherName)\n\n        # Construct new object\n        if qty is None:\n            return UnknownQuantity(name=newname, data=v, grid=self.grid, output=self.output, attr={'description': '', 'equation': newname})\n        else:\n            return qty(name=newname, data=v, grid=self.grid, output=self.output, attr={'description': '', 'equation': newname})",
  "def getName(self): return self.name",
  "def getData(self): return self.data[:]",
  "def getTeXName(self):\n        return self.name.replace('_', r'\\_')",
  "def getTeXIntegralName(self):\n        return 'Integrated '+self.getTeXName()",
  "def nametransform(n):\n            if ' ' in n: return '('+n+')'\n            else: return n",
  "class Grid:\n    \n\n    def __init__(self, grid=None):\n        \"\"\"\n        Constructor.\n\n        grid: Grid data from DREAM output.\n        \"\"\"\n        self.t = None\n        self.r = None\n        self.r_f = None\n        self.dr = None\n        self.VpVol = None\n        self.hottail = None\n        self.runaway = None\n\n        # Geometric quantities\n        self.effectivePassingFraction = None\n        self.xi0TrappedBoundary = None\n        self.toroidalFlux = None\n\n        if grid is not None:\n            self.setGrid(grid)\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s  = \"DREAM Grid Object\\n\"\n        s += \"   t: {} elements from {} to {}\\n\".format(self.t.size, self.t[0], self.t[-1])\n        s += \"   r: {} elements from {} to {}\\n\".format(self.r.size, self.r[0], self.r[-1])\n        s += \"   hottail   ({})\\n{}\".format(self.strType(self.hottail) if self.hottail is not None else 'DISABLED', self.strGrid(self.hottail))\n        s += \"   runaway   ({})\\n{}\".format(self.strType(self.runaway) if self.runaway is not None else 'DISABLED', self.strGrid(self.runaway))\n\n        return s\n\n\n    def getTimeAndUnit(self, t):\n        \"\"\"\n        If 't' is an integer, returns the time at the specified index,\n        together with the appropriate unit. Otherwise, if 't' is a float,\n        returns the specified time with the appropriate unit.\n        \"\"\"\n        if type(t) == int:\n            return self.getTimeAndUnit(t=self.t[t])\n\n        unit = ['s', 'ms', r'\\mu s', 'ns', 'ps']\n        tval = t\n        ui = 0\n\n        if tval == 0: return tval, unit[ui]\n\n        while tval < 1 and ui+1 < len(unit):\n            tval *= 1e3\n            ui += 1\n\n        return tval, unit[ui]\n\n\n    def integrate(self, data, w=1.0, axis=-1):\n        \"\"\"\n        Evaluate a numerical volume integral of the given data\n        on this grid.\n\n        data: Data to integrate.\n        w:    Optional weighting function.\n        axis: Axis to integrate over.\n        \"\"\"\n        return (self.VpVol*self.dr * w * data).sum(axis)\n\n\n    def strType(self, grid):\n        \"\"\"\n        Returns the grid type as a string representation\n        \"\"\"\n        if grid is None: return \"\"\n\n        if grid.type == MomentumGrid.TYPE_PXI:\n            return 'p/xi'\n        elif grid.type == MomentumGrid.TYPE_PPARPPERP:\n            return 'ppar/pperp'\n        else:\n            return '<unknown-type>'\n\n\n    def strGrid(self, grid):\n        \"\"\"\n        Returns some information about the grid as a string.\n        \"\"\"\n        if grid is None: return \"\"\n\n        s  = \"      {:6s} {} elements from {} to {}\\n\".format(grid.p1name+':', grid.p1.size, grid.p1[0], grid.p1[-1])\n        s += \"      {:6s} {} elements from {} to {}\\n\".format(grid.p2name+':', grid.p2.size, grid.p2[0], grid.p2[-1])\n\n        return s\n\n\n    def setGrid(self, grid):\n        \"\"\"\n        Set grid data based on output from DREAM.\n        \"\"\"\n        self.t = grid['t']\n        self.r = grid['r']\n        self.r_f = grid['r_f']\n        self.dr = grid['dr']\n        self.VpVol = grid['VpVol']\n\n        if 'R0' in grid:\n            self.R0 = grid['R0']\n        if 'a' in grid:\n            self.a = grid['a']\n\n        if 'geometry' in grid:        \n            geom = grid['geometry']\n            self.effectivePassingFraction = geom['effectivePassingFraction']\n            self.xi0TrappedBoundary = geom['xi0TrappedBoundary']\n            self.toroidalFlux = geom['toroidalFlux']\n            self.GR0 = geom['GR0']\n            self.Bmin = geom['Bmin']\n            self.Bmax = geom['Bmax']\n            self.FSA_BOverBmin2 = geom['FSA_BOverBmin2']\n            self.FSA_BOverBmin = geom['FSA_BOverBmin']\n            self.FSA_R02OverR2 = geom['FSA_R02OverR2']\n            self.FSA_NablaR2_R02OverR2 = geom['FSA_NablaR2_R02OverR2']\n        \n        # Workaround for initial data which doesn't have a time grid from DREAM\n        # (TODO we should fix this in the kernel instead)\n        if self.t.size == 0:\n            self.t = np.array([0])\n\n        if 'hottail' in grid:\n            self.hottail = self._generateMomentumGrid('hottail', data=grid['hottail'])\n\n        if 'runaway' in grid:\n            self.runaway = self._generateMomentumGrid('runaway', data=grid['runaway'])\n\n\n    def _generateMomentumGrid(self, name, data):\n        \"\"\"\n        Generate momentum grid object of the appropriate type.\n\n        name: Grid name.\n        data: Raw grid data from DREAM output file.\n        \"\"\"\n        if data['type'] == MomentumGrid.TYPE_PXI:\n            return PXiGrid(name=name, rgrid=self, data=data)\n        elif data['type'] == MomentumGrid.TYPE_PPARPPERP:\n            return PparPperpGrid(name=name, r=self, data=data)\n        else:\n            raise OutputException(\"grid: Unrecognized grid type: {}.\".format(data['type']))",
  "def __init__(self, grid=None):\n        \"\"\"\n        Constructor.\n\n        grid: Grid data from DREAM output.\n        \"\"\"\n        self.t = None\n        self.r = None\n        self.r_f = None\n        self.dr = None\n        self.VpVol = None\n        self.hottail = None\n        self.runaway = None\n\n        # Geometric quantities\n        self.effectivePassingFraction = None\n        self.xi0TrappedBoundary = None\n        self.toroidalFlux = None\n\n        if grid is not None:\n            self.setGrid(grid)",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s  = \"DREAM Grid Object\\n\"\n        s += \"   t: {} elements from {} to {}\\n\".format(self.t.size, self.t[0], self.t[-1])\n        s += \"   r: {} elements from {} to {}\\n\".format(self.r.size, self.r[0], self.r[-1])\n        s += \"   hottail   ({})\\n{}\".format(self.strType(self.hottail) if self.hottail is not None else 'DISABLED', self.strGrid(self.hottail))\n        s += \"   runaway   ({})\\n{}\".format(self.strType(self.runaway) if self.runaway is not None else 'DISABLED', self.strGrid(self.runaway))\n\n        return s",
  "def getTimeAndUnit(self, t):\n        \"\"\"\n        If 't' is an integer, returns the time at the specified index,\n        together with the appropriate unit. Otherwise, if 't' is a float,\n        returns the specified time with the appropriate unit.\n        \"\"\"\n        if type(t) == int:\n            return self.getTimeAndUnit(t=self.t[t])\n\n        unit = ['s', 'ms', r'\\mu s', 'ns', 'ps']\n        tval = t\n        ui = 0\n\n        if tval == 0: return tval, unit[ui]\n\n        while tval < 1 and ui+1 < len(unit):\n            tval *= 1e3\n            ui += 1\n\n        return tval, unit[ui]",
  "def integrate(self, data, w=1.0, axis=-1):\n        \"\"\"\n        Evaluate a numerical volume integral of the given data\n        on this grid.\n\n        data: Data to integrate.\n        w:    Optional weighting function.\n        axis: Axis to integrate over.\n        \"\"\"\n        return (self.VpVol*self.dr * w * data).sum(axis)",
  "def strType(self, grid):\n        \"\"\"\n        Returns the grid type as a string representation\n        \"\"\"\n        if grid is None: return \"\"\n\n        if grid.type == MomentumGrid.TYPE_PXI:\n            return 'p/xi'\n        elif grid.type == MomentumGrid.TYPE_PPARPPERP:\n            return 'ppar/pperp'\n        else:\n            return '<unknown-type>'",
  "def strGrid(self, grid):\n        \"\"\"\n        Returns some information about the grid as a string.\n        \"\"\"\n        if grid is None: return \"\"\n\n        s  = \"      {:6s} {} elements from {} to {}\\n\".format(grid.p1name+':', grid.p1.size, grid.p1[0], grid.p1[-1])\n        s += \"      {:6s} {} elements from {} to {}\\n\".format(grid.p2name+':', grid.p2.size, grid.p2[0], grid.p2[-1])\n\n        return s",
  "def setGrid(self, grid):\n        \"\"\"\n        Set grid data based on output from DREAM.\n        \"\"\"\n        self.t = grid['t']\n        self.r = grid['r']\n        self.r_f = grid['r_f']\n        self.dr = grid['dr']\n        self.VpVol = grid['VpVol']\n\n        if 'R0' in grid:\n            self.R0 = grid['R0']\n        if 'a' in grid:\n            self.a = grid['a']\n\n        if 'geometry' in grid:        \n            geom = grid['geometry']\n            self.effectivePassingFraction = geom['effectivePassingFraction']\n            self.xi0TrappedBoundary = geom['xi0TrappedBoundary']\n            self.toroidalFlux = geom['toroidalFlux']\n            self.GR0 = geom['GR0']\n            self.Bmin = geom['Bmin']\n            self.Bmax = geom['Bmax']\n            self.FSA_BOverBmin2 = geom['FSA_BOverBmin2']\n            self.FSA_BOverBmin = geom['FSA_BOverBmin']\n            self.FSA_R02OverR2 = geom['FSA_R02OverR2']\n            self.FSA_NablaR2_R02OverR2 = geom['FSA_NablaR2_R02OverR2']\n        \n        # Workaround for initial data which doesn't have a time grid from DREAM\n        # (TODO we should fix this in the kernel instead)\n        if self.t.size == 0:\n            self.t = np.array([0])\n\n        if 'hottail' in grid:\n            self.hottail = self._generateMomentumGrid('hottail', data=grid['hottail'])\n\n        if 'runaway' in grid:\n            self.runaway = self._generateMomentumGrid('runaway', data=grid['runaway'])",
  "def _generateMomentumGrid(self, name, data):\n        \"\"\"\n        Generate momentum grid object of the appropriate type.\n\n        name: Grid name.\n        data: Raw grid data from DREAM output file.\n        \"\"\"\n        if data['type'] == MomentumGrid.TYPE_PXI:\n            return PXiGrid(name=name, rgrid=self, data=data)\n        elif data['type'] == MomentumGrid.TYPE_PPARPPERP:\n            return PparPperpGrid(name=name, r=self, data=data)\n        else:\n            raise OutputException(\"grid: Unrecognized grid type: {}.\".format(data['type']))",
  "class ElectricField(FluidQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n    \n    def getNormEfield(self, field, r=None, t=None):\n        \"\"\"\n        Returns an electric field from the other quantities by name.\n        This routine is intended as a uniform interface for fetching\n        quantities such as Ec, Eceff, ED etc.\n        \"\"\"\n        # List of supported quantities (to avoid user error)\n        nrm = ['Eceff', 'Ecfree', 'Ectot', 'Ec', 'ED', 'EDreic']\n        if field == 'Ec': field = 'Ectot'\n        elif field == 'ED': field = 'EDreic'\n\n        if 'fluid' not in self.output.other:\n            raise OutputException('No \"other\" fluid quantities saved in output. Normalizing electric fields are thus not available.')\n        if field not in nrm:\n            raise OutputException(\"Cannot normalize to '{}': This seems to not make sense.\".format(field))\n        if field not in self.output.other.fluid:\n            raise OutputException(\"Cannot normalize to '{}': quantity not saved to output after simulation.\".format(field))\n\n        return self.output.other.fluid[field].get(r=r, t=t)\n\n\n    def maxEnergy(self, t=-1):\n        r\"\"\"\n        Evaluates the maximum attainable runaway kinetic energy (in normalized\n        units) at time ``t``. This energy is obtained by integrating the\n        equation of motion:\n\n        .. math::\n        \n            \\frac{\\mathrm{d}p}{\\mathrm{d}t} = eE \\quad\\implies\\quad\n            p = \\int_0^t eE(t)\\,\\mathrm{d}t',\\\\\n            W = mc^2(\\sqrt{p^2+1}-1),\n\n        where :math:`e` is the elementary charge and :math:`p` is the electron\n        momentum.\n\n        :param int t: Index of time to calculate transferred momentum until.\n        \"\"\"\n        p = self.maxMomentum(t=t)\n        return np.sqrt(p**2 + 1)-1\n\n\n    def maxMomentum(self, t=-1):\n        r\"\"\"\n        Evaluates the maximum attainable runaway momentum (in normalized units)\n        at time ``t``. This momentum is obtained by integrating the equation of\n        motion:\n\n        .. math::\n        \n            \\frac{\\mathrm{d}p}{\\mathrm{d}t} = eE \\quad\\implies\\quad\n            p = \\int_0^t eE(t)\\,\\mathrm{d}t',\n\n        where :math:`e` is the elementary charge and :math:`p` is the electron\n        momentum.\n\n        :param int t: Index of time to calculate transferred momentum until.\n        \"\"\"\n        if np.isscalar(t):\n            p = np.trapz(self[:t], self.grid.t[:t], axis=0)\n        else:\n            p = []\n            t = np.asarray(t)\n\n            if t.ndim != 1:\n                raise OutputException(\"Unrecognized dimensions of time index: {}.\".format(t.ndim))\n\n            for time in t:\n                p.append(np.trapz(self[:time], self.grid.t[:time], axis=0))\n\n            p = np.array(p)\n\n        p *= scipy.constants.e / (scipy.constants.m_e * scipy.constants.c)\n        return p\n\n\n    def norm(self, to='Ec'):\n        \"\"\"\n        Return the value of this quantity normalized to the\n        quantity specified by 'to'.\n\n        to: Name of quantity to normalize electric field to.\n            Possible values:\n               Eceff   Effective critical electric field (as defined by Hesslow et al)\n               Ecfree  Connor-Hastie threshold field (calculated with n=n_free)\n               Ectot   Connor-Hastie threshold field (calculated with n=n_tot)\n               Ec      (alias for 'Ectot')\n               ED      Dreicer field\n            Note that the quantity with which to normalize to\n            must be saved as an 'OtherQuantity'.\n        \"\"\"\n        return self.normalize(to=to)\n\n\n    def normalize(self, to='Ec'):\n        \"\"\"\n        Return the value of this quantity normalized to the\n        quantity specified by 'to'.\n\n        to: Name of quantity to normalize electric field to.\n            Possible values:\n               Eceff   Effective critical electric field (as defined by Hesslow et al)\n               Ecfree  Connor-Hastie threshold field (calculated with n=n_free)\n               Ectot   Connor-Hastie threshold field (calculated with n=n_tot)\n               Ec      (alias for 'Ectot')\n               EDreic  Dreicer field\n               ED      (alias for 'EDreic')\n            Note that the quantity with which to normalize to\n            must be saved as an 'OtherQuantity'.\n        \"\"\"\n        # OtherQuantity's are not defined at t=0, so we extend them\n        # arbitrarily here (in order for the resulting FluidQuantity to\n        # be plottable on the regular time grid)\n        Enorm = np.zeros(self.data.shape)\n        Enorm[1:,:] = self.getNormEfield(field=to)\n        Enorm[0,:]  = Enorm[1,:]\n\n        data = self.data[:] / Enorm\n        return FluidQuantity(name='E / {}'.format(to), data=data, grid=self.grid, output=self.output)\n\n\n    def plot(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plot(), adding the 'norm' argument\n        (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plot(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plot(**kwargs)\n\n\n    def plotRadialProfile(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotRadialProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotRadialProfile(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotRadialProfile(**kwargs)\n\n\n    def plotTimeProfile(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotTimeProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotTimeProfile(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotTimeProfile(**kwargs)\n\n\n    def plotIntegral(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotTimeProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotIntegral(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotIntegral(**kwargs)",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)",
  "def getNormEfield(self, field, r=None, t=None):\n        \"\"\"\n        Returns an electric field from the other quantities by name.\n        This routine is intended as a uniform interface for fetching\n        quantities such as Ec, Eceff, ED etc.\n        \"\"\"\n        # List of supported quantities (to avoid user error)\n        nrm = ['Eceff', 'Ecfree', 'Ectot', 'Ec', 'ED', 'EDreic']\n        if field == 'Ec': field = 'Ectot'\n        elif field == 'ED': field = 'EDreic'\n\n        if 'fluid' not in self.output.other:\n            raise OutputException('No \"other\" fluid quantities saved in output. Normalizing electric fields are thus not available.')\n        if field not in nrm:\n            raise OutputException(\"Cannot normalize to '{}': This seems to not make sense.\".format(field))\n        if field not in self.output.other.fluid:\n            raise OutputException(\"Cannot normalize to '{}': quantity not saved to output after simulation.\".format(field))\n\n        return self.output.other.fluid[field].get(r=r, t=t)",
  "def maxEnergy(self, t=-1):\n        r\"\"\"\n        Evaluates the maximum attainable runaway kinetic energy (in normalized\n        units) at time ``t``. This energy is obtained by integrating the\n        equation of motion:\n\n        .. math::\n        \n            \\frac{\\mathrm{d}p}{\\mathrm{d}t} = eE \\quad\\implies\\quad\n            p = \\int_0^t eE(t)\\,\\mathrm{d}t',\\\\\n            W = mc^2(\\sqrt{p^2+1}-1),\n\n        where :math:`e` is the elementary charge and :math:`p` is the electron\n        momentum.\n\n        :param int t: Index of time to calculate transferred momentum until.\n        \"\"\"\n        p = self.maxMomentum(t=t)\n        return np.sqrt(p**2 + 1)-1",
  "def maxMomentum(self, t=-1):\n        r\"\"\"\n        Evaluates the maximum attainable runaway momentum (in normalized units)\n        at time ``t``. This momentum is obtained by integrating the equation of\n        motion:\n\n        .. math::\n        \n            \\frac{\\mathrm{d}p}{\\mathrm{d}t} = eE \\quad\\implies\\quad\n            p = \\int_0^t eE(t)\\,\\mathrm{d}t',\n\n        where :math:`e` is the elementary charge and :math:`p` is the electron\n        momentum.\n\n        :param int t: Index of time to calculate transferred momentum until.\n        \"\"\"\n        if np.isscalar(t):\n            p = np.trapz(self[:t], self.grid.t[:t], axis=0)\n        else:\n            p = []\n            t = np.asarray(t)\n\n            if t.ndim != 1:\n                raise OutputException(\"Unrecognized dimensions of time index: {}.\".format(t.ndim))\n\n            for time in t:\n                p.append(np.trapz(self[:time], self.grid.t[:time], axis=0))\n\n            p = np.array(p)\n\n        p *= scipy.constants.e / (scipy.constants.m_e * scipy.constants.c)\n        return p",
  "def norm(self, to='Ec'):\n        \"\"\"\n        Return the value of this quantity normalized to the\n        quantity specified by 'to'.\n\n        to: Name of quantity to normalize electric field to.\n            Possible values:\n               Eceff   Effective critical electric field (as defined by Hesslow et al)\n               Ecfree  Connor-Hastie threshold field (calculated with n=n_free)\n               Ectot   Connor-Hastie threshold field (calculated with n=n_tot)\n               Ec      (alias for 'Ectot')\n               ED      Dreicer field\n            Note that the quantity with which to normalize to\n            must be saved as an 'OtherQuantity'.\n        \"\"\"\n        return self.normalize(to=to)",
  "def normalize(self, to='Ec'):\n        \"\"\"\n        Return the value of this quantity normalized to the\n        quantity specified by 'to'.\n\n        to: Name of quantity to normalize electric field to.\n            Possible values:\n               Eceff   Effective critical electric field (as defined by Hesslow et al)\n               Ecfree  Connor-Hastie threshold field (calculated with n=n_free)\n               Ectot   Connor-Hastie threshold field (calculated with n=n_tot)\n               Ec      (alias for 'Ectot')\n               EDreic  Dreicer field\n               ED      (alias for 'EDreic')\n            Note that the quantity with which to normalize to\n            must be saved as an 'OtherQuantity'.\n        \"\"\"\n        # OtherQuantity's are not defined at t=0, so we extend them\n        # arbitrarily here (in order for the resulting FluidQuantity to\n        # be plottable on the regular time grid)\n        Enorm = np.zeros(self.data.shape)\n        Enorm[1:,:] = self.getNormEfield(field=to)\n        Enorm[0,:]  = Enorm[1,:]\n\n        data = self.data[:] / Enorm\n        return FluidQuantity(name='E / {}'.format(to), data=data, grid=self.grid, output=self.output)",
  "def plot(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plot(), adding the 'norm' argument\n        (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plot(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plot(**kwargs)",
  "def plotRadialProfile(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotRadialProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotRadialProfile(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotRadialProfile(**kwargs)",
  "def plotTimeProfile(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotTimeProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotTimeProfile(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotTimeProfile(**kwargs)",
  "def plotIntegral(self, norm=None, **kwargs):\n        \"\"\"\n        Wrapper for FluidQuantity.plotTimeProfile(), adding the 'norm'\n        argument (for directly plotting a normalized electric field)\n        \"\"\"\n        if norm is None:\n            return super().plotIntegral(**kwargs)\n        else:\n            _E = self.normalize(to=norm)\n            return _E.plotIntegral(**kwargs)",
  "class FluidQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(FluidQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        # Cell or flux grid?\n        if data.shape[1] == self.grid.r.size:\n            self.radius = self.grid.r\n        elif data.shape[1] == self.grid.r.size+1:\n            self.radius = self.grid.r_f\n        else:\n            raise Exception(\"Unrecognized shape of data for '{}': {}. Expected (nt, nr) = ({}, {}).\".format(name, data.shape, grid.t.size, grid.r.size))\n\n        self.time = self.grid.t\n\n    \n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__() + \"\\n\"\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \":: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n        s += self.dumps()\n        return s\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Fluid quantity of size NT x NR = {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1])\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]\n\n\n    def animate(self, keep=[], ax=None, repeat=False, repeat_delay=None, speed=None, blit=True, save=None, dpi=None, **kwargs):\n        \"\"\"\n        Creates an animation of the time evolution of this\n        fluid quantity.\n\n        :param list keep:   List of time indices to keep after plotting.\n        :param bool repeat: If ``True``, repeats the animation.\n        \"\"\"\n        show = ax is None\n\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        def update_ani(num, fq, ax, line, lbl, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(fq.time[num]*tfac, tunit))\n            line.set_data(fq.radius, self.data[num,:])\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n                keeplines[idx].set_data(fq.radius, self.data[num,:])\n\n            return (line, lbl) + tuple(keeplines)\n\n        # Automatically determine the plotting interval\n        if speed is None:\n            speed = 50\n        \n        line, = ax.plot(self.radius, self.data[0,:], 'k', linewidth=2, **kwargs)\n\n        # Create placeholders for the 'keep' lines\n        keeplines = []\n        if keep is not None:\n            for i in range(len(keep)):\n                l, = ax.plot([], [], linewidth=2, **kwargs)\n                keeplines.append(l)\n\n        xmin, xmax = 0, self.radius[-1]\n        ax.set_xlim([xmin, xmax])\n\n        # Set y limits\n        data = self.data[:]     # Make sure to load data only once\n        ymin, ymax = 1.1*np.amin(data), 1.1*np.amax(data)\n        if ymin >= 0:\n            ymin, ymax = 0, 1.1*np.amax(data)\n\n        ax.set_ylim([ymin, ymax])\n        \n        # Determine relevant time scale\n        tmax = self.time[-1]\n        idx  = 0\n        tfac = 1\n        tunits = ['s', 'ms', '\u00b5s', 'ns', 'ps']\n        while tmax*tfac < 1 and idx < len(tunits)-1:\n            idx += 1\n            tfac = (1e3)**(idx)\n\n        xp, yp = 0.03, 0.93\n        txt = ax.text(xmin+xp*(xmax-xmin), ymin+yp*(ymax-ymin), r't = {:.3f} {}'.format(self.time[0]*tfac, tunits[idx]), usetex=False)\n\n        ax.set_xlabel(r'$r/a$ (m)')\n\n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=self.time.size,\n            interval=speed, repeat_delay=repeat_delay, repeat=repeat, blit=blit,\n            fargs=(self, ax, line, txt, keeplines, tfac, tunits[idx], keep))\n\n        # Save animation?\n        if save:\n            writer = animation.FFMpegFileWriter(fps=1000/speed)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\n        if show:\n            plt.show()\n\n\n    def get(self, r=None, t=None):\n        \"\"\"\n        Returns the data in the specified time or radial point. If neither ``r``\n        nor ``t`` are given, returns the full spatiotemporal evolution of the\n        profile.\n        \"\"\"\n        if (r is None) and (t is None):\n            return self.data[:]\n        elif (r is not None) and (t is None):\n            return self.data[:,r]\n        elif (r is None) and (t is not None):\n            return self.data[t,:]\n        else:\n            return self.data[t,r]\n\n        \n    def plot(self, ax=None, show=None, r=None, t=None, log=False, colorbar=True, VpVol=False, weight=None, unit='s', **kwargs):\n        \"\"\"\n        Generate a contour plot of the spatiotemporal evolution of this\n        quantity.\n\n        :param ax:       Matplotlib axes object to use for plotting.\n        :param show:     If 'True', shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param log:      If ``True``, plot on a logarithmic scale.\n        :param colorbar: If ``True``, and a 2D plot is requested, also draw a colorbar.\n        :param VpVol:    Weight quantity with ``grid.VpVol`` when plotting.\n        :param weight:   Optional quantity to weight this quantity with when plotting.\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # If the data is 1D, make sure it is plotted\n        # as such (and not as a contour plot)\n        if self.data.shape[0] == 1:\n            t = 0\n        elif self.data.shape[1] == 1:\n            r = 0\n        \n        if (r is None) and (t is None):\n            data = self.data[:]\n            if VpVol:\n                data *= self.grid.VpVol[:]\n            if weight is not None:\n                data *= weight\n\n            if log:\n                data = np.log10(np.abs(data))\n\n            time = self.time * self._getTimeUnitFactor(unit)\n\n            cp = ax.contourf(self.radius, time, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'Radius $r$ (m)')\n            ax.set_ylabel(fr'Time $t$ ({unit})')\n\n            cb = None\n            if colorbar:\n                cb = plt.colorbar(mappable=cp, ax=ax)\n\n            if show:\n                plt.show(block=False)\n\n            return ax, cb\n        elif (r is not None) and (t is None):\n            return self.plotTimeProfile(r=r, ax=ax, show=show, VpVol=VpVol, weight=weight, log=log, **kwargs)\n        elif (r is None) and (t is not None):\n            return self.plotRadialProfile(t=t, ax=ax, show=show, VpVol=VpVol, weight=weight, log=log, **kwargs)\n        else:\n            raise OutputException(\"Cannot plot a scalar value. r = {}, t = {}.\".format(r, t))\n\n\n    def plotPoloidal(self, ax=None, show=None, t=-1, colorbar=True, displayGrid=False, maxMinScale=True, logscale=False, **kwargs):\n        \"\"\"\n        Plot the radial profile of this quantity revolved over a \n        poloidal cross section at the specified time step. \n        NOTE: Currently assumes a cylindrical flux surface geometry!\n        \n        :param matplotlib.pyplot.Axis ax:   Matplotlib axes object to use for plotting.\n        :param bool show: If 'True', shows the plot immediately via a call to 'matplotlib.pyplot.show()' with 'block=False'. If 'None', this is interpreted as 'True' if 'ax' is also 'None'.\n        :param int t: Time index to plot.\n        :param matplotlib.pyplot.Colorbar colorbar: Specify wether or not to include a colorbar.\n        :param bool displayGrid: Specify wether or not to display a polar grid in the plot.\n        :param bool maxMinScale: If 'True', set tha max and min of the color scale to the maximum and minimum values of the data stored by this object over all time steps.\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        \n        genax = ax is None\n\n        if genax:\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([self.grid.r[0],self.grid.r[-1]])\n            ax.set_title('t = '+str(self.grid.t[t]))\n\n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n\n            if show is None:\n                show = True\n                \n        theta=np.linspace(0,2*np.pi)\n        if logscale:\n        \tdata_mat=np.log10(self.data[t,:])*np.ones((len(theta),len(self.grid.r)))\n        else:\n        \tdata_mat=self.data[t,:]*np.ones((len(theta),len(self.grid.r)))\n        \t\n        if maxMinScale:\n            if logscale:\n                cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',levels=np.linspace(np.min(np.log10(self.data)),np.max(np.log10(self.data))), **kwargs)\n            else:\n                cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',levels=np.linspace(np.min(self.data),np.max(self.data)), **kwargs)\n        else:\n            cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',**kwargs)\n\t\t\t\n        cb = None\n        if colorbar:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n            if logscale:\n                cb.ax.set_ylabel('$\\log _{10}($'+'{}'.format(self.getTeXName()+')'))\n            else:\n                cb.ax.set_ylabel('{}'.format(self.getTeXName()))\n            \n        if show:\n            plt.show(block=False)\n            \n        return ax, cb\n\n        \n    def animatePoloidal(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None,**kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the present quantity, \n        including the specified time steps.\n        \n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param float dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        \"\"\"\n        \n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPoloidal(show=False,t=0,**kwargs)\n        \n        def update_ani(t, fq, ax):\n            ax.clear()\n            ax=fq.plotPoloidal(colorbar=False, show=False,t=t,**kwargs)\n        \n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n        \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()\n\n    def plotRadialProfile(self, t=-1, ax=None, show=None, VpVol=False, weight=None, log=False, **kwargs):\n        \"\"\"\n        Plot the radial profile of this quantity at the specified time slice.\n\n        :param t:      Time index to plot.\n        :param ax:     Matplotlib axes object to use for plotting.\n        :param show:   If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param VpVol:  If ``True``, weight the radial profile with the spatial jacobian V'.\n        :param weight: Optional quantity to weight this quantity with when plotting.\n        :param log:    If ``True``, plot on a logarithmic scale.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if np.isscalar(t):\n            t = [t]\n\n        lbls = []\n        vpv = self.grid.VpVol[:]\n        for it in t:\n            data = self.data[it,:]\n            wlbl = ''\n            if VpVol:\n                data *= vpv\n                wlbl += \"*V'\"\n            if weight is not None:\n                data *= weight\n                wlbl += '*w'\n\n\n            if log:\n                if np.any(data>0):\n                    ax.semilogy(self.radius, data, **kwargs)\n                else:\n                    ax.semilogy(self.radius, -data, '--', **kwargs)\n            else:\n                ax.plot(self.radius, data, **kwargs)\n\n            # Add legend label\n            tval, unit = self.grid.getTimeAndUnit(it)\n            lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}$'.format(tval, unit))\n\n        ax.set_xlabel(r'Radius $r$ (m)')\n        ax.set_ylabel('{}{}'.format(self.getTeXName(), wlbl))\n\n        if len(lbls) > 0:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n\n        return ax   \t\n\n\n    def plotTimeProfile(self, r=0, ax=None, show=None, VpVol=False, weight=None, log=False, **kwargs):\n        \"\"\"\n        Plot the temporal profile of this quantity at the specified radius.\n\n        :param r:      Radial index to plot evolution for.\n        :param ax:     Matplotlib axes object to use for plotting.\n        :param show:   If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param VpVol:  If ``True``, weight the radial profile with the spatial jacobian V'.\n        :param weight: Optional quantity to weight this quantity with when plotting.\n        :param log:    If ``True``, plot on a logarithmic scale.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if np.isscalar(r):\n            r = [r]\n\n        lbls = []\n        for ir in r:\n            data = self.data[:,ir]\n            wlbl = ''\n            if VpVol:\n                data *= self.grid.VpVol[ir]\n                wlbl += \"*V'\"\n            if weight is not None:\n                data *= weight\n                wlbl += '*w'\n\n            if log:\n                if np.any(data>0):\n                    ax.semilogy(self.time, data, **kwargs)\n                else:\n                    ax.semilogy(self.time, -data, '--', **kwargs)\n            else:\n                ax.plot(self.time, data, **kwargs)\n\n            # Add legend label\n            lbls.append(r'$r = {:.3f}\\,\\mathrm{{m}}$'.format(self.radius[ir]))\n\n        ax.set_xlabel(r'Time $t$')\n        ax.set_ylabel('{}{}'.format(self.getTeXName(), wlbl))\n\n        if len(lbls) > 1:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n\n        return ax\n\n\n    def plotIntegral(self, ax=None, show=None, unit='s', time_shift = 0, time_scale_factor = 1.0, w=1.0, time_derivative = False, log=False, **kwargs):\n        \"\"\"\n        Plot the time evolution of the radial integral of this quantity.\n\n        :param ax:   Matplotlib axes object to use for plotting.\n        :param show: If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        time = self.time * self._getTimeUnitFactor(unit)\n        time = time + time_shift\n        time = time*time_scale_factor\n\n        if time_derivative:\n            integrated_data = self.integral(w=w)\n            tm = time[1:-1]\n            v = (integrated_data[2:]-integrated_data[:-2])/((time[2:]-time[:-2])/time_scale_factor)\n        else:\n            tm = time\n            v = self.integral(w=w)\n\n        if log:\n            ax.semilogy(tm, v, **kwargs)\n        else:\n            ax.plot(tm, v, **kwargs)\n\n        ax.set_xlabel(fr'Time $t$ ({unit})')\n        ax.set_ylabel('{}'.format(self.getTeXIntegralName()))\n\n        if show:\n            plt.show(block=False)\n\n        return ax\n\n\n    def dumps(self, r=None, t=None):\n        return self.get(r=r, t=t).__str__()\n\n\n    def print(self, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        print(self.dumps(r,t))\n\n\n    def integral(self, t=None, w=1.0):\n        \"\"\"\n        Evaluate the volume integral of this fluid quantity in the given time\n        step using a trapezoidal rule.\n\n        :param t: Time step to integrate over. If ``None``, integrates over radius in every time step. May be a slice.\n        :param w: Weighting function.\n        \"\"\"\n        if t is None:\n            return self.grid.integrate(self.data[:], w)\n        else:\n            return self.grid.integrate(self.data[t,:], w)\n\n\n    def _getTimeUnitFactor(self, unit):\n        \"\"\"\n        Converts a time unit given as a string to a numeric factor\n        for converting the 'grid.time' vector to the specified units\n        (i.e. from seconds).\n        \"\"\"\n        if unit == 's': return 1\n        elif unit == 'ms': return 1e3\n        elif unit == '\u00b5s': return 1e6\n        elif unit == 'ns': return 1e9\n        else:\n            raise ValueError(f\"Unrecognized time unit: '{unit}'.\")",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(FluidQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        # Cell or flux grid?\n        if data.shape[1] == self.grid.r.size:\n            self.radius = self.grid.r\n        elif data.shape[1] == self.grid.r.size+1:\n            self.radius = self.grid.r_f\n        else:\n            raise Exception(\"Unrecognized shape of data for '{}': {}. Expected (nt, nr) = ({}, {}).\".format(name, data.shape, grid.t.size, grid.r.size))\n\n        self.time = self.grid.t",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__() + \"\\n\"\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \":: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n        s += self.dumps()\n        return s",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Fluid quantity of size NT x NR = {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1])",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def animate(self, keep=[], ax=None, repeat=False, repeat_delay=None, speed=None, blit=True, save=None, dpi=None, **kwargs):\n        \"\"\"\n        Creates an animation of the time evolution of this\n        fluid quantity.\n\n        :param list keep:   List of time indices to keep after plotting.\n        :param bool repeat: If ``True``, repeats the animation.\n        \"\"\"\n        show = ax is None\n\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        def update_ani(num, fq, ax, line, lbl, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(fq.time[num]*tfac, tunit))\n            line.set_data(fq.radius, self.data[num,:])\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n                keeplines[idx].set_data(fq.radius, self.data[num,:])\n\n            return (line, lbl) + tuple(keeplines)\n\n        # Automatically determine the plotting interval\n        if speed is None:\n            speed = 50\n        \n        line, = ax.plot(self.radius, self.data[0,:], 'k', linewidth=2, **kwargs)\n\n        # Create placeholders for the 'keep' lines\n        keeplines = []\n        if keep is not None:\n            for i in range(len(keep)):\n                l, = ax.plot([], [], linewidth=2, **kwargs)\n                keeplines.append(l)\n\n        xmin, xmax = 0, self.radius[-1]\n        ax.set_xlim([xmin, xmax])\n\n        # Set y limits\n        data = self.data[:]     # Make sure to load data only once\n        ymin, ymax = 1.1*np.amin(data), 1.1*np.amax(data)\n        if ymin >= 0:\n            ymin, ymax = 0, 1.1*np.amax(data)\n\n        ax.set_ylim([ymin, ymax])\n        \n        # Determine relevant time scale\n        tmax = self.time[-1]\n        idx  = 0\n        tfac = 1\n        tunits = ['s', 'ms', '\u00b5s', 'ns', 'ps']\n        while tmax*tfac < 1 and idx < len(tunits)-1:\n            idx += 1\n            tfac = (1e3)**(idx)\n\n        xp, yp = 0.03, 0.93\n        txt = ax.text(xmin+xp*(xmax-xmin), ymin+yp*(ymax-ymin), r't = {:.3f} {}'.format(self.time[0]*tfac, tunits[idx]), usetex=False)\n\n        ax.set_xlabel(r'$r/a$ (m)')\n\n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=self.time.size,\n            interval=speed, repeat_delay=repeat_delay, repeat=repeat, blit=blit,\n            fargs=(self, ax, line, txt, keeplines, tfac, tunits[idx], keep))\n\n        # Save animation?\n        if save:\n            writer = animation.FFMpegFileWriter(fps=1000/speed)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\n        if show:\n            plt.show()",
  "def get(self, r=None, t=None):\n        \"\"\"\n        Returns the data in the specified time or radial point. If neither ``r``\n        nor ``t`` are given, returns the full spatiotemporal evolution of the\n        profile.\n        \"\"\"\n        if (r is None) and (t is None):\n            return self.data[:]\n        elif (r is not None) and (t is None):\n            return self.data[:,r]\n        elif (r is None) and (t is not None):\n            return self.data[t,:]\n        else:\n            return self.data[t,r]",
  "def plot(self, ax=None, show=None, r=None, t=None, log=False, colorbar=True, VpVol=False, weight=None, unit='s', **kwargs):\n        \"\"\"\n        Generate a contour plot of the spatiotemporal evolution of this\n        quantity.\n\n        :param ax:       Matplotlib axes object to use for plotting.\n        :param show:     If 'True', shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param log:      If ``True``, plot on a logarithmic scale.\n        :param colorbar: If ``True``, and a 2D plot is requested, also draw a colorbar.\n        :param VpVol:    Weight quantity with ``grid.VpVol`` when plotting.\n        :param weight:   Optional quantity to weight this quantity with when plotting.\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # If the data is 1D, make sure it is plotted\n        # as such (and not as a contour plot)\n        if self.data.shape[0] == 1:\n            t = 0\n        elif self.data.shape[1] == 1:\n            r = 0\n        \n        if (r is None) and (t is None):\n            data = self.data[:]\n            if VpVol:\n                data *= self.grid.VpVol[:]\n            if weight is not None:\n                data *= weight\n\n            if log:\n                data = np.log10(np.abs(data))\n\n            time = self.time * self._getTimeUnitFactor(unit)\n\n            cp = ax.contourf(self.radius, time, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'Radius $r$ (m)')\n            ax.set_ylabel(fr'Time $t$ ({unit})')\n\n            cb = None\n            if colorbar:\n                cb = plt.colorbar(mappable=cp, ax=ax)\n\n            if show:\n                plt.show(block=False)\n\n            return ax, cb\n        elif (r is not None) and (t is None):\n            return self.plotTimeProfile(r=r, ax=ax, show=show, VpVol=VpVol, weight=weight, log=log, **kwargs)\n        elif (r is None) and (t is not None):\n            return self.plotRadialProfile(t=t, ax=ax, show=show, VpVol=VpVol, weight=weight, log=log, **kwargs)\n        else:\n            raise OutputException(\"Cannot plot a scalar value. r = {}, t = {}.\".format(r, t))",
  "def plotPoloidal(self, ax=None, show=None, t=-1, colorbar=True, displayGrid=False, maxMinScale=True, logscale=False, **kwargs):\n        \"\"\"\n        Plot the radial profile of this quantity revolved over a \n        poloidal cross section at the specified time step. \n        NOTE: Currently assumes a cylindrical flux surface geometry!\n        \n        :param matplotlib.pyplot.Axis ax:   Matplotlib axes object to use for plotting.\n        :param bool show: If 'True', shows the plot immediately via a call to 'matplotlib.pyplot.show()' with 'block=False'. If 'None', this is interpreted as 'True' if 'ax' is also 'None'.\n        :param int t: Time index to plot.\n        :param matplotlib.pyplot.Colorbar colorbar: Specify wether or not to include a colorbar.\n        :param bool displayGrid: Specify wether or not to display a polar grid in the plot.\n        :param bool maxMinScale: If 'True', set tha max and min of the color scale to the maximum and minimum values of the data stored by this object over all time steps.\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        \n        genax = ax is None\n\n        if genax:\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([self.grid.r[0],self.grid.r[-1]])\n            ax.set_title('t = '+str(self.grid.t[t]))\n\n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n\n            if show is None:\n                show = True\n                \n        theta=np.linspace(0,2*np.pi)\n        if logscale:\n        \tdata_mat=np.log10(self.data[t,:])*np.ones((len(theta),len(self.grid.r)))\n        else:\n        \tdata_mat=self.data[t,:]*np.ones((len(theta),len(self.grid.r)))\n        \t\n        if maxMinScale:\n            if logscale:\n                cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',levels=np.linspace(np.min(np.log10(self.data)),np.max(np.log10(self.data))), **kwargs)\n            else:\n                cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',levels=np.linspace(np.min(self.data),np.max(self.data)), **kwargs)\n        else:\n            cp = ax.contourf(theta,self.grid.r, data_mat.T, cmap='GeriMap',**kwargs)\n\t\t\t\n        cb = None\n        if colorbar:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n            if logscale:\n                cb.ax.set_ylabel('$\\log _{10}($'+'{}'.format(self.getTeXName()+')'))\n            else:\n                cb.ax.set_ylabel('{}'.format(self.getTeXName()))\n            \n        if show:\n            plt.show(block=False)\n            \n        return ax, cb",
  "def animatePoloidal(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None,**kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the present quantity, \n        including the specified time steps.\n        \n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param float dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        \"\"\"\n        \n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPoloidal(show=False,t=0,**kwargs)\n        \n        def update_ani(t, fq, ax):\n            ax.clear()\n            ax=fq.plotPoloidal(colorbar=False, show=False,t=t,**kwargs)\n        \n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n        \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()",
  "def plotRadialProfile(self, t=-1, ax=None, show=None, VpVol=False, weight=None, log=False, **kwargs):\n        \"\"\"\n        Plot the radial profile of this quantity at the specified time slice.\n\n        :param t:      Time index to plot.\n        :param ax:     Matplotlib axes object to use for plotting.\n        :param show:   If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param VpVol:  If ``True``, weight the radial profile with the spatial jacobian V'.\n        :param weight: Optional quantity to weight this quantity with when plotting.\n        :param log:    If ``True``, plot on a logarithmic scale.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if np.isscalar(t):\n            t = [t]\n\n        lbls = []\n        vpv = self.grid.VpVol[:]\n        for it in t:\n            data = self.data[it,:]\n            wlbl = ''\n            if VpVol:\n                data *= vpv\n                wlbl += \"*V'\"\n            if weight is not None:\n                data *= weight\n                wlbl += '*w'\n\n\n            if log:\n                if np.any(data>0):\n                    ax.semilogy(self.radius, data, **kwargs)\n                else:\n                    ax.semilogy(self.radius, -data, '--', **kwargs)\n            else:\n                ax.plot(self.radius, data, **kwargs)\n\n            # Add legend label\n            tval, unit = self.grid.getTimeAndUnit(it)\n            lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}$'.format(tval, unit))\n\n        ax.set_xlabel(r'Radius $r$ (m)')\n        ax.set_ylabel('{}{}'.format(self.getTeXName(), wlbl))\n\n        if len(lbls) > 0:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def plotTimeProfile(self, r=0, ax=None, show=None, VpVol=False, weight=None, log=False, **kwargs):\n        \"\"\"\n        Plot the temporal profile of this quantity at the specified radius.\n\n        :param r:      Radial index to plot evolution for.\n        :param ax:     Matplotlib axes object to use for plotting.\n        :param show:   If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n        :param VpVol:  If ``True``, weight the radial profile with the spatial jacobian V'.\n        :param weight: Optional quantity to weight this quantity with when plotting.\n        :param log:    If ``True``, plot on a logarithmic scale.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if np.isscalar(r):\n            r = [r]\n\n        lbls = []\n        for ir in r:\n            data = self.data[:,ir]\n            wlbl = ''\n            if VpVol:\n                data *= self.grid.VpVol[ir]\n                wlbl += \"*V'\"\n            if weight is not None:\n                data *= weight\n                wlbl += '*w'\n\n            if log:\n                if np.any(data>0):\n                    ax.semilogy(self.time, data, **kwargs)\n                else:\n                    ax.semilogy(self.time, -data, '--', **kwargs)\n            else:\n                ax.plot(self.time, data, **kwargs)\n\n            # Add legend label\n            lbls.append(r'$r = {:.3f}\\,\\mathrm{{m}}$'.format(self.radius[ir]))\n\n        ax.set_xlabel(r'Time $t$')\n        ax.set_ylabel('{}{}'.format(self.getTeXName(), wlbl))\n\n        if len(lbls) > 1:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def plotIntegral(self, ax=None, show=None, unit='s', time_shift = 0, time_scale_factor = 1.0, w=1.0, time_derivative = False, log=False, **kwargs):\n        \"\"\"\n        Plot the time evolution of the radial integral of this quantity.\n\n        :param ax:   Matplotlib axes object to use for plotting.\n        :param show: If ``True``, shows the plot immediately via a call to ``matplotlib.pyplot.show()`` with ``block=False``. If ``None``, this is interpreted as ``True`` if ``ax`` is also ``None``.\n\n        :return: a matplotlib axis object.\n        \"\"\"\n        if ax is None:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        time = self.time * self._getTimeUnitFactor(unit)\n        time = time + time_shift\n        time = time*time_scale_factor\n\n        if time_derivative:\n            integrated_data = self.integral(w=w)\n            tm = time[1:-1]\n            v = (integrated_data[2:]-integrated_data[:-2])/((time[2:]-time[:-2])/time_scale_factor)\n        else:\n            tm = time\n            v = self.integral(w=w)\n\n        if log:\n            ax.semilogy(tm, v, **kwargs)\n        else:\n            ax.plot(tm, v, **kwargs)\n\n        ax.set_xlabel(fr'Time $t$ ({unit})')\n        ax.set_ylabel('{}'.format(self.getTeXIntegralName()))\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def dumps(self, r=None, t=None):\n        return self.get(r=r, t=t).__str__()",
  "def print(self, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        print(self.dumps(r,t))",
  "def integral(self, t=None, w=1.0):\n        \"\"\"\n        Evaluate the volume integral of this fluid quantity in the given time\n        step using a trapezoidal rule.\n\n        :param t: Time step to integrate over. If ``None``, integrates over radius in every time step. May be a slice.\n        :param w: Weighting function.\n        \"\"\"\n        if t is None:\n            return self.grid.integrate(self.data[:], w)\n        else:\n            return self.grid.integrate(self.data[t,:], w)",
  "def _getTimeUnitFactor(self, unit):\n        \"\"\"\n        Converts a time unit given as a string to a numeric factor\n        for converting the 'grid.time' vector to the specified units\n        (i.e. from seconds).\n        \"\"\"\n        if unit == 's': return 1\n        elif unit == 'ms': return 1e3\n        elif unit == '\u00b5s': return 1e6\n        elif unit == 'ns': return 1e9\n        else:\n            raise ValueError(f\"Unrecognized time unit: '{unit}'.\")",
  "def update_ani(num, fq, ax, line, lbl, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(fq.time[num]*tfac, tunit))\n            line.set_data(fq.radius, self.data[num,:])\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n                keeplines[idx].set_data(fq.radius, self.data[num,:])\n\n            return (line, lbl) + tuple(keeplines)",
  "def update_ani(t, fq, ax):\n            ax.clear()\n            ax=fq.plotPoloidal(colorbar=False, show=False,t=t,**kwargs)",
  "class IonSpeciesFluidQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, attr, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.attr = attr\n        self.ions = output.ionmeta\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__()\n\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \"\\n:: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n\n        return s\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        if self.data.ndim == 3:\n            nt, ni, nr = self.data.shape\n        else:\n            ni, nt, nr = 1, *self.data.shape\n        s = '({}) Ion species fluid quantity of size NI x NT x NR = {} x {} x {}\\n'.format(self.name, ni, nt, nr)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s\n\n\n    def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        if self.data.ndim == 3:\n            data = self.data[:,idx,:]\n        else:\n            data = self.data[:]\n\n        return FluidQuantity(name='{}_{}'.format(self.name, name), data=data, grid=self.grid, output=self.output, attr=self.attr)\n\n    \n    def dumps(self, ion=None, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        return self.get(ion=ion, r=r, t=t).__str__()\n\n\n    def get(self, ion=None, r=None, t=None):\n        \"\"\"\n        Returns data for the specified ion, or in the specified time\n        interval or radial point. If none of the indices are given, returns\n        the full evolution of the quantity.\n        \"\"\"\n        sion = ion if ion is not None else slice(None)\n        sr = r if r is not None else slice(None)\n        st = t if t is not None else slice(None)\n\n        if self.data.ndim == 3:\n            return self.data[st,sion,sr]\n        else:\n            return self.data[st,sr]\n\n\n    def plot(self, ion=None, ax=None, show=None, r=None, t=None, *args, **kwargs):\n        \"\"\"\n        Plot data for all members of this IonSpeciesFluidQuantity in the\n        same figure.\n        \"\"\"\n        # Prevent trying to plot multiple 2D plots in the same window...\n        if ion is None:\n            if (r is None and self.grid.r.size != 1) and (t is None):\n                raise Exception('Cannot plot ion temperature for all ions simultaneously when nr > 1.')\n\n        if ion is not None:\n            q = self[ion]\n            ax = q.plot(ax=ax, show=show, r=r, t=t, *args, **kwargs)\n        else:\n            for i in self.ions.names:\n                q = self[i]\n\n                ax = q.plot(ax=ax, show=show, r=r, t=t, label=i, *args, **kwargs)\n\n            plt.legend()\n\n        return ax",
  "def __init__(self, name, data, attr, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.attr = attr\n        self.ions = output.ionmeta",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__()\n\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \"\\n:: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n\n        return s",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        if self.data.ndim == 3:\n            nt, ni, nr = self.data.shape\n        else:\n            ni, nt, nr = 1, *self.data.shape\n        s = '({}) Ion species fluid quantity of size NI x NT x NR = {} x {} x {}\\n'.format(self.name, ni, nt, nr)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s",
  "def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        if self.data.ndim == 3:\n            data = self.data[:,idx,:]\n        else:\n            data = self.data[:]\n\n        return FluidQuantity(name='{}_{}'.format(self.name, name), data=data, grid=self.grid, output=self.output, attr=self.attr)",
  "def dumps(self, ion=None, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        return self.get(ion=ion, r=r, t=t).__str__()",
  "def get(self, ion=None, r=None, t=None):\n        \"\"\"\n        Returns data for the specified ion, or in the specified time\n        interval or radial point. If none of the indices are given, returns\n        the full evolution of the quantity.\n        \"\"\"\n        sion = ion if ion is not None else slice(None)\n        sr = r if r is not None else slice(None)\n        st = t if t is not None else slice(None)\n\n        if self.data.ndim == 3:\n            return self.data[st,sion,sr]\n        else:\n            return self.data[st,sr]",
  "def plot(self, ion=None, ax=None, show=None, r=None, t=None, *args, **kwargs):\n        \"\"\"\n        Plot data for all members of this IonSpeciesFluidQuantity in the\n        same figure.\n        \"\"\"\n        # Prevent trying to plot multiple 2D plots in the same window...\n        if ion is None:\n            if (r is None and self.grid.r.size != 1) and (t is None):\n                raise Exception('Cannot plot ion temperature for all ions simultaneously when nr > 1.')\n\n        if ion is not None:\n            q = self[ion]\n            ax = q.plot(ax=ax, show=show, r=r, t=t, *args, **kwargs)\n        else:\n            for i in self.ions.names:\n                q = self[i]\n\n                ax = q.plot(ax=ax, show=show, r=r, t=t, label=i, *args, **kwargs)\n\n            plt.legend()\n\n        return ax",
  "class PlasmaCurrent(ScalarQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        :param str name:           Name of quantity.\n        :param numpy.ndarray data: Data for quantity.\n        :param list attr:          List of attributes for quantity.\n        :param grid:               Grid on which the quantity is defined.\n        :param DREAMOutput output: Parent output object.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n\n    def plotCurrents(self, ax=None, show=None, t=None):\n        \"\"\"\n        Plot the runaway, hot, and ohmic currents, alongside the plasma\n        current in the same plot.\n        \"\"\"\n        Ire  = self.output.eqsys.j_re.current()\n        Ihot = self.output.eqsys.j_hot.current()\n        Iohm = self.output.eqsys.j_ohm.current()\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if t is None:\n            t = slice(None)\n\n        ax.plot(self.time[t], self.data[t], 'k', label=r'$I_{\\rm p}$')\n        ax.plot(self.time[t], Ire[t], 'r--', label=r'$I_{\\rm re}$')\n        ax.plot(self.time[t], Iohm[t], 'b--', label=r'$I_{\\Omega}$')\n        ax.plot(self.time[t], Ihot[t], 'y--', label=r'$I_{\\rm hot}$')\n\n        ax.set_xlabel(r'Time $t$ (s)')\n        ax.set_ylabel(r'Plasma current')\n\n        ax.set_xlim([min(self.time[t]), max(self.time[t])])\n\n        Imax = max(np.amax(abs(self.data[t])), np.amax(abs(Ire)), np.amax(abs(Ihot)), np.amax(abs(Iohm)))\n        if np.any(self.data[t]<0) or np.any(Ire<0) or np.any(Ihot<0) or np.any(Iohm<0):\n            ax.set_ylim([-1.1*Imax, 1.1*Imax])\n        else:\n            ax.set_ylim([0, 1.1*Imax])\n        \n        ax.legend(frameon=False)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        :param str name:           Name of quantity.\n        :param numpy.ndarray data: Data for quantity.\n        :param list attr:          List of attributes for quantity.\n        :param grid:               Grid on which the quantity is defined.\n        :param DREAMOutput output: Parent output object.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)",
  "def plotCurrents(self, ax=None, show=None, t=None):\n        \"\"\"\n        Plot the runaway, hot, and ohmic currents, alongside the plasma\n        current in the same plot.\n        \"\"\"\n        Ire  = self.output.eqsys.j_re.current()\n        Ihot = self.output.eqsys.j_hot.current()\n        Iohm = self.output.eqsys.j_ohm.current()\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if t is None:\n            t = slice(None)\n\n        ax.plot(self.time[t], self.data[t], 'k', label=r'$I_{\\rm p}$')\n        ax.plot(self.time[t], Ire[t], 'r--', label=r'$I_{\\rm re}$')\n        ax.plot(self.time[t], Iohm[t], 'b--', label=r'$I_{\\Omega}$')\n        ax.plot(self.time[t], Ihot[t], 'y--', label=r'$I_{\\rm hot}$')\n\n        ax.set_xlabel(r'Time $t$ (s)')\n        ax.set_ylabel(r'Plasma current')\n\n        ax.set_xlim([min(self.time[t]), max(self.time[t])])\n\n        Imax = max(np.amax(abs(self.data[t])), np.amax(abs(Ire)), np.amax(abs(Ihot)), np.amax(abs(Iohm)))\n        if np.any(self.data[t]<0) or np.any(Ire<0) or np.any(Ihot<0) or np.any(Iohm<0):\n            ax.set_ylim([-1.1*Imax, 1.1*Imax])\n        else:\n            ax.set_ylim([0, 1.1*Imax])\n        \n        ax.legend(frameon=False)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class IonSpeciesScalarQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, attr, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.attr = attr\n        self.ions = output.ionmeta\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__()\n\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \"\\n:: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n\n        return s\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        if self.data.ndim == 2:\n            nt, ni = self.data.shape\n        else:\n            ni, nt = 1, self.data.shape[0]\n        s = '({}) Ion species scalar quantity of size NT x NI = {} x {}\\n'.format(self.name, nt, ni)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s\n\n\n    def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        if self.data.ndim == 2:\n            data = self.data[:,idx]\n        else:\n            data = self.data[:]\n\n        return ScalarQuantity(name='{}_{}'.format(self.name, name), data=data, grid=self.grid, output=self.output, attr=self.attr)\n\n    \n    def dumps(self, ion=None, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        return self.get(ion=ion, r=r, t=t).__str__()\n\n\n    def get(self, ion=None, t=None):\n        \"\"\"\n        Returns data for the specified ion, or in the specified time\n        interval or point. If none of the indices are given, returns\n        the full evolution of the quantity.\n        \"\"\"\n        sion = ion if ion is not None else slice(None)\n        st = t if t is not None else slice(None)\n\n        return self.data[st,sion]",
  "def __init__(self, name, data, attr, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.attr = attr\n        self.ions = output.ionmeta",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__()\n\n        if hasattr(self, 'description') and hasattr(self, 'description_eqn'):\n            s += \"\\n:: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n\n        return s",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        if self.data.ndim == 2:\n            nt, ni = self.data.shape\n        else:\n            ni, nt = 1, self.data.shape[0]\n        s = '({}) Ion species scalar quantity of size NT x NI = {} x {}\\n'.format(self.name, nt, ni)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s",
  "def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        if self.data.ndim == 2:\n            data = self.data[:,idx]\n        else:\n            data = self.data[:]\n\n        return ScalarQuantity(name='{}_{}'.format(self.name, name), data=data, grid=self.grid, output=self.output, attr=self.attr)",
  "def dumps(self, ion=None, r=None, t=None):\n        \"\"\"\n        Print the data in this quantity.\n        \"\"\"\n        return self.get(ion=ion, r=r, t=t).__str__()",
  "def get(self, ion=None, t=None):\n        \"\"\"\n        Returns data for the specified ion, or in the specified time\n        interval or point. If none of the indices are given, returns\n        the full evolution of the quantity.\n        \"\"\"\n        sion = ion if ion is not None else slice(None)\n        st = t if t is not None else slice(None)\n\n        return self.data[st,sion]",
  "class Temperature(FluidQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, grid=grid, output=output, attr=attr)\n\n\n    def plotEnergyBalance(self, r=None, t=None, ax=None, show=True, log=False):\n        \"\"\"\n        Plot all the terms appearing in the energy balance equation.\n        \"\"\"\n        integrate = False\n        if t is None and r is None:\n            integrate = True\n\n        labels = []\n        for o in self.output.other.fluid.keys():\n            if not o.startswith('Tcold_'):\n                continue\n\n            q = self.output.other.fluid[o]\n\n            if integrate:\n                ax = q.plotIntegral(ax=ax, show=show)\n            else:\n                ax = q.plot(r=r, t=t, ax=ax, show=False, log=log)\n\n            labels.append(o[6:].replace(r'_', r'\\_'))\n\n        plt.legend(labels)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, grid=grid, output=output, attr=attr)",
  "def plotEnergyBalance(self, r=None, t=None, ax=None, show=True, log=False):\n        \"\"\"\n        Plot all the terms appearing in the energy balance equation.\n        \"\"\"\n        integrate = False\n        if t is None and r is None:\n            integrate = True\n\n        labels = []\n        for o in self.output.other.fluid.keys():\n            if not o.startswith('Tcold_'):\n                continue\n\n            q = self.output.other.fluid[o]\n\n            if integrate:\n                ax = q.plotIntegral(ax=ax, show=show)\n            else:\n                ax = q.plot(r=r, t=t, ax=ax, show=False, log=log)\n\n            labels.append(o[6:].replace(r'_', r'\\_'))\n\n        plt.legend(labels)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class IonMetaData:\n    \n\n    def __init__(self, data):\n        \"\"\"\n        Constructor.\n\n        data: Dictionary containing atomic charge 'Z' and ion names 'names'\n              (either as a Python list or DREAM monolithic string list)\n        \"\"\"\n\n        self.Z = [int(Z) for Z in data['Z'][:]]\n        self.names = data['names'][:]\n\n        # DREAM monolithic string list? (i.e. a series of strings\n        # glued together with ';' in between)\n        if ';' in self.names:\n            self.names = self.names.split(';')[:-1]\n\n\n    def __getitem__(self, i):\n        \"\"\"\n        IF i IS AN INTEGER\n          Returns a tuple consisting of the ion name and\n          charge for the specified ion.\n\n        IF i IS A STRING\n          Returns the ion charge for the named ion.\n        \"\"\"\n        if type(i) == str:\n            return self.Z[i]\n        else:\n            return (self.names[i], self.Z[i])\n\n\n    def getName(self, i):\n        \"\"\"\n        Get the name of the ion with the specified index.\n        \"\"\"\n        return self.names[i]\n\n\n    def getNames(self):\n        \"\"\"\n        Get a list of all ion names.\n        \"\"\"\n        return self.names\n\n\n    def getIndex(self, name):\n        \"\"\"\n        Returns the index corresponding to the named ion species.\n        \"\"\"\n        for i in range(len(self.names)):\n            if self.names[i] == name:\n                return i\n\n        raise KeyError(\"No ion species named '{}' found in output.\".format(name))\n\n\n    def getIonOffset(self, name, Z0=0):\n        \"\"\"\n        Returns the array index of the named ion species (and charge state)\n        which can be used to index a vector with all ion species located one\n        after another.\n        \"\"\"\n        idx = 0\n        for i in range(len(self.names)):\n            if self.names[i] == name:\n                return idx + Z0\n\n            idx += self.Z[i]+1\n\n        raise KeyError(f\"No ion named {name} found in the output.\")\n\n\n    def getCharge(self, i):\n        \"\"\"\n        Get the ion charge for the ion with the specified index.\n        \"\"\"\n        return self.Z[i]\n\n\n    def getCharges(self):\n        \"\"\"\n        Get a list of all ion charges.\n        \"\"\"\n        return self.Z",
  "def __init__(self, data):\n        \"\"\"\n        Constructor.\n\n        data: Dictionary containing atomic charge 'Z' and ion names 'names'\n              (either as a Python list or DREAM monolithic string list)\n        \"\"\"\n\n        self.Z = [int(Z) for Z in data['Z'][:]]\n        self.names = data['names'][:]\n\n        # DREAM monolithic string list? (i.e. a series of strings\n        # glued together with ';' in between)\n        if ';' in self.names:\n            self.names = self.names.split(';')[:-1]",
  "def __getitem__(self, i):\n        \"\"\"\n        IF i IS AN INTEGER\n          Returns a tuple consisting of the ion name and\n          charge for the specified ion.\n\n        IF i IS A STRING\n          Returns the ion charge for the named ion.\n        \"\"\"\n        if type(i) == str:\n            return self.Z[i]\n        else:\n            return (self.names[i], self.Z[i])",
  "def getName(self, i):\n        \"\"\"\n        Get the name of the ion with the specified index.\n        \"\"\"\n        return self.names[i]",
  "def getNames(self):\n        \"\"\"\n        Get a list of all ion names.\n        \"\"\"\n        return self.names",
  "def getIndex(self, name):\n        \"\"\"\n        Returns the index corresponding to the named ion species.\n        \"\"\"\n        for i in range(len(self.names)):\n            if self.names[i] == name:\n                return i\n\n        raise KeyError(\"No ion species named '{}' found in output.\".format(name))",
  "def getIonOffset(self, name, Z0=0):\n        \"\"\"\n        Returns the array index of the named ion species (and charge state)\n        which can be used to index a vector with all ion species located one\n        after another.\n        \"\"\"\n        idx = 0\n        for i in range(len(self.names)):\n            if self.names[i] == name:\n                return idx + Z0\n\n            idx += self.Z[i]+1\n\n        raise KeyError(f\"No ion named {name} found in the output.\")",
  "def getCharge(self, i):\n        \"\"\"\n        Get the ion charge for the ion with the specified index.\n        \"\"\"\n        return self.Z[i]",
  "def getCharges(self):\n        \"\"\"\n        Get a list of all ion charges.\n        \"\"\"\n        return self.Z",
  "class OtherQuantities:\n    \n\n    SPECIAL_TREATMENT = {\n        # List of other quantities with their own classes\n        'f_hot_ripple_pmn': OtherQuantity,\n        'f_re_ripple_pmn': OtherQuantity,\n        'GammaAva': AvalancheGrowthRate,\n        'nu_D_f1': OtherKineticQuantity,\n        'nu_D_f2': OtherKineticQuantity,\n        'nu_s_f1': OtherKineticQuantity,\n        'nu_s_f2': OtherKineticQuantity,\n    }\n\n\n    def __init__(self, name, other=None, grid=None, output=None, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.name = name\n        self.grid = grid\n        self.quantities = {}\n        self.output = output\n        self.momentumgrid = momentumgrid\n        \n        if other is not None:\n            self.setQuantities(other)\n\n\n    def __contains__(self, index):\n        return (index in self.quantities)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the list of quantities.\n        \"\"\"\n        return self.quantities[index]\n\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over other quantities.\n        \"\"\"\n        for key, item in self.quantities.items():\n            yield key, item\n\n\n    def __repr__(self):\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return self.tostring()\n\n\n    def keys(self): return self.quantities.keys()\n\n\n    def getQuantityNames(self):\n        \"\"\"\n        Get a list with the names of all other quantities\n        stored in the output file.\n        \"\"\"\n        return list(self.quantities.keys())\n\n\n    def setGrid(self, grid):\n        \"\"\"\n        Sets the grid that was used for the DREAM simulation.\n        \"\"\"\n        self.grid = grid\n\n\n    def setQuantity(self, name, data, attributes=None, datatype=None):\n        \"\"\"\n        Add the given quantity to the list of other quantities.\n\n        name: Name of the quantity.\n        data: Data of the quantity (raw, as a dict from the output file).\n        \"\"\"\n        desc = \"\"\n        if 'description' in attributes:\n            desc = attributes['description']\n\n        if datatype is not None:\n            if data.ndim == 4 and self.momentumgrid is not None:\n                o = datatype(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            else:\n                o = datatype(name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n        elif name in self.SPECIAL_TREATMENT:\n            if data.ndim == 4 and self.momentumgrid is not None:\n                o = self.SPECIAL_TREATMENT[name](name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n            else:\n                o = self.SPECIAL_TREATMENT[name](name=name, data=data, description=desc, grid=self.grid, output=self.output)\n        else:\n            if self.name == 'scalar':\n                o = OtherScalarQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            elif data.ndim == 2:\n                o = OtherFluidQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            elif data.ndim == 4 and self.momentumgrid is not None:\n                o = OtherKineticQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n            else:\n                #raise Exception(\"Unrecognized number of dimensions of other quantity '{}': {}.\".format(name, data.ndim))\n                o = OtherQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n\n        setattr(self, name, o)\n        self.quantities[name] = o\n\n\n    def setQuantities(self, quantities):\n        \"\"\"\n        Add a list of other quantities to this handler.\n        \"\"\"\n        for oqn in quantities:\n            # Skip attribute containers\n            if oqn[-2:] == '@@': continue\n\n            # Is there an attribute container for this quantity?\n            if oqn+'@@' in quantities:\n                self.setQuantity(name=oqn, data=quantities[oqn], attributes=quantities[oqn+'@@'])\n            else:\n                self.setQuantity(name=oqn, data=quantities[oqn])\n\n\n    def resetQuantity(self, quantity, datatype):\n        \"\"\"\n        Reinitializes the named other quantity, making it of the given\n        data type.\n        \"\"\"\n        if quantity not in self.quantities:\n            return\n\n        attr = {}\n        q = self.quantities[quantity]\n        if hasattr(q, 'description'):\n            attr['description'] = q.description\n\n        self.setQuantity(name=quantity, data=q.data, attributes=attr, datatype=datatype)\n\n\n    def tostring(self, padding=''):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"\"\n        for oqn in self.quantities:\n            q = self.quantities[oqn]\n\n            s += \"{}{:28s} -- {}\\n\".format(padding, q.name, q.description)\n        \n        return s",
  "def __init__(self, name, other=None, grid=None, output=None, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.name = name\n        self.grid = grid\n        self.quantities = {}\n        self.output = output\n        self.momentumgrid = momentumgrid\n        \n        if other is not None:\n            self.setQuantities(other)",
  "def __contains__(self, index):\n        return (index in self.quantities)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the list of quantities.\n        \"\"\"\n        return self.quantities[index]",
  "def __iter__(self):\n        \"\"\"\n        Iterate over other quantities.\n        \"\"\"\n        for key, item in self.quantities.items():\n            yield key, item",
  "def __repr__(self):\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return self.tostring()",
  "def keys(self): return self.quantities.keys()",
  "def getQuantityNames(self):\n        \"\"\"\n        Get a list with the names of all other quantities\n        stored in the output file.\n        \"\"\"\n        return list(self.quantities.keys())",
  "def setGrid(self, grid):\n        \"\"\"\n        Sets the grid that was used for the DREAM simulation.\n        \"\"\"\n        self.grid = grid",
  "def setQuantity(self, name, data, attributes=None, datatype=None):\n        \"\"\"\n        Add the given quantity to the list of other quantities.\n\n        name: Name of the quantity.\n        data: Data of the quantity (raw, as a dict from the output file).\n        \"\"\"\n        desc = \"\"\n        if 'description' in attributes:\n            desc = attributes['description']\n\n        if datatype is not None:\n            if data.ndim == 4 and self.momentumgrid is not None:\n                o = datatype(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            else:\n                o = datatype(name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n        elif name in self.SPECIAL_TREATMENT:\n            if data.ndim == 4 and self.momentumgrid is not None:\n                o = self.SPECIAL_TREATMENT[name](name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n            else:\n                o = self.SPECIAL_TREATMENT[name](name=name, data=data, description=desc, grid=self.grid, output=self.output)\n        else:\n            if self.name == 'scalar':\n                o = OtherScalarQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            elif data.ndim == 2:\n                o = OtherFluidQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n            elif data.ndim == 4 and self.momentumgrid is not None:\n                o = OtherKineticQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid)\n            else:\n                #raise Exception(\"Unrecognized number of dimensions of other quantity '{}': {}.\".format(name, data.ndim))\n                o = OtherQuantity(name=name, data=data, description=desc, grid=self.grid, output=self.output)\n\n        setattr(self, name, o)\n        self.quantities[name] = o",
  "def setQuantities(self, quantities):\n        \"\"\"\n        Add a list of other quantities to this handler.\n        \"\"\"\n        for oqn in quantities:\n            # Skip attribute containers\n            if oqn[-2:] == '@@': continue\n\n            # Is there an attribute container for this quantity?\n            if oqn+'@@' in quantities:\n                self.setQuantity(name=oqn, data=quantities[oqn], attributes=quantities[oqn+'@@'])\n            else:\n                self.setQuantity(name=oqn, data=quantities[oqn])",
  "def resetQuantity(self, quantity, datatype):\n        \"\"\"\n        Reinitializes the named other quantity, making it of the given\n        data type.\n        \"\"\"\n        if quantity not in self.quantities:\n            return\n\n        attr = {}\n        q = self.quantities[quantity]\n        if hasattr(q, 'description'):\n            attr['description'] = q.description\n\n        self.setQuantity(name=quantity, data=q.data, attributes=attr, datatype=datatype)",
  "def tostring(self, padding=''):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"\"\n        for oqn in self.quantities:\n            q = self.quantities[oqn]\n\n            s += \"{}{:28s} -- {}\\n\".format(padding, q.name, q.description)\n        \n        return s",
  "class RunawayElectronDensity(FluidQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, grid=grid, output=output, attr=attr)\n\n\n    def plotRates(self, r=None, t=None, ax=None, show=True):\n        \"\"\"\n        Plot all runaway rates in the same figure.\n        \"\"\"\n        if t is None and r is None:\n            raise OutputException(\"When plotting all runaway rates, at least one of 'r' and 't' must be specified.\")\n\n        labels = []\n\n        if 'fluid' not in self.output.other:\n            raise OutputException(\"No 'other' fluid quantities saved in output. Cannot plot runaway rates.\")\n\n        # Plot total runaway rate\n        if 'runawayRate' in self.output.other.fluid:\n            ax = self.output.other.fluid.runawayRate.plot(r=r, t=t, ax=ax, show=False)\n            labels.append('Total')\n\n        # Plot avalanche\n        if 'GammaAva' in self.output.other.fluid:\n            ax = self.output.other.fluid.GammaAva.plotRunawayRate(r=r, t=t, ax=ax, show=False)\n            labels.append('Avalanche')\n\n        for o in self.output.other.fluid.keys():\n            if not o.startswith('gamma'):\n                continue\n\n            q = self.output.other.fluid[o]\n            \n            # Ignore if empty\n            if np.sum(np.abs(q[:])) == 0:\n                continue\n\n            ax = q.plot(r=r, t=t, ax=ax, show=False)\n            labels.append(o[5:].replace(r'_', r'\\_'))\n\n        plt.ylabel('Runaway rates')\n        plt.legend(labels)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, grid=grid, output=output, attr=attr)",
  "def plotRates(self, r=None, t=None, ax=None, show=True):\n        \"\"\"\n        Plot all runaway rates in the same figure.\n        \"\"\"\n        if t is None and r is None:\n            raise OutputException(\"When plotting all runaway rates, at least one of 'r' and 't' must be specified.\")\n\n        labels = []\n\n        if 'fluid' not in self.output.other:\n            raise OutputException(\"No 'other' fluid quantities saved in output. Cannot plot runaway rates.\")\n\n        # Plot total runaway rate\n        if 'runawayRate' in self.output.other.fluid:\n            ax = self.output.other.fluid.runawayRate.plot(r=r, t=t, ax=ax, show=False)\n            labels.append('Total')\n\n        # Plot avalanche\n        if 'GammaAva' in self.output.other.fluid:\n            ax = self.output.other.fluid.GammaAva.plotRunawayRate(r=r, t=t, ax=ax, show=False)\n            labels.append('Avalanche')\n\n        for o in self.output.other.fluid.keys():\n            if not o.startswith('gamma'):\n                continue\n\n            q = self.output.other.fluid[o]\n            \n            # Ignore if empty\n            if np.sum(np.abs(q[:])) == 0:\n                continue\n\n            ax = q.plot(r=r, t=t, ax=ax, show=False)\n            labels.append(o[5:].replace(r'_', r'\\_'))\n\n        plt.ylabel('Runaway rates')\n        plt.legend(labels)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class SolverNonLinear(Solver):\n    \n\n    def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(solverdata, output)\n\n        self.iterations = [int(x) for x in solverdata['iterations'][:]]\n        self.backupinverter = [x==1 for x in solverdata['backupinverter'][:]]\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object into a string.\n        \"\"\"\n        s = \"Non-linear solver statistics\\n\\n\"\n\n        s += \"Max. iterations: {}\\n\".format(max(self.iterations))\n        s += \"Avg. iterations: {}\\n\".format(sum(self.iterations)/len(self.iterations))\n        s += \"Min. iterations: {}\\n\\n\".format(min(self.iterations))\n        \n        bi = sum(self.backupinverter)\n        if bi == 0:\n            s += \"Backup inverter not used\\n\"\n        elif bi == 1:\n            s += \"Backup inverter used: 1 time\\n\"\n        else:\n            s += \"Backup inverter used: {} times\\n\".format(bi)\n\n        return s\n\n\n    def getBackupRanges(self):\n        \"\"\"\n        Return the time step ranges for which the backup solver was used.\n        This method returns an array of tuples, where each tuple denotes a\n        single range of time steps where the backup solver was used.\n        \"\"\"\n        r = np.linspace(1, self.output.grid.t.size, self.output.grid.t.size)[np.where(self.backupinverter)]\n        if not r:\n            return []\n\n        arr = []\n        start = r[0]\n        i = 1\n        while i < r.size:\n            # One step in between _without_ backup solver\n            if r[i] > r[i-1]+1:\n                arr.append((start, r[i-1]))\n                start = r[i]\n\n            i += 1\n\n        arr.append((start, r[-1]))\n\n        return arr\n\n    \n    def plot(self, time=True, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the solver statistics.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n            \n            if show is None:\n                show = True\n\n        if time:\n            t = self.output.grid.t[1:]\n            xlbl = r'Simulation time (s)'\n        else:\n            t = np.linspace(1, self.output.grid.t.size-1, self.output.grid.t.size-1)\n            xlbl = r'Time step'\n\n        ax.plot(t, self.iterations, linewidth=2, **kwargs)\n\n        ax.set_xlabel(xlbl)\n        ax.set_ylabel(r'Number of iterations')\n\n        ymax = max(self.iterations)*1.2\n        ax.set_ylim([0, ymax])\n\n        # Plot where backup solver is used\n        xr = self.getBackupRanges()\n        for rg in xr:\n            if time:\n                ts1 = 0.5*self.output.grid.t[int(rg[0])] + 0.5*self.output.grid.t[int(rg[0])-1]\n                ts2 = 0.5*self.output.grid.t[int(rg[1])]\n\n                if rg[1]+1 < self.output.grid.t.size:\n                    ts2 += 0.5*self.output.grid.t[int(rg[1])+1]\n                else:\n                    ts2 += 2*ts2 - 0.5*self.output.grid.t[int(rg[1])-1]\n            else:\n                ts1, ts2 = rg[0]-0.5, rg[1]+0.5\n\n            ax.fill_between([ts1, ts2], [0, 0], [ymax, ymax], color='r', alpha=0.3)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(solverdata, output)\n\n        self.iterations = [int(x) for x in solverdata['iterations'][:]]\n        self.backupinverter = [x==1 for x in solverdata['backupinverter'][:]]",
  "def __str__(self):\n        \"\"\"\n        Convert this object into a string.\n        \"\"\"\n        s = \"Non-linear solver statistics\\n\\n\"\n\n        s += \"Max. iterations: {}\\n\".format(max(self.iterations))\n        s += \"Avg. iterations: {}\\n\".format(sum(self.iterations)/len(self.iterations))\n        s += \"Min. iterations: {}\\n\\n\".format(min(self.iterations))\n        \n        bi = sum(self.backupinverter)\n        if bi == 0:\n            s += \"Backup inverter not used\\n\"\n        elif bi == 1:\n            s += \"Backup inverter used: 1 time\\n\"\n        else:\n            s += \"Backup inverter used: {} times\\n\".format(bi)\n\n        return s",
  "def getBackupRanges(self):\n        \"\"\"\n        Return the time step ranges for which the backup solver was used.\n        This method returns an array of tuples, where each tuple denotes a\n        single range of time steps where the backup solver was used.\n        \"\"\"\n        r = np.linspace(1, self.output.grid.t.size, self.output.grid.t.size)[np.where(self.backupinverter)]\n        if not r:\n            return []\n\n        arr = []\n        start = r[0]\n        i = 1\n        while i < r.size:\n            # One step in between _without_ backup solver\n            if r[i] > r[i-1]+1:\n                arr.append((start, r[i-1]))\n                start = r[i]\n\n            i += 1\n\n        arr.append((start, r[-1]))\n\n        return arr",
  "def plot(self, time=True, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the solver statistics.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n            \n            if show is None:\n                show = True\n\n        if time:\n            t = self.output.grid.t[1:]\n            xlbl = r'Simulation time (s)'\n        else:\n            t = np.linspace(1, self.output.grid.t.size-1, self.output.grid.t.size-1)\n            xlbl = r'Time step'\n\n        ax.plot(t, self.iterations, linewidth=2, **kwargs)\n\n        ax.set_xlabel(xlbl)\n        ax.set_ylabel(r'Number of iterations')\n\n        ymax = max(self.iterations)*1.2\n        ax.set_ylim([0, ymax])\n\n        # Plot where backup solver is used\n        xr = self.getBackupRanges()\n        for rg in xr:\n            if time:\n                ts1 = 0.5*self.output.grid.t[int(rg[0])] + 0.5*self.output.grid.t[int(rg[0])-1]\n                ts2 = 0.5*self.output.grid.t[int(rg[1])]\n\n                if rg[1]+1 < self.output.grid.t.size:\n                    ts2 += 0.5*self.output.grid.t[int(rg[1])+1]\n                else:\n                    ts2 += 2*ts2 - 0.5*self.output.grid.t[int(rg[1])-1]\n            else:\n                ts1, ts2 = rg[0]-0.5, rg[1]+0.5\n\n            ax.fill_between([ts1, ts2], [0, 0], [ymax, ymax], color='r', alpha=0.3)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class Solver:\n    \n\n    def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.solverdata = None\n        self.output = output\n\n\n\n    def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.__dict__)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the timing information.\n        \"\"\"\n        return self.__dict__[index]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()\n\n\n    def plot(self):\n        \"\"\"\n        Generic plotting routine\n        \"\"\"\n        print(\"Method 'plot()' not implemented for this solver.\")",
  "def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.solverdata = None\n        self.output = output",
  "def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.__dict__)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the timing information.\n        \"\"\"\n        return self.__dict__[index]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()",
  "def plot(self):\n        \"\"\"\n        Generic plotting routine\n        \"\"\"\n        print(\"Method 'plot()' not implemented for this solver.\")",
  "class SolverLinear(Solver):\n    \n\n    def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(solverdata, output)\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object into a string.\n        \"\"\"\n        return \"<Empty linear solver data>\"",
  "def __init__(self, solverdata=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(solverdata, output)",
  "def __str__(self):\n        \"\"\"\n        Convert this object into a string.\n        \"\"\"\n        return \"<Empty linear solver data>\"",
  "class OtherIonSpeciesFluidQuantity(IonSpeciesFluidQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]\n\n    \n    def __repr__(self):\n        return self.__str__()\n\n\n    def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        return OtherFluidQuantity(name='{}_{}'.format(self.name, name), data=self.data[:,idx,:], description=self.description, grid=self.grid, output=self.output)",
  "def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        return self.__str__()",
  "def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        return OtherFluidQuantity(name='{}_{}'.format(self.name, name), data=self.data[:,idx,:], description=self.description, grid=self.grid, output=self.output)",
  "def synchrotron(P, XI, wavelength, magneticField):\n    \"\"\"\n    Calculates the synchrotron power at the given wavelength\n    'wavelength' (which may be an array) on the given P/XI\n    grid, with magnetic field strength 'magneticField'.\n\n    P:             Momentum grid.\n    XI:            Pitch grid.\n    wavelength:    Wavelength(s) at which to evaluate the function.\n    magneticField: Magnetic field strength.\n    \"\"\"\n    c = 299792458\n    e = 1.60217662e-19\n    m = 9.10938356e-31\n    eps0 = 8.854187817e-12\n    B = magneticField\n\n    gmm = np.sqrt(1 + P**2)\n    gmmpar = np.divide(gmm, np.sqrt(1 + P**2 * (1 - XI**2)))\n\n    lBLookUp, intLookUp = GetLookupTable()\n\n    lowerBound = 4*np.pi/3 * c*m*np.divide(gmmpar, e*B*gmm**2)\n    pf = 1/np.sqrt(3) * c*e**2 * np.divide(1, eps0*gmm**2)\n\n    try: wavelength[0]\n    except: wavelength = np.array([wavelength])\n\n    s = 0\n    for i in range(0, len(wavelength)):\n        intK53 = np.power(10, np.interp(np.log10(lowerBound/wavelength[i]), lBLookUp, intLookUp))\n        prefactor = pf / wavelength[i]**3\n        s = s + prefactor * intK53\n\n    return s",
  "def GetLookupTable():\n    lBLookup = np.array([\n        -6.000000000000000, -5.836734693877551, -5.673469387755102, -5.510204081632653, -5.346938775510204,\n        -5.183673469387755, -5.020408163265306, -4.857142857142858, -4.693877551020408, -4.530612244897959,\n        -4.367346938775510, -4.204081632653061, -4.040816326530612, -3.877551020408163, -3.714285714285714,\n        -3.551020408163265, -3.387755102040817, -3.224489795918367, -3.061224489795918, -2.897959183673469,\n        -2.734693877551020, -2.571428571428572, -2.408163265306122, -2.244897959183673, -2.081632653061225,\n        -1.918367346938775, -1.755102040816326, -1.591836734693878, -1.428571428571429, -1.265306122448980,\n        -1.102040816326531, -0.938775510204081, -0.775510204081633, -0.612244897959184, -0.448979591836735,\n        -0.285714285714286, -0.122448979591836, 0.040816326530612, 0.204081632653061, 0.367346938775510,\n        0.530612244897959, 0.693877551020408, 0.857142857142857, 1.020408163265306, 1.183673469387755,\n        1.346938775510204, 1.510204081632653, 1.673469387755102, 1.836734693877551, 2.000000000000000])\n\n    intLookup = np.array([\n        4.332306507591236, 4.223452531429022, 4.114595581696063, 4.005734811209318, 3.896869131331935,\n        3.787997143100175, 3.679117048667274, 3.570226537415596, 3.461322639450533, 3.352401537069625,\n        3.243458322041925, 3.134486682945749, 3.025478502115155, 2.916423335580212, 2.807307741236207,\n        2.698114409641302, 2.588821037306935, 2.479398862661506, 2.369810757916434, 2.260008732677154,\n        2.149930652562293, 2.039495901005069, 1.928599603509577, 1.817104873140658, 1.704832295876338,\n        1.591545509901944, 1.476931172514143, 1.360570737756962, 1.241900105480748, 1.120151062268769,\n        0.994265076008625, 0.862764772319786, 0.723560384647874, 0.573656419896563, 0.408706316122164,\n        0.222338614659824, 0.005145959802919, -0.256813349793911, -0.584206297790505, -1.007591859847029,\n        -1.571969326553784, -2.343311632609895, -3.417993705758430, -4.936475261893763, -7.103233595741016,\n        -10.215841848083457, -14.707383123030544, -21.208278598380790, -30.636369276961265, -44.328124551687772])\n\n    return lBLookup, intLookup",
  "class OtherScalarQuantity(ScalarQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherScalarQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other scalar quantity of size NT = {}'.format(self.name, self.data.shape[0])\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherScalarQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other scalar quantity of size NT = {}'.format(self.name, self.data.shape[0])",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "class SPIShardPositions(ScalarQuantity):\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n        \n    def plotRadialCoordinate(self, shards=None,**kwargs):\n        \"\"\" \n        Wrapper for ScalarQuantity.plot(), calculating \n        the radial coordinate of the shards instead of \n        the cartesian coordinates. Also allows the user \n        to choose which shards whose radial coordinates \n        should be plotted. \n        NOTE: Currently only valid for cylindrical geometry!\n        \n        :param slice shards: Shards wose radii should be plotted\n        \n        :return: Axis object containing the plot\n        \"\"\"\n        \n        data_rhop=self.calcRadialCoordinate(shards)\n                \n        _rhop=ScalarQuantity(name='\\\\rho_p',data=data_rhop, grid=self.grid, output=self.output)\n        return _rhop.plot(**kwargs)\n        \n    def calcRadialCoordinate(self, shards=None, t=None):\n        \"\"\" \n        Calculates the radial coordinates of the shards \n        (instead of the cartesian coordinates)\n        \n        :param slice shards: Shards wose radial coordinates should be calculated\n        :param slice t: time steps at which the radial coordinates should be calculated\n        \n        :return: radial coordinate data_rhop and poloidal angle data_thetap\n        \"\"\"\n        \n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        data_xp=self.data[:,0::3,0]\n        data_xp.reshape(data_xp.shape[0:2])\n        data_yp=self.data[:,1::3,0]\n        data_yp.reshape(data_xp.shape[0:2])\n        data_zp=self.data[:,2::3,0]\n        data_zp.reshape(data_xp.shape[0:2])\n        \n        data_rhop=np.sqrt(data_xp[t,shards]**2+data_yp[t,shards]**2)\n        data_thetap=np.arctan2(data_yp[t,shards],data_xp[t,shards])\n        \n        return data_rhop, data_thetap",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)",
  "def plotRadialCoordinate(self, shards=None,**kwargs):\n        \"\"\" \n        Wrapper for ScalarQuantity.plot(), calculating \n        the radial coordinate of the shards instead of \n        the cartesian coordinates. Also allows the user \n        to choose which shards whose radial coordinates \n        should be plotted. \n        NOTE: Currently only valid for cylindrical geometry!\n        \n        :param slice shards: Shards wose radii should be plotted\n        \n        :return: Axis object containing the plot\n        \"\"\"\n        \n        data_rhop=self.calcRadialCoordinate(shards)\n                \n        _rhop=ScalarQuantity(name='\\\\rho_p',data=data_rhop, grid=self.grid, output=self.output)\n        return _rhop.plot(**kwargs)",
  "def calcRadialCoordinate(self, shards=None, t=None):\n        \"\"\" \n        Calculates the radial coordinates of the shards \n        (instead of the cartesian coordinates)\n        \n        :param slice shards: Shards wose radial coordinates should be calculated\n        :param slice t: time steps at which the radial coordinates should be calculated\n        \n        :return: radial coordinate data_rhop and poloidal angle data_thetap\n        \"\"\"\n        \n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        data_xp=self.data[:,0::3,0]\n        data_xp.reshape(data_xp.shape[0:2])\n        data_yp=self.data[:,1::3,0]\n        data_yp.reshape(data_xp.shape[0:2])\n        data_zp=self.data[:,2::3,0]\n        data_zp.reshape(data_xp.shape[0:2])\n        \n        data_rhop=np.sqrt(data_xp[t,shards]**2+data_yp[t,shards]**2)\n        data_thetap=np.arctan2(data_yp[t,shards],data_xp[t,shards])\n        \n        return data_rhop, data_thetap",
  "class CurrentDensity(FluidQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(CurrentDensity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n\n    def current(self, t=None):\n        \"\"\"\n        Calculates the total current corresponding to this current density.\n        \"\"\"\n        geom = self.grid.GR0/self.grid.Bmin * self.grid.FSA_R02OverR2\n\n        return self.integral(t=t, w=geom) / (2*np.pi)\n\n\n    def totalCurrent(self, t=None):\n        \"\"\"\n        Calculates the total current corresponding to this current density\n        (alias for ``current()``).\n        \"\"\"\n        return self.current(t=t)",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(CurrentDensity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)",
  "def current(self, t=None):\n        \"\"\"\n        Calculates the total current corresponding to this current density.\n        \"\"\"\n        geom = self.grid.GR0/self.grid.Bmin * self.grid.FSA_R02OverR2\n\n        return self.integral(t=t, w=geom) / (2*np.pi)",
  "def totalCurrent(self, t=None):\n        \"\"\"\n        Calculates the total current corresponding to this current density\n        (alias for ``current()``).\n        \"\"\"\n        return self.current(t=t)",
  "class HotElectronDistributionFunction(DistributionFunction):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=grid.hottail)\n\n\n    def getTeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of this quantity.\n        \"\"\"\n        return r'$f_{\\rm hot}$'",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=grid.hottail)",
  "def getTeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of this quantity.\n        \"\"\"\n        return r'$f_{\\rm hot}$'",
  "class Timings:\n    \n\n    def __init__(self, timings=None, output=None):\n        \"\"\"\n        Constructor.\n\n        timings: Dictionary containing timings information from the DREAM kernel.\n        output:  Parent DREAMOutput object.\n        \"\"\"\n        self.timings = {}\n        self.output  = output\n        self.descriptions = {}\n        self.subtimers = []\n\n        if timings is not None:\n            self.loadTimingInformation(timings)\n\n\n    def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.__dict__)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the timing information.\n        \"\"\"\n        return self.__dict__[index]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()\n\n    \n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"\"\n        for key in self.timings:\n            unit, t = self.formatTimeAndUnit(self.timings[key])\n            s += '  {:30s}  -- {} {}\\n'.format(self.descriptions[key], t, unit)\n\n        for key in self.subtimers:\n            unit, t = self.formatTimeAndUnit(self[key].getTotal())\n            s += '  {:30s}  -- {} {}\\n'.format(key, t, unit)\n\n        return s\n\n\n    def formatTimeAndUnit(self, time):\n        \"\"\"\n        Format the given time and provide an appropriate unit.\n        \"\"\"\n        # Convert to ms\n        unit = 'ms'\n        t = time / 1000\n\n        if t > 1000:\n            t /= 1000\n            unit = 's'\n\n        return unit, t\n\n\n    def loadTimingInformation(self, timings):\n        \"\"\"\n        Load timing information from the given dict.\n        \"\"\"\n        tim = {}\n\n        for key in timings:\n            if key[-2:] == '@@':\n                self.descriptions[key[:-2]] = timings[key]['desc']\n            elif type(timings[key]) == float:\n                setattr(self, key, timings[key])\n                tim[key] = timings[key]\n            elif type(timings[key]) == np.ndarray:\n                setattr(self, key, timings[key][0])\n                tim[key] = timings[key][0]\n            elif type(timings[key]) == DataObject:\n                setattr(self, key, timings[key][:][0])\n                tim[key] = timings[key][:][0]\n            elif type(timings[key]) == dict:\n                setattr(self, key, Timings(timings[key], output=self.output))\n                self.subtimers.append(key)\n            else:\n                raise DREAMException(\"Unrecognized type of member '{}' of timings information: {}.\".format(key, type(timings[key])))\n\n        self.timings   = tim\n        self.subtimers = sorted(self.subtimers)\n        \n\n    def getTotal(self):\n        \"\"\"\n        Get total simulation time.\n        \"\"\"\n        if 'total' in self.timings:\n            return self.timings['total']\n        else:\n            t = 0\n            for key in self.timings:\n                if type(self.timings[key]) == float:\n                    t += self.timings[key]\n            \n            return t",
  "def __init__(self, timings=None, output=None):\n        \"\"\"\n        Constructor.\n\n        timings: Dictionary containing timings information from the DREAM kernel.\n        output:  Parent DREAMOutput object.\n        \"\"\"\n        self.timings = {}\n        self.output  = output\n        self.descriptions = {}\n        self.subtimers = []\n\n        if timings is not None:\n            self.loadTimingInformation(timings)",
  "def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.__dict__)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the timing information.\n        \"\"\"\n        return self.__dict__[index]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"\"\n        for key in self.timings:\n            unit, t = self.formatTimeAndUnit(self.timings[key])\n            s += '  {:30s}  -- {} {}\\n'.format(self.descriptions[key], t, unit)\n\n        for key in self.subtimers:\n            unit, t = self.formatTimeAndUnit(self[key].getTotal())\n            s += '  {:30s}  -- {} {}\\n'.format(key, t, unit)\n\n        return s",
  "def formatTimeAndUnit(self, time):\n        \"\"\"\n        Format the given time and provide an appropriate unit.\n        \"\"\"\n        # Convert to ms\n        unit = 'ms'\n        t = time / 1000\n\n        if t > 1000:\n            t /= 1000\n            unit = 's'\n\n        return unit, t",
  "def loadTimingInformation(self, timings):\n        \"\"\"\n        Load timing information from the given dict.\n        \"\"\"\n        tim = {}\n\n        for key in timings:\n            if key[-2:] == '@@':\n                self.descriptions[key[:-2]] = timings[key]['desc']\n            elif type(timings[key]) == float:\n                setattr(self, key, timings[key])\n                tim[key] = timings[key]\n            elif type(timings[key]) == np.ndarray:\n                setattr(self, key, timings[key][0])\n                tim[key] = timings[key][0]\n            elif type(timings[key]) == DataObject:\n                setattr(self, key, timings[key][:][0])\n                tim[key] = timings[key][:][0]\n            elif type(timings[key]) == dict:\n                setattr(self, key, Timings(timings[key], output=self.output))\n                self.subtimers.append(key)\n            else:\n                raise DREAMException(\"Unrecognized type of member '{}' of timings information: {}.\".format(key, type(timings[key])))\n\n        self.timings   = tim\n        self.subtimers = sorted(self.subtimers)",
  "def getTotal(self):\n        \"\"\"\n        Get total simulation time.\n        \"\"\"\n        if 'total' in self.timings:\n            return self.timings['total']\n        else:\n            t = 0\n            for key in self.timings:\n                if type(self.timings[key]) == float:\n                    t += self.timings[key]\n            \n            return t",
  "class MomentumGrid:\n    \n\n    def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        self.name  = name\n        self.r     = rgrid.r\n        self.r_f   = rgrid.r_f\n        self.dr    = rgrid.dr\n        self.type  = data['type']\n        self.rgrid = rgrid\n\n        self.Vprime = data['Vprime']\n        if 'Vprime_f2' in data:\n            self.Vprime_f2 = data['Vprime_f2']\n        self.p1   = data['p1']\n        self.p2   = data['p2']\n        self.p1_f = data['p1_f']\n        self.p2_f = data['p2_f']\n        self.dp1  = data['dp1']\n        self.dp2  = data['dp2']\n\n\n        self.Vprime_VpVol = np.copy(self.Vprime[:])\n        for i in range(0, self.rgrid.r.size):\n            self.Vprime_VpVol[i,:] /= rgrid.VpVol[i]\n\n        self.DR, self.DP2, self.DP1 = np.meshgrid(self.dr[:], self.dp2[:], self.dp1[:], indexing='ij')\n\n\n    def integrate3D(self, data, axes=(-3,-2,-1)):\n        \"\"\"\n        Evaluate a numerical volume integral of the given data\n        on this grid.\n        \n        data: Data to numerically integrate.\n        axes: Axes to integrate over.\n        \"\"\"\n        if len(axes) != 3:\n            raise OutputException(\"Invalid 'axes' parameter provided to 'integrate3D()'.\")\n\n        return (data * self.Vprime * self.DR * self.DP1 * self.DP2).sum(axes)\n\n\n    def integrate2D(self, data, axes=(-2,-1)):\n        \"\"\"\n        Evaluate a numerical momentum integral of the given\n        data on this grid.\n\n        data: Data to numerically integrate.\n        axes: Axes to integrate over.\n        \"\"\"\n        if len(axes) != 2:\n            raise OutputException(\"Invalid 'axes' parameter provided to 'integrate2D()'.\")\n        return (data * self.Vprime_VpVol * self.DP1 * self.DP2).sum(axes)\n\n\n    def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on\n        this 2D momentum grid.\n        \"\"\"\n        raise OutputException(\"'getGamma()' has not been implemented for this momentum grid.\")\n\n\n    def getP1TeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of the p1 coordinate.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            return r'$p$'\n        elif self.type == TYPE_PPARPPERP:\n            return r'$p_\\parallel$'\n        else:\n            raise OutputException(\"Unrecognized grid type: {}\".format(self.type))\n            \n\n    def getP2TeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of the p2 coordinate.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            return r'$\\xi$'\n        elif self.type == TYPE_PPARPPERP:\n            return r'$p_\\perp$'\n        else:\n            raise OutputException(\"Unrecognized grid type: {}\".format(self.type))\n\n\n    def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid. (This method must be implemented separately\n        for each specific momentum grid type)\n        \"\"\"\n        raise OutputException(\"'getVpar()' has not been implemented for this momentum grid.\")\n\n\n    def getBounceAveragedVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the integrand that should weigh\n        a function when carrying out the v_par moment of a quantity.\n\n        It should be identical to the ``integrand`` produced by the \n        ``CurrentDensityFromDistributionFunction`` class in the DREAM kernel.\n        \n        (This method must be implemented separately for each specific momentum grid type)\n        \"\"\"\n        raise OutputException(\"'getBounceAveragedVpar()' has not been implemented for this momentum grid.\")",
  "def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        self.name  = name\n        self.r     = rgrid.r\n        self.r_f   = rgrid.r_f\n        self.dr    = rgrid.dr\n        self.type  = data['type']\n        self.rgrid = rgrid\n\n        self.Vprime = data['Vprime']\n        if 'Vprime_f2' in data:\n            self.Vprime_f2 = data['Vprime_f2']\n        self.p1   = data['p1']\n        self.p2   = data['p2']\n        self.p1_f = data['p1_f']\n        self.p2_f = data['p2_f']\n        self.dp1  = data['dp1']\n        self.dp2  = data['dp2']\n\n\n        self.Vprime_VpVol = np.copy(self.Vprime[:])\n        for i in range(0, self.rgrid.r.size):\n            self.Vprime_VpVol[i,:] /= rgrid.VpVol[i]\n\n        self.DR, self.DP2, self.DP1 = np.meshgrid(self.dr[:], self.dp2[:], self.dp1[:], indexing='ij')",
  "def integrate3D(self, data, axes=(-3,-2,-1)):\n        \"\"\"\n        Evaluate a numerical volume integral of the given data\n        on this grid.\n        \n        data: Data to numerically integrate.\n        axes: Axes to integrate over.\n        \"\"\"\n        if len(axes) != 3:\n            raise OutputException(\"Invalid 'axes' parameter provided to 'integrate3D()'.\")\n\n        return (data * self.Vprime * self.DR * self.DP1 * self.DP2).sum(axes)",
  "def integrate2D(self, data, axes=(-2,-1)):\n        \"\"\"\n        Evaluate a numerical momentum integral of the given\n        data on this grid.\n\n        data: Data to numerically integrate.\n        axes: Axes to integrate over.\n        \"\"\"\n        if len(axes) != 2:\n            raise OutputException(\"Invalid 'axes' parameter provided to 'integrate2D()'.\")\n        return (data * self.Vprime_VpVol * self.DP1 * self.DP2).sum(axes)",
  "def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on\n        this 2D momentum grid.\n        \"\"\"\n        raise OutputException(\"'getGamma()' has not been implemented for this momentum grid.\")",
  "def getP1TeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of the p1 coordinate.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            return r'$p$'\n        elif self.type == TYPE_PPARPPERP:\n            return r'$p_\\parallel$'\n        else:\n            raise OutputException(\"Unrecognized grid type: {}\".format(self.type))",
  "def getP2TeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of the p2 coordinate.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            return r'$\\xi$'\n        elif self.type == TYPE_PPARPPERP:\n            return r'$p_\\perp$'\n        else:\n            raise OutputException(\"Unrecognized grid type: {}\".format(self.type))",
  "def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid. (This method must be implemented separately\n        for each specific momentum grid type)\n        \"\"\"\n        raise OutputException(\"'getVpar()' has not been implemented for this momentum grid.\")",
  "def getBounceAveragedVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the integrand that should weigh\n        a function when carrying out the v_par moment of a quantity.\n\n        It should be identical to the ``integrand`` produced by the \n        ``CurrentDensityFromDistributionFunction`` class in the DREAM kernel.\n        \n        (This method must be implemented separately for each specific momentum grid type)\n        \"\"\"\n        raise OutputException(\"'getBounceAveragedVpar()' has not been implemented for this momentum grid.\")",
  "class OtherFluidQuantity(FluidQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherFluidQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other fluid quantity of size NT x NR = {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1])\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]\n\n\n    def _renormalizeTimeIndexForUnknown(self, t):\n        \"\"\"\n        Tries to re-normalize the given time index so that it correctly indexes\n        a regular unknown quantity (which has a different time base).\n        \"\"\"\n        if t is None:\n            t = slice(None)\n\n        start, stop, step = t.start, t.stop, t.step\n        if start is None or start == 0:\n            start = 1\n        if stop is not None:\n            stop += 1\n\n        t = slice(start, stop, step)\n\n        return t",
  "def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherFluidQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other fluid quantity of size NT x NR = {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1])",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def _renormalizeTimeIndexForUnknown(self, t):\n        \"\"\"\n        Tries to re-normalize the given time index so that it correctly indexes\n        a regular unknown quantity (which has a different time base).\n        \"\"\"\n        if t is None:\n            t = slice(None)\n\n        start, stop, step = t.start, t.stop, t.step\n        if start is None or start == 0:\n            start = 1\n        if stop is not None:\n            stop += 1\n\n        t = slice(start, stop, step)\n\n        return t",
  "class OtherQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other quantity of size {}'.format(self.name, self.data.shape)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]\n\n\n    def _renormalizeTimeIndexForUnknown(self, t):\n        \"\"\"\n        Tries to re-normalize the given time index so that it correctly indexes\n        a regular unknown quantity (which has a different time base).\n        \"\"\"\n        if t is None:\n            t = slice(None)\n\n        start, stop, step = t.start, t.stop, t.step\n        if start is None or start == 0:\n            start = 1\n        if stop is not None:\n            stop += 1\n\n        t = slice(start, stop, step)\n\n        return t",
  "def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other quantity of size {}'.format(self.name, self.data.shape)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def _renormalizeTimeIndexForUnknown(self, t):\n        \"\"\"\n        Tries to re-normalize the given time index so that it correctly indexes\n        a regular unknown quantity (which has a different time base).\n        \"\"\"\n        if t is None:\n            t = slice(None)\n\n        start, stop, step = t.start, t.stop, t.step\n        if start is None or start == 0:\n            start = 1\n        if stop is not None:\n            stop += 1\n\n        t = slice(start, stop, step)\n\n        return t",
  "class AvalancheGrowthRate(OtherFluidQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, description=description, grid=grid, output=output)\n\n\n    def plotNormalized(self, r=None, t=None, ax=None, show=True, norm='Eceff'):\n        \"\"\"\n        Plot the avalanche growth rate, normalized to E-Eceff.\n        \"\"\"\n        ut = self._renormalizeTimeIndexForUnknown(t)\n\n        Enorm = self.output.eqsys.E_field.getNormEfield(field=norm, r=r, t=t)\n        E     = self.output.eqsys.E_field.get(r=r, t=ut)\n        EE    = E-Enorm\n\n        return self.plot(r=r, t=t, ax=ax, show=show, weight=EE)\n\n\n    def plotRunawayRate(self, r=None, t=None, ax=None, show=True):\n        \"\"\"\n        Plot the runaway corresponding to this growth rate (i.e.\n        GammaAva*n_re).\n        \"\"\"\n        ut = self._renormalizeTimeIndexForUnknown(t)\n\n        n_re = self.output.eqsys.n_re.get(r=r, t=ut)\n        return self.plot(r=r, t=t, ax=ax, show=show, weight=n_re)",
  "def __init__(self, name, data, description, grid, output):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, description=description, grid=grid, output=output)",
  "def plotNormalized(self, r=None, t=None, ax=None, show=True, norm='Eceff'):\n        \"\"\"\n        Plot the avalanche growth rate, normalized to E-Eceff.\n        \"\"\"\n        ut = self._renormalizeTimeIndexForUnknown(t)\n\n        Enorm = self.output.eqsys.E_field.getNormEfield(field=norm, r=r, t=t)\n        E     = self.output.eqsys.E_field.get(r=r, t=ut)\n        EE    = E-Enorm\n\n        return self.plot(r=r, t=t, ax=ax, show=show, weight=EE)",
  "def plotRunawayRate(self, r=None, t=None, ax=None, show=True):\n        \"\"\"\n        Plot the runaway corresponding to this growth rate (i.e.\n        GammaAva*n_re).\n        \"\"\"\n        ut = self._renormalizeTimeIndexForUnknown(t)\n\n        n_re = self.output.eqsys.n_re.get(r=r, t=ut)\n        return self.plot(r=r, t=t, ax=ax, show=show, weight=n_re)",
  "class OutputException(Exception):\n    \n    def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "class PparPperpGrid(MomentumGrid):\n    \n\n    def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        super(PXiGrid, self).__init__(name=name, rgrid=rgrid, data=data)\n\n        self.ppar   = data['p1']\n        self.pperp  = data['p2']\n        self.dppar  = data['dp1']\n        self.dpperp = data['dp2']\n\n        self.PPAR, self.PPERP = np.meshgrid(self.ppar[:], self.pperp[:])\n        self.P = np.sqrt(self.PPAR**2 + self.PPERP**2)\n        self.XI = self.PPAR / self.P\n        self.GAMMA = np.sqrt(self.P**2 + 1)\n\n\n    def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on this\n        2D momentum grid.\n        \"\"\"\n        return self.GAMMA\n\n\n    def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid.\n        \"\"\"\n        return scipy.constants.c * (self.PPAR/self.GAMMA)",
  "def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        super(PXiGrid, self).__init__(name=name, rgrid=rgrid, data=data)\n\n        self.ppar   = data['p1']\n        self.pperp  = data['p2']\n        self.dppar  = data['dp1']\n        self.dpperp = data['dp2']\n\n        self.PPAR, self.PPERP = np.meshgrid(self.ppar[:], self.pperp[:])\n        self.P = np.sqrt(self.PPAR**2 + self.PPERP**2)\n        self.XI = self.PPAR / self.P\n        self.GAMMA = np.sqrt(self.P**2 + 1)",
  "def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on this\n        2D momentum grid.\n        \"\"\"\n        return self.GAMMA",
  "def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid.\n        \"\"\"\n        return scipy.constants.c * (self.PPAR/self.GAMMA)",
  "class IonSpecies:\n    \n\n    def __init__(self, name, Z, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        name: Name of ion species.\n        Z:    Ion atomic charge.\n        data: Ion density data (size nt x nZ0 x nr, where nZ0 = Z+1\n              is the number of charge states for this ion).\n        \"\"\"\n        self.name = name\n        self.Z    = Z\n        self.grid = grid\n        self.output = output\n        self.ionstates = list()\n        self.data = data\n\n        nt = len(self.grid.t)\n        nr = len(self.grid.r)\n\n        if data.shape != (nt, Z+1, nr):\n            raise OutputException(\"Invalid dimensions of data. Expected {}x{}x{}, but found {}x{}x{}.\"\n                .format(nt, Z+1, nr, data.shape[0], data.shape[1], data.shape[2]))\n\n        for Z0 in range(0, Z+1):\n            self.addChargeState(name=name, Z=Z, Z0=Z0, data=data[:,Z0,:], attr=attr)\n\n\n    def __getitem__(self, Z0):\n        \"\"\"\n        Returns the 'IonState' object corresponding to the\n        specified charge state.\n        \"\"\"\n        return self.ionstates[Z0]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this IonSpecies object to an \"official\" string.\n        \"\"\"\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this IonSpecies object to a string.\n        \"\"\"\n        s = \"Ion species {} (Z={}) of size NT x NR = {} x {}\\n\".format(self.name, self.Z, self.grid.t.size, self.grid.r.size)\n        #s += 't=final {}'.format(self.getDensity(t=-1))\n        for Z0 in range(self.Z+1):\n            s += \"  Z0={:2d}:  {:1.3e} particles\\n\".format(Z0, self.ionstates[Z0].integral(t=-1))\n\n        return s\n\n\n    def addChargeState(self, name, Z, Z0, data, attr=list()):\n        \"\"\"\n        Adds a new IonState object to the list of ion charge states.\n        \"\"\"\n        self.ionstates.append(IonState(name=name, Z=Z, Z0=Z0, data=data, grid=self.grid, output=self.output, attr=attr))\n\n\n    def getCharge(self): return self.Z\n\n\n    def getName(self): return self.name\n\n\n    def getDensity(self, t=-1):\n        \"\"\"\n        Returns the total radial density (summed over all charge\n        states) in the given time step.\n        \"\"\"\n        #n = np.zeros((self.grid.r.size,))\n        n = None\n\n        for ion in self.ionstates:\n            if n is None:\n                n = np.copy(ion.get(t=t))\n            else:\n                n += ion.get(t=t)\n\n        return n\n\n\n    def getParticleNumber(self, t=-1):\n        \"\"\"\n        Returns the number of particles of this ion species\n        in the given time step.\n        \"\"\"\n        return self.grid.integrate(self.getDensity(t=t))\n\n\n    def plot(self, t=None, r=None, Z0=None, ax=None, show=None):\n        \"\"\"\n        Plots the ion charge state densities.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if t is None: t = slice(None)\n        if Z0 is None: Z0 = slice(None)\n\n        legs = []\n        states = self.ionstates[Z0]\n        for state in states:\n            data = None\n            # If 'r' is None, we integrate over all radii\n            # to get the total number of particles...\n            if r is None:\n                data = state.integral(t=t)\n            else:\n                data = state[t,r]\n\n            ax.plot(self.grid.t[t], data)\n\n            legs.append('$Z_0 = {}$'.format(state.Z0))\n\n        if len(legs) > 0:\n            ax.legend(legs)\n\n        if show:\n            plt.show(block=False)\n\n        return ax\n        \n    def plotSum(self, Z0 = None, integrate = False, **kwargs):\n        \"\"\"\n        Plots the spatio-temporal evolution of the sum of the specified charge states of this ion species\n        Z0:         list of charge states to be summed and plotted\n        integrate:  if 'True', plot the volume integral of the specified charge states\n        \"\"\"\n        if Z0 is None: Z0 = slice(None)\n        states = self.ionstates[Z0]\n        data = None\n        for state in states:\n            if data is None:\n                data = state.data\n            else:\n                data = data + state.data\n                \n        _IonSum = FluidQuantity(name = self.name, data=data, attr=list(), grid=self.grid, output=self.output)\n        if integrate:\n            return _IonSum.plotIntegral(**kwargs)\n        else:\n            return _IonSum.plot(**kwargs)\n\n\n    def histogram(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Create a histogram of the ion charge state densities for this species.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        x = [0]\n        y = [0]\n        labels = ['']\n        for state in self.ionstates:\n            x.append(x[-1]+1)\n            y.append(state.integral(t=t))\n            labels.append(state.getRomanName())\n\n        x = x[1:]\n        y = y[1:]\n        labels = labels[1:]\n\n        ax.bar(x, y, tick_label=labels, **kwargs)\n        lbls = ax.get_xticklabels()\n        plt.setp(lbls, rotation=45)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, name, Z, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        name: Name of ion species.\n        Z:    Ion atomic charge.\n        data: Ion density data (size nt x nZ0 x nr, where nZ0 = Z+1\n              is the number of charge states for this ion).\n        \"\"\"\n        self.name = name\n        self.Z    = Z\n        self.grid = grid\n        self.output = output\n        self.ionstates = list()\n        self.data = data\n\n        nt = len(self.grid.t)\n        nr = len(self.grid.r)\n\n        if data.shape != (nt, Z+1, nr):\n            raise OutputException(\"Invalid dimensions of data. Expected {}x{}x{}, but found {}x{}x{}.\"\n                .format(nt, Z+1, nr, data.shape[0], data.shape[1], data.shape[2]))\n\n        for Z0 in range(0, Z+1):\n            self.addChargeState(name=name, Z=Z, Z0=Z0, data=data[:,Z0,:], attr=attr)",
  "def __getitem__(self, Z0):\n        \"\"\"\n        Returns the 'IonState' object corresponding to the\n        specified charge state.\n        \"\"\"\n        return self.ionstates[Z0]",
  "def __repr__(self):\n        \"\"\"\n        Convert this IonSpecies object to an \"official\" string.\n        \"\"\"\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this IonSpecies object to a string.\n        \"\"\"\n        s = \"Ion species {} (Z={}) of size NT x NR = {} x {}\\n\".format(self.name, self.Z, self.grid.t.size, self.grid.r.size)\n        #s += 't=final {}'.format(self.getDensity(t=-1))\n        for Z0 in range(self.Z+1):\n            s += \"  Z0={:2d}:  {:1.3e} particles\\n\".format(Z0, self.ionstates[Z0].integral(t=-1))\n\n        return s",
  "def addChargeState(self, name, Z, Z0, data, attr=list()):\n        \"\"\"\n        Adds a new IonState object to the list of ion charge states.\n        \"\"\"\n        self.ionstates.append(IonState(name=name, Z=Z, Z0=Z0, data=data, grid=self.grid, output=self.output, attr=attr))",
  "def getCharge(self): return self.Z",
  "def getName(self): return self.name",
  "def getDensity(self, t=-1):\n        \"\"\"\n        Returns the total radial density (summed over all charge\n        states) in the given time step.\n        \"\"\"\n        #n = np.zeros((self.grid.r.size,))\n        n = None\n\n        for ion in self.ionstates:\n            if n is None:\n                n = np.copy(ion.get(t=t))\n            else:\n                n += ion.get(t=t)\n\n        return n",
  "def getParticleNumber(self, t=-1):\n        \"\"\"\n        Returns the number of particles of this ion species\n        in the given time step.\n        \"\"\"\n        return self.grid.integrate(self.getDensity(t=t))",
  "def plot(self, t=None, r=None, Z0=None, ax=None, show=None):\n        \"\"\"\n        Plots the ion charge state densities.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        if t is None: t = slice(None)\n        if Z0 is None: Z0 = slice(None)\n\n        legs = []\n        states = self.ionstates[Z0]\n        for state in states:\n            data = None\n            # If 'r' is None, we integrate over all radii\n            # to get the total number of particles...\n            if r is None:\n                data = state.integral(t=t)\n            else:\n                data = state[t,r]\n\n            ax.plot(self.grid.t[t], data)\n\n            legs.append('$Z_0 = {}$'.format(state.Z0))\n\n        if len(legs) > 0:\n            ax.legend(legs)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def plotSum(self, Z0 = None, integrate = False, **kwargs):\n        \"\"\"\n        Plots the spatio-temporal evolution of the sum of the specified charge states of this ion species\n        Z0:         list of charge states to be summed and plotted\n        integrate:  if 'True', plot the volume integral of the specified charge states\n        \"\"\"\n        if Z0 is None: Z0 = slice(None)\n        states = self.ionstates[Z0]\n        data = None\n        for state in states:\n            if data is None:\n                data = state.data\n            else:\n                data = data + state.data\n                \n        _IonSum = FluidQuantity(name = self.name, data=data, attr=list(), grid=self.grid, output=self.output)\n        if integrate:\n            return _IonSum.plotIntegral(**kwargs)\n        else:\n            return _IonSum.plot(**kwargs)",
  "def histogram(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Create a histogram of the ion charge state densities for this species.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        x = [0]\n        y = [0]\n        labels = ['']\n        for state in self.ionstates:\n            x.append(x[-1]+1)\n            y.append(state.integral(t=t))\n            labels.append(state.getRomanName())\n\n        x = x[1:]\n        y = y[1:]\n        labels = labels[1:]\n\n        ax.bar(x, y, tick_label=labels, **kwargs)\n        lbls = ax.get_xticklabels()\n        plt.setp(lbls, rotation=45)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class EquationSystem:\n\n\n    SPECIAL_TREATMENT = {\n        # List of unknown quantities with their own classes\n        'E_field':      ElectricField,\n        'f_hot':        HotElectronDistributionFunction,\n        'f_re':         RunawayElectronDistributionFunction,\n        'I_p':          PlasmaCurrent,\n        'I_wall':       ScalarQuantity,\n        'j_hot':        CurrentDensity,\n        'j_ohm':        CurrentDensity,\n        'j_re':         CurrentDensity,\n        'j_tot':        CurrentDensity,\n        'n_cold':       FluidQuantity,\n        'n_hot':        FluidQuantity,\n        'n_i':          IonHandler,\n        'N_i':          IonSpeciesFluidQuantity,\n        'n_re':         RunawayElectronDensity,\n        'n_re_neg':     RunawayElectronDensity,\n        'n_tot':        FluidQuantity,\n        'psi_edge':     ScalarQuantity,\n        'psi_p':        FluidQuantity,\n        'psi_trans':    ScalarQuantity,\n        'psi_wall':     ScalarQuantity,\n        'S_particle':   FluidQuantity,\n        'tau_coll':     FluidQuantity,\n        'T_cold':       Temperature,\n        'V_loop_trans': ScalarQuantity,\n        'V_loop_w':     ScalarQuantity,\n        'W_cold':       Temperature,\n        'W_i':          IonThermalEnergy,\n        'x_p':          SPIShardPositions,\n        'Y_p':          SPIShardRadii\n    }\n    \n\n    def __init__(self, unknowns=None, grid=None, output=None):\n        \"\"\"\n        Constructor.\n\n        unknowns: List of unknowns in the equation system (with data).\n        \"\"\"\n        self.grid = grid\n        self.unknowns = {}\n        self.output = output\n\n        if unknowns is not None:\n            self.setUnknowns(unknowns)\n\n\n    def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.unknowns)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the list of unknowns.\n        \"\"\"\n        return self.unknowns[index]\n\n\n    def keys(self): return self.unknowns.keys()\n\n\n    def getUnknownNames(self):\n        \"\"\"\n        Get a list with the names of all unknowns in\n        the equation system.\n        \"\"\"\n        return list(self.unknowns.keys())\n\n\n    def setGrid(self, grid):\n        \"\"\"\n        Sets the grid used for the DREAM simulation.\n        \"\"\"\n        self.grid = grid\n\n\n    def setUnknown(self, name, data, attr, datatype=None):\n        \"\"\"\n        Add the given unknown to this equation system.\n\n        name: Name of the unknown.\n        data: Data for the unknown (raw, as a dict from the output file).\n        attr: List of attributes set to this unknown in the output file.\n        \"\"\"\n        if datatype is not None:\n            o = datatype(name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n        elif name in self.SPECIAL_TREATMENT:\n            o = self.SPECIAL_TREATMENT[name](name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n        else:\n            o = UnknownQuantity(name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n\n        setattr(self, name, o)\n        self.unknowns[name] = o\n        \n\n    def setUnknowns(self, unknowns):\n        \"\"\"\n        Add a list of unknowns to this equation system.\n        \"\"\"\n        for uqn in unknowns:\n            # Skip attributes\n            if uqn[-2:] == '@@': continue\n\n            attr = []\n            if uqn+'@@' in unknowns:\n                attr = unknowns[uqn+'@@']\n\n            self.setUnknown(name=uqn, data=unknowns[uqn], attr=attr)\n\n\n    def resetUnknown(self, unknown, datatype):\n        \"\"\"\n        Reinitializes the named unknown quantity, making it of the given\n        data type.\n        \"\"\"\n        if unknown not in self.unknowns:\n            return\n\n        attr = {}\n        u = self.unknowns[unknown]\n        if 'description' in u.__dict__:\n            attr['description'] = u.description\n        if 'description_eqn' in u.__dict__:\n            attr['equation'] = u.description_eqn\n\n        self.setUnknown(name=unknown, data=u.data, attr=attr, datatype=datatype)",
  "def __init__(self, unknowns=None, grid=None, output=None):\n        \"\"\"\n        Constructor.\n\n        unknowns: List of unknowns in the equation system (with data).\n        \"\"\"\n        self.grid = grid\n        self.unknowns = {}\n        self.output = output\n\n        if unknowns is not None:\n            self.setUnknowns(unknowns)",
  "def __contains__(self, item):\n        \"\"\"\n        Overrides the Python 'in' operator.\n        \"\"\"\n        return (item in self.unknowns)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access by name to the list of unknowns.\n        \"\"\"\n        return self.unknowns[index]",
  "def keys(self): return self.unknowns.keys()",
  "def getUnknownNames(self):\n        \"\"\"\n        Get a list with the names of all unknowns in\n        the equation system.\n        \"\"\"\n        return list(self.unknowns.keys())",
  "def setGrid(self, grid):\n        \"\"\"\n        Sets the grid used for the DREAM simulation.\n        \"\"\"\n        self.grid = grid",
  "def setUnknown(self, name, data, attr, datatype=None):\n        \"\"\"\n        Add the given unknown to this equation system.\n\n        name: Name of the unknown.\n        data: Data for the unknown (raw, as a dict from the output file).\n        attr: List of attributes set to this unknown in the output file.\n        \"\"\"\n        if datatype is not None:\n            o = datatype(name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n        elif name in self.SPECIAL_TREATMENT:\n            o = self.SPECIAL_TREATMENT[name](name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n        else:\n            o = UnknownQuantity(name=name, data=data, attr=attr, grid=self.grid, output=self.output)\n\n        setattr(self, name, o)\n        self.unknowns[name] = o",
  "def setUnknowns(self, unknowns):\n        \"\"\"\n        Add a list of unknowns to this equation system.\n        \"\"\"\n        for uqn in unknowns:\n            # Skip attributes\n            if uqn[-2:] == '@@': continue\n\n            attr = []\n            if uqn+'@@' in unknowns:\n                attr = unknowns[uqn+'@@']\n\n            self.setUnknown(name=uqn, data=unknowns[uqn], attr=attr)",
  "def resetUnknown(self, unknown, datatype):\n        \"\"\"\n        Reinitializes the named unknown quantity, making it of the given\n        data type.\n        \"\"\"\n        if unknown not in self.unknowns:\n            return\n\n        attr = {}\n        u = self.unknowns[unknown]\n        if 'description' in u.__dict__:\n            attr['description'] = u.description\n        if 'description_eqn' in u.__dict__:\n            attr['equation'] = u.description_eqn\n\n        self.setUnknown(name=unknown, data=u.data, attr=attr, datatype=datatype)",
  "class OtherIonSpeciesScalarQuantity(IonSpeciesScalarQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]\n\n    \n    def __repr__(self):\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = '({}) Other ion species scalar quantity of size NI x NT = {} x {}\\n'.format(self.name, *self.data.shape)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s\n\n\n    def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        return OtherScalarQuantity(name='{}_{}'.format(self.name, name), data=self.data[:,idx], description=self.description, grid=self.grid, output=self.output)",
  "def __init__(self, name, data, description, grid, output, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super().__init__(name=name, data=data, grid=grid, attr=attr, output=output)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = '({}) Other ion species scalar quantity of size NI x NT = {} x {}\\n'.format(self.name, *self.data.shape)\n        for i in range(len(self.ions.Z)):\n            s += \"  {:2s} (Z = {:3d})\\n\".format(*self.ions[i])\n\n        return s",
  "def __getitem__(self, name):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        idx = self.ions.getIndex(name)\n\n        return OtherScalarQuantity(name='{}_{}'.format(self.name, name), data=self.data[:,idx], description=self.description, grid=self.grid, output=self.output)",
  "class PXiGrid(MomentumGrid):\n    \n\n    def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        super(PXiGrid, self).__init__(name=name, rgrid=rgrid, data=data)\n\n        self.p1name = 'p'\n        self.p2name = 'xi'\n\n        self.p  = data['p1']\n        self.xi = data['p2']\n        self.xi_f = data['p2_f']\n        self.dp = data['dp1']\n        self.dxi = data['dp2']\n\n        self.P, self.XI = np.meshgrid(self.p[:], self.xi[:])\n        self.PPAR = self.P*self.XI\n        self.PPERP = self.P*np.sqrt(1-self.XI**2)\n        self.GAMMA = np.sqrt(self.P**2 + 1)\n\n\n    def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on this\n        2D momentum grid.\n        \"\"\"\n        return self.GAMMA\n\n\n    def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid.\n        \"\"\"\n        return scipy.constants.c * (self.PPAR/self.GAMMA)\n\n    def getBounceAveragedVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the integrand that should weigh\n        a function when carrying out the v_par moment of a quantity.\n        \n        It should be identical to the ``integrand`` produced by the \n        ``CurrentDensityFromDistributionFunction`` class in the DREAM kernel.        \n        \"\"\"\n        c  = scipy.constants.speed_of_light\n        integrand = np.zeros(self.Vprime.shape)\n\n        # Load in data from file to speed up calculation\n        Vprime_VpVol = self.Vprime_VpVol[:]\n        p = self.p[:]\n        xi = self.xi[:]\n        xi_f = self.xi_f[:]\n        xi0TrappedBoundary = self.rgrid.xi0TrappedBoundary[:]\n\n        # Calculate bounce averaged v||\n        for ir in range(0, self.rgrid.r.size):\n            xi0Trapped = xi0TrappedBoundary[ir]\n            for j in range(0, xi.size):\n                xi1 = xi_f[j]\n                xi2 = xi_f[j+1]\n                if(xi1>xi2):\n                    xi_t = xi1\n                    xi1 = xi2\n                    xi2 = xi_t\n                \n                xi0Average = 0\n                if (xi2<=-xi0Trapped) or (xi1>=xi0Trapped) or ((xi1<=-xi0Trapped) and (xi2>=xi0Trapped)):  \n                    xi0Average = xi[j]\n\n                if xi0Average != 0:\n                    for i in range(0, p.size):\n                        v = c * p[i] / np.sqrt(1+p[i]**2)\n                        integrand[ir,j,i] =  2*np.pi * p[i]**2 * v * xi0Average / Vprime_VpVol[ir,j,i]\n\n        return integrand",
  "def __init__(self, name, rgrid, data):\n        \"\"\"\n        Constructor.\n\n        name:  Grid name.\n        rgrid: Parent 'Grid' object (representing radial grid).\n        data:  Momentum grid data.\n        \"\"\"\n        super(PXiGrid, self).__init__(name=name, rgrid=rgrid, data=data)\n\n        self.p1name = 'p'\n        self.p2name = 'xi'\n\n        self.p  = data['p1']\n        self.xi = data['p2']\n        self.xi_f = data['p2_f']\n        self.dp = data['dp1']\n        self.dxi = data['dp2']\n\n        self.P, self.XI = np.meshgrid(self.p[:], self.xi[:])\n        self.PPAR = self.P*self.XI\n        self.PPERP = self.P*np.sqrt(1-self.XI**2)\n        self.GAMMA = np.sqrt(self.P**2 + 1)",
  "def getGamma(self):\n        \"\"\"\n        Returns a meshgrid representing the relativistic factor on this\n        2D momentum grid.\n        \"\"\"\n        return self.GAMMA",
  "def getVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the parallel velocity on this\n        2D momentum grid.\n        \"\"\"\n        return scipy.constants.c * (self.PPAR/self.GAMMA)",
  "def getBounceAveragedVpar(self):\n        \"\"\"\n        Returns a meshgrid representing the integrand that should weigh\n        a function when carrying out the v_par moment of a quantity.\n        \n        It should be identical to the ``integrand`` produced by the \n        ``CurrentDensityFromDistributionFunction`` class in the DREAM kernel.        \n        \"\"\"\n        c  = scipy.constants.speed_of_light\n        integrand = np.zeros(self.Vprime.shape)\n\n        # Load in data from file to speed up calculation\n        Vprime_VpVol = self.Vprime_VpVol[:]\n        p = self.p[:]\n        xi = self.xi[:]\n        xi_f = self.xi_f[:]\n        xi0TrappedBoundary = self.rgrid.xi0TrappedBoundary[:]\n\n        # Calculate bounce averaged v||\n        for ir in range(0, self.rgrid.r.size):\n            xi0Trapped = xi0TrappedBoundary[ir]\n            for j in range(0, xi.size):\n                xi1 = xi_f[j]\n                xi2 = xi_f[j+1]\n                if(xi1>xi2):\n                    xi_t = xi1\n                    xi1 = xi2\n                    xi2 = xi_t\n                \n                xi0Average = 0\n                if (xi2<=-xi0Trapped) or (xi1>=xi0Trapped) or ((xi1<=-xi0Trapped) and (xi2>=xi0Trapped)):  \n                    xi0Average = xi[j]\n\n                if xi0Average != 0:\n                    for i in range(0, p.size):\n                        v = c * p[i] / np.sqrt(1+p[i]**2)\n                        integrand[ir,j,i] =  2*np.pi * p[i]**2 * v * xi0Average / Vprime_VpVol[ir,j,i]\n\n        return integrand",
  "class RunawayElectronDistributionFunction(DistributionFunction):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=grid.runaway)\n\n\n    def getTeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of this quantity.\n        \"\"\"\n        return r'$f_{\\rm RE}$'",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=grid.runaway)",
  "def getTeXName(self):\n        \"\"\"\n        Returns the TeX-compatible name of this quantity.\n        \"\"\"\n        return r'$f_{\\rm RE}$'",
  "class IonState(FluidQuantity):\n    \n\n    def __init__(self, name, Z, Z0, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=(\"{}-{}\".format(name, Z0)), data=data, attr=attr, grid=grid, output=output)\n\n        self.Z  = Z\n        self.Z0 = Z0\n\n\n    def getRomanName(self):\n        \"\"\"\n        Returns the name of this ion charge state using roman\n        numerals for the charge state number.\n        \"\"\"\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        roman_num = ''\n        i = 0\n        num = self.Z0\n\n        if num == 0:\n            roman_num = '0'\n        else:\n            while num > 0:\n                for _ in range(num // val[i]):\n                    roman_num += syb[i]\n                    num -= val[i]\n                i += 1\n\n        return self.name.split('-')[0]+f'-{roman_num}'",
  "def __init__(self, name, Z, Z0, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=(\"{}-{}\".format(name, Z0)), data=data, attr=attr, grid=grid, output=output)\n\n        self.Z  = Z\n        self.Z0 = Z0",
  "def getRomanName(self):\n        \"\"\"\n        Returns the name of this ion charge state using roman\n        numerals for the charge state number.\n        \"\"\"\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        roman_num = ''\n        i = 0\n        num = self.Z0\n\n        if num == 0:\n            roman_num = '0'\n        else:\n            while num > 0:\n                for _ in range(num // val[i]):\n                    roman_num += syb[i]\n                    num -= val[i]\n                i += 1\n\n        return self.name.split('-')[0]+f'-{roman_num}'",
  "class OtherQuantityHandler:\n    \n\n    def __init__(self, other=None, grid=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.fluid   = None\n        self.hottail = None\n        self.runaway = None\n        self.scalar  = None\n\n        self.categories = []\n\n        if other is not None:\n            for category in other.keys():\n                self.categories.append(category)\n                if category == 'hottail':\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output, grid.hottail))\n                elif category == 'runaway':\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output, grid.runaway))\n                else:\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output))\n\n    \n    def __contains__(self, item):\n        return (item in self.__dict__)\n\n\n    def __getitem__(self, index):\n        return self.__dict__[index]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"OtherQuantityHandler with\"\n        \n        for category in self.categories:\n            s += \"\\n   {}\\n{}\".format(category, self[category].tostring(padding=6*' '))\n\n        return s",
  "def __init__(self, other=None, grid=None, output=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.fluid   = None\n        self.hottail = None\n        self.runaway = None\n        self.scalar  = None\n\n        self.categories = []\n\n        if other is not None:\n            for category in other.keys():\n                self.categories.append(category)\n                if category == 'hottail':\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output, grid.hottail))\n                elif category == 'runaway':\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output, grid.runaway))\n                else:\n                    setattr(self, category, OtherQuantities(category, other[category], grid, output))",
  "def __contains__(self, item):\n        return (item in self.__dict__)",
  "def __getitem__(self, index):\n        return self.__dict__[index]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        s = \"OtherQuantityHandler with\"\n        \n        for category in self.categories:\n            s += \"\\n   {}\\n{}\".format(category, self[category].tostring(padding=6*' '))\n\n        return s",
  "class ScalarQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        :param str name:           Name of quantity.\n        :param numpy.ndarray data: Data for quanity.\n        :param list attr:          List of attributes for quantity.\n        :param grid:               Grid on which the quantity is defined.\n        :param DREAMOutput output: Parent output object.\n        \"\"\"\n        super(ScalarQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n        self.time = grid.t\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__() + \"\\n\"\n        s += \":: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n        s += self.dumps()\n        return s\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Scalar quantity of size NT = {}'.format(self.name, self.data.shape[0])\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]\n\n\n    def plot(self, ax=None, show=None, t=None, t_shift = 0, **kwargs):\n\n        \"\"\"\n        Generate a plot of the time evolution of this quantity.\n\n        :param matplotlib.axes.Axes ax: Axes object to create the plot on.\n        :param bool show:               If ``True``, calls ``matplotlib.pyplot.show(block=False)`` after creating the plot.\n        :param t:                       Selection of time points to plot. Can be a list, numpy array, slice or ``None``.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n        \n        if t is None:\n            t = slice(None)\n\n        ax.plot(self.time[t]+t_shift, self.data[t], **kwargs)\n        ax.set_xlabel(r'Time $t$ (s)')\n        ax.set_ylabel(r'{}'.format(self.getTeXName()))\n\n        if show:\n            plt.show(block=False)\n\n        return ax\n\n\n    def dumps(self, t=None):\n        \"\"\"\n        Dumps the data of this quantity as a string.\n        \n        :param t: Selection of time points to dump.\n        \"\"\"\n        if t is not None:\n            return self.data[t].__str__()\n        else:\n            return self.data[:].__str__()\n\n\n    def print(self, t=None):\n        \"\"\"\n        Print the data in this quantity at the given time.\n        \n        :param t: Time, or selection of times, from which to print the data.\n        \"\"\"\n        print(self.dumps(t))",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n\n        :param str name:           Name of quantity.\n        :param numpy.ndarray data: Data for quanity.\n        :param list attr:          List of attributes for quantity.\n        :param grid:               Grid on which the quantity is defined.\n        :param DREAMOutput output: Parent output object.\n        \"\"\"\n        super(ScalarQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n        self.time = grid.t",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        s = self.__str__() + \"\\n\"\n        s += \":: {}\\n:: Evolved using: {}\\n\".format(self.description, self.description_eqn)\n        s += self.dumps()\n        return s",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Scalar quantity of size NT = {}'.format(self.name, self.data.shape[0])",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def plot(self, ax=None, show=None, t=None, t_shift = 0, **kwargs):\n\n        \"\"\"\n        Generate a plot of the time evolution of this quantity.\n\n        :param matplotlib.axes.Axes ax: Axes object to create the plot on.\n        :param bool show:               If ``True``, calls ``matplotlib.pyplot.show(block=False)`` after creating the plot.\n        :param t:                       Selection of time points to plot. Can be a list, numpy array, slice or ``None``.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n        \n        if t is None:\n            t = slice(None)\n\n        ax.plot(self.time[t]+t_shift, self.data[t], **kwargs)\n        ax.set_xlabel(r'Time $t$ (s)')\n        ax.set_ylabel(r'{}'.format(self.getTeXName()))\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def dumps(self, t=None):\n        \"\"\"\n        Dumps the data of this quantity as a string.\n        \n        :param t: Selection of time points to dump.\n        \"\"\"\n        if t is not None:\n            return self.data[t].__str__()\n        else:\n            return self.data[:].__str__()",
  "def print(self, t=None):\n        \"\"\"\n        Print the data in this quantity at the given time.\n        \n        :param t: Time, or selection of times, from which to print the data.\n        \"\"\"\n        print(self.dumps(t))",
  "class SPIShardRadii(ScalarQuantity):\n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n        self.nshard=data.shape[1]\n        \n    def plotRadii(self, shards=None,**kwargs):\n        \"\"\"\n        Wrapper for ScalarQuantity.plot(), calculating the actual \n        shard radii (instead of r_p**(5/3) as used in the c++ core), \n        and also allowing the user to select which shards' radii to plot\n        \n        :param slice shards: Shards wose radii should be plotted\n        \n        :return: Axis object containing the plot\n        \"\"\"\n        _r_p=ScalarQuantity(name=self.name,data=self.calcRadii(shards), grid=self.grid, output=self.output)\n        return _r_p.plot(**kwargs)\n        \n    def calcRadii(self,shards=None, t=None):\n        \"\"\"\n        calculates the actual shard radii (instead of r_p**(5/3) \n        as used in the c++ core)\n        \n        :param slice shards: Shards wose radii should be calculated\n        :param slice t: time steps at whoch the radii should be calculated\n        \n        :return: shard radii\n        \"\"\"\n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        data_rp=(self.data[t,shards,0]*(self.data[t,shards,0]>0))**(3.0/5.0)\n        return data_rp.reshape(data_rp.shape[0:2])\n        \n        \n    def calcTotalVolume(self,shards=None, t=None):\n        \"\"\"\n        calculates the total volume of the specified shards\n        \n        shards: Shards whose volume should be calculated\n        t: time steps at which the radii should be calculated\n        \n        :return: Total volume of all specified shards combined\n        \"\"\"\n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        Vp_tot=np.sum(4*np.pi/3*(self.data[t,shards,0]*(self.data[t,shards,0]>0))**(9.0/5.0),axis=-1)\n        return Vp_tot.reshape(-1,1)\n        \n        \n    def plotTotalVolume(self, shards=None, **kwargs):\n        \"\"\"\n        Wrapper for ScalarQuantity.plot(), calculating the \n        total volume of the specified shards, \n        \n        :param slice shards: Shards wose volume should be plotted\n        \"\"\"\n        _Vp_tot=ScalarQuantity(name='V_{p,tot} [m$^3$]',data=self.calcTotalVolume(shards), grid=self.grid, output=self.output)\n        return _Vp_tot.plot(**kwargs)\n        \n    def plotAblatedVolume(self, shards = None, **kwargs):\n        nt = len(self.grid.t)\n        nr = len(self.grid.r)\n        data = np.zeros((nt,nr))\n        for it in range(1,nt):\n        \n            data[it,:] = data[it-1,:]\n            \n            rpPrev = self.calcRadii(shards = shards, t = it-1)\n            rp = self.calcRadii(shards = shards,t = it)\n            VPrev = 4*np.pi*rpPrev**3/3\n            V = 4*np.pi*rp**3/3\n            DV = VPrev - V\n            r, theta = self.output.eqsys.x_p.calcRadialCoordinate(shards = shards, t=it) # NOTE: assumes r stays the same during the whole saved time step! Should be improved!\n            for ir in range(nr):\n                data[it,ir] += np.sum(DV[(r>self.grid.r_f[ir]) & (r<self.grid.r_f[ir+1])])\n                \n        _ablatedVolume = FluidQuantity(name = \"ablated volume [m$^3$]\", data=data, attr=list(), grid=self.grid, output=self.output)\n        return _ablatedVolume.plot(**kwargs)\n            \n        \n    def plotPoloidal(self, ax=None, show=None, t=-1, displayGrid=False, sizeFactor=5e3, backgroundQuantity=None, **kwargs):\n        \"\"\"\n        Plot the position and size of the pellet shards, possibly together with \n        a background poloidal contour plot of another fluid quantity at the \n        specified time step. \n        NOTE: Currently assumes a cylindrical flux surface geometry!\n        \n        :param matplotlib.pyplot.axis ax:   Matplotlib axes object to use for plotting.\n        :param bool show: If 'True', shows the plot immediately via a call to\n              'matplotlib.pyplot.show()' with 'block=False'. If\n              'None', this is interpreted as 'True' if 'ax' is\n              also 'None'.\n        :param int t: Time index to plot\n        :param bool displayGrid: Specify wether or not to display a polar grid in the plot\n        :param float sizeFactor: factor used to scale up the shard radii (in meters) to make \n                    them visible in the plot\n        :param DREAM.Output.FluidQuantity.FluidQuantity backgroundQuantity: FluidQuantity object for which the poloidal\n                    contours should be included in the \n                    background\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([self.grid.r[0],self.grid.r[-1]])\n            ax.set_title('t = '+str(self.grid.t[t]))\n            cb=None\n\n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n                \n\n            if show is None:\n                show = True\n                \n        if backgroundQuantity is not None:\n            _,cb = backgroundQuantity.plotPoloidal(ax=ax,show=False, t=t,displayGrid=displayGrid, **kwargs)\n                \n                \n        data_xp=self.output.eqsys.x_p.data[t,0::3,0]\n        data_xp.reshape(data_xp.shape[0:2])\n        data_yp=self.output.eqsys.x_p.data[t,1::3,0]\n        data_yp.reshape(data_xp.shape[0:2])\n        \n        data_rp=self.calcRadii(t=t)\n        \n        rho_p, theta_p=self.output.eqsys.x_p.calcRadialCoordinate(t=t)\n        sizes=data_rp*sizeFactor\n\t\t\n        ax.scatter(theta_p,rho_p,s=sizes,color='c')\n\t\t\n        if show:\n            plt.show(block=False)\n            \n        return ax, cb\n\n        \n        \n    def animatePoloidal(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None, backgroundQuantity=None, **kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the SPI shards, \n        including the specified time steps. It is also possible to\n        include poloidal contours of a fluid quantity specified by \n        the backgroudQuantity argument\n        \n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param float dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        :param DREAM.Output.FluidQuantity.FluidQuantity backgroundQuantity: FluidQuantity object for which the poloidal\n                            contours should be included in the \n                            background\n        \"\"\"\n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPoloidal(show=False,t=0, backgroundQuantity=backgroundQuantity, **kwargs)\n        \n        def update_ani(t,ssr, ax):\n            ax.clear()\n            ax=ssr.plotPoloidal(colorbar=False, show=False, t=t, backgroundQuantity=backgroundQuantity, **kwargs)\n        \n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n        \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n        self.nshard=data.shape[1]",
  "def plotRadii(self, shards=None,**kwargs):\n        \"\"\"\n        Wrapper for ScalarQuantity.plot(), calculating the actual \n        shard radii (instead of r_p**(5/3) as used in the c++ core), \n        and also allowing the user to select which shards' radii to plot\n        \n        :param slice shards: Shards wose radii should be plotted\n        \n        :return: Axis object containing the plot\n        \"\"\"\n        _r_p=ScalarQuantity(name=self.name,data=self.calcRadii(shards), grid=self.grid, output=self.output)\n        return _r_p.plot(**kwargs)",
  "def calcRadii(self,shards=None, t=None):\n        \"\"\"\n        calculates the actual shard radii (instead of r_p**(5/3) \n        as used in the c++ core)\n        \n        :param slice shards: Shards wose radii should be calculated\n        :param slice t: time steps at whoch the radii should be calculated\n        \n        :return: shard radii\n        \"\"\"\n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        data_rp=(self.data[t,shards,0]*(self.data[t,shards,0]>0))**(3.0/5.0)\n        return data_rp.reshape(data_rp.shape[0:2])",
  "def calcTotalVolume(self,shards=None, t=None):\n        \"\"\"\n        calculates the total volume of the specified shards\n        \n        shards: Shards whose volume should be calculated\n        t: time steps at which the radii should be calculated\n        \n        :return: Total volume of all specified shards combined\n        \"\"\"\n        if shards is None:\n            shards=slice(None)\n            \n        if t is None:\n            t=slice(None)\n            \n        Vp_tot=np.sum(4*np.pi/3*(self.data[t,shards,0]*(self.data[t,shards,0]>0))**(9.0/5.0),axis=-1)\n        return Vp_tot.reshape(-1,1)",
  "def plotTotalVolume(self, shards=None, **kwargs):\n        \"\"\"\n        Wrapper for ScalarQuantity.plot(), calculating the \n        total volume of the specified shards, \n        \n        :param slice shards: Shards wose volume should be plotted\n        \"\"\"\n        _Vp_tot=ScalarQuantity(name='V_{p,tot} [m$^3$]',data=self.calcTotalVolume(shards), grid=self.grid, output=self.output)\n        return _Vp_tot.plot(**kwargs)",
  "def plotAblatedVolume(self, shards = None, **kwargs):\n        nt = len(self.grid.t)\n        nr = len(self.grid.r)\n        data = np.zeros((nt,nr))\n        for it in range(1,nt):\n        \n            data[it,:] = data[it-1,:]\n            \n            rpPrev = self.calcRadii(shards = shards, t = it-1)\n            rp = self.calcRadii(shards = shards,t = it)\n            VPrev = 4*np.pi*rpPrev**3/3\n            V = 4*np.pi*rp**3/3\n            DV = VPrev - V\n            r, theta = self.output.eqsys.x_p.calcRadialCoordinate(shards = shards, t=it) # NOTE: assumes r stays the same during the whole saved time step! Should be improved!\n            for ir in range(nr):\n                data[it,ir] += np.sum(DV[(r>self.grid.r_f[ir]) & (r<self.grid.r_f[ir+1])])\n                \n        _ablatedVolume = FluidQuantity(name = \"ablated volume [m$^3$]\", data=data, attr=list(), grid=self.grid, output=self.output)\n        return _ablatedVolume.plot(**kwargs)",
  "def plotPoloidal(self, ax=None, show=None, t=-1, displayGrid=False, sizeFactor=5e3, backgroundQuantity=None, **kwargs):\n        \"\"\"\n        Plot the position and size of the pellet shards, possibly together with \n        a background poloidal contour plot of another fluid quantity at the \n        specified time step. \n        NOTE: Currently assumes a cylindrical flux surface geometry!\n        \n        :param matplotlib.pyplot.axis ax:   Matplotlib axes object to use for plotting.\n        :param bool show: If 'True', shows the plot immediately via a call to\n              'matplotlib.pyplot.show()' with 'block=False'. If\n              'None', this is interpreted as 'True' if 'ax' is\n              also 'None'.\n        :param int t: Time index to plot\n        :param bool displayGrid: Specify wether or not to display a polar grid in the plot\n        :param float sizeFactor: factor used to scale up the shard radii (in meters) to make \n                    them visible in the plot\n        :param DREAM.Output.FluidQuantity.FluidQuantity backgroundQuantity: FluidQuantity object for which the poloidal\n                    contours should be included in the \n                    background\n\n        :return: a matplotlib axis object and a colorbar object (which may be 'None' if not used).\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([self.grid.r[0],self.grid.r[-1]])\n            ax.set_title('t = '+str(self.grid.t[t]))\n            cb=None\n\n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n                \n\n            if show is None:\n                show = True\n                \n        if backgroundQuantity is not None:\n            _,cb = backgroundQuantity.plotPoloidal(ax=ax,show=False, t=t,displayGrid=displayGrid, **kwargs)\n                \n                \n        data_xp=self.output.eqsys.x_p.data[t,0::3,0]\n        data_xp.reshape(data_xp.shape[0:2])\n        data_yp=self.output.eqsys.x_p.data[t,1::3,0]\n        data_yp.reshape(data_xp.shape[0:2])\n        \n        data_rp=self.calcRadii(t=t)\n        \n        rho_p, theta_p=self.output.eqsys.x_p.calcRadialCoordinate(t=t)\n        sizes=data_rp*sizeFactor\n\t\t\n        ax.scatter(theta_p,rho_p,s=sizes,color='c')\n\t\t\n        if show:\n            plt.show(block=False)\n            \n        return ax, cb",
  "def animatePoloidal(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None, backgroundQuantity=None, **kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the SPI shards, \n        including the specified time steps. It is also possible to\n        include poloidal contours of a fluid quantity specified by \n        the backgroudQuantity argument\n        \n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param float dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        :param DREAM.Output.FluidQuantity.FluidQuantity backgroundQuantity: FluidQuantity object for which the poloidal\n                            contours should be included in the \n                            background\n        \"\"\"\n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPoloidal(show=False,t=0, backgroundQuantity=backgroundQuantity, **kwargs)\n        \n        def update_ani(t,ssr, ax):\n            ax.clear()\n            ax=ssr.plotPoloidal(colorbar=False, show=False, t=t, backgroundQuantity=backgroundQuantity, **kwargs)\n        \n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n        \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()",
  "def update_ani(t,ssr, ax):\n            ax.clear()\n            ax=ssr.plotPoloidal(colorbar=False, show=False, t=t, backgroundQuantity=backgroundQuantity, **kwargs)",
  "class DistributionFunction(KineticQuantity):\n    \n\n    def __init__(self, name, data, grid, output, momentumgrid=None, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(DistributionFunction, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=momentumgrid)\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        p1name = 'P1'\n        p2name = 'P2'\n\n        if self.momentumgrid is not None:\n            if self.momentumgrid.type == TYPE_PXI:\n                p1name, p2name = 'P', 'XI'\n            elif self.momentumgrid.type == TYPE_PPARPPERP:\n                p1name, p2name = 'PAR', 'PERP'\n\n        return '({}) Kinetic quantity of size NT x NR x N{} x N{} = {} x {} x {} x {}\\n:: {}\\n:: Evolved using: {}'.format(self.name, p2name, p1name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3], self.description, self.description_eqn)\n\n\n    #########################################\n    # INTEGRALS OF THE DISTRIBUTION FUNCTION\n    #########################################\n\n    def currentDensity(self, t=None, r=None):\n        \"\"\"\n        Calculates the current density carried by the electrons of\n        this distribution function.\n        \"\"\"\n#        Vpar = self.momentumgrid.getBounceAveragedVpar()\n        Vpar = self.momentumgrid.getVpar()\n        return self.moment(Vpar, t=t, r=r) * scipy.constants.e\n\n\n    def density(self, t=None, r=None):\n        \"\"\"\n        Calculates the total density of this distribution function.\n        \"\"\"\n        return self.moment(1, t=t, r=r)\n\n\n    def kineticEnergy(self, t=None, r=None):\n        \"\"\"\n        Calculates the kinetic energy contained in the distribution function.\n        (energy in Joule).\n        \"\"\"\n        gamma1 = self.momentumgrid.getGamma()-1\n        mc2    = scipy.constants.m_e * scipy.constants.c**2\n        return self.moment(gamma1, t=t, r=r) * mc2\n\n\n    def plasmaCurrent(self, t=None):\n        \"\"\"\n        Calculates the total plasma current carried by the electrons of\n        this distribution function.\n        \"\"\"\n        j = self.currentDensity(t=t)\n        return self.grid.integrate(j)\n\n\n    def pressure(self, t=None, r=None):\n        \"\"\"\n        Evaluates the parallel and perpendicular pressure moments of the\n        distribution function according to\n\n          P_||    = mc^2 <p_||^2 / sqrt(1+p^2)>\n          P_\\perp = mc^2 <p_\\perp^2 / (2*sqrt(1+p^2))>\n\n        where <...> denotes an integral over all of momentum space. The\n        pressure is returned in units of Pa.\n\n        :returns: Tuple consisting of parallel and perpendicular pressures.\n        \"\"\"\n        p, xi  = self.momentumgrid.p1[:], self.momentumgrid.p2[:]\n        P, XI  = np.meshgrid(p, xi)\n        PPAR2  = (P*XI)**2\n        PPERP2 = P**2*(1-XI**2)\n\n        GAMMA = self.momentumgrid.getGamma()\n        mc2 = scipy.constants.m_e * scipy.constants.c**2\n\n        Ppar = self.moment(PPAR2/GAMMA, t=t, r=r) * mc2\n        Pperp = self.moment(PPERP2/GAMMA, t=t, r=r) * 0.5*mc2\n\n        return Ppar, Pperp\n\n\n    def partialDensity(self, t=None, r=None, pc=None):\n        \"\"\"\n        Calculate the density of electrons contained above a momentum ``pc``. If\n        a value for ``pc`` is not explicitly given, it is taken as either the\n        critical momentum ``other.fluid.pCrit`` if available, or as the\n        approximation ``pc = 1/sqrt(E/Ec-1)``.\n\n        The parameter ``pc`` may be a scalar or a fluid quantity, varying in\n        time and space.\n        \"\"\"\n        if t is None:\n            t = list(range(len(self.time)))\n        elif np.isscalar(t):\n            t = np.array([t])\n\n        if r is None:\n            r = list(range(len(self.grid.r)))\n        elif np.isscalar(t):\n            r = np.array([r])\n\n        if pc is None:\n            if 'fluid' in self.output.other:\n                if 'pCrit' in self.output.other.fluid:\n                    pc = self.output.other.fluid.pCrit[:]\n                elif 'Ecfree' in self.output.other.fluid:\n                    Ec = self.output.other.fluid.Ecfree[:]\n                    E = self.output.eqsys.E_field[1:,:]\n                    pc = 1/np.sqrt(E/Ec - 1)\n\n            if pc is None:\n                T = self.output.eqsys.T_cold[:]\n                n = self.output.eqsys.n_cold[:]\n                E = self.output.eqsys.E_field[:]\n\n                Ec = Formulas.Ec(T=T, n=n)\n                pc = 1/np.sqrt(E/Ec-1)\n\n            if pc.shape[0] == self.grid.t.size-1:\n                ppc = np.zeros((self.grid.t.size, pc.shape[1]))\n                ppc[1:,:] = pc[:]\n                ppc[0,:]  = np.inf\n                pc = ppc\n        elif np.isscalar(pc):\n            pc = pc*np.ones((self.time.size, self.grid.r.size))\n\n        p = self.momentumgrid.p1\n        data = np.zeros((len(t), len(r)))\n        for i in range(len(t)):\n            for j in range(len(r)):\n                F = self.data\n                mask = np.zeros((F.shape[2], F.shape[3]))\n                mask[:,np.where(p >= pc[t[i],r[j]])] = 1\n                data[i,j] = self.moment(mask, t=t[i], r=r[j])\n\n        return data\n\n\n    def runawayRate(self, t=None, r=None, pc=None):\n        \"\"\"\n        Calculate the runaway rate, with the given definition of critical\n        momentum, as a moment of the distribution function.\n        \"\"\"\n        n = self.partialDensity(pc=pc)\n        dt = np.diff(self.grid.t)\n        dndt = (np.diff(n, axis=0).T / dt).T\n\n        return dndt\n\n\n    def synchrotron(self, model='spectrum', B=3.1, wavelength=700e-9, t=None, r=None):\n        \"\"\"\n        Returns the synchrotron radiation emitted by this distribution function\n        as a :py:class:`DREAM.Output.KineticQuantity.KineticQuantity`.\n\n        :param str model:        Model to use for synchrotron moment. Either 'spectrum' (for synchrotron spectrum at specified wavelength and magnetic field) or 'total' (for total emitted power).\n        :param float B:          Magnetic field strength to use with 'spectrum' model.\n        :param float wavelength: Wavelength to use with 'spectrum' model (in meters).\n        \"\"\"\n        if t is None:\n            t = range(len(self.time))\n        elif np.isscalar(t):\n            t = np.array([t])\n\n        if r is None:\n            r = range(len(self.grid.r))\n        elif np.isscalar(r):\n            r = np.array([r])\n\n        data = None\n        if model == 'total':\n            pperp2 = self.momentumgrid.PPERP**2\n            m2c2   = (scipy.constants.m_e * scipy.constants.c)**2\n            data = pperp2 * self.data[t,r,:] * self.momentumgrid.Vprime_VpVol[r,:]\n        elif model == 'spectrum':\n            S = []\n            W = Bekefi.synchrotron(self.momentumgrid.P, self.momentumgrid.XI, wavelength, B)\n            data = W * self.data[t,r,:] * self.momentumgrid.Vprime_VpVol[r,:]\n        else:\n            raise OutputException(\"Unrecognized model for calculating synchrotron moment with: '{}'.\".format(model))\n\n        data = data.reshape((len(t), len(r), data.shape[-2], data.shape[-1]))\n        return KineticQuantity('synchrotron({})'.format(self.name), data=data, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid, attr={'description': 'Synchrotron moment of {}'.format(self.name), 'equation': 'synchrotron({})'.format(self.name)})\n\n\n    ##########################################\n    # PLOTTING ROUTINES\n    ##########################################\n    def plot(self, t=-1, r=0, moment='distribution', p2=None, ax=None, show=None, logy=True, **kwargs):\n        \"\"\"\n        Alias for :py:meth:`semilogy` henceforth.\n        \"\"\"\n        v = self.semilogy(t=t, r=r, moment=moment, p2=p2, ax=ax, show=show, **kwargs)\n\n        if logy:\n            v.set_yscale('log')\n        else:\n            v.set_yscale('linear')\n\n        return v\n\n\n    def plot2D(self, t=-1, r=0, ax=None, show=None, logarithmic=True, coordinates=None, **kwargs):\n        \"\"\"\n        Make a contour plot of this quantity.\n\n        :param int t:            Time index to plot.\n        :param int r:            Radial index to plot.\n        :param ax:               Matplotlib axes object to use for plotting.\n        :param bool show:        If ``True``, or ``None`` and ``ax`` is NOT provided, calls ``matplotlib.pyplot.show()`` just before returning.\n        :param bool logarithmic: If ``True``, uses a logarithmic colour scale.\n        :param str coordinates:  Name of coordinates to use (either 'spherical' (p/xi) or 'cylindrical' (ppar/pperp)).\n        :param kwargs:           Keyword arguments passed on to matplotlib.contourf().\n        \"\"\"\n        return super(DistributionFunction, self).plot(t=t, r=r, ax=ax, show=show, logarithmic=logarithmic, coordinates=coordinates, **kwargs)\n\n\n    def semilog(self, t=-1, r=0, p2=None, ax=None, show=None, **kwargs):\n        \"\"\"\n        Alias for :py:meth:`semilogy`.\n        \"\"\"\n        return self.semilogy(t=t, r=r, p2=p2, ax=ax, show=show, **kwargs)\n\n\n    def semilogy(self, t=-1, r=0, moment='distribution', p2=None, ax=None, show=None, **kwargs):\n        \"\"\"\n        Plot this distribution function on a semilogarithmic scale.\n        If 'p2' is None, the distribution function is first angle-averaged.\n        Otherwise, 'p2' is interpreted as an index into the distribution\n        function (second momentum dimension, i.e. xi or pperp).\n\n        :param int t: Integer, or list of integers, specifying the time indices of the distributions to plot.\n        :param int r: Integer, or list of integers, specifying the radial indices of the distributions to plot.\n        :param str moment: String (or array) speciyfing the angle averaged moment of the distribution to plot. See :py:meth:`DREAM.Output.KineticQuantity.KineticQuantity.angleAveraged` for possible values.\n        :param int p2: Index into second momentum parameter (xi or pperp) of distribution to plot.\n        :param matplotlib.Axes ax: Axes object to draw on.\n        :param bool show: If ``True``, show the figure after plotting.\n        \"\"\"\n        genax = ax is None\n\n        # Generate matplotlib axes\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # Retrieve data to plot\n        if p2 is None:\n            favg = self.angleAveraged(t=t, r=r, moment=moment)\n        else:\n            favg = self.data[t,r,p2,:]\n\n        #if favg.ndim != 1:\n        #    raise OutputException(\"Data dimensionality is too high. Unable to visualize distribution function.\")\n        if favg.ndim > 1: ndim = np.prod(favg.shape[:-1])\n        else: ndim = 1\n\n        favg = np.reshape(favg, (ndim, favg.shape[-1]))\n\n        colors = GeriMap.get(N=ndim+1)\n        lbls = []\n        p = self.momentumgrid.p1\n        for i in range(0, ndim):\n            if 'color' not in kwargs:\n                ax.semilogy(p, favg[i,:], color=colors(i/(ndim+1)), **kwargs)\n            else:\n                ax.semilogy(p, favg[i,:], **kwargs)\n\n            if np.isscalar(t) and np.isscalar(r): continue\n            elif np.isscalar(r):\n                tval, unit = self.grid.getTimeAndUnit(t[i])\n                lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}$'.format(tval, unit))\n            elif np.isscalar(t):\n                lbls.append(r'$r = {:.3f}\\,\\mathrm{{m}}$'.format(self.grid.r[r[i]]))\n            else:\n                it, ir = np.unravel_index(i, (len(t), len(r)))\n                tval, unit = self.grid.getTimeAndUnit(it)\n                lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}, r = {:.3f}\\,\\mathrm{{m}}$'.format(tval, unit, self.grid.r[ir]))\n\n        ax.set_xlabel(self.momentumgrid.getP1TeXName())\n\n        if type(moment) == str:\n            n = self.getTeXName()\n            if moment == 'distribution':\n                ax.set_ylabel(r'$\\langle${}$\\rangle$'.format(n))\n            elif moment == 'density':\n                ax.set_ylabel(r\"$\\langle(\\mathcal{{V}}'/V')${}$\\rangle$\".format(n))\n            elif moment == 'current':\n                ax.set_ylabel(r\"$\\langle ev_\\parallel(\\mathcal{{V}}'/V')${}$\\rangle$\".format(n))\n            else:\n                ax.set_ylabel(r\"Moment of $(\\mathcal{{V}}'/V')${}\".format(n))\n        else:\n            ax.set_ylabel(r\"Moment of $(\\mathcal{{V}}'/V')${}\".format(n))\n\n        fmax = np.amax(favg)\n        ax.set_xlim([self.momentumgrid.p1[0], self.momentumgrid.p1[-1]])\n        ax.set_ylim(np.array([1e-30, 10]) * fmax)\n\n        if len(lbls) > 0:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n        \n        return ax",
  "def __init__(self, name, data, grid, output, momentumgrid=None, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(DistributionFunction, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output, momentumgrid=momentumgrid)",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        p1name = 'P1'\n        p2name = 'P2'\n\n        if self.momentumgrid is not None:\n            if self.momentumgrid.type == TYPE_PXI:\n                p1name, p2name = 'P', 'XI'\n            elif self.momentumgrid.type == TYPE_PPARPPERP:\n                p1name, p2name = 'PAR', 'PERP'\n\n        return '({}) Kinetic quantity of size NT x NR x N{} x N{} = {} x {} x {} x {}\\n:: {}\\n:: Evolved using: {}'.format(self.name, p2name, p1name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3], self.description, self.description_eqn)",
  "def currentDensity(self, t=None, r=None):\n        \"\"\"\n        Calculates the current density carried by the electrons of\n        this distribution function.\n        \"\"\"\n#        Vpar = self.momentumgrid.getBounceAveragedVpar()\n        Vpar = self.momentumgrid.getVpar()\n        return self.moment(Vpar, t=t, r=r) * scipy.constants.e",
  "def density(self, t=None, r=None):\n        \"\"\"\n        Calculates the total density of this distribution function.\n        \"\"\"\n        return self.moment(1, t=t, r=r)",
  "def kineticEnergy(self, t=None, r=None):\n        \"\"\"\n        Calculates the kinetic energy contained in the distribution function.\n        (energy in Joule).\n        \"\"\"\n        gamma1 = self.momentumgrid.getGamma()-1\n        mc2    = scipy.constants.m_e * scipy.constants.c**2\n        return self.moment(gamma1, t=t, r=r) * mc2",
  "def plasmaCurrent(self, t=None):\n        \"\"\"\n        Calculates the total plasma current carried by the electrons of\n        this distribution function.\n        \"\"\"\n        j = self.currentDensity(t=t)\n        return self.grid.integrate(j)",
  "def pressure(self, t=None, r=None):\n        \"\"\"\n        Evaluates the parallel and perpendicular pressure moments of the\n        distribution function according to\n\n          P_||    = mc^2 <p_||^2 / sqrt(1+p^2)>\n          P_\\perp = mc^2 <p_\\perp^2 / (2*sqrt(1+p^2))>\n\n        where <...> denotes an integral over all of momentum space. The\n        pressure is returned in units of Pa.\n\n        :returns: Tuple consisting of parallel and perpendicular pressures.\n        \"\"\"\n        p, xi  = self.momentumgrid.p1[:], self.momentumgrid.p2[:]\n        P, XI  = np.meshgrid(p, xi)\n        PPAR2  = (P*XI)**2\n        PPERP2 = P**2*(1-XI**2)\n\n        GAMMA = self.momentumgrid.getGamma()\n        mc2 = scipy.constants.m_e * scipy.constants.c**2\n\n        Ppar = self.moment(PPAR2/GAMMA, t=t, r=r) * mc2\n        Pperp = self.moment(PPERP2/GAMMA, t=t, r=r) * 0.5*mc2\n\n        return Ppar, Pperp",
  "def partialDensity(self, t=None, r=None, pc=None):\n        \"\"\"\n        Calculate the density of electrons contained above a momentum ``pc``. If\n        a value for ``pc`` is not explicitly given, it is taken as either the\n        critical momentum ``other.fluid.pCrit`` if available, or as the\n        approximation ``pc = 1/sqrt(E/Ec-1)``.\n\n        The parameter ``pc`` may be a scalar or a fluid quantity, varying in\n        time and space.\n        \"\"\"\n        if t is None:\n            t = list(range(len(self.time)))\n        elif np.isscalar(t):\n            t = np.array([t])\n\n        if r is None:\n            r = list(range(len(self.grid.r)))\n        elif np.isscalar(t):\n            r = np.array([r])\n\n        if pc is None:\n            if 'fluid' in self.output.other:\n                if 'pCrit' in self.output.other.fluid:\n                    pc = self.output.other.fluid.pCrit[:]\n                elif 'Ecfree' in self.output.other.fluid:\n                    Ec = self.output.other.fluid.Ecfree[:]\n                    E = self.output.eqsys.E_field[1:,:]\n                    pc = 1/np.sqrt(E/Ec - 1)\n\n            if pc is None:\n                T = self.output.eqsys.T_cold[:]\n                n = self.output.eqsys.n_cold[:]\n                E = self.output.eqsys.E_field[:]\n\n                Ec = Formulas.Ec(T=T, n=n)\n                pc = 1/np.sqrt(E/Ec-1)\n\n            if pc.shape[0] == self.grid.t.size-1:\n                ppc = np.zeros((self.grid.t.size, pc.shape[1]))\n                ppc[1:,:] = pc[:]\n                ppc[0,:]  = np.inf\n                pc = ppc\n        elif np.isscalar(pc):\n            pc = pc*np.ones((self.time.size, self.grid.r.size))\n\n        p = self.momentumgrid.p1\n        data = np.zeros((len(t), len(r)))\n        for i in range(len(t)):\n            for j in range(len(r)):\n                F = self.data\n                mask = np.zeros((F.shape[2], F.shape[3]))\n                mask[:,np.where(p >= pc[t[i],r[j]])] = 1\n                data[i,j] = self.moment(mask, t=t[i], r=r[j])\n\n        return data",
  "def runawayRate(self, t=None, r=None, pc=None):\n        \"\"\"\n        Calculate the runaway rate, with the given definition of critical\n        momentum, as a moment of the distribution function.\n        \"\"\"\n        n = self.partialDensity(pc=pc)\n        dt = np.diff(self.grid.t)\n        dndt = (np.diff(n, axis=0).T / dt).T\n\n        return dndt",
  "def synchrotron(self, model='spectrum', B=3.1, wavelength=700e-9, t=None, r=None):\n        \"\"\"\n        Returns the synchrotron radiation emitted by this distribution function\n        as a :py:class:`DREAM.Output.KineticQuantity.KineticQuantity`.\n\n        :param str model:        Model to use for synchrotron moment. Either 'spectrum' (for synchrotron spectrum at specified wavelength and magnetic field) or 'total' (for total emitted power).\n        :param float B:          Magnetic field strength to use with 'spectrum' model.\n        :param float wavelength: Wavelength to use with 'spectrum' model (in meters).\n        \"\"\"\n        if t is None:\n            t = range(len(self.time))\n        elif np.isscalar(t):\n            t = np.array([t])\n\n        if r is None:\n            r = range(len(self.grid.r))\n        elif np.isscalar(r):\n            r = np.array([r])\n\n        data = None\n        if model == 'total':\n            pperp2 = self.momentumgrid.PPERP**2\n            m2c2   = (scipy.constants.m_e * scipy.constants.c)**2\n            data = pperp2 * self.data[t,r,:] * self.momentumgrid.Vprime_VpVol[r,:]\n        elif model == 'spectrum':\n            S = []\n            W = Bekefi.synchrotron(self.momentumgrid.P, self.momentumgrid.XI, wavelength, B)\n            data = W * self.data[t,r,:] * self.momentumgrid.Vprime_VpVol[r,:]\n        else:\n            raise OutputException(\"Unrecognized model for calculating synchrotron moment with: '{}'.\".format(model))\n\n        data = data.reshape((len(t), len(r), data.shape[-2], data.shape[-1]))\n        return KineticQuantity('synchrotron({})'.format(self.name), data=data, grid=self.grid, output=self.output, momentumgrid=self.momentumgrid, attr={'description': 'Synchrotron moment of {}'.format(self.name), 'equation': 'synchrotron({})'.format(self.name)})",
  "def plot(self, t=-1, r=0, moment='distribution', p2=None, ax=None, show=None, logy=True, **kwargs):\n        \"\"\"\n        Alias for :py:meth:`semilogy` henceforth.\n        \"\"\"\n        v = self.semilogy(t=t, r=r, moment=moment, p2=p2, ax=ax, show=show, **kwargs)\n\n        if logy:\n            v.set_yscale('log')\n        else:\n            v.set_yscale('linear')\n\n        return v",
  "def plot2D(self, t=-1, r=0, ax=None, show=None, logarithmic=True, coordinates=None, **kwargs):\n        \"\"\"\n        Make a contour plot of this quantity.\n\n        :param int t:            Time index to plot.\n        :param int r:            Radial index to plot.\n        :param ax:               Matplotlib axes object to use for plotting.\n        :param bool show:        If ``True``, or ``None`` and ``ax`` is NOT provided, calls ``matplotlib.pyplot.show()`` just before returning.\n        :param bool logarithmic: If ``True``, uses a logarithmic colour scale.\n        :param str coordinates:  Name of coordinates to use (either 'spherical' (p/xi) or 'cylindrical' (ppar/pperp)).\n        :param kwargs:           Keyword arguments passed on to matplotlib.contourf().\n        \"\"\"\n        return super(DistributionFunction, self).plot(t=t, r=r, ax=ax, show=show, logarithmic=logarithmic, coordinates=coordinates, **kwargs)",
  "def semilog(self, t=-1, r=0, p2=None, ax=None, show=None, **kwargs):\n        \"\"\"\n        Alias for :py:meth:`semilogy`.\n        \"\"\"\n        return self.semilogy(t=t, r=r, p2=p2, ax=ax, show=show, **kwargs)",
  "def semilogy(self, t=-1, r=0, moment='distribution', p2=None, ax=None, show=None, **kwargs):\n        \"\"\"\n        Plot this distribution function on a semilogarithmic scale.\n        If 'p2' is None, the distribution function is first angle-averaged.\n        Otherwise, 'p2' is interpreted as an index into the distribution\n        function (second momentum dimension, i.e. xi or pperp).\n\n        :param int t: Integer, or list of integers, specifying the time indices of the distributions to plot.\n        :param int r: Integer, or list of integers, specifying the radial indices of the distributions to plot.\n        :param str moment: String (or array) speciyfing the angle averaged moment of the distribution to plot. See :py:meth:`DREAM.Output.KineticQuantity.KineticQuantity.angleAveraged` for possible values.\n        :param int p2: Index into second momentum parameter (xi or pperp) of distribution to plot.\n        :param matplotlib.Axes ax: Axes object to draw on.\n        :param bool show: If ``True``, show the figure after plotting.\n        \"\"\"\n        genax = ax is None\n\n        # Generate matplotlib axes\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # Retrieve data to plot\n        if p2 is None:\n            favg = self.angleAveraged(t=t, r=r, moment=moment)\n        else:\n            favg = self.data[t,r,p2,:]\n\n        #if favg.ndim != 1:\n        #    raise OutputException(\"Data dimensionality is too high. Unable to visualize distribution function.\")\n        if favg.ndim > 1: ndim = np.prod(favg.shape[:-1])\n        else: ndim = 1\n\n        favg = np.reshape(favg, (ndim, favg.shape[-1]))\n\n        colors = GeriMap.get(N=ndim+1)\n        lbls = []\n        p = self.momentumgrid.p1\n        for i in range(0, ndim):\n            if 'color' not in kwargs:\n                ax.semilogy(p, favg[i,:], color=colors(i/(ndim+1)), **kwargs)\n            else:\n                ax.semilogy(p, favg[i,:], **kwargs)\n\n            if np.isscalar(t) and np.isscalar(r): continue\n            elif np.isscalar(r):\n                tval, unit = self.grid.getTimeAndUnit(t[i])\n                lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}$'.format(tval, unit))\n            elif np.isscalar(t):\n                lbls.append(r'$r = {:.3f}\\,\\mathrm{{m}}$'.format(self.grid.r[r[i]]))\n            else:\n                it, ir = np.unravel_index(i, (len(t), len(r)))\n                tval, unit = self.grid.getTimeAndUnit(it)\n                lbls.append(r'$t = {:.3f}\\,\\mathrm{{{}}}, r = {:.3f}\\,\\mathrm{{m}}$'.format(tval, unit, self.grid.r[ir]))\n\n        ax.set_xlabel(self.momentumgrid.getP1TeXName())\n\n        if type(moment) == str:\n            n = self.getTeXName()\n            if moment == 'distribution':\n                ax.set_ylabel(r'$\\langle${}$\\rangle$'.format(n))\n            elif moment == 'density':\n                ax.set_ylabel(r\"$\\langle(\\mathcal{{V}}'/V')${}$\\rangle$\".format(n))\n            elif moment == 'current':\n                ax.set_ylabel(r\"$\\langle ev_\\parallel(\\mathcal{{V}}'/V')${}$\\rangle$\".format(n))\n            else:\n                ax.set_ylabel(r\"Moment of $(\\mathcal{{V}}'/V')${}\".format(n))\n        else:\n            ax.set_ylabel(r\"Moment of $(\\mathcal{{V}}'/V')${}\".format(n))\n\n        fmax = np.amax(favg)\n        ax.set_xlim([self.momentumgrid.p1[0], self.momentumgrid.p1[-1]])\n        ax.set_ylim(np.array([1e-30, 10]) * fmax)\n\n        if len(lbls) > 0:\n            ax.legend(lbls)\n\n        if show:\n            plt.show(block=False)\n        \n        return ax",
  "class KineticQuantity(UnknownQuantity):\n    \n\n    def __init__(self, name, data, grid, output, momentumgrid=None, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(KineticQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.momentumgrid = momentumgrid\n\n        # Cell or flux grid?\n        if momentumgrid.p1.size == data.shape[3]:\n            self.p1 = momentumgrid.p1\n        elif momentumgrid.p1_f.size == data.shape[3]:\n            self.p1 = momentumgrid.p1_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        if momentumgrid.p2.size == data.shape[2]:\n            self.p2 = momentumgrid.p2\n        elif momentumgrid.p2_f.size == data.shape[2]:\n            self.p2 = momentumgrid.p2_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        if grid.r.size == data.shape[1]:\n            self.radius = grid.r\n        elif grid.r_f.size == data.shape[1]:\n            self.radius = grid.r_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        self.time = self.grid.t\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Kinetic quantity of size NT x NR x NP2 x NP1 = {} x {} x {} x {}\\n:: {}\\n:: Evolved using: {}\\n{}'.format(self.name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3], self.description, self.description_eqn, self.data)\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]\n\n\n    def angleAveraged(self, t=None, r=None, moment='distribution'):\n        r\"\"\"\n        Returns the angle-averaged distribution function. Depending on\n        the input parameters, the whole or only some parts of the spatiotemporal\n        distribution can be angle-averaged.\n\n        This method can only be applied to distributions defined on p/xi\n        momentum grids.\n\n        Supported moments:\n        \n        - ``distribution``: :math:`\\left\\langle f \\right\\rangle_{\\xi_0}`\n        - ``density``: :math:`\\left\\langle V'f\\right\\rangle_{\\xi_0}`\n        - ``current``: :math:`\\left\\langle v\\xi_0 V' f\\right\\rangle_{\\xi_0}`\n        - ...or a vector (or scalar) to weight the distribution function with.\n\n        where :math:`\\left\\langle X \\right\\rangle_{\\xi_0} = \\int_{-1}^1 X\\,\\mathrm{d}\\xi_0`.\n        \"\"\"\n        if self.momentumgrid is None or self.momentumgrid.type != TYPE_PXI:\n            raise OutputException(\"The angle average can only be calculated on p/xi grids.\")\n\n        if t is None: t = slice(None)\n        if r is None: r = slice(None)\n        \n        data = self.data[t,r,:]\n\n        if type(moment) == str:\n            if moment == 'distribution':\n                # Divide by range of xi\n                data = data/2\n            elif moment == 'density':\n                data = data * self.momentumgrid.Vprime_VpVol[r,:]\n            elif moment == 'current':\n                vPar = self.momentumgrid.getBounceAveragedVpar()\n                data = data * vPar[r,:] * self.momentumgrid.Vprime_VpVol[r,:] * scipy.constants.e\n        elif type(moment) == float or type(moment) == np.ndarray:\n            data = data * moment * self.momentumgrid.Vprime_VpVol[r,:]\n        else:\n            raise OutputException(\"Invalid type of parameter 'moment'.\")\n            \n        favg = np.sum(data * self.momentumgrid.DP2[r,:], axis=data.ndim-2)\n\n        return favg\n\n    \n    def animate(self, keep=[], r=0, ax=None, repeat=False, repeat_delay=None, speed=None, blit=True, moment='distribution', save=None, dpi=None, **kwargs):\n        \"\"\"\n        Creates an animation of the time evolution of the angle average of\n        this kinetic quantity.\n\n        :param list keep:        List of time indices to keep in the plot.\n        :param r:                Radius to plot angle average for.\n        :param ax:               Axes object to use for plotting.\n        :param bool repeat:      If ``True``, repeats animation after it is finished.\n        :param int repeat_delay: Number of milliseconds to wait before repeating animation.\n        :param int speed:        Number of milliseconds to show each frame.\n        :param bool blit:        If ``True``, use blitting to optimize drawing.\n        :param str moment:       Moment of distribution function to plot (same values as for :py:meth:`DREAM.Output.KineticQuantity.KineticQuantity.angleAveraged`).\n        :param str save:         If provided, saves the animation to the named file instead of showing it.\n        :param int dpi:          Video resolution (if saving animation to file).\n        :param kwargs:           Keyword arguments passed to ``ax.plot()``.\n        \"\"\"\n        show = ax is None\n\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        favg = self.angleAveraged(r=r, moment=moment)\n        def update_ani(num, kq, ax, lines, lbl, favg, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(kq.time[num]*tfac, tunit))\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n            else:\n                idx = None\n\n            # Iterate over radii\n            n = len(lines)\n            for i in range(n):\n                if favg.ndim == 3: d = favg[num,i,:]\n                else: d = favg[num,:]\n\n                line.set_data(kq.p1, d)\n\n                # Keep line after time step has passed?\n                if idx is not None:\n                    keeplines[idx*n+i].set_data(kq.p1, d)\n\n            return (line, lbl) + tuple(keeplines)\n\n        if speed is None:\n            speed = 50\n\n        # Determine number of radii to plot\n        if favg.ndim == 3:\n            nr = favg.shape[1]\n        elif favg.ndim == 2:\n            nr = 1\n        else:\n            raise OutputException(\"Invalid number of dimensions selected to animate.\")\n\n        # Plot at t=0\n        colors = GeriMap.get(N=favg.ndim)\n        lines = []\n        for i in range(nr):\n            # Select data to plot\n            if favg.ndim == 3: d = favg[0,i,:]\n            else: d = favg[0,:]\n\n            if 'color' not in kwargs:\n                line, = ax.semilogy(self.p1, d, color=colors(i/(nr+1)), **kwargs)\n            else:\n                line, = ax.semilogy(self.p1, d, **kwargs)\n\n            lines.append(line)\n\n        # Create placeholders for the 'keep' lines\n        keeplines = []\n        if keep is not None:\n            for i in range(len(keep)):\n                for j in range(nr):\n                    if 'color' not in kwargs:\n                        l, = ax.plot([], [], linewidth=2, color=colors(j/(nr+1)), **kwargs)\n                    else:\n                        l, = ax.plot([], [], linewidth=2, **kwargs)\n\n                    keeplines.append(l)\n\n        # Set x/y limits\n        fmax = np.amax(favg)\n        xmin, xmax = self.p1[0], self.p1[-1]\n        ymin, ymax = 1e-30*fmax, 10*fmax\n        ax.set_xlim([xmin, xmax])\n        ax.set_ylim([ymin ,ymax])\n\n        # Determine the relevant time scale\n        tmax = self.time[-1]\n        idx  = 0\n        tfac = 1\n        tunits = ['s', 'ms', '\u00b5s', 'ns', 'ps']\n        while tmax*tfac < 1 and idx < len(tunits)-1:\n            idx += 1\n            tfac = (1e3)**(idx)\n\n        xp, yp = 0.60, 0.93\n        lymin, lymax = np.log10(ymin), np.log10(ymax)\n        tx = xmin+xp*(xmax-xmin)\n        ty = lymin+yp*(lymax-lymin)\n        txt = ax.text(tx, 10**ty, r't = {:.3f} {}'.format(self.time[0]*tfac, tunits[idx]), usetex=False)\n\n        ax.set_xlabel(r'$r/a$ (m)')\n\n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=self.time.size,\n            interval=speed, repeat_delay=repeat_delay, repeat=repeat, blit=blit,\n            fargs=(self, ax, lines, txt, favg, keeplines, tfac, tunits[idx], keep))\n\n        # Save animation?\n        if save:\n            writer = animation.FFMpegFileWriter(fps=1000/speed)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\n        if show:\n            plt.show()\n\n        return ani\n\n\n    def get(self, t=None, r=None, p2=None, p1=None):\n        \"\"\"\n        Returns data using the specified indexing. If an argument is ``None``,\n        this method will return all elements along that dimension.\n        \"\"\"\n        sel = [slice(None)] * 4\n\n        if t  is not None: sel[0] = t\n        if r  is not None: sel[1] = r\n        if p2 is not None: sel[2] = p2\n        if p1 is not None: sel[3] = p1\n\n        return self.data[tuple(sel)]\n\n\n    def moment(self, weight, t=None, r=None):\n        \"\"\"\n        Evaluate a moment of this distribution function with the given weighting\n        factor.\n        \"\"\"\n        if t is None:\n            t = range(len(self.time))\n        if r is None:\n            r = range(len(self.grid.r))\n\n        if np.isscalar(t):\n            t = np.asarray([t])\n        if np.isscalar(r):\n            r = np.asarray([r])\n\n        if np.ndim(weight) != 4:\n            _weight = np.ones((self.time.size,self.grid.r.size,self.momentumgrid.p2.size,self.momentumgrid.p1.size))\n            \n            if np.ndim(weight) == 0:\n                weight = _weight*weight\n            if np.ndim(weight) == 1:\n                weight = _weight*weight[np.newaxis,np.newaxis,np.newaxis,:]\n            elif np.ndim(weight) == 2:\n                weight = _weight*weight[np.newaxis,np.newaxis,:]\n            elif np.ndim(weight) == 3:\n                weight = _weight*weight[np.newaxis,:]\n                \n        q = np.zeros((len(t), len(r)))\n        for iT in range(len(t)):\n            for iR in range(len(r)):\n                q[iT,iR] = self.momentumgrid.integrate2D(self.data[t[iT],r[iR],:] * weight[t[iT],r[iR],:])[0]\n        \n        return q\n\n\n    def plot(self, t=-1, r=0, ax=None, show=None, logarithmic=False, coordinates=None, **kwargs):\n        \"\"\"\n        Visualize this kinetic quantity at one time and radius using a filled\n        contour plot.\n\n        :param t:           Time index to visualize quantity at.\n        :param r:           Radial index to visualize quantity at.\n        :param ax:          Matplotlib Axes object to draw plot on.\n        :param show:        If ``True``, calls ``matplotlib.pyplot.show()`` with ``block=False`` after plotting the quantity.\n        :param logarithmic: If ``True``, plots the base-10 logarithm of the quantity.\n        :param coordinates: Determines which momentum coordinate system to use.\n        :param kwargs:      Keyword arguments passed on to ``matplotlib.Axes.contourf()`` method.\n        \"\"\"\n        if self.momentumgrid is None:\n            raise OutputException(\"Unable to plot kinetic quantity as its momentum grid has not been specified.\")\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        data = None\n        if logarithmic:\n            data = np.log10(self.data[t,r,:])\n        else:\n            data = self.data[t,r,:]\n\n        if data.ndim != 2:\n            raise OutputException(\"Data dimensionality is too high. Unable to visualize kinetic quantity.\")\n\n        if coordinates is None:\n            cp = ax.contourf(self.p1, self.p2, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(self.momentumgrid.getP1TeXName())\n            ax.set_ylabel(self.momentumgrid.getP2TeXName())\n        # Accept 'spherical' or 'spherica' or 'spheric' or ... 's':\n        elif coordinates == 'spherical'[:len(coordinates)]:\n            cp = ax.contourf(self.momentumgrid.P, self.momentumgrid.XI, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'$p$')\n            ax.set_ylabel(r'$\\xi$')\n        elif coordinates == 'cylindrical'[:len(coordinates)]:\n            cp = ax.contourf(self.momentumgrid.PPAR, self.momentumgrid.PPERP, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'$p_\\parallel$')\n            ax.set_ylabel(r'$p_\\perp$')\n        else:\n            raise OutputException(\"Unrecognized coordinate type: '{}'.\".format(coordinates))\n\n        cb = None\n        if genax:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n\n        if show:\n            plt.show(block=False)\n\n        return ax\n        \n        \n        \n    def plotPolar(self, t=-1, r=0, ax=None, show=None, colorbar=True, displayGrid=False, logarithmic=False, thetaMin=0, thetaMax=np.pi, maxMinScale=True, **kwargs):\n        \"\"\"\n        Plot this kinetic quantity on a polar axis.\n        \n        t: Time index to plot\n        ax:   Matplotlib axes object to use for plotting.\n        show: If 'True', shows the plot immediately via a call to\n              'matplotlib.pyplot.show()' with 'block=False'. If\n              'None', this is interpreted as 'True' if 'ax' is\n              also 'None'.\n        colorbar: Specify wether or not to include a colorbar\n        displayGrid: Specify wether or not to display a polar grid in the plot\n        logarithmic: If 'True', plot logarithm of the data\n        thetaMin: Minimum pitch angle included in the plot\n        thetaMax: Maximum pitch angle included in the plot\n        maxMinScale: If 'True', set tha max and min of the color scale to the \n                     maximum and minimum values of the data stored by this object\n                     over all time steps at the radial grid point specified by r\n\n        RETURNS a matplotlib axis object and a colorbar object\n        (which may be 'None' if not used).\n        \"\"\"\n        if self.momentumgrid is None:\n            raise OutputException(\"Unable to plot kinetic quantity as its momentum grid has not been specified.\")\n\n        # As we sometimes do not have very many xi-points, the field line parallel direction can \n        # look \"empty\" if we just plot for the xi-points in the center of the grid cells\n        # Therefore, we extend the pitch-angle grid to cover a whole round (with the first and\n        # last point at the same angle) and then extend the data accordingly, so that contourf\n        # interpolates over the field line parallel direction\n        xi=self.momentumgrid.XI\n        pitch_angle=np.concatenate((-np.arccos(xi),np.flip(np.arccos(xi))))\n        pitch_angle=np.concatenate([pitch_angle,pitch_angle[:1]])\n        \n        p=self.momentumgrid.P\n        p=np.concatenate((p,p))\n        p=np.concatenate([p,p[:1]])\n\n\t\t\n        genax = ax is None\n\n        if genax:\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([p[0,0],p[0,-1]])\n            ax.set_xlim([thetaMin,thetaMax])\n            \n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n\n            if show is None:\n                show = True\n\n        data = None\n        if logarithmic:\n            data = np.log10(self.data[t,r,:])\n        else:\n            data = self.data[t,r,:]\n\n        if data.ndim != 2:\n            raise OutputException(\"Data dimensionality is too high. Unable to visualize kinetic quantity.\")\n            \n        # Duplicate data in accordance with the extension of the pitch angle grid\n        data_plot=np.concatenate((data,np.flip(data,0)))\n        data_plot=np.concatenate((data_plot,data_plot[:1]))\n\t\t    \n        if maxMinScale:\n            if logarithmic:\n                cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',levels=np.linspace(np.log10(np.min(np.abs(self.data[:,r,:]))),np.log10(np.max(np.abs(self.data[:,r,:])))),**kwargs)\n            else:\n                cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',levels=np.linspace(np.min(self.data[:,r,:]),np.max(self.data[:,r,:])),**kwargs)\n        else:\n            cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',**kwargs)\n\t\t   \n        cb = None\n        if colorbar:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n\n        if show:\n            plt.show(block=False)\n\n        return ax, cb\n            \n        \n    def animatePolar(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None,**kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the present quantity, \n        including the specified time steps.\n        \n\n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param int dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        \"\"\"\n        \n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPolar(show=False,t=0,**kwargs)\n        \n        def update_ani(t, kq, ax):\n            ax.clear()\n            ax=kq.plotPolar(colorbar=False, show=False, t=t,**kwargs)\n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n            \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()",
  "def __init__(self, name, data, grid, output, momentumgrid=None, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(KineticQuantity, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.momentumgrid = momentumgrid\n\n        # Cell or flux grid?\n        if momentumgrid.p1.size == data.shape[3]:\n            self.p1 = momentumgrid.p1\n        elif momentumgrid.p1_f.size == data.shape[3]:\n            self.p1 = momentumgrid.p1_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        if momentumgrid.p2.size == data.shape[2]:\n            self.p2 = momentumgrid.p2\n        elif momentumgrid.p2_f.size == data.shape[2]:\n            self.p2 = momentumgrid.p2_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        if grid.r.size == data.shape[1]:\n            self.radius = grid.r\n        elif grid.r_f.size == data.shape[1]:\n            self.radius = grid.r_f\n        else:\n            raise Exception(\"Unrecognized shape of data: {}. Expected (nt, nr, np2, np1) = ({}, {}, {}, {}).\".format(data.shape, grid.t.size, grid.r.size, momentumgrid.p2.size, momentumgrid.p1.size))\n\n        self.time = self.grid.t",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Kinetic quantity of size NT x NR x NP2 x NP1 = {} x {} x {} x {}\\n:: {}\\n:: Evolved using: {}\\n{}'.format(self.name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3], self.description, self.description_eqn, self.data)",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def angleAveraged(self, t=None, r=None, moment='distribution'):\n        r\"\"\"\n        Returns the angle-averaged distribution function. Depending on\n        the input parameters, the whole or only some parts of the spatiotemporal\n        distribution can be angle-averaged.\n\n        This method can only be applied to distributions defined on p/xi\n        momentum grids.\n\n        Supported moments:\n        \n        - ``distribution``: :math:`\\left\\langle f \\right\\rangle_{\\xi_0}`\n        - ``density``: :math:`\\left\\langle V'f\\right\\rangle_{\\xi_0}`\n        - ``current``: :math:`\\left\\langle v\\xi_0 V' f\\right\\rangle_{\\xi_0}`\n        - ...or a vector (or scalar) to weight the distribution function with.\n\n        where :math:`\\left\\langle X \\right\\rangle_{\\xi_0} = \\int_{-1}^1 X\\,\\mathrm{d}\\xi_0`.\n        \"\"\"\n        if self.momentumgrid is None or self.momentumgrid.type != TYPE_PXI:\n            raise OutputException(\"The angle average can only be calculated on p/xi grids.\")\n\n        if t is None: t = slice(None)\n        if r is None: r = slice(None)\n        \n        data = self.data[t,r,:]\n\n        if type(moment) == str:\n            if moment == 'distribution':\n                # Divide by range of xi\n                data = data/2\n            elif moment == 'density':\n                data = data * self.momentumgrid.Vprime_VpVol[r,:]\n            elif moment == 'current':\n                vPar = self.momentumgrid.getBounceAveragedVpar()\n                data = data * vPar[r,:] * self.momentumgrid.Vprime_VpVol[r,:] * scipy.constants.e\n        elif type(moment) == float or type(moment) == np.ndarray:\n            data = data * moment * self.momentumgrid.Vprime_VpVol[r,:]\n        else:\n            raise OutputException(\"Invalid type of parameter 'moment'.\")\n            \n        favg = np.sum(data * self.momentumgrid.DP2[r,:], axis=data.ndim-2)\n\n        return favg",
  "def animate(self, keep=[], r=0, ax=None, repeat=False, repeat_delay=None, speed=None, blit=True, moment='distribution', save=None, dpi=None, **kwargs):\n        \"\"\"\n        Creates an animation of the time evolution of the angle average of\n        this kinetic quantity.\n\n        :param list keep:        List of time indices to keep in the plot.\n        :param r:                Radius to plot angle average for.\n        :param ax:               Axes object to use for plotting.\n        :param bool repeat:      If ``True``, repeats animation after it is finished.\n        :param int repeat_delay: Number of milliseconds to wait before repeating animation.\n        :param int speed:        Number of milliseconds to show each frame.\n        :param bool blit:        If ``True``, use blitting to optimize drawing.\n        :param str moment:       Moment of distribution function to plot (same values as for :py:meth:`DREAM.Output.KineticQuantity.KineticQuantity.angleAveraged`).\n        :param str save:         If provided, saves the animation to the named file instead of showing it.\n        :param int dpi:          Video resolution (if saving animation to file).\n        :param kwargs:           Keyword arguments passed to ``ax.plot()``.\n        \"\"\"\n        show = ax is None\n\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        favg = self.angleAveraged(r=r, moment=moment)\n        def update_ani(num, kq, ax, lines, lbl, favg, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(kq.time[num]*tfac, tunit))\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n            else:\n                idx = None\n\n            # Iterate over radii\n            n = len(lines)\n            for i in range(n):\n                if favg.ndim == 3: d = favg[num,i,:]\n                else: d = favg[num,:]\n\n                line.set_data(kq.p1, d)\n\n                # Keep line after time step has passed?\n                if idx is not None:\n                    keeplines[idx*n+i].set_data(kq.p1, d)\n\n            return (line, lbl) + tuple(keeplines)\n\n        if speed is None:\n            speed = 50\n\n        # Determine number of radii to plot\n        if favg.ndim == 3:\n            nr = favg.shape[1]\n        elif favg.ndim == 2:\n            nr = 1\n        else:\n            raise OutputException(\"Invalid number of dimensions selected to animate.\")\n\n        # Plot at t=0\n        colors = GeriMap.get(N=favg.ndim)\n        lines = []\n        for i in range(nr):\n            # Select data to plot\n            if favg.ndim == 3: d = favg[0,i,:]\n            else: d = favg[0,:]\n\n            if 'color' not in kwargs:\n                line, = ax.semilogy(self.p1, d, color=colors(i/(nr+1)), **kwargs)\n            else:\n                line, = ax.semilogy(self.p1, d, **kwargs)\n\n            lines.append(line)\n\n        # Create placeholders for the 'keep' lines\n        keeplines = []\n        if keep is not None:\n            for i in range(len(keep)):\n                for j in range(nr):\n                    if 'color' not in kwargs:\n                        l, = ax.plot([], [], linewidth=2, color=colors(j/(nr+1)), **kwargs)\n                    else:\n                        l, = ax.plot([], [], linewidth=2, **kwargs)\n\n                    keeplines.append(l)\n\n        # Set x/y limits\n        fmax = np.amax(favg)\n        xmin, xmax = self.p1[0], self.p1[-1]\n        ymin, ymax = 1e-30*fmax, 10*fmax\n        ax.set_xlim([xmin, xmax])\n        ax.set_ylim([ymin ,ymax])\n\n        # Determine the relevant time scale\n        tmax = self.time[-1]\n        idx  = 0\n        tfac = 1\n        tunits = ['s', 'ms', '\u00b5s', 'ns', 'ps']\n        while tmax*tfac < 1 and idx < len(tunits)-1:\n            idx += 1\n            tfac = (1e3)**(idx)\n\n        xp, yp = 0.60, 0.93\n        lymin, lymax = np.log10(ymin), np.log10(ymax)\n        tx = xmin+xp*(xmax-xmin)\n        ty = lymin+yp*(lymax-lymin)\n        txt = ax.text(tx, 10**ty, r't = {:.3f} {}'.format(self.time[0]*tfac, tunits[idx]), usetex=False)\n\n        ax.set_xlabel(r'$r/a$ (m)')\n\n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=self.time.size,\n            interval=speed, repeat_delay=repeat_delay, repeat=repeat, blit=blit,\n            fargs=(self, ax, lines, txt, favg, keeplines, tfac, tunits[idx], keep))\n\n        # Save animation?\n        if save:\n            writer = animation.FFMpegFileWriter(fps=1000/speed)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\n        if show:\n            plt.show()\n\n        return ani",
  "def get(self, t=None, r=None, p2=None, p1=None):\n        \"\"\"\n        Returns data using the specified indexing. If an argument is ``None``,\n        this method will return all elements along that dimension.\n        \"\"\"\n        sel = [slice(None)] * 4\n\n        if t  is not None: sel[0] = t\n        if r  is not None: sel[1] = r\n        if p2 is not None: sel[2] = p2\n        if p1 is not None: sel[3] = p1\n\n        return self.data[tuple(sel)]",
  "def moment(self, weight, t=None, r=None):\n        \"\"\"\n        Evaluate a moment of this distribution function with the given weighting\n        factor.\n        \"\"\"\n        if t is None:\n            t = range(len(self.time))\n        if r is None:\n            r = range(len(self.grid.r))\n\n        if np.isscalar(t):\n            t = np.asarray([t])\n        if np.isscalar(r):\n            r = np.asarray([r])\n\n        if np.ndim(weight) != 4:\n            _weight = np.ones((self.time.size,self.grid.r.size,self.momentumgrid.p2.size,self.momentumgrid.p1.size))\n            \n            if np.ndim(weight) == 0:\n                weight = _weight*weight\n            if np.ndim(weight) == 1:\n                weight = _weight*weight[np.newaxis,np.newaxis,np.newaxis,:]\n            elif np.ndim(weight) == 2:\n                weight = _weight*weight[np.newaxis,np.newaxis,:]\n            elif np.ndim(weight) == 3:\n                weight = _weight*weight[np.newaxis,:]\n                \n        q = np.zeros((len(t), len(r)))\n        for iT in range(len(t)):\n            for iR in range(len(r)):\n                q[iT,iR] = self.momentumgrid.integrate2D(self.data[t[iT],r[iR],:] * weight[t[iT],r[iR],:])[0]\n        \n        return q",
  "def plot(self, t=-1, r=0, ax=None, show=None, logarithmic=False, coordinates=None, **kwargs):\n        \"\"\"\n        Visualize this kinetic quantity at one time and radius using a filled\n        contour plot.\n\n        :param t:           Time index to visualize quantity at.\n        :param r:           Radial index to visualize quantity at.\n        :param ax:          Matplotlib Axes object to draw plot on.\n        :param show:        If ``True``, calls ``matplotlib.pyplot.show()`` with ``block=False`` after plotting the quantity.\n        :param logarithmic: If ``True``, plots the base-10 logarithm of the quantity.\n        :param coordinates: Determines which momentum coordinate system to use.\n        :param kwargs:      Keyword arguments passed on to ``matplotlib.Axes.contourf()`` method.\n        \"\"\"\n        if self.momentumgrid is None:\n            raise OutputException(\"Unable to plot kinetic quantity as its momentum grid has not been specified.\")\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        data = None\n        if logarithmic:\n            data = np.log10(self.data[t,r,:])\n        else:\n            data = self.data[t,r,:]\n\n        if data.ndim != 2:\n            raise OutputException(\"Data dimensionality is too high. Unable to visualize kinetic quantity.\")\n\n        if coordinates is None:\n            cp = ax.contourf(self.p1, self.p2, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(self.momentumgrid.getP1TeXName())\n            ax.set_ylabel(self.momentumgrid.getP2TeXName())\n        # Accept 'spherical' or 'spherica' or 'spheric' or ... 's':\n        elif coordinates == 'spherical'[:len(coordinates)]:\n            cp = ax.contourf(self.momentumgrid.P, self.momentumgrid.XI, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'$p$')\n            ax.set_ylabel(r'$\\xi$')\n        elif coordinates == 'cylindrical'[:len(coordinates)]:\n            cp = ax.contourf(self.momentumgrid.PPAR, self.momentumgrid.PPERP, data, cmap='GeriMap', **kwargs)\n            ax.set_xlabel(r'$p_\\parallel$')\n            ax.set_ylabel(r'$p_\\perp$')\n        else:\n            raise OutputException(\"Unrecognized coordinate type: '{}'.\".format(coordinates))\n\n        cb = None\n        if genax:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def plotPolar(self, t=-1, r=0, ax=None, show=None, colorbar=True, displayGrid=False, logarithmic=False, thetaMin=0, thetaMax=np.pi, maxMinScale=True, **kwargs):\n        \"\"\"\n        Plot this kinetic quantity on a polar axis.\n        \n        t: Time index to plot\n        ax:   Matplotlib axes object to use for plotting.\n        show: If 'True', shows the plot immediately via a call to\n              'matplotlib.pyplot.show()' with 'block=False'. If\n              'None', this is interpreted as 'True' if 'ax' is\n              also 'None'.\n        colorbar: Specify wether or not to include a colorbar\n        displayGrid: Specify wether or not to display a polar grid in the plot\n        logarithmic: If 'True', plot logarithm of the data\n        thetaMin: Minimum pitch angle included in the plot\n        thetaMax: Maximum pitch angle included in the plot\n        maxMinScale: If 'True', set tha max and min of the color scale to the \n                     maximum and minimum values of the data stored by this object\n                     over all time steps at the radial grid point specified by r\n\n        RETURNS a matplotlib axis object and a colorbar object\n        (which may be 'None' if not used).\n        \"\"\"\n        if self.momentumgrid is None:\n            raise OutputException(\"Unable to plot kinetic quantity as its momentum grid has not been specified.\")\n\n        # As we sometimes do not have very many xi-points, the field line parallel direction can \n        # look \"empty\" if we just plot for the xi-points in the center of the grid cells\n        # Therefore, we extend the pitch-angle grid to cover a whole round (with the first and\n        # last point at the same angle) and then extend the data accordingly, so that contourf\n        # interpolates over the field line parallel direction\n        xi=self.momentumgrid.XI\n        pitch_angle=np.concatenate((-np.arccos(xi),np.flip(np.arccos(xi))))\n        pitch_angle=np.concatenate([pitch_angle,pitch_angle[:1]])\n        \n        p=self.momentumgrid.P\n        p=np.concatenate((p,p))\n        p=np.concatenate([p,p[:1]])\n\n\t\t\n        genax = ax is None\n\n        if genax:\n            ax = plt.subplot(polar=True)\n            ax.set_facecolor('k')\n            ax.set_ylim([p[0,0],p[0,-1]])\n            ax.set_xlim([thetaMin,thetaMax])\n            \n            if not displayGrid:\n                ax.grid(None)\n                ax.set_yticklabels([])\n                ax.set_xticklabels([])\n\n            if show is None:\n                show = True\n\n        data = None\n        if logarithmic:\n            data = np.log10(self.data[t,r,:])\n        else:\n            data = self.data[t,r,:]\n\n        if data.ndim != 2:\n            raise OutputException(\"Data dimensionality is too high. Unable to visualize kinetic quantity.\")\n            \n        # Duplicate data in accordance with the extension of the pitch angle grid\n        data_plot=np.concatenate((data,np.flip(data,0)))\n        data_plot=np.concatenate((data_plot,data_plot[:1]))\n\t\t    \n        if maxMinScale:\n            if logarithmic:\n                cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',levels=np.linspace(np.log10(np.min(np.abs(self.data[:,r,:]))),np.log10(np.max(np.abs(self.data[:,r,:])))),**kwargs)\n            else:\n                cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',levels=np.linspace(np.min(self.data[:,r,:]),np.max(self.data[:,r,:])),**kwargs)\n        else:\n            cp=ax.contourf(pitch_angle,p,data_plot,cmap='GeriMap',**kwargs)\n\t\t   \n        cb = None\n        if colorbar:\n            cb = plt.colorbar(mappable=cp, ax=ax)\n\n        if show:\n            plt.show(block=False)\n\n        return ax, cb",
  "def animatePolar(self, t=None, repeat=False, repeat_delay=None, speed=None, dpi=100, save=None,**kwargs):\n        \"\"\"\n        Make an animation of poloidal plots of the present quantity, \n        including the specified time steps.\n        \n\n        :param slice t: time steps to include in the animation\n        :param bool repeat: If ``True``, repeats the animation.\n        :param int repeat_delay: Time between consecutive animation runs in milliseconds\n        :param int speed: delay between frames in milliseconds\n        :param int dpi: animation resolution\n        :param str save: title of the file (if any) into which the animation is saved\n        \"\"\"\n        \n        fig, ax=plt.subplots(1,1)\n        \n        if t is None:\n            t=range(len(self.grid.t))\n            \n        ax,cb=self.plotPolar(show=False,t=0,**kwargs)\n        \n        def update_ani(t, kq, ax):\n            ax.clear()\n            ax=kq.plotPolar(colorbar=False, show=False, t=t,**kwargs)\n            \n        # Create the animation\n        ani = animation.FuncAnimation(fig, update_ani, frames=t,\n            repeat=repeat, repeat_delay=repeat_delay, interval=speed,\n            fargs=(self, ax))\n            \n        if save:\n            # Make animation\n            writer = animation.FFMpegFileWriter(fps=fps)\n            writer.setup(fig, save, dpi=dpi)\n            ani.save(save, writer=writer)\n            print(\"Done saving video to '{}'.\".format(save))\n\t\t            \n        plt.show()",
  "def update_ani(num, kq, ax, lines, lbl, favg, keeplines, tfac, tunit, keep):\n            lbl.set_text(r't = {:.3f} {}'.format(kq.time[num]*tfac, tunit))\n\n            if keep is not None and num in keep:\n                idx = keep.index(num)\n            else:\n                idx = None\n\n            # Iterate over radii\n            n = len(lines)\n            for i in range(n):\n                if favg.ndim == 3: d = favg[num,i,:]\n                else: d = favg[num,:]\n\n                line.set_data(kq.p1, d)\n\n                # Keep line after time step has passed?\n                if idx is not None:\n                    keeplines[idx*n+i].set_data(kq.p1, d)\n\n            return (line, lbl) + tuple(keeplines)",
  "def update_ani(t, kq, ax):\n            ax.clear()\n            ax=kq.plotPolar(colorbar=False, show=False, t=t,**kwargs)",
  "class IonHandler(UnknownQuantity):\n\n    \n    def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(IonHandler, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.meta = output.ionmeta\n        self.ions = list()\n\n        # Verify that data is consistent\n        nZ0 = sum([Z+1 for Z in self.meta.Z])\n        if nZ0 != data.shape[1]:\n            raise OutputException(\"Inconsistent size of data array. Expected nZ0 = {}, but it was {}.\"\n                .format(nZ0, data.shape[1]))\n\n        # Add ions\n        iidx = 0\n        for name, Z in zip(self.meta.names, self.meta.Z):\n            self.addIon(name=name, Z=Z, data=data[:,iidx:(iidx+Z+1),:], attr=attr)\n            iidx += Z+1\n\n\n    def __getitem__(self, i):\n        \"\"\"\n        If i is a string, retrieves an 'IonSpecies' object by name.\n        Otherwise, if i is an integer, returns the ion by index.\n\n        If also Z0 is specified (and is an integer), returns an\n        'IonState' object corresponding to the selected charge state.\n        \"\"\"\n        idx, Z0 = None, None\n\n        ion = None\n        if type(i) == str:\n            ion = self.getIonByName(i)\n        else:\n            if len(i) == 2:\n                idx = i[0]\n                Z0 = i[1]\n            else:\n                idx = i\n\n            ion = self.ions[idx]\n\n        if Z0 is not None:\n            return ion[Z0]\n        else:\n            return ion\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this IonHandler to an \"official\" string representation.\n        \"\"\"\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this IonHandler object to a string.\n        \"\"\"\n        # TODO also show relative abundance\n        s = \"{} ion species\\n\".format(len(self.ions))\n        for ion in self.ions:\n            s += \"   {:2s} (Z = {:3d})  {:.3e} particles\\n\".format(ion.getName(), ion.getCharge(), ion.getParticleNumber())\n        \n        return s\n\n\n    def addIon(self, name, Z, data, attr=list()):\n        \"\"\"\n        Adds a new ion to the list of ions.\n        \"\"\"\n        self.ions.append(IonSpecies(name=name, Z=Z, data=data, grid=self.grid, output=self.output, attr=attr))\n    \n    \n    def getIonByName(self, name):\n        \"\"\"\n        Returns the ion with the specified name.\n        \"\"\"\n        for ion in self.ions:\n            if ion.getName() == name:\n                return ion\n\n        raise KeyError(\"No ion named '{}' found in the output.\".format(name))\n\n\n    def getIonOffset(self, name, Z0=0):\n        \"\"\"\n        Returns the array index of the named ion species (and charge state)\n        which can be used to index a vector with all ion species located one\n        after another.\n        \"\"\"\n        return self.meta.getIonOffset(name=name, Z0=Z0)\n\n\n    def ionNameToIndex(self, name):\n        \"\"\"\n        Returns the index of the named ion species.\n        \"\"\"\n        for i in range(len(self.ions)):\n            if self.ions[i].getName() == name:\n                return i\n\n        raise KeyError(\"No ion named '{}' found in the output.\".format(name))\n\n\n    def plot(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the ion charge state densities.\n        \"\"\"\n        self.histogram(t=t, ax=ax, show=show, **kwargs)\n\n\n    def histogram(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Create a histogram of the ion charge state densities.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        x = [0]\n        y = [0]\n        labels = ['']\n        for i in range(len(self.ions)):\n            ion = self.ions[i]\n            for state in ion.ionstates:\n                x.append(x[-1]+1)\n                y.append(state.integral(t=t))\n                labels.append(state.getRomanName())\n        \n        x = x[1:]\n        y = y[1:]\n        labels = labels[1:]\n\n        #ax.hist(y, weights=x)\n        ax.bar(x, y, tick_label=labels, **kwargs)\n        lbls = ax.get_xticklabels()\n        plt.setp(lbls, rotation=45)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "def __init__(self, name, data, grid, output, attr=list()):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super(IonHandler, self).__init__(name=name, data=data, attr=attr, grid=grid, output=output)\n\n        self.meta = output.ionmeta\n        self.ions = list()\n\n        # Verify that data is consistent\n        nZ0 = sum([Z+1 for Z in self.meta.Z])\n        if nZ0 != data.shape[1]:\n            raise OutputException(\"Inconsistent size of data array. Expected nZ0 = {}, but it was {}.\"\n                .format(nZ0, data.shape[1]))\n\n        # Add ions\n        iidx = 0\n        for name, Z in zip(self.meta.names, self.meta.Z):\n            self.addIon(name=name, Z=Z, data=data[:,iidx:(iidx+Z+1),:], attr=attr)\n            iidx += Z+1",
  "def __getitem__(self, i):\n        \"\"\"\n        If i is a string, retrieves an 'IonSpecies' object by name.\n        Otherwise, if i is an integer, returns the ion by index.\n\n        If also Z0 is specified (and is an integer), returns an\n        'IonState' object corresponding to the selected charge state.\n        \"\"\"\n        idx, Z0 = None, None\n\n        ion = None\n        if type(i) == str:\n            ion = self.getIonByName(i)\n        else:\n            if len(i) == 2:\n                idx = i[0]\n                Z0 = i[1]\n            else:\n                idx = i\n\n            ion = self.ions[idx]\n\n        if Z0 is not None:\n            return ion[Z0]\n        else:\n            return ion",
  "def __repr__(self):\n        \"\"\"\n        Convert this IonHandler to an \"official\" string representation.\n        \"\"\"\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this IonHandler object to a string.\n        \"\"\"\n        # TODO also show relative abundance\n        s = \"{} ion species\\n\".format(len(self.ions))\n        for ion in self.ions:\n            s += \"   {:2s} (Z = {:3d})  {:.3e} particles\\n\".format(ion.getName(), ion.getCharge(), ion.getParticleNumber())\n        \n        return s",
  "def addIon(self, name, Z, data, attr=list()):\n        \"\"\"\n        Adds a new ion to the list of ions.\n        \"\"\"\n        self.ions.append(IonSpecies(name=name, Z=Z, data=data, grid=self.grid, output=self.output, attr=attr))",
  "def getIonByName(self, name):\n        \"\"\"\n        Returns the ion with the specified name.\n        \"\"\"\n        for ion in self.ions:\n            if ion.getName() == name:\n                return ion\n\n        raise KeyError(\"No ion named '{}' found in the output.\".format(name))",
  "def getIonOffset(self, name, Z0=0):\n        \"\"\"\n        Returns the array index of the named ion species (and charge state)\n        which can be used to index a vector with all ion species located one\n        after another.\n        \"\"\"\n        return self.meta.getIonOffset(name=name, Z0=Z0)",
  "def ionNameToIndex(self, name):\n        \"\"\"\n        Returns the index of the named ion species.\n        \"\"\"\n        for i in range(len(self.ions)):\n            if self.ions[i].getName() == name:\n                return i\n\n        raise KeyError(\"No ion named '{}' found in the output.\".format(name))",
  "def plot(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the ion charge state densities.\n        \"\"\"\n        self.histogram(t=t, ax=ax, show=show, **kwargs)",
  "def histogram(self, t=-1, ax=None, show=None, **kwargs):\n        \"\"\"\n        Create a histogram of the ion charge state densities.\n        \"\"\"\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        x = [0]\n        y = [0]\n        labels = ['']\n        for i in range(len(self.ions)):\n            ion = self.ions[i]\n            for state in ion.ionstates:\n                x.append(x[-1]+1)\n                y.append(state.integral(t=t))\n                labels.append(state.getRomanName())\n        \n        x = x[1:]\n        y = y[1:]\n        labels = labels[1:]\n\n        #ax.hist(y, weights=x)\n        ax.bar(x, y, tick_label=labels, **kwargs)\n        lbls = ax.get_xticklabels()\n        plt.setp(lbls, rotation=45)\n\n        if show:\n            plt.show(block=False)\n\n        return ax",
  "class IonThermalEnergy(IonSpeciesFluidQuantity):\n    \n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n\n    def getTemperature(self, ion=None):\n        \"\"\"\n        Returns the temperature of the named ion species. If no\n        ion name is provided, a compound ion temperature object\n        is returned, containing T_i for all ions.\n        \"\"\"\n        ec = scipy.constants.e\n\n        if ion is None:\n            W_i = self.data[:]\n            N_i = self.output.eqsys.N_i.data[:]\n            T_i = (2/3) * (W_i/ec) / N_i\n\n            return IonSpeciesFluidQuantity(name='T_i', data=T_i, grid=self.grid, output=self.output, attr=self.attr)\n        else:\n            W_i = self[ion][:]\n            N_i = self.output.eqsys.N_i[ion][:]\n            T_i = (2/3) * (W_i/ec) / N_i\n\n            return FluidQuantity(name=f'Ti_{ion}', data=T_i, grid=self.grid, output=self.output, attr=self.attr)\n\n\n    def plotTemperature(self, ion=None, ax=None, show=None, r=None, t=None, *args, **kwargs):\n        \"\"\"\n        Plot ion temperature\n        \"\"\"\n        T_i = self.getTemperature(ion)\n        return T_i.plot(ax=ax, show=show, r=r, t=t, *args, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)",
  "def getTemperature(self, ion=None):\n        \"\"\"\n        Returns the temperature of the named ion species. If no\n        ion name is provided, a compound ion temperature object\n        is returned, containing T_i for all ions.\n        \"\"\"\n        ec = scipy.constants.e\n\n        if ion is None:\n            W_i = self.data[:]\n            N_i = self.output.eqsys.N_i.data[:]\n            T_i = (2/3) * (W_i/ec) / N_i\n\n            return IonSpeciesFluidQuantity(name='T_i', data=T_i, grid=self.grid, output=self.output, attr=self.attr)\n        else:\n            W_i = self[ion][:]\n            N_i = self.output.eqsys.N_i[ion][:]\n            T_i = (2/3) * (W_i/ec) / N_i\n\n            return FluidQuantity(name=f'Ti_{ion}', data=T_i, grid=self.grid, output=self.output, attr=self.attr)",
  "def plotTemperature(self, ion=None, ax=None, show=None, r=None, t=None, *args, **kwargs):\n        \"\"\"\n        Plot ion temperature\n        \"\"\"\n        T_i = self.getTemperature(ion)\n        return T_i.plot(ax=ax, show=show, r=r, t=t, *args, **kwargs)",
  "class OtherKineticQuantity(KineticQuantity):\n    \n\n    def __init__(self, name, data, description, grid, output, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherKineticQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output, momentumgrid=momentumgrid)\n\n        self.time = grid.t[1:]\n\n\n    def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other kinetic quantity of size NT x NR x NP2 x NP1 = {} x {} x {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3])\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def __init__(self, name, data, description, grid, output, momentumgrid=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        attr = {'description': description}\n        super(OtherKineticQuantity, self).__init__(name=name, data=data, grid=grid, attr=attr, output=output, momentumgrid=momentumgrid)\n\n        self.time = grid.t[1:]",
  "def __repr__(self):\n        \"\"\"\n        Convert this object to an \"official\" string.\n        \"\"\"\n        #s = self.__str__() \n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        Convert this object to a string.\n        \"\"\"\n        return '({}) Other kinetic quantity of size NT x NR x NP2 x NP1 = {} x {} x {} x {}'.format(self.name, self.data.shape[0], self.data.shape[1], self.data.shape[2], self.data.shape[3])",
  "def __getitem__(self, index):\n        \"\"\"\n        Direct access to data.\n        \"\"\"\n        return self.data[index]",
  "def getConnorHastieRunawayRate(T, n, E, Zeff, with_corrections=True):\n    \"\"\"\n    Calculates the runaway rate according to the formula given by Connor & Hastie.\n\n    :param float T:               Electron temperature (eV).\n    :param float n:               Electron density (m^-3).\n    :param float E:               Electric field strength (V/m).\n    :param float Zeff:            Plasma effective charge.\n    :param bool with_corrections: If ``True``, includes the weak electric field limit corrections to the runaway rate.\n    \"\"\"\n    if E == 0: return 0.0\n\n    Ec = getEc(T, n)\n    if Ec >= E: return 0.0\n\n    ED = getED(T, n)\n    tauEE = getTauEETh(T, n)\n\n    EEc = E/Ec\n    EED = E/ED\n\n    # \"Undetermined\" factor (~1 is usually good according to simulations!)\n    C = 1.0\n    h, eta, lmbd = (1.0,)*3\n    \n    if with_corrections:\n        h    = 1.0/(3*(EEc-1)) * (EEc + 2*(EEc-2)*np.sqrt(EEc/(EEc-1)) - (Zeff-7)/(Zeff+1))\n        etaf = np.pi/2 - np.arcsin(1-2/EEc)\n        eta  = EEc*EEc/(4*(EEc-1)) * etaf**2\n        lmbd = 8*EEc**2 * (1-1/(2*EEc) - np.sqrt(1-1/EEc))\n\n    alpha = -3/16*(1+Zeff)*h\n    return C*n/tauEE * np.power(EED, alpha) * np.exp(-lmbd/(4*EED) - np.sqrt(eta*(1+Zeff)/EED))",
  "def getRelativisticMaxwellJuttnerDistribution(p,T,n):\n    \"\"\"\n    Calculates the relativistic Maxwell-J\u00fcttner distribution.\n\n    :param float p: Momentum in units of m_e*c\n    :param float T: Plasma temperature (eV)\n    :param float n: Plasma density (m^-3)\n    \"\"\"\n    mc2inEV = scipy.constants.m_e*scipy.constants.c*scipy.constants.c / scipy.constants.elementary_charge\n    Theta = T / mc2inEV\n    K2scaled = scipy.special.kve(2,1/Theta) # scaled bessel function \n    tK2exp = 4*np.pi*Theta*K2scaled # normalization factor\n    p2 = p**2\n    g = np.sqrt(1+p2)\n    gMinus1 = p2/(g+1) \n    expTerm = np.exp(-gMinus1/Theta)\n\n    return n * expTerm / tK2exp",
  "def getCoulombLogarithm(T, n):\n    \"\"\"\n    Calculates the Coulomb logarithm according to the formula given in\n    Wesson's book \"Tokamaks\".\n\n    :param float T: Plasma temperature (eV).\n    :param float n: Plasma density (m^-3).\n    \"\"\"\n    return 14.9 - 0.5*np.log(n / 1e20) + np.log(T / 1e3)",
  "def getEc(T, n):\n    \"\"\"\n    Calculates the Connor-Hastie critical electric field, below which no\n    runaway electrons can be generated.\n\n    :param float T: Plasma temperature (eV).\n    :param float n: Plasma density (m^-3).\n    \"\"\"\n    logLambda = getCoulombLogarithm(T, n)\n\n    c = scipy.constants.c\n    e = scipy.constants.e\n    me = scipy.constants.m_e\n    eps0 = scipy.constants.epsilon_0\n\n    return (n*logLambda*e**3) / (4*np.pi*eps0**2 * me * c**2)",
  "def getConnorHastieCriticalField(T, n): return getEc(T, n)",
  "def getED(T, n):\n    \"\"\"\n    Calculates the Dreicer electric field at the given plasma temperature and\n    density, giving the electric field at which all electrons are accelerated\n    to the runaway region.\n\n    :param float T: Plasma temperature (eV).\n    :param float n: Plasma density (m^-3).\n    \"\"\"\n    c = scipy.constants.c\n    e = scipy.constants.e\n    me = scipy.constants.m_e\n\n    Ec = getEc(T, n)\n\n    return Ec * me * c**2 / (e*T)",
  "def getDreicerElectricField(T, n): return getED(T, N)",
  "def getTauEETh(T, n):\n    \"\"\"\n    Calculates the thermal electron-electron collision frequency.\n\n    :param float T: Plasma temperature (eV).\n    :param float n: Plasma density (m^-3).\n    \"\"\"\n    mc2  = scipy.constants.physical_constants['electron mass energy equivalent in MeV'][0] * 1e6\n    betaTh2 = getBetaThermal(T)**2\n\n    return getTauEERel(T, n) * betaTh2*np.sqrt(betaTh2)",
  "def getThermalElectronCollisionFrequency(T, n): return getTauEETh(T, n)",
  "def getBetaThermal(T): return getNormalizedThermalSpeed(T)",
  "def getNormalizedThermalSpeed(T):\n    \"\"\"\n    Calculates the thermal electron speed, v_{th}, normalized\n    to the speed of light in vacuum.\n    \"\"\"\n    return getThermalSpeed(T) / scipy.constants.c",
  "def getThermalSpeed(T):\n    \"\"\"\n    Calculates the thermal electron speed, v_{th}, for the given\n    plasma temperature.\n\n    :param float T: Electron temperature.\n    \"\"\"\n    return np.sqrt(2*scipy.constants.e*T / scipy.constants.m_e)",
  "def getTauEERel(T, n):\n    \"\"\"\n    Calculates the relativistic electron-electron collision frequency.\n\n    :param float T: Plasma temperature (eV).\n    :param float n: Plasma density (m^-3).\n    \"\"\"\n    c = scipy.constants.c\n    e = scipy.constants.e\n    me = scipy.constants.m_e\n    r0 = scipy.constants.physical_constants['classical electron radius'][0]\n\n    C = 4*np.pi * r0**2 * c\n    logLambda = getCoulombLogarithm(T, n)\n\n    return 1/(logLambda * n * C)",
  "def getRelativisticElectronCollisionFrequency(T, n): return getTauEERel(T, n)",
  "class ToleranceSettings:\n    \n    def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        # General absolute and relative tolerances (applied to\n        # unknowns without explicit tolerances)\n        self.reltol = 1e-6\n        self.overrides = []\n\n\n    def disable(self, unknown=None):\n        \"\"\"\n        Disable tolerance checking for the given unknowns. If 'unknown'\n        is ``None``, tolerance checking is disabled for all unknowns.\n        This can be reset for each unknown by explicitly calling\n        :automethod:`set` for them.\n        \"\"\"\n        if unknown is None:\n            self.reltol = 0.0\n            self.overrides = []\n        elif type(unknown) == str:\n            self.set(unknown, abstol=0, reltol=0)\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, abstol=0, reltol=0)\n        else:\n            raise DREAMException(\"Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))\n\n\n    def getRelTol(self, unknown):\n        \"\"\"\n        Returns the relative tolerance of the named unknown.\n        \"\"\"\n        i = self.getIndex(unknown)\n        if i < 0:\n            return self.reltol\n        else:\n            return self.overrides[i]['reltol']\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load tolerance settings from a dictionary.\n        \"\"\"\n        if 'reltol' in data:\n            r = data['reltol']\n            if type(r) == float: self.reltol = r\n            else: self.reltol = float(r[0])\n\n        overrides = []\n\n        if 'names' in data:\n            if 'abstols' not in data:\n                raise DREAMException(\"'names' setting present, but no 'abstols' setting found.\")\n            if 'reltols' not in data:\n                raise DREAMException(\"'names' setting present, but no 'reltols' setting found.\")\n                \n            names = data['names'].split(';')[:-1]\n            for i in range(len(names)):\n                atol = data['abstols'][i]\n                rtol = data['reltols'][i]\n\n                l = {'name': names[i], 'abstol': float(atol), 'reltol': float(rtol)}\n                overrides.append(l)\n\n            self.overrides = overrides\n\n    \n    def getIndex(self, unknown):\n        \"\"\"\n        Returns the index into the 'overrides' list for the\n        given unknown. If the returned value is '-1', no\n        override exists for the quantity and the general\n        absolute and relative tolerances are used instead.\n        \"\"\"\n        for i in range(0, len(self.overrides)):\n            if self.overrides[i]['name'] == unknown:\n                return i\n        \n        return -1\n\n\n    def set(self, unknown=None, abstol=None, reltol=None):\n        \"\"\"\n        Set the absolute and relative tolerance of one or more unknown\n        quantities.\n\n        :param unknown: A string or list of strings specifying the name(s) of the quantity/ies to set the tolerances for. If 'None', the tolerances are applied to all unknowns.\n        :param float abstol: Absolut tolerance to set for unknown.\n        :param float reltol: Relative tolerance to set for unknown.\n        \"\"\"\n        if unknown is None:\n            if reltol is None:\n                raise Exception('If no unknown is specified, the default relative tolerance to use for the system must be specified.')\n\n            self.reltol = float(reltol)\n            self.overrides = []\n        elif type(unknown) == str:\n            t = self.getIndex(unknown)\n\n            # Append to list or overwrite existing element?\n            if t < 0:\n                if abstol is None: abstol = 0\n                if reltol is None: reltol = self.reltol\n\n                self.overrides.append({'name': unknown, 'abstol': float(abstol), 'reltol': float(reltol)})\n            else:\n                if abstol is not None:\n                    self.overrides[t]['abstol'] = float(abstol)\n                if reltol is not None:\n                    self.overrides[t]['reltol'] = float(reltol)\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, abstol=abstol, reltol=reltol)\n        else:\n            raise DREAMException(\"ToleranceSettings.set(): Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))\n\n\n    def todict(self):\n        \"\"\"\n        Convert this object to a dict.\n        \"\"\"\n        data = {'reltol': self.reltol}\n\n        if len(self.overrides) > 0:\n            data['names'] = ''\n            data['abstols'] = []\n            data['reltols'] = []\n            for u in self.overrides:\n                data['names'] += '{};'.format(u['name'])\n                data['abstols'].append(u['abstol'])\n                data['reltols'].append(u['reltol'])\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        if type(self.reltol) is not float:\n            raise DREAMException(\"Invalid type of general relative tolerance: {}. Expected float.\".format(type(self.reltol)))\n\n\n        for i in range(len(self.overrides)):\n            u = self.overrides[i]\n            if ('name' not in u) or ('abstol' not in u) or ('reltol' not in u):\n                raise DREAMException(\"Incomplete override at index {}.\".format(i))\n            elif type(u['abstol']) is not float:\n                raise DREAMException(\"Invalid type of absolute tolerance for unknown '{}': {}. Expected float.\".format(u['name'], type(u['abstol'])))\n            elif type(u['reltol']) is not float:\n                raise DREAMException(\"Invalid type of relative tolerance for unknown '{}': {}. Expected float.\".format(u['name'], type(u['reltol'])))\n\n            if u['name'] not in EquationSystem.UNKNOWNS:\n                print(\"WARNING: No unknown quantity with name '{}' is available in DREAM. Tolerance setting will be ignored...\".format(u['name']))",
  "def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        # General absolute and relative tolerances (applied to\n        # unknowns without explicit tolerances)\n        self.reltol = 1e-6\n        self.overrides = []",
  "def disable(self, unknown=None):\n        \"\"\"\n        Disable tolerance checking for the given unknowns. If 'unknown'\n        is ``None``, tolerance checking is disabled for all unknowns.\n        This can be reset for each unknown by explicitly calling\n        :automethod:`set` for them.\n        \"\"\"\n        if unknown is None:\n            self.reltol = 0.0\n            self.overrides = []\n        elif type(unknown) == str:\n            self.set(unknown, abstol=0, reltol=0)\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, abstol=0, reltol=0)\n        else:\n            raise DREAMException(\"Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))",
  "def getRelTol(self, unknown):\n        \"\"\"\n        Returns the relative tolerance of the named unknown.\n        \"\"\"\n        i = self.getIndex(unknown)\n        if i < 0:\n            return self.reltol\n        else:\n            return self.overrides[i]['reltol']",
  "def fromdict(self, data):\n        \"\"\"\n        Load tolerance settings from a dictionary.\n        \"\"\"\n        if 'reltol' in data:\n            r = data['reltol']\n            if type(r) == float: self.reltol = r\n            else: self.reltol = float(r[0])\n\n        overrides = []\n\n        if 'names' in data:\n            if 'abstols' not in data:\n                raise DREAMException(\"'names' setting present, but no 'abstols' setting found.\")\n            if 'reltols' not in data:\n                raise DREAMException(\"'names' setting present, but no 'reltols' setting found.\")\n                \n            names = data['names'].split(';')[:-1]\n            for i in range(len(names)):\n                atol = data['abstols'][i]\n                rtol = data['reltols'][i]\n\n                l = {'name': names[i], 'abstol': float(atol), 'reltol': float(rtol)}\n                overrides.append(l)\n\n            self.overrides = overrides",
  "def getIndex(self, unknown):\n        \"\"\"\n        Returns the index into the 'overrides' list for the\n        given unknown. If the returned value is '-1', no\n        override exists for the quantity and the general\n        absolute and relative tolerances are used instead.\n        \"\"\"\n        for i in range(0, len(self.overrides)):\n            if self.overrides[i]['name'] == unknown:\n                return i\n        \n        return -1",
  "def set(self, unknown=None, abstol=None, reltol=None):\n        \"\"\"\n        Set the absolute and relative tolerance of one or more unknown\n        quantities.\n\n        :param unknown: A string or list of strings specifying the name(s) of the quantity/ies to set the tolerances for. If 'None', the tolerances are applied to all unknowns.\n        :param float abstol: Absolut tolerance to set for unknown.\n        :param float reltol: Relative tolerance to set for unknown.\n        \"\"\"\n        if unknown is None:\n            if reltol is None:\n                raise Exception('If no unknown is specified, the default relative tolerance to use for the system must be specified.')\n\n            self.reltol = float(reltol)\n            self.overrides = []\n        elif type(unknown) == str:\n            t = self.getIndex(unknown)\n\n            # Append to list or overwrite existing element?\n            if t < 0:\n                if abstol is None: abstol = 0\n                if reltol is None: reltol = self.reltol\n\n                self.overrides.append({'name': unknown, 'abstol': float(abstol), 'reltol': float(reltol)})\n            else:\n                if abstol is not None:\n                    self.overrides[t]['abstol'] = float(abstol)\n                if reltol is not None:\n                    self.overrides[t]['reltol'] = float(reltol)\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, abstol=abstol, reltol=reltol)\n        else:\n            raise DREAMException(\"ToleranceSettings.set(): Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))",
  "def todict(self):\n        \"\"\"\n        Convert this object to a dict.\n        \"\"\"\n        data = {'reltol': self.reltol}\n\n        if len(self.overrides) > 0:\n            data['names'] = ''\n            data['abstols'] = []\n            data['reltols'] = []\n            for u in self.overrides:\n                data['names'] += '{};'.format(u['name'])\n                data['abstols'].append(u['abstol'])\n                data['reltols'].append(u['reltol'])\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        if type(self.reltol) is not float:\n            raise DREAMException(\"Invalid type of general relative tolerance: {}. Expected float.\".format(type(self.reltol)))\n\n\n        for i in range(len(self.overrides)):\n            u = self.overrides[i]\n            if ('name' not in u) or ('abstol' not in u) or ('reltol' not in u):\n                raise DREAMException(\"Incomplete override at index {}.\".format(i))\n            elif type(u['abstol']) is not float:\n                raise DREAMException(\"Invalid type of absolute tolerance for unknown '{}': {}. Expected float.\".format(u['name'], type(u['abstol'])))\n            elif type(u['reltol']) is not float:\n                raise DREAMException(\"Invalid type of relative tolerance for unknown '{}': {}. Expected float.\".format(u['name'], type(u['reltol'])))\n\n            if u['name'] not in EquationSystem.UNKNOWNS:\n                print(\"WARNING: No unknown quantity with name '{}' is available in DREAM. Tolerance setting will be ignored...\".format(u['name']))",
  "class PGrid:\n\n\n    def __init__(self, name, parent, ttype=1, np=0, pmax=None, data=None):\n        \"\"\"\n        Constructor.\n\n          name:  Name of grid (e.g. 'hottailgrid' or 'runawaygrid')\n        AND\n          ttype: Grid type.\n          np:    Number of p grid points.\n          pmax:  Maximum value of p.\n        OR\n          data:  Dictionary containing all of the above settings\n                 (except 'ttype' should be called 'pgrid')\n        \"\"\"\n        self.name = name\n        self.parent = parent\n\n        self.npsep = None\n        self.npsep_frac = None\n        self.psep  = None\n        self.p_f = None\n        self.pmin = 0\n\n        if data is not None:\n            self.fromdict(data)\n        else:\n            self.setType(ttype=ttype)\n            self.setNp(np)\n\n            if pmax is not None:\n                self.setPmax(pmax)\n            else:\n                self.pmax = pmax\n\n\n    ####################\n    # GETTERS\n    ####################\n    def getNp(self): return self.np\n    def getPmax(self): return self.pmax\n    def getPmin(self): return self.pmin\n    def getType(self): return self.type\n\n\n    ####################\n    # SETTERS\n    ####################\n    def setNp(self, np):\n        if np == 1:\n            print(\"WARNING: PGrid {}: np = 1. Consider disabling the hot-tail grid altogether.\".format(self.name))\n        self.np = int(np)\n\n\n    def setPmax(self, pmax):\n        if pmax <= 0:\n            raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, pmax))\n\n        self.pmax = float(pmax)\n\n\n    def setPmin(self, pmin):\n        if pmin < 0:\n            raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmin': {}. Must be >= 0.\".format(self.name, pmin))\n\n        self.pmin = float(pmin)\n\n\n    def setBiuniform(self, psep, npsep = None, npsep_frac = None):\n        self.type = TYPE_BIUNIFORM\n        self.psep = psep\n        if npsep is not None:\n            self.npsep = npsep\n            self.npsep_frac = None\n        elif npsep_frac is not None:\n            self.npsep = None\n            self.npsep_frac = npsep_frac\n        else:\n            raise DREAMException(\"PGrid biuniform {}: npsep or npsep_frac must be set.\")\n\n    def setCustomGridPoints(self, p_f):\n        \"\"\"\n        Set an arbitrary custom grid point distribution\n        on the momentum flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'np' which will be taken as the number of cells\n        described by the prescribed grid points, and 'pmax'\n        which will be taken as the largest element in p_f\n\n        :param float p_f: List of momentum flux grid points\n        \"\"\"\n        self.type = TYPE_CUSTOM\n\n        if type(p_f)==list:\n            p_f = np.array(p_f)\n        if np.size(p_f)<2:\n            raise EquationException(\"PGrid: Custom grid point vector 'p_f' must have size 2 or greater.\")\n\n        for i in range(np.size(p_f)-1):\n            if not p_f[i+1]>p_f[i]:\n                raise EquationException(\"PGrid: Custom grid points 'p_f' must be an array of increasing numbers.\")\n\n        self.p_f = p_f\n        if self.np != 0:\n            print(\"*WARNING* PGrid: Prescibing custom momentum grid overrides 'np'.\")\n        self.np = np.size(self.p_f) - 1\n\n        if self.pmax is not None:\n            print(\"*WARNING* PGrid: Prescibing custom momentum grid overrides 'pmax'.\")\n        self.pmax = float(p_f[-1])        \n\n        if self.pmin is not None:\n            print(\"*WARNING* PGrid: Prescribing custom momentum grid overrides 'pmin'.\")\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Set the type of p grid generator.\n        \"\"\"\n        if ttype == TYPE_UNIFORM or ttype == TYPE_BIUNIFORM:\n            self.type = ttype\n        else:\n            raise DREAMException(\"PGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load this p-grid from the specified dictionary.\n        \"\"\"\n        self.type = data['pgrid']\n        self.np   = data['np']\n        self.pmax = data['pmax']\n\n        if 'pmin' in data:\n            self.pmin = data['pmin']\n\n        if self.type == TYPE_BIUNIFORM:\n            if 'npsep' in data:\n                self.npsep = int(data['npsep'])\n            if 'npsep_frac' in data:\n                self.npsep_frac = float(data['npsep_frac'])\n\n            self.psep  = data['psep']\n        elif self.type == TYPE_CUSTOM:\n            self.p_f = data['p_f']\n\n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n\n        data = { \n            'pgrid': self.type, \n            'np': self.np,\n            'pmax': self.pmax,\n            'pmin': self.pmin\n        }\n        if self.type == TYPE_BIUNIFORM:\n            if self.npsep is not None:\n                data['npsep'] = self.npsep\n            elif self.npsep_frac is not None:\n                data['npsep_frac'] = self.npsep_frac\n\n            data['psep'] = self.psep\n        elif self.type == TYPE_CUSTOM:\n            data['p_f'] = self.p_f\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if not self.parent.enabled:\n            return\n\n        if self.type in [TYPE_UNIFORM, TYPE_BIUNIFORM, TYPE_CUSTOM]:\n            if self.np is None or self.np <= 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'np': {}. Must be > 0.\".format(self.name, self.np))\n            elif self.pmax is None or self.pmax <= 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, self.pmax))\n            elif self.pmin is None or self.pmin < 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmin': {}. Must be >= 0.\".format(self.name, self.pmin))\n        else:\n            raise DREAMException(\"PGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))\n        if self.type == TYPE_BIUNIFORM:\n            if self.npsep is not None and (self.npsep <= 0 or self.npsep >= self.np):\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'npsep': {}. Must be > 0 and < np.\".format(self.name, self.npsep))\n            elif self.npsep_frac is not None and (self.npsep_frac <= 0 or self.npsep_frac >= 1):\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'npsep_frac': {}. Must be > 0 and < np.\".format(self.name, self.npsep_frac))\n            elif self.npsep is None and self.npsep_frac is None:\n                raise DREAMException(\"PGrid {}: Neither 'npsep' nor 'npsep_frac' have been set.\".format(self.name))\n            elif self.psep is None or self.psep <= 0 or self.psep >= self.pmax:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'psep': {}. Must be > 0 and < pmax.\".format(self.name, self.psep))",
  "def __init__(self, name, parent, ttype=1, np=0, pmax=None, data=None):\n        \"\"\"\n        Constructor.\n\n          name:  Name of grid (e.g. 'hottailgrid' or 'runawaygrid')\n        AND\n          ttype: Grid type.\n          np:    Number of p grid points.\n          pmax:  Maximum value of p.\n        OR\n          data:  Dictionary containing all of the above settings\n                 (except 'ttype' should be called 'pgrid')\n        \"\"\"\n        self.name = name\n        self.parent = parent\n\n        self.npsep = None\n        self.npsep_frac = None\n        self.psep  = None\n        self.p_f = None\n        self.pmin = 0\n\n        if data is not None:\n            self.fromdict(data)\n        else:\n            self.setType(ttype=ttype)\n            self.setNp(np)\n\n            if pmax is not None:\n                self.setPmax(pmax)\n            else:\n                self.pmax = pmax",
  "def getNp(self): return self.np",
  "def getPmax(self): return self.pmax",
  "def getPmin(self): return self.pmin",
  "def getType(self): return self.type",
  "def setNp(self, np):\n        if np == 1:\n            print(\"WARNING: PGrid {}: np = 1. Consider disabling the hot-tail grid altogether.\".format(self.name))\n        self.np = int(np)",
  "def setPmax(self, pmax):\n        if pmax <= 0:\n            raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, pmax))\n\n        self.pmax = float(pmax)",
  "def setPmin(self, pmin):\n        if pmin < 0:\n            raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmin': {}. Must be >= 0.\".format(self.name, pmin))\n\n        self.pmin = float(pmin)",
  "def setBiuniform(self, psep, npsep = None, npsep_frac = None):\n        self.type = TYPE_BIUNIFORM\n        self.psep = psep\n        if npsep is not None:\n            self.npsep = npsep\n            self.npsep_frac = None\n        elif npsep_frac is not None:\n            self.npsep = None\n            self.npsep_frac = npsep_frac\n        else:\n            raise DREAMException(\"PGrid biuniform {}: npsep or npsep_frac must be set.\")",
  "def setCustomGridPoints(self, p_f):\n        \"\"\"\n        Set an arbitrary custom grid point distribution\n        on the momentum flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'np' which will be taken as the number of cells\n        described by the prescribed grid points, and 'pmax'\n        which will be taken as the largest element in p_f\n\n        :param float p_f: List of momentum flux grid points\n        \"\"\"\n        self.type = TYPE_CUSTOM\n\n        if type(p_f)==list:\n            p_f = np.array(p_f)\n        if np.size(p_f)<2:\n            raise EquationException(\"PGrid: Custom grid point vector 'p_f' must have size 2 or greater.\")\n\n        for i in range(np.size(p_f)-1):\n            if not p_f[i+1]>p_f[i]:\n                raise EquationException(\"PGrid: Custom grid points 'p_f' must be an array of increasing numbers.\")\n\n        self.p_f = p_f\n        if self.np != 0:\n            print(\"*WARNING* PGrid: Prescibing custom momentum grid overrides 'np'.\")\n        self.np = np.size(self.p_f) - 1\n\n        if self.pmax is not None:\n            print(\"*WARNING* PGrid: Prescibing custom momentum grid overrides 'pmax'.\")\n        self.pmax = float(p_f[-1])        \n\n        if self.pmin is not None:\n            print(\"*WARNING* PGrid: Prescribing custom momentum grid overrides 'pmin'.\")",
  "def setType(self, ttype):\n        \"\"\"\n        Set the type of p grid generator.\n        \"\"\"\n        if ttype == TYPE_UNIFORM or ttype == TYPE_BIUNIFORM:\n            self.type = ttype\n        else:\n            raise DREAMException(\"PGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))",
  "def fromdict(self, data):\n        \"\"\"\n        Load this p-grid from the specified dictionary.\n        \"\"\"\n        self.type = data['pgrid']\n        self.np   = data['np']\n        self.pmax = data['pmax']\n\n        if 'pmin' in data:\n            self.pmin = data['pmin']\n\n        if self.type == TYPE_BIUNIFORM:\n            if 'npsep' in data:\n                self.npsep = int(data['npsep'])\n            if 'npsep_frac' in data:\n                self.npsep_frac = float(data['npsep_frac'])\n\n            self.psep  = data['psep']\n        elif self.type == TYPE_CUSTOM:\n            self.p_f = data['p_f']\n\n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n\n        data = { \n            'pgrid': self.type, \n            'np': self.np,\n            'pmax': self.pmax,\n            'pmin': self.pmin\n        }\n        if self.type == TYPE_BIUNIFORM:\n            if self.npsep is not None:\n                data['npsep'] = self.npsep\n            elif self.npsep_frac is not None:\n                data['npsep_frac'] = self.npsep_frac\n\n            data['psep'] = self.psep\n        elif self.type == TYPE_CUSTOM:\n            data['p_f'] = self.p_f\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if not self.parent.enabled:\n            return\n\n        if self.type in [TYPE_UNIFORM, TYPE_BIUNIFORM, TYPE_CUSTOM]:\n            if self.np is None or self.np <= 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'np': {}. Must be > 0.\".format(self.name, self.np))\n            elif self.pmax is None or self.pmax <= 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, self.pmax))\n            elif self.pmin is None or self.pmin < 0:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'pmin': {}. Must be >= 0.\".format(self.name, self.pmin))\n        else:\n            raise DREAMException(\"PGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))\n        if self.type == TYPE_BIUNIFORM:\n            if self.npsep is not None and (self.npsep <= 0 or self.npsep >= self.np):\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'npsep': {}. Must be > 0 and < np.\".format(self.name, self.npsep))\n            elif self.npsep_frac is not None and (self.npsep_frac <= 0 or self.npsep_frac >= 1):\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'npsep_frac': {}. Must be > 0 and < np.\".format(self.name, self.npsep_frac))\n            elif self.npsep is None and self.npsep_frac is None:\n                raise DREAMException(\"PGrid {}: Neither 'npsep' nor 'npsep_frac' have been set.\".format(self.name))\n            elif self.psep is None or self.psep <= 0 or self.psep >= self.pmax:\n                raise DREAMException(\"PGrid {}: Invalid value assigned to 'psep': {}. Must be > 0 and < pmax.\".format(self.name, self.psep))",
  "class RadialGrid(PrescribedScalarParameter):\n    \n\n    def __init__(self, ttype=1):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.setType(ttype=ttype)\n\n        # Cylindrical settings\n        self.a  = 0.0\n        self.b  = 0.0\n        self.B0 = 0.0\n        self.nr = int(0)\n        self.r0 = 0.0\n\n        # Analytic toroidal settings\n        self.R0 = 2.0\n        self.ntheta = 20\n        self.Delta = None       # Shafranov shift\n        self.Delta_r = None\n        self.delta = None       # Triangularity\n        self.delta_r = None\n        self.GOverR0 = None     # R*Bphi/R0\n        self.GOverR0_r = None\n        self.kappa = None       # Elongation\n        self.kappa_r = None\n        self.psi_p0 = None      # Reference poloidal flux\n        self.psi_p0_r = None\n        # Ripple parameters\n        self.ripple_ncoils = 0\n        self.ripple_deltacoils = 0.0\n        self.ripple_m = None\n        self.ripple_n = None\n        self.ripple_dB_B = None\n        self.ripple_r = None\n        self.ripple_t = None\n        # Time-varying magnetic field parameter\n        self.dlnB0dt_x = None\n        self.dlnB0dt_t = None\n\n        # Numerical magnetic field parameters\n        self.num_filename = None\n        self.num_fileformat = None\n        self.num_magneticfield = None   # Magnetic field class parsing data\n\n        # prescribed arbitrary grid\n        self.r_f = None \n\n\n    #######################\n    # SETTERS\n    #######################\n    def setCustomGridPoints(self, r_f):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set an arbitrary custom grid point distribution\n        on the radial flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'nr', which will be taken as the number of cells\n        described by the prescribed grid points.\n\n        :param float r_f: List of radial flux grid points\n        \"\"\"\n        if self.nr != 0 or self.a != 0 or self.r0 != 0:\n            #raise EquationException(\"RadialGrid: Cannot assign custom grid points while prescribing 'nr', 'a' or 'r0'.\")         \n            print(\"*WARNING* RadialGrid: Prescibing custom radial grid overrides 'nr', 'a' and 'r0'.\")\n            self.nr = int(0)\n            self.a  = 0.0\n            self.r0 = 0.0\n\n        if type(r_f)==list:\n            r_f = np.array(r_f)\n        if np.size(r_f)<2:\n            raise EquationException(\"RadialGrid: Custom grid point vector 'r_f' must have size 2 or greater.\")\n        for i in range(np.size(r_f)-1):\n            if r_f[i+1]<r_f[i]:\n                raise EquationException(\"RadialGrid: Custom grid points 'r_f' must be an array of increasing numbers.\")\n        if np.min(r_f)<0:\n            raise EquationException(\"RadialGrid: Custom grid points must be non-negative.\")\n        self.r_f = r_f\n\n    def setB0(self, B0):\n        \"\"\"\n        (Cylindrical)\n        Set the on-axis magnetic field strength.\n        \"\"\"\n        if B0 <= 0:\n            raise EquationException(\"RadialGrid: Invalid value assigned to 'B0': {}. Must be >0.\".format(B0))\n        \n        self.B0 = float(B0)\n\n\n    def setInnerRadius(self, r0):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the innermost radial point to simulate.\n        \"\"\"\n        if r0 < 0:\n            raise EquationException(\"RadialGrid: Invalid value assigned to innermost radius 'r0': {}\".format(r0))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Inner radius' r0 overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n\n        self.r0 = r0\n\n\n    def setMinorRadius(self, a):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the plasma minor radius.\n        \"\"\"\n        if a <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to minor radius 'a': {}\".format(a))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Minor radius' a overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n\n        self.a = float(a)\n\n\n    def setMajorRadius(self, R0):\n        \"\"\"\n        (Analytic toroidal)\n        Set the tokamak major radius.\n        \"\"\"\n        if R0 <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to major radius 'R0': {}\".format(R0))\n\n        self.R0 = float(R0)\n\n    def setWallRadius(self, wall_radius):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the minor radius of the wall\n        \"\"\"\n        self.b = float(wall_radius)\n\n    def setNr(self, nr):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the number of radial grid points to use.\n        \"\"\"\n        if nr <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to 'nr': {}\".format(nr))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Nr' overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n            \n        self.nr = int(nr)\n\n\n    def setNtheta(self, ntheta):\n        \"\"\"\n        (Analytic toroidal and numerical)\n        Set the number of grid points to use for the poloidal grid on which bounce\n        averages are calculated.\n        \"\"\"\n        if ntheta <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}\".format(ntheta))\n\n        self.ntheta = ntheta\n\n\n    def setShapeParameter(self, name, data, r=0.0):\n        \"\"\"\n        (Analytic toroidal)\n        Set a specific magnetic field shape parameter.\n        \"\"\"\n        if name not in ['Delta', 'delta', 'GOverR0', 'kappa', 'psi_p0']:\n            raise DREAMException(\"RadialGrid: Invalid name of shape parameter specified: '{}'.\".format(name))\n\n        if type(data) in [float, int]:\n            data = np.array([float(data)])\n        elif type(data) == list:\n            data = np.array(data)\n\n        if type(r) in [float, int]:\n            r = np.array([float(r)])\n        elif type(r) == list:\n            r = np.array(r)\n\n        setattr(self, name, data)\n        setattr(self, name+'_r', r)\n\n\n    def setShaping(self, psi, GOverR0, rpsi=0.0, rG=0.0,\n        Delta=0.0, rDelta=0.0, delta=0.0, rdelta=0.0,\n        kappa=1.0, rkappa=0.0):\n        \"\"\"\n        (Analytic toroidal)\n        Set the plasma shape parameters to use with the magnetic field.\n\n        :param GOverR0:      Toroidal magnetic field component, ``R*Bphi``, normalized by ``R0``.\n        :param rG:     Radial grid for ``GOverR0``.\n        :param psi:    Reference poloidal flux, normalized by ``R0``.\n        :param rpsi:   Radial grid for ``psi``.\n        :param Delta:  Shafranov shift.\n        :param rDelta: Radial grid for Shafranov shift.\n        :param delta:  Triangularity.\n        :param rdelta: Radial grid for triangularity.\n        :param kappa:  Elongation.\n        :param rkappa: Radial grid for elongation.\n        \"\"\"\n        self.setType(TYPE_ANALYTIC_TOROIDAL)\n\n        self.setShapeParameter('Delta',   r=rDelta, data=Delta)\n        self.setShapeParameter('delta',   r=rdelta, data=delta)\n        self.setShapeParameter('GOverR0', r=rG,     data=GOverR0)\n        self.setShapeParameter('kappa',   r=rkappa, data=kappa)\n        self.setShapeParameter('psi_p0',  r=rpsi,   data=psi)\n\n\n    def setRipple(self, m, n, dB_B, ncoils=0, deltacoils=0, r=[0], t=[0]):\n        \"\"\"\n        Enable the ripple pitch scattering term.\n\n        :param list m:           Poloidal mode numbers of magnetic perturbation(s).\n        :param list n:           Toroidal mode numbers of magnetic perturbation(s).\n        :param dB_B:             Magnetic perturbations (shape: nModes x nt x nr).\n        :param int ncoils:       Number of toroidal field coils.\n        :param float deltacoils: Distance between toroidal field coils.\n        :param r:                Radial grid on which the magnetic perturbations are given.\n        :param t:                Time grid on which the magnetic perturbations are given.\n        \"\"\"\n        if type(m) == list: m = np.array(m)\n        elif np.isscalar(m): m = np.array([float(m)])\n\n        if type(n) == list: n = np.array(n)\n        elif np.isscalar(n): n = np.array([float(n)])\n\n        if type(r) == list: r = np.array(r)\n        elif np.isscalar(r): r = np.array([float(r)])\n\n        if type(t) == list: t = np.array(t)\n        elif np.isscalar(t): t = np.array([float(t)])\n\n        if type(dB_B) == list:\n            dB_B = np.array(dB_B)\n        if type(dB_B) == float or dB_B.ndim == 1:\n            dB_B = np.ones((m.size, t.size, r.size)) * dB_B\n\n        if m.size != n.size:\n            raise EquationException(\"RadialGrid: m and n must have the same number of elements.\")\n        elif dB_B.ndim == 1 and dB_B.size == m.size:\n            dB_B = dB_B*np.ones((m.size, t.size, r.size))\n        elif dB_B.ndim != 3 or dB_B.shape != (m.size, t.size, r.size):\n            raise EquationException(\"RadialGrid: Invalid dimensions of parameter 'dB_B'. Expected {}, but array has {}.\".format((m.size, t.size, r.size), dB_B.shape))\n\n        self.ripple_ncoils = int(ncoils)\n        self.ripple_deltacoils = float(deltacoils)\n        self.ripple_m = m\n        self.ripple_n = n\n        self.ripple_dB_B = dB_B\n        self.ripple_r = r\n        self.ripple_t = t\n\n\n    def setTimeVaryingB(self, dB0dt_B0, t=0):\n        \"\"\"\n        Set the time-rate-of-change of the magnetic field strength (for the\n        approximate time varying B compression force operator). Note that the\n        specified parameter should be (1/B0)*(dB0/dt), where B0 is the on-axis\n        magnetic field strength and dB0/dt denotes the absolute\n        time-rate-of-change of B0.\n\n        :param dB0dt_B0: Normalized time-rate-of-change of the on-axis magnetic field strength.\n        :param t: Time vector corresponding to the given time-rate-of-change.\n        \"\"\"\n        self.dlnB0dt_x, self.dlnB0dt_t = self._setScalarData(data=dB0dt_B0, times=t)\n\n\n    def setNumerical(self, filename, format=FILE_FORMAT_LUKE):\n        \"\"\"\n        Sets the numerical magnetic field to use for the simulation.\n\n        :param str filename: Name of file containing magnetic field data.\n        :param int format:   Format of the magnetic field data in the given file.\n        \"\"\"\n        self.type = TYPE_NUMERICAL\n        self.num_filename = filename\n        \n        if format is not None:\n            self.num_fileformat = format\n\n        if format == FILE_FORMAT_LUKE:\n            self.num_magneticfield = LUKEMagneticField(filename)\n\n        self.a = self.num_magneticfield.a\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Set the type of radial grid to use.\n        \"\"\"\n        types = [TYPE_CYLINDRICAL, TYPE_ANALYTIC_TOROIDAL, TYPE_NUMERICAL]\n        if ttype in types:\n            self.type = ttype\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(ttype))\n\n\n    def visualize(self, *args, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the current magnetic field.\n\n        :param int nr:     Number of flux surfaces to show.\n        :param int ntheta: Number of poloidal angles per flux surface.\n        \"\"\"\n        # Ensure that settings are valid...\n        self.verifySettings()\n\n        if self.type == TYPE_ANALYTIC_TOROIDAL:\n            self.visualize_analytic(*args, ax=ax, show=show, **kwargs)\n        elif self.type == TYPE_NUMERICAL:\n            self.num_magneticfield.visualize(*args, ax=ax, show=show, **kwargs)\n        else:\n            raise DREAMException(\"RadialGrid: Can only visualize the analytic toroidal magnetic field.\")\n\n        \n    def visualize_analytic(self, nr=10, ntheta=40, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize an analytic toroidal magnetic field.\n        \"\"\"\n        red   = (249/255, 65/255, 68/255)\n        black = (87/255, 117/255, 144/255)\n        gray  = (190/255, 190/255, 190/255)\n\n        # Set up axes (if not already done)\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # Generate r/theta grid\n        if self.a == 0:\n            # Custom radial grid (i.e. not generated by specifying r0 and a)\n            r_f = self.r_f\n            # Resample\n            r_f = np.interp(np.linspace(0, 1, nr)*r_f.size, range(r_f.size), r_f)\n        else:\n            r_f = np.linspace(self.r0, self.a, nr+1)\n\n        r   = (r_f[:-1] + r_f[1:]) / 2.0\n        t   = np.linspace(0, 2*np.pi, ntheta)\n\n        rr, tt = np.meshgrid(r, t)\n\n        # Helper interpolation function\n        def interppar(r, rParam, param):\n            f = None\n            if param.size == 1:\n                return param[0] * np.ones(r.shape)\n            elif param.size == 2:\n                f = scipy.interpolate.interp1d(rParam, param)\n            else:\n                # Not exactly what is done in the kernel (which uses Steffen\n                # interpolation, which is cubic and guarantees positivity)\n                f = scipy.interpolate.interp1d(rParam, param, kind='cubic', bounds_error=False, fill_value='extrapolate')\n\n            return f(r)\n\n        # Interpolate shaping parameters\n        Delta = lambda r : interppar(r, self.Delta_r, self.Delta)\n        delta = lambda r : interppar(r, self.delta_r, self.delta)\n        kappa = lambda r : interppar(r, self.kappa_r, self.kappa)\n\n        # Construct flux surfaces\n        if np.isinf(self.R0):\n            R = lambda r, t : Delta(r) + r*np.cos(t + delta(r)*np.sin(t))\n        else:\n            R = lambda r, t : self.R0 + Delta(r) + r*np.cos(t + delta(r)*np.sin(t))\n        Z = lambda r, t : r*kappa(r)*np.sin(t)\n\n        # Flux surfaces\n        ax.plot(R(rr, tt), Z(rr, tt), color=gray, linewidth=1, **kwargs)\n        # Limiter\n        ax.plot(R(r_f[-1], tt), Z(r_f[-1], tt), color=black, linewidth=2, **kwargs)\n        # Wall\n        ax.plot(R(np.array([self.b]), tt), Z(np.array([self.b]), tt), color=red, linewidth=2, **kwargs)\n        ax.axis('equal')\n\n        if np.isinf(self.R0):\n            ax.set_xlabel('Major radius $R-R_0$ (m)')\n        else:\n            ax.set_xlabel('Major radius $R$ (m)')\n        ax.set_ylabel('Height $Z$ (m)')\n\n        if show:\n            plt.show()\n\n        return ax\n\n    \n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = data['type']\n\n        if 'wall_radius' in data:\n            self.b = data['wall_radius']\n            if type(self.b) == np.ndarray:\n                self.b = float(self.b[0])\n            else:\n                self.b = float(self.b)\n\n        if self.type == TYPE_CYLINDRICAL or self.type == TYPE_ANALYTIC_TOROIDAL or self.type == TYPE_NUMERICAL:\n            self.a = data['a']\n            self.nr = data['nr']\n            self.r0 = data['r0']\n            if 'r_f' in data:\n                self.r_f = data['r_f']\n\n        if self.type == TYPE_CYLINDRICAL:\n            self.B0 = data['B0']\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            self.R0 = data['R0']\n            self.ntheta = data['ntheta']\n\n            self.Delta = data['Delta']['x']\n            self.Delta_r = data['Delta']['r']\n            self.delta = data['delta']['x']\n            self.delta_r = data['delta']['r']\n            self.GOverR0 = data['GOverR0']['x']\n            self.GOverR0_r = data['GOverR0']['r']\n            self.kappa = data['kappa']['x']\n            self.kappa_r = data['kappa']['r']\n            self.psi_p0 = data['psi_p0']['x']\n            self.psi_p0_r = data['psi_p0']['r']\n        elif self.type == TYPE_NUMERICAL:\n            self.num_filename = data['filename']\n            self.ntheta = data['ntheta']\n\n            if 'fileformat' in data:\n                self.num_fileformat = data['fileformat']\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        if 'ripple' in data:\n            self.ripple_ncoils = int(scal(data['ripple']['ncoils']))\n            self.ripple_deltacoils = float(scal(data['ripple']['deltacoils']))\n            self.ripple_m = data['ripple']['m']\n            self.ripple_n = data['ripple']['n']\n            self.ripple_dB_B = data['ripple']['x']\n            self.ripple_r = data['ripple']['r']\n            self.ripple_t = data['ripple']['t']\n\n        if 'dlnB0dt' in data:\n            self.dlnB0dt_x = data['dlnB0dt']['x']\n            self.dlnB0dt_t = data['dlnB0dt']['t']\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns the settings in this object as a Python dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type\n        }\n\n        if self.type == TYPE_CYLINDRICAL or self.type == TYPE_ANALYTIC_TOROIDAL or self.type == TYPE_NUMERICAL:\n            data['a'] = self.a\n            data['nr'] = self.nr\n            data['r0'] = self.r0\n            data['wall_radius'] = self.b\n            if self.r_f is not None:\n                data['r_f'] = self.r_f\n\n        if self.type == TYPE_CYLINDRICAL:\n            data['B0'] = self.B0\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            data['R0'] = self.R0\n            data['ntheta'] = self.ntheta\n\n            data['Delta']   = {'x': self.Delta, 'r': self.Delta_r}\n            data['delta']   = {'x': self.delta, 'r': self.delta_r}\n            data['GOverR0'] = {'x': self.GOverR0, 'r': self.GOverR0_r}\n            data['kappa']   = {'x': self.kappa, 'r': self.kappa_r}\n            data['psi_p0']  = {'x': self.psi_p0, 'r': self.psi_p0_r}\n        elif self.type == TYPE_NUMERICAL:\n            data['filename'] = self.num_filename\n            data['ntheta'] = self.ntheta\n\n            if self.num_fileformat is not None:\n                data['fileformat'] = self.num_fileformat\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        if self.ripple_ncoils > 0 or self.ripple_deltacoils > 0:\n            data['ripple'] = {\n                'ncoils': self.ripple_ncoils,\n                'deltacoils': self.ripple_deltacoils,\n                'm': self.ripple_m,\n                'n': self.ripple_n,\n                'x': self.ripple_dB_B,\n                'r': self.ripple_r,\n                't': self.ripple_t\n            }\n\n        if self.dlnB0dt_x is not None:\n            data['dlnB0dt'] = {\n                'x': self.dlnB0dt_x,\n                't': self.dlnB0dt_t\n            }\n\n        return data\n        \n            \n    def verifySettings(self):\n        \"\"\"\n        Verfiy that the RadialGrid settings are consistent.\n        \"\"\"\n        types = [TYPE_CYLINDRICAL, TYPE_ANALYTIC_TOROIDAL, TYPE_NUMERICAL]\n        if self.type in types:\n            if (self.a is None or self.a <= 0) and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to minor radius 'a': {}\".format(self.a))\n            elif (self.r0 is None or self.r0 < 0) and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to innermost simulated radius 'r0': {}\".format(self.r0))\n            elif self.b is None or self.b<self.a:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to wall radius 'b' (must be explicitly set to >= 'a' using 'setWallRadius'): \".format(self.b))\n            if self.r0 >= self.a and self.r_f is None:\n                raise DREAMException(\"RadialGrid: 'r0' must be strictly less than 'a'.\")\n            if self.nr <= 0 and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned 'nr': {}. Must be > 0.\".format(self.nr))\n            if not np.isscalar(self.b):\n                raise DREAMException(\"RadialGrid: The specified wall radius is not a scalar: {}.\".format(self.b))\n\n        if self.type == TYPE_CYLINDRICAL:\n            if self.B0 is None or self.B0 <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'B0': {}\".format(self.B0))\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            if self.R0 is None or self.R0 <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to tokamak major radius 'R0': {}\".format(self.R0))\n            elif self.ntheta <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}. Must be > 0.\".format(self.ntheta))\n\n            self.verifySettingsShapeParameter('Delta')\n            self.verifySettingsShapeParameter('delta')\n            self.verifySettingsShapeParameter('GOverR0')\n            self.verifySettingsShapeParameter('kappa')\n            self.verifySettingsShapeParameter('psi_p0')\n\n            if np.size(self.Delta_r)>1:\n                if self.Delta_r[0]==0 and self.Delta[0]!=0:\n                    print(\"*WARNING* RadialGrid: Shape parameter 'Delta' (Shafranov shift) is non-zero at r=0, which is inconsistent (add Delta(0) to the major radius R0 instead)\")\n            elif self.Delta!=0:\n                print(\"*WARNING* RadialGrid: Shape parameter 'Delta' (Shafranov shift) is assigned a constant non-zero value. It is recommended to add its value to the major radius R0 instead\")\n            if np.size(self.delta_r)>1:\n                if self.delta_r[0]==0 and self.delta[0]!=0:\n                    print(\"*WARNING* RadialGrid: Shape parameter 'delta' (triangularity) is non-zero at r=0, which is inconsistent with Grad-Shafranov\")\n        elif self.type == TYPE_NUMERICAL:\n            if type(self.num_filename) != str:\n                raise DREAMException(\"RadialGrid: No numerical magnetic field file specified.\")\n            elif not pathlib.Path(self.num_filename).is_file():\n                raise DREAMException(\"RadialGrid: The specified numerical magnetic field file does not exist.\")\n            elif self.ntheta <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}. Must be > 0.\".format(self.ntheta))\n\n            formats = [FILE_FORMAT_LUKE]\n            if (self.num_fileformat is not None) and (self.num_fileformat not in formats):\n                raise DREAMException(\"RadialGrid: Unrecognized file format specified for numerical magnetic field: {}.\".format(self.num_fileformat))\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        # Ripple settings\n        if self.ripple_ncoils > 0 or self.ripple_deltacoils > 0:\n            if type(self.ripple_m) != np.ndarray or self.ripple_m.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_m'.\")\n            elif type(self.ripple_n) != np.ndarray or self.ripple_n.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_n'.\")\n            elif self.ripple_m.size != self.ripple_n.size:\n                raise EquationException(\"RadialGrid: 'ripple_m' and 'ripple_n' must have the same number of elements.\")\n            elif type(self.ripple_r) != np.ndarray or self.ripple_r.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_r'.\")\n            elif type(self.ripple_t) != np.ndarray or self.ripple_t.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_t'.\")\n            elif type(self.ripple_dB_B) != np.ndarray or self.ripple_dB_B.shape != (self.ripple_m.size, self.ripple_t.size, self.ripple_r.size):\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_dB_B'.\".format(self.ripple_dB_B))\n\n        \n    def verifySettingsShapeParameter(self, shapeparam):\n        \"\"\"\n        Verify the settings of the named shape parameter.\n        \n        :param str shapeparam: Name of shape parameter to verify settings for.\n        \"\"\"\n        v = getattr(self, shapeparam)\n        r = getattr(self, shapeparam+'_r')\n\n        if v is None or type(v) != np.ndarray:\n            raise DREAMException(\"RadialGrid: Invalid type of shape parameter '{}': {}.\".format(shapeparam, type(v)))\n        elif r is None or type(r) != np.ndarray:\n            raise DREAMException(\"RadialGrid: Invalid type of radial grid for shape parameter '{}': {}.\".format(shapeparam, type(r)))\n\n        if v.shape != r.shape:\n            raise DREAMException(\"RadialGrid: Dimensions mismatch between shape parameter '{}' {} and its radial grid {}.\".format(shapeparam, v.shape, r.shape))",
  "def __init__(self, ttype=1):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.setType(ttype=ttype)\n\n        # Cylindrical settings\n        self.a  = 0.0\n        self.b  = 0.0\n        self.B0 = 0.0\n        self.nr = int(0)\n        self.r0 = 0.0\n\n        # Analytic toroidal settings\n        self.R0 = 2.0\n        self.ntheta = 20\n        self.Delta = None       # Shafranov shift\n        self.Delta_r = None\n        self.delta = None       # Triangularity\n        self.delta_r = None\n        self.GOverR0 = None     # R*Bphi/R0\n        self.GOverR0_r = None\n        self.kappa = None       # Elongation\n        self.kappa_r = None\n        self.psi_p0 = None      # Reference poloidal flux\n        self.psi_p0_r = None\n        # Ripple parameters\n        self.ripple_ncoils = 0\n        self.ripple_deltacoils = 0.0\n        self.ripple_m = None\n        self.ripple_n = None\n        self.ripple_dB_B = None\n        self.ripple_r = None\n        self.ripple_t = None\n        # Time-varying magnetic field parameter\n        self.dlnB0dt_x = None\n        self.dlnB0dt_t = None\n\n        # Numerical magnetic field parameters\n        self.num_filename = None\n        self.num_fileformat = None\n        self.num_magneticfield = None   # Magnetic field class parsing data\n\n        # prescribed arbitrary grid\n        self.r_f = None",
  "def setCustomGridPoints(self, r_f):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set an arbitrary custom grid point distribution\n        on the radial flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'nr', which will be taken as the number of cells\n        described by the prescribed grid points.\n\n        :param float r_f: List of radial flux grid points\n        \"\"\"\n        if self.nr != 0 or self.a != 0 or self.r0 != 0:\n            #raise EquationException(\"RadialGrid: Cannot assign custom grid points while prescribing 'nr', 'a' or 'r0'.\")         \n            print(\"*WARNING* RadialGrid: Prescibing custom radial grid overrides 'nr', 'a' and 'r0'.\")\n            self.nr = int(0)\n            self.a  = 0.0\n            self.r0 = 0.0\n\n        if type(r_f)==list:\n            r_f = np.array(r_f)\n        if np.size(r_f)<2:\n            raise EquationException(\"RadialGrid: Custom grid point vector 'r_f' must have size 2 or greater.\")\n        for i in range(np.size(r_f)-1):\n            if r_f[i+1]<r_f[i]:\n                raise EquationException(\"RadialGrid: Custom grid points 'r_f' must be an array of increasing numbers.\")\n        if np.min(r_f)<0:\n            raise EquationException(\"RadialGrid: Custom grid points must be non-negative.\")\n        self.r_f = r_f",
  "def setB0(self, B0):\n        \"\"\"\n        (Cylindrical)\n        Set the on-axis magnetic field strength.\n        \"\"\"\n        if B0 <= 0:\n            raise EquationException(\"RadialGrid: Invalid value assigned to 'B0': {}. Must be >0.\".format(B0))\n        \n        self.B0 = float(B0)",
  "def setInnerRadius(self, r0):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the innermost radial point to simulate.\n        \"\"\"\n        if r0 < 0:\n            raise EquationException(\"RadialGrid: Invalid value assigned to innermost radius 'r0': {}\".format(r0))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Inner radius' r0 overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n\n        self.r0 = r0",
  "def setMinorRadius(self, a):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the plasma minor radius.\n        \"\"\"\n        if a <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to minor radius 'a': {}\".format(a))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Minor radius' a overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n\n        self.a = float(a)",
  "def setMajorRadius(self, R0):\n        \"\"\"\n        (Analytic toroidal)\n        Set the tokamak major radius.\n        \"\"\"\n        if R0 <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to major radius 'R0': {}\".format(R0))\n\n        self.R0 = float(R0)",
  "def setWallRadius(self, wall_radius):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the minor radius of the wall\n        \"\"\"\n        self.b = float(wall_radius)",
  "def setNr(self, nr):\n        \"\"\"\n        (Cylindrical, Analytic toroidal)\n        Set the number of radial grid points to use.\n        \"\"\"\n        if nr <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to 'nr': {}\".format(nr))\n        if self.r_f is not None:\n            print(\"*WARNING* RadialGrid: Prescibing 'Nr' overrides the custom radial grid 'r_f'.\")\n            self.r_f = None\n            \n        self.nr = int(nr)",
  "def setNtheta(self, ntheta):\n        \"\"\"\n        (Analytic toroidal and numerical)\n        Set the number of grid points to use for the poloidal grid on which bounce\n        averages are calculated.\n        \"\"\"\n        if ntheta <= 0:\n            raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}\".format(ntheta))\n\n        self.ntheta = ntheta",
  "def setShapeParameter(self, name, data, r=0.0):\n        \"\"\"\n        (Analytic toroidal)\n        Set a specific magnetic field shape parameter.\n        \"\"\"\n        if name not in ['Delta', 'delta', 'GOverR0', 'kappa', 'psi_p0']:\n            raise DREAMException(\"RadialGrid: Invalid name of shape parameter specified: '{}'.\".format(name))\n\n        if type(data) in [float, int]:\n            data = np.array([float(data)])\n        elif type(data) == list:\n            data = np.array(data)\n\n        if type(r) in [float, int]:\n            r = np.array([float(r)])\n        elif type(r) == list:\n            r = np.array(r)\n\n        setattr(self, name, data)\n        setattr(self, name+'_r', r)",
  "def setShaping(self, psi, GOverR0, rpsi=0.0, rG=0.0,\n        Delta=0.0, rDelta=0.0, delta=0.0, rdelta=0.0,\n        kappa=1.0, rkappa=0.0):\n        \"\"\"\n        (Analytic toroidal)\n        Set the plasma shape parameters to use with the magnetic field.\n\n        :param GOverR0:      Toroidal magnetic field component, ``R*Bphi``, normalized by ``R0``.\n        :param rG:     Radial grid for ``GOverR0``.\n        :param psi:    Reference poloidal flux, normalized by ``R0``.\n        :param rpsi:   Radial grid for ``psi``.\n        :param Delta:  Shafranov shift.\n        :param rDelta: Radial grid for Shafranov shift.\n        :param delta:  Triangularity.\n        :param rdelta: Radial grid for triangularity.\n        :param kappa:  Elongation.\n        :param rkappa: Radial grid for elongation.\n        \"\"\"\n        self.setType(TYPE_ANALYTIC_TOROIDAL)\n\n        self.setShapeParameter('Delta',   r=rDelta, data=Delta)\n        self.setShapeParameter('delta',   r=rdelta, data=delta)\n        self.setShapeParameter('GOverR0', r=rG,     data=GOverR0)\n        self.setShapeParameter('kappa',   r=rkappa, data=kappa)\n        self.setShapeParameter('psi_p0',  r=rpsi,   data=psi)",
  "def setRipple(self, m, n, dB_B, ncoils=0, deltacoils=0, r=[0], t=[0]):\n        \"\"\"\n        Enable the ripple pitch scattering term.\n\n        :param list m:           Poloidal mode numbers of magnetic perturbation(s).\n        :param list n:           Toroidal mode numbers of magnetic perturbation(s).\n        :param dB_B:             Magnetic perturbations (shape: nModes x nt x nr).\n        :param int ncoils:       Number of toroidal field coils.\n        :param float deltacoils: Distance between toroidal field coils.\n        :param r:                Radial grid on which the magnetic perturbations are given.\n        :param t:                Time grid on which the magnetic perturbations are given.\n        \"\"\"\n        if type(m) == list: m = np.array(m)\n        elif np.isscalar(m): m = np.array([float(m)])\n\n        if type(n) == list: n = np.array(n)\n        elif np.isscalar(n): n = np.array([float(n)])\n\n        if type(r) == list: r = np.array(r)\n        elif np.isscalar(r): r = np.array([float(r)])\n\n        if type(t) == list: t = np.array(t)\n        elif np.isscalar(t): t = np.array([float(t)])\n\n        if type(dB_B) == list:\n            dB_B = np.array(dB_B)\n        if type(dB_B) == float or dB_B.ndim == 1:\n            dB_B = np.ones((m.size, t.size, r.size)) * dB_B\n\n        if m.size != n.size:\n            raise EquationException(\"RadialGrid: m and n must have the same number of elements.\")\n        elif dB_B.ndim == 1 and dB_B.size == m.size:\n            dB_B = dB_B*np.ones((m.size, t.size, r.size))\n        elif dB_B.ndim != 3 or dB_B.shape != (m.size, t.size, r.size):\n            raise EquationException(\"RadialGrid: Invalid dimensions of parameter 'dB_B'. Expected {}, but array has {}.\".format((m.size, t.size, r.size), dB_B.shape))\n\n        self.ripple_ncoils = int(ncoils)\n        self.ripple_deltacoils = float(deltacoils)\n        self.ripple_m = m\n        self.ripple_n = n\n        self.ripple_dB_B = dB_B\n        self.ripple_r = r\n        self.ripple_t = t",
  "def setTimeVaryingB(self, dB0dt_B0, t=0):\n        \"\"\"\n        Set the time-rate-of-change of the magnetic field strength (for the\n        approximate time varying B compression force operator). Note that the\n        specified parameter should be (1/B0)*(dB0/dt), where B0 is the on-axis\n        magnetic field strength and dB0/dt denotes the absolute\n        time-rate-of-change of B0.\n\n        :param dB0dt_B0: Normalized time-rate-of-change of the on-axis magnetic field strength.\n        :param t: Time vector corresponding to the given time-rate-of-change.\n        \"\"\"\n        self.dlnB0dt_x, self.dlnB0dt_t = self._setScalarData(data=dB0dt_B0, times=t)",
  "def setNumerical(self, filename, format=FILE_FORMAT_LUKE):\n        \"\"\"\n        Sets the numerical magnetic field to use for the simulation.\n\n        :param str filename: Name of file containing magnetic field data.\n        :param int format:   Format of the magnetic field data in the given file.\n        \"\"\"\n        self.type = TYPE_NUMERICAL\n        self.num_filename = filename\n        \n        if format is not None:\n            self.num_fileformat = format\n\n        if format == FILE_FORMAT_LUKE:\n            self.num_magneticfield = LUKEMagneticField(filename)\n\n        self.a = self.num_magneticfield.a",
  "def setType(self, ttype):\n        \"\"\"\n        Set the type of radial grid to use.\n        \"\"\"\n        types = [TYPE_CYLINDRICAL, TYPE_ANALYTIC_TOROIDAL, TYPE_NUMERICAL]\n        if ttype in types:\n            self.type = ttype\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(ttype))",
  "def visualize(self, *args, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize the current magnetic field.\n\n        :param int nr:     Number of flux surfaces to show.\n        :param int ntheta: Number of poloidal angles per flux surface.\n        \"\"\"\n        # Ensure that settings are valid...\n        self.verifySettings()\n\n        if self.type == TYPE_ANALYTIC_TOROIDAL:\n            self.visualize_analytic(*args, ax=ax, show=show, **kwargs)\n        elif self.type == TYPE_NUMERICAL:\n            self.num_magneticfield.visualize(*args, ax=ax, show=show, **kwargs)\n        else:\n            raise DREAMException(\"RadialGrid: Can only visualize the analytic toroidal magnetic field.\")",
  "def visualize_analytic(self, nr=10, ntheta=40, ax=None, show=None, **kwargs):\n        \"\"\"\n        Visualize an analytic toroidal magnetic field.\n        \"\"\"\n        red   = (249/255, 65/255, 68/255)\n        black = (87/255, 117/255, 144/255)\n        gray  = (190/255, 190/255, 190/255)\n\n        # Set up axes (if not already done)\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n\n        # Generate r/theta grid\n        if self.a == 0:\n            # Custom radial grid (i.e. not generated by specifying r0 and a)\n            r_f = self.r_f\n            # Resample\n            r_f = np.interp(np.linspace(0, 1, nr)*r_f.size, range(r_f.size), r_f)\n        else:\n            r_f = np.linspace(self.r0, self.a, nr+1)\n\n        r   = (r_f[:-1] + r_f[1:]) / 2.0\n        t   = np.linspace(0, 2*np.pi, ntheta)\n\n        rr, tt = np.meshgrid(r, t)\n\n        # Helper interpolation function\n        def interppar(r, rParam, param):\n            f = None\n            if param.size == 1:\n                return param[0] * np.ones(r.shape)\n            elif param.size == 2:\n                f = scipy.interpolate.interp1d(rParam, param)\n            else:\n                # Not exactly what is done in the kernel (which uses Steffen\n                # interpolation, which is cubic and guarantees positivity)\n                f = scipy.interpolate.interp1d(rParam, param, kind='cubic', bounds_error=False, fill_value='extrapolate')\n\n            return f(r)\n\n        # Interpolate shaping parameters\n        Delta = lambda r : interppar(r, self.Delta_r, self.Delta)\n        delta = lambda r : interppar(r, self.delta_r, self.delta)\n        kappa = lambda r : interppar(r, self.kappa_r, self.kappa)\n\n        # Construct flux surfaces\n        if np.isinf(self.R0):\n            R = lambda r, t : Delta(r) + r*np.cos(t + delta(r)*np.sin(t))\n        else:\n            R = lambda r, t : self.R0 + Delta(r) + r*np.cos(t + delta(r)*np.sin(t))\n        Z = lambda r, t : r*kappa(r)*np.sin(t)\n\n        # Flux surfaces\n        ax.plot(R(rr, tt), Z(rr, tt), color=gray, linewidth=1, **kwargs)\n        # Limiter\n        ax.plot(R(r_f[-1], tt), Z(r_f[-1], tt), color=black, linewidth=2, **kwargs)\n        # Wall\n        ax.plot(R(np.array([self.b]), tt), Z(np.array([self.b]), tt), color=red, linewidth=2, **kwargs)\n        ax.axis('equal')\n\n        if np.isinf(self.R0):\n            ax.set_xlabel('Major radius $R-R_0$ (m)')\n        else:\n            ax.set_xlabel('Major radius $R$ (m)')\n        ax.set_ylabel('Height $Z$ (m)')\n\n        if show:\n            plt.show()\n\n        return ax",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = data['type']\n\n        if 'wall_radius' in data:\n            self.b = data['wall_radius']\n            if type(self.b) == np.ndarray:\n                self.b = float(self.b[0])\n            else:\n                self.b = float(self.b)\n\n        if self.type == TYPE_CYLINDRICAL or self.type == TYPE_ANALYTIC_TOROIDAL or self.type == TYPE_NUMERICAL:\n            self.a = data['a']\n            self.nr = data['nr']\n            self.r0 = data['r0']\n            if 'r_f' in data:\n                self.r_f = data['r_f']\n\n        if self.type == TYPE_CYLINDRICAL:\n            self.B0 = data['B0']\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            self.R0 = data['R0']\n            self.ntheta = data['ntheta']\n\n            self.Delta = data['Delta']['x']\n            self.Delta_r = data['Delta']['r']\n            self.delta = data['delta']['x']\n            self.delta_r = data['delta']['r']\n            self.GOverR0 = data['GOverR0']['x']\n            self.GOverR0_r = data['GOverR0']['r']\n            self.kappa = data['kappa']['x']\n            self.kappa_r = data['kappa']['r']\n            self.psi_p0 = data['psi_p0']['x']\n            self.psi_p0_r = data['psi_p0']['r']\n        elif self.type == TYPE_NUMERICAL:\n            self.num_filename = data['filename']\n            self.ntheta = data['ntheta']\n\n            if 'fileformat' in data:\n                self.num_fileformat = data['fileformat']\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        if 'ripple' in data:\n            self.ripple_ncoils = int(scal(data['ripple']['ncoils']))\n            self.ripple_deltacoils = float(scal(data['ripple']['deltacoils']))\n            self.ripple_m = data['ripple']['m']\n            self.ripple_n = data['ripple']['n']\n            self.ripple_dB_B = data['ripple']['x']\n            self.ripple_r = data['ripple']['r']\n            self.ripple_t = data['ripple']['t']\n\n        if 'dlnB0dt' in data:\n            self.dlnB0dt_x = data['dlnB0dt']['x']\n            self.dlnB0dt_t = data['dlnB0dt']['t']",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns the settings in this object as a Python dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type\n        }\n\n        if self.type == TYPE_CYLINDRICAL or self.type == TYPE_ANALYTIC_TOROIDAL or self.type == TYPE_NUMERICAL:\n            data['a'] = self.a\n            data['nr'] = self.nr\n            data['r0'] = self.r0\n            data['wall_radius'] = self.b\n            if self.r_f is not None:\n                data['r_f'] = self.r_f\n\n        if self.type == TYPE_CYLINDRICAL:\n            data['B0'] = self.B0\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            data['R0'] = self.R0\n            data['ntheta'] = self.ntheta\n\n            data['Delta']   = {'x': self.Delta, 'r': self.Delta_r}\n            data['delta']   = {'x': self.delta, 'r': self.delta_r}\n            data['GOverR0'] = {'x': self.GOverR0, 'r': self.GOverR0_r}\n            data['kappa']   = {'x': self.kappa, 'r': self.kappa_r}\n            data['psi_p0']  = {'x': self.psi_p0, 'r': self.psi_p0_r}\n        elif self.type == TYPE_NUMERICAL:\n            data['filename'] = self.num_filename\n            data['ntheta'] = self.ntheta\n\n            if self.num_fileformat is not None:\n                data['fileformat'] = self.num_fileformat\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        if self.ripple_ncoils > 0 or self.ripple_deltacoils > 0:\n            data['ripple'] = {\n                'ncoils': self.ripple_ncoils,\n                'deltacoils': self.ripple_deltacoils,\n                'm': self.ripple_m,\n                'n': self.ripple_n,\n                'x': self.ripple_dB_B,\n                'r': self.ripple_r,\n                't': self.ripple_t\n            }\n\n        if self.dlnB0dt_x is not None:\n            data['dlnB0dt'] = {\n                'x': self.dlnB0dt_x,\n                't': self.dlnB0dt_t\n            }\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verfiy that the RadialGrid settings are consistent.\n        \"\"\"\n        types = [TYPE_CYLINDRICAL, TYPE_ANALYTIC_TOROIDAL, TYPE_NUMERICAL]\n        if self.type in types:\n            if (self.a is None or self.a <= 0) and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to minor radius 'a': {}\".format(self.a))\n            elif (self.r0 is None or self.r0 < 0) and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to innermost simulated radius 'r0': {}\".format(self.r0))\n            elif self.b is None or self.b<self.a:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to wall radius 'b' (must be explicitly set to >= 'a' using 'setWallRadius'): \".format(self.b))\n            if self.r0 >= self.a and self.r_f is None:\n                raise DREAMException(\"RadialGrid: 'r0' must be strictly less than 'a'.\")\n            if self.nr <= 0 and self.r_f is None:\n                raise DREAMException(\"RadialGrid: Invalid value assigned 'nr': {}. Must be > 0.\".format(self.nr))\n            if not np.isscalar(self.b):\n                raise DREAMException(\"RadialGrid: The specified wall radius is not a scalar: {}.\".format(self.b))\n\n        if self.type == TYPE_CYLINDRICAL:\n            if self.B0 is None or self.B0 <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'B0': {}\".format(self.B0))\n        elif self.type == TYPE_ANALYTIC_TOROIDAL:\n            if self.R0 is None or self.R0 <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to tokamak major radius 'R0': {}\".format(self.R0))\n            elif self.ntheta <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}. Must be > 0.\".format(self.ntheta))\n\n            self.verifySettingsShapeParameter('Delta')\n            self.verifySettingsShapeParameter('delta')\n            self.verifySettingsShapeParameter('GOverR0')\n            self.verifySettingsShapeParameter('kappa')\n            self.verifySettingsShapeParameter('psi_p0')\n\n            if np.size(self.Delta_r)>1:\n                if self.Delta_r[0]==0 and self.Delta[0]!=0:\n                    print(\"*WARNING* RadialGrid: Shape parameter 'Delta' (Shafranov shift) is non-zero at r=0, which is inconsistent (add Delta(0) to the major radius R0 instead)\")\n            elif self.Delta!=0:\n                print(\"*WARNING* RadialGrid: Shape parameter 'Delta' (Shafranov shift) is assigned a constant non-zero value. It is recommended to add its value to the major radius R0 instead\")\n            if np.size(self.delta_r)>1:\n                if self.delta_r[0]==0 and self.delta[0]!=0:\n                    print(\"*WARNING* RadialGrid: Shape parameter 'delta' (triangularity) is non-zero at r=0, which is inconsistent with Grad-Shafranov\")\n        elif self.type == TYPE_NUMERICAL:\n            if type(self.num_filename) != str:\n                raise DREAMException(\"RadialGrid: No numerical magnetic field file specified.\")\n            elif not pathlib.Path(self.num_filename).is_file():\n                raise DREAMException(\"RadialGrid: The specified numerical magnetic field file does not exist.\")\n            elif self.ntheta <= 0:\n                raise DREAMException(\"RadialGrid: Invalid value assigned to 'ntheta': {}. Must be > 0.\".format(self.ntheta))\n\n            formats = [FILE_FORMAT_LUKE]\n            if (self.num_fileformat is not None) and (self.num_fileformat not in formats):\n                raise DREAMException(\"RadialGrid: Unrecognized file format specified for numerical magnetic field: {}.\".format(self.num_fileformat))\n        else:\n            raise DREAMException(\"RadialGrid: Unrecognized grid type specified: {}.\".format(self.type))\n\n        # Ripple settings\n        if self.ripple_ncoils > 0 or self.ripple_deltacoils > 0:\n            if type(self.ripple_m) != np.ndarray or self.ripple_m.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_m'.\")\n            elif type(self.ripple_n) != np.ndarray or self.ripple_n.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_n'.\")\n            elif self.ripple_m.size != self.ripple_n.size:\n                raise EquationException(\"RadialGrid: 'ripple_m' and 'ripple_n' must have the same number of elements.\")\n            elif type(self.ripple_r) != np.ndarray or self.ripple_r.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_r'.\")\n            elif type(self.ripple_t) != np.ndarray or self.ripple_t.ndim != 1:\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_t'.\")\n            elif type(self.ripple_dB_B) != np.ndarray or self.ripple_dB_B.shape != (self.ripple_m.size, self.ripple_t.size, self.ripple_r.size):\n                raise EquationException(\"RadialGrid: Invalid type or shape of 'ripple_dB_B'.\".format(self.ripple_dB_B))",
  "def verifySettingsShapeParameter(self, shapeparam):\n        \"\"\"\n        Verify the settings of the named shape parameter.\n        \n        :param str shapeparam: Name of shape parameter to verify settings for.\n        \"\"\"\n        v = getattr(self, shapeparam)\n        r = getattr(self, shapeparam+'_r')\n\n        if v is None or type(v) != np.ndarray:\n            raise DREAMException(\"RadialGrid: Invalid type of shape parameter '{}': {}.\".format(shapeparam, type(v)))\n        elif r is None or type(r) != np.ndarray:\n            raise DREAMException(\"RadialGrid: Invalid type of radial grid for shape parameter '{}': {}.\".format(shapeparam, type(r)))\n\n        if v.shape != r.shape:\n            raise DREAMException(\"RadialGrid: Dimensions mismatch between shape parameter '{}' {} and its radial grid {}.\".format(shapeparam, v.shape, r.shape))",
  "def interppar(r, rParam, param):\n            f = None\n            if param.size == 1:\n                return param[0] * np.ones(r.shape)\n            elif param.size == 2:\n                f = scipy.interpolate.interp1d(rParam, param)\n            else:\n                # Not exactly what is done in the kernel (which uses Steffen\n                # interpolation, which is cubic and guarantees positivity)\n                f = scipy.interpolate.interp1d(rParam, param, kind='cubic', bounds_error=False, fill_value='extrapolate')\n\n            return f(r)",
  "def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v",
  "class TimeStepper:\n    \n    def __init__(self, ttype=1, checkevery=0, tmax=None, dt=None, nt=None, nSaveSteps=0, reltol=1e-2, verbose=False, constantstep=False):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.set(ttype=ttype, checkevery=checkevery, tmax=tmax, dt=dt, nt=nt, nSaveSteps=nSaveSteps, reltol=reltol, verbose=verbose, constantstep=constantstep)\n        \n\n    def set(self, ttype=1, checkevery=0, tmax=None, dt=None, nt=None, nSaveSteps=0, reltol=1e-2, verbose=False, constantstep=False, minsavedt=0):\n        \"\"\"\n        Set properties of the time stepper.\n        \"\"\"\n        self.type = int(ttype)\n\n        self.setCheckInterval(checkevery)\n        self.setTmax(tmax)\n        self.setDt(dt)\n        self.setNt(nt)\n        self.setMinSaveTimestep(minsavedt)\n        self.setNumberOfSaveSteps(nSaveSteps)\n        self.setVerbose(verbose)\n        self.setConstantStep(constantstep)       \n        self.tolerance = ToleranceSettings()\n        self.tolerance.set(reltol=reltol)\n        \n        self.dtmax = None\n        self.automaticstep = None\n        self.safetyfactor = None\n\n\n    def __contains__(self, item):\n        return (item in self.todict(False))\n\n\n    def __getitem__(self, key):\n        return self.todict(False)[key]\n\n\n    ######################\n    # SETTERS\n    ######################\n    def setCheckInterval(self, checkevery):\n        if checkevery < 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'checkevery': {}\".format(checkevery))\n        \n        self.checkevery = int(checkevery)\n\n\n    def setConstantStep(self, constantstep):\n        self.constantstep = bool(constantstep)\n\n\n    def setDt(self, dt):\n        if dt is None:\n            self.dt = None\n            return\n\n        if dt < 0 or (dt == 0 and self.type != TYPE_IONIZATION):\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'dt': {}\".format(tmax))\n        if self.nt is not None and dt > 0:\n            raise DREAMException(\"TimeStepper: 'dt' may not be set alongside 'nt'.\")\n            \n        self.dt = float(dt)\n\n\n    def setMinSaveTimestep(self, dt):\n        \"\"\"\n        For the adapative ionization-based time stepper, sets the minimum\n        time which must elapse between two saved time steps.\n        \"\"\"\n        self.minsavedt = dt\n\n\n    def setNt(self, nt):\n        if nt is None:\n            self.nt = None\n            return\n\n        if nt <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'dt': {}\".format(tmax))\n        if self.dt is not None and self.dt > 0:\n            raise DREAMException(\"TimeStepper: 'nt' may not be set alongside 'dt'.\")\n            \n        self.nt = int(nt)\n\n\n    def setNumberOfSaveSteps(self, nSaveSteps):\n        \"\"\"\n        Sets the number of time steps to save to the output file.\n        This number must be <= Nt. If 0, all time steps are saved.\n        \"\"\"\n        self.nSaveSteps = nSaveSteps\n\n\n    def setRelTol(self, reltol): self.setRelativeTolerance(reltol=reltol)\n\n\n    def setRelativeTolerance(self, reltol):\n        if reltol <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'reltol': {}\".format(reltol))\n\n        self.tolerance.set(reltol=float(reltol))\n\n\n    def setTmax(self, tmax):\n        if tmax is None:\n            self.tmax = None\n            return\n\n        if tmax <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'tmax': {}\".format(tmax))\n\n        self.tmax = float(tmax)\n\n\n    def setType(self, ttype, *args, **kwargs):\n        if ttype not in [TYPE_CONSTANT, TYPE_ADAPTIVE, TYPE_IONIZATION]:\n            raise DREAMException(\"TimeStepper: Unrecognized time stepper type specified: {}\".format(ttype))\n\n        if ttype in [TYPE_ADAPTIVE, TYPE_IONIZATION]:\n            self.nt = None\n\n        self.type = int(ttype)\n        \n        if ttype == TYPE_IONIZATION:\n            self.setIonization(*args, **kwargs)\n    \n\n    def setIonization(self, dt0=0, dtmax=0, tmax=None, automaticstep=1e-12, safetyfactor=50):\n        \"\"\"\n        Select and set parameters for the ionization time stepper.\n        \"\"\"\n        self.type = TYPE_IONIZATION\n        self.dt = dt0\n        self.dtmax = dtmax\n        self.automaticstep = automaticstep\n        self.safetyfactor = safetyfactor\n\n        if tmax is not None:\n            self.tmax = tmax\n\n\n    def setVerbose(self, verbose=True):\n        self.verbose = bool(verbose)\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = data['type']\n        self.tmax = data['tmax']\n\n        if type(self.type) == np.ndarray: self.type = int(self.type.flatten()[0])\n        if type(self.tmax) == np.ndarray: self.tmax = float(self.tmax.flatten()[0])\n\n        if 'automaticstep' in data: self.automaticstep = float(scal(data['automaticstep']))\n        if 'checkevery' in data: self.checkevery = int(scal(data['checkevery']))\n        if 'constantstep' in data: self.constantstep = bool(scal(data['constantstep']))\n        if 'dt' in data: self.dt = float(scal(data['dt']))\n        if 'dtmax' in data: self.dtmax = float(scal(data['dtmax']))\n        if 'minsavedt' in data: self.minsavedt = float(scal(data['minsavedt']))\n        if 'nt' in data: self.nt = int(scal(data['nt']))\n        if 'nsavesteps' in data: self.nSaveSteps = int(scal(data['nsavesteps']))\n        if 'verbose' in data: self.verbose = bool(scal(data['verbose']))\n        if 'safetyfactor' in data: self.safetyfactor = float(scal(data['safetyfactor']))\n        if 'tolerance' in data: self.tolerance.fromdict(data['tolerance'])\n        \n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this TimeStepper object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type,\n            'tmax': self.tmax\n        }\n\n        if self.dt is not None: data['dt'] = self.dt\n\n        if self.type == TYPE_CONSTANT:\n            if self.nt is not None: data['nt'] = self.nt\n            data['nsavesteps'] = int(self.nSaveSteps)\n        elif self.type == TYPE_ADAPTIVE:\n            data['checkevery'] = self.checkevery\n            data['constantstep'] = self.constantstep\n            data['tolerance'] = self.tolerance.todict()\n            data['verbose'] = self.verbose\n        elif self.type == TYPE_IONIZATION:\n            if self.dtmax is not None: data['dtmax'] = self.dtmax\n            data['automaticstep'] = self.automaticstep\n            data['safetyfactor'] = self.safetyfactor\n            data['minsavedt'] = self.minsavedt\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the TimeStepper settings are consistent.\n        \"\"\"\n        if self.type == TYPE_CONSTANT:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper constant: 'tmax' must be set to a value > 0.\")\n            \n            # Verify that _exactly_ one of 'dt' and 'nt' is\n            # set to a valid value\n            dtSet = (self.dt is not None and self.dt > 0)\n            ntSet = (self.nt is not None and self.nt > 0)\n\n            if dtSet and ntSet:\n                raise DREAMException(\"TimeStepper constant: Exactly one of 'dt' and 'nt' must be > 0.\")\n\n            if self.nSaveSteps < 0 or (ntSet and self.nSaveSteps > self.nt):\n                raise DREAMException(\"TimeStepper constant: Invalid value assigned to 'nSaveSteps'. Must between 0 and nt.\")\n        elif self.type == TYPE_ADAPTIVE:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper adaptive: 'tmax' must be set to a value > 0.\")\n            elif self.nt is not None:\n                raise DREAMException(\"TimeStepper adaptive: 'nt' cannot be used with the adaptive time stepper.\")\n\n            if type(self.checkevery) != int or self.checkevery < 0:\n                raise DREAMException(\"TimeStepper adaptive: 'checkevery' must be a non-negative integer.\")\n            elif type(self.verbose) != bool:\n                raise DREAMException(\"TimeStepper adaptive: 'verbose' must be a boolean.\")\n            elif type(self.constantstep) != bool:\n                raise DREAMException(\"TimeStepper adaptive: 'constantstep' must be a boolean.\")\n            self.tolerance.verifySettings()\n        elif self.type == TYPE_IONIZATION:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper ionization: 'tmax' must be set to a value > 0.\")\n            elif self.dt is None or self.dt < 0:\n                raise DREAMException(\"TimeStepper ionization: 'dt' must be set to a non-negative value.\")\n            elif self.dtmax is None or self.dtmax < 0:\n                raise DREAMException(\"TimeStepper ionization: 'dtmax' must be set to a non-negative value.\")\n            elif self.minsavedt < 0:\n                raise DREAMException(\"TimeStepper ionization: 'minsavedt' must be non-negative.\")\n        else:\n            raise DREAMException(\"Unrecognized time stepper type selected: {}.\".format(self.type))",
  "def __init__(self, ttype=1, checkevery=0, tmax=None, dt=None, nt=None, nSaveSteps=0, reltol=1e-2, verbose=False, constantstep=False):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.set(ttype=ttype, checkevery=checkevery, tmax=tmax, dt=dt, nt=nt, nSaveSteps=nSaveSteps, reltol=reltol, verbose=verbose, constantstep=constantstep)",
  "def set(self, ttype=1, checkevery=0, tmax=None, dt=None, nt=None, nSaveSteps=0, reltol=1e-2, verbose=False, constantstep=False, minsavedt=0):\n        \"\"\"\n        Set properties of the time stepper.\n        \"\"\"\n        self.type = int(ttype)\n\n        self.setCheckInterval(checkevery)\n        self.setTmax(tmax)\n        self.setDt(dt)\n        self.setNt(nt)\n        self.setMinSaveTimestep(minsavedt)\n        self.setNumberOfSaveSteps(nSaveSteps)\n        self.setVerbose(verbose)\n        self.setConstantStep(constantstep)       \n        self.tolerance = ToleranceSettings()\n        self.tolerance.set(reltol=reltol)\n        \n        self.dtmax = None\n        self.automaticstep = None\n        self.safetyfactor = None",
  "def __contains__(self, item):\n        return (item in self.todict(False))",
  "def __getitem__(self, key):\n        return self.todict(False)[key]",
  "def setCheckInterval(self, checkevery):\n        if checkevery < 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'checkevery': {}\".format(checkevery))\n        \n        self.checkevery = int(checkevery)",
  "def setConstantStep(self, constantstep):\n        self.constantstep = bool(constantstep)",
  "def setDt(self, dt):\n        if dt is None:\n            self.dt = None\n            return\n\n        if dt < 0 or (dt == 0 and self.type != TYPE_IONIZATION):\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'dt': {}\".format(tmax))\n        if self.nt is not None and dt > 0:\n            raise DREAMException(\"TimeStepper: 'dt' may not be set alongside 'nt'.\")\n            \n        self.dt = float(dt)",
  "def setMinSaveTimestep(self, dt):\n        \"\"\"\n        For the adapative ionization-based time stepper, sets the minimum\n        time which must elapse between two saved time steps.\n        \"\"\"\n        self.minsavedt = dt",
  "def setNt(self, nt):\n        if nt is None:\n            self.nt = None\n            return\n\n        if nt <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'dt': {}\".format(tmax))\n        if self.dt is not None and self.dt > 0:\n            raise DREAMException(\"TimeStepper: 'nt' may not be set alongside 'dt'.\")\n            \n        self.nt = int(nt)",
  "def setNumberOfSaveSteps(self, nSaveSteps):\n        \"\"\"\n        Sets the number of time steps to save to the output file.\n        This number must be <= Nt. If 0, all time steps are saved.\n        \"\"\"\n        self.nSaveSteps = nSaveSteps",
  "def setRelTol(self, reltol): self.setRelativeTolerance(reltol=reltol)",
  "def setRelativeTolerance(self, reltol):\n        if reltol <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'reltol': {}\".format(reltol))\n\n        self.tolerance.set(reltol=float(reltol))",
  "def setTmax(self, tmax):\n        if tmax is None:\n            self.tmax = None\n            return\n\n        if tmax <= 0:\n            raise DREAMException(\"TimeStepper: Invalid value assigned to 'tmax': {}\".format(tmax))\n\n        self.tmax = float(tmax)",
  "def setType(self, ttype, *args, **kwargs):\n        if ttype not in [TYPE_CONSTANT, TYPE_ADAPTIVE, TYPE_IONIZATION]:\n            raise DREAMException(\"TimeStepper: Unrecognized time stepper type specified: {}\".format(ttype))\n\n        if ttype in [TYPE_ADAPTIVE, TYPE_IONIZATION]:\n            self.nt = None\n\n        self.type = int(ttype)\n        \n        if ttype == TYPE_IONIZATION:\n            self.setIonization(*args, **kwargs)",
  "def setIonization(self, dt0=0, dtmax=0, tmax=None, automaticstep=1e-12, safetyfactor=50):\n        \"\"\"\n        Select and set parameters for the ionization time stepper.\n        \"\"\"\n        self.type = TYPE_IONIZATION\n        self.dt = dt0\n        self.dtmax = dtmax\n        self.automaticstep = automaticstep\n        self.safetyfactor = safetyfactor\n\n        if tmax is not None:\n            self.tmax = tmax",
  "def setVerbose(self, verbose=True):\n        self.verbose = bool(verbose)",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = data['type']\n        self.tmax = data['tmax']\n\n        if type(self.type) == np.ndarray: self.type = int(self.type.flatten()[0])\n        if type(self.tmax) == np.ndarray: self.tmax = float(self.tmax.flatten()[0])\n\n        if 'automaticstep' in data: self.automaticstep = float(scal(data['automaticstep']))\n        if 'checkevery' in data: self.checkevery = int(scal(data['checkevery']))\n        if 'constantstep' in data: self.constantstep = bool(scal(data['constantstep']))\n        if 'dt' in data: self.dt = float(scal(data['dt']))\n        if 'dtmax' in data: self.dtmax = float(scal(data['dtmax']))\n        if 'minsavedt' in data: self.minsavedt = float(scal(data['minsavedt']))\n        if 'nt' in data: self.nt = int(scal(data['nt']))\n        if 'nsavesteps' in data: self.nSaveSteps = int(scal(data['nsavesteps']))\n        if 'verbose' in data: self.verbose = bool(scal(data['verbose']))\n        if 'safetyfactor' in data: self.safetyfactor = float(scal(data['safetyfactor']))\n        if 'tolerance' in data: self.tolerance.fromdict(data['tolerance'])\n        \n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this TimeStepper object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type,\n            'tmax': self.tmax\n        }\n\n        if self.dt is not None: data['dt'] = self.dt\n\n        if self.type == TYPE_CONSTANT:\n            if self.nt is not None: data['nt'] = self.nt\n            data['nsavesteps'] = int(self.nSaveSteps)\n        elif self.type == TYPE_ADAPTIVE:\n            data['checkevery'] = self.checkevery\n            data['constantstep'] = self.constantstep\n            data['tolerance'] = self.tolerance.todict()\n            data['verbose'] = self.verbose\n        elif self.type == TYPE_IONIZATION:\n            if self.dtmax is not None: data['dtmax'] = self.dtmax\n            data['automaticstep'] = self.automaticstep\n            data['safetyfactor'] = self.safetyfactor\n            data['minsavedt'] = self.minsavedt\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the TimeStepper settings are consistent.\n        \"\"\"\n        if self.type == TYPE_CONSTANT:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper constant: 'tmax' must be set to a value > 0.\")\n            \n            # Verify that _exactly_ one of 'dt' and 'nt' is\n            # set to a valid value\n            dtSet = (self.dt is not None and self.dt > 0)\n            ntSet = (self.nt is not None and self.nt > 0)\n\n            if dtSet and ntSet:\n                raise DREAMException(\"TimeStepper constant: Exactly one of 'dt' and 'nt' must be > 0.\")\n\n            if self.nSaveSteps < 0 or (ntSet and self.nSaveSteps > self.nt):\n                raise DREAMException(\"TimeStepper constant: Invalid value assigned to 'nSaveSteps'. Must between 0 and nt.\")\n        elif self.type == TYPE_ADAPTIVE:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper adaptive: 'tmax' must be set to a value > 0.\")\n            elif self.nt is not None:\n                raise DREAMException(\"TimeStepper adaptive: 'nt' cannot be used with the adaptive time stepper.\")\n\n            if type(self.checkevery) != int or self.checkevery < 0:\n                raise DREAMException(\"TimeStepper adaptive: 'checkevery' must be a non-negative integer.\")\n            elif type(self.verbose) != bool:\n                raise DREAMException(\"TimeStepper adaptive: 'verbose' must be a boolean.\")\n            elif type(self.constantstep) != bool:\n                raise DREAMException(\"TimeStepper adaptive: 'constantstep' must be a boolean.\")\n            self.tolerance.verifySettings()\n        elif self.type == TYPE_IONIZATION:\n            if self.tmax is None or self.tmax <= 0:\n                raise DREAMException(\"TimeStepper ionization: 'tmax' must be set to a value > 0.\")\n            elif self.dt is None or self.dt < 0:\n                raise DREAMException(\"TimeStepper ionization: 'dt' must be set to a non-negative value.\")\n            elif self.dtmax is None or self.dtmax < 0:\n                raise DREAMException(\"TimeStepper ionization: 'dtmax' must be set to a non-negative value.\")\n            elif self.minsavedt < 0:\n                raise DREAMException(\"TimeStepper ionization: 'minsavedt' must be non-negative.\")\n        else:\n            raise DREAMException(\"Unrecognized time stepper type selected: {}.\".format(self.type))",
  "def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v",
  "class XiGrid:\n    def __init__(self, name, parent, ttype=TYPE_UNIFORM, nxi=0, data=None):\n        \"\"\"\n        Constructor.\n\n          name:  Name of grid (e.g. 'hottailgrid' or 'runawaygrid')\n        AND\n          ttype: Grid type.\n          np:    Number of p grid points.\n          pmax:  Maximum value of p.\n        OR\n          data:  Dictionary containing all of the above settings\n                 (except 'ttype' should be called 'xigrid')\n        \"\"\"\n        self.name = name\n        self.parent = parent\n\n        self.nxisep = None\n        self.nxisep_frac = None\n        self.xisep  = None\n        self.nthetasep = None\n        self.nthetasep_frac = None\n        self.thetasep  = None\n\n        self.trapped_dxiMax = None\n        self.trapped_NxiPass = None\n        self.trapped_NxiTrap = None\n        self.trapped_blWidth = None     # Trapped/passing boundary layer width\n\n        self.xi_f = None\n\n        if data is not None:\n            self.fromdict(data)\n        else:\n            self.setType(ttype=ttype)\n            self.setNxi(nxi)\n\n\n    ####################\n    # GETTERS\n    ####################\n    def getNxi(self): return self.nxi\n    def getType(self): return self.type\n\n\n    ####################\n    # SETTERS\n    ####################\n    def setNxi(self, nxi):\n        self.nxi = int(nxi)\n\n\n    def setBiuniform(self, xisep=None, nxisep = None, nxisep_frac = None,thetasep = None, nthetasep =None, nthetasep_frac=None ):\n       \n        if xisep is not None:\n            self.type = TYPE_BIUNIFORM\n            self.xisep = float(xisep)\n            if nxisep is not None:\n                self.nxisep = int(nxisep)\n                self.nxisep_frac = None\n            elif nxisep_frac is not None:\n                self.nxisep = None\n                self.nxisep_frac = nxisep_frac\n            else:\n                raise DREAMException(\"XiGrid biuniform {}: nxisep or nxisep_frac must be set.\")\n        elif thetasep is not None:\n            self.type = TYPE_BIUNIFORM_THETA\n            self.thetasep = float(thetasep)\n            if nthetasep is not None:\n                self.nthetasep = int(nthetasep)\n                self.nthetasep_frac = None\n            elif nthetasep_frac is not None:\n                self.nthetasep = None\n                self.nthetasep_frac = nthetasep_frac\n            else:\n                raise DREAMException(\"XiGrid biuniform theta {}: nthetasep or nthetasep_frac must be set.\")\n        else:\t\n            raise DREAMException(\"XiGrid biuniform  {}: thetasep or xisep must be set.\")\n\n    def setCustomGridPoints(self, xi_f):\n        \"\"\"\n        Set an arbitrary custom grid point distribution\n        on the pitch flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'nxi', which will be taken as the number of cells\n        described by the prescribed grid points.\n\n        :param float xi_f: List of pitch flux grid points\n        \"\"\"\n        self.type = TYPE_CUSTOM\n        if type(xi_f)==list:\n            xi_f = np.array(xi_f)\n        if np.size(xi_f)<2:\n            raise EquationException(\"XiGrid: Custom grid point vector 'xi_f' must have size 2 or greater.\")\n        for i in range(np.size(xi_f)-1):\n            if not xi_f[i+1]>xi_f[i]:\n                raise EquationException(\"XiGrid: Custom grid points 'xi_f' must be an array of increasing numbers.\")\n        if np.min(xi_f)!=-1 or np.max(xi_f)!=1:\n            raise EquationException(\"XiGrid: Custom pitch grid must span [-1,1].\")\n        self.xi_f = xi_f\n        if self.nxi != 0:\n            print(\"*WARNING* XiGrid: Prescibing custom pitch grid overrides 'nxi'.\")\n        self.nxi = np.size(self.xi_f) - 1\n\n\n    def setTrappedPassingBoundaryLayerGrid(self, dxiMax=2, NxiPass=1, NxiTrap=1, boundaryLayerWidth=1e-3):\n        self.setType(TYPE_TRAPPED)\n\n        self.trapped_dxiMax = float(dxiMax)\n        self.trapped_NxiPass = int(NxiPass)\n        self.trapped_NxiTrap = int(NxiTrap)\n        self.trapped_blWidth = float(boundaryLayerWidth)\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Set the type of xi grid generator.\n        \"\"\"\n        if ttype in [TYPE_UNIFORM,TYPE_BIUNIFORM,TYPE_UNIFORM_THETA,TYPE_BIUNIFORM_THETA,TYPE_CUSTOM,TYPE_TRAPPED]:\n            self.type = ttype\n        else:\n            raise DREAMException(\"XiGrid {}: Unrecognized grid type specified: {}.\".format(self.name, ttype))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load this xi-grid from the specified dictionary.\n        \"\"\"\n        self.type = data['xigrid']\n        self.nxi  = data['nxi']\n        if self.type == TYPE_BIUNIFORM:\n            self.xisep  = data['xisep']\n            if 'nxisep' in data:\n                self.nxisep = int(data['nxisep'])\n            elif 'nxisep_frac' in data:\n                self.nxisep_frac = float(data['nxisep_frac'])\n        \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            self.thetasep  = data['xisep']\n            if 'nxisep' in data:\n                self.nthetasep = int(data['nxisep'])\n            elif 'nxisep_frac' in data:\n                self.nthetasep_frac = float(data['nxisep_frac'])\n        elif self.type == TYPE_CUSTOM:\n            self.xi_f = data['xi_f']\n        elif self.type == TYPE_TRAPPED:\n            self.trapped_dxiMax = float(data['dximax'])\n            self.trapped_NxiPass = int(data['nxipass'])\n            self.trapped_NxiTrap = int(data['nxitrap'])\n            self.trapped_blWidth = float(data['boundarylayerwidth'])\n            \n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this XiGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = { \n            'xigrid': self.type, \n            'nxi': self.nxi,\n        }\n        if self.type == TYPE_BIUNIFORM:\n            if self.nxisep is not None:\n                data['nxisep'] = self.nxisep\n            elif self.nxisep_frac is not None:\n                #data['nxisep'] = int(round(self.nxi*self.nxisep_frac))\n                data['nxisep_frac'] = self.nxisep_frac\n            else:\n                raise DREAMException(\"XiGrid {}: Neither 'nxisep' nor 'nxisep_frac' have been specified.\".format(self.name))\n\n            data['xisep'] = self.xisep\n            \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            if self.nthetasep is not None:\n                data['nxisep'] = self.nthetasep\n            elif self.nthetasep_frac is not None:\n                #data['nxisep'] = int(round(self.nxi*self.nthetasep_frac))\n                data['nxisep_frac'] = self.nthetasep_frac\n\n            data['xisep'] = self.thetasep\n        elif self.type == TYPE_CUSTOM:\n            data['xi_f'] = self.xi_f\n        elif self.type == TYPE_TRAPPED:\n            data['dximax'] = self.trapped_dxiMax\n            data['nxipass'] = self.trapped_NxiPass\n            data['nxitrap'] = self.trapped_NxiTrap\n            data['boundarylayerwidth'] = self.trapped_blWidth\n\n        return data\n\n    \n    def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if not self.parent.enabled:\n            return\n\n        if self.type in [TYPE_UNIFORM,TYPE_BIUNIFORM,TYPE_UNIFORM_THETA,TYPE_BIUNIFORM_THETA,TYPE_CUSTOM]:\n            if self.nxi is None or self.nxi <= 0:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxi': {}. Must be > 0.\".format(self.name, self.nxi))\n        elif self.type in [TYPE_TRAPPED]:\n            # No further checkes required here\n            pass\n        else:\n            raise DREAMException(\"XiGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))\n\n        if self.type == TYPE_BIUNIFORM:\n            if self.nxisep is not None and (self.nxisep <= 0 or self.nxisep >= self.nxi):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxisep': {}. Must be > 0 and < nxi.\".format(self.name, self.nxisep))\n            if self.nxisep_frac is not None and (self.nxisep_frac <= 0 or self.nxisep_frac >= 1):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxisep_frac': {}. Must be > 0 and < 1.\".format(self.name, self.nxisep))\n            elif self.nxisep is None and self.nxisep_frac is None:\n                raise DREAMException(\"XiGrid {}: Neither 'nxisep' nor 'nxisep_frac' have been specified.\".format(self.name))\n            elif self.xisep is None or self.xisep <= -1 or self.xisep >= 1:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'xisep': {}. Must be > -1 and < 1.\".format(self.name, self.xisep))\n                \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            if self.nthetasep is not None and (self.nthetasep <= 0 or self.nthetasep >= self.nxi):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nthetasep': {}. Must be > 0 and < nxi.\".format(self.name, self.nthetasep))\n            elif self.nthetasep_frac is not None and (self.nthetasep_frac <= 0 or self.nthetasep_frac >= 1):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nthetasep_frac': {}. Must be > 0 and < 1.\".format(self.name, self.nthetasep_frac))\n            elif self.nthetasep is None and self.nthetasep_frac is None:\n                raise DREAMException(\"XiGrid {}: Neither 'nthetasep' nor 'nthetasep_frac' have been specified.\".format(self.name))\n            elif self.thetasep is None or self.thetasep <= 0 or self.thetasep >= np.pi:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'thetasep': {}. Must be > 0 and < pi.\".format(self.name, self.thetasep))\n        elif self.type == TYPE_TRAPPED:\n            if self.trapped_dxiMax <= 0:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'dxiMax' must be > 0.\".format(self.name))\n            elif self.trapped_NxiPass < 1:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'NxiPass' must be > 0.\".format(self.name))\n            elif self.trapped_NxiTrap < 1:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'NxiTrap' must be > 0.\".format(self.name))\n            elif self.trapped_blWidth <= 0:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'boundaryLayerWidth' must be > 0.\".format(self.name))",
  "def __init__(self, name, parent, ttype=TYPE_UNIFORM, nxi=0, data=None):\n        \"\"\"\n        Constructor.\n\n          name:  Name of grid (e.g. 'hottailgrid' or 'runawaygrid')\n        AND\n          ttype: Grid type.\n          np:    Number of p grid points.\n          pmax:  Maximum value of p.\n        OR\n          data:  Dictionary containing all of the above settings\n                 (except 'ttype' should be called 'xigrid')\n        \"\"\"\n        self.name = name\n        self.parent = parent\n\n        self.nxisep = None\n        self.nxisep_frac = None\n        self.xisep  = None\n        self.nthetasep = None\n        self.nthetasep_frac = None\n        self.thetasep  = None\n\n        self.trapped_dxiMax = None\n        self.trapped_NxiPass = None\n        self.trapped_NxiTrap = None\n        self.trapped_blWidth = None     # Trapped/passing boundary layer width\n\n        self.xi_f = None\n\n        if data is not None:\n            self.fromdict(data)\n        else:\n            self.setType(ttype=ttype)\n            self.setNxi(nxi)",
  "def getNxi(self): return self.nxi",
  "def getType(self): return self.type",
  "def setNxi(self, nxi):\n        self.nxi = int(nxi)",
  "def setBiuniform(self, xisep=None, nxisep = None, nxisep_frac = None,thetasep = None, nthetasep =None, nthetasep_frac=None ):\n       \n        if xisep is not None:\n            self.type = TYPE_BIUNIFORM\n            self.xisep = float(xisep)\n            if nxisep is not None:\n                self.nxisep = int(nxisep)\n                self.nxisep_frac = None\n            elif nxisep_frac is not None:\n                self.nxisep = None\n                self.nxisep_frac = nxisep_frac\n            else:\n                raise DREAMException(\"XiGrid biuniform {}: nxisep or nxisep_frac must be set.\")\n        elif thetasep is not None:\n            self.type = TYPE_BIUNIFORM_THETA\n            self.thetasep = float(thetasep)\n            if nthetasep is not None:\n                self.nthetasep = int(nthetasep)\n                self.nthetasep_frac = None\n            elif nthetasep_frac is not None:\n                self.nthetasep = None\n                self.nthetasep_frac = nthetasep_frac\n            else:\n                raise DREAMException(\"XiGrid biuniform theta {}: nthetasep or nthetasep_frac must be set.\")\n        else:\t\n            raise DREAMException(\"XiGrid biuniform  {}: thetasep or xisep must be set.\")",
  "def setCustomGridPoints(self, xi_f):\n        \"\"\"\n        Set an arbitrary custom grid point distribution\n        on the pitch flux grid (i.e. the locations of\n        the cell edges). This overrides the grid resolution\n        'nxi', which will be taken as the number of cells\n        described by the prescribed grid points.\n\n        :param float xi_f: List of pitch flux grid points\n        \"\"\"\n        self.type = TYPE_CUSTOM\n        if type(xi_f)==list:\n            xi_f = np.array(xi_f)\n        if np.size(xi_f)<2:\n            raise EquationException(\"XiGrid: Custom grid point vector 'xi_f' must have size 2 or greater.\")\n        for i in range(np.size(xi_f)-1):\n            if not xi_f[i+1]>xi_f[i]:\n                raise EquationException(\"XiGrid: Custom grid points 'xi_f' must be an array of increasing numbers.\")\n        if np.min(xi_f)!=-1 or np.max(xi_f)!=1:\n            raise EquationException(\"XiGrid: Custom pitch grid must span [-1,1].\")\n        self.xi_f = xi_f\n        if self.nxi != 0:\n            print(\"*WARNING* XiGrid: Prescibing custom pitch grid overrides 'nxi'.\")\n        self.nxi = np.size(self.xi_f) - 1",
  "def setTrappedPassingBoundaryLayerGrid(self, dxiMax=2, NxiPass=1, NxiTrap=1, boundaryLayerWidth=1e-3):\n        self.setType(TYPE_TRAPPED)\n\n        self.trapped_dxiMax = float(dxiMax)\n        self.trapped_NxiPass = int(NxiPass)\n        self.trapped_NxiTrap = int(NxiTrap)\n        self.trapped_blWidth = float(boundaryLayerWidth)",
  "def setType(self, ttype):\n        \"\"\"\n        Set the type of xi grid generator.\n        \"\"\"\n        if ttype in [TYPE_UNIFORM,TYPE_BIUNIFORM,TYPE_UNIFORM_THETA,TYPE_BIUNIFORM_THETA,TYPE_CUSTOM,TYPE_TRAPPED]:\n            self.type = ttype\n        else:\n            raise DREAMException(\"XiGrid {}: Unrecognized grid type specified: {}.\".format(self.name, ttype))",
  "def fromdict(self, data):\n        \"\"\"\n        Load this xi-grid from the specified dictionary.\n        \"\"\"\n        self.type = data['xigrid']\n        self.nxi  = data['nxi']\n        if self.type == TYPE_BIUNIFORM:\n            self.xisep  = data['xisep']\n            if 'nxisep' in data:\n                self.nxisep = int(data['nxisep'])\n            elif 'nxisep_frac' in data:\n                self.nxisep_frac = float(data['nxisep_frac'])\n        \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            self.thetasep  = data['xisep']\n            if 'nxisep' in data:\n                self.nthetasep = int(data['nxisep'])\n            elif 'nxisep_frac' in data:\n                self.nthetasep_frac = float(data['nxisep_frac'])\n        elif self.type == TYPE_CUSTOM:\n            self.xi_f = data['xi_f']\n        elif self.type == TYPE_TRAPPED:\n            self.trapped_dxiMax = float(data['dximax'])\n            self.trapped_NxiPass = int(data['nxipass'])\n            self.trapped_NxiTrap = int(data['nxitrap'])\n            self.trapped_blWidth = float(data['boundarylayerwidth'])\n            \n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this XiGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = { \n            'xigrid': self.type, \n            'nxi': self.nxi,\n        }\n        if self.type == TYPE_BIUNIFORM:\n            if self.nxisep is not None:\n                data['nxisep'] = self.nxisep\n            elif self.nxisep_frac is not None:\n                #data['nxisep'] = int(round(self.nxi*self.nxisep_frac))\n                data['nxisep_frac'] = self.nxisep_frac\n            else:\n                raise DREAMException(\"XiGrid {}: Neither 'nxisep' nor 'nxisep_frac' have been specified.\".format(self.name))\n\n            data['xisep'] = self.xisep\n            \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            if self.nthetasep is not None:\n                data['nxisep'] = self.nthetasep\n            elif self.nthetasep_frac is not None:\n                #data['nxisep'] = int(round(self.nxi*self.nthetasep_frac))\n                data['nxisep_frac'] = self.nthetasep_frac\n\n            data['xisep'] = self.thetasep\n        elif self.type == TYPE_CUSTOM:\n            data['xi_f'] = self.xi_f\n        elif self.type == TYPE_TRAPPED:\n            data['dximax'] = self.trapped_dxiMax\n            data['nxipass'] = self.trapped_NxiPass\n            data['nxitrap'] = self.trapped_NxiTrap\n            data['boundarylayerwidth'] = self.trapped_blWidth\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if not self.parent.enabled:\n            return\n\n        if self.type in [TYPE_UNIFORM,TYPE_BIUNIFORM,TYPE_UNIFORM_THETA,TYPE_BIUNIFORM_THETA,TYPE_CUSTOM]:\n            if self.nxi is None or self.nxi <= 0:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxi': {}. Must be > 0.\".format(self.name, self.nxi))\n        elif self.type in [TYPE_TRAPPED]:\n            # No further checkes required here\n            pass\n        else:\n            raise DREAMException(\"XiGrid {}: Unrecognized grid type specified: {}.\".format(self.name, self.type))\n\n        if self.type == TYPE_BIUNIFORM:\n            if self.nxisep is not None and (self.nxisep <= 0 or self.nxisep >= self.nxi):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxisep': {}. Must be > 0 and < nxi.\".format(self.name, self.nxisep))\n            if self.nxisep_frac is not None and (self.nxisep_frac <= 0 or self.nxisep_frac >= 1):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nxisep_frac': {}. Must be > 0 and < 1.\".format(self.name, self.nxisep))\n            elif self.nxisep is None and self.nxisep_frac is None:\n                raise DREAMException(\"XiGrid {}: Neither 'nxisep' nor 'nxisep_frac' have been specified.\".format(self.name))\n            elif self.xisep is None or self.xisep <= -1 or self.xisep >= 1:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'xisep': {}. Must be > -1 and < 1.\".format(self.name, self.xisep))\n                \n        elif self.type == TYPE_BIUNIFORM_THETA:\n            if self.nthetasep is not None and (self.nthetasep <= 0 or self.nthetasep >= self.nxi):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nthetasep': {}. Must be > 0 and < nxi.\".format(self.name, self.nthetasep))\n            elif self.nthetasep_frac is not None and (self.nthetasep_frac <= 0 or self.nthetasep_frac >= 1):\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'nthetasep_frac': {}. Must be > 0 and < 1.\".format(self.name, self.nthetasep_frac))\n            elif self.nthetasep is None and self.nthetasep_frac is None:\n                raise DREAMException(\"XiGrid {}: Neither 'nthetasep' nor 'nthetasep_frac' have been specified.\".format(self.name))\n            elif self.thetasep is None or self.thetasep <= 0 or self.thetasep >= np.pi:\n                raise DREAMException(\"XiGrid {}: Invalid value assigned to 'thetasep': {}. Must be > 0 and < pi.\".format(self.name, self.thetasep))\n        elif self.type == TYPE_TRAPPED:\n            if self.trapped_dxiMax <= 0:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'dxiMax' must be > 0.\".format(self.name))\n            elif self.trapped_NxiPass < 1:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'NxiPass' must be > 0.\".format(self.name))\n            elif self.trapped_NxiTrap < 1:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'NxiTrap' must be > 0.\".format(self.name))\n            elif self.trapped_blWidth <= 0:\n                raise DREAMException(\"XiGrid {}: The trapped/passing grid parameter 'boundaryLayerWidth' must be > 0.\".format(self.name))",
  "class NumericalMagneticField:\n    \n\n    def __init__(self, a, R0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.a = a\n        self.R0 = R0\n\n    \n    def visualize(self, ax=None, show=None):\n        \"\"\"\n        Visualize this numerical magnetic field.\n        \"\"\"\n        raise Exception(\"This numerical magnetic field does not implement 'visualize()'.\")",
  "def __init__(self, a, R0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.a = a\n        self.R0 = R0",
  "def visualize(self, ax=None, show=None):\n        \"\"\"\n        Visualize this numerical magnetic field.\n        \"\"\"\n        raise Exception(\"This numerical magnetic field does not implement 'visualize()'.\")",
  "class Atomics:\n    def __init__(self,\n            adas_interpolation = ADAS_INTERP_BICUBIC):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.adas_interpolation = adas_interpolation\n    \n    def fromdict(self, data):\n        \"\"\"\n        Load settings from dictionary.\n        \"\"\"\n        self.adas_interpolation = data['adas_interpolation']\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n        data = { 'adas_interpolation' : self.adas_interpolation }\n        \n        return data\n        \n    \n    def verifySettings(self):\n        \"\"\"\n        TODO\n        \"\"\"\n        pass",
  "def __init__(self,\n            adas_interpolation = ADAS_INTERP_BICUBIC):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.adas_interpolation = adas_interpolation",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from dictionary.\n        \"\"\"\n        self.adas_interpolation = data['adas_interpolation']",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n        data = { 'adas_interpolation' : self.adas_interpolation }\n        \n        return data",
  "def verifySettings(self):\n        \"\"\"\n        TODO\n        \"\"\"\n        pass",
  "class OtherQuantities:\n    \n    \n    # Here, we keep a list of the possible settings found in DREAM.\n    # This allows to check the input the user gives, and emit warnings\n    # if the user specifies an unrecognized quantity.\n    QUANTITIES = [\n        'all',\n        'fluid',\n        'fluid/conductivity',\n        'fluid/Eceff',\n        'fluid/GammaAva',\n        'fluid/gammaCompton', 'fluid/gammaDreicer', 'fluid/gammaTritium', 'fluid/gammaHottail',\n        'fluid/Lambda_hypres',\n        'fluid/lnLambdaC', 'fluid/lnLambdaT',\n        'fluid/pCrit', 'fluid/pCritHottail',\n        'fluid/qR0',\n        'fluid/radiation',\n        'fluid/runawayRate',\n        'fluid/Tcold_ohmic',\n        'fluid/Tcold_fhot_coll',\n        'fluid/Tcold_fre_coll',\n        'fluid/Tcold_transport',\n        'fluid/Tcold_radiation',\n#        'fluid/Tcold_radiationFromNuS',\n        'fluid/Tcold_ion_coll',\n        'fluid/W_hot',\n        'fluid/W_re',\n        'energy',\n        'hottail/Ar', 'hottail/Ap1', 'hottail/Ap2',\n        'hottail/Drr', 'hottail/Dpp', 'hottail/Dpx', 'hottail/Dxp', 'hottail/Dxx',\n        'hottail/timevaryingb_Ap2',\n        'hottail/lnLambda_ee_f1', 'hottail/lnLambda_ee_f2',\n        'hottail/lnLambda_ei_f1', 'hottail/lnLambda_ei_f2',\n        'hottail/nu_D_f1', 'hottail/nu_D_f2',\n        'hottail/nu_s_f1', 'hottail/nu_s_f2',\n        'hottail/nu_par_f1', 'hottail/nu_par_f2',\n        'hottail/S_ava', 'hottail/synchrotron_loss',\n        'lnLambda',\n        'nu_s',\n        'nu_D',\n        'runaway/Ar', 'runaway/Ap1', 'runaway/Ap2',\n        'runaway/Drr', 'runaway/Dpp', 'runaway/Dpx', 'runaway/Dxp', 'runaway/Dxx',\n        'runaway/timevaryingb_Ap2',\n        'runaway/lnLambda_ee_f1', 'runaway/lnLambda_ee_f2',\n        'runaway/lnLambda_ei_f1', 'runaway/lnLambda_ei_f2',\n        'runaway/nu_D_f1', 'runaway/nu_D_f2',\n        'runaway/nu_s_f1', 'runaway/nu_s_f2',\n        'runaway/nu_par_f1', 'runaway/nu_par_f2',\n        'runaway/S_ava', 'runaway/synchrotron_loss',\n        'scalar',\n        'scalar/E_mag',\n        'scalar/L_i',\n        'scalar/L_i_flux',\n        'scalar/l_i',\n        'scalar/radialloss_n_re',\n        'scalar/energyloss_T_cold',\n        'scalar/radialloss_f_re',\n        'scalar/radialloss_f_hot',\n        'scalar/energyloss_f_re',\n        'scalar/energyloss_f_hot', \n        'ripple',\n        'transport'\n    ]\n\n    def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self._include = list()\n\n    \n    def include(self, *args):\n        \"\"\"\n        Include one or more \"other\" quantities in the output.\n        \"\"\"\n        for a in args:\n            if type(a) == list:\n                self.include(*a)\n            elif type(a) == str:\n                if a not in self.QUANTITIES:\n                    print(\"WARNING: Unrecognized other quantity '{}'. Is it perhaps misspelled?\".format(a))\n\n                self._include.append(a)\n            else:\n                raise DREAMException(\"other: Unrecognized type of argument: '{}'.\".format(type(a)))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load these settings from the given dictionary.\n        \"\"\"\n        inc = []\n        if 'include' in data:\n            inc = data['include'].split(';')\n\n        if len(inc) > 0 and inc[-1] == '':\n            inc = inc[:-1]\n\n        self.include(inc)\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a dict representing the settings in this object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        if len(self._include) == 0:\n            return {}\n        else:\n            return {'include': ';'.join(self._include)}\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        pass",
  "def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self._include = list()",
  "def include(self, *args):\n        \"\"\"\n        Include one or more \"other\" quantities in the output.\n        \"\"\"\n        for a in args:\n            if type(a) == list:\n                self.include(*a)\n            elif type(a) == str:\n                if a not in self.QUANTITIES:\n                    print(\"WARNING: Unrecognized other quantity '{}'. Is it perhaps misspelled?\".format(a))\n\n                self._include.append(a)\n            else:\n                raise DREAMException(\"other: Unrecognized type of argument: '{}'.\".format(type(a)))",
  "def fromdict(self, data):\n        \"\"\"\n        Load these settings from the given dictionary.\n        \"\"\"\n        inc = []\n        if 'include' in data:\n            inc = data['include'].split(';')\n\n        if len(inc) > 0 and inc[-1] == '':\n            inc = inc[:-1]\n\n        self.include(inc)",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a dict representing the settings in this object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        if len(self._include) == 0:\n            return {}\n        else:\n            return {'include': ';'.join(self._include)}",
  "def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        pass",
  "class Output:\n    \n    \n    def __init__(self, filename='output.h5'):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.filename = filename\n        self.savesettings = True\n        self.timingstdout = False\n        self.timingfile = True\n\n\n    ############################\n    # SETTERS\n    ############################\n    def setFilename(self, filename):\n        \"\"\"\n        Set the name of the output file.\n\n        :param str filename: Name of output file to store simulation data to.\n        \"\"\"\n        self.filename = filename\n\n\n    def setSaveSettings(self, save=True):\n        \"\"\"\n        Specify whether or not to save a copy of the input settings to the\n        output file (enabled by default).\n\n        :param bool save: If ``True``, copy settings to the output file.\n        \"\"\"\n        self.savesettings = save\n\n\n    def setTiming(self, stdout=None, file=None):\n        \"\"\"\n        Specifies whether to print timing information and/or include\n        it in the output file.\n\n        :param bool stdout: If ``True``, prints details about execution time to ``stdout`` at the end of the simulation.\n        :param bool file:   If ``True``, stores details about execution time in the output file after the simulation.\n        \"\"\"\n        if stdout is not None:\n            self.timingstdout = stdout\n        if file is not None:\n            self.timingfile = file\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n\n        :param dict data: Dictionary to load settings from.\n        \"\"\"\n        self.filename = data['filename']\n        self.timingstdout = bool(data['timingstdout'])\n        self.timingfile = bool(data['timingfile'])\n\n        if 'savesettings' in data:\n            self.savesettings = bool(data['savesettings'])\n\n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Output object.\n\n        :param bool verify: If ``True``, verifies the settings of this object before generating the dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'filename': self.filename,\n            'savesettings': self.savesettings,\n            'timingfile': self.timingfile,\n            'timingstdout': self.timingstdout\n        }\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the Output settings are consistent.\n        \"\"\"\n        if type(self.filename) != str:\n            raise DREAMException(\"The output file name must be string.\")\n        elif type(self.savesettings) != bool:\n            raise DREAMException(\"The option 'savesettings' must be a bool.\")\n        elif type(self.timingfile) != bool:\n            raise DREAMException(\"The option 'timingfile' must be a bool.\")\n        elif type(self.timingstdout) != bool:\n            raise DREAMException(\"The option 'timingstdout' must be a bool.\")",
  "def __init__(self, filename='output.h5'):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.filename = filename\n        self.savesettings = True\n        self.timingstdout = False\n        self.timingfile = True",
  "def setFilename(self, filename):\n        \"\"\"\n        Set the name of the output file.\n\n        :param str filename: Name of output file to store simulation data to.\n        \"\"\"\n        self.filename = filename",
  "def setSaveSettings(self, save=True):\n        \"\"\"\n        Specify whether or not to save a copy of the input settings to the\n        output file (enabled by default).\n\n        :param bool save: If ``True``, copy settings to the output file.\n        \"\"\"\n        self.savesettings = save",
  "def setTiming(self, stdout=None, file=None):\n        \"\"\"\n        Specifies whether to print timing information and/or include\n        it in the output file.\n\n        :param bool stdout: If ``True``, prints details about execution time to ``stdout`` at the end of the simulation.\n        :param bool file:   If ``True``, stores details about execution time in the output file after the simulation.\n        \"\"\"\n        if stdout is not None:\n            self.timingstdout = stdout\n        if file is not None:\n            self.timingfile = file",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n\n        :param dict data: Dictionary to load settings from.\n        \"\"\"\n        self.filename = data['filename']\n        self.timingstdout = bool(data['timingstdout'])\n        self.timingfile = bool(data['timingfile'])\n\n        if 'savesettings' in data:\n            self.savesettings = bool(data['savesettings'])\n\n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Output object.\n\n        :param bool verify: If ``True``, verifies the settings of this object before generating the dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'filename': self.filename,\n            'savesettings': self.savesettings,\n            'timingfile': self.timingfile,\n            'timingstdout': self.timingstdout\n        }\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the Output settings are consistent.\n        \"\"\"\n        if type(self.filename) != str:\n            raise DREAMException(\"The output file name must be string.\")\n        elif type(self.savesettings) != bool:\n            raise DREAMException(\"The option 'savesettings' must be a bool.\")\n        elif type(self.timingfile) != bool:\n            raise DREAMException(\"The option 'timingfile' must be a bool.\")\n        elif type(self.timingstdout) != bool:\n            raise DREAMException(\"The option 'timingstdout' must be a bool.\")",
  "class Solver:\n    \n\n    def __init__(self, ttype=LINEAR_IMPLICIT, linsolv=LINEAR_SOLVER_LU, maxiter=100, verbose=False):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.setType(ttype)\n\n        self.debug_printmatrixinfo = False\n        self.debug_printjacobianinfo = False\n        self.debug_savejacobian = False\n        self.debug_savesolution = False\n        self.debug_savematrix = False\n        self.debug_savenumericaljacobian = False\n        self.debug_saverhs = False\n        self.debug_saveresidual = False\n        self.debug_savesystem = False\n        self.debug_timestep = 0\n        self.debug_iteration = 1\n        self.debug_rescaled = False\n\n        self.backupsolver = None\n        self.tolerance = ToleranceSettings()\n        self.preconditioner = Preconditioner()\n        self.setOption(linsolv=linsolv, maxiter=maxiter, verbose=verbose)\n\n\n    def setDebug(self, printmatrixinfo=False, printjacobianinfo=False, savejacobian=False,\n                 savesolution=False, savematrix=False, savenumericaljacobian=False, saverhs=False,\n                 saveresidual=False, savesystem=False, rescaled=False, timestep=0, iteration=1):\n        \"\"\"\n        Enable output of debug information.\n\n        :param int timestep:   Index of time step to generate debug info for. If ``0``, debug info is generated in every (iteration of every) time step.\n        :param int savesystem: Save full equation system as a DREAMOutput file in the most recent iteration/time step.\n\n        LINEAR SOLVER\n        :param bool printmatrixinfo: If ``True``, calls ``PrintInfo()`` on the linear operator matrix.\n        :param bool savematrix:      If ``True``, saves the linear operator matrix using a PETSc viewer.\n        :param bool saverhs:         If ``True``, saves the right-hand side vector to a ``.mat`` file.\n\n        NON-LINEAR SOLVER\n        :param bool printjacobianinfo:     If ``True``, calls ``PrintInfo()`` on the jacobian matrix.\n        :param bool savejacobian:          If ``True``, saves the jacobian matrix using a PETSc viewer.\n        :param bool savesolution:          If ``True``, saves the solution vector to a ``.mat`` file.\n        :param bool savenumericaljacobian: If ``True``, evaluates the jacobian matrix numerically and saves it using a PETSc viewer.\n        :param bool saveresidual:          If ``True``, saves the residual vector to a ``.mat`` file.\n        :param bool rescaled:              If ``True``, saves the rescaled versions of the jacobian/solution/residual.\n        :param int iteration:              Index of iteration to save debug info for. If ``0``, saves in all iterations. If ``timestep`` is ``0``, this parameter is always ignored.\n        \"\"\"\n        self.debug_printmatrixinfo = printmatrixinfo\n        self.debug_printjacobianinfo = printjacobianinfo\n        self.debug_savejacobian = savejacobian\n        self.debug_savesolution = savesolution\n        self.debug_savematrix = savematrix\n        self.debug_savenumericaljacobian = savenumericaljacobian\n        self.debug_saverhs = saverhs\n        self.debug_saveresidual = saveresidual\n        self.debug_savesystem = savesystem\n        self.debug_rescaled = rescaled\n        self.debug_timestep = timestep\n        self.debug_iteration = iteration\n\n\n    def setBackupSolver(self, backup):\n        \"\"\"\n        Set the backup linear solver to use in case the main linear\n        solver fails. Set to ``None`` to disable (default).\n        \"\"\"\n        self.backupsolver = backup\n\n\n    def setLinearSolver(self, linsolv):\n        \"\"\"\n        Set the linear solver to use.\n        \"\"\"\n        self.linsolv = linsolv\n\n\n    def setMaxIterations(self, maxiter):\n        \"\"\"\n        Set maximum number of allowed nonlinear iterations.\n        \"\"\"\n        self.setOption(maxiter=maxiter)\n\n\n    def setTolerance(self, reltol):\n        \"\"\"\n        Set relative tolerance for nonlinear solve.\n        \"\"\"\n        print(\"WARNING: The 'Solver.setTolerance()' method is deprecated. Please use 'Solver.tolerance.set(reltol=...)' instead.\")\n        self.tolerance.set(reltol=reltol)\n\n\n    def setVerbose(self, verbose):\n        \"\"\"\n        If 'True', generates excessive output during nonlinear solve.\n        \"\"\"\n        self.setOption(verbose=verbose)\n\n\n    def setOption(self, linsolv=None, maxiter=None, verbose=None):\n        \"\"\"\n        Sets a solver option.\n        \"\"\"\n        if linsolv is not None:\n            self.linsolv = linsolv\n        if maxiter is not None:\n            self.maxiter = maxiter\n        if verbose is not None:\n            self.verbose = verbose\n\n        self.verifySettings()\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Specifies which type of solver to use (either ``LINEAR_IMPLICIT``\n        or ``NONLINEAR``).\n        \"\"\"\n        if ttype == LINEAR_IMPLICIT:\n            self.type = ttype\n        elif ttype == NONLINEAR:\n            self.type = ttype\n        else:\n            raise DREAMException(\"Solver: Unrecognized solver type: {}.\".format(ttype))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = int(scal(data['type']))\n        self.linsolv = int(data['linsolv'])\n        \n        if 'maxiter' in data:\n            self.maxiter = int(data['maxiter'])\n\n        if 'verbose' in data:\n            self.verbose = bool(data['verbose'])\n\n        if 'tolerance' in data:\n            self.tolerance.fromdict(data['tolerance'])\n\n        if 'preconditioner' in data:\n            self.preconditioner.fromdict(data['preconditioner'])\n\n        if 'backupsolver' in data:\n            self.backupsolver = int(data['backupsolver'])\n\n        if 'debug' in data:\n            flags = ['printmatrixinfo', 'printjacobianinfo', 'savejacobian', 'savesolution', 'savematrix', 'savenumericaljacobian', 'saverhs', 'saveresidual', 'savesystem', 'rescaled']\n\n            for f in flags:\n                if f in data['debug']:\n                    setattr(self, 'debug_{}'.format(f), bool(data['debug'][f]))\n\n            if 'timestep' in data['debug']:\n                self.debug_timestep = int(data['debug']['timestep'])\n            if 'iteration' in data['debug']:\n                self.debug_iteration = int(data['debug']['iteration'])\n\n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Solver object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type,\n            'linsolv': self.linsolv,\n            'maxiter': self.maxiter,\n            'verbose': self.verbose\n        }\n\n        data['preconditioner'] = self.preconditioner.todict()\n\n        if self.type == LINEAR_IMPLICIT:\n            data['debug'] = {\n                'printmatrixinfo': self.debug_printmatrixinfo,\n                'savematrix': self.debug_savematrix,\n                'saverhs': self.debug_saverhs,\n                'savesystem': self.debug_savesystem,\n                'timestep': self.debug_timestep\n            }\n        elif self.type == NONLINEAR:\n            data['tolerance'] = self.tolerance.todict()\n            data['debug'] = {\n                'printjacobianinfo': self.debug_printjacobianinfo,\n                'savejacobian': self.debug_savejacobian,\n                'savesolution': self.debug_savesolution,\n                'savenumericaljacobian': self.debug_savenumericaljacobian,\n                'saveresidual': self.debug_saveresidual,\n                'savesystem': self.debug_savesystem,\n                'rescaled': self.debug_rescaled,\n                'timestep': self.debug_timestep,\n                'iteration': self.debug_iteration\n            }\n\n            if self.backupsolver is not None:\n                data['backupsolver'] = self.backupsolver\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verifies that the settings of this object are consistent.\n        \"\"\"\n        if self.type == LINEAR_IMPLICIT:\n            self.verifyLinearSolverSettings()\n\n            if type(self.debug_printmatrixinfo) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_printmatrixinfo': {}. Expected boolean.\".format(type(self.debug_printmatrixinfo)))\n            elif type(self.debug_savematrix) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savematrix': {}. Expected boolean.\".format(type(self.debug_savematrix)))\n            elif type(self.debug_saverhs) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saverhs': {}. Expected boolean.\".format(type(self.debug_saverhs)))\n            elif type(self.debug_timestep) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_timestep': {}. Expected integer.\".format(type(self.debug_timestep)))\n\n        elif self.type == NONLINEAR:\n            if type(self.maxiter) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'maxiter': {}. Expected integer.\".format(type(self.maxiter)))\n            elif type(self.verbose) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'verbose': {}. Expected boolean.\".format(type(self.verbose)))\n\n            if type(self.debug_printjacobianinfo) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_printjacobianinfo': {}. Expected boolean.\".format(type(self.debug_printjacobianinfo)))\n            elif type(self.debug_savejacobian) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savejacobian': {}. Expected boolean.\".format(type(self.debug_savejacobian)))\n            elif type(self.debug_savesolution) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savesolution': {}. Expected boolean.\".format(type(self.debug_savesolution)))\n            elif type(self.debug_saverhs) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saverhs': {}. Expected boolean.\".format(type(self.debug_saverhs)))\n            elif type(self.debug_saveresidual) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saveresidual': {}. Expected boolean.\".format(type(self.debug_saveresidual)))\n            elif type(self.debug_rescaled) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_rescaled': {}. Expected boolean.\".format(type(self.debug_rescaled)))\n            elif type(self.debug_timestep) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_timestep': {}. Expected integer.\".format(type(self.debug_timestep)))\n            elif type(self.debug_iteration) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_iteration': {}. Expected boolean.\".format(type(self.debug_iteration)))\n\n            self.tolerance.verifySettings()\n            self.verifyLinearSolverSettings()\n        else:\n            raise DREAMException(\"Solver: Unrecognized solver type: {}.\".format(self.type))\n\n        self.preconditioner.verifySettings()\n\n\n    def verifyLinearSolverSettings(self):\n        \"\"\"\n        Verifies the settings for the linear solver (which is used\n        by both the 'LINEAR_IMPLICIT' and 'NONLINEAR' solvers).\n        \"\"\"\n        solv = [LINEAR_SOLVER_LU, LINEAR_SOLVER_MUMPS, LINEAR_SOLVER_MKL, LINEAR_SOLVER_SUPERLU, LINEAR_SOLVER_GMRES]\n        if self.linsolv not in solv:\n            raise DREAMException(\"Solver: Unrecognized linear solver type: {}.\".format(self.linsolv))\n        elif self.backupsolver is not None and (self.backupsolver not in solv and self.backupsolver != BACKUP_SOLVER_NONE):\n            raise DREAMException(\"Solver: Unrecognized backup linear solver type: {}.\".format(self.backupsolver))",
  "def __init__(self, ttype=LINEAR_IMPLICIT, linsolv=LINEAR_SOLVER_LU, maxiter=100, verbose=False):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.setType(ttype)\n\n        self.debug_printmatrixinfo = False\n        self.debug_printjacobianinfo = False\n        self.debug_savejacobian = False\n        self.debug_savesolution = False\n        self.debug_savematrix = False\n        self.debug_savenumericaljacobian = False\n        self.debug_saverhs = False\n        self.debug_saveresidual = False\n        self.debug_savesystem = False\n        self.debug_timestep = 0\n        self.debug_iteration = 1\n        self.debug_rescaled = False\n\n        self.backupsolver = None\n        self.tolerance = ToleranceSettings()\n        self.preconditioner = Preconditioner()\n        self.setOption(linsolv=linsolv, maxiter=maxiter, verbose=verbose)",
  "def setDebug(self, printmatrixinfo=False, printjacobianinfo=False, savejacobian=False,\n                 savesolution=False, savematrix=False, savenumericaljacobian=False, saverhs=False,\n                 saveresidual=False, savesystem=False, rescaled=False, timestep=0, iteration=1):\n        \"\"\"\n        Enable output of debug information.\n\n        :param int timestep:   Index of time step to generate debug info for. If ``0``, debug info is generated in every (iteration of every) time step.\n        :param int savesystem: Save full equation system as a DREAMOutput file in the most recent iteration/time step.\n\n        LINEAR SOLVER\n        :param bool printmatrixinfo: If ``True``, calls ``PrintInfo()`` on the linear operator matrix.\n        :param bool savematrix:      If ``True``, saves the linear operator matrix using a PETSc viewer.\n        :param bool saverhs:         If ``True``, saves the right-hand side vector to a ``.mat`` file.\n\n        NON-LINEAR SOLVER\n        :param bool printjacobianinfo:     If ``True``, calls ``PrintInfo()`` on the jacobian matrix.\n        :param bool savejacobian:          If ``True``, saves the jacobian matrix using a PETSc viewer.\n        :param bool savesolution:          If ``True``, saves the solution vector to a ``.mat`` file.\n        :param bool savenumericaljacobian: If ``True``, evaluates the jacobian matrix numerically and saves it using a PETSc viewer.\n        :param bool saveresidual:          If ``True``, saves the residual vector to a ``.mat`` file.\n        :param bool rescaled:              If ``True``, saves the rescaled versions of the jacobian/solution/residual.\n        :param int iteration:              Index of iteration to save debug info for. If ``0``, saves in all iterations. If ``timestep`` is ``0``, this parameter is always ignored.\n        \"\"\"\n        self.debug_printmatrixinfo = printmatrixinfo\n        self.debug_printjacobianinfo = printjacobianinfo\n        self.debug_savejacobian = savejacobian\n        self.debug_savesolution = savesolution\n        self.debug_savematrix = savematrix\n        self.debug_savenumericaljacobian = savenumericaljacobian\n        self.debug_saverhs = saverhs\n        self.debug_saveresidual = saveresidual\n        self.debug_savesystem = savesystem\n        self.debug_rescaled = rescaled\n        self.debug_timestep = timestep\n        self.debug_iteration = iteration",
  "def setBackupSolver(self, backup):\n        \"\"\"\n        Set the backup linear solver to use in case the main linear\n        solver fails. Set to ``None`` to disable (default).\n        \"\"\"\n        self.backupsolver = backup",
  "def setLinearSolver(self, linsolv):\n        \"\"\"\n        Set the linear solver to use.\n        \"\"\"\n        self.linsolv = linsolv",
  "def setMaxIterations(self, maxiter):\n        \"\"\"\n        Set maximum number of allowed nonlinear iterations.\n        \"\"\"\n        self.setOption(maxiter=maxiter)",
  "def setTolerance(self, reltol):\n        \"\"\"\n        Set relative tolerance for nonlinear solve.\n        \"\"\"\n        print(\"WARNING: The 'Solver.setTolerance()' method is deprecated. Please use 'Solver.tolerance.set(reltol=...)' instead.\")\n        self.tolerance.set(reltol=reltol)",
  "def setVerbose(self, verbose):\n        \"\"\"\n        If 'True', generates excessive output during nonlinear solve.\n        \"\"\"\n        self.setOption(verbose=verbose)",
  "def setOption(self, linsolv=None, maxiter=None, verbose=None):\n        \"\"\"\n        Sets a solver option.\n        \"\"\"\n        if linsolv is not None:\n            self.linsolv = linsolv\n        if maxiter is not None:\n            self.maxiter = maxiter\n        if verbose is not None:\n            self.verbose = verbose\n\n        self.verifySettings()",
  "def setType(self, ttype):\n        \"\"\"\n        Specifies which type of solver to use (either ``LINEAR_IMPLICIT``\n        or ``NONLINEAR``).\n        \"\"\"\n        if ttype == LINEAR_IMPLICIT:\n            self.type = ttype\n        elif ttype == NONLINEAR:\n            self.type = ttype\n        else:\n            raise DREAMException(\"Solver: Unrecognized solver type: {}.\".format(ttype))",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the given dictionary.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        self.type = int(scal(data['type']))\n        self.linsolv = int(data['linsolv'])\n        \n        if 'maxiter' in data:\n            self.maxiter = int(data['maxiter'])\n\n        if 'verbose' in data:\n            self.verbose = bool(data['verbose'])\n\n        if 'tolerance' in data:\n            self.tolerance.fromdict(data['tolerance'])\n\n        if 'preconditioner' in data:\n            self.preconditioner.fromdict(data['preconditioner'])\n\n        if 'backupsolver' in data:\n            self.backupsolver = int(data['backupsolver'])\n\n        if 'debug' in data:\n            flags = ['printmatrixinfo', 'printjacobianinfo', 'savejacobian', 'savesolution', 'savematrix', 'savenumericaljacobian', 'saverhs', 'saveresidual', 'savesystem', 'rescaled']\n\n            for f in flags:\n                if f in data['debug']:\n                    setattr(self, 'debug_{}'.format(f), bool(data['debug'][f]))\n\n            if 'timestep' in data['debug']:\n                self.debug_timestep = int(data['debug']['timestep'])\n            if 'iteration' in data['debug']:\n                self.debug_iteration = int(data['debug']['iteration'])\n\n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Solver object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'type': self.type,\n            'linsolv': self.linsolv,\n            'maxiter': self.maxiter,\n            'verbose': self.verbose\n        }\n\n        data['preconditioner'] = self.preconditioner.todict()\n\n        if self.type == LINEAR_IMPLICIT:\n            data['debug'] = {\n                'printmatrixinfo': self.debug_printmatrixinfo,\n                'savematrix': self.debug_savematrix,\n                'saverhs': self.debug_saverhs,\n                'savesystem': self.debug_savesystem,\n                'timestep': self.debug_timestep\n            }\n        elif self.type == NONLINEAR:\n            data['tolerance'] = self.tolerance.todict()\n            data['debug'] = {\n                'printjacobianinfo': self.debug_printjacobianinfo,\n                'savejacobian': self.debug_savejacobian,\n                'savesolution': self.debug_savesolution,\n                'savenumericaljacobian': self.debug_savenumericaljacobian,\n                'saveresidual': self.debug_saveresidual,\n                'savesystem': self.debug_savesystem,\n                'rescaled': self.debug_rescaled,\n                'timestep': self.debug_timestep,\n                'iteration': self.debug_iteration\n            }\n\n            if self.backupsolver is not None:\n                data['backupsolver'] = self.backupsolver\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verifies that the settings of this object are consistent.\n        \"\"\"\n        if self.type == LINEAR_IMPLICIT:\n            self.verifyLinearSolverSettings()\n\n            if type(self.debug_printmatrixinfo) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_printmatrixinfo': {}. Expected boolean.\".format(type(self.debug_printmatrixinfo)))\n            elif type(self.debug_savematrix) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savematrix': {}. Expected boolean.\".format(type(self.debug_savematrix)))\n            elif type(self.debug_saverhs) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saverhs': {}. Expected boolean.\".format(type(self.debug_saverhs)))\n            elif type(self.debug_timestep) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_timestep': {}. Expected integer.\".format(type(self.debug_timestep)))\n\n        elif self.type == NONLINEAR:\n            if type(self.maxiter) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'maxiter': {}. Expected integer.\".format(type(self.maxiter)))\n            elif type(self.verbose) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'verbose': {}. Expected boolean.\".format(type(self.verbose)))\n\n            if type(self.debug_printjacobianinfo) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_printjacobianinfo': {}. Expected boolean.\".format(type(self.debug_printjacobianinfo)))\n            elif type(self.debug_savejacobian) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savejacobian': {}. Expected boolean.\".format(type(self.debug_savejacobian)))\n            elif type(self.debug_savesolution) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_savesolution': {}. Expected boolean.\".format(type(self.debug_savesolution)))\n            elif type(self.debug_saverhs) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saverhs': {}. Expected boolean.\".format(type(self.debug_saverhs)))\n            elif type(self.debug_saveresidual) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_saveresidual': {}. Expected boolean.\".format(type(self.debug_saveresidual)))\n            elif type(self.debug_rescaled) != bool:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_rescaled': {}. Expected boolean.\".format(type(self.debug_rescaled)))\n            elif type(self.debug_timestep) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_timestep': {}. Expected integer.\".format(type(self.debug_timestep)))\n            elif type(self.debug_iteration) != int:\n                raise DREAMException(\"Solver: Invalid type of parameter 'debug_iteration': {}. Expected boolean.\".format(type(self.debug_iteration)))\n\n            self.tolerance.verifySettings()\n            self.verifyLinearSolverSettings()\n        else:\n            raise DREAMException(\"Solver: Unrecognized solver type: {}.\".format(self.type))\n\n        self.preconditioner.verifySettings()",
  "def verifyLinearSolverSettings(self):\n        \"\"\"\n        Verifies the settings for the linear solver (which is used\n        by both the 'LINEAR_IMPLICIT' and 'NONLINEAR' solvers).\n        \"\"\"\n        solv = [LINEAR_SOLVER_LU, LINEAR_SOLVER_MUMPS, LINEAR_SOLVER_MKL, LINEAR_SOLVER_SUPERLU, LINEAR_SOLVER_GMRES]\n        if self.linsolv not in solv:\n            raise DREAMException(\"Solver: Unrecognized linear solver type: {}.\".format(self.linsolv))\n        elif self.backupsolver is not None and (self.backupsolver not in solv and self.backupsolver != BACKUP_SOLVER_NONE):\n            raise DREAMException(\"Solver: Unrecognized backup linear solver type: {}.\".format(self.backupsolver))",
  "def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v",
  "class CollisionHandler:\n    \n\n    def __init__(self,\n            bremsstrahlung_mode=BREMSSTRAHLUNG_MODE_NEGLECT,\n            collfreq_mode=COLLFREQ_MODE_FULL, collfreq_type=COLLFREQ_TYPE_PARTIALLY_SCREENED,\n            lnlambda=LNLAMBDA_THERMAL, pstar_mode=PSTAR_MODE_COLLISIONLESS, screened_diffusion=SCREENED_DIFFUSION_MODE_MAXWELLIAN):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.bremsstrahlung_mode = bremsstrahlung_mode\n        self.collfreq_mode = collfreq_mode\n        self.collfreq_type = collfreq_type\n        self.lnlambda = lnlambda\n        self.pstar_mode = pstar_mode\n        self.screened_diffusion = screened_diffusion\n\n    \n    def fromdict(self, data):\n        \"\"\"\n        Load settings from dictionary.\n        \"\"\"\n        if 'bremsstrahlung_mode' in data:\n            self.bremsstrahlung_mode = data['bremsstrahlung_mode']\n        if 'collfreq_mode' in data:\n            self.collfreq_mode = data['collfreq_mode']\n        if 'collfreq_type' in data:\n            self.collfreq_type = data['collfreq_type']\n        if 'lnlambda' in data:\n            self.lnlambda = data['lnlambda']\n        if 'pstar_mode' in data:\n            self.pstar_mode = data['pstar_mode']\n        if 'screened_diffusion_mode' in data:\n            self.screened_diffusion = data['screened_diffusion_mode']\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        return {\n            'bremsstrahlung_mode': self.bremsstrahlung_mode,\n            'collfreq_mode': self.collfreq_mode,\n            'collfreq_type': self.collfreq_type,\n            'lnlambda': self.lnlambda,\n            'pstar_mode': self.pstar_mode,\n            'screened_diffusion_mode': self.screened_diffusion\n        }\n\n    \n    def verifySettings(self):\n        \"\"\"\n        TODO\n        \"\"\"\n        pass",
  "def __init__(self,\n            bremsstrahlung_mode=BREMSSTRAHLUNG_MODE_NEGLECT,\n            collfreq_mode=COLLFREQ_MODE_FULL, collfreq_type=COLLFREQ_TYPE_PARTIALLY_SCREENED,\n            lnlambda=LNLAMBDA_THERMAL, pstar_mode=PSTAR_MODE_COLLISIONLESS, screened_diffusion=SCREENED_DIFFUSION_MODE_MAXWELLIAN):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.bremsstrahlung_mode = bremsstrahlung_mode\n        self.collfreq_mode = collfreq_mode\n        self.collfreq_type = collfreq_type\n        self.lnlambda = lnlambda\n        self.pstar_mode = pstar_mode\n        self.screened_diffusion = screened_diffusion",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from dictionary.\n        \"\"\"\n        if 'bremsstrahlung_mode' in data:\n            self.bremsstrahlung_mode = data['bremsstrahlung_mode']\n        if 'collfreq_mode' in data:\n            self.collfreq_mode = data['collfreq_mode']\n        if 'collfreq_type' in data:\n            self.collfreq_type = data['collfreq_type']\n        if 'lnlambda' in data:\n            self.lnlambda = data['lnlambda']\n        if 'pstar_mode' in data:\n            self.pstar_mode = data['pstar_mode']\n        if 'screened_diffusion_mode' in data:\n            self.screened_diffusion = data['screened_diffusion_mode']",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        return {\n            'bremsstrahlung_mode': self.bremsstrahlung_mode,\n            'collfreq_mode': self.collfreq_mode,\n            'collfreq_type': self.collfreq_type,\n            'lnlambda': self.lnlambda,\n            'pstar_mode': self.pstar_mode,\n            'screened_diffusion_mode': self.screened_diffusion\n        }",
  "def verifySettings(self):\n        \"\"\"\n        TODO\n        \"\"\"\n        pass",
  "class AdvectionInterpolation:\n    \n\n    def __init__(self, kinetic=True,\n        ad_int_r=AD_INTERP_CENTRED, ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED, ad_jac_r=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.kinetic = kinetic\n\n        self.adv_interp_r  = ad_int_r\n        self.adv_interp_p1 = ad_int_p1\n        self.adv_interp_p2 = ad_int_p2\n\n        self.adv_jac_r  = ad_jac_r\n        self.adv_jac_p1 = ad_jac_p1\n        self.adv_jac_p2 = ad_jac_p2\n\n        self.fluxlimiterdamping = fluxlimiterdamping\n\n\n    def setMethod(self, ad_int=None, ad_int_r=AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED, ad_int_p2=AD_INTERP_CENTRED, ad_jac=None, \n        ad_jac_r=AD_INTERP_JACOBIAN_LINEAR, ad_jac_p1=AD_INTERP_JACOBIAN_LINEAR,\n        ad_jac_p2=AD_INTERP_JACOBIAN_LINEAR, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the equation. To set all three components simultaneously, provide ad_int\n        and/or ad_jac. Otherwise the three components can use separate interpolation\n        methods.\n        \n        :param int ad_int:               Interpolation method to use for all coordinates.\n        :param int ad_int_r:             Interpolation method to use for the radial coordinate.\n        :param int ad_int_p1:            Interpolation method to use for the first momentum coordinate.\n        :param int ad_int_p2:            Interpolation method to use for the second momentum coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for all coordinates.\n        :param int ad_jac_r:             Jacobian interpolation mode to use for the radial coordinate.\n        :param int ad_jac_p1:            Jacobian interpolation mode to use for the first momentum coordinate.\n        :param int ad_jac_p2:            Jacobian interpolation mode to use for the second momentum coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.fluxlimiterdamping = fluxlimiterdamping\n        if ad_int is not None:\n            self.adv_interp_r  = ad_int\n            self.adv_interp_p1 = ad_int\n            self.adv_interp_p2 = ad_int\n        else:\n            self.adv_interp_r  = ad_int_r\n            self.adv_interp_p1 = ad_int_p1\n            self.adv_interp_p2 = ad_int_p2\n\n        if ad_jac is not None:\n            self.adv_jac_r  = ad_jac\n            self.adv_jac_p1 = ad_jac\n            self.adv_jac_p2 = ad_jac\n        else:\n            self.adv_jac_r  = ad_jac_r\n            self.adv_jac_p1 = ad_jac_p1\n            self.adv_jac_p2 = ad_jac_p2\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the specified dictionary.\n        \"\"\"\n        self.adv_interp_r = data['r']\n        self.adv_jac_r = data['r_jac']\n\n        if self.kinetic:\n            self.adv_interp_p1 = int(data['p1'])\n            self.adv_interp_p2 = int(data['p2'])\n            self.adv_jac_p1 = int(data['p1_jac'])\n            self.adv_jac_p2 = int(data['p2_jac'])\n\n        self.fluxlimiterdamping = float(data['fluxlimiterdamping'])\n\n\n    def todict(self):\n        \"\"\"\n        Convert these settings to a dictionary.\n        \"\"\"\n        data = {}\n\n        data['r']  = self.adv_interp_r\n        data['r_jac'] = self.adv_jac_r\n\n        if self.kinetic:\n            data['p1'] = self.adv_interp_p1\n            data['p2'] = self.adv_interp_p2\n            data['p1_jac'] = self.adv_jac_p1\n            data['p2_jac'] = self.adv_jac_p2\n\n        data['fluxlimiterdamping'] = self.fluxlimiterdamping\n\n        return data\n\n\n    def verifySettings(self):\n        ad_int_opts = [\n            AD_INTERP_CENTRED, AD_INTERP_DOWNWIND, AD_INTERP_UPWIND, AD_INTERP_UPWIND_2ND_ORDER, \n            AD_INTERP_QUICK, AD_INTERP_SMART, AD_INTERP_MUSCL, AD_INTERP_OSPRE, AD_INTERP_TCDF\n        ]\n        if self.adv_interp_r not in ad_int_opts:\n            raise EquationException(\"{}: Invalid radial interpolation coefficient set: {}.\".format(self.name, self.adv_interp_r))\n\n        if self.kinetic:\n            if self.adv_interp_p1 not in ad_int_opts:\n                raise EquationException(\"{}: Invalid p1 interpolation coefficient set: {}.\".format(self.name, self.adv_interp_p1))\n            if self.adv_interp_p2 not in ad_int_opts:\n                raise EquationException(\"{}: Invalid p2 interpolation coefficient set: {}.\".format(self.name, self.adv_interp_p2))\n\n        if (self.fluxlimiterdamping<0.0) or (self.fluxlimiterdamping>1.0):\n            raise EquationException(\"{}: Invalid flux limiter damping coefficient: {}. Choose between 0 and 1.\".format(self.name, self.fluxlimiterdamping))",
  "def __init__(self, kinetic=True,\n        ad_int_r=AD_INTERP_CENTRED, ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED, ad_jac_r=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.kinetic = kinetic\n\n        self.adv_interp_r  = ad_int_r\n        self.adv_interp_p1 = ad_int_p1\n        self.adv_interp_p2 = ad_int_p2\n\n        self.adv_jac_r  = ad_jac_r\n        self.adv_jac_p1 = ad_jac_p1\n        self.adv_jac_p2 = ad_jac_p2\n\n        self.fluxlimiterdamping = fluxlimiterdamping",
  "def setMethod(self, ad_int=None, ad_int_r=AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED, ad_int_p2=AD_INTERP_CENTRED, ad_jac=None, \n        ad_jac_r=AD_INTERP_JACOBIAN_LINEAR, ad_jac_p1=AD_INTERP_JACOBIAN_LINEAR,\n        ad_jac_p2=AD_INTERP_JACOBIAN_LINEAR, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the equation. To set all three components simultaneously, provide ad_int\n        and/or ad_jac. Otherwise the three components can use separate interpolation\n        methods.\n        \n        :param int ad_int:               Interpolation method to use for all coordinates.\n        :param int ad_int_r:             Interpolation method to use for the radial coordinate.\n        :param int ad_int_p1:            Interpolation method to use for the first momentum coordinate.\n        :param int ad_int_p2:            Interpolation method to use for the second momentum coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for all coordinates.\n        :param int ad_jac_r:             Jacobian interpolation mode to use for the radial coordinate.\n        :param int ad_jac_p1:            Jacobian interpolation mode to use for the first momentum coordinate.\n        :param int ad_jac_p2:            Jacobian interpolation mode to use for the second momentum coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.fluxlimiterdamping = fluxlimiterdamping\n        if ad_int is not None:\n            self.adv_interp_r  = ad_int\n            self.adv_interp_p1 = ad_int\n            self.adv_interp_p2 = ad_int\n        else:\n            self.adv_interp_r  = ad_int_r\n            self.adv_interp_p1 = ad_int_p1\n            self.adv_interp_p2 = ad_int_p2\n\n        if ad_jac is not None:\n            self.adv_jac_r  = ad_jac\n            self.adv_jac_p1 = ad_jac\n            self.adv_jac_p2 = ad_jac\n        else:\n            self.adv_jac_r  = ad_jac_r\n            self.adv_jac_p1 = ad_jac_p1\n            self.adv_jac_p2 = ad_jac_p2",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the specified dictionary.\n        \"\"\"\n        self.adv_interp_r = data['r']\n        self.adv_jac_r = data['r_jac']\n\n        if self.kinetic:\n            self.adv_interp_p1 = int(data['p1'])\n            self.adv_interp_p2 = int(data['p2'])\n            self.adv_jac_p1 = int(data['p1_jac'])\n            self.adv_jac_p2 = int(data['p2_jac'])\n\n        self.fluxlimiterdamping = float(data['fluxlimiterdamping'])",
  "def todict(self):\n        \"\"\"\n        Convert these settings to a dictionary.\n        \"\"\"\n        data = {}\n\n        data['r']  = self.adv_interp_r\n        data['r_jac'] = self.adv_jac_r\n\n        if self.kinetic:\n            data['p1'] = self.adv_interp_p1\n            data['p2'] = self.adv_interp_p2\n            data['p1_jac'] = self.adv_jac_p1\n            data['p2_jac'] = self.adv_jac_p2\n\n        data['fluxlimiterdamping'] = self.fluxlimiterdamping\n\n        return data",
  "def verifySettings(self):\n        ad_int_opts = [\n            AD_INTERP_CENTRED, AD_INTERP_DOWNWIND, AD_INTERP_UPWIND, AD_INTERP_UPWIND_2ND_ORDER, \n            AD_INTERP_QUICK, AD_INTERP_SMART, AD_INTERP_MUSCL, AD_INTERP_OSPRE, AD_INTERP_TCDF\n        ]\n        if self.adv_interp_r not in ad_int_opts:\n            raise EquationException(\"{}: Invalid radial interpolation coefficient set: {}.\".format(self.name, self.adv_interp_r))\n\n        if self.kinetic:\n            if self.adv_interp_p1 not in ad_int_opts:\n                raise EquationException(\"{}: Invalid p1 interpolation coefficient set: {}.\".format(self.name, self.adv_interp_p1))\n            if self.adv_interp_p2 not in ad_int_opts:\n                raise EquationException(\"{}: Invalid p2 interpolation coefficient set: {}.\".format(self.name, self.adv_interp_p2))\n\n        if (self.fluxlimiterdamping<0.0) or (self.fluxlimiterdamping>1.0):\n            raise EquationException(\"{}: Invalid flux limiter damping coefficient: {}. Choose between 0 and 1.\".format(self.name, self.fluxlimiterdamping))",
  "class MomentumGrid:\n\n    \n    def __init__(self, name, enabled=True, ttype=TYPE_PXI, np=0, nxi=0, pmax=None):\n        \"\"\"\n        Constructor.\n\n        name:    Name, indicating what type of grid this is (hot-tail or runaway).\n        enabled: If 'True', enables the hot-tail grid in the simulation.\n        ttype:   Type of momentum grid (p/xi or ppar/pperp).\n        np:      Number of momentum grid points.\n        nxi:     Number of pitch grid points.\n        pmax:    Maximum momentum on grid.\n        \n        \"\"\"\n        self.name = name\n\n        self.set(enabled=enabled, ttype=ttype, np=np, nxi=nxi, pmax=pmax)\n\n\n    def __contains__(self, item):\n        return (item in self.todict(False))\n\n\n    def __getitem__(self, index):\n        return self.todict(False)[index]\n\n\n    def set(self, enabled=True, ttype=1, np=100, nxi=1, pmax=None):\n        \"\"\"\n        Set all settings for this hot-tail grid.\n        \"\"\"\n        self.enabled = enabled\n\n        self.type = ttype\n        if self.type == TYPE_PXI:\n            self.pgrid = PGrid(self.name, parent=self, np=np, pmax=pmax)\n            self.xigrid = XiGrid(self.name, parent=self, nxi=nxi)\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"No support implemented yet for 'ppar/pperp' grids.\")\n        else:\n            raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(ttype))\n\n    ##################\n    # SETTERS\n    ##################\n    def setEnabled(self, enabled=True):\n        self.enabled = (enabled == True)\n\n\n    def setNp(self, np):\n        if np <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'np': {}. Must be > 0.\".format(self.name, np))\n        elif np == 1:\n            print(\"WARNING: {}: np = 1. Consider disabling the hot-tail grid altogether.\".format(self.name))\n\n        self.pgrid.setNp(np)\n\n\n    def setNxi(self, nxi):\n        if nxi <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'nxi': {}. Must be > 0.\".format(self.name, nxi))\n\n        self.xigrid.setNxi(nxi)\n\n\n    def setPmax(self, pmax):\n        if pmax <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, pmax))\n\n        self.pgrid.setPmax(pmax)\n\n\n    def setPmin(self, pmin):\n        \"\"\"\n        Sets the minimum momentum on the kinetic grid. NOTE: This parameter\n        is only observed IF the runaway grid is the only kinetic grid enabled.\n        \"\"\"\n        self.pgrid.setPmin(pmin)\n\n\n    def setBiuniformGrid(self, psep=None, npsep=None, npsep_frac=None, xisep=None, nxisep=None, nxisep_frac=None, thetasep=None, nthetasep=None, nthetasep_frac=None):\n        \"\"\"\n        Set a two-region momentum grid. The lower part (0 < p < psep) has 'npsep' \n        number of grid points, while the upper region has 'np-npsep' number of\n        grid points. This makes it possible to, for example, have denser\n        grid near the bulk and a coarser grid in the runaway tail. \n        Similarly, the lower part (-1 < xi < xisep) of the pitch grid has 'nxisep'\n        number of grid points, etc.\n\n        :param float psep:        \t Momentum value separating the two sections.\n        :param int npsep:         \t Number of grid points on the lower grid section.\n        :param float npsep_frac:  \t If ``npsep`` is ``None``, gives the fraction of grid \n                                  \t points to put in the lower region. Otherwise, not used.\n        :param float xisep:       \t Pitch value separating the two sections.\n        :param int nxisep:        \t Number of grid points on the lower grid section.\n        :param float nxisep_frac: \t If ``nxisep`` is ``None``, gives the fraction of grid\n                                  \t points to put in the lower region. Otherwise not used.\n        :param float thetasep:    \t Theta value separating the two sections.\n        :param int nthetasep:        Number of grid points on the lower grid section.\n        :param float nthetasep_frac: If ``nthetasep`` is ``None``, gives the fraction of grid\n                                  \t points to put in the lower region. Otherwise not used.\n        \"\"\"\n        if psep is not None:\n            self.pgrid.setBiuniform(psep=psep,npsep=npsep,npsep_frac=npsep_frac)\n        if xisep is not None:\n            self.xigrid.setBiuniform(xisep=xisep,nxisep=nxisep,nxisep_frac=nxisep_frac)\n        elif thetasep is not None:\n            self.xigrid.setBiuniform(thetasep=thetasep,nthetasep=nthetasep,nthetasep_frac=nthetasep_frac)\n            \n    def setCustomGrid(self, p_f=None, xi_f=None):\n        \"\"\"\n        Sets p and xi to an arbitrary meshgrid, where the flux grid points \n        of the respective grids are contained in the lists 'p_f' and 'xi_f'.\n        The resolution parameters 'np' and 'nxi' are overwritten by the sizes\n        of the two input grids.\n\n        :param float p_f:       Increasing list of momentum flux grid points, with p_f[0]=0.\n        :param float xi_f:      Increasing list of pitch grid points with xi_f[0] = -1 and xi_f[-1] = 1\n        \"\"\"\n        if p_f is not None:\n            self.pgrid.setCustomGridPoints(p_f=p_f)\n        if xi_f is not None:\n            self.xigrid.setCustomGridPoints(xi_f=xi_f)\n\n    def setTrappedPassingBoundaryLayerGrid(self, xi0Trapped=None, dxiMax=2, NxiPass=1, NxiTrap=1, boundaryLayerWidth=1e-3):\n        \"\"\"\n        Designs a custom pitch grid which places tight grid cells \n        straddling each trapped-passing boundary, so that these\n        singular points are well resolved.\n\n        :param float xi0Trapped:            List of trapped-passing boundary pitches \n                                            (contained in do.grid.xi0TrappedBoundary of an output object).\n                                            NEW: To automatically determine the trapped-passing boundary,\n                                            leave out this parameter (or set it explicitly to ``None``).\n        :param float dxiMax:                Maximum allowed grid spacing dxi: if this spacing is exceeded after\n                                            placing points on the trapped-passing boundary, will fill in the gaps\n                                            by adding one or more grid points (uniformly) in the gaps\n        :param int NxiPass:                 Number of grid cells in pitch to be contained \n                                            between the largest xi0Trapped and xi0=+/-1\n        :param int NxiTrap:                 Number of grid cells in pitch to be contained \n                                            between (+/-) the minimum xi0Trapped and xi0=0\n        :param float boundaryLayerWidth:    Width in pitch of the grid cell containing each\n                                            trapped-passing boundary, typically << 1\n        \"\"\"\n        if xi0Trapped is None:\n            self.xigrid.setTrappedPassingBoundaryLayerGrid(dxiMax=dxiMax, NxiPass=NxiPass, NxiTrap=NxiTrap, boundaryLayerWidth=boundaryLayerWidth)\n        else:\n            # Old method, which requires prior knowledge of 'xi0Trapped'\n            if type(xi0Trapped)==list:\n                xi0Trapped = np.array(xi0Trapped)\n            xi0Trapped = np.sort(xi0Trapped)\n\n            x0 = np.linspace( xi0Trapped.max(), 1, NxiPass+1 )[1:]\n            xi_f = np.array([-x0,x0])\n            if NxiTrap > 1 and xi0Trapped.min() > 0:\n                xTrap = np.linspace( 0, xi0Trapped.min(), NxiTrap+1 )[1:-1]\n                xi_f = np.append( xi_f, [-xTrap, xTrap] )\n            xi_f = np.append(xi_f, 0)\n\n            for i in range(xi0Trapped.size):\n                if xi0Trapped[i]>0:\n                    xiAdd1 = xi0Trapped[i] + 0.5*boundaryLayerWidth\n                    xiAdd2 = xi0Trapped[i] - 0.5*boundaryLayerWidth\n                    xi_f = np.append(xi_f, [-xiAdd1, xiAdd1, -xiAdd2, xiAdd2])\n\n            # Add additional point if the resulting spacing exceeds the desired dxiMax\n            xi_f = np.sort(xi_f)\n            for i in range(xi_f.size-1):\n                dxi = xi_f[i+1] - xi_f[i]\n                N = int(np.floor( dxi/dxiMax ))\n                if N>=1:\n                    xi_f = np.append(xi_f, np.linspace(xi_f[i], xi_f[i+1],N+2)[1:-1])\n\n            self.setCustomGrid(xi_f=np.sort(xi_f))\n\n    def setXiType(self,ttype):\n        \"\"\"\n        Set type of xi grid. \n        \"\"\"\n        self.xigrid.setType(ttype)\n\t\n    def fromdict(self, name, data):\n        \"\"\"\n        Loads a momentum grid from the specified dictionary.\n        \"\"\"\n        self.name    = name\n        self.enabled = data['enabled']\n\n        if self.enabled:\n            self.type    = data['type']\n            if self.type == TYPE_PXI:\n                self.pgrid = PGrid(name, parent=self, data=data)\n                self.xigrid = XiGrid(name, parent=self, data=data)\n            elif self.type == TYPE_PPARPPERP:\n                raise DREAMException(\"No support implemented yet for loading 'ppar/pperp' grids.\")\n            else:\n                raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(self.type))\n        else:\n            # Set default grid\n            self.set(enabled=False, ttype=self.type)\n\n        self.verifySettings()\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this MomentumGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'enabled': self.enabled,\n            'type':    self.type\n        }\n\n        if not self.enabled: return data\n\n        if self.type == TYPE_PXI:\n            data = {**data, **(self.pgrid.todict()), **(self.xigrid.todict())}\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"No support implemented yet for saving 'ppar/pperp' grids.\")\n        else:\n            raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(self.type))\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            if self.enabled:\n                self.pgrid.verifySettings()\n                self.xigrid.verifySettings()\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"{}: No support implemented yet for 'ppar/pperp' grids.\".format(self.name))\n        else:\n            raise DREAMException(\"{}: Unrecognized momentum grid type specified: {}.\".format(self.name, self.type))",
  "def __init__(self, name, enabled=True, ttype=TYPE_PXI, np=0, nxi=0, pmax=None):\n        \"\"\"\n        Constructor.\n\n        name:    Name, indicating what type of grid this is (hot-tail or runaway).\n        enabled: If 'True', enables the hot-tail grid in the simulation.\n        ttype:   Type of momentum grid (p/xi or ppar/pperp).\n        np:      Number of momentum grid points.\n        nxi:     Number of pitch grid points.\n        pmax:    Maximum momentum on grid.\n        \n        \"\"\"\n        self.name = name\n\n        self.set(enabled=enabled, ttype=ttype, np=np, nxi=nxi, pmax=pmax)",
  "def __contains__(self, item):\n        return (item in self.todict(False))",
  "def __getitem__(self, index):\n        return self.todict(False)[index]",
  "def set(self, enabled=True, ttype=1, np=100, nxi=1, pmax=None):\n        \"\"\"\n        Set all settings for this hot-tail grid.\n        \"\"\"\n        self.enabled = enabled\n\n        self.type = ttype\n        if self.type == TYPE_PXI:\n            self.pgrid = PGrid(self.name, parent=self, np=np, pmax=pmax)\n            self.xigrid = XiGrid(self.name, parent=self, nxi=nxi)\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"No support implemented yet for 'ppar/pperp' grids.\")\n        else:\n            raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(ttype))",
  "def setEnabled(self, enabled=True):\n        self.enabled = (enabled == True)",
  "def setNp(self, np):\n        if np <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'np': {}. Must be > 0.\".format(self.name, np))\n        elif np == 1:\n            print(\"WARNING: {}: np = 1. Consider disabling the hot-tail grid altogether.\".format(self.name))\n\n        self.pgrid.setNp(np)",
  "def setNxi(self, nxi):\n        if nxi <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'nxi': {}. Must be > 0.\".format(self.name, nxi))\n\n        self.xigrid.setNxi(nxi)",
  "def setPmax(self, pmax):\n        if pmax <= 0:\n            raise DREAMException(\"{}: Invalid value assigned to 'pmax': {}. Must be > 0.\".format(self.name, pmax))\n\n        self.pgrid.setPmax(pmax)",
  "def setPmin(self, pmin):\n        \"\"\"\n        Sets the minimum momentum on the kinetic grid. NOTE: This parameter\n        is only observed IF the runaway grid is the only kinetic grid enabled.\n        \"\"\"\n        self.pgrid.setPmin(pmin)",
  "def setBiuniformGrid(self, psep=None, npsep=None, npsep_frac=None, xisep=None, nxisep=None, nxisep_frac=None, thetasep=None, nthetasep=None, nthetasep_frac=None):\n        \"\"\"\n        Set a two-region momentum grid. The lower part (0 < p < psep) has 'npsep' \n        number of grid points, while the upper region has 'np-npsep' number of\n        grid points. This makes it possible to, for example, have denser\n        grid near the bulk and a coarser grid in the runaway tail. \n        Similarly, the lower part (-1 < xi < xisep) of the pitch grid has 'nxisep'\n        number of grid points, etc.\n\n        :param float psep:        \t Momentum value separating the two sections.\n        :param int npsep:         \t Number of grid points on the lower grid section.\n        :param float npsep_frac:  \t If ``npsep`` is ``None``, gives the fraction of grid \n                                  \t points to put in the lower region. Otherwise, not used.\n        :param float xisep:       \t Pitch value separating the two sections.\n        :param int nxisep:        \t Number of grid points on the lower grid section.\n        :param float nxisep_frac: \t If ``nxisep`` is ``None``, gives the fraction of grid\n                                  \t points to put in the lower region. Otherwise not used.\n        :param float thetasep:    \t Theta value separating the two sections.\n        :param int nthetasep:        Number of grid points on the lower grid section.\n        :param float nthetasep_frac: If ``nthetasep`` is ``None``, gives the fraction of grid\n                                  \t points to put in the lower region. Otherwise not used.\n        \"\"\"\n        if psep is not None:\n            self.pgrid.setBiuniform(psep=psep,npsep=npsep,npsep_frac=npsep_frac)\n        if xisep is not None:\n            self.xigrid.setBiuniform(xisep=xisep,nxisep=nxisep,nxisep_frac=nxisep_frac)\n        elif thetasep is not None:\n            self.xigrid.setBiuniform(thetasep=thetasep,nthetasep=nthetasep,nthetasep_frac=nthetasep_frac)",
  "def setCustomGrid(self, p_f=None, xi_f=None):\n        \"\"\"\n        Sets p and xi to an arbitrary meshgrid, where the flux grid points \n        of the respective grids are contained in the lists 'p_f' and 'xi_f'.\n        The resolution parameters 'np' and 'nxi' are overwritten by the sizes\n        of the two input grids.\n\n        :param float p_f:       Increasing list of momentum flux grid points, with p_f[0]=0.\n        :param float xi_f:      Increasing list of pitch grid points with xi_f[0] = -1 and xi_f[-1] = 1\n        \"\"\"\n        if p_f is not None:\n            self.pgrid.setCustomGridPoints(p_f=p_f)\n        if xi_f is not None:\n            self.xigrid.setCustomGridPoints(xi_f=xi_f)",
  "def setTrappedPassingBoundaryLayerGrid(self, xi0Trapped=None, dxiMax=2, NxiPass=1, NxiTrap=1, boundaryLayerWidth=1e-3):\n        \"\"\"\n        Designs a custom pitch grid which places tight grid cells \n        straddling each trapped-passing boundary, so that these\n        singular points are well resolved.\n\n        :param float xi0Trapped:            List of trapped-passing boundary pitches \n                                            (contained in do.grid.xi0TrappedBoundary of an output object).\n                                            NEW: To automatically determine the trapped-passing boundary,\n                                            leave out this parameter (or set it explicitly to ``None``).\n        :param float dxiMax:                Maximum allowed grid spacing dxi: if this spacing is exceeded after\n                                            placing points on the trapped-passing boundary, will fill in the gaps\n                                            by adding one or more grid points (uniformly) in the gaps\n        :param int NxiPass:                 Number of grid cells in pitch to be contained \n                                            between the largest xi0Trapped and xi0=+/-1\n        :param int NxiTrap:                 Number of grid cells in pitch to be contained \n                                            between (+/-) the minimum xi0Trapped and xi0=0\n        :param float boundaryLayerWidth:    Width in pitch of the grid cell containing each\n                                            trapped-passing boundary, typically << 1\n        \"\"\"\n        if xi0Trapped is None:\n            self.xigrid.setTrappedPassingBoundaryLayerGrid(dxiMax=dxiMax, NxiPass=NxiPass, NxiTrap=NxiTrap, boundaryLayerWidth=boundaryLayerWidth)\n        else:\n            # Old method, which requires prior knowledge of 'xi0Trapped'\n            if type(xi0Trapped)==list:\n                xi0Trapped = np.array(xi0Trapped)\n            xi0Trapped = np.sort(xi0Trapped)\n\n            x0 = np.linspace( xi0Trapped.max(), 1, NxiPass+1 )[1:]\n            xi_f = np.array([-x0,x0])\n            if NxiTrap > 1 and xi0Trapped.min() > 0:\n                xTrap = np.linspace( 0, xi0Trapped.min(), NxiTrap+1 )[1:-1]\n                xi_f = np.append( xi_f, [-xTrap, xTrap] )\n            xi_f = np.append(xi_f, 0)\n\n            for i in range(xi0Trapped.size):\n                if xi0Trapped[i]>0:\n                    xiAdd1 = xi0Trapped[i] + 0.5*boundaryLayerWidth\n                    xiAdd2 = xi0Trapped[i] - 0.5*boundaryLayerWidth\n                    xi_f = np.append(xi_f, [-xiAdd1, xiAdd1, -xiAdd2, xiAdd2])\n\n            # Add additional point if the resulting spacing exceeds the desired dxiMax\n            xi_f = np.sort(xi_f)\n            for i in range(xi_f.size-1):\n                dxi = xi_f[i+1] - xi_f[i]\n                N = int(np.floor( dxi/dxiMax ))\n                if N>=1:\n                    xi_f = np.append(xi_f, np.linspace(xi_f[i], xi_f[i+1],N+2)[1:-1])\n\n            self.setCustomGrid(xi_f=np.sort(xi_f))",
  "def setXiType(self,ttype):\n        \"\"\"\n        Set type of xi grid. \n        \"\"\"\n        self.xigrid.setType(ttype)",
  "def fromdict(self, name, data):\n        \"\"\"\n        Loads a momentum grid from the specified dictionary.\n        \"\"\"\n        self.name    = name\n        self.enabled = data['enabled']\n\n        if self.enabled:\n            self.type    = data['type']\n            if self.type == TYPE_PXI:\n                self.pgrid = PGrid(name, parent=self, data=data)\n                self.xigrid = XiGrid(name, parent=self, data=data)\n            elif self.type == TYPE_PPARPPERP:\n                raise DREAMException(\"No support implemented yet for loading 'ppar/pperp' grids.\")\n            else:\n                raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(self.type))\n        else:\n            # Set default grid\n            self.set(enabled=False, ttype=self.type)\n\n        self.verifySettings()",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this MomentumGrid object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {\n            'enabled': self.enabled,\n            'type':    self.type\n        }\n\n        if not self.enabled: return data\n\n        if self.type == TYPE_PXI:\n            data = {**data, **(self.pgrid.todict()), **(self.xigrid.todict())}\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"No support implemented yet for saving 'ppar/pperp' grids.\")\n        else:\n            raise DREAMException(\"Unrecognized momentum grid type specified: {}.\".format(self.type))\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that all (mandatory) settings are set and consistent.\n        \"\"\"\n        if self.type == TYPE_PXI:\n            if self.enabled:\n                self.pgrid.verifySettings()\n                self.xigrid.verifySettings()\n        elif self.type == TYPE_PPARPPERP:\n            raise DREAMException(\"{}: No support implemented yet for 'ppar/pperp' grids.\".format(self.name))\n        else:\n            raise DREAMException(\"{}: Unrecognized momentum grid type specified: {}.\".format(self.name, self.type))",
  "class EquationSystem:\n    \n    def __init__(self, settings):\n        \"\"\"\n        Constructor.\n\n        settings: Parent settings object.\n        \"\"\"\n        # Parent settings object\n        self.settings = settings\n\n        self.unknowns = list()\n        self.addUnknown('E_field', ElectricField(settings=settings))\n        self.addUnknown('f_hot', HotElectronDistribution(settings=settings))\n        self.addUnknown('f_re', RunawayElectronDistribution(settings=settings))\n        self.addUnknown('j_ohm', OhmicCurrent(settings=settings))\n        self.addUnknown('n_cold', ColdElectrons(settings=settings))\n        self.addUnknown('n_i', Ions(settings=settings))\n        self.addUnknown('n_re', RunawayElectrons(settings=settings))\n        self.addUnknown('psi_p', PoloidalFlux(settings=settings))\n        self.addUnknown('T_cold', ColdElectronTemperature(settings=settings))\n        self.addUnknown('spi', SPI(settings=settings))\n\n\n    def __getitem__(self, name):\n        \"\"\"\n        Get UnknownQuantity by name.\n        \"\"\"\n        return getattr(self, name)\n\n\n    def addUnknown(self, name, obj):\n        \"\"\"\n        Add an unknown to this object. This adds the unknown to\n        the 'unknowns' list, in addition to making it accessible\n        through usual \"dot\" notation (i.e. you can access it either\n        as \"self.myUnknown\" or \"self.unknowns['myUnknown']\")\n\n        name: Name of unknown object to add.\n        obj:  Unknown object to add.\n        \"\"\"\n        setattr(self, name, obj)\n        self.unknowns.append(name)\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Sets the options of this object from a dictionary.\n        \"\"\"\n        sets = copy.copy(self.unknowns)\n\n        for key in data:\n            # Warn about unrecognized settings\n            if key not in sets:\n                print(\"WARNING: Unrecognized setting '{}'.\".format(key))\n                continue\n\n            # Remove from list of not-found settings\n            sets.remove(key)\n            # Set settings\n            try:\n                self[key].fromdict(data[key])\n            except EquationException as ex:\n                print(\"WARNING: {}\".format(ex))\n\n\n    def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this EquationSystem object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {}\n\n        for u in self.unknowns:\n            data[u] = self[u].todict()\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that all unknowns have been properly configured\n        and that all settings are consistent.\n        \"\"\"\n        for u in self.unknowns:\n            self[u].verifySettings()",
  "def __init__(self, settings):\n        \"\"\"\n        Constructor.\n\n        settings: Parent settings object.\n        \"\"\"\n        # Parent settings object\n        self.settings = settings\n\n        self.unknowns = list()\n        self.addUnknown('E_field', ElectricField(settings=settings))\n        self.addUnknown('f_hot', HotElectronDistribution(settings=settings))\n        self.addUnknown('f_re', RunawayElectronDistribution(settings=settings))\n        self.addUnknown('j_ohm', OhmicCurrent(settings=settings))\n        self.addUnknown('n_cold', ColdElectrons(settings=settings))\n        self.addUnknown('n_i', Ions(settings=settings))\n        self.addUnknown('n_re', RunawayElectrons(settings=settings))\n        self.addUnknown('psi_p', PoloidalFlux(settings=settings))\n        self.addUnknown('T_cold', ColdElectronTemperature(settings=settings))\n        self.addUnknown('spi', SPI(settings=settings))",
  "def __getitem__(self, name):\n        \"\"\"\n        Get UnknownQuantity by name.\n        \"\"\"\n        return getattr(self, name)",
  "def addUnknown(self, name, obj):\n        \"\"\"\n        Add an unknown to this object. This adds the unknown to\n        the 'unknowns' list, in addition to making it accessible\n        through usual \"dot\" notation (i.e. you can access it either\n        as \"self.myUnknown\" or \"self.unknowns['myUnknown']\")\n\n        name: Name of unknown object to add.\n        obj:  Unknown object to add.\n        \"\"\"\n        setattr(self, name, obj)\n        self.unknowns.append(name)",
  "def fromdict(self, data):\n        \"\"\"\n        Sets the options of this object from a dictionary.\n        \"\"\"\n        sets = copy.copy(self.unknowns)\n\n        for key in data:\n            # Warn about unrecognized settings\n            if key not in sets:\n                print(\"WARNING: Unrecognized setting '{}'.\".format(key))\n                continue\n\n            # Remove from list of not-found settings\n            sets.remove(key)\n            # Set settings\n            try:\n                self[key].fromdict(data[key])\n            except EquationException as ex:\n                print(\"WARNING: {}\".format(ex))",
  "def todict(self, verify=True):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this EquationSystem object.\n        \"\"\"\n        if verify:\n            self.verifySettings()\n\n        data = {}\n\n        for u in self.unknowns:\n            data[u] = self[u].todict()\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that all unknowns have been properly configured\n        and that all settings are consistent.\n        \"\"\"\n        for u in self.unknowns:\n            self[u].verifySettings()",
  "class Preconditioner:\n    \n\n    def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.enabled = True\n        self.overrides = []\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load preconditioner settings from a dictionary.\n        \"\"\"\n        if 'enabled' in data:\n            self.enabled = bool(data['enabled'])\n\n        if 'names' in data:\n            if 'equation_scales' not in data:\n                raise DREAMException(\"'names' setting present, but no 'equation_scales' setting found.\")\n            if 'unknown_scales' not in data:\n                raise DREAMException(\"'names' setting present, but no 'unknown_scales' setting found.\")\n\n            names = data['names'].split(';')[:-1]\n            overrides = []\n            for i in range(len(names)):\n                escal = data['equation_scales'][i]\n                uscal = data['unknown_scales'][i]\n\n                l = {'name': names[i], 'equation_scale': float(escal), 'unknown_scale': float(uscal)}\n                overrides.append(l)\n\n            self.overrides = overrides\n\n\n    def getIndex(self, unknown):\n        \"\"\"\n        Returns the index into the 'overrides' list for the\n        given unknown. If the returned value is '-1', no\n        override exists for the quantity and the default\n        scsales are used instead.\n        \"\"\"\n        for i in range(0, len(self.overrides)):\n            if self.overrides[i]['name'] == unknown:\n                return i\n        \n        return -1\n\n\n    def set(self, unknown, scale, equation_scale=None):\n        \"\"\"\n        Set the scales for one or more unknown quantities.\n\n        :param unknown:        A string or list of strings specifying the name(s) of the quantity/ies to set the scales for.\n        :param scale:          Scale to normalize the unknown quantity to.\n        :param equation_scale: Scale to normalize the equation of the unknown to. If 'None', it is taken to be the same as 'scale'.\n        \"\"\"\n        if equation_scale is None:\n            equation_scale = scale\n\n        if type(unknown) == str:\n            t = self.getIndex(unknown)\n            l = {'name': unknown, 'equation_scale': float(equation_scale), 'unknown_scale': float(scale)}\n\n            if t < 0:\n                self.overrides.append(l)\n            else:\n                self.overrides[t] = l\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, scale=scale, equation_scale=equation_scale)\n        else:\n            raise DREAMException(\"Preconditioner.set(): Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))\n\n\n    def setEnabled(self, enabled=True):\n        \"\"\"\n        Enable/disable the physics-based preconditioner.\n\n        :param bool enabled: Indicates whether to enable/disable the preconditioner.\n        \"\"\"\n        self.enabled = enabled\n\n\n    def todict(self):\n        \"\"\"\n        Convert this object to a dict.\n        \"\"\"\n        data = {'enabled': self.enabled}\n\n        if len(self.overrides) > 0:\n            data['names'] = ''\n            data['equation_scales'] = []\n            data['unknown_scales'] = []\n\n            for u in self.overrides:\n                data['names'] += '{};'.format(u['name'])\n                data['equation_scales'].append(u['equation_scale'])\n                data['unknown_scales'].append(u['unknown_scale'])\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        if type(self.enabled) is not bool:\n            raise DREAMException(\"Invalid type of option 'enabled': {}. Expected bool.\".format(type(self.enabled)))\n\n        for i in range(len(self.overrides)):\n            u = self.overrides[i]\n            if ('name' not in u) or ('equation_scales' not in u) or ('unknown_scales' not in u):\n                raise DREAMException(\"Incomplete override at index {}.\".format(i))\n            elif type(u['equation_scale']) is not float:\n                raise DREAMException(\"Invalid type of equation scale for unknown '{}': {}. Expected float.\".format(u['name'], type(u['equation_scale'])))\n            elif type(u['unknown_scale']) is not float:\n                raise DREAMException(\"Invalid type of scale for unknown '{}': {}. Expected float.\".format(u['name'], type(u['unknown_scale'])))\n\n            if u['name'] not in EquationSystem.UNKNOWNS:\n                print(\"WARNING: No unknown quantity with name '{}' is available in DREAM. Preconditioner scale setting will be ignored...\".format(u['name']))",
  "def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.enabled = True\n        self.overrides = []",
  "def fromdict(self, data):\n        \"\"\"\n        Load preconditioner settings from a dictionary.\n        \"\"\"\n        if 'enabled' in data:\n            self.enabled = bool(data['enabled'])\n\n        if 'names' in data:\n            if 'equation_scales' not in data:\n                raise DREAMException(\"'names' setting present, but no 'equation_scales' setting found.\")\n            if 'unknown_scales' not in data:\n                raise DREAMException(\"'names' setting present, but no 'unknown_scales' setting found.\")\n\n            names = data['names'].split(';')[:-1]\n            overrides = []\n            for i in range(len(names)):\n                escal = data['equation_scales'][i]\n                uscal = data['unknown_scales'][i]\n\n                l = {'name': names[i], 'equation_scale': float(escal), 'unknown_scale': float(uscal)}\n                overrides.append(l)\n\n            self.overrides = overrides",
  "def getIndex(self, unknown):\n        \"\"\"\n        Returns the index into the 'overrides' list for the\n        given unknown. If the returned value is '-1', no\n        override exists for the quantity and the default\n        scsales are used instead.\n        \"\"\"\n        for i in range(0, len(self.overrides)):\n            if self.overrides[i]['name'] == unknown:\n                return i\n        \n        return -1",
  "def set(self, unknown, scale, equation_scale=None):\n        \"\"\"\n        Set the scales for one or more unknown quantities.\n\n        :param unknown:        A string or list of strings specifying the name(s) of the quantity/ies to set the scales for.\n        :param scale:          Scale to normalize the unknown quantity to.\n        :param equation_scale: Scale to normalize the equation of the unknown to. If 'None', it is taken to be the same as 'scale'.\n        \"\"\"\n        if equation_scale is None:\n            equation_scale = scale\n\n        if type(unknown) == str:\n            t = self.getIndex(unknown)\n            l = {'name': unknown, 'equation_scale': float(equation_scale), 'unknown_scale': float(scale)}\n\n            if t < 0:\n                self.overrides.append(l)\n            else:\n                self.overrides[t] = l\n        elif type(unknown) == list:\n            for u in unknown:\n                self.set(u, scale=scale, equation_scale=equation_scale)\n        else:\n            raise DREAMException(\"Preconditioner.set(): Unrecognized type of parameter 'unknown': {}.\".format(type(unknown)))",
  "def setEnabled(self, enabled=True):\n        \"\"\"\n        Enable/disable the physics-based preconditioner.\n\n        :param bool enabled: Indicates whether to enable/disable the preconditioner.\n        \"\"\"\n        self.enabled = enabled",
  "def todict(self):\n        \"\"\"\n        Convert this object to a dict.\n        \"\"\"\n        data = {'enabled': self.enabled}\n\n        if len(self.overrides) > 0:\n            data['names'] = ''\n            data['equation_scales'] = []\n            data['unknown_scales'] = []\n\n            for u in self.overrides:\n                data['names'] += '{};'.format(u['name'])\n                data['equation_scales'].append(u['equation_scale'])\n                data['unknown_scales'].append(u['unknown_scale'])\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that these settings are consistent.\n        \"\"\"\n        if type(self.enabled) is not bool:\n            raise DREAMException(\"Invalid type of option 'enabled': {}. Expected bool.\".format(type(self.enabled)))\n\n        for i in range(len(self.overrides)):\n            u = self.overrides[i]\n            if ('name' not in u) or ('equation_scales' not in u) or ('unknown_scales' not in u):\n                raise DREAMException(\"Incomplete override at index {}.\".format(i))\n            elif type(u['equation_scale']) is not float:\n                raise DREAMException(\"Invalid type of equation scale for unknown '{}': {}. Expected float.\".format(u['name'], type(u['equation_scale'])))\n            elif type(u['unknown_scale']) is not float:\n                raise DREAMException(\"Invalid type of scale for unknown '{}': {}. Expected float.\".format(u['name'], type(u['unknown_scale'])))\n\n            if u['name'] not in EquationSystem.UNKNOWNS:\n                print(\"WARNING: No unknown quantity with name '{}' is available in DREAM. Preconditioner scale setting will be ignored...\".format(u['name']))",
  "class TransportSettings:\n    \n\n    def __init__(self, kinetic=False):\n        \"\"\"\n        Constructor.\n\n        :param bool kinetic: If ``True``, the coefficient will be assumed kinetic (4D). Otherwise fluid (2D).\n        \"\"\"\n        self.kinetic = kinetic\n        self.type    = TRANSPORT_NONE\n\n\n        # Prescribed advection\n        self.ar           = None\n        self.ar_t         = None\n        self.ar_r         = None\n        self.ar_p         = None\n        self.ar_xi        = None\n        self.ar_ppar      = None\n        self.ar_pperp     = None\n        self.ar_interp3d  = None\n        \n        # Prescribed diffusion\n        self.drr          = None\n        self.drr_t        = None\n        self.drr_r        = None\n        self.drr_p        = None\n        self.drr_xi       = None\n        self.drr_ppar     = None\n        self.drr_pperp    = None\n        self.drr_interp3d = None\n\n        # Svensson pstar\n        self.pstar          = None\n        self.interp1d_param = SVENSSON_INTERP1D_PARAM_TIME \n        \n        # Svensson advection\n        self.s_ar           = None\n        self.s_ar_r         = None\n        self.s_ar_t         = None\n        self.s_ar_p         = None\n        self.s_ar_xi        = None\n        self.s_ar_ppar      = None\n        self.s_ar_pperp     = None\n        self.s_ar_interp3d  = None\n        self.s_ar_interp1d  = None\n        \n        # Svensson diffusion\n        self.s_drr          = None\n        self.s_drr_r        = None\n        self.s_drr_t        = None\n        self.s_drr_p        = None\n        self.s_drr_xi       = None\n        self.s_drr_ppar     = None\n        self.s_drr_pperp    = None\n        self.s_drr_interp3d = None\n        self.s_drr_interp1d = None\n\n        # Rechester-Rosenbluth (diffusive) transport\n        self.dBB   = None\n        self.dBB_t = None\n        self.dBB_r = None\n\n        self.boundarycondition = BC_CONSERVATIVE\n\n\n    def isKinetic(self): return self.kinetic\n    \n\n    def prescribeAdvection(self, ar, t=None, r=None, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the advection coefficient to use.\n        \"\"\"\n        self._prescribeCoefficient('ar', coeff=ar, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp)\n\n\n    def prescribeDiffusion(self, drr, t=None, r=None, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the diffusion coefficient to use.\n        \"\"\"\n        self._prescribeCoefficient('drr', coeff=drr, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp)\n\n\n    def setSvenssonPstar(self,pstar):\n        \"\"\"\n        Set the lower momentum bound for the runaway, radial transport, region.\n        \"\"\"\n        self.pstar=float(pstar)\n    \n\n    def setSvenssonInterp1dParam(self, interp1d_param=SVENSSON_INTERP1D_PARAM_TIME):\n        \"\"\"\n        Set the lower momentum bound for the runaway, radial transport, region.\n        \"\"\"\n        self.interp1d_param = int(interp1d_param)\n\n\n    def setBoundaryCondition(self, bc=None):\n        \"\"\"\n        Set the type of boundary condition. (Default is BC_CONSERVATIVE)\n        \"\"\"\n        self.boundarycondition = bc\n    \n\n    def setSvenssonAdvection(self, ar, t=None, Ip=None, r=None, p=None, xi=None, ppar=None, pperp=None, interp3d=INTERP3D_LINEAR, interp1d=INTERP1D_LINEAR):\n        r\"\"\"\n        Set the Svensson advection coefficient to use.\n\n        :param ar:       Advection coefficient, :math:`A_r(t,r,\\xi_0,p)` or :math:`A_r(I_p,r,\\xi_0,p)`.\n        :param t:        Time vector for which ``ar`` is defined (if ``Ip`` is not provided).\n        :param Ip:       Plasma current vector for which ``ar`` is defined (if ``t`` is not provided).\n        :param r:        Radial grid vector for which ``ar`` is defined.\n        :param p:        Momentum grid vector for which ``ar`` is defined.\n        :param xi:       Pitch grid vector for which ``ar`` is defined.\n        :param interp3d: Interpolation method to use when interpolating in (r,xi,p) part of coefficient.\n        :param interp1d: Interpolation method to use when interpolating in time/Ip variable.\n        \"\"\"\n        if self.interp1d_param == SVENSSON_INTERP1D_PARAM_TIME:\n            if t is not None:\n                self._prescribeCoefficient('s_ar', coeff=ar, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else: \n                raise TransportException('interp1d_param has been set to \"time\", but no time variable was given.')\n        elif self.interp1d_param == SVENSSON_INTERP1D_PARAM_IP:\n            if Ip is not None:\n                self._prescribeCoefficient('s_ar', coeff=ar, t=Ip, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else:\n                raise TransportException('interp1d_param has been set to \"Ip\", but no plasma-current variable was given.')\n        else:\n            raise TransportException('interp1d_param has not been set or is invalid. It must be set before setting the Svensson transport coefficients.')\n        self.type = TRANSPORT_SVENSSON\n        self.s_ar_interp1d = interp1d\n    \n\n    def setSvenssonDiffusion(self, drr, t=None, Ip=None, r=None, p=None, xi=None, ppar=None, pperp=None,interp3d=INTERP3D_LINEAR, interp1d=INTERP1D_LINEAR):\n        r\"\"\"\n        Set the Svensson diffusion coefficient to use.\n\n        :param drr:      Diffusion coefficient, :math:`D_{rr}(t,r,\\xi_0,p)` or :math:`D_{rr}(I_p,r,\\xi_0,p)`.\n        :param t:        Time vector for which ``drr`` is defined (if ``Ip`` is not provided).\n        :param Ip:       Plasma current vector for which ``drr`` is defined (if ``t`` is not provided).\n        :param r:        Radial grid vector for which ``drr`` is defined.\n        :param p:        Momentum grid vector for which ``drr`` is defined.\n        :param xi:       Pitch grid vector for which ``drr`` is defined.\n        :param interp3d: Interpolation method to use when interpolating in (r,xi,p) part of coefficient.\n        :param interp1d: Interpolation method to use when interpolating in time/Ip variable.\n        \"\"\"\n        if self.interp1d_param == SVENSSON_INTERP1D_PARAM_TIME:\n            if t is not None:\n                self._prescribeCoefficient('s_drr', coeff=drr, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else: \n                raise TransportException('interp1d_param has been set to \"time\", but no time variable was given.')\n        elif self.interp1d_param == SVENSSON_INTERP1D_PARAM_IP:\n            if Ip is not None:\n                self._prescribeCoefficient('s_drr', coeff=drr, t=Ip, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else:\n                raise TransportException('interp1d_param has been set to \"Ip\", but no plasma-current variable was given.')\n        else:\n            raise TransportException('interp1d_param has not been set or is invalid. It must be set before setting the Svensson transport coefficients.')\n        self.type = TRANSPORT_SVENSSON\n        self.s_drr_interp1d = interp1d\n\n\n    def _prescribeCoefficient(self, name, coeff, t=None, r=None, p=None, xi=None, ppar=None, pperp=None,interp3d=INTERP3D_LINEAR, override_kinetic=False):\n        \"\"\"\n        General method for prescribing an advection or diffusion coefficient.\n        \"\"\"\n        self.type = TRANSPORT_PRESCRIBED\n\n        setattr(self, name+'_interp3d', interp3d)\n\n        if np.isscalar(coeff):\n            r = np.array([0])\n            t = np.array([0])\n            p = np.array([0])\n            xi = np.array([0])\n\n            if self.kinetic or override_kinetic:\n                coeff = coeff * np.ones((1,)*4)\n            else:\n                coeff = coeff * np.ones((1,)*2)\n\n        r = np.asarray(r)\n        t = np.asarray(t)\n        \n        if r.ndim != 1: r = np.reshape(r, (r.size,))\n        if t.ndim != 1: t = np.reshape(t, (t.size,))\n\n        if (self.kinetic == False and not override_kinetic) and len(coeff.shape) == 2:\n            setattr(self, name, coeff)\n            setattr(self, name+'_r', r)\n            setattr(self, name+'_t', t)\n        elif (self.kinetic == True or override_kinetic) and len(coeff.shape) == 4:\n            # Verify that the momentum grid is given\n            if p is not None and xi is not None:\n                ppar, pperp = None, None\n            elif ppar is not None and pperp is not None:\n                p, xi = None, None\n            else:\n                raise TransportException(\"No momentum grid provided for the 4D transport coefficient.\")\n\n            setattr(self, name, coeff)\n            setattr(self, name+'_r', r)\n            setattr(self, name+'_t', t)\n\n            if p is not None:\n                setattr(self, name+'_p', p)\n                setattr(self, name+'_xi', xi)\n            else:\n                setattr(self, name+'_ppar', ppar)\n                setattr(self, name+'_pperp', pperp)\n        else:\n            raise TransportException(\"Invalid dimensions of prescribed coefficient: {}. Expected {} dimensions.\".format(coeff.shape, 4 if (self.kinetic or override_kinetic) else 2))\n\n            \n    def setMagneticPerturbation(self, dBB, t=None, r=None):\n        \"\"\"\n        Prescribes the evolution of the magnetic perturbation level (dB/B).\n\n        :param dBB: Magnetic perturbation level.\n        :param t:   Time grid on which the perturbation is defined.\n        :param r:   Radial grid on which the perturbation is defined.\n        \"\"\"\n        self.type = TRANSPORT_RECHESTER_ROSENBLUTH\n\n        if np.isscalar(dBB):\n            dBB = dBB * np.ones((1,1))\n            r = np.array([0])\n            t = np.array([0])\n\n        r = np.asarray(r)\n        t = np.asarray(t)\n\n        if r.ndim != 1: r = np.reshape(r, (r.size,))\n        if t.ndim != 1: t = np.reshape(t, (t.size,))\n\n        self.dBB_r = r\n        self.dBB_t = t\n        self.dBB   = dBB\n\n\n    def setBoundaryCondition(self, bc):\n        \"\"\"\n        Set the boundary condition to use for the transport.\n        \"\"\"\n        self.boundarycondition = bc\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        # Prescribed advection\n        self.ar = None\n        self.ar_r = None\n        self.ar_t = None\n        self.ar_p = None\n        self.ar_xi = None\n        self.ar_ppar = None\n        self.ar_pperp = None\n        self.ar_interp3d =None\n        \n        # Prescribed diffusion\n        self.drr = None\n        self.drr_r = None\n        self.drr_t = None\n        self.drr_p = None\n        self.drr_xi = None\n        self.drr_ppar = None\n        self.drr_pperp = None\n        self.drr_interp3d =None\n        \n        # Svensson pstar\n        self.pstar          = None\n        self.interp1d_param = None\n        \n        # Svensson advection\n        self.s_ar           = None\n        self.s_ar_r         = None\n        self.s_ar_t         = None\n        self.s_ar_p         = None\n        self.s_ar_xi        = None\n        self.s_ar_ppar      = None\n        self.s_ar_pperp     = None\n        self.s_ar_interp3d  = None\n        self.s_ar_interp1d  = None\n        \n\n        # Svensson diffusion\n        self.s_drr          = None\n        self.s_drr_r        = None\n        self.s_drr_t        = None\n        self.s_drr_p        = None\n        self.s_drr_xi       = None\n        self.s_drr_ppar     = None\n        self.s_drr_pperp    = None\n        self.s_drr_interp3d = None\n        self.s_drr_interp1d = None\n\n\n        # Rechester--Rosenbluth\n        self.dBB = None\n        self.dBB_r = None\n        self.dBB_t = None\n\n        if 'type' in data:\n            self.type = data['type']\n\n        if 'boundarycondition' in data:\n            self.boundarycondition = data['boundarycondition']\n\n        if 'ar' in data:\n            self.ar = data['ar']['x']\n            self.ar_r  = data['ar']['r']\n            self.ar_t  = data['ar']['t']\n\n            if 'interp3d' in data['ar']:\n                self.ar_interp3d = data['ar']['interp3d']\n\n            if self.kinetic:\n                if 'p' in data['ar']: self.ar_p = data['ar']['p']\n                if 'xi' in data['ar']: self.ar_xi = data['ar']['xi']\n                if 'ppar' in data['ar']: self.ar_ppar = data['ar']['ppar']\n                if 'pperp' in data['ar']: self.ar_pperp = data['ar']['pperp']\n\n        if 'drr' in data:\n            self.drr = data['drr']['x']\n            self.drr_r  = data['drr']['r']\n            self.drr_t  = data['drr']['t']\n\n            if 'interp3d' in data['drr']:\n                self.drr_interp3d = data['drr']['interp3d']\n\n            if self.kinetic:\n                if 'p' in data['drr']: self.drr_p = data['drr']['p']\n                if 'xi' in data['drr']: self.drr_xi = data['drr']['xi']\n                if 'ppar' in data['drr']: self.drr_ppar = data['drr']['ppar']\n                if 'pperp' in data['drr']: self.drr_pperp = data['drr']['pperp']\n\n        if 'pstar' in data:\n            self.pstar = data['pstar']\n            \n        if 'interp1d_param' in data:\n            self.interp1d_param = data['interp1d_param']\n            \n        if 's_ar' in data:\n            self.s_ar                 = data['s_ar']['x']\n            self.s_ar_r               = data['s_ar']['r']\n            self.s_ar_t               = data['s_ar']['t']\n            self.s_ar_interp3d        = data['s_ar']['interp3d']\n            self.s_ar_interp1d        = data['s_ar']['interp1d']\n            \n            if 'p' in data['s_ar']:     self.s_ar_p     = data['s_ar']['p']\n            if 'xi' in data['s_ar']:    self.s_ar_xi    = data['s_ar']['xi']\n            if 'ppar' in data['s_ar']:  self.s_ar_ppar  = data['s_ar']['ppar']\n            if 'pperp' in data['s_ar']: self.s_ar_pperp = data['s_ar']['pperp']\n\n        if 's_drr' in data:\n            self.s_drr                 = data['s_drr']['x']\n            self.s_drr_r               = data['s_drr']['r']\n            self.s_drr_t               = data['s_drr']['t']\n            self.s_drr_interp3d        = data['s_drr']['interp3d']\n            self.s_drr_interp1d        = data['s_drr']['interp1d']\n\n            if 'p' in data['s_drr']:     self.s_drr_p     = data['s_drr']['p']\n            if 'xi' in data['s_drr']:    self.s_drr_xi    = data['s_drr']['xi']\n            if 'ppar' in data['s_drr']:  self.s_drr_ppar  = data['s_drr']['ppar']\n            if 'pperp' in data['s_drr']: self.s_drr_pperp = data['s_drr']['pperp']\n\n        if 'dBB' in data:\n            self.dBB   = data['dBB']['x']\n            self.dBB_r = data['dBB']['r']\n            self.dBB_t = data['dBB']['t']\n\n\n    def todict(self):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        data = {\n            'type': self.type,\n            'boundarycondition': self.boundarycondition\n        }\n\n        # Advection?\n        if self.type == TRANSPORT_PRESCRIBED and self.ar is not None:\n            data['ar'] = {\n                'x': self.ar,\n                'r': self.ar_r,\n                't': self.ar_t,\n                'interp3d': self.ar_interp3d\n            }\n\n            if self.kinetic:\n                if self.ar_p is not None:\n                    data['ar']['p'] = self.ar_p\n                    data['ar']['xi'] = self.ar_xi\n                else:\n                    data['ar']['ppar'] = self.ar_ppar\n                    data['ar']['pperp'] = self.ar_pperp\n\n        # Diffusion?\n        if self.type == TRANSPORT_PRESCRIBED and self.drr is not None:\n            data['drr'] = {\n                'x': self.drr,\n                'r': self.drr_r,\n                't': self.drr_t,\n                'interp3d': self.drr_interp3d\n            }\n\n            if self.kinetic:\n                if self.drr_p is not None:\n                    data['drr']['p'] = self.drr_p\n                    data['drr']['xi'] = self.drr_xi\n                else:\n                    data['drr']['ppar'] = self.drr_ppar\n                    data['drr']['pperp'] = self.drr_pperp\n\n        \n        # Svensson pstar\n        if self.type == TRANSPORT_SVENSSON and self.pstar is not None:\n            data['pstar'] = self.pstar\n\n        # Svensson 1d interpolatino method\n        if self.type == TRANSPORT_SVENSSON and self.interp1d_param is not None:\n            data['interp1d_param'] =  self.interp1d_param\n        \n        # Svensson Advection?\n        if self.type == TRANSPORT_SVENSSON and self.s_ar is not None:\n            data['s_ar'] = {\n                'x': self.s_ar,\n                'r': self.s_ar_r,\n                't': self.s_ar_t,\n                'interp3d': self.s_ar_interp3d,\n                'interp1d': self.s_ar_interp1d,\n            }\n\n            if self.s_ar_p is not None:\n                data['s_ar']['p'] = self.s_ar_p\n                data['s_ar']['xi'] = self.s_ar_xi\n            else:\n                data['s_ar']['ppar'] = self.s_ar_ppar\n                data['s_ar']['pperp'] = self.s_ar_pperp\n\n        # Svensson Diffusion?\n        if self.type == TRANSPORT_SVENSSON and self.s_drr is not None:\n            data['s_drr'] = {\n                'x': self.s_drr,\n                'r': self.s_drr_r,\n                't': self.s_drr_t,\n                'interp3d': self.s_drr_interp3d,\n                'interp1d': self.s_drr_interp1d,\n            }\n\n            if self.s_drr_p is not None:\n                data['s_drr']['p'] = self.s_drr_p\n                data['s_drr']['xi'] = self.s_drr_xi\n            else:\n                data['s_drr']['ppar'] = self.s_drr_ppar\n                data['s_drr']['pperp'] = self.s_drr_pperp\n\n        \n        if self.type == TRANSPORT_RECHESTER_ROSENBLUTH and self.dBB is not None:\n            data['dBB'] = {\n                'x': self.dBB,\n                'r': self.dBB_r,\n                't': self.dBB_t\n            }\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings are consistent.\n        \"\"\"\n        if self.type == TRANSPORT_NONE:\n            pass\n        elif self.type == TRANSPORT_PRESCRIBED:\n            self.verifySettingsCoefficient('ar')\n            self.verifySettingsCoefficient('drr')\n            self.verifyBoundaryCondition()\n        elif self.type == TRANSPORT_SVENSSON:\n            self.verifySettingsCoefficient('s_ar',override_kinetic=True)\n            self.verifySettingsCoefficient('s_drr',override_kinetic=True)\n            if self.pstar is None or type(self.pstar) != float:\n                raise TransportException(\"pstar not defined or wrong type.\")\n            elif self.pstar<=0:\n                raise TransportException(\"pstar = %0.3f <= 0 not allowed.\" % self.pstar)\n            \n            self.verifyBoundaryCondition() \n        elif self.type == TRANSPORT_RECHESTER_ROSENBLUTH:\n            self.verifySettingsRechesterRosenbluth()\n            self.verifyBoundaryCondition()\n        else:\n            raise TransportException(\"Unrecognized transport type: {}\".format(self.type))\n\n\n    def verifyBoundaryCondition(self):\n        \"\"\"\n        Verify that the boundary condition has been correctly configured.\n        \"\"\"\n        bcs = [BC_CONSERVATIVE, BC_F_0, BC_DF_CONST]\n        if self.boundarycondition not in bcs:\n            raise TransportException(\"Invalid boundary condition specified for transport: {}\".format(self.boundarycondition))\n\n\n    def verifySettingsCoefficient(self, coeff, override_kinetic=False):\n        \"\"\"\n        Verify consistency of the named prescribed transport coefficient.\n        \"\"\"\n        g = lambda v : self.__dict__[coeff+v]\n        c = g('')\n\n        if c is None: return\n\n        if self.kinetic or override_kinetic:\n            if c.ndim != 4:\n                raise TransportException(\"{}: Invalid dimensions of transport coefficient: {}\".format(coeff, c.shape))\n            elif g('_t').ndim != 1 or g('_t').size != c.shape[0]:\n                raise TransportException(\"{}: Invalid dimensions of time vector. Expected {} elements.\".format(coeff, c.shape[0]))\n            elif g('_r').ndim != 1 or g('_r').size != c.shape[1]:\n                raise TransportException(\"{}: Invalid dimensions of radius vector. Expected {} elements.\".format(coeff, c.shape[1]))\n\n            if g('_interp3d') not in [INTERP3D_LINEAR, INTERP3D_NEAREST]:\n                raise TransportException(\"{}: Invalid value assigned to interp3d.\".format(coeff))\n\n            if coeff+'v' in self.__dict__:\n                if g('_interp1d') not in [INTERP1D_LINEAR, INTERP1D_NEAREST]:\n                    raise TransportException(\"{}: Invalid value assigned to interp1d.\".format(coeff))\n\n            if g('_p') is not None or g('_xi') is not None:\n                if g('_xi').ndim != 1 or g('_xi').size != c.shape[2]:\n                    raise TransportException(\"{}: Invalid dimensions of xi vector. Expected {} elements.\".format(coeff, c.shape[2]))\n                elif g('_p').ndim != 1 or g('_p').size != c.shape[3]:\n                    raise TransportException(\"{}: Invalid dimensions of p vector. Expected {} elements.\".format(coeff, c.shape[3]))\n            elif g('_ppar') is not None or g('_pperp') is not None:\n                if g('_pperp').ndim != 1 or g('_pperp').size != c.shape[2]:\n                    raise TransportException(\"{}: Invalid dimensions of pperp vector. Expected {} elements.\".format(coeff, c.shape[2]))\n                elif g('_ppar').ndim != 1 or g('_ppar').size != c.shape[3]:\n                    raise TransportException(\"{}: Invalid dimensions of ppar vector. Expected {} elements.\".format(coeff, c.shape[3]))\n            else:\n                raise TransportException(\"No momentum grid provided for transport coefficient '{}'.\".format(coeff))\n        else:\n            if c.ndim != 2:\n                raise TransportException(\"{}: Invalid dimensions of transport coefficient: {}\".format(coeff, c.shape))\n            elif g('_t').ndim != 1 or g('_t').size != c.shape[0]:\n                raise TransportException(\"{}: Invalid dimensions of time vector. Expected {} elements.\".format(coeff, c.shape[0]))\n            elif g('_r').ndim != 1 or g('_r').size != c.shape[1]:\n                raise TransportException(\"{}: Invalid dimensions of radius vector. Expected {} elements.\".format(coeff, c.shape[1]))\n\n    def verifySettingsRechesterRosenbluth(self):\n        \"\"\"\n        Verify consistency of the Rechester-Rosenbluth transport settings.\n        \"\"\"\n        if self.dBB.ndim != 2:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of transport coefficient: {}\".format(self.dBB.shape))\n        elif self.dBB_t.ndim != 1 or self.dBB_t.size != self.dBB.shape[0]:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of time vector. Expected {} elements.\".format(self.dBB.shape[0]))\n        elif self.dBB_r.ndim != 1 or self.dBB_r.size != self.dBB.shape[1]:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of radius vector. Expected {} elements.\".format(self.dBB.shape[1]))",
  "class TransportException(DREAMException):\n    def __init__(self, msg):\n        super().__init__(msg)",
  "def __init__(self, kinetic=False):\n        \"\"\"\n        Constructor.\n\n        :param bool kinetic: If ``True``, the coefficient will be assumed kinetic (4D). Otherwise fluid (2D).\n        \"\"\"\n        self.kinetic = kinetic\n        self.type    = TRANSPORT_NONE\n\n\n        # Prescribed advection\n        self.ar           = None\n        self.ar_t         = None\n        self.ar_r         = None\n        self.ar_p         = None\n        self.ar_xi        = None\n        self.ar_ppar      = None\n        self.ar_pperp     = None\n        self.ar_interp3d  = None\n        \n        # Prescribed diffusion\n        self.drr          = None\n        self.drr_t        = None\n        self.drr_r        = None\n        self.drr_p        = None\n        self.drr_xi       = None\n        self.drr_ppar     = None\n        self.drr_pperp    = None\n        self.drr_interp3d = None\n\n        # Svensson pstar\n        self.pstar          = None\n        self.interp1d_param = SVENSSON_INTERP1D_PARAM_TIME \n        \n        # Svensson advection\n        self.s_ar           = None\n        self.s_ar_r         = None\n        self.s_ar_t         = None\n        self.s_ar_p         = None\n        self.s_ar_xi        = None\n        self.s_ar_ppar      = None\n        self.s_ar_pperp     = None\n        self.s_ar_interp3d  = None\n        self.s_ar_interp1d  = None\n        \n        # Svensson diffusion\n        self.s_drr          = None\n        self.s_drr_r        = None\n        self.s_drr_t        = None\n        self.s_drr_p        = None\n        self.s_drr_xi       = None\n        self.s_drr_ppar     = None\n        self.s_drr_pperp    = None\n        self.s_drr_interp3d = None\n        self.s_drr_interp1d = None\n\n        # Rechester-Rosenbluth (diffusive) transport\n        self.dBB   = None\n        self.dBB_t = None\n        self.dBB_r = None\n\n        self.boundarycondition = BC_CONSERVATIVE",
  "def isKinetic(self): return self.kinetic",
  "def prescribeAdvection(self, ar, t=None, r=None, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the advection coefficient to use.\n        \"\"\"\n        self._prescribeCoefficient('ar', coeff=ar, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp)",
  "def prescribeDiffusion(self, drr, t=None, r=None, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the diffusion coefficient to use.\n        \"\"\"\n        self._prescribeCoefficient('drr', coeff=drr, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp)",
  "def setSvenssonPstar(self,pstar):\n        \"\"\"\n        Set the lower momentum bound for the runaway, radial transport, region.\n        \"\"\"\n        self.pstar=float(pstar)",
  "def setSvenssonInterp1dParam(self, interp1d_param=SVENSSON_INTERP1D_PARAM_TIME):\n        \"\"\"\n        Set the lower momentum bound for the runaway, radial transport, region.\n        \"\"\"\n        self.interp1d_param = int(interp1d_param)",
  "def setBoundaryCondition(self, bc=None):\n        \"\"\"\n        Set the type of boundary condition. (Default is BC_CONSERVATIVE)\n        \"\"\"\n        self.boundarycondition = bc",
  "def setSvenssonAdvection(self, ar, t=None, Ip=None, r=None, p=None, xi=None, ppar=None, pperp=None, interp3d=INTERP3D_LINEAR, interp1d=INTERP1D_LINEAR):\n        r\"\"\"\n        Set the Svensson advection coefficient to use.\n\n        :param ar:       Advection coefficient, :math:`A_r(t,r,\\xi_0,p)` or :math:`A_r(I_p,r,\\xi_0,p)`.\n        :param t:        Time vector for which ``ar`` is defined (if ``Ip`` is not provided).\n        :param Ip:       Plasma current vector for which ``ar`` is defined (if ``t`` is not provided).\n        :param r:        Radial grid vector for which ``ar`` is defined.\n        :param p:        Momentum grid vector for which ``ar`` is defined.\n        :param xi:       Pitch grid vector for which ``ar`` is defined.\n        :param interp3d: Interpolation method to use when interpolating in (r,xi,p) part of coefficient.\n        :param interp1d: Interpolation method to use when interpolating in time/Ip variable.\n        \"\"\"\n        if self.interp1d_param == SVENSSON_INTERP1D_PARAM_TIME:\n            if t is not None:\n                self._prescribeCoefficient('s_ar', coeff=ar, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else: \n                raise TransportException('interp1d_param has been set to \"time\", but no time variable was given.')\n        elif self.interp1d_param == SVENSSON_INTERP1D_PARAM_IP:\n            if Ip is not None:\n                self._prescribeCoefficient('s_ar', coeff=ar, t=Ip, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else:\n                raise TransportException('interp1d_param has been set to \"Ip\", but no plasma-current variable was given.')\n        else:\n            raise TransportException('interp1d_param has not been set or is invalid. It must be set before setting the Svensson transport coefficients.')\n        self.type = TRANSPORT_SVENSSON\n        self.s_ar_interp1d = interp1d",
  "def setSvenssonDiffusion(self, drr, t=None, Ip=None, r=None, p=None, xi=None, ppar=None, pperp=None,interp3d=INTERP3D_LINEAR, interp1d=INTERP1D_LINEAR):\n        r\"\"\"\n        Set the Svensson diffusion coefficient to use.\n\n        :param drr:      Diffusion coefficient, :math:`D_{rr}(t,r,\\xi_0,p)` or :math:`D_{rr}(I_p,r,\\xi_0,p)`.\n        :param t:        Time vector for which ``drr`` is defined (if ``Ip`` is not provided).\n        :param Ip:       Plasma current vector for which ``drr`` is defined (if ``t`` is not provided).\n        :param r:        Radial grid vector for which ``drr`` is defined.\n        :param p:        Momentum grid vector for which ``drr`` is defined.\n        :param xi:       Pitch grid vector for which ``drr`` is defined.\n        :param interp3d: Interpolation method to use when interpolating in (r,xi,p) part of coefficient.\n        :param interp1d: Interpolation method to use when interpolating in time/Ip variable.\n        \"\"\"\n        if self.interp1d_param == SVENSSON_INTERP1D_PARAM_TIME:\n            if t is not None:\n                self._prescribeCoefficient('s_drr', coeff=drr, t=t, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else: \n                raise TransportException('interp1d_param has been set to \"time\", but no time variable was given.')\n        elif self.interp1d_param == SVENSSON_INTERP1D_PARAM_IP:\n            if Ip is not None:\n                self._prescribeCoefficient('s_drr', coeff=drr, t=Ip, r=r, p=p, xi=xi, ppar=ppar, pperp=pperp,interp3d=interp3d,override_kinetic=True)\n            else:\n                raise TransportException('interp1d_param has been set to \"Ip\", but no plasma-current variable was given.')\n        else:\n            raise TransportException('interp1d_param has not been set or is invalid. It must be set before setting the Svensson transport coefficients.')\n        self.type = TRANSPORT_SVENSSON\n        self.s_drr_interp1d = interp1d",
  "def _prescribeCoefficient(self, name, coeff, t=None, r=None, p=None, xi=None, ppar=None, pperp=None,interp3d=INTERP3D_LINEAR, override_kinetic=False):\n        \"\"\"\n        General method for prescribing an advection or diffusion coefficient.\n        \"\"\"\n        self.type = TRANSPORT_PRESCRIBED\n\n        setattr(self, name+'_interp3d', interp3d)\n\n        if np.isscalar(coeff):\n            r = np.array([0])\n            t = np.array([0])\n            p = np.array([0])\n            xi = np.array([0])\n\n            if self.kinetic or override_kinetic:\n                coeff = coeff * np.ones((1,)*4)\n            else:\n                coeff = coeff * np.ones((1,)*2)\n\n        r = np.asarray(r)\n        t = np.asarray(t)\n        \n        if r.ndim != 1: r = np.reshape(r, (r.size,))\n        if t.ndim != 1: t = np.reshape(t, (t.size,))\n\n        if (self.kinetic == False and not override_kinetic) and len(coeff.shape) == 2:\n            setattr(self, name, coeff)\n            setattr(self, name+'_r', r)\n            setattr(self, name+'_t', t)\n        elif (self.kinetic == True or override_kinetic) and len(coeff.shape) == 4:\n            # Verify that the momentum grid is given\n            if p is not None and xi is not None:\n                ppar, pperp = None, None\n            elif ppar is not None and pperp is not None:\n                p, xi = None, None\n            else:\n                raise TransportException(\"No momentum grid provided for the 4D transport coefficient.\")\n\n            setattr(self, name, coeff)\n            setattr(self, name+'_r', r)\n            setattr(self, name+'_t', t)\n\n            if p is not None:\n                setattr(self, name+'_p', p)\n                setattr(self, name+'_xi', xi)\n            else:\n                setattr(self, name+'_ppar', ppar)\n                setattr(self, name+'_pperp', pperp)\n        else:\n            raise TransportException(\"Invalid dimensions of prescribed coefficient: {}. Expected {} dimensions.\".format(coeff.shape, 4 if (self.kinetic or override_kinetic) else 2))",
  "def setMagneticPerturbation(self, dBB, t=None, r=None):\n        \"\"\"\n        Prescribes the evolution of the magnetic perturbation level (dB/B).\n\n        :param dBB: Magnetic perturbation level.\n        :param t:   Time grid on which the perturbation is defined.\n        :param r:   Radial grid on which the perturbation is defined.\n        \"\"\"\n        self.type = TRANSPORT_RECHESTER_ROSENBLUTH\n\n        if np.isscalar(dBB):\n            dBB = dBB * np.ones((1,1))\n            r = np.array([0])\n            t = np.array([0])\n\n        r = np.asarray(r)\n        t = np.asarray(t)\n\n        if r.ndim != 1: r = np.reshape(r, (r.size,))\n        if t.ndim != 1: t = np.reshape(t, (t.size,))\n\n        self.dBB_r = r\n        self.dBB_t = t\n        self.dBB   = dBB",
  "def setBoundaryCondition(self, bc):\n        \"\"\"\n        Set the boundary condition to use for the transport.\n        \"\"\"\n        self.boundarycondition = bc",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        # Prescribed advection\n        self.ar = None\n        self.ar_r = None\n        self.ar_t = None\n        self.ar_p = None\n        self.ar_xi = None\n        self.ar_ppar = None\n        self.ar_pperp = None\n        self.ar_interp3d =None\n        \n        # Prescribed diffusion\n        self.drr = None\n        self.drr_r = None\n        self.drr_t = None\n        self.drr_p = None\n        self.drr_xi = None\n        self.drr_ppar = None\n        self.drr_pperp = None\n        self.drr_interp3d =None\n        \n        # Svensson pstar\n        self.pstar          = None\n        self.interp1d_param = None\n        \n        # Svensson advection\n        self.s_ar           = None\n        self.s_ar_r         = None\n        self.s_ar_t         = None\n        self.s_ar_p         = None\n        self.s_ar_xi        = None\n        self.s_ar_ppar      = None\n        self.s_ar_pperp     = None\n        self.s_ar_interp3d  = None\n        self.s_ar_interp1d  = None\n        \n\n        # Svensson diffusion\n        self.s_drr          = None\n        self.s_drr_r        = None\n        self.s_drr_t        = None\n        self.s_drr_p        = None\n        self.s_drr_xi       = None\n        self.s_drr_ppar     = None\n        self.s_drr_pperp    = None\n        self.s_drr_interp3d = None\n        self.s_drr_interp1d = None\n\n\n        # Rechester--Rosenbluth\n        self.dBB = None\n        self.dBB_r = None\n        self.dBB_t = None\n\n        if 'type' in data:\n            self.type = data['type']\n\n        if 'boundarycondition' in data:\n            self.boundarycondition = data['boundarycondition']\n\n        if 'ar' in data:\n            self.ar = data['ar']['x']\n            self.ar_r  = data['ar']['r']\n            self.ar_t  = data['ar']['t']\n\n            if 'interp3d' in data['ar']:\n                self.ar_interp3d = data['ar']['interp3d']\n\n            if self.kinetic:\n                if 'p' in data['ar']: self.ar_p = data['ar']['p']\n                if 'xi' in data['ar']: self.ar_xi = data['ar']['xi']\n                if 'ppar' in data['ar']: self.ar_ppar = data['ar']['ppar']\n                if 'pperp' in data['ar']: self.ar_pperp = data['ar']['pperp']\n\n        if 'drr' in data:\n            self.drr = data['drr']['x']\n            self.drr_r  = data['drr']['r']\n            self.drr_t  = data['drr']['t']\n\n            if 'interp3d' in data['drr']:\n                self.drr_interp3d = data['drr']['interp3d']\n\n            if self.kinetic:\n                if 'p' in data['drr']: self.drr_p = data['drr']['p']\n                if 'xi' in data['drr']: self.drr_xi = data['drr']['xi']\n                if 'ppar' in data['drr']: self.drr_ppar = data['drr']['ppar']\n                if 'pperp' in data['drr']: self.drr_pperp = data['drr']['pperp']\n\n        if 'pstar' in data:\n            self.pstar = data['pstar']\n            \n        if 'interp1d_param' in data:\n            self.interp1d_param = data['interp1d_param']\n            \n        if 's_ar' in data:\n            self.s_ar                 = data['s_ar']['x']\n            self.s_ar_r               = data['s_ar']['r']\n            self.s_ar_t               = data['s_ar']['t']\n            self.s_ar_interp3d        = data['s_ar']['interp3d']\n            self.s_ar_interp1d        = data['s_ar']['interp1d']\n            \n            if 'p' in data['s_ar']:     self.s_ar_p     = data['s_ar']['p']\n            if 'xi' in data['s_ar']:    self.s_ar_xi    = data['s_ar']['xi']\n            if 'ppar' in data['s_ar']:  self.s_ar_ppar  = data['s_ar']['ppar']\n            if 'pperp' in data['s_ar']: self.s_ar_pperp = data['s_ar']['pperp']\n\n        if 's_drr' in data:\n            self.s_drr                 = data['s_drr']['x']\n            self.s_drr_r               = data['s_drr']['r']\n            self.s_drr_t               = data['s_drr']['t']\n            self.s_drr_interp3d        = data['s_drr']['interp3d']\n            self.s_drr_interp1d        = data['s_drr']['interp1d']\n\n            if 'p' in data['s_drr']:     self.s_drr_p     = data['s_drr']['p']\n            if 'xi' in data['s_drr']:    self.s_drr_xi    = data['s_drr']['xi']\n            if 'ppar' in data['s_drr']:  self.s_drr_ppar  = data['s_drr']['ppar']\n            if 'pperp' in data['s_drr']: self.s_drr_pperp = data['s_drr']['pperp']\n\n        if 'dBB' in data:\n            self.dBB   = data['dBB']['x']\n            self.dBB_r = data['dBB']['r']\n            self.dBB_t = data['dBB']['t']",
  "def todict(self):\n        \"\"\"\n        Returns these settings as a dictionary.\n        \"\"\"\n        data = {\n            'type': self.type,\n            'boundarycondition': self.boundarycondition\n        }\n\n        # Advection?\n        if self.type == TRANSPORT_PRESCRIBED and self.ar is not None:\n            data['ar'] = {\n                'x': self.ar,\n                'r': self.ar_r,\n                't': self.ar_t,\n                'interp3d': self.ar_interp3d\n            }\n\n            if self.kinetic:\n                if self.ar_p is not None:\n                    data['ar']['p'] = self.ar_p\n                    data['ar']['xi'] = self.ar_xi\n                else:\n                    data['ar']['ppar'] = self.ar_ppar\n                    data['ar']['pperp'] = self.ar_pperp\n\n        # Diffusion?\n        if self.type == TRANSPORT_PRESCRIBED and self.drr is not None:\n            data['drr'] = {\n                'x': self.drr,\n                'r': self.drr_r,\n                't': self.drr_t,\n                'interp3d': self.drr_interp3d\n            }\n\n            if self.kinetic:\n                if self.drr_p is not None:\n                    data['drr']['p'] = self.drr_p\n                    data['drr']['xi'] = self.drr_xi\n                else:\n                    data['drr']['ppar'] = self.drr_ppar\n                    data['drr']['pperp'] = self.drr_pperp\n\n        \n        # Svensson pstar\n        if self.type == TRANSPORT_SVENSSON and self.pstar is not None:\n            data['pstar'] = self.pstar\n\n        # Svensson 1d interpolatino method\n        if self.type == TRANSPORT_SVENSSON and self.interp1d_param is not None:\n            data['interp1d_param'] =  self.interp1d_param\n        \n        # Svensson Advection?\n        if self.type == TRANSPORT_SVENSSON and self.s_ar is not None:\n            data['s_ar'] = {\n                'x': self.s_ar,\n                'r': self.s_ar_r,\n                't': self.s_ar_t,\n                'interp3d': self.s_ar_interp3d,\n                'interp1d': self.s_ar_interp1d,\n            }\n\n            if self.s_ar_p is not None:\n                data['s_ar']['p'] = self.s_ar_p\n                data['s_ar']['xi'] = self.s_ar_xi\n            else:\n                data['s_ar']['ppar'] = self.s_ar_ppar\n                data['s_ar']['pperp'] = self.s_ar_pperp\n\n        # Svensson Diffusion?\n        if self.type == TRANSPORT_SVENSSON and self.s_drr is not None:\n            data['s_drr'] = {\n                'x': self.s_drr,\n                'r': self.s_drr_r,\n                't': self.s_drr_t,\n                'interp3d': self.s_drr_interp3d,\n                'interp1d': self.s_drr_interp1d,\n            }\n\n            if self.s_drr_p is not None:\n                data['s_drr']['p'] = self.s_drr_p\n                data['s_drr']['xi'] = self.s_drr_xi\n            else:\n                data['s_drr']['ppar'] = self.s_drr_ppar\n                data['s_drr']['pperp'] = self.s_drr_pperp\n\n        \n        if self.type == TRANSPORT_RECHESTER_ROSENBLUTH and self.dBB is not None:\n            data['dBB'] = {\n                'x': self.dBB,\n                'r': self.dBB_r,\n                't': self.dBB_t\n            }\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings are consistent.\n        \"\"\"\n        if self.type == TRANSPORT_NONE:\n            pass\n        elif self.type == TRANSPORT_PRESCRIBED:\n            self.verifySettingsCoefficient('ar')\n            self.verifySettingsCoefficient('drr')\n            self.verifyBoundaryCondition()\n        elif self.type == TRANSPORT_SVENSSON:\n            self.verifySettingsCoefficient('s_ar',override_kinetic=True)\n            self.verifySettingsCoefficient('s_drr',override_kinetic=True)\n            if self.pstar is None or type(self.pstar) != float:\n                raise TransportException(\"pstar not defined or wrong type.\")\n            elif self.pstar<=0:\n                raise TransportException(\"pstar = %0.3f <= 0 not allowed.\" % self.pstar)\n            \n            self.verifyBoundaryCondition() \n        elif self.type == TRANSPORT_RECHESTER_ROSENBLUTH:\n            self.verifySettingsRechesterRosenbluth()\n            self.verifyBoundaryCondition()\n        else:\n            raise TransportException(\"Unrecognized transport type: {}\".format(self.type))",
  "def verifyBoundaryCondition(self):\n        \"\"\"\n        Verify that the boundary condition has been correctly configured.\n        \"\"\"\n        bcs = [BC_CONSERVATIVE, BC_F_0, BC_DF_CONST]\n        if self.boundarycondition not in bcs:\n            raise TransportException(\"Invalid boundary condition specified for transport: {}\".format(self.boundarycondition))",
  "def verifySettingsCoefficient(self, coeff, override_kinetic=False):\n        \"\"\"\n        Verify consistency of the named prescribed transport coefficient.\n        \"\"\"\n        g = lambda v : self.__dict__[coeff+v]\n        c = g('')\n\n        if c is None: return\n\n        if self.kinetic or override_kinetic:\n            if c.ndim != 4:\n                raise TransportException(\"{}: Invalid dimensions of transport coefficient: {}\".format(coeff, c.shape))\n            elif g('_t').ndim != 1 or g('_t').size != c.shape[0]:\n                raise TransportException(\"{}: Invalid dimensions of time vector. Expected {} elements.\".format(coeff, c.shape[0]))\n            elif g('_r').ndim != 1 or g('_r').size != c.shape[1]:\n                raise TransportException(\"{}: Invalid dimensions of radius vector. Expected {} elements.\".format(coeff, c.shape[1]))\n\n            if g('_interp3d') not in [INTERP3D_LINEAR, INTERP3D_NEAREST]:\n                raise TransportException(\"{}: Invalid value assigned to interp3d.\".format(coeff))\n\n            if coeff+'v' in self.__dict__:\n                if g('_interp1d') not in [INTERP1D_LINEAR, INTERP1D_NEAREST]:\n                    raise TransportException(\"{}: Invalid value assigned to interp1d.\".format(coeff))\n\n            if g('_p') is not None or g('_xi') is not None:\n                if g('_xi').ndim != 1 or g('_xi').size != c.shape[2]:\n                    raise TransportException(\"{}: Invalid dimensions of xi vector. Expected {} elements.\".format(coeff, c.shape[2]))\n                elif g('_p').ndim != 1 or g('_p').size != c.shape[3]:\n                    raise TransportException(\"{}: Invalid dimensions of p vector. Expected {} elements.\".format(coeff, c.shape[3]))\n            elif g('_ppar') is not None or g('_pperp') is not None:\n                if g('_pperp').ndim != 1 or g('_pperp').size != c.shape[2]:\n                    raise TransportException(\"{}: Invalid dimensions of pperp vector. Expected {} elements.\".format(coeff, c.shape[2]))\n                elif g('_ppar').ndim != 1 or g('_ppar').size != c.shape[3]:\n                    raise TransportException(\"{}: Invalid dimensions of ppar vector. Expected {} elements.\".format(coeff, c.shape[3]))\n            else:\n                raise TransportException(\"No momentum grid provided for transport coefficient '{}'.\".format(coeff))\n        else:\n            if c.ndim != 2:\n                raise TransportException(\"{}: Invalid dimensions of transport coefficient: {}\".format(coeff, c.shape))\n            elif g('_t').ndim != 1 or g('_t').size != c.shape[0]:\n                raise TransportException(\"{}: Invalid dimensions of time vector. Expected {} elements.\".format(coeff, c.shape[0]))\n            elif g('_r').ndim != 1 or g('_r').size != c.shape[1]:\n                raise TransportException(\"{}: Invalid dimensions of radius vector. Expected {} elements.\".format(coeff, c.shape[1]))",
  "def verifySettingsRechesterRosenbluth(self):\n        \"\"\"\n        Verify consistency of the Rechester-Rosenbluth transport settings.\n        \"\"\"\n        if self.dBB.ndim != 2:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of transport coefficient: {}\".format(self.dBB.shape))\n        elif self.dBB_t.ndim != 1 or self.dBB_t.size != self.dBB.shape[0]:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of time vector. Expected {} elements.\".format(self.dBB.shape[0]))\n        elif self.dBB_r.ndim != 1 or self.dBB_r.size != self.dBB.shape[1]:\n            raise TransportException(\"Rechester-Rosenbluth: Invalid dimensions of radius vector. Expected {} elements.\".format(self.dBB.shape[1]))",
  "def __init__(self, msg):\n        super().__init__(msg)",
  "class LUKEMagneticField(NumericalMagneticField):\n    \n\n    def __init__(self, filename):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.load(filename)\n\n        super().__init__(a=self.getMinorRadius(), R0=self.getMajorRadius())\n\n\n    def load(self, filename, path=''):\n        \"\"\"\n        Load a LUKE magnetic equilibrium from the named file.\n        \"\"\"\n        PATH = '{}/equil'.format(path)\n\n        with h5py.File(filename, 'r') as f:\n            self.id = DREAMIO.getData(f[PATH], 'id')\n            if type(self.id) != str:\n                self.id = ''\n\n            self.Rp = f['{}/Rp'.format(PATH)][:]\n            self.Zp = f['{}/Zp'.format(PATH)][:]\n            self.psi_apRp = f['{}/psi_apRp'.format(PATH)][:]\n            self.theta = f['{}/theta'.format(PATH)][:]\n            self.ptx = f['{}/ptx'.format(PATH)][:]\n            self.pty = f['{}/pty'.format(PATH)][:]\n            self.ptBx = f['{}/ptBx'.format(PATH)][:]\n            self.ptBy = f['{}/ptBy'.format(PATH)][:]\n            self.ptBPHI = f['{}/ptBPHI'.format(PATH)][:]\n\n        if self.Rp.ndim == 2:\n            self.Rp = self.Rp[0,0]\n        if self.Zp.ndim == 2:\n            self.Zp = self.Zp[0,0]\n        if self.psi_apRp.shape[0] == 1:\n            self.psi_apRp = self.psi_apRp[0,:]\n        if self.theta.shape[0] == 1:\n            self.theta = self.theta[0,:]\n\n\n    def getMinorRadius(self):\n        \"\"\"\n        Returns plasma minor radius.\n        \"\"\"\n        return float(self.ptx[0,-1])\n\n\n    def getMajorRadius(self):\n        \"\"\"\n        Returns tokamak major radius.\n        \"\"\"\n        return float(self.Rp)\n\n\n    def visualize(self, npsi=20, ax=None, show=None):\n        \"\"\"\n        Visualize this magnetic field.\n        \"\"\"\n        red   = (249/255, 65/255, 68/255)\n        black = (87/255, 117/255, 144/255)\n        gray  = (120/255, 120/255, 120/255)\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n    \n        R, Z = self.ptx[:,:-1]+self.Rp, self.pty[:,:-1]+self.Zp\n        if npsi > R.shape[1]:\n            npsi = R.shape[1]\n\n        sel  = [int(i) for i in np.round(np.linspace(0, R.shape[1]-1, npsi))]\n\n        ax.plot(R[:,sel], Z[:,sel], color=gray, linewidth=0.5)\n        ax.plot(self.ptx[:,-1] + self.Rp, self.pty[:,-1] + self.Zp, color=red, linewidth=2)\n        ax.plot(self.Rp, self.Zp, 's', color=red)\n\n        ax.set_title(helpers.safeTeXstring(self.id))\n        ax.set_xlabel('$R$ (m)')\n        ax.set_ylabel('$Z$ (m)')\n\n        ax.axis('equal')\n\n        if show:\n            plt.show()\n\n        return ax",
  "def __init__(self, filename):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.load(filename)\n\n        super().__init__(a=self.getMinorRadius(), R0=self.getMajorRadius())",
  "def load(self, filename, path=''):\n        \"\"\"\n        Load a LUKE magnetic equilibrium from the named file.\n        \"\"\"\n        PATH = '{}/equil'.format(path)\n\n        with h5py.File(filename, 'r') as f:\n            self.id = DREAMIO.getData(f[PATH], 'id')\n            if type(self.id) != str:\n                self.id = ''\n\n            self.Rp = f['{}/Rp'.format(PATH)][:]\n            self.Zp = f['{}/Zp'.format(PATH)][:]\n            self.psi_apRp = f['{}/psi_apRp'.format(PATH)][:]\n            self.theta = f['{}/theta'.format(PATH)][:]\n            self.ptx = f['{}/ptx'.format(PATH)][:]\n            self.pty = f['{}/pty'.format(PATH)][:]\n            self.ptBx = f['{}/ptBx'.format(PATH)][:]\n            self.ptBy = f['{}/ptBy'.format(PATH)][:]\n            self.ptBPHI = f['{}/ptBPHI'.format(PATH)][:]\n\n        if self.Rp.ndim == 2:\n            self.Rp = self.Rp[0,0]\n        if self.Zp.ndim == 2:\n            self.Zp = self.Zp[0,0]\n        if self.psi_apRp.shape[0] == 1:\n            self.psi_apRp = self.psi_apRp[0,:]\n        if self.theta.shape[0] == 1:\n            self.theta = self.theta[0,:]",
  "def getMinorRadius(self):\n        \"\"\"\n        Returns plasma minor radius.\n        \"\"\"\n        return float(self.ptx[0,-1])",
  "def getMajorRadius(self):\n        \"\"\"\n        Returns tokamak major radius.\n        \"\"\"\n        return float(self.Rp)",
  "def visualize(self, npsi=20, ax=None, show=None):\n        \"\"\"\n        Visualize this magnetic field.\n        \"\"\"\n        red   = (249/255, 65/255, 68/255)\n        black = (87/255, 117/255, 144/255)\n        gray  = (120/255, 120/255, 120/255)\n\n        genax = ax is None\n\n        if genax:\n            ax = plt.axes()\n\n            if show is None:\n                show = True\n    \n        R, Z = self.ptx[:,:-1]+self.Rp, self.pty[:,:-1]+self.Zp\n        if npsi > R.shape[1]:\n            npsi = R.shape[1]\n\n        sel  = [int(i) for i in np.round(np.linspace(0, R.shape[1]-1, npsi))]\n\n        ax.plot(R[:,sel], Z[:,sel], color=gray, linewidth=0.5)\n        ax.plot(self.ptx[:,-1] + self.Rp, self.pty[:,-1] + self.Zp, color=red, linewidth=2)\n        ax.plot(self.Rp, self.Zp, 's', color=red)\n\n        ax.set_title(helpers.safeTeXstring(self.id))\n        ax.set_xlabel('$R$ (m)')\n        ax.set_ylabel('$Z$ (m)')\n\n        ax.axis('equal')\n\n        if show:\n            plt.show()\n\n        return ax",
  "class UnknownQuantity:\n    \n\n    def __init__(self, settings):\n        self.settings = settings",
  "def __init__(self, settings):\n        self.settings = settings",
  "class PrescribedParameter:\n    \n\n    def _setPrescribedData(self, data, radius=0, times=0):\n        \"\"\"\n        Set prescribed data appropriately.\n        \"\"\"\n        if np.isscalar(radius):\n            r = np.asarray([radius])\n        else: r = np.asarray(radius)\n\n        if np.isscalar(times):\n            t = np.asarray([times])\n        else: t = np.asarray(times)\n\n        if np.isscalar(data):\n            d = data*np.ones((t.size, r.size))\n        else: d = np.asarray(data)\n\n        # Ensure that the data is 2D\n        d = np.reshape(d, (t.size, r.size))\n\n        return d, r, t\n\n\n    def _verifySettingsPrescribedData(self, name, data, radius, times):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 2:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed data. Expected 2 dimensions (time x radius).\".format(name))\n        elif len(times.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in time grid of prescribed data. Expected one dimension.\".format(name))\n        elif len(radius.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed data. Expected one dimension.\".format(name))\n        elif data.shape[0] != times.size or data.shape[1] != radius.size:\n            raise EquationException(\"{}: Invalid dimensions of prescribed data: {}x{}. Expected {}x{} (time x radius).\"\n                .format(name, data.shape[0], data.shape[1], times.size, radius.size))",
  "def _setPrescribedData(self, data, radius=0, times=0):\n        \"\"\"\n        Set prescribed data appropriately.\n        \"\"\"\n        if np.isscalar(radius):\n            r = np.asarray([radius])\n        else: r = np.asarray(radius)\n\n        if np.isscalar(times):\n            t = np.asarray([times])\n        else: t = np.asarray(times)\n\n        if np.isscalar(data):\n            d = data*np.ones((t.size, r.size))\n        else: d = np.asarray(data)\n\n        # Ensure that the data is 2D\n        d = np.reshape(d, (t.size, r.size))\n\n        return d, r, t",
  "def _verifySettingsPrescribedData(self, name, data, radius, times):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 2:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed data. Expected 2 dimensions (time x radius).\".format(name))\n        elif len(times.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in time grid of prescribed data. Expected one dimension.\".format(name))\n        elif len(radius.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed data. Expected one dimension.\".format(name))\n        elif data.shape[0] != times.size or data.shape[1] != radius.size:\n            raise EquationException(\"{}: Invalid dimensions of prescribed data: {}x{}. Expected {}x{} (time x radius).\"\n                .format(name, data.shape[0], data.shape[1], times.size, radius.size))",
  "class ElectricField(PrescribedParameter, PrescribedInitialParameter, PrescribedScalarParameter, UnknownQuantity):\n    \n    def __init__(self, settings, ttype=TYPE_PRESCRIBED, efield=None, radius=0,\n                 times=0):\n        \"\"\"\n        Constructor.\n\n        :param DREAM.DREAMSettings settings: Parent settings object.\n        :param int ttype: Method to use for evolving electric field.\n        :param efield: Prescribed or initial electric field (profile).\n        :param radius: Radial grid on which the prescribed or initial electric field (profile) is defined.\n        :param times: Time grid on which the prescribed electric field is defined.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        # Prescribed electric field evolution\n        self.efield = None\n        self.radius = None\n        self.times  = None\n\n        if (ttype == TYPE_PRESCRIBED) and (efield is not None):\n            self.setPrescribedData(efield=efield, radius=radius, times=times)\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.setInitialProfile(efield=efield, radius=radius)\n\n        # Boundary condition quantities\n        self.bctype = BC_TYPE_PRESCRIBED\n        self.inverse_wall_time = None\n        self.V_loop_wall_R0 = None\n        self.V_loop_wall_t = None\n        self.R0 = 0\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns the value of the prescribed electric field at\n        the given indices.\n        \"\"\"\n        return self.efield[index]\n\n\n    ####################\n    # SETTERS\n    ####################\n    def setInitialProfile(self, efield, radius=0):\n        \"\"\"\n        When ``TYPE_SELFCONSISTENT``, sets the initial electric field profile.\n        The parameter ``efield`` may be either a scalar (in which case the\n        profile is taken to be uniform) or an array. The associated radial grid\n        ``radius`` must be of the same type and dimension.\n\n        :param efield: Initial electric field profile.\n        :param radius: Radial grid on which the initial profile is defined.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=efield, radius=radius)\n\n        self.efield = _data\n        self.radius = _rad\n        self.times  = None\n\n        self._verifySettingsPrescribedInitialData()\n\n\n    def setPrescribedData(self, efield, radius=0, times=0):\n        \"\"\"\n        When ``TYPE_PRESCRIBED``, sets the spatiotemporal evolution of the\n        electric field during the simulation. The parameter ``efield`` may be\n        either a scalar (in which case the electric field is taken to be\n        constant and uniform in time and radius) or a 2D array of shape\n        (nt, nr). The associated time grid ``times`` must be of size ``nt`` and\n        the radial grid must be of size ``nr``.\n\n        :param efield: Prescribed electric field.\n        :param radius: Radial grid on which the electric field is prescribed.\n        :param times:  Time grid on which the electric field is prescribed.\n        \"\"\"\n        _data, _rad, _tim = self._setPrescribedData(efield, radius, times)\n        self.efield = _data\n        self.radius = _rad\n        self.times  = _tim\n\n        self._verifySettingsPrescribedData()\n\n\n    def setBoundaryCondition(self, bctype = BC_TYPE_SELFCONSISTENT, V_loop_wall_R0=None,\n                             times=0, inverse_wall_time=None, R0=0):\n        r\"\"\"\n        Specifies the boundary condition to use when solving for the electric\n        field self-consistently, i.e. with ``TYPE_SELFCONSISTENT``. Possible\n        boundary condition types are:\n\n        +------------------------+------------------------------------------------------------------------------------------+\n        | Name                   | Description                                                                              |\n        +========================+==========================================================================================+\n        | BC_TYPE_PRESCRIBED     | Set :math:`V_{\\rm loop}` on the tokamak wall.                                            |\n        +------------------------+------------------------------------------------------------------------------------------+\n        | BC_TYPE_SELFCONSISTENT | Specify the tokamak wall time and solve self-consistently for :math:`V_{\\rm loop,wall}`. |\n        +------------------------+------------------------------------------------------------------------------------------+\n        | BC_TYPE_TRANSFORMER    | Same as ``BC_TYPE_SELFCONSISTENT``, but with prescribed loop voltage via transformer.    |\n        +------------------------+------------------------------------------------------------------------------------------+\n\n        :param int bctype:        Type of boundary condition to use (see table above for available options).\n        :param V_loop_wall_R0:    Prescribed value of :math:`V_{\\rm loop}/R_0` on the tokamak wall (or at transformer in case of ``type=BC_TYPE_TRANSFORMER``), normalized to the tokamak major radius :math:`R_0`.\n        :param times:             Time grid on which ``V_loop_wall_R0`` is given.\n        :param inverse_wall_time: Inverse wall time for the tokamak, used when solving for :math:`V_{\\rm loop,wall}` self-consistently.\n        :param R0:                Major radius for the tokamak, only used when solving for :math:`V_{\\rm loop,wall}` self-consistently (independent of radial-grid major radius).\n        \"\"\"\n        if bctype == BC_TYPE_PRESCRIBED:\n            self.bctype = bctype\n\n            # Ensure correct format\n            _data, _tim = self._setScalarData(data=V_loop_wall_R0, times=times)\n            self.V_loop_wall_R0 = _data\n            self.V_loop_wall_t = _tim\n        elif bctype == BC_TYPE_SELFCONSISTENT:\n            self.bctype = bctype\n            self.inverse_wall_time = inverse_wall_time\n            self.R0 = R0\n        elif bctype == BC_TYPE_TRANSFORMER:\n            self.bctype = bctype\n            self.inverse_wall_time = inverse_wall_time\n            self.R0 = R0\n\n            # Ensure correct format\n            _data, _tim = self._setScalarData(data=V_loop_wall_R0, times=times)\n            self.V_loop_wall_R0 = _data\n            self.V_loop_wall_t = _tim\n        else:\n            raise EquationException(\"E_field: Unrecognized boundary condition type: {}\".format(bctype))\n\n\n    def setType(self, ttype):\n        r\"\"\"\n        Set the type of equation to use for evolving the electric field. The\n        available types are\n\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | Name                          | Description                                                                                  |\n        +===============================+==============================================================================================+\n        | TYPE_PRESCRIBED               | Prescribe spatiotemporal evolution of electric field.                                        |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | TYPE_SELFCONSISTENT           | Evolve electric field consistent with the evolution of the poloidal flux and plasma current. |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | TYPE_PRESCRIBED_OHMIC_CURRENT | Evolve electric field consistent with the evolution of the poloidal flux and plasma current. |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n\n        :param int ttype: Type of electric field evolution to use.\n        \"\"\"\n        if ttype in [TYPE_PRESCRIBED, TYPE_PRESCRIBED_OHMIC_CURRENT]:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n\n            if self.efield is not None:\n                self.efield = None\n                self.radius = None\n                self.times = None\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(ttype))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Sets this paramater from settings provided in a dictionary.\n        \"\"\"\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.efield = data['data']['x']\n            self.radius = data['data']['r']\n            self.times  = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            self.bctype = data['bc']['type']\n\n            if 'init' in data:\n                self.efield = data['init']['x']\n                self.radius = data['init']['r']\n\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                self.V_loop_wall_R0   = data['bc']['V_loop_wall']['x']\n                self.V_loop_wall_t = data['bc']['V_loop_wall']['t']\n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                self.inverse_wall_time = data['bc']['inverse_wall_time']\n                if not np.isscalar(self.inverse_wall_time):\n                    self.inverse_wall_time = float(self.inverse_wall_time[0])\n                if 'R0' in data['bc']:\n                    self.R0 = float(data['bc']['R0'])\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                self.inverse_wall_time = data['bc']['inverse_wall_time']\n                if not np.isscalar(self.inverse_wall_time):\n                    self.inverse_wall_time = float(self.inverse_wall_time[0])\n                if 'R0' in data['bc']:\n                    self.R0 = float(data['bc']['R0'])\n\n                self.V_loop_wall_R0 = data['bc']['V_loop_wall']['x']\n                self.V_loop_wall_t  = data['bc']['V_loop_wall']['t']\n            else:\n                raise EquationException(\"E_field: Unrecognized boundary condition type: {}\".format(self.bctype))\n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(self.type))\n\n        self.verifySettings()\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n        data['bc'] = {'type' : self.bctype}\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.efield,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            # The initial condition can either be given\n            # in terms of the electric field or in terms\n            # of the current density...\n            if self.efield is not None:\n                data['init'] = {\n                    'x': self.efield,\n                    'r': self.radius,\n                }            \n\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                data['bc']['V_loop_wall'] = {\n                        'x': self.V_loop_wall_R0,\n                        't': self.V_loop_wall_t\n                }                \n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                data['bc']['inverse_wall_time'] = self.inverse_wall_time\n                data['bc']['R0'] = self.R0\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                data['bc']['inverse_wall_time'] = self.inverse_wall_time\n                data['bc']['R0'] = self.R0\n                data['bc']['V_loop_wall'] = {\n                        'x': self.V_loop_wall_R0,\n                        't': self.V_loop_wall_t\n                }                \n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(self.type))\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.efield) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no electric field data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self._verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            if self.efield is not None:\n                if type(self.efield) != np.ndarray:\n                    raise EquationException(\"E_field: Electric field prescribed, but no electric field data provided.\")\n                elif type(self.radius) != np.ndarray:\n                    raise EquationException(\"E_field: Electric field prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            # Check boundary condition\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                self._verifySettingsPrescribedScalarData()\n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                if not np.isscalar(self.inverse_wall_time):\n                    raise EquationException(\"E_field: The specified inverse wall time is not a scalar: {}\".format(self.inverse_wall_time))\n                if not np.isscalar(self.R0) and not self.R0<0:\n                    raise EquationException(\"E_field: The specified major radius must be scalar and non-negative: R0 = {}\".format(self.R0))\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                self._verifySettingsPrescribedScalarData()\n                if not np.isscalar(self.inverse_wall_time):\n                    raise EquationException(\"E_field: The specified inverse wall time is not a scalar: {}\".format(self.inverse_wall_time))\n                if not np.isscalar(self.R0) and not self.R0<0:\n                    raise EquationException(\"E_field: The specified major radius must be scalar and non-negative: R0 = {}\".format(self.R0))\n            else:\n                raise EquationException(\"E_field: Unrecognized boundary condition type: {}.\".format(self.bctype))\n\n            if self.efield is not None:\n                self._verifySettingsPrescribedInitialData()\n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized equation type specified: {}.\".format(self.type))\n\n\n    def _verifySettingsPrescribedData(self):\n        super()._verifySettingsPrescribedData('E_field', data=self.efield, radius=self.radius, times=self.times)\n\n\n    def _verifySettingsPrescribedInitialData(self):\n        super()._verifySettingsPrescribedInitialData('E_field', data=self.efield, radius=self.radius)\n\n\n    def _verifySettingsPrescribedScalarData(self):\n        super()._verifySettingsPrescribedScalarData('E_field', data=self.V_loop_wall_R0, times=self.V_loop_wall_t)",
  "def __init__(self, settings, ttype=TYPE_PRESCRIBED, efield=None, radius=0,\n                 times=0):\n        \"\"\"\n        Constructor.\n\n        :param DREAM.DREAMSettings settings: Parent settings object.\n        :param int ttype: Method to use for evolving electric field.\n        :param efield: Prescribed or initial electric field (profile).\n        :param radius: Radial grid on which the prescribed or initial electric field (profile) is defined.\n        :param times: Time grid on which the prescribed electric field is defined.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        # Prescribed electric field evolution\n        self.efield = None\n        self.radius = None\n        self.times  = None\n\n        if (ttype == TYPE_PRESCRIBED) and (efield is not None):\n            self.setPrescribedData(efield=efield, radius=radius, times=times)\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.setInitialProfile(efield=efield, radius=radius)\n\n        # Boundary condition quantities\n        self.bctype = BC_TYPE_PRESCRIBED\n        self.inverse_wall_time = None\n        self.V_loop_wall_R0 = None\n        self.V_loop_wall_t = None\n        self.R0 = 0",
  "def __getitem__(self, index):\n        \"\"\"\n        Returns the value of the prescribed electric field at\n        the given indices.\n        \"\"\"\n        return self.efield[index]",
  "def setInitialProfile(self, efield, radius=0):\n        \"\"\"\n        When ``TYPE_SELFCONSISTENT``, sets the initial electric field profile.\n        The parameter ``efield`` may be either a scalar (in which case the\n        profile is taken to be uniform) or an array. The associated radial grid\n        ``radius`` must be of the same type and dimension.\n\n        :param efield: Initial electric field profile.\n        :param radius: Radial grid on which the initial profile is defined.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=efield, radius=radius)\n\n        self.efield = _data\n        self.radius = _rad\n        self.times  = None\n\n        self._verifySettingsPrescribedInitialData()",
  "def setPrescribedData(self, efield, radius=0, times=0):\n        \"\"\"\n        When ``TYPE_PRESCRIBED``, sets the spatiotemporal evolution of the\n        electric field during the simulation. The parameter ``efield`` may be\n        either a scalar (in which case the electric field is taken to be\n        constant and uniform in time and radius) or a 2D array of shape\n        (nt, nr). The associated time grid ``times`` must be of size ``nt`` and\n        the radial grid must be of size ``nr``.\n\n        :param efield: Prescribed electric field.\n        :param radius: Radial grid on which the electric field is prescribed.\n        :param times:  Time grid on which the electric field is prescribed.\n        \"\"\"\n        _data, _rad, _tim = self._setPrescribedData(efield, radius, times)\n        self.efield = _data\n        self.radius = _rad\n        self.times  = _tim\n\n        self._verifySettingsPrescribedData()",
  "def setBoundaryCondition(self, bctype = BC_TYPE_SELFCONSISTENT, V_loop_wall_R0=None,\n                             times=0, inverse_wall_time=None, R0=0):\n        r\"\"\"\n        Specifies the boundary condition to use when solving for the electric\n        field self-consistently, i.e. with ``TYPE_SELFCONSISTENT``. Possible\n        boundary condition types are:\n\n        +------------------------+------------------------------------------------------------------------------------------+\n        | Name                   | Description                                                                              |\n        +========================+==========================================================================================+\n        | BC_TYPE_PRESCRIBED     | Set :math:`V_{\\rm loop}` on the tokamak wall.                                            |\n        +------------------------+------------------------------------------------------------------------------------------+\n        | BC_TYPE_SELFCONSISTENT | Specify the tokamak wall time and solve self-consistently for :math:`V_{\\rm loop,wall}`. |\n        +------------------------+------------------------------------------------------------------------------------------+\n        | BC_TYPE_TRANSFORMER    | Same as ``BC_TYPE_SELFCONSISTENT``, but with prescribed loop voltage via transformer.    |\n        +------------------------+------------------------------------------------------------------------------------------+\n\n        :param int bctype:        Type of boundary condition to use (see table above for available options).\n        :param V_loop_wall_R0:    Prescribed value of :math:`V_{\\rm loop}/R_0` on the tokamak wall (or at transformer in case of ``type=BC_TYPE_TRANSFORMER``), normalized to the tokamak major radius :math:`R_0`.\n        :param times:             Time grid on which ``V_loop_wall_R0`` is given.\n        :param inverse_wall_time: Inverse wall time for the tokamak, used when solving for :math:`V_{\\rm loop,wall}` self-consistently.\n        :param R0:                Major radius for the tokamak, only used when solving for :math:`V_{\\rm loop,wall}` self-consistently (independent of radial-grid major radius).\n        \"\"\"\n        if bctype == BC_TYPE_PRESCRIBED:\n            self.bctype = bctype\n\n            # Ensure correct format\n            _data, _tim = self._setScalarData(data=V_loop_wall_R0, times=times)\n            self.V_loop_wall_R0 = _data\n            self.V_loop_wall_t = _tim\n        elif bctype == BC_TYPE_SELFCONSISTENT:\n            self.bctype = bctype\n            self.inverse_wall_time = inverse_wall_time\n            self.R0 = R0\n        elif bctype == BC_TYPE_TRANSFORMER:\n            self.bctype = bctype\n            self.inverse_wall_time = inverse_wall_time\n            self.R0 = R0\n\n            # Ensure correct format\n            _data, _tim = self._setScalarData(data=V_loop_wall_R0, times=times)\n            self.V_loop_wall_R0 = _data\n            self.V_loop_wall_t = _tim\n        else:\n            raise EquationException(\"E_field: Unrecognized boundary condition type: {}\".format(bctype))",
  "def setType(self, ttype):\n        r\"\"\"\n        Set the type of equation to use for evolving the electric field. The\n        available types are\n\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | Name                          | Description                                                                                  |\n        +===============================+==============================================================================================+\n        | TYPE_PRESCRIBED               | Prescribe spatiotemporal evolution of electric field.                                        |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | TYPE_SELFCONSISTENT           | Evolve electric field consistent with the evolution of the poloidal flux and plasma current. |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n        | TYPE_PRESCRIBED_OHMIC_CURRENT | Evolve electric field consistent with the evolution of the poloidal flux and plasma current. |\n        +-------------------------------+----------------------------------------------------------------------------------------------+\n\n        :param int ttype: Type of electric field evolution to use.\n        \"\"\"\n        if ttype in [TYPE_PRESCRIBED, TYPE_PRESCRIBED_OHMIC_CURRENT]:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n\n            if self.efield is not None:\n                self.efield = None\n                self.radius = None\n                self.times = None\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(ttype))",
  "def fromdict(self, data):\n        \"\"\"\n        Sets this paramater from settings provided in a dictionary.\n        \"\"\"\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.efield = data['data']['x']\n            self.radius = data['data']['r']\n            self.times  = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            self.bctype = data['bc']['type']\n\n            if 'init' in data:\n                self.efield = data['init']['x']\n                self.radius = data['init']['r']\n\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                self.V_loop_wall_R0   = data['bc']['V_loop_wall']['x']\n                self.V_loop_wall_t = data['bc']['V_loop_wall']['t']\n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                self.inverse_wall_time = data['bc']['inverse_wall_time']\n                if not np.isscalar(self.inverse_wall_time):\n                    self.inverse_wall_time = float(self.inverse_wall_time[0])\n                if 'R0' in data['bc']:\n                    self.R0 = float(data['bc']['R0'])\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                self.inverse_wall_time = data['bc']['inverse_wall_time']\n                if not np.isscalar(self.inverse_wall_time):\n                    self.inverse_wall_time = float(self.inverse_wall_time[0])\n                if 'R0' in data['bc']:\n                    self.R0 = float(data['bc']['R0'])\n\n                self.V_loop_wall_R0 = data['bc']['V_loop_wall']['x']\n                self.V_loop_wall_t  = data['bc']['V_loop_wall']['t']\n            else:\n                raise EquationException(\"E_field: Unrecognized boundary condition type: {}\".format(self.bctype))\n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(self.type))\n\n        self.verifySettings()",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n        data['bc'] = {'type' : self.bctype}\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.efield,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            # The initial condition can either be given\n            # in terms of the electric field or in terms\n            # of the current density...\n            if self.efield is not None:\n                data['init'] = {\n                    'x': self.efield,\n                    'r': self.radius,\n                }            \n\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                data['bc']['V_loop_wall'] = {\n                        'x': self.V_loop_wall_R0,\n                        't': self.V_loop_wall_t\n                }                \n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                data['bc']['inverse_wall_time'] = self.inverse_wall_time\n                data['bc']['R0'] = self.R0\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                data['bc']['inverse_wall_time'] = self.inverse_wall_time\n                data['bc']['R0'] = self.R0\n                data['bc']['V_loop_wall'] = {\n                        'x': self.V_loop_wall_R0,\n                        't': self.V_loop_wall_t\n                }                \n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized electric field type: {}\".format(self.type))\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.efield) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no electric field data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"E_field: Electric field prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self._verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            if self.efield is not None:\n                if type(self.efield) != np.ndarray:\n                    raise EquationException(\"E_field: Electric field prescribed, but no electric field data provided.\")\n                elif type(self.radius) != np.ndarray:\n                    raise EquationException(\"E_field: Electric field prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            # Check boundary condition\n            if self.bctype == BC_TYPE_PRESCRIBED:\n                self._verifySettingsPrescribedScalarData()\n            elif self.bctype == BC_TYPE_SELFCONSISTENT:\n                if not np.isscalar(self.inverse_wall_time):\n                    raise EquationException(\"E_field: The specified inverse wall time is not a scalar: {}\".format(self.inverse_wall_time))\n                if not np.isscalar(self.R0) and not self.R0<0:\n                    raise EquationException(\"E_field: The specified major radius must be scalar and non-negative: R0 = {}\".format(self.R0))\n            elif self.bctype == BC_TYPE_TRANSFORMER:\n                self._verifySettingsPrescribedScalarData()\n                if not np.isscalar(self.inverse_wall_time):\n                    raise EquationException(\"E_field: The specified inverse wall time is not a scalar: {}\".format(self.inverse_wall_time))\n                if not np.isscalar(self.R0) and not self.R0<0:\n                    raise EquationException(\"E_field: The specified major radius must be scalar and non-negative: R0 = {}\".format(self.R0))\n            else:\n                raise EquationException(\"E_field: Unrecognized boundary condition type: {}.\".format(self.bctype))\n\n            if self.efield is not None:\n                self._verifySettingsPrescribedInitialData()\n        elif self.type == TYPE_PRESCRIBED_OHMIC_CURRENT:\n            pass\n        else:\n            raise EquationException(\"E_field: Unrecognized equation type specified: {}.\".format(self.type))",
  "def _verifySettingsPrescribedData(self):\n        super()._verifySettingsPrescribedData('E_field', data=self.efield, radius=self.radius, times=self.times)",
  "def _verifySettingsPrescribedInitialData(self):\n        super()._verifySettingsPrescribedInitialData('E_field', data=self.efield, radius=self.radius)",
  "def _verifySettingsPrescribedScalarData(self):\n        super()._verifySettingsPrescribedScalarData('E_field', data=self.V_loop_wall_R0, times=self.V_loop_wall_t)",
  "class RunawayElectrons(UnknownQuantity,PrescribedInitialParameter):\n\n    def __init__(self, settings, density=0, radius=0, avalanche=AVALANCHE_MODE_NEGLECT, dreicer=DREICER_RATE_DISABLED, compton=COMPTON_MODE_NEGLECT, Eceff=COLLQTY_ECEFF_MODE_FULL, pCutAvalanche=0, comptonPhotonFlux=0, tritium=False, hottail=HOTTAIL_MODE_DISABLED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.avalanche = avalanche\n        self.dreicer   = dreicer\n        self.compton   = compton\n        self.comptonPhotonFlux = comptonPhotonFlux\n        self.Eceff     = Eceff\n        self.pCutAvalanche = pCutAvalanche\n        self.tritium   = tritium\n        self.hottail   = hottail\n        self.negative_re = False\n\n        self.advectionInterpolation = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)\n        self.transport = TransportSettings(kinetic=False)\n\n        self.density = None\n        self.radius  = None\n        self.setInitialProfile(density=density, radius=radius)\n\n\n    def setInitialProfile(self, density, radius=0):\n        _data, _rad = self._setInitialData(data=density, radius=radius)\n\n        self.density = _data\n        self.radius  = _rad\n        self.verifySettingsPrescribedInitialData()\n\n\n    def setAvalanche(self, avalanche, pCutAvalanche=0):\n        \"\"\"\n        Enables/disables avalanche generation.\n        \"\"\"\n        if avalanche == False:\n            self.avalanche = AVALANCHE_MODE_NEGLECT\n        else:\n            self.avalanche = int(avalanche)\n            self.pCutAvalanche = pCutAvalanche\n\n\n    def setDreicer(self, dreicer):\n        \"\"\"\n        Specifies which model to use for calculating the\n        Dreicer runaway rate.\n        \"\"\"\n        if dreicer == False:\n            self.dreicer = DREICER_RATE_DISABLED\n        else:\n            self.dreicer = int(dreicer)\n\n\n    def setCompton(self, compton, photonFlux = None):\n        \"\"\"\n        Specifies which model to use for calculating the\n        compton runaway rate.\n        \"\"\"\n        if compton == False or compton == COMPTON_MODE_NEGLECT:\n            self.compton = COMPTON_MODE_NEGLECT\n        else:\n            if compton == COMPTON_RATE_ITER_DMS:\n                # set fluid compton source and standard ITER flux of 1e18\n                compton = COMPTON_MODE_FLUID\n                if photonFlux is None:\n                    photonFlux = ITER_PHOTON_FLUX_DENSITY\n            \n            if photonFlux is None:\n                raise EquationException(\"n_re: Compton photon flux must be set.\")\n\n            self.compton = int(compton)\n            self.comptonPhotonFlux = photonFlux\n\n\n    def setEceff(self, Eceff):\n        \"\"\"\n        Specifies which model to use for calculating the\n        effective critical field (used in the avalanche formula).\n        \"\"\"\n        self.Eceff = int(Eceff)\n\n\n    def setTritium(self, tritium):\n        \"\"\"\n        Specifices whether or not to include runaway generation\n        through tritium decay as a source term.\n        \"\"\"\n        self.tritium = tritium\n\n\n    def setHottail(self, hottail):\n        \"\"\"\n        Specify which model to use for hottail runaway generation\n        \"\"\"\n        if hottail == False:\n            self.hottail = HOTTAIL_MODE_DISABLED\n        else:\n            self.hottail = hottail\n            if hottail != HOTTAIL_MODE_DISABLED:\n                self.settings.eqsys.f_hot.enableAnalyticalDistribution()\n\n\n    def setNegativeRunaways(self, negative_re=True):\n        \"\"\"\n        Introduce a density of runaway electrons with negative pitch,\n        allowing the kinetic avalanche source term to properly account for\n        large-angle collisions with runaways moving in different directions.\n        \"\"\"\n        self.negative_re = negative_re\n\n\n    def setAdvectionInterpolationMethod(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolation.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        self.avalanche = int(data['avalanche'])\n\n        if 'pCutAvalanche' in data:\n            self.pCutAvalanche = data['pCutAvalanche']\n\n        self.dreicer   = int(data['dreicer'])\n        self.Eceff     = int(data['Eceff'])\n        self.compton            = int(data['compton']['mode'])\n        self.comptonPhotonFlux  = data['compton']['flux']\n        self.density   = data['init']['x']\n        self.radius    = data['init']['r']\n\n        if 'adv_interp' in data:\n            self.advectionInterpolation.fromdict(data['adv_interp'])\n\n        if 'hottail' in data:\n            self.hottail = int(data['hottail'])\n\n        if 'tritium' in data:\n            self.tritium = bool(data['tritium'])\n\n        if 'negative_re' in data:\n            self.negative_re = bool(data['negative_re'])\n\n        if 'transport' in data:\n            self.transport.fromdict(data['transport'])\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this RunawayElectrons object.\n        \"\"\"\n        data = {\n            'avalanche': self.avalanche,\n            'dreicer': self.dreicer,\n            'Eceff': self.Eceff,\n            'pCutAvalanche': self.pCutAvalanche,\n            'transport': self.transport.todict(),\n            'tritium': self.tritium,\n            'hottail': self.hottail,\n            'negative_re': self.negative_re\n        }\n        data['compton'] = {\n            'mode': self.compton,\n            'flux': self.comptonPhotonFlux\n        }\n        data['init'] = {\n            'x': self.density,\n            'r': self.radius\n        }\n\n        # Flux limiter settings\n        data['adv_interp'] = self.advectionInterpolation.todict()\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if type(self.avalanche) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'avalanche'. Expected integer.\")\n        if type(self.dreicer) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'dreicer'. Expected integer.\")\n        if type(self.compton) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'compton'. Expected integer.\")\n        if type(self.hottail) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'hottail'. Expected integer.\")\n        if type(self.Eceff) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'Eceff'. Expected integer.\")\n        if self.avalanche == AVALANCHE_MODE_KINETIC and self.pCutAvalanche == 0:\n            raise EquationException(\"n_re: Invalid value assigned to 'pCutAvalanche'. Must be set explicitly when using KINETIC avalanche.\")\n        if type(self.tritium) != bool:\n            raise EquationException(\"n_re: Invalid value assigned to 'tritium'. Expected bool.\")\n        if self.hottail != HOTTAIL_MODE_DISABLED and self.settings.eqsys.f_hot.mode == DISTRIBUTION_MODE_NUMERICAL:\n            raise EquationException(\"n_re: Invalid setting combination: when hottail is enabled, the 'mode' of f_hot cannot be NUMERICAL. Enable ANALYTICAL f_hot distribution or disable hottail.\")\n        if type(self.negative_re) != bool:\n            raise EquationException(\"n_re: Invalid value assigned to 'negative_re'. Expected bool.\")\n\n        self.advectionInterpolation.verifySettings()\n        self.transport.verifySettings()\n\n\n    def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('n_re', data=self.density, radius=self.radius)",
  "def __init__(self, settings, density=0, radius=0, avalanche=AVALANCHE_MODE_NEGLECT, dreicer=DREICER_RATE_DISABLED, compton=COMPTON_MODE_NEGLECT, Eceff=COLLQTY_ECEFF_MODE_FULL, pCutAvalanche=0, comptonPhotonFlux=0, tritium=False, hottail=HOTTAIL_MODE_DISABLED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.avalanche = avalanche\n        self.dreicer   = dreicer\n        self.compton   = compton\n        self.comptonPhotonFlux = comptonPhotonFlux\n        self.Eceff     = Eceff\n        self.pCutAvalanche = pCutAvalanche\n        self.tritium   = tritium\n        self.hottail   = hottail\n        self.negative_re = False\n\n        self.advectionInterpolation = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)\n        self.transport = TransportSettings(kinetic=False)\n\n        self.density = None\n        self.radius  = None\n        self.setInitialProfile(density=density, radius=radius)",
  "def setInitialProfile(self, density, radius=0):\n        _data, _rad = self._setInitialData(data=density, radius=radius)\n\n        self.density = _data\n        self.radius  = _rad\n        self.verifySettingsPrescribedInitialData()",
  "def setAvalanche(self, avalanche, pCutAvalanche=0):\n        \"\"\"\n        Enables/disables avalanche generation.\n        \"\"\"\n        if avalanche == False:\n            self.avalanche = AVALANCHE_MODE_NEGLECT\n        else:\n            self.avalanche = int(avalanche)\n            self.pCutAvalanche = pCutAvalanche",
  "def setDreicer(self, dreicer):\n        \"\"\"\n        Specifies which model to use for calculating the\n        Dreicer runaway rate.\n        \"\"\"\n        if dreicer == False:\n            self.dreicer = DREICER_RATE_DISABLED\n        else:\n            self.dreicer = int(dreicer)",
  "def setCompton(self, compton, photonFlux = None):\n        \"\"\"\n        Specifies which model to use for calculating the\n        compton runaway rate.\n        \"\"\"\n        if compton == False or compton == COMPTON_MODE_NEGLECT:\n            self.compton = COMPTON_MODE_NEGLECT\n        else:\n            if compton == COMPTON_RATE_ITER_DMS:\n                # set fluid compton source and standard ITER flux of 1e18\n                compton = COMPTON_MODE_FLUID\n                if photonFlux is None:\n                    photonFlux = ITER_PHOTON_FLUX_DENSITY\n            \n            if photonFlux is None:\n                raise EquationException(\"n_re: Compton photon flux must be set.\")\n\n            self.compton = int(compton)\n            self.comptonPhotonFlux = photonFlux",
  "def setEceff(self, Eceff):\n        \"\"\"\n        Specifies which model to use for calculating the\n        effective critical field (used in the avalanche formula).\n        \"\"\"\n        self.Eceff = int(Eceff)",
  "def setTritium(self, tritium):\n        \"\"\"\n        Specifices whether or not to include runaway generation\n        through tritium decay as a source term.\n        \"\"\"\n        self.tritium = tritium",
  "def setHottail(self, hottail):\n        \"\"\"\n        Specify which model to use for hottail runaway generation\n        \"\"\"\n        if hottail == False:\n            self.hottail = HOTTAIL_MODE_DISABLED\n        else:\n            self.hottail = hottail\n            if hottail != HOTTAIL_MODE_DISABLED:\n                self.settings.eqsys.f_hot.enableAnalyticalDistribution()",
  "def setNegativeRunaways(self, negative_re=True):\n        \"\"\"\n        Introduce a density of runaway electrons with negative pitch,\n        allowing the kinetic avalanche source term to properly account for\n        large-angle collisions with runaways moving in different directions.\n        \"\"\"\n        self.negative_re = negative_re",
  "def setAdvectionInterpolationMethod(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolation.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        self.avalanche = int(data['avalanche'])\n\n        if 'pCutAvalanche' in data:\n            self.pCutAvalanche = data['pCutAvalanche']\n\n        self.dreicer   = int(data['dreicer'])\n        self.Eceff     = int(data['Eceff'])\n        self.compton            = int(data['compton']['mode'])\n        self.comptonPhotonFlux  = data['compton']['flux']\n        self.density   = data['init']['x']\n        self.radius    = data['init']['r']\n\n        if 'adv_interp' in data:\n            self.advectionInterpolation.fromdict(data['adv_interp'])\n\n        if 'hottail' in data:\n            self.hottail = int(data['hottail'])\n\n        if 'tritium' in data:\n            self.tritium = bool(data['tritium'])\n\n        if 'negative_re' in data:\n            self.negative_re = bool(data['negative_re'])\n\n        if 'transport' in data:\n            self.transport.fromdict(data['transport'])",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this RunawayElectrons object.\n        \"\"\"\n        data = {\n            'avalanche': self.avalanche,\n            'dreicer': self.dreicer,\n            'Eceff': self.Eceff,\n            'pCutAvalanche': self.pCutAvalanche,\n            'transport': self.transport.todict(),\n            'tritium': self.tritium,\n            'hottail': self.hottail,\n            'negative_re': self.negative_re\n        }\n        data['compton'] = {\n            'mode': self.compton,\n            'flux': self.comptonPhotonFlux\n        }\n        data['init'] = {\n            'x': self.density,\n            'r': self.radius\n        }\n\n        # Flux limiter settings\n        data['adv_interp'] = self.advectionInterpolation.todict()\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if type(self.avalanche) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'avalanche'. Expected integer.\")\n        if type(self.dreicer) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'dreicer'. Expected integer.\")\n        if type(self.compton) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'compton'. Expected integer.\")\n        if type(self.hottail) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'hottail'. Expected integer.\")\n        if type(self.Eceff) != int:\n            raise EquationException(\"n_re: Invalid value assigned to 'Eceff'. Expected integer.\")\n        if self.avalanche == AVALANCHE_MODE_KINETIC and self.pCutAvalanche == 0:\n            raise EquationException(\"n_re: Invalid value assigned to 'pCutAvalanche'. Must be set explicitly when using KINETIC avalanche.\")\n        if type(self.tritium) != bool:\n            raise EquationException(\"n_re: Invalid value assigned to 'tritium'. Expected bool.\")\n        if self.hottail != HOTTAIL_MODE_DISABLED and self.settings.eqsys.f_hot.mode == DISTRIBUTION_MODE_NUMERICAL:\n            raise EquationException(\"n_re: Invalid setting combination: when hottail is enabled, the 'mode' of f_hot cannot be NUMERICAL. Enable ANALYTICAL f_hot distribution or disable hottail.\")\n        if type(self.negative_re) != bool:\n            raise EquationException(\"n_re: Invalid value assigned to 'negative_re'. Expected bool.\")\n\n        self.advectionInterpolation.verifySettings()\n        self.transport.verifySettings()",
  "def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('n_re', data=self.density, radius=self.radius)",
  "class Ions(UnknownQuantity):\n    \n\n    def __init__(self, settings, ionization=IONIZATION_MODE_FLUID):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.ions = list()\n        self.r    = None\n        self.t    = None\n        \n        self.rChargedPrescribedDiffusion = None\n        self.rNeutralPrescribedDiffusion = None\n        self.tChargedPrescribedDiffusion = None\n        self.tNeutralPrescribedDiffusion = None\n        \n        self.rChargedPrescribedAdvection = None\n        self.rNeutralPrescribedAdvection = None\n        self.tChargedPrescribedAdvection = None\n        self.tNeutralPrescribedAdvection = None\n        self.tSourceTerm                 = None\n\n        self.ionization = ionization\n        self.typeTi = IONS_T_I_NEGLECT\n        \n        self.advectionInterpolationCharged = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)\n        self.advectionInterpolationNeutral = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)\n\n\n    def addIon(self, name, Z, iontype=IONS_PRESCRIBED, Z0=None, isotope=0, SPIMolarFraction=-1, opacity_mode=ION_OPACITY_MODE_TRANSPARENT, \n        charged_diffusion_mode=ION_CHARGED_DIFFUSION_MODE_NONE, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None,\n        neutral_diffusion_mode=ION_NEUTRAL_DIFFUSION_MODE_NONE, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None,\n        charged_advection_mode=ION_CHARGED_ADVECTION_MODE_NONE, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None,\n        neutral_advection_mode=ION_NEUTRAL_ADVECTION_MODE_NONE, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None,\n        t_transp_expdecay_all_cs = None, t_transp_start_expdecay_all_cs = 0, diffusion_initial_all_cs = None, diffusion_final_all_cs = 0, advection_initial_all_cs = None, advection_final_all_cs = 0, r_expdecay_all_cs = None, t_expdecay_all_cs = None, \n        T=None, n=None, r=None, t=None, tritium=False, hydrogen=False):\n\n        \"\"\"\n        Adds a new ion species to the plasma.\n\n        :param str name:        Name by which the ion species will be referred to.\n        :param int Z:           Ion charge number.\n        :param int isotope:            Ion mass number.\n        :param int iontype:     Method to use for evolving ions in time.\n        :param int Z0:          Charge state to populate (used for populating exactly one charge state for the ion).\n        :param n:               Ion density (can be either a scalar, 1D array or 2D array, depending on the other input parameters)\n        :param float SPIMolarFraction: Molar fraction of the SPI injection (if any). A negative value means that this species is not part of the SPI injection \n        :param numpy.ndarray r: Radial grid on which the input density is defined.\n        :param T:               Ion initial temperature (can be scalar for uniform temperature, otherwise 1D array matching `r` in size)\n        :param numpy.ndarray r: Radial grid on which the input density and temperature is defined.\n        :param numpy.ndarray t: Time grid on which the input density is defined.\n        :param bool tritium:    If ``True``, the ion species is treated as Tritium.\n        :param bool hydrogen:   If ``True``, the ion species is treated as Hydrogen (single proton).\n        \"\"\"\n        if (self.r is not None) and (r is not None) and (np.any(self.r[:] != r[:])):\n            if self.r.size == 1:\n                self.changeRadialGrid(r)\n            else:\n                raise EquationException(\"The radial grid must be the same for all ion species.\")\n        if (self.t is not None) and (t is not None) and (np.any(self.t != t)):\n            raise EquationException(\"The time grid must be the same for all ion species.\")\n            \n        if (self.rChargedPrescribedDiffusion is not None) and (rChargedPrescribedDiffusion is not None) and (np.any(self.rChargedPrescribedDiffusion != rChargedPrescribedDiffusion)):\n            raise EquationException(\"The radial grid for the prescribed charged diffusion must be the same for all ion species.\")\n        if (self.tChargedPrescribedDiffusion is not None) and (tChargedPrescribedDiffusion is not None) and (np.any(self.tChargedPrescribedDiffusion != tChargedPrescribedDiffusion)):\n            raise EquationException(\"The time grid for the prescribed charged diffusion must be the same for all ion species.\")\n            \n        if (self.rNeutralPrescribedDiffusion is not None) and (rNeutralPrescribedDiffusion is not None) and (np.any(self.rNeutralPrescribedDiffusion != rNeutralPrescribedDiffusion)):\n            raise EquationException(\"The radial grid for the prescribed neutral diffusion must be the same for all ion species.\")\n        if (self.tNeutralPrescribedDiffusion is not None) and (tNeutralPrescribedDiffusion is not None) and (np.any(self.tNeutralPrescribedDiffusion != tNeutralPrescribedDiffusion)):\n            raise EquationException(\"The time grid for the prescribed neutral diffusion must be the same for all ion species.\")\n\n        if T is not None:\n            self.typeTi = IONS_T_I_INCLUDE\n\n        ion = IonSpecies(settings=self.settings, name=name, Z=Z, ttype=iontype, Z0=Z0, isotope=isotope, SPIMolarFraction=SPIMolarFraction, opacity_mode=opacity_mode, \n            charged_diffusion_mode=charged_diffusion_mode, charged_prescribed_diffusion=charged_prescribed_diffusion, rChargedPrescribedDiffusion=rChargedPrescribedDiffusion, tChargedPrescribedDiffusion=tChargedPrescribedDiffusion,\n            neutral_diffusion_mode=neutral_diffusion_mode, neutral_prescribed_diffusion=neutral_prescribed_diffusion, rNeutralPrescribedDiffusion=rNeutralPrescribedDiffusion, tNeutralPrescribedDiffusion=tNeutralPrescribedDiffusion,           \n            charged_advection_mode=charged_advection_mode, charged_prescribed_advection=charged_prescribed_advection, rChargedPrescribedAdvection=rChargedPrescribedAdvection, tChargedPrescribedAdvection=tChargedPrescribedAdvection,\n            neutral_advection_mode=neutral_advection_mode, neutral_prescribed_advection=neutral_prescribed_advection, rNeutralPrescribedAdvection=rNeutralPrescribedAdvection, tNeutralPrescribedAdvection=tNeutralPrescribedAdvection,\n            t_transp_expdecay_all_cs = t_transp_expdecay_all_cs, t_transp_start_expdecay_all_cs = t_transp_start_expdecay_all_cs,\n            diffusion_initial_all_cs = diffusion_initial_all_cs, diffusion_final_all_cs = diffusion_final_all_cs, \n            advection_initial_all_cs = advection_initial_all_cs, advection_final_all_cs = advection_final_all_cs, \n            r_expdecay_all_cs = r_expdecay_all_cs, t_expdecay_all_cs = t_expdecay_all_cs,            \n            T=T, n=n, r=r, t=t, interpr=self.r, interpt=None, tritium=tritium, hydrogen=hydrogen)\n\n        self.ions.append(ion)\n\n        self.r = ion.getR()\n        if ion.getTime() is not None:\n            self.t = ion.getTime()\n            \n        if charged_diffusion_mode==ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n            self.rChargedPrescribedDiffusion = ion.getRChargedPrescribedDiffusion()\n            self.tChargedPrescribedDiffusion = ion.getTChargedPrescribedDiffusion()\n            \n        if neutral_diffusion_mode==ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n            self.rNeutralPrescribedDiffusion = ion.getRNeutralPrescribedDiffusion()\n            self.tNeutralPrescribedDiffusion = ion.getTNeutralPrescribedDiffusion()\n            \n        if charged_advection_mode==ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n            self.rChargedPrescribedAdvection = ion.getRChargedPrescribedAdvection()\n            self.tChargedPrescribedAdvection = ion.getTChargedPrescribedAdvection()\n            \n        if neutral_advection_mode==ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n            self.rNeutralPrescribedAdvection = ion.getRNeutralPrescribedAdvection()\n            self.tNeutralPrescribedAdvection = ion.getTNeutralPrescribedAdvection()\n\n\n    def addIonSource(self, species, dNdt=None, t=None, Z0=0):\n        \"\"\"\n        Add a source term for the specified ion species.\n\n        :param species: Name of the ion species to add this source term to.\n        :param dNdt:    Number of particles to add per unit time.\n        :param t:       Time grid associated with ``dNdt`` (if any).\n        :param Z0:      For scalar or 1D ``dNdt``, the charge state for which to add the source term.\n        \"\"\"\n        if t is None:\n            t = self.tSourceTerm\n        elif self.tSourceTerm is not None and not np.all(t == self.tSourceTerm):\n            raise EquationException(f\"The time grid used for ion sources must be the same for all ion species.\")\n            \n        found = False\n        for ion in self.ions:\n            if ion.name == species:\n                ion.initialize_source(n=dNdt, t=t, Z0=Z0)\n                found = True\n\n                self.tSourceTerm = ion.getSourceTime()\n\n        if not found:\n            raise EquationException(f\"No ion species with name '{species}' has been added to the simulation. Unable to add source term.\")\n\n\n    def changeRadialGrid(self, r):\n        \"\"\"\n        Change the radial grid used for the ion species.\n        \"\"\"\n        for ion in self.ions:\n            if ion.r.size == 1:\n                ion.n = ion.n * np.ones(ion.n.shape[:-1] + (r.size,))\n                ion.T = ion.T * np.ones(ion.T.shape[:-1] + (r.size,))\n                ion.r = r\n            else:\n                fn = scipy.interpolate.interp1d(ion.r, ion.n, axis=-1, bounds_error=False, fill_value='extrapolate')\n                fT = scipy.interpolate.interp1d(ion.r, ion.n, axis=-1, bounds_error=False, fill_value='extrapolate')\n                ion.n = fn(r)\n                ion.T = fT(r)\n                ion.r = r\n\n        self.r = r\n\n\n    def getCharges(self):\n        \"\"\"\n        Returns a list of the charges of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getZ() for ion in self.ions]\n\n\n    def getIsotopes(self):\n        \"\"\"\n        Returns a list of the isotopes of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getIsotope() for ion in self.ions]\n\n\n    def getSPIMolarFraction(self):\n        \"\"\"\n        Returns a list of the SPI molar fractions of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getSPIMolarFraction() for ion in self.ions]\n\n\n    def getIndex(self, species):\n        \"\"\"\n        Return the index of the ion species with the specified name.\n        \"\"\"\n        for iIon in range(len(self.ions)):\n            if self.ions[iIon].getName() == species:\n                return iIon\n\n        raise EquationException(f\"No species with name '{species}'.\")\n\n\n    def getIon(self, i=None):\n        \"\"\"\n        Returns the ion species with the specified index or name.\n\n        :param i: Index or name of ion species to retrieve.\n        \"\"\"\n        if type(i) == int: return self.ions[i]\n        elif type(i) == str:\n            for j in range(0, len(self.ions)):\n                if self.ions[j].getName() == i:\n                    return self.ions[j]\n\n            raise EquationException(\"No ion with name '{}' has been defined.\".format(i))\n        else:\n            raise EquationException(\"Invalid call to 'getIon()'.\")\n\n\n    def setIonization(self, ionization=IONIZATION_MODE_FLUID):\n        \"\"\"\n        Sets which model to use for ionization.\n\n        :param int ionization: Flag indicating which model to use for ionization.\n        \"\"\"\n        self.ionization=ionization\n\n\n    def getHydrogenSpecies(self):\n        \"\"\"\n        Returns a list of names of the ion species which are treated\n        as Hydrogen.\n        \"\"\"\n        hydr = []\n        for ion in self.ions:\n            if ion.hydrogen:\n                hydr.append(ion.getName())\n\n        return hydr\n\n\n    def getTritiumSpecies(self):\n        \"\"\"\n        Returns a list of names of the ion species which are treated\n        as Tritium.\n        \"\"\"\n        trit = []\n        for ion in self.ions:\n            if ion.tritium:\n                trit.append(ion.getName())\n\n        return trit\n\n\n    def getTypes(self):\n        \"\"\"\n        Returns a list of ion types for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getType() for ion in self.ions]\n        \n    def getOpacityModes(self):\n        \"\"\"\n        Returns a list of ion opacity modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getOpacityMode() for ion in self.ions]\n        \n    def getChargedDiffusionModes(self):\n        \"\"\"\n        Returns a list of ion charged diffusion modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getChargedDiffusionMode() for ion in self.ions]\n        \n    def getNeutralDiffusionModes(self):\n        \"\"\"\n        Returns a list of ion neutral diffusion modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getNeutralDiffusionMode() for ion in self.ions]\n        \n    def getChargedAdvectionModes(self):\n        \"\"\"\n        Returns a list of ion charged advection modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getChargedAdvectionMode() for ion in self.ions]\n        \n    def getNeutralAdvectionModes(self):\n        \"\"\"\n        Returns a list of ion neutral advection modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getNeutralAdvectionMode() for ion in self.ions]\n        \n    def setAdvectionInterpolationMethodCharged(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the charged advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolationCharged.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)\n        \n    def setAdvectionInterpolationMethodNeutral(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the neutral advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolationNeutral.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)\n\n\n    def setIonType(self, index, ttype):\n        \"\"\"\n        Modifies the type of equation used for the specified ion species.\n\n        :param index: Index or name of ion species to set type for.\n        :param int ttype: Type of equation to use for evolving the ion species.\n        \"\"\"\n        ion = self.getIon(index)\n\n        # Note that the DREAM kernel only uses positive type indices.\n        # The negative type indices are interface extensions which can\n        # only be used with the 'initialize()' methods.\n        if ttype <= 0:\n            raise DREAMException(\"Trying to set invalid ion type for ion species '{}': {}.\".format(ion.name, ttype))\n\n        ion.ttype = ttype\n    \n\n    def fromdict(self, data):\n        \"\"\"\n        Load settings from the specified dictionary.\n        \n        :param dict data: Dictionary containing all settings to load.\n        \"\"\"\n        names        = data['names'].split(';')[:-1]\n        Z            = data['Z']\n\n        if 'isotopes' in data and len(data['isotopes']) == len(Z):\n            isotopes = data['isotopes']\n        else:\n            isotopes = [0]*len(Z)\n\n        if 'types' in data and len(data['types']) == len(Z):\n            types = data['types']\n        else:\n            types = [0]*len(Z)\n\n        if 'opacity_modes' in data and len(data['opacity_modes']) == len(Z):\n            opacity_modes = data['opacity_modes']\n        else:\n            opacity_modes = self.getOpacityModes()\n\n        charged_diffusion_modes = [ION_CHARGED_DIFFUSION_MODE_NONE]*len(Z)\n        neutral_diffusion_modes = [ION_NEUTRAL_DIFFUSION_MODE_NONE]*len(Z)\n        charged_advection_modes = [ION_CHARGED_ADVECTION_MODE_NONE]*len(Z)\n        neutral_advection_modes = [ION_NEUTRAL_ADVECTION_MODE_NONE]*len(Z)\n\n        if 'charged_diffusion_modes' in data:\n            charged_diffusion_modes = data['charged_diffusion_modes']\n        if 'neutral_diffusion_modes' in data:\n            neutral_diffusion_modes = data['neutral_diffusion_modes']\n        if 'charged_advection_modes' in data:\n            charged_advection_modes = data['charged_advection_modes']\n        if 'neutral_advection_modes' in data:\n            neutral_advection_modes = data['neutral_advection_modes']\n\n        SPIMolarFraction = data['SPIMolarFraction']\n        nZSPI = len(Z)-np.sum(SPIMolarFraction<0)\n        if nZSPI>0:\n            nShard = int(np.sum(SPIMolarFraction>=0)/nZSPI)\n        else:\n            nShard = 0\n\n        if 'tritiumnames' in data:\n            tritiumnames = data['tritiumnames'].split(';')[:-1]\n        else:\n            tritiumnames = []\n\n        if 'hydrogennames' in data:\n            hydrogennames = data['hydrogennames'].split(';')[:-1]\n        else:\n            hydrogennames = []\n\n        initial    = None\n        prescribed = None\n        initialTi  = None\n        charged_prescribed_diffusion = None\n        neutral_prescribed_diffusion = None\n        charged_prescribed_advection = None\n        neutral_prescribed_advection = None\n        self.typeTi = IONS_T_I_NEGLECT\n        if 'typeTi' in data:\n            self.typeTi = int(data['typeTi'])\n        if 'initial' in data:\n            initial = data['initial']\n        if 'prescribed' in data:\n            prescribed = data['prescribed']\n        if 'charged_prescribed_diffusion' in data:\n            charged_prescribed_diffusion = data['charged_prescribed_diffusion']\n        if 'neutral_prescribed_diffusion' in data:\n            neutral_prescribed_diffusion = data['neutral_prescribed_diffusion']\n        if 'charged_prescribed_advection' in data:\n            charged_prescribed_advection = data['charged_prescribed_advection']\n        if 'neutral_prescribed_advection' in data:\n            neutral_prescribed_advection = data['neutral_prescribed_advection']\n        if 'adv_interp_charged' in data:\n            self.advectionInterpolationCharged.fromdict(data['adv_interp_charged'])\n        if 'adv_interp_neutral' in data:\n            self.advectionInterpolationNeutral.fromdict(data['adv_interp_neutral'])\n        if 'initialTi' in data:\n            initialTi = data['initialTi']\n        iidx, pidx, spiidx, cpdidx, npdidx, cpaidx, npaidx = 0, 0, 0, 0, 0, 0, 0\n        for i in range(len(Z)):\n            if types[i] == IONS_PRESCRIBED:\n                n = prescribed['x'][pidx:(pidx+Z[i]+1)]\n                r = prescribed['r']\n                t = prescribed['t']\n                pidx += Z[i]+1\n            else:\n                n = initial['x'][iidx:(iidx+Z[i]+1)]\n                r = initial['r']\n                t = None #initial['t']\n                iidx += Z[i]+1\n            if self.typeTi==IONS_T_I_INCLUDE and initialTi is not None:\n                T = initialTi['x'][i]\n            else: \n                T = None\n            if SPIMolarFraction[spiidx]>=0:\n                SPIMolarFractionSingleSpecies = SPIMolarFraction[spiidx:spiidx+nShard]\n                spiidx+=nShard\n            else:\n                SPIMolarFractionSingleSpecies = SPIMolarFraction[spiidx]\n                spiidx+=1\n            tritium = (names[i] in tritiumnames)\n            hydrogen = (names[i] in hydrogennames)\n            \n            if charged_diffusion_modes[i] == ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n                cpd = charged_prescribed_diffusion['x'][cpdidx:(cpdidx+Z[i])]\n                rcpd = charged_prescribed_diffusion['r']\n                tcpd = charged_prescribed_diffusion['t']\n                cpdidx += Z[i]\n            else:\n                cpd=None\n                rcpd=None\n                tcpd=None\n                \n            if neutral_diffusion_modes[i] == ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n                npd = neutral_prescribed_diffusion['x'][npdidx:(npdidx+1)]\n                rnpd = neutral_prescribed_diffusion['r']\n                tnpd = neutral_prescribed_diffusion['t']\n                npdidx += 1\n            else:\n                npd=None\n                rnpd=None\n                tnpd=None\n                \n            if charged_advection_modes[i] == ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n                cpa = charged_prescribed_advection['x'][cpaidx:(cpaidx+Z[i])]\n                rcpa = charged_prescribed_advection['r']\n                tcpa = charged_prescribed_advection['t']\n                cpaidx += Z[i]\n            else:\n                cpa=None\n                rcpa=None\n                tcpa=None\n                \n            if neutral_advection_modes[i] == ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n                npa = neutral_prescribed_advection['x'][npaidx:(npaidx+1)]\n                rnpa = neutral_prescribed_advection['r']\n                tnpa = neutral_prescribed_advection['t']\n                npaidx += 1\n            else:\n                npa=None\n                rnpa=None\n                tnpa=None\n\n            self.addIon(name=names[i], Z=Z[i], isotope=isotopes[i], SPIMolarFraction=SPIMolarFractionSingleSpecies, iontype=types[i], opacity_mode=opacity_modes[i], \n                charged_diffusion_mode=charged_diffusion_modes[i], charged_prescribed_diffusion = cpd, rChargedPrescribedDiffusion=rcpd, tChargedPrescribedDiffusion = tcpd,\n                neutral_diffusion_mode=neutral_diffusion_modes[i], neutral_prescribed_diffusion = npd, rNeutralPrescribedDiffusion=rnpd, tNeutralPrescribedDiffusion = tnpd,\n                charged_advection_mode=charged_advection_modes[i], charged_prescribed_advection = cpa, rChargedPrescribedAdvection=rcpa, tChargedPrescribedAdvection = tcpa,\n                neutral_advection_mode=neutral_advection_modes[i], neutral_prescribed_advection = npa, rNeutralPrescribedAdvection=rnpa, tNeutralPrescribedAdvection = tnpa,\n                T=T, n=n, r=r, t=t, tritium=tritium, hydrogen=hydrogen)\n\n        if 'ionization' in data:\n            self.ionization = int(data['ionization'])\n\n        self.verifySettings()\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Ions object.\n        \"\"\"\n\n        Z       = self.getCharges()\n        itypes  = self.getTypes()\n        iopacity_modes =self.getOpacityModes()\n        icharged_diffusion_modes =self.getChargedDiffusionModes()\n        ineutral_diffusion_modes =self.getNeutralDiffusionModes()\n        icharged_advection_modes =self.getChargedAdvectionModes()\n        ineutral_advection_modes =self.getNeutralAdvectionModes()\n        isotopes     = self.getIsotopes()\n        initial = None\n        initialTi = None\n        prescribed = None\n        sourceterm = None\n        sourceterm_types = []\n        charged_prescribed_diffusion = None\n        neutral_prescribed_diffusion = None\n        charged_prescribed_advection = None\n        neutral_prescribed_advection = None\n        names   = \"\"\n\n        hydrogennames = \"\"\n        tritiumnames = \"\"\n\n        SPIMolarFraction = None\n\n        for ion in self.ions:\n            names += '{};'.format(ion.getName())\n\n            if ion.tritium:\n                tritiumnames += '{};'.format(ion.getName())\n            elif ion.hydrogen:\n                hydrogennames += '{};'.format(ion.getName())\n\n            # Set prescribed/initial density\n            if ion.getTime() is None:\n                if initial is None:\n                    initial = np.copy(ion.getDensity())\n                else:\n                    initial = np.concatenate((initial, ion.getDensity()))\n            else:\n                if prescribed is None:\n                    prescribed = np.copy(ion.getDensity())\n                else:\n                    prescribed = np.concatenate((prescribed, ion.getDensity()))\n\n            # Construct source term\n            sourceterm_types.append(ion.getSourceType())\n            if sourceterm is None:\n                sourceterm = np.copy(ion.getSourceDensity())\n            else:\n                sourceterm = np.concatenate((sourceterm, ion.getSourceDensity()))\n\n            if initialTi is None:\n                initialTi = np.copy(ion.getTemperature())\n            else:\n                initialTi = np.concatenate((initialTi, ion.getTemperature()))\n                \n            if SPIMolarFraction is None:\n                SPIMolarFraction = np.copy(ion.getSPIMolarFraction())\n            else:\n                SPIMolarFraction = np.concatenate((SPIMolarFraction, ion.getSPIMolarFraction()))\n                \n            if ion.getChargedDiffusionMode()==ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n                if charged_prescribed_diffusion is None:\n                    charged_prescribed_diffusion = np.copy(ion.getChargedPrescribedDiffusion())\n                else:\n                    charged_prescribed_diffusion = np.concatenate((charged_prescribed_diffusion, ion.getChargedPrescribedDiffusion()))\n           \n            if ion.getNeutralDiffusionMode()==ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n                if neutral_prescribed_diffusion is None:\n                    neutral_prescribed_diffusion = np.copy(ion.getNeutralPrescribedDiffusion())\n                else:\n                    neutral_prescribed_diffusion = np.concatenate((neutral_prescribed_diffusion, ion.getNeutralPrescribedDiffusion()))\n\n            if ion.getChargedAdvectionMode()==ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n                if charged_prescribed_advection is None:\n                    charged_prescribed_advection = np.copy(ion.getChargedPrescribedAdvection())\n                else:\n                    charged_prescribed_advection = np.concatenate((charged_prescribed_advection, ion.getChargedPrescribedAdvection()))\n           \n            if ion.getNeutralAdvectionMode()==ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n                if neutral_prescribed_advection is None:\n                    neutral_prescribed_advection = np.copy(ion.getNeutralPrescribedAdvection())\n                else:\n                    neutral_prescribed_advection = np.concatenate((neutral_prescribed_advection, ion.getNeutralPrescribedAdvection()))\n                \n        data = {\n            'names': names,\n            'Z': Z,\n            'isotopes':isotopes,\n            'SPIMolarFraction':SPIMolarFraction,\n            'types': itypes,\n            'opacity_modes':iopacity_modes,\n            'charged_diffusion_modes':icharged_diffusion_modes,\n            'neutral_diffusion_modes':ineutral_diffusion_modes,\n            'charged_advection_modes':icharged_advection_modes,\n            'neutral_advection_modes':ineutral_advection_modes\n        }\n\n        if len(tritiumnames) > 0:\n            data['tritiumnames'] = tritiumnames\n        if len(hydrogennames) > 0:\n            data['hydrogennames'] = hydrogennames\n\n        if initial is not None:\n            data['initial'] = {\n                'r': self.r,\n                'x': initial\n            }\n\n        if prescribed is not None:\n            data['prescribed'] = {\n                'r': self.r,\n                't': self.t,\n                'x': prescribed\n            }\n\n        if charged_prescribed_diffusion is not None:\n            data['charged_prescribed_diffusion'] = {\n                'r': self.rChargedPrescribedDiffusion,\n                't': self.tChargedPrescribedDiffusion,\n                'x': charged_prescribed_diffusion\n            }\n            \n        if neutral_prescribed_diffusion is not None:\n            data['neutral_prescribed_diffusion'] = {\n                'r': self.rNeutralPrescribedDiffusion,\n                't': self.tNeutralPrescribedDiffusion,\n                'x': neutral_prescribed_diffusion\n            }\n            \n        if charged_prescribed_advection is not None:\n            data['charged_prescribed_advection'] = {\n                'r': self.rChargedPrescribedAdvection,\n                't': self.tChargedPrescribedAdvection,\n                'x': charged_prescribed_advection\n            }\n            \n        if neutral_prescribed_advection is not None:\n            data['neutral_prescribed_advection'] = {\n                'r': self.rNeutralPrescribedAdvection,\n                't': self.tNeutralPrescribedAdvection,\n                'x': neutral_prescribed_advection\n            }\n\n        if self.tSourceTerm is not None:\n            data['ion_source_types'] = sourceterm_types\n            data['ion_source'] = {\n                't': self.tSourceTerm,\n                'x': sourceterm\n            }\n        \n        # Flux limiter settings\n        data['adv_interp_charged'] = self.advectionInterpolationCharged.todict()\n        data['adv_interp_neutral'] = self.advectionInterpolationNeutral.todict()\n            \n        data['initialTi'] = {\n            'r': self.r,\n            'x': initialTi\n        }\n        data['ionization'] = self.ionization\n        data['typeTi'] = self.typeTi\n\n        return data\n            \n\n    def verifySettings(self):\n        \"\"\"\n        Verify that all settings are consistent.\n        \"\"\"\n        # Make sure there are no double names\n        for i in range(0, len(self.ions)):\n            for j in range(0, len(self.ions)):\n                if i == j: continue\n\n                if self.ions[i].getName() == self.ions[j].getName():\n                    raise EquationException(\"ions: More than one ion species is named '{}'.\".format(self.ions[i].getName()))\n            \n            self.ions[i].verifySettings()\n        \n        if (self.ionization != IONIZATION_MODE_FLUID) and (self.ionization != IONIZATION_MODE_KINETIC) and (self.ionization != IONIZATION_MODE_KINETIC_APPROX_JAC):\n            raise EquationException(\"ions: Invalid ionization mode: {}.\".format(self.ionization))\n \n\n    def getFreeElectronDensity(self, t=0):\n        \"\"\"\n        Returns the plasma free electron density at the given time index, based\n        on the prescribed/initialized ion densities.\n\n        :param int t: Index of time for which to retrieve the free electron density.\n        \"\"\"\n        n_free = np.zeros( self.r.shape )\n\n        for ion in self.ions:\n            for Z0 in range(1,ion.Z + 1):\n                if len( ion.n.shape ) == 3:\n                    n_free = n_free + Z0 * ion.n[Z0,t,:]\n                elif len( ion.n.shape ) == 2:\n                    n_free = n_free + Z0 * ion.n[Z0,:]\n                \n        return n_free, self.r",
  "def __init__(self, settings, ionization=IONIZATION_MODE_FLUID):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.ions = list()\n        self.r    = None\n        self.t    = None\n        \n        self.rChargedPrescribedDiffusion = None\n        self.rNeutralPrescribedDiffusion = None\n        self.tChargedPrescribedDiffusion = None\n        self.tNeutralPrescribedDiffusion = None\n        \n        self.rChargedPrescribedAdvection = None\n        self.rNeutralPrescribedAdvection = None\n        self.tChargedPrescribedAdvection = None\n        self.tNeutralPrescribedAdvection = None\n        self.tSourceTerm                 = None\n\n        self.ionization = ionization\n        self.typeTi = IONS_T_I_NEGLECT\n        \n        self.advectionInterpolationCharged = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)\n        self.advectionInterpolationNeutral = AdvectionInterpolation.AdvectionInterpolation(kinetic=False)",
  "def addIon(self, name, Z, iontype=IONS_PRESCRIBED, Z0=None, isotope=0, SPIMolarFraction=-1, opacity_mode=ION_OPACITY_MODE_TRANSPARENT, \n        charged_diffusion_mode=ION_CHARGED_DIFFUSION_MODE_NONE, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None,\n        neutral_diffusion_mode=ION_NEUTRAL_DIFFUSION_MODE_NONE, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None,\n        charged_advection_mode=ION_CHARGED_ADVECTION_MODE_NONE, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None,\n        neutral_advection_mode=ION_NEUTRAL_ADVECTION_MODE_NONE, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None,\n        t_transp_expdecay_all_cs = None, t_transp_start_expdecay_all_cs = 0, diffusion_initial_all_cs = None, diffusion_final_all_cs = 0, advection_initial_all_cs = None, advection_final_all_cs = 0, r_expdecay_all_cs = None, t_expdecay_all_cs = None, \n        T=None, n=None, r=None, t=None, tritium=False, hydrogen=False):\n\n        \"\"\"\n        Adds a new ion species to the plasma.\n\n        :param str name:        Name by which the ion species will be referred to.\n        :param int Z:           Ion charge number.\n        :param int isotope:            Ion mass number.\n        :param int iontype:     Method to use for evolving ions in time.\n        :param int Z0:          Charge state to populate (used for populating exactly one charge state for the ion).\n        :param n:               Ion density (can be either a scalar, 1D array or 2D array, depending on the other input parameters)\n        :param float SPIMolarFraction: Molar fraction of the SPI injection (if any). A negative value means that this species is not part of the SPI injection \n        :param numpy.ndarray r: Radial grid on which the input density is defined.\n        :param T:               Ion initial temperature (can be scalar for uniform temperature, otherwise 1D array matching `r` in size)\n        :param numpy.ndarray r: Radial grid on which the input density and temperature is defined.\n        :param numpy.ndarray t: Time grid on which the input density is defined.\n        :param bool tritium:    If ``True``, the ion species is treated as Tritium.\n        :param bool hydrogen:   If ``True``, the ion species is treated as Hydrogen (single proton).\n        \"\"\"\n        if (self.r is not None) and (r is not None) and (np.any(self.r[:] != r[:])):\n            if self.r.size == 1:\n                self.changeRadialGrid(r)\n            else:\n                raise EquationException(\"The radial grid must be the same for all ion species.\")\n        if (self.t is not None) and (t is not None) and (np.any(self.t != t)):\n            raise EquationException(\"The time grid must be the same for all ion species.\")\n            \n        if (self.rChargedPrescribedDiffusion is not None) and (rChargedPrescribedDiffusion is not None) and (np.any(self.rChargedPrescribedDiffusion != rChargedPrescribedDiffusion)):\n            raise EquationException(\"The radial grid for the prescribed charged diffusion must be the same for all ion species.\")\n        if (self.tChargedPrescribedDiffusion is not None) and (tChargedPrescribedDiffusion is not None) and (np.any(self.tChargedPrescribedDiffusion != tChargedPrescribedDiffusion)):\n            raise EquationException(\"The time grid for the prescribed charged diffusion must be the same for all ion species.\")\n            \n        if (self.rNeutralPrescribedDiffusion is not None) and (rNeutralPrescribedDiffusion is not None) and (np.any(self.rNeutralPrescribedDiffusion != rNeutralPrescribedDiffusion)):\n            raise EquationException(\"The radial grid for the prescribed neutral diffusion must be the same for all ion species.\")\n        if (self.tNeutralPrescribedDiffusion is not None) and (tNeutralPrescribedDiffusion is not None) and (np.any(self.tNeutralPrescribedDiffusion != tNeutralPrescribedDiffusion)):\n            raise EquationException(\"The time grid for the prescribed neutral diffusion must be the same for all ion species.\")\n\n        if T is not None:\n            self.typeTi = IONS_T_I_INCLUDE\n\n        ion = IonSpecies(settings=self.settings, name=name, Z=Z, ttype=iontype, Z0=Z0, isotope=isotope, SPIMolarFraction=SPIMolarFraction, opacity_mode=opacity_mode, \n            charged_diffusion_mode=charged_diffusion_mode, charged_prescribed_diffusion=charged_prescribed_diffusion, rChargedPrescribedDiffusion=rChargedPrescribedDiffusion, tChargedPrescribedDiffusion=tChargedPrescribedDiffusion,\n            neutral_diffusion_mode=neutral_diffusion_mode, neutral_prescribed_diffusion=neutral_prescribed_diffusion, rNeutralPrescribedDiffusion=rNeutralPrescribedDiffusion, tNeutralPrescribedDiffusion=tNeutralPrescribedDiffusion,           \n            charged_advection_mode=charged_advection_mode, charged_prescribed_advection=charged_prescribed_advection, rChargedPrescribedAdvection=rChargedPrescribedAdvection, tChargedPrescribedAdvection=tChargedPrescribedAdvection,\n            neutral_advection_mode=neutral_advection_mode, neutral_prescribed_advection=neutral_prescribed_advection, rNeutralPrescribedAdvection=rNeutralPrescribedAdvection, tNeutralPrescribedAdvection=tNeutralPrescribedAdvection,\n            t_transp_expdecay_all_cs = t_transp_expdecay_all_cs, t_transp_start_expdecay_all_cs = t_transp_start_expdecay_all_cs,\n            diffusion_initial_all_cs = diffusion_initial_all_cs, diffusion_final_all_cs = diffusion_final_all_cs, \n            advection_initial_all_cs = advection_initial_all_cs, advection_final_all_cs = advection_final_all_cs, \n            r_expdecay_all_cs = r_expdecay_all_cs, t_expdecay_all_cs = t_expdecay_all_cs,            \n            T=T, n=n, r=r, t=t, interpr=self.r, interpt=None, tritium=tritium, hydrogen=hydrogen)\n\n        self.ions.append(ion)\n\n        self.r = ion.getR()\n        if ion.getTime() is not None:\n            self.t = ion.getTime()\n            \n        if charged_diffusion_mode==ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n            self.rChargedPrescribedDiffusion = ion.getRChargedPrescribedDiffusion()\n            self.tChargedPrescribedDiffusion = ion.getTChargedPrescribedDiffusion()\n            \n        if neutral_diffusion_mode==ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n            self.rNeutralPrescribedDiffusion = ion.getRNeutralPrescribedDiffusion()\n            self.tNeutralPrescribedDiffusion = ion.getTNeutralPrescribedDiffusion()\n            \n        if charged_advection_mode==ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n            self.rChargedPrescribedAdvection = ion.getRChargedPrescribedAdvection()\n            self.tChargedPrescribedAdvection = ion.getTChargedPrescribedAdvection()\n            \n        if neutral_advection_mode==ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n            self.rNeutralPrescribedAdvection = ion.getRNeutralPrescribedAdvection()\n            self.tNeutralPrescribedAdvection = ion.getTNeutralPrescribedAdvection()",
  "def addIonSource(self, species, dNdt=None, t=None, Z0=0):\n        \"\"\"\n        Add a source term for the specified ion species.\n\n        :param species: Name of the ion species to add this source term to.\n        :param dNdt:    Number of particles to add per unit time.\n        :param t:       Time grid associated with ``dNdt`` (if any).\n        :param Z0:      For scalar or 1D ``dNdt``, the charge state for which to add the source term.\n        \"\"\"\n        if t is None:\n            t = self.tSourceTerm\n        elif self.tSourceTerm is not None and not np.all(t == self.tSourceTerm):\n            raise EquationException(f\"The time grid used for ion sources must be the same for all ion species.\")\n            \n        found = False\n        for ion in self.ions:\n            if ion.name == species:\n                ion.initialize_source(n=dNdt, t=t, Z0=Z0)\n                found = True\n\n                self.tSourceTerm = ion.getSourceTime()\n\n        if not found:\n            raise EquationException(f\"No ion species with name '{species}' has been added to the simulation. Unable to add source term.\")",
  "def changeRadialGrid(self, r):\n        \"\"\"\n        Change the radial grid used for the ion species.\n        \"\"\"\n        for ion in self.ions:\n            if ion.r.size == 1:\n                ion.n = ion.n * np.ones(ion.n.shape[:-1] + (r.size,))\n                ion.T = ion.T * np.ones(ion.T.shape[:-1] + (r.size,))\n                ion.r = r\n            else:\n                fn = scipy.interpolate.interp1d(ion.r, ion.n, axis=-1, bounds_error=False, fill_value='extrapolate')\n                fT = scipy.interpolate.interp1d(ion.r, ion.n, axis=-1, bounds_error=False, fill_value='extrapolate')\n                ion.n = fn(r)\n                ion.T = fT(r)\n                ion.r = r\n\n        self.r = r",
  "def getCharges(self):\n        \"\"\"\n        Returns a list of the charges of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getZ() for ion in self.ions]",
  "def getIsotopes(self):\n        \"\"\"\n        Returns a list of the isotopes of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getIsotope() for ion in self.ions]",
  "def getSPIMolarFraction(self):\n        \"\"\"\n        Returns a list of the SPI molar fractions of the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getSPIMolarFraction() for ion in self.ions]",
  "def getIndex(self, species):\n        \"\"\"\n        Return the index of the ion species with the specified name.\n        \"\"\"\n        for iIon in range(len(self.ions)):\n            if self.ions[iIon].getName() == species:\n                return iIon\n\n        raise EquationException(f\"No species with name '{species}'.\")",
  "def getIon(self, i=None):\n        \"\"\"\n        Returns the ion species with the specified index or name.\n\n        :param i: Index or name of ion species to retrieve.\n        \"\"\"\n        if type(i) == int: return self.ions[i]\n        elif type(i) == str:\n            for j in range(0, len(self.ions)):\n                if self.ions[j].getName() == i:\n                    return self.ions[j]\n\n            raise EquationException(\"No ion with name '{}' has been defined.\".format(i))\n        else:\n            raise EquationException(\"Invalid call to 'getIon()'.\")",
  "def setIonization(self, ionization=IONIZATION_MODE_FLUID):\n        \"\"\"\n        Sets which model to use for ionization.\n\n        :param int ionization: Flag indicating which model to use for ionization.\n        \"\"\"\n        self.ionization=ionization",
  "def getHydrogenSpecies(self):\n        \"\"\"\n        Returns a list of names of the ion species which are treated\n        as Hydrogen.\n        \"\"\"\n        hydr = []\n        for ion in self.ions:\n            if ion.hydrogen:\n                hydr.append(ion.getName())\n\n        return hydr",
  "def getTritiumSpecies(self):\n        \"\"\"\n        Returns a list of names of the ion species which are treated\n        as Tritium.\n        \"\"\"\n        trit = []\n        for ion in self.ions:\n            if ion.tritium:\n                trit.append(ion.getName())\n\n        return trit",
  "def getTypes(self):\n        \"\"\"\n        Returns a list of ion types for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getType() for ion in self.ions]",
  "def getOpacityModes(self):\n        \"\"\"\n        Returns a list of ion opacity modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getOpacityMode() for ion in self.ions]",
  "def getChargedDiffusionModes(self):\n        \"\"\"\n        Returns a list of ion charged diffusion modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getChargedDiffusionMode() for ion in self.ions]",
  "def getNeutralDiffusionModes(self):\n        \"\"\"\n        Returns a list of ion neutral diffusion modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getNeutralDiffusionMode() for ion in self.ions]",
  "def getChargedAdvectionModes(self):\n        \"\"\"\n        Returns a list of ion charged advection modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getChargedAdvectionMode() for ion in self.ions]",
  "def getNeutralAdvectionModes(self):\n        \"\"\"\n        Returns a list of ion neutral advection modes for the various ion species\n        contained by this object.\n        \"\"\"\n        return [ion.getNeutralAdvectionMode() for ion in self.ions]",
  "def setAdvectionInterpolationMethodCharged(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the charged advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolationCharged.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)",
  "def setAdvectionInterpolationMethodNeutral(self, ad_int=AD_INTERP_CENTRED,\n        ad_jac=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the neutral advection terms of\n        the transport equation.\n        \n        :param int ad_int:               Interpolation method to use for the radial coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for the radial coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolationNeutral.setMethod(ad_int=ad_int, ad_jac=ad_jac, fluxlimiterdamping=fluxlimiterdamping)",
  "def setIonType(self, index, ttype):\n        \"\"\"\n        Modifies the type of equation used for the specified ion species.\n\n        :param index: Index or name of ion species to set type for.\n        :param int ttype: Type of equation to use for evolving the ion species.\n        \"\"\"\n        ion = self.getIon(index)\n\n        # Note that the DREAM kernel only uses positive type indices.\n        # The negative type indices are interface extensions which can\n        # only be used with the 'initialize()' methods.\n        if ttype <= 0:\n            raise DREAMException(\"Trying to set invalid ion type for ion species '{}': {}.\".format(ion.name, ttype))\n\n        ion.ttype = ttype",
  "def fromdict(self, data):\n        \"\"\"\n        Load settings from the specified dictionary.\n        \n        :param dict data: Dictionary containing all settings to load.\n        \"\"\"\n        names        = data['names'].split(';')[:-1]\n        Z            = data['Z']\n\n        if 'isotopes' in data and len(data['isotopes']) == len(Z):\n            isotopes = data['isotopes']\n        else:\n            isotopes = [0]*len(Z)\n\n        if 'types' in data and len(data['types']) == len(Z):\n            types = data['types']\n        else:\n            types = [0]*len(Z)\n\n        if 'opacity_modes' in data and len(data['opacity_modes']) == len(Z):\n            opacity_modes = data['opacity_modes']\n        else:\n            opacity_modes = self.getOpacityModes()\n\n        charged_diffusion_modes = [ION_CHARGED_DIFFUSION_MODE_NONE]*len(Z)\n        neutral_diffusion_modes = [ION_NEUTRAL_DIFFUSION_MODE_NONE]*len(Z)\n        charged_advection_modes = [ION_CHARGED_ADVECTION_MODE_NONE]*len(Z)\n        neutral_advection_modes = [ION_NEUTRAL_ADVECTION_MODE_NONE]*len(Z)\n\n        if 'charged_diffusion_modes' in data:\n            charged_diffusion_modes = data['charged_diffusion_modes']\n        if 'neutral_diffusion_modes' in data:\n            neutral_diffusion_modes = data['neutral_diffusion_modes']\n        if 'charged_advection_modes' in data:\n            charged_advection_modes = data['charged_advection_modes']\n        if 'neutral_advection_modes' in data:\n            neutral_advection_modes = data['neutral_advection_modes']\n\n        SPIMolarFraction = data['SPIMolarFraction']\n        nZSPI = len(Z)-np.sum(SPIMolarFraction<0)\n        if nZSPI>0:\n            nShard = int(np.sum(SPIMolarFraction>=0)/nZSPI)\n        else:\n            nShard = 0\n\n        if 'tritiumnames' in data:\n            tritiumnames = data['tritiumnames'].split(';')[:-1]\n        else:\n            tritiumnames = []\n\n        if 'hydrogennames' in data:\n            hydrogennames = data['hydrogennames'].split(';')[:-1]\n        else:\n            hydrogennames = []\n\n        initial    = None\n        prescribed = None\n        initialTi  = None\n        charged_prescribed_diffusion = None\n        neutral_prescribed_diffusion = None\n        charged_prescribed_advection = None\n        neutral_prescribed_advection = None\n        self.typeTi = IONS_T_I_NEGLECT\n        if 'typeTi' in data:\n            self.typeTi = int(data['typeTi'])\n        if 'initial' in data:\n            initial = data['initial']\n        if 'prescribed' in data:\n            prescribed = data['prescribed']\n        if 'charged_prescribed_diffusion' in data:\n            charged_prescribed_diffusion = data['charged_prescribed_diffusion']\n        if 'neutral_prescribed_diffusion' in data:\n            neutral_prescribed_diffusion = data['neutral_prescribed_diffusion']\n        if 'charged_prescribed_advection' in data:\n            charged_prescribed_advection = data['charged_prescribed_advection']\n        if 'neutral_prescribed_advection' in data:\n            neutral_prescribed_advection = data['neutral_prescribed_advection']\n        if 'adv_interp_charged' in data:\n            self.advectionInterpolationCharged.fromdict(data['adv_interp_charged'])\n        if 'adv_interp_neutral' in data:\n            self.advectionInterpolationNeutral.fromdict(data['adv_interp_neutral'])\n        if 'initialTi' in data:\n            initialTi = data['initialTi']\n        iidx, pidx, spiidx, cpdidx, npdidx, cpaidx, npaidx = 0, 0, 0, 0, 0, 0, 0\n        for i in range(len(Z)):\n            if types[i] == IONS_PRESCRIBED:\n                n = prescribed['x'][pidx:(pidx+Z[i]+1)]\n                r = prescribed['r']\n                t = prescribed['t']\n                pidx += Z[i]+1\n            else:\n                n = initial['x'][iidx:(iidx+Z[i]+1)]\n                r = initial['r']\n                t = None #initial['t']\n                iidx += Z[i]+1\n            if self.typeTi==IONS_T_I_INCLUDE and initialTi is not None:\n                T = initialTi['x'][i]\n            else: \n                T = None\n            if SPIMolarFraction[spiidx]>=0:\n                SPIMolarFractionSingleSpecies = SPIMolarFraction[spiidx:spiidx+nShard]\n                spiidx+=nShard\n            else:\n                SPIMolarFractionSingleSpecies = SPIMolarFraction[spiidx]\n                spiidx+=1\n            tritium = (names[i] in tritiumnames)\n            hydrogen = (names[i] in hydrogennames)\n            \n            if charged_diffusion_modes[i] == ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n                cpd = charged_prescribed_diffusion['x'][cpdidx:(cpdidx+Z[i])]\n                rcpd = charged_prescribed_diffusion['r']\n                tcpd = charged_prescribed_diffusion['t']\n                cpdidx += Z[i]\n            else:\n                cpd=None\n                rcpd=None\n                tcpd=None\n                \n            if neutral_diffusion_modes[i] == ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n                npd = neutral_prescribed_diffusion['x'][npdidx:(npdidx+1)]\n                rnpd = neutral_prescribed_diffusion['r']\n                tnpd = neutral_prescribed_diffusion['t']\n                npdidx += 1\n            else:\n                npd=None\n                rnpd=None\n                tnpd=None\n                \n            if charged_advection_modes[i] == ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n                cpa = charged_prescribed_advection['x'][cpaidx:(cpaidx+Z[i])]\n                rcpa = charged_prescribed_advection['r']\n                tcpa = charged_prescribed_advection['t']\n                cpaidx += Z[i]\n            else:\n                cpa=None\n                rcpa=None\n                tcpa=None\n                \n            if neutral_advection_modes[i] == ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n                npa = neutral_prescribed_advection['x'][npaidx:(npaidx+1)]\n                rnpa = neutral_prescribed_advection['r']\n                tnpa = neutral_prescribed_advection['t']\n                npaidx += 1\n            else:\n                npa=None\n                rnpa=None\n                tnpa=None\n\n            self.addIon(name=names[i], Z=Z[i], isotope=isotopes[i], SPIMolarFraction=SPIMolarFractionSingleSpecies, iontype=types[i], opacity_mode=opacity_modes[i], \n                charged_diffusion_mode=charged_diffusion_modes[i], charged_prescribed_diffusion = cpd, rChargedPrescribedDiffusion=rcpd, tChargedPrescribedDiffusion = tcpd,\n                neutral_diffusion_mode=neutral_diffusion_modes[i], neutral_prescribed_diffusion = npd, rNeutralPrescribedDiffusion=rnpd, tNeutralPrescribedDiffusion = tnpd,\n                charged_advection_mode=charged_advection_modes[i], charged_prescribed_advection = cpa, rChargedPrescribedAdvection=rcpa, tChargedPrescribedAdvection = tcpa,\n                neutral_advection_mode=neutral_advection_modes[i], neutral_prescribed_advection = npa, rNeutralPrescribedAdvection=rnpa, tNeutralPrescribedAdvection = tnpa,\n                T=T, n=n, r=r, t=t, tritium=tritium, hydrogen=hydrogen)\n\n        if 'ionization' in data:\n            self.ionization = int(data['ionization'])\n\n        self.verifySettings()",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this Ions object.\n        \"\"\"\n\n        Z       = self.getCharges()\n        itypes  = self.getTypes()\n        iopacity_modes =self.getOpacityModes()\n        icharged_diffusion_modes =self.getChargedDiffusionModes()\n        ineutral_diffusion_modes =self.getNeutralDiffusionModes()\n        icharged_advection_modes =self.getChargedAdvectionModes()\n        ineutral_advection_modes =self.getNeutralAdvectionModes()\n        isotopes     = self.getIsotopes()\n        initial = None\n        initialTi = None\n        prescribed = None\n        sourceterm = None\n        sourceterm_types = []\n        charged_prescribed_diffusion = None\n        neutral_prescribed_diffusion = None\n        charged_prescribed_advection = None\n        neutral_prescribed_advection = None\n        names   = \"\"\n\n        hydrogennames = \"\"\n        tritiumnames = \"\"\n\n        SPIMolarFraction = None\n\n        for ion in self.ions:\n            names += '{};'.format(ion.getName())\n\n            if ion.tritium:\n                tritiumnames += '{};'.format(ion.getName())\n            elif ion.hydrogen:\n                hydrogennames += '{};'.format(ion.getName())\n\n            # Set prescribed/initial density\n            if ion.getTime() is None:\n                if initial is None:\n                    initial = np.copy(ion.getDensity())\n                else:\n                    initial = np.concatenate((initial, ion.getDensity()))\n            else:\n                if prescribed is None:\n                    prescribed = np.copy(ion.getDensity())\n                else:\n                    prescribed = np.concatenate((prescribed, ion.getDensity()))\n\n            # Construct source term\n            sourceterm_types.append(ion.getSourceType())\n            if sourceterm is None:\n                sourceterm = np.copy(ion.getSourceDensity())\n            else:\n                sourceterm = np.concatenate((sourceterm, ion.getSourceDensity()))\n\n            if initialTi is None:\n                initialTi = np.copy(ion.getTemperature())\n            else:\n                initialTi = np.concatenate((initialTi, ion.getTemperature()))\n                \n            if SPIMolarFraction is None:\n                SPIMolarFraction = np.copy(ion.getSPIMolarFraction())\n            else:\n                SPIMolarFraction = np.concatenate((SPIMolarFraction, ion.getSPIMolarFraction()))\n                \n            if ion.getChargedDiffusionMode()==ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n                if charged_prescribed_diffusion is None:\n                    charged_prescribed_diffusion = np.copy(ion.getChargedPrescribedDiffusion())\n                else:\n                    charged_prescribed_diffusion = np.concatenate((charged_prescribed_diffusion, ion.getChargedPrescribedDiffusion()))\n           \n            if ion.getNeutralDiffusionMode()==ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n                if neutral_prescribed_diffusion is None:\n                    neutral_prescribed_diffusion = np.copy(ion.getNeutralPrescribedDiffusion())\n                else:\n                    neutral_prescribed_diffusion = np.concatenate((neutral_prescribed_diffusion, ion.getNeutralPrescribedDiffusion()))\n\n            if ion.getChargedAdvectionMode()==ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n                if charged_prescribed_advection is None:\n                    charged_prescribed_advection = np.copy(ion.getChargedPrescribedAdvection())\n                else:\n                    charged_prescribed_advection = np.concatenate((charged_prescribed_advection, ion.getChargedPrescribedAdvection()))\n           \n            if ion.getNeutralAdvectionMode()==ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n                if neutral_prescribed_advection is None:\n                    neutral_prescribed_advection = np.copy(ion.getNeutralPrescribedAdvection())\n                else:\n                    neutral_prescribed_advection = np.concatenate((neutral_prescribed_advection, ion.getNeutralPrescribedAdvection()))\n                \n        data = {\n            'names': names,\n            'Z': Z,\n            'isotopes':isotopes,\n            'SPIMolarFraction':SPIMolarFraction,\n            'types': itypes,\n            'opacity_modes':iopacity_modes,\n            'charged_diffusion_modes':icharged_diffusion_modes,\n            'neutral_diffusion_modes':ineutral_diffusion_modes,\n            'charged_advection_modes':icharged_advection_modes,\n            'neutral_advection_modes':ineutral_advection_modes\n        }\n\n        if len(tritiumnames) > 0:\n            data['tritiumnames'] = tritiumnames\n        if len(hydrogennames) > 0:\n            data['hydrogennames'] = hydrogennames\n\n        if initial is not None:\n            data['initial'] = {\n                'r': self.r,\n                'x': initial\n            }\n\n        if prescribed is not None:\n            data['prescribed'] = {\n                'r': self.r,\n                't': self.t,\n                'x': prescribed\n            }\n\n        if charged_prescribed_diffusion is not None:\n            data['charged_prescribed_diffusion'] = {\n                'r': self.rChargedPrescribedDiffusion,\n                't': self.tChargedPrescribedDiffusion,\n                'x': charged_prescribed_diffusion\n            }\n            \n        if neutral_prescribed_diffusion is not None:\n            data['neutral_prescribed_diffusion'] = {\n                'r': self.rNeutralPrescribedDiffusion,\n                't': self.tNeutralPrescribedDiffusion,\n                'x': neutral_prescribed_diffusion\n            }\n            \n        if charged_prescribed_advection is not None:\n            data['charged_prescribed_advection'] = {\n                'r': self.rChargedPrescribedAdvection,\n                't': self.tChargedPrescribedAdvection,\n                'x': charged_prescribed_advection\n            }\n            \n        if neutral_prescribed_advection is not None:\n            data['neutral_prescribed_advection'] = {\n                'r': self.rNeutralPrescribedAdvection,\n                't': self.tNeutralPrescribedAdvection,\n                'x': neutral_prescribed_advection\n            }\n\n        if self.tSourceTerm is not None:\n            data['ion_source_types'] = sourceterm_types\n            data['ion_source'] = {\n                't': self.tSourceTerm,\n                'x': sourceterm\n            }\n        \n        # Flux limiter settings\n        data['adv_interp_charged'] = self.advectionInterpolationCharged.todict()\n        data['adv_interp_neutral'] = self.advectionInterpolationNeutral.todict()\n            \n        data['initialTi'] = {\n            'r': self.r,\n            'x': initialTi\n        }\n        data['ionization'] = self.ionization\n        data['typeTi'] = self.typeTi\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that all settings are consistent.\n        \"\"\"\n        # Make sure there are no double names\n        for i in range(0, len(self.ions)):\n            for j in range(0, len(self.ions)):\n                if i == j: continue\n\n                if self.ions[i].getName() == self.ions[j].getName():\n                    raise EquationException(\"ions: More than one ion species is named '{}'.\".format(self.ions[i].getName()))\n            \n            self.ions[i].verifySettings()\n        \n        if (self.ionization != IONIZATION_MODE_FLUID) and (self.ionization != IONIZATION_MODE_KINETIC) and (self.ionization != IONIZATION_MODE_KINETIC_APPROX_JAC):\n            raise EquationException(\"ions: Invalid ionization mode: {}.\".format(self.ionization))",
  "def getFreeElectronDensity(self, t=0):\n        \"\"\"\n        Returns the plasma free electron density at the given time index, based\n        on the prescribed/initialized ion densities.\n\n        :param int t: Index of time for which to retrieve the free electron density.\n        \"\"\"\n        n_free = np.zeros( self.r.shape )\n\n        for ion in self.ions:\n            for Z0 in range(1,ion.Z + 1):\n                if len( ion.n.shape ) == 3:\n                    n_free = n_free + Z0 * ion.n[Z0,t,:]\n                elif len( ion.n.shape ) == 2:\n                    n_free = n_free + Z0 * ion.n[Z0,:]\n                \n        return n_free, self.r",
  "class PoloidalFlux(UnknownQuantity,PrescribedParameter):\n    \n    def __init__(self, settings):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.hyperresistivity_enabled = False\n        self.hyperresistivity_Lambda_x = None\n        self.hyperresistivity_Lambda_r = None\n        self.hyperresistivity_Lambda_t = None\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'hyperresistivity' in data:\n            hyp = data['hyperresistivity']\n            self.hyperresistivity_enabled = bool(hyp['enabled'])\n\n            if 'Lambda' in hyp:\n                self.hyperresistivity_Lambda_x = hyp['Lambda']['x']\n                self.hyperresistivity_Lambda_r = hyp['Lambda']['r']\n                self.hyperresistivity_Lambda_t = hyp['Lambda']['t']\n\n\n    def setHyperresistivity(self, Lambda, radius=None, times=None):\n        \"\"\"\n        Enable the hyperresistive diffusion term and specify the\n        transport coefficient ``Lambda``.\n\n        :param Lambda: Diffusion coefficient.\n        :param radius: Radial grid on which  ``Lambda`` is specified (if any).\n        :param times:  Time grid on which ``Lambda`` is specified (if any).\n        \"\"\"\n        d, r, t = self._setPrescribedData(data=Lambda, radius=radius, times=times)\n\n        self.hyperresistivity_enabled = True\n        self.hyperresistivity_Lambda_x = d\n        self.hyperresistivity_Lambda_r = r\n        self.hyperresistivity_Lambda_t = t\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PoloidalFlux object.\n        \"\"\"\n        data = {\n            'hyperresistivity': {\n                'enabled': self.hyperresistivity_enabled\n            }\n        }\n\n        if self.hyperresistivity_enabled:\n            data['hyperresistivity']['Lambda'] = {\n                'x': self.hyperresistivity_Lambda_x,\n                'r': self.hyperresistivity_Lambda_r,\n                't': self.hyperresistivity_Lambda_t\n            }\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.hyperresistivity_enabled:\n            self._verifySettingsPrescribedData('psi_p hyperresistivity', data=self.hyperresistivity_Lambda_x, radius=self.hyperresistivity_Lambda_r, times=self.hyperresistivity_Lambda_t)",
  "def __init__(self, settings):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.hyperresistivity_enabled = False\n        self.hyperresistivity_Lambda_x = None\n        self.hyperresistivity_Lambda_r = None\n        self.hyperresistivity_Lambda_t = None",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'hyperresistivity' in data:\n            hyp = data['hyperresistivity']\n            self.hyperresistivity_enabled = bool(hyp['enabled'])\n\n            if 'Lambda' in hyp:\n                self.hyperresistivity_Lambda_x = hyp['Lambda']['x']\n                self.hyperresistivity_Lambda_r = hyp['Lambda']['r']\n                self.hyperresistivity_Lambda_t = hyp['Lambda']['t']",
  "def setHyperresistivity(self, Lambda, radius=None, times=None):\n        \"\"\"\n        Enable the hyperresistive diffusion term and specify the\n        transport coefficient ``Lambda``.\n\n        :param Lambda: Diffusion coefficient.\n        :param radius: Radial grid on which  ``Lambda`` is specified (if any).\n        :param times:  Time grid on which ``Lambda`` is specified (if any).\n        \"\"\"\n        d, r, t = self._setPrescribedData(data=Lambda, radius=radius, times=times)\n\n        self.hyperresistivity_enabled = True\n        self.hyperresistivity_Lambda_x = d\n        self.hyperresistivity_Lambda_r = r\n        self.hyperresistivity_Lambda_t = t",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PoloidalFlux object.\n        \"\"\"\n        data = {\n            'hyperresistivity': {\n                'enabled': self.hyperresistivity_enabled\n            }\n        }\n\n        if self.hyperresistivity_enabled:\n            data['hyperresistivity']['Lambda'] = {\n                'x': self.hyperresistivity_Lambda_x,\n                'r': self.hyperresistivity_Lambda_r,\n                't': self.hyperresistivity_Lambda_t\n            }\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.hyperresistivity_enabled:\n            self._verifySettingsPrescribedData('psi_p hyperresistivity', data=self.hyperresistivity_Lambda_x, radius=self.hyperresistivity_Lambda_r, times=self.hyperresistivity_Lambda_t)",
  "class ColdElectrons(UnknownQuantity,PrescribedParameter, PrescribedScalarParameter):\n    \n    def __init__(self, settings, ttype=TYPE_SELFCONSISTENT, density=None, radius=None, times=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        self.density = None\n        self.radius  = None\n        self.times   = None\n\n        if (ttype == TYPE_PRESCRIBED) and (density is not None) and (radius is not None) and (times is not None):\n            self.setPrescribedData(density=density, radius=radius, times=times)\n        \n\n    ###################\n    # SETTERS\n    ###################\n    def setPrescribedData(self, density, radius=0, times=0):\n        \"\"\"\n        Prescribe the cold electron density in time and space.\n\n        :param density: Cold electron density (2D array (nt, nr) or scalar (=> constant and uniform in time and space))\n        :param radius:  Radial grid on which the cold electron density is defined.\n        :param times:   Time grid on which the cold electron density is defined.\n        \"\"\"\n        _data, _rad, _tim = self._setPrescribedData(density, radius, times)\n        self.density = _data\n        self.radius = _rad\n        self.times  = _tim\n\n        self.setType(TYPE_PRESCRIBED)\n\n        self.verifySettingsPrescribedData()\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Sets the type of equation to use for evolving the cold electron density.\n\n        :param int ttype: Flag indicating how to evolve the cold electron density.\n        \"\"\"\n        if ttype == TYPE_PRESCRIBED:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n\n        :param dict data: List of settings to load.\n        \"\"\"\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.density = data['data']['x']\n            self.radius  = data['data']['r']\n            self.times   = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))\n\n        self.verifySettings()\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.density,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.density) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no density data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            # Nothing todo\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized equation type specified: {}.\".format(self.type))\n\n\n    def verifySettingsPrescribedData(self):\n        \"\"\"\n        Verify that the prescribed has a valid format.\n        \"\"\"\n        if len(self.density.shape) != 2:\n            raise EquationException(\"n_cold: Invalid number of dimensions in prescribed data. Expected 2 dimensions (time x radius).\")\n        elif len(self.times.shape) != 1:\n            raise EquationException(\"n_cold: Invalid number of dimensions in time grid of prescribed data. Expected one dimension.\")\n        elif len(self.radius.shape) != 1:\n            raise EquationException(\"n_cold: Invalid number of dimensions in radial grid of prescribed data. Expected one dimension.\")\n        elif self.density.shape[0] != self.times.size or self.density.shape[1] != self.radius.size:\n            raise EquationException(\"n_cold: Invalid dimensions of prescribed data: {}x{}. Expected {}x{} (time x radius).\"\n                .format(self.density.shape[0], self.density.shape[1], self.times.size, self.radius.size))",
  "def __init__(self, settings, ttype=TYPE_SELFCONSISTENT, density=None, radius=None, times=None):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        self.density = None\n        self.radius  = None\n        self.times   = None\n\n        if (ttype == TYPE_PRESCRIBED) and (density is not None) and (radius is not None) and (times is not None):\n            self.setPrescribedData(density=density, radius=radius, times=times)",
  "def setPrescribedData(self, density, radius=0, times=0):\n        \"\"\"\n        Prescribe the cold electron density in time and space.\n\n        :param density: Cold electron density (2D array (nt, nr) or scalar (=> constant and uniform in time and space))\n        :param radius:  Radial grid on which the cold electron density is defined.\n        :param times:   Time grid on which the cold electron density is defined.\n        \"\"\"\n        _data, _rad, _tim = self._setPrescribedData(density, radius, times)\n        self.density = _data\n        self.radius = _rad\n        self.times  = _tim\n\n        self.setType(TYPE_PRESCRIBED)\n\n        self.verifySettingsPrescribedData()",
  "def setType(self, ttype):\n        \"\"\"\n        Sets the type of equation to use for evolving the cold electron density.\n\n        :param int ttype: Flag indicating how to evolve the cold electron density.\n        \"\"\"\n        if ttype == TYPE_PRESCRIBED:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n\n        :param dict data: List of settings to load.\n        \"\"\"\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.density = data['data']['x']\n            self.radius  = data['data']['r']\n            self.times   = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))\n\n        self.verifySettings()",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.density,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized cold electron density type: {}\".format(self.type))\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.density) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no density data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"n_cold: Density prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            # Nothing todo\n            pass\n        else:\n            raise EquationException(\"n_cold: Unrecognized equation type specified: {}.\".format(self.type))",
  "def verifySettingsPrescribedData(self):\n        \"\"\"\n        Verify that the prescribed has a valid format.\n        \"\"\"\n        if len(self.density.shape) != 2:\n            raise EquationException(\"n_cold: Invalid number of dimensions in prescribed data. Expected 2 dimensions (time x radius).\")\n        elif len(self.times.shape) != 1:\n            raise EquationException(\"n_cold: Invalid number of dimensions in time grid of prescribed data. Expected one dimension.\")\n        elif len(self.radius.shape) != 1:\n            raise EquationException(\"n_cold: Invalid number of dimensions in radial grid of prescribed data. Expected one dimension.\")\n        elif self.density.shape[0] != self.times.size or self.density.shape[1] != self.radius.size:\n            raise EquationException(\"n_cold: Invalid dimensions of prescribed data: {}x{}. Expected {}x{} (time x radius).\"\n                .format(self.density.shape[0], self.density.shape[1], self.times.size, self.radius.size))",
  "class EquationException(Exception):\n    \n    def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "def __init__(self, message):\n        super(Exception, self).__init__(message)",
  "class HotElectronDistribution(DistributionFunction):\n    \n    def __init__(self, settings,\n        fhot=None, initr=None, initp=None, initxi=None,\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=BC_PHI_CONST,\n        ad_int_r =AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED,\n        ad_jac_r =AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, \n        ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        fluxlimiterdamping=1.0,\n        dist_mode = F_HOT_DIST_MODE_NONREL,\n        pThreshold=7, pThresholdMode=HOT_REGION_P_MODE_THERMAL,\n        particleSource=PARTICLE_SOURCE_EXPLICIT,\n        particleSourceShape=PARTICLE_SOURCE_SHAPE_MAXWELLIAN):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings, name='f_hot', grid=settings.hottailgrid,\n            f=fhot, initr=initr, initp=initp, initxi=initxi, initppar=initppar,\n            initpperp=initpperp, rn0=rn0, n0=n0, rT0=rT0, T0=T0,\n            bc=bc, ad_int_r=ad_int_r, ad_int_p1=ad_int_p1,\n            ad_int_p2=ad_int_p2, ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1,\n            ad_jac_p2=ad_jac_p2, fluxlimiterdamping=fluxlimiterdamping)\n\n        self.dist_mode      = dist_mode\n        self.pThreshold     = pThreshold\n        self.pThresholdMode = pThresholdMode\n\n        self.particleSource = particleSource\n        self.particleSourceShape = particleSourceShape\n\n\n    def setHotRegionThreshold(self, pThreshold=7, pMode=HOT_REGION_P_MODE_THERMAL):\n        \"\"\"\n        Sets the boundary 'pThreshold' which defines the cutoff separating 'cold'\n        from 'hot' electrons when using collfreq_mode FULL. \n        \"\"\"\n        self.pThreshold = pThreshold\n        self.pThresholdMode = pMode\n\n\n    def setParticleSource(self, particleSource=PARTICLE_SOURCE_EXPLICIT, shape=PARTICLE_SOURCE_SHAPE_MAXWELLIAN):\n        \"\"\"\n        Sets which model to use for S_particle if using collfreq_mode FULL,\n        which is designed to force the density moment of f_hot to n_cold+n_hot.\n\n        ZERO: The particle source is disabled and set to zero\n        EXPLICIT/IMPLICIT: Two in principle equivalent models, but can be more or less stable in different situations. \n        \"\"\"\n        self.particleSource = particleSource\n        self.particleSourceShape = shape\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n        \"\"\"\n        super().fromdict(data)\n        if 'dist_mode' in data:\n            self.dist_mode = data['dist_mode']\n        if 'pThreshold' in data:\n            self.pThreshold = data['pThreshold']\n            self.pThresholdMode = data['pThresholdMode']\n        if 'particleSource' in data:\n            self.particleSource = data['particleSource']\n        if 'particleSourceShape' in data:\n            self.particleSourceShape = data['particleSourceShape']\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this HotElectronDistribution object.\n        \"\"\"\n        data = super().todict()\n        data['dist_mode'] = self.dist_mode\n        if self.grid.enabled:\n            data['pThreshold']     = self.pThreshold\n            data['pThresholdMode'] = self.pThresholdMode\n            data['particleSource'] = self.particleSource\n            data['particleSourceShape'] = self.particleSourceShape\n\n        return data",
  "def __init__(self, settings,\n        fhot=None, initr=None, initp=None, initxi=None,\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=BC_PHI_CONST,\n        ad_int_r =AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED,\n        ad_jac_r =AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, \n        ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        fluxlimiterdamping=1.0,\n        dist_mode = F_HOT_DIST_MODE_NONREL,\n        pThreshold=7, pThresholdMode=HOT_REGION_P_MODE_THERMAL,\n        particleSource=PARTICLE_SOURCE_EXPLICIT,\n        particleSourceShape=PARTICLE_SOURCE_SHAPE_MAXWELLIAN):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings, name='f_hot', grid=settings.hottailgrid,\n            f=fhot, initr=initr, initp=initp, initxi=initxi, initppar=initppar,\n            initpperp=initpperp, rn0=rn0, n0=n0, rT0=rT0, T0=T0,\n            bc=bc, ad_int_r=ad_int_r, ad_int_p1=ad_int_p1,\n            ad_int_p2=ad_int_p2, ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1,\n            ad_jac_p2=ad_jac_p2, fluxlimiterdamping=fluxlimiterdamping)\n\n        self.dist_mode      = dist_mode\n        self.pThreshold     = pThreshold\n        self.pThresholdMode = pThresholdMode\n\n        self.particleSource = particleSource\n        self.particleSourceShape = particleSourceShape",
  "def setHotRegionThreshold(self, pThreshold=7, pMode=HOT_REGION_P_MODE_THERMAL):\n        \"\"\"\n        Sets the boundary 'pThreshold' which defines the cutoff separating 'cold'\n        from 'hot' electrons when using collfreq_mode FULL. \n        \"\"\"\n        self.pThreshold = pThreshold\n        self.pThresholdMode = pMode",
  "def setParticleSource(self, particleSource=PARTICLE_SOURCE_EXPLICIT, shape=PARTICLE_SOURCE_SHAPE_MAXWELLIAN):\n        \"\"\"\n        Sets which model to use for S_particle if using collfreq_mode FULL,\n        which is designed to force the density moment of f_hot to n_cold+n_hot.\n\n        ZERO: The particle source is disabled and set to zero\n        EXPLICIT/IMPLICIT: Two in principle equivalent models, but can be more or less stable in different situations. \n        \"\"\"\n        self.particleSource = particleSource\n        self.particleSourceShape = shape",
  "def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n        \"\"\"\n        super().fromdict(data)\n        if 'dist_mode' in data:\n            self.dist_mode = data['dist_mode']\n        if 'pThreshold' in data:\n            self.pThreshold = data['pThreshold']\n            self.pThresholdMode = data['pThresholdMode']\n        if 'particleSource' in data:\n            self.particleSource = data['particleSource']\n        if 'particleSourceShape' in data:\n            self.particleSourceShape = data['particleSourceShape']",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this HotElectronDistribution object.\n        \"\"\"\n        data = super().todict()\n        data['dist_mode'] = self.dist_mode\n        if self.grid.enabled:\n            data['pThreshold']     = self.pThreshold\n            data['pThresholdMode'] = self.pThresholdMode\n            data['particleSource'] = self.particleSource\n            data['particleSourceShape'] = self.particleSourceShape\n\n        return data",
  "class PrescribedInitialParameter:\n    \n\n    def _setInitialData(self, data, radius=0):\n        \"\"\"\n        Set prescribed initial data appropriately.\n        \"\"\"\n        if np.isscalar(radius):\n            r = np.asarray([radius])\n        else: r = np.asarray(radius)\n\n        if np.isscalar(data):\n            d = data*np.ones((r.size, ))\n        else: d = np.asarray(data)\n\n        return d, r\n\n\n    def _verifySettingsPrescribedInitialData(self, name, data, radius):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed initial data. Expected one dimension (radius).\".format(name))\n        elif len(radius.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed initial data. Expected one dimension.\".format(name))\n        elif data.shape[0] != radius.size:\n            raise EquationException(\"{}: Invalid size of prescribed data: {}. Expected {} elements.\"\n                .format(name, data.shape[0], radius.size))",
  "def _setInitialData(self, data, radius=0):\n        \"\"\"\n        Set prescribed initial data appropriately.\n        \"\"\"\n        if np.isscalar(radius):\n            r = np.asarray([radius])\n        else: r = np.asarray(radius)\n\n        if np.isscalar(data):\n            d = data*np.ones((r.size, ))\n        else: d = np.asarray(data)\n\n        return d, r",
  "def _verifySettingsPrescribedInitialData(self, name, data, radius):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed initial data. Expected one dimension (radius).\".format(name))\n        elif len(radius.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed initial data. Expected one dimension.\".format(name))\n        elif data.shape[0] != radius.size:\n            raise EquationException(\"{}: Invalid size of prescribed data: {}. Expected {} elements.\"\n                .format(name, data.shape[0], radius.size))",
  "class RunawayElectronDistribution(DistributionFunction):\n    \n    def __init__(self, settings,\n        fre=[0.0], initr=[0.0], initp=[0.0], initxi=[0.0],\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=DistFunc.BC_PHI_CONST,\n        ad_int_r=DistFunc.AD_INTERP_CENTRED,\n        ad_int_p1=DistFunc.AD_INTERP_CENTRED,\n        ad_int_p2=DistFunc.AD_INTERP_CENTRED,\n        ad_jac_r=DistFunc.AD_INTERP_JACOBIAN_LINEAR,\n        ad_jac_p1=DistFunc.AD_INTERP_JACOBIAN_LINEAR, \n        ad_jac_p2=DistFunc.AD_INTERP_JACOBIAN_LINEAR,\n        fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings, name='f_re', grid=settings.runawaygrid,\n            f=fre, initr=initr, initp=initp, initxi=initxi, initppar=initppar,\n            initpperp=initpperp, rn0=rn0, n0=n0, rT0=rT0, T0=T0,\n            bc=bc, ad_int_r=ad_int_r, ad_int_p1=ad_int_p1,\n            ad_int_p2=ad_int_p2, fluxlimiterdamping=fluxlimiterdamping)\n\n        self.inittype = INIT_FORWARD\n\n\n    def setInitType(self, inittype):\n        \"\"\"\n        Specifies how the runaway electron distribution function f_re should be\n        initialized from the runaway density n_re.\n\n        :param int inittype: Flag indicating how to initialize f_re.\n        \"\"\"\n        self.inittype = int(inittype)\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n        \"\"\"\n        super().fromdict(data)\n\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        if 'inittype' in data:\n            self.inittype = int(scal(data['inittype']))\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this RunawayElectronDistribution object.\n        \"\"\"\n        d = super().todict()\n        d['inittype'] = self.inittype\n\n        return d",
  "def __init__(self, settings,\n        fre=[0.0], initr=[0.0], initp=[0.0], initxi=[0.0],\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=DistFunc.BC_PHI_CONST,\n        ad_int_r=DistFunc.AD_INTERP_CENTRED,\n        ad_int_p1=DistFunc.AD_INTERP_CENTRED,\n        ad_int_p2=DistFunc.AD_INTERP_CENTRED,\n        ad_jac_r=DistFunc.AD_INTERP_JACOBIAN_LINEAR,\n        ad_jac_p1=DistFunc.AD_INTERP_JACOBIAN_LINEAR, \n        ad_jac_p2=DistFunc.AD_INTERP_JACOBIAN_LINEAR,\n        fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings, name='f_re', grid=settings.runawaygrid,\n            f=fre, initr=initr, initp=initp, initxi=initxi, initppar=initppar,\n            initpperp=initpperp, rn0=rn0, n0=n0, rT0=rT0, T0=T0,\n            bc=bc, ad_int_r=ad_int_r, ad_int_p1=ad_int_p1,\n            ad_int_p2=ad_int_p2, fluxlimiterdamping=fluxlimiterdamping)\n\n        self.inittype = INIT_FORWARD",
  "def setInitType(self, inittype):\n        \"\"\"\n        Specifies how the runaway electron distribution function f_re should be\n        initialized from the runaway density n_re.\n\n        :param int inittype: Flag indicating how to initialize f_re.\n        \"\"\"\n        self.inittype = int(inittype)",
  "def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n        \"\"\"\n        super().fromdict(data)\n\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        if 'inittype' in data:\n            self.inittype = int(scal(data['inittype']))",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this RunawayElectronDistribution object.\n        \"\"\"\n        d = super().todict()\n        d['inittype'] = self.inittype\n\n        return d",
  "def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v",
  "class SPI(UnknownQuantity):\n    \n\n    def __init__(self, settings, rp=None, vp=None, xp=None , VpVolNormFactor=1, rclPrescribedConstant=0.01, velocity=VELOCITY_MODE_NONE, ablation=ABLATION_MODE_NEGLECT, deposition=DEPOSITION_MODE_NEGLECT, heatAbsorbtion=HEAT_ABSORBTION_MODE_NEGLECT, cloudRadiusMode=CLOUD_RADIUS_MODE_NEGLECT, magneticFieldDependenceMode=MAGNETIC_FIELD_DEPENDENCE_MODE_NEGLECT, abl_ioniz=ABL_IONIZ_MODE_NEUTRAL):\n        \"\"\"\n        Constructor.\n        \n        :param DREAMSettings settings: Parent DREAMSettings object.\n        :param numpy.ndarray rp: Initial shard radii.\n        :param numpy.ndarray vp: Initial shard velocities (cartesian coordinates)\n        :param numpy.ndarray xp: Initial shard positions (cartesian coordinates)\n        :param float VpVolNormFactor: Factor used to renormalize the value of VpVol \n                used for calculating the voluma of the flux tubes (eg major radius in \n                case of cylindrical geometry)\n        :param float rclPrescribedConstant: Constant, prescribed radius of the neutral \n                cloud surrounding each pellet shard (only applicable if \n                cloudRadiusMode=CLOUD_RADIUS_MODE_PRESCRIBED_CONSTANT)\n        :param int velocity: Model used for the shard velocities\n        :param int ablation: Model used for shard ablation\n        :param int deposition: Model used for the deposition of the ablated material\n        :param int heatAbsobtion: Model used for absorbtion of heat flowing into the neutral clouds\n        :param int cloudRadiusMode: Mode used for calculating the radius of the neutral clouds\n        :param int magneticFieldDependenceMode: Mode used for calculating the magnetic field dependence of the albation\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.velocity                    = int(velocity)\n        self.ablation                    = int(ablation)\n        self.deposition                  = int(deposition)\n        self.heatAbsorbtion              = int(heatAbsorbtion)\n        self.cloudRadiusMode             = int(cloudRadiusMode)\n        self.VpVolNormFactor             = VpVolNormFactor\n        self.rclPrescribedConstant       = rclPrescribedConstant\n        self.magneticFieldDependenceMode = int(magneticFieldDependenceMode)\n        self.abl_ioniz                   = int(abl_ioniz)\n\n        self.rp       = None\n        self.vp       = None\n        self.xp       = None\n\n\n    def setInitialData(self, rp=None, vp=None, xp=None):\n\n        if rp is not None:\n            if np.isscalar(rp):\n                self.rp = np.asarray([rp])\n            else: self.rp = np.asarray(rp)\n\n        if vp is not None:\n            if np.isscalar(vp):\n                self.vp = np.asarray([vp])\n            else: self.vp = np.asarray(vp)\n\n        if xp is not None:\n            if np.isscalar(xp):\n                self.xp = np.asarray([xp])\n            else: self.xp = np.asarray(xp)\n        \n    def rpDistrParksStatistical(self,rp,kp):\n        \"\"\"\n        Evaluates the shard size distribution function referred to as the \n        'statistical model' in P. Parks 2016 GA report (DOI:10.2172/1344852)\n        \"\"\"\n        return kn(0,rp*kp)*kp**2*rp\n        \n    def sampleRpDistrParksStatistical(self,N,kp):\n        \"\"\"\n        Samples N shard radii according to the distribution function \n        given by rpDistrParksStatistical()\n        \"\"\"\n        # First we calculate the cdf, and then interpolate the cdf-values \n        # back to the corresponding radii at N randomly chosen points between 0 and 1\n        rp_integrate=np.linspace(1e-10/kp,10/kp,5000)\n        cdf=integrate.cumtrapz(y=self.rpDistrParksStatistical(rp_integrate,kp),x=rp_integrate)\n        return np.interp(np.random.uniform(size=N),np.hstack((0.0,cdf)),rp_integrate)\n        \n    def setRpParksStatistical(self, nShard, Ninj, Zs, isotopes, molarFractions, ionNames,  opacity_modes = None, add=True, n=1e0,\n    charged_advection_modes = None, charged_prescribed_advections = None, rChargedPrescribedAdvections = None, tChargedPrescribedAdvections = None,\n    neutral_advection_modes = None, neutral_prescribed_advections = None, rNeutralPrescribedAdvections = None, tNeutralPrescribedAdvections = None,\n    charged_diffusion_modes = None, charged_prescribed_diffusions = None, rChargedPrescribedDiffusions = None, tChargedPrescribedDiffusions = None,\n    neutral_diffusion_modes = None, neutral_prescribed_diffusions = None, rNeutralPrescribedDiffusions = None, tNeutralPrescribedDiffusions = None,\n    **kwargs):\n        \"\"\"\n        sets (or adds) nShard shards with radii distributed accordin to \n        rpDistrParksStatistical(), with the characteristic inverse shard size kp \n        calculated from the given pellet and shattering parameters. Also updates the ion \n        settings with the appropriate molar fractions contributing to each ion species\n        \n        :param int nShard: Number of shards into which the pellet is shattered\n        :param float Ninj: Numbr of particles contained in the pellet\n        :param list Zs: List of charge numbers for every ion species the pellet consists of\n        :param list isotopes: List of isotopes for every ion species the pellet consists of\n        :param numpy.ndarray molarFractions: Molar fraction with which each ion species contribute\n        :param list ionNames: List of names for the ion species to be added and connected \n                  to the ablation of this pellet\n        :param list opacity_modes: List of opacity modes for every ion species the pellet consists of.\n                  If 'None', this argument is omitted when adding the ion species, so that the default \n                  settings (transparent) is used\n        :param bool add: If 'True', add the new pellet shards to the existing ones, otherwise \n             existing shards are cleared\n             \n        :return: the inverse characteristic shard size kp\n        \"\"\"\n        \n        \n        # Calculate solid particle density of the pellet (needed to calculate the \n        # inverse characteristic shard size)\n        molarVolume=0\n        for iZ in range(len(Zs)):\n            for iList in range(len(solidDensityList)):\n                if Zs[iZ]==ZSolidDensityList[iList] and isotopes[iZ]==isotopesSolidDensityList[iList]:\n                    solidDensityIZ=solidDensityList[iList]\n                if Zs[iZ]==ZMolarMassList[iList] and isotopes[iZ]==isotopesMolarMassList[iList]:\n                    molarMassIZ=molarMassList[iList]\n            \n            molarVolume+=molarFractions[iZ]*molarMassIZ/solidDensityIZ\n            \n        solidParticleDensity=N_A/molarVolume\n       \n       \n        # Calculate inverse characteristic shard size\n        kp=(6*np.pi**2*solidParticleDensity*nShard/Ninj)**(1/3)\n        \n        # Sample the shard sizes and rescale to get exactly the \n        # specified number of particles in the pellet\n        rp_init=self.sampleRpDistrParksStatistical(nShard,kp)\n        Ninj_obtained=np.sum(4*np.pi*rp_init**(3)/3/molarVolume*N_A)\n        rp_init*=(Ninj/Ninj_obtained)**(1/3)       \n       \n        if add and self.rp is not None:\n            self.rp=np.concatenate((self.rp,rp_init))\n        else:\n            self.rp=rp_init\n            \n        # Add zeros to the end of SPIMolarFraction for all ion species previously connected to a pellet\n        for ion in self.settings.eqsys.n_i.ions:\n            SPIMolarFractionPrevious=ion.getSPIMolarFraction()\n            if SPIMolarFractionPrevious[0]!=-1:\n                ion.setSPIMolarFraction(np.concatenate((SPIMolarFractionPrevious,np.zeros(nShard))))\n            \n        # Fix arrays of settings to have correct shape if None is specified        \n        if opacity_modes is None:\n            opacity_modes = []\n            for iZ in range(len(Zs)):\n                opacity_modes.append(Ions.ION_OPACITY_MODE_TRANSPARENT)\n                \n        if charged_advection_modes is None:\n            charged_advection_modes = []\n            for iZ in range(len(Zs)):\n                charged_advection_modes.append(Ions.ION_CHARGED_ADVECTION_MODE_NONE)\n        if charged_prescribed_advections is None:\n            charged_prescribed_advections = []\n            for iZ in range(len(Zs)):\n                charged_prescribed_advections.append(None)\n        if rChargedPrescribedAdvections is None:\n            rChargedPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                rChargedPrescribedAdvections.append(None)\n        if tChargedPrescribedAdvections is None:\n            tChargedPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                tChargedPrescribedAdvections.append(None)\n                \n        if neutral_advection_modes is None:\n            neutral_advection_modes = []\n            for iZ in range(len(Zs)):\n                neutral_advection_modes.append(Ions.ION_NEUTRAL_ADVECTION_MODE_NONE)\n        if neutral_prescribed_advections is None:\n            neutral_prescribed_advections = []\n            for iZ in range(len(Zs)):\n                neutral_prescribed_advections.append(None)\n        if rNeutralPrescribedAdvections is None:\n            rNeutralPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                rNeutralPrescribedAdvections.append(None)\n        if tNeutralPrescribedAdvections is None:\n            tNeutralPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                tNeutralPrescribedAdvections.append(None)\n                \n        if charged_diffusion_modes is None:\n            charged_diffusion_modes = []\n            for iZ in range(len(Zs)):\n                charged_diffusion_modes.append(Ions.ION_CHARGED_DIFFUSION_MODE_NONE)\n        if charged_prescribed_diffusions is None:\n            charged_prescribed_diffusions = []\n            for iZ in range(len(Zs)):\n                charged_prescribed_diffusions.append(None)\n        if rChargedPrescribedDiffusions is None:\n            rChargedPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                rChargedPrescribedDiffusions.append(None)\n        if tChargedPrescribedDiffusions is None:\n            tChargedPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                tChargedPrescribedDiffusions.append(None)\n                \n        if neutral_diffusion_modes is None:\n            neutral_diffusion_modes = []\n            for iZ in range(len(Zs)):\n                neutral_diffusion_modes.append(Ions.ION_NEUTRAL_DIFFUSION_MODE_NONE)\n        if neutral_prescribed_diffusions is None:\n            neutral_prescribed_diffusions = []\n            for iZ in range(len(Zs)):\n                neutral_prescribed_diffusions.append(None)\n        if rNeutralPrescribedDiffusions is None:\n            rNeutralPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                rNeutralPrescribedDiffusions.append(None)\n        if tNeutralPrescribedDiffusions is None:\n            tNeutralPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                tNeutralPrescribedDiffusions.append(None)\n                                \n        # Add an ion species connected to this pellet to the ion settings\n        for iZ in range(len(Zs)):\n            \n            # SPIMolarFraction must have the smae length as all pellet shard, \n            # not only the pellet which is initiated here, so set the molar fraction \n            # to zero for previously set shards\n            SPIMolarFraction=np.zeros(len(self.rp))\n            SPIMolarFraction[-nShard:]=molarFractions[iZ]*np.ones(nShard)\n            \n            \n            self.settings.eqsys.n_i.addIon(name=ionNames[iZ], n=n, Z=Zs[iZ], isotope=isotopes[iZ], opacity_mode=opacity_modes[iZ], iontype=Ions.IONS_DYNAMIC_NEUTRAL, SPIMolarFraction=SPIMolarFraction,\n            charged_diffusion_mode = charged_diffusion_modes[iZ], charged_prescribed_diffusion = charged_prescribed_diffusions[iZ], rChargedPrescribedDiffusion = rChargedPrescribedDiffusions[iZ], tChargedPrescribedDiffusion = tChargedPrescribedDiffusions[iZ],\n            neutral_diffusion_mode = neutral_diffusion_modes[iZ], neutral_prescribed_diffusion = neutral_prescribed_diffusions[iZ], rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusions[iZ], tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusions[iZ],\n            charged_advection_mode = charged_advection_modes[iZ], charged_prescribed_advection = charged_prescribed_advections[iZ], rChargedPrescribedAdvection = rChargedPrescribedAdvections[iZ], tChargedPrescribedAdvection = tChargedPrescribedAdvections[iZ],\n            neutral_advection_mode = neutral_advection_modes[iZ], neutral_prescribed_advection = neutral_prescribed_advections[iZ], rNeutralPrescribedAdvection = rNeutralPrescribedAdvections[iZ], tNeutralPrescribedAdvection = tNeutralPrescribedAdvections[iZ],\n            **kwargs)\n            \n            \n              \n        return kp\n        \n    def setShardPositionSinglePoint(self, nShard,shatterPoint,add=True):\n        \"\"\"\n        Sets self.xp to a vector of the (x,y,z)-coordinates of nShard initial\n        pellet shard positions starting from the single point shatterPoint\n        \n        :param int nShard: Number of shards \n        :param numpy.ndarray shatterPoint: (x,y,z)-coordinates for the starting point of the shards to be set\n        :param bool add: If 'True', add the new pellet shard positions to the existing ones, otherwise \n             existing shards are cleared\n        \"\"\"\n        if add and self.xp is not None:\n            self.xp=np.concatenate((self.xp,np.tile(shatterPoint,nShard)))\n        else:\n            self.xp=np.tile(shatterPoint,nShard)\n            \n    def setShardVelocitiesUniform(self, nShard,abs_vp_mean,abs_vp_diff,alpha_max,nDim=2,add=True, shards=None):\n        \"\"\"\n        Sets self.vp to a vector storing the (x,y,z)-components of nShard shard velosities,\n        assuming a uniform velocity distribution over a nDim-dimensional cone whose axis\n        is anti-parallell to the x-axis. TODO: implement support for an arbitrary axis?\n        \n        :param int nShard: Number of shards\n        :param float abs_vp_mean: Mean of the magnitude of the shard velocities\n        :param float abs_vp_diff: width of the uniform distribution of the magnitude of the shard velocities\n        :param float alpha_max: Span of divergence angle (ie twice the opening angle of the cone)\n        :param int nDim: number of dimensions into which the shards should be spread\n        :param bool add: If 'True', add the new pellet shard velocities to the existing ones, otherwise \n             existing shards are cleared\n        :param slice shards: indices of existing shards whose velocities should be updated. If not 'None', \n                add is set to 'False' and nShard is set to the number of indices to be updated\n        \"\"\"\n        \n        if shards is not None:\n        \tnShard=len(self.vp[shards])\n        \tadd=False\n        \n        # Sample magnitude of velocities\n        abs_vp_init=(abs_vp_mean+abs_vp_diff*(-1+2*np.random.uniform(size=nShard)))\n        \n        # Sample directions uniformly over a nDim-dimensional cone and set the velocity vectors\n        vp_init=np.zeros(3*nShard)\n        if nDim==1:\n            # in 1D, the \"cone\" simply becomes a straight line\n            vp_init[0::3]=-abs_vp_init\n            \n        elif nDim==2:\n            # in 2D, the cone becomes a circle sector\n            alpha=alpha_max*(-1+2*np.random.uniform(size=nShard))\n            vp_init[0::3]=-abs_vp_init*np.cos(alpha)\n            vp_init[1::3]=abs_vp_init*np.sin(alpha)\n            \n        elif nDim==3:\n            # The solid angle covered by the part of the cone between alpa and d(alpha) \n            # is proportional to sin(alpha), and the normalised probability distribution \n            # becomes f(alpha)=sin(alpha)/(1-cos(alpha_max/2)). We sample from this\n            # distribution by applying the inverse cdf to uniformly drawn numbers\n            # between 0 and 1\n            alpha=np.arccos(1-np.random.uniform(size=nShard)*(1-np.cos(alpha_max/2)))\n            \n            # The angle in the yz-plane is simply drawn randomly\n            phi=2*np.pi*np.random.uniform(size=nShard)\n            \n            # Finally calculate the velocity vectors\n            vp_init[0::3]=-abs_vp_init*np.cos(alpha)\n            vp_init[1::3]=abs_vp_init*np.sin(alpha)*np.cos(phi)\n            vp_init[2::3]=abs_vp_init*np.sin(alpha)*np.sin(phi)\n            \n        else:\n            raise EquationException(\"spi: Invalid number of dimensions into which the pellet shards are spread\")\n            \n        if add and self.vp is not None:\n            self.vp=np.concatenate((self.vp,vp_init))\n        elif shards is not None:\n        \t# Pick out the components of the stored shard velocities...\n        \tvpx=self.vp[0::3]\n        \tvpy=self.vp[1::3]\n        \tvpz=self.vp[2::3]\n        \t\n        \t# ... Change the velocities of the shards specified in the input...\n        \tvpx[shards]=vp_init[0::3]\n        \tvpy[shards]=vp_init[1::3]\n        \tvpz[shards]=vp_init[2::3]\n        \t\n        \t# ...and finallyset the stored velocities to the updated ones\n        \tself.vp[0::3]=vpx\n        \tself.vp[1::3]=vpy\n        \tself.vp[2::3]=vpz\n        else:\n            self.vp=vp_init\n            \n    def setParamsVallhagenMSc(self, nShard, Ninj, Zs, isotopes, molarFractions, ionNames, shatterPoint, abs_vp_mean,abs_vp_diff,alpha_max,nDim=2, add=True, opacity_modes = None, **kwargs):\n        \"\"\"\n        Wrapper for setRpParksStatistical(), setShardPositionSinglePoint() and setShardVelocitiesUniform(),\n        which combined are used to set up an SPI-scenario similar to those in Oskar Vallhagens MSc thesis\n        (available at https://hdl.handle.net/20.500.12380/302296)\n        \"\"\"\n        \n        kp=self.setRpParksStatistical(nShard, Ninj, Zs, isotopes, molarFractions, ionNames, opacity_modes, add, **kwargs)\n        self.setShardPositionSinglePoint(nShard,shatterPoint,add)\n        self.setShardVelocitiesUniform(nShard,abs_vp_mean,abs_vp_diff,alpha_max,nDim,add)\n        return kp\n        \n    def setVpVolNormFactor(self,VpVolNormFactor):\n        self.VpVolNormFactor=VpVolNormFactor\n\n    def setRclPrescribedConstant(self,rclPrescribedConstant):\n        self.rclPrescribedConstant=rclPrescribedConstant\n\n\n    def setVelocity(self, velocity):\n        \"\"\"\n        Specifies mode to calculate shard velocities.\n        \"\"\"\n        self.velocity = int(velocity)\n\n\n    def setAblation(self, ablation):\n        \"\"\"\n        Specifies which model to use for calculating the\n        ablation rate.\n        \"\"\"\n        self.ablation = int(ablation)\n\n    def setDeposition(self, deposition):\n        \"\"\"\n        Specifies which model to use for calculating the\n        deposition of ablated material.\n        \"\"\"\n        self.deposition = int(deposition)\n\n    def setHeatAbsorbtion(self, heatAbsorbtion):\n        \"\"\"\n        Specifies which model to use for calculating the\n        heat absorbtion in the neutral pellet cloud\n        \"\"\"\n        self.heatAbsorbtion = int(heatAbsorbtion)\n\n    def setCloudRadiusMode(self, cloudRadiusMode):\n        \"\"\"\n        Specifies which model to use for calculating the\n        radius of the the neutral pellet cloud\n        \"\"\"\n        self.cloudRadiusMode = int(cloudRadiusMode)\n        \n    def setMagneticFieldDependenceMode(self, magneticFieldDependenceMode):\n        \"\"\"\n        Specifies which model to use for calculating the\n        magnetic field dependence of the ablation\n        \"\"\"\n        self.magneticFieldDependenceMode = int(magneticFieldDependenceMode)\n        \n    def setAblIoniz(self, abl_ioniz):\n        \"\"\"\n        Specifies which model to use for calculating the\n        charge state distribution with which the recently \n        ablated material is deposited\n        \"\"\"\n        self.abl_ioniz = int(abl_ioniz)\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'velocity' in data:\n            self.velocity       = int(data['velocity'])\n        if 'ablation' in data:\n            self.ablation       = int(data['ablation'])\n        if 'deposition' in data:\n            self.deposition     = int(data['deposition'])\n        if 'heatAbsorption' in data:\n            self.heatAbsorbtion = int(data['heatAbsorbtion'])\n        if 'cloudRadiusMode' in data:\n            self.cloudRadiusMode = int(data['cloudRadiusMode'])\n        if 'magneticFieldDependenceMode' in data:\n            self.magneticFieldDependenceMode = int(data['magneticFieldDependenceMode'])\n        if 'abl_ioniz' in data:\n            self.abl_ioniz = int(data['abl_ioniz'])\n\n        if 'VpVolNormFactor' in data:\n            self.VpVolNormFactor = data['VpVolNormFactor']\n        if 'rclPrescribedConstant' in data:\n            self.rclPrescribedConstant = data['rclPrescribedConstant']\n        if 'rp' in data['init']:\n            self.rp              = data['init']['rp']\n        if 'vp' in data['init']:\n            self.vp              = data['init']['vp']\n        if 'xp' in data['init']:\n            self.xp              = data['init']['xp']\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this SPI object.\n        \"\"\"\n        data = {\n            'velocity': self.velocity,\n            'ablation': self.ablation,\n            'deposition': self.deposition,\n            'heatAbsorbtion': self.heatAbsorbtion,\n            'cloudRadiusMode': self.cloudRadiusMode,\n            'magneticFieldDependenceMode': self.magneticFieldDependenceMode,\n            'abl_ioniz': self.abl_ioniz,\n            'VpVolNormFactor': self.VpVolNormFactor,\n            'rclPrescribedConstant': self.rclPrescribedConstant\n        }\n        \n        # If no SPI settings have been given, set everything to zero (to avoid a DREAMIOException)\n        # Before this stage it is usefull to use None to indicate if any SPI settings have been made yet,\n        # to know if there are any previous shards to add the new ones to, so therefore\n        # we don't set this default setting until this stage\n        if self.rp is None:\n            self.rp=np.array([0])\n        if self.vp is None:\n            self.vp=np.array([0,0,0])\n        if self.xp is None:\n            self.xp=np.array([0,0,0])\n            \n        data['init'] = {\n                'rp': self.rp,\n                'vp': self.vp,\n                'xp': self.xp\n        }\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if type(self.velocity) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'velocity'. Expected integer.\")\n        if type(self.ablation) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'ablation'. Expected integer.\")\n        if type(self.deposition) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'deposition'. Expected integer.\")\n        if type(self.heatAbsorbtion) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'heatAbsorbtion'. Expected integer.\")\n\n\n\n    def verifySettingsPrescribedInitialData(self):\n        if vp.size!=3*rp.size:\n            raise EquationException(\"Missmatch in size of initial data arrays for rp and vp. Expected vp to have a size 3 times the size of rp\")\n        if xp.size!=3*rp.size:\n            raise EquationException(\"Missmatch in size of initial data arrays for rp and xp. Expected xp to have a size 3 times the size of rp\")",
  "def __init__(self, settings, rp=None, vp=None, xp=None , VpVolNormFactor=1, rclPrescribedConstant=0.01, velocity=VELOCITY_MODE_NONE, ablation=ABLATION_MODE_NEGLECT, deposition=DEPOSITION_MODE_NEGLECT, heatAbsorbtion=HEAT_ABSORBTION_MODE_NEGLECT, cloudRadiusMode=CLOUD_RADIUS_MODE_NEGLECT, magneticFieldDependenceMode=MAGNETIC_FIELD_DEPENDENCE_MODE_NEGLECT, abl_ioniz=ABL_IONIZ_MODE_NEUTRAL):\n        \"\"\"\n        Constructor.\n        \n        :param DREAMSettings settings: Parent DREAMSettings object.\n        :param numpy.ndarray rp: Initial shard radii.\n        :param numpy.ndarray vp: Initial shard velocities (cartesian coordinates)\n        :param numpy.ndarray xp: Initial shard positions (cartesian coordinates)\n        :param float VpVolNormFactor: Factor used to renormalize the value of VpVol \n                used for calculating the voluma of the flux tubes (eg major radius in \n                case of cylindrical geometry)\n        :param float rclPrescribedConstant: Constant, prescribed radius of the neutral \n                cloud surrounding each pellet shard (only applicable if \n                cloudRadiusMode=CLOUD_RADIUS_MODE_PRESCRIBED_CONSTANT)\n        :param int velocity: Model used for the shard velocities\n        :param int ablation: Model used for shard ablation\n        :param int deposition: Model used for the deposition of the ablated material\n        :param int heatAbsobtion: Model used for absorbtion of heat flowing into the neutral clouds\n        :param int cloudRadiusMode: Mode used for calculating the radius of the neutral clouds\n        :param int magneticFieldDependenceMode: Mode used for calculating the magnetic field dependence of the albation\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.velocity                    = int(velocity)\n        self.ablation                    = int(ablation)\n        self.deposition                  = int(deposition)\n        self.heatAbsorbtion              = int(heatAbsorbtion)\n        self.cloudRadiusMode             = int(cloudRadiusMode)\n        self.VpVolNormFactor             = VpVolNormFactor\n        self.rclPrescribedConstant       = rclPrescribedConstant\n        self.magneticFieldDependenceMode = int(magneticFieldDependenceMode)\n        self.abl_ioniz                   = int(abl_ioniz)\n\n        self.rp       = None\n        self.vp       = None\n        self.xp       = None",
  "def setInitialData(self, rp=None, vp=None, xp=None):\n\n        if rp is not None:\n            if np.isscalar(rp):\n                self.rp = np.asarray([rp])\n            else: self.rp = np.asarray(rp)\n\n        if vp is not None:\n            if np.isscalar(vp):\n                self.vp = np.asarray([vp])\n            else: self.vp = np.asarray(vp)\n\n        if xp is not None:\n            if np.isscalar(xp):\n                self.xp = np.asarray([xp])\n            else: self.xp = np.asarray(xp)",
  "def rpDistrParksStatistical(self,rp,kp):\n        \"\"\"\n        Evaluates the shard size distribution function referred to as the \n        'statistical model' in P. Parks 2016 GA report (DOI:10.2172/1344852)\n        \"\"\"\n        return kn(0,rp*kp)*kp**2*rp",
  "def sampleRpDistrParksStatistical(self,N,kp):\n        \"\"\"\n        Samples N shard radii according to the distribution function \n        given by rpDistrParksStatistical()\n        \"\"\"\n        # First we calculate the cdf, and then interpolate the cdf-values \n        # back to the corresponding radii at N randomly chosen points between 0 and 1\n        rp_integrate=np.linspace(1e-10/kp,10/kp,5000)\n        cdf=integrate.cumtrapz(y=self.rpDistrParksStatistical(rp_integrate,kp),x=rp_integrate)\n        return np.interp(np.random.uniform(size=N),np.hstack((0.0,cdf)),rp_integrate)",
  "def setRpParksStatistical(self, nShard, Ninj, Zs, isotopes, molarFractions, ionNames,  opacity_modes = None, add=True, n=1e0,\n    charged_advection_modes = None, charged_prescribed_advections = None, rChargedPrescribedAdvections = None, tChargedPrescribedAdvections = None,\n    neutral_advection_modes = None, neutral_prescribed_advections = None, rNeutralPrescribedAdvections = None, tNeutralPrescribedAdvections = None,\n    charged_diffusion_modes = None, charged_prescribed_diffusions = None, rChargedPrescribedDiffusions = None, tChargedPrescribedDiffusions = None,\n    neutral_diffusion_modes = None, neutral_prescribed_diffusions = None, rNeutralPrescribedDiffusions = None, tNeutralPrescribedDiffusions = None,\n    **kwargs):\n        \"\"\"\n        sets (or adds) nShard shards with radii distributed accordin to \n        rpDistrParksStatistical(), with the characteristic inverse shard size kp \n        calculated from the given pellet and shattering parameters. Also updates the ion \n        settings with the appropriate molar fractions contributing to each ion species\n        \n        :param int nShard: Number of shards into which the pellet is shattered\n        :param float Ninj: Numbr of particles contained in the pellet\n        :param list Zs: List of charge numbers for every ion species the pellet consists of\n        :param list isotopes: List of isotopes for every ion species the pellet consists of\n        :param numpy.ndarray molarFractions: Molar fraction with which each ion species contribute\n        :param list ionNames: List of names for the ion species to be added and connected \n                  to the ablation of this pellet\n        :param list opacity_modes: List of opacity modes for every ion species the pellet consists of.\n                  If 'None', this argument is omitted when adding the ion species, so that the default \n                  settings (transparent) is used\n        :param bool add: If 'True', add the new pellet shards to the existing ones, otherwise \n             existing shards are cleared\n             \n        :return: the inverse characteristic shard size kp\n        \"\"\"\n        \n        \n        # Calculate solid particle density of the pellet (needed to calculate the \n        # inverse characteristic shard size)\n        molarVolume=0\n        for iZ in range(len(Zs)):\n            for iList in range(len(solidDensityList)):\n                if Zs[iZ]==ZSolidDensityList[iList] and isotopes[iZ]==isotopesSolidDensityList[iList]:\n                    solidDensityIZ=solidDensityList[iList]\n                if Zs[iZ]==ZMolarMassList[iList] and isotopes[iZ]==isotopesMolarMassList[iList]:\n                    molarMassIZ=molarMassList[iList]\n            \n            molarVolume+=molarFractions[iZ]*molarMassIZ/solidDensityIZ\n            \n        solidParticleDensity=N_A/molarVolume\n       \n       \n        # Calculate inverse characteristic shard size\n        kp=(6*np.pi**2*solidParticleDensity*nShard/Ninj)**(1/3)\n        \n        # Sample the shard sizes and rescale to get exactly the \n        # specified number of particles in the pellet\n        rp_init=self.sampleRpDistrParksStatistical(nShard,kp)\n        Ninj_obtained=np.sum(4*np.pi*rp_init**(3)/3/molarVolume*N_A)\n        rp_init*=(Ninj/Ninj_obtained)**(1/3)       \n       \n        if add and self.rp is not None:\n            self.rp=np.concatenate((self.rp,rp_init))\n        else:\n            self.rp=rp_init\n            \n        # Add zeros to the end of SPIMolarFraction for all ion species previously connected to a pellet\n        for ion in self.settings.eqsys.n_i.ions:\n            SPIMolarFractionPrevious=ion.getSPIMolarFraction()\n            if SPIMolarFractionPrevious[0]!=-1:\n                ion.setSPIMolarFraction(np.concatenate((SPIMolarFractionPrevious,np.zeros(nShard))))\n            \n        # Fix arrays of settings to have correct shape if None is specified        \n        if opacity_modes is None:\n            opacity_modes = []\n            for iZ in range(len(Zs)):\n                opacity_modes.append(Ions.ION_OPACITY_MODE_TRANSPARENT)\n                \n        if charged_advection_modes is None:\n            charged_advection_modes = []\n            for iZ in range(len(Zs)):\n                charged_advection_modes.append(Ions.ION_CHARGED_ADVECTION_MODE_NONE)\n        if charged_prescribed_advections is None:\n            charged_prescribed_advections = []\n            for iZ in range(len(Zs)):\n                charged_prescribed_advections.append(None)\n        if rChargedPrescribedAdvections is None:\n            rChargedPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                rChargedPrescribedAdvections.append(None)\n        if tChargedPrescribedAdvections is None:\n            tChargedPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                tChargedPrescribedAdvections.append(None)\n                \n        if neutral_advection_modes is None:\n            neutral_advection_modes = []\n            for iZ in range(len(Zs)):\n                neutral_advection_modes.append(Ions.ION_NEUTRAL_ADVECTION_MODE_NONE)\n        if neutral_prescribed_advections is None:\n            neutral_prescribed_advections = []\n            for iZ in range(len(Zs)):\n                neutral_prescribed_advections.append(None)\n        if rNeutralPrescribedAdvections is None:\n            rNeutralPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                rNeutralPrescribedAdvections.append(None)\n        if tNeutralPrescribedAdvections is None:\n            tNeutralPrescribedAdvections = []\n            for iZ in range(len(Zs)):\n                tNeutralPrescribedAdvections.append(None)\n                \n        if charged_diffusion_modes is None:\n            charged_diffusion_modes = []\n            for iZ in range(len(Zs)):\n                charged_diffusion_modes.append(Ions.ION_CHARGED_DIFFUSION_MODE_NONE)\n        if charged_prescribed_diffusions is None:\n            charged_prescribed_diffusions = []\n            for iZ in range(len(Zs)):\n                charged_prescribed_diffusions.append(None)\n        if rChargedPrescribedDiffusions is None:\n            rChargedPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                rChargedPrescribedDiffusions.append(None)\n        if tChargedPrescribedDiffusions is None:\n            tChargedPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                tChargedPrescribedDiffusions.append(None)\n                \n        if neutral_diffusion_modes is None:\n            neutral_diffusion_modes = []\n            for iZ in range(len(Zs)):\n                neutral_diffusion_modes.append(Ions.ION_NEUTRAL_DIFFUSION_MODE_NONE)\n        if neutral_prescribed_diffusions is None:\n            neutral_prescribed_diffusions = []\n            for iZ in range(len(Zs)):\n                neutral_prescribed_diffusions.append(None)\n        if rNeutralPrescribedDiffusions is None:\n            rNeutralPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                rNeutralPrescribedDiffusions.append(None)\n        if tNeutralPrescribedDiffusions is None:\n            tNeutralPrescribedDiffusions = []\n            for iZ in range(len(Zs)):\n                tNeutralPrescribedDiffusions.append(None)\n                                \n        # Add an ion species connected to this pellet to the ion settings\n        for iZ in range(len(Zs)):\n            \n            # SPIMolarFraction must have the smae length as all pellet shard, \n            # not only the pellet which is initiated here, so set the molar fraction \n            # to zero for previously set shards\n            SPIMolarFraction=np.zeros(len(self.rp))\n            SPIMolarFraction[-nShard:]=molarFractions[iZ]*np.ones(nShard)\n            \n            \n            self.settings.eqsys.n_i.addIon(name=ionNames[iZ], n=n, Z=Zs[iZ], isotope=isotopes[iZ], opacity_mode=opacity_modes[iZ], iontype=Ions.IONS_DYNAMIC_NEUTRAL, SPIMolarFraction=SPIMolarFraction,\n            charged_diffusion_mode = charged_diffusion_modes[iZ], charged_prescribed_diffusion = charged_prescribed_diffusions[iZ], rChargedPrescribedDiffusion = rChargedPrescribedDiffusions[iZ], tChargedPrescribedDiffusion = tChargedPrescribedDiffusions[iZ],\n            neutral_diffusion_mode = neutral_diffusion_modes[iZ], neutral_prescribed_diffusion = neutral_prescribed_diffusions[iZ], rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusions[iZ], tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusions[iZ],\n            charged_advection_mode = charged_advection_modes[iZ], charged_prescribed_advection = charged_prescribed_advections[iZ], rChargedPrescribedAdvection = rChargedPrescribedAdvections[iZ], tChargedPrescribedAdvection = tChargedPrescribedAdvections[iZ],\n            neutral_advection_mode = neutral_advection_modes[iZ], neutral_prescribed_advection = neutral_prescribed_advections[iZ], rNeutralPrescribedAdvection = rNeutralPrescribedAdvections[iZ], tNeutralPrescribedAdvection = tNeutralPrescribedAdvections[iZ],\n            **kwargs)\n            \n            \n              \n        return kp",
  "def setShardPositionSinglePoint(self, nShard,shatterPoint,add=True):\n        \"\"\"\n        Sets self.xp to a vector of the (x,y,z)-coordinates of nShard initial\n        pellet shard positions starting from the single point shatterPoint\n        \n        :param int nShard: Number of shards \n        :param numpy.ndarray shatterPoint: (x,y,z)-coordinates for the starting point of the shards to be set\n        :param bool add: If 'True', add the new pellet shard positions to the existing ones, otherwise \n             existing shards are cleared\n        \"\"\"\n        if add and self.xp is not None:\n            self.xp=np.concatenate((self.xp,np.tile(shatterPoint,nShard)))\n        else:\n            self.xp=np.tile(shatterPoint,nShard)",
  "def setShardVelocitiesUniform(self, nShard,abs_vp_mean,abs_vp_diff,alpha_max,nDim=2,add=True, shards=None):\n        \"\"\"\n        Sets self.vp to a vector storing the (x,y,z)-components of nShard shard velosities,\n        assuming a uniform velocity distribution over a nDim-dimensional cone whose axis\n        is anti-parallell to the x-axis. TODO: implement support for an arbitrary axis?\n        \n        :param int nShard: Number of shards\n        :param float abs_vp_mean: Mean of the magnitude of the shard velocities\n        :param float abs_vp_diff: width of the uniform distribution of the magnitude of the shard velocities\n        :param float alpha_max: Span of divergence angle (ie twice the opening angle of the cone)\n        :param int nDim: number of dimensions into which the shards should be spread\n        :param bool add: If 'True', add the new pellet shard velocities to the existing ones, otherwise \n             existing shards are cleared\n        :param slice shards: indices of existing shards whose velocities should be updated. If not 'None', \n                add is set to 'False' and nShard is set to the number of indices to be updated\n        \"\"\"\n        \n        if shards is not None:\n        \tnShard=len(self.vp[shards])\n        \tadd=False\n        \n        # Sample magnitude of velocities\n        abs_vp_init=(abs_vp_mean+abs_vp_diff*(-1+2*np.random.uniform(size=nShard)))\n        \n        # Sample directions uniformly over a nDim-dimensional cone and set the velocity vectors\n        vp_init=np.zeros(3*nShard)\n        if nDim==1:\n            # in 1D, the \"cone\" simply becomes a straight line\n            vp_init[0::3]=-abs_vp_init\n            \n        elif nDim==2:\n            # in 2D, the cone becomes a circle sector\n            alpha=alpha_max*(-1+2*np.random.uniform(size=nShard))\n            vp_init[0::3]=-abs_vp_init*np.cos(alpha)\n            vp_init[1::3]=abs_vp_init*np.sin(alpha)\n            \n        elif nDim==3:\n            # The solid angle covered by the part of the cone between alpa and d(alpha) \n            # is proportional to sin(alpha), and the normalised probability distribution \n            # becomes f(alpha)=sin(alpha)/(1-cos(alpha_max/2)). We sample from this\n            # distribution by applying the inverse cdf to uniformly drawn numbers\n            # between 0 and 1\n            alpha=np.arccos(1-np.random.uniform(size=nShard)*(1-np.cos(alpha_max/2)))\n            \n            # The angle in the yz-plane is simply drawn randomly\n            phi=2*np.pi*np.random.uniform(size=nShard)\n            \n            # Finally calculate the velocity vectors\n            vp_init[0::3]=-abs_vp_init*np.cos(alpha)\n            vp_init[1::3]=abs_vp_init*np.sin(alpha)*np.cos(phi)\n            vp_init[2::3]=abs_vp_init*np.sin(alpha)*np.sin(phi)\n            \n        else:\n            raise EquationException(\"spi: Invalid number of dimensions into which the pellet shards are spread\")\n            \n        if add and self.vp is not None:\n            self.vp=np.concatenate((self.vp,vp_init))\n        elif shards is not None:\n        \t# Pick out the components of the stored shard velocities...\n        \tvpx=self.vp[0::3]\n        \tvpy=self.vp[1::3]\n        \tvpz=self.vp[2::3]\n        \t\n        \t# ... Change the velocities of the shards specified in the input...\n        \tvpx[shards]=vp_init[0::3]\n        \tvpy[shards]=vp_init[1::3]\n        \tvpz[shards]=vp_init[2::3]\n        \t\n        \t# ...and finallyset the stored velocities to the updated ones\n        \tself.vp[0::3]=vpx\n        \tself.vp[1::3]=vpy\n        \tself.vp[2::3]=vpz\n        else:\n            self.vp=vp_init",
  "def setParamsVallhagenMSc(self, nShard, Ninj, Zs, isotopes, molarFractions, ionNames, shatterPoint, abs_vp_mean,abs_vp_diff,alpha_max,nDim=2, add=True, opacity_modes = None, **kwargs):\n        \"\"\"\n        Wrapper for setRpParksStatistical(), setShardPositionSinglePoint() and setShardVelocitiesUniform(),\n        which combined are used to set up an SPI-scenario similar to those in Oskar Vallhagens MSc thesis\n        (available at https://hdl.handle.net/20.500.12380/302296)\n        \"\"\"\n        \n        kp=self.setRpParksStatistical(nShard, Ninj, Zs, isotopes, molarFractions, ionNames, opacity_modes, add, **kwargs)\n        self.setShardPositionSinglePoint(nShard,shatterPoint,add)\n        self.setShardVelocitiesUniform(nShard,abs_vp_mean,abs_vp_diff,alpha_max,nDim,add)\n        return kp",
  "def setVpVolNormFactor(self,VpVolNormFactor):\n        self.VpVolNormFactor=VpVolNormFactor",
  "def setRclPrescribedConstant(self,rclPrescribedConstant):\n        self.rclPrescribedConstant=rclPrescribedConstant",
  "def setVelocity(self, velocity):\n        \"\"\"\n        Specifies mode to calculate shard velocities.\n        \"\"\"\n        self.velocity = int(velocity)",
  "def setAblation(self, ablation):\n        \"\"\"\n        Specifies which model to use for calculating the\n        ablation rate.\n        \"\"\"\n        self.ablation = int(ablation)",
  "def setDeposition(self, deposition):\n        \"\"\"\n        Specifies which model to use for calculating the\n        deposition of ablated material.\n        \"\"\"\n        self.deposition = int(deposition)",
  "def setHeatAbsorbtion(self, heatAbsorbtion):\n        \"\"\"\n        Specifies which model to use for calculating the\n        heat absorbtion in the neutral pellet cloud\n        \"\"\"\n        self.heatAbsorbtion = int(heatAbsorbtion)",
  "def setCloudRadiusMode(self, cloudRadiusMode):\n        \"\"\"\n        Specifies which model to use for calculating the\n        radius of the the neutral pellet cloud\n        \"\"\"\n        self.cloudRadiusMode = int(cloudRadiusMode)",
  "def setMagneticFieldDependenceMode(self, magneticFieldDependenceMode):\n        \"\"\"\n        Specifies which model to use for calculating the\n        magnetic field dependence of the ablation\n        \"\"\"\n        self.magneticFieldDependenceMode = int(magneticFieldDependenceMode)",
  "def setAblIoniz(self, abl_ioniz):\n        \"\"\"\n        Specifies which model to use for calculating the\n        charge state distribution with which the recently \n        ablated material is deposited\n        \"\"\"\n        self.abl_ioniz = int(abl_ioniz)",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'velocity' in data:\n            self.velocity       = int(data['velocity'])\n        if 'ablation' in data:\n            self.ablation       = int(data['ablation'])\n        if 'deposition' in data:\n            self.deposition     = int(data['deposition'])\n        if 'heatAbsorption' in data:\n            self.heatAbsorbtion = int(data['heatAbsorbtion'])\n        if 'cloudRadiusMode' in data:\n            self.cloudRadiusMode = int(data['cloudRadiusMode'])\n        if 'magneticFieldDependenceMode' in data:\n            self.magneticFieldDependenceMode = int(data['magneticFieldDependenceMode'])\n        if 'abl_ioniz' in data:\n            self.abl_ioniz = int(data['abl_ioniz'])\n\n        if 'VpVolNormFactor' in data:\n            self.VpVolNormFactor = data['VpVolNormFactor']\n        if 'rclPrescribedConstant' in data:\n            self.rclPrescribedConstant = data['rclPrescribedConstant']\n        if 'rp' in data['init']:\n            self.rp              = data['init']['rp']\n        if 'vp' in data['init']:\n            self.vp              = data['init']['vp']\n        if 'xp' in data['init']:\n            self.xp              = data['init']['xp']",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this SPI object.\n        \"\"\"\n        data = {\n            'velocity': self.velocity,\n            'ablation': self.ablation,\n            'deposition': self.deposition,\n            'heatAbsorbtion': self.heatAbsorbtion,\n            'cloudRadiusMode': self.cloudRadiusMode,\n            'magneticFieldDependenceMode': self.magneticFieldDependenceMode,\n            'abl_ioniz': self.abl_ioniz,\n            'VpVolNormFactor': self.VpVolNormFactor,\n            'rclPrescribedConstant': self.rclPrescribedConstant\n        }\n        \n        # If no SPI settings have been given, set everything to zero (to avoid a DREAMIOException)\n        # Before this stage it is usefull to use None to indicate if any SPI settings have been made yet,\n        # to know if there are any previous shards to add the new ones to, so therefore\n        # we don't set this default setting until this stage\n        if self.rp is None:\n            self.rp=np.array([0])\n        if self.vp is None:\n            self.vp=np.array([0,0,0])\n        if self.xp is None:\n            self.xp=np.array([0,0,0])\n            \n        data['init'] = {\n                'rp': self.rp,\n                'vp': self.vp,\n                'xp': self.xp\n        }\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if type(self.velocity) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'velocity'. Expected integer.\")\n        if type(self.ablation) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'ablation'. Expected integer.\")\n        if type(self.deposition) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'deposition'. Expected integer.\")\n        if type(self.heatAbsorbtion) != int:\n            raise EquationException(\"spi: Invalid value assigned to 'heatAbsorbtion'. Expected integer.\")",
  "def verifySettingsPrescribedInitialData(self):\n        if vp.size!=3*rp.size:\n            raise EquationException(\"Missmatch in size of initial data arrays for rp and vp. Expected vp to have a size 3 times the size of rp\")\n        if xp.size!=3*rp.size:\n            raise EquationException(\"Missmatch in size of initial data arrays for rp and xp. Expected xp to have a size 3 times the size of rp\")",
  "class IonSpecies:\n    \n    def __init__(self, settings, name, Z, ttype=0, Z0=None, isotope=0, SPIMolarFraction=-1.0, opacity_mode = ION_OPACITY_MODE_TRANSPARENT, \n        charged_diffusion_mode=ION_CHARGED_DIFFUSION_MODE_NONE, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None,\n        neutral_diffusion_mode=ION_NEUTRAL_DIFFUSION_MODE_NONE, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None,\n        charged_advection_mode=ION_CHARGED_ADVECTION_MODE_NONE, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None,\n        neutral_advection_mode=ION_NEUTRAL_ADVECTION_MODE_NONE, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None,\n        t_transp_expdecay_all_cs = None, t_transp_start_expdecay_all_cs = 0, diffusion_initial_all_cs = None, diffusion_final_all_cs = 0, advection_initial_all_cs = None, advection_final_all_cs = 0, r_expdecay_all_cs = None, t_expdecay_all_cs = None,        \n        T=None, n=None, r=None, t=None, interpr=None, interpt=None, tritium=False, hydrogen=False):\n        \"\"\"\n        Constructor.\n\n        :param DREAMSettings settings: Parent DREAMSettings object.\n        :param str name:               Name by which the ion species will be referred to.\n        :param int Z:                  Ion charge number.\n        :param int isotope:            Ion mass number.\n        :param int ttype:              Method to use for evolving ions in time.\n        :param int Z0:                 Charge state to populate with given density.\n        :param float n:                Ion density (can be either a scalar, 1D array or 2D array, depending on the other input parameters)\n        :param float SPIMolarFraction: Molar fraction of the SPI injection (if any). A negative value means that this species is not part of the SPI injection \n        :param T:                      Ion initial temperature (can be scalar for uniform temperature, otherwise 1D array matching `r` in size)\n        :param numpy.ndarray r:        Radial grid on which the input density is defined.\n        :param numpy.ndarray t:        Time grid on which the input density is defined.\n        :param numpy.ndarray interpr:  Radial grid onto which ion densities should be interpolated.\n        :param numpy.ndarray interpt:  Time grid onto which ion densities should be interpolated.\n        :param bool tritium:           If ``True``, this ion species is treated as Tritium.\n        :param bool hydrogen:          If ``True``, this ion species is treated as Hydrogen.\n        \"\"\"\n        if ';' in name:\n            raise EquationException(\"ion_species: '{}': Invalid character found in ion name: '{}'.\".format(name, ';'))\n\n        self.settings = settings\n        self.name     = name\n        self.Z        = int(Z)\n        self.isotope  = int(isotope)\n        self.ttype    = None\n        self.tritium  = tritium\n        self.hydrogen = hydrogen\n        self.opacity_mode = opacity_mode\n        self.charged_diffusion_mode = None\n        self.neutral_diffusion_mode = None\n        self.charged_advection_mode = None\n        self.neutral_advection_mode = None\n\n        self.setSPIMolarFraction(SPIMolarFraction)\n\n        if self.tritium and self.hydrogen:\n            raise EquationException(\"ion_species: '{}': Ion species indicated as both Tritium and Hydrogen simultaneously.\")\n\n        # Emit warning if 'T' is used as name but 'tritium = False',\n        # as this may indicate a user error\n        if name == 'T' and tritium == False:\n            print(\"WARNING: Ion species with name 'T' added, but 'tritium = False'.\")\n        if name == 'H' and hydrogen == False:\n            print(\"WARNING: Ion species with name 'H' added, but 'hydrogen = False'.\")\n\n        self.source_n = np.zeros((self.Z+1, 1))\n        self.source_t = np.array([0])\n        self.source_type = ION_SOURCE_NONE\n\n        self.n = None\n        self.r = None\n        self.t = None\n        if ttype == IONS_PRESCRIBED:\n            if Z0 is not None:\n                self.initialize_prescribed_charge_state(Z0=Z0, n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n            else:\n                self.initialize_prescribed(n=n, r=r, t=t)\n        elif ttype == IONS_DYNAMIC:\n            if Z0 is not None:\n                self.initialize_dynamic_charge_state(Z0=Z0, n=n, r=r, interpr=interpr)\n            else:\n                self.initialize_dynamic(n=n, r=r)\n        elif ttype == IONS_EQUILIBRIUM:\n            self.initialize_equilibrium(n=n, r=r, Z0=Z0)\n        elif Z0 is not None:\n            print(\"WARNING: Charge state Z0 given, but ion type is not simply 'prescribed', 'dynamic' or 'equilibrium'. Hence, Z0 is ignored.\")\n        \n        # TYPES AVAILABLE ONLY IN THIS INTERFACE\n        elif ttype == IONS_DYNAMIC_NEUTRAL:\n            self.initialize_dynamic_neutral(n=n, r=r, interpr=interpr)\n        elif ttype == IONS_DYNAMIC_FULLY_IONIZED:\n            self.initialize_dynamic_fully_ionized(n=n, r=r, interpr=interpr)\n        elif ttype == IONS_PRESCRIBED_NEUTRAL:\n            self.initialize_prescribed_neutral(n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n        elif ttype == IONS_PRESCRIBED_FULLY_IONIZED:\n            self.initialize_prescribed_fully_ionized(n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized ion type: {}.\".format(self.name, ttype))\n\n        self.T = self.setTemperature(T)\n        \n        # Initialize diffusion\n        self.charged_prescribed_diffusion = None\n        self.rChargedPrescribedDiffusion = None\n        self.tChargedPrescribedDiffusion = None\n        if charged_diffusion_mode == ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed diffusion coefficients according to this, if nothing else is prescribed\n            if charged_prescribed_diffusion is None and t_transp_expdecay_all_cs is not None:\n                charged_prescribed_diffusion, rChargedPrescribedDiffusion, tChargedPrescribedDiffusion = self.calcTransportCoefficientExpdecayAllChargedStates(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = diffusion_initial_all_cs, cf = diffusion_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_charged_prescribed_diffusion(charged_prescribed_diffusion = charged_prescribed_diffusion, rChargedPrescribedDiffusion = rChargedPrescribedDiffusion,\n                tChargedPrescribedDiffusion = tChargedPrescribedDiffusion, interpr=interpr, interpt=interpt)\n        else:\n            self.charged_diffusion_mode = charged_diffusion_mode\n            \n        self.neutral_prescribed_diffusion = None\n        self.rNeutralPrescribedDiffusion = None\n        self.tNeutralPrescribedDiffusion = None\n        if neutral_diffusion_mode == ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed diffusion coefficients according to this, if nothing else is prescribed\n            if neutral_prescribed_diffusion is None and t_transp_expdecay_all_cs is not None:\n                neutral_prescribed_diffusion, rNeutralPrescribedDiffusion, tNeutralPrescribedDiffusion = self.calcTransportCoefficientExpdecaySingleChargeState(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = diffusion_initial_all_cs, cf = diffusion_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_neutral_prescribed_diffusion(neutral_prescribed_diffusion = neutral_prescribed_diffusion, rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion,\n                tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion, interpr=interpr, interpt=interpt)\n        else:\n            self.neutral_diffusion_mode = neutral_diffusion_mode\n\n        # Initialize advection\n        self.charged_prescribed_advection = None\n        self.rChargedPrescribedAdvection = None\n        self.tChargedPrescribedAdvection = None\n        if charged_advection_mode == ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed advection coefficients according to this, if nothing else is prescribed\n            if charged_prescribed_advection is None and t_transp_expdecay_all_cs is not None:\n                charged_prescribed_advection, rChargedPrescribedAdvection, tChargedPrescribedAdvection = self.calcTransportCoefficientExpdecayAllChargedStates(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = advection_initial_all_cs, cf = advection_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_charged_prescribed_advection(charged_prescribed_advection = charged_prescribed_advection, rChargedPrescribedAdvection = rChargedPrescribedAdvection,\n                tChargedPrescribedAdvection = tChargedPrescribedAdvection, interpr=interpr, interpt=interpt)\n        else:\n            self.charged_advection_mode = charged_advection_mode\n            \n        self.neutral_prescribed_advection = None\n        self.rNeutralPrescribedAdvection = None\n        self.tNeutralPrescribedAdvection = None\n        if neutral_advection_mode == ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed advection coefficients according to this, if nothing else is prescribed\n            if neutral_prescribed_advection is None and t_transp_expdecay_all_cs is not None:\n                neutral_prescribed_advection, rNeutralPrescribedAdvection, tNeutralPrescribedAdvection = self.calcTransportCoefficientExpdecaySingleChargeState(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = advection_initial_all_cs, cf = advection_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_neutral_prescribed_advection(neutral_prescribed_advection = neutral_prescribed_advection, rNeutralPrescribedAdvection = rNeutralPrescribedAdvection,\n                tNeutralPrescribedAdvection = tNeutralPrescribedAdvection, interpr=interpr, interpt=interpt)\n        else:\n            self.neutral_advection_mode = neutral_advection_mode\n\n\n    def setTemperature(self, T):\n        \"\"\"\n        Sets the ion temperature from an input value `T`. \n        For scalar T, sets a uniform radial profile,\n        otherwise requires the T profile to be given on the \n        `r` grid which is provided to the IonSpecies constructor.\n        \"\"\"\n        if type(T) == list:\n            T = np.array(T)\n        if T is None:\n            T = np.zeros((1,np.size(self.r)))\n        elif np.isscalar(T):\n            T = np.ones((1, np.size(self.r)))*T\n        elif np.ndim(T)==1:  \n            T = T[None,:]\n        elif T.shape[1] != np.size(self.r):\n             raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion temperature T: {}x{}. Expected {}x{}.\"\n                .format(self.name, T.shape[0], T.shape[1], 1, np.size(self.r)))        \n        return T\n\n\n    def getDensity(self):\n        \"\"\"\n        Returns the prescribed density array for this ion species.\n        \"\"\"\n        return self.n\n\n\n    def getSourceDensity(self):\n        \"\"\"\n        Returns the (time evolution of the) source term used to seed this\n        ion species with new particles.\n        \"\"\"\n        return self.source_n\n\n\n    def getSourceType(self):\n        \"\"\"\n        Returns the type of the source term used.\n        \"\"\"\n        return self.source_type\n        \n        \n    # Getters for diffusion-related quantities    \n    def getChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.charged_prescribed_diffusion\n        \n    def getRChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the radial grid for the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.rChargedPrescribedDiffusion\n        \n    def getTChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the time grid for the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.tChargedPrescribedDiffusion\n        \n    def getRNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the radial grid for the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.rNeutralPrescribedDiffusion\n        \n    def getTNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the time grid for the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.tNeutralPrescribedDiffusion\n        \n    def getNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.neutral_prescribed_diffusion\n        \n        \n        \n    # Getters for advection-related quantities    \n    def getChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.charged_prescribed_advection\n        \n    def getRChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the radial grid for the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.rChargedPrescribedAdvection\n        \n    def getTChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the time grid for the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.tChargedPrescribedAdvection\n        \n    def getRNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the radial grid for the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.rNeutralPrescribedAdvection\n        \n    def getTNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the time grid for the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.tNeutralPrescribedAdvection\n        \n    def getNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.neutral_prescribed_advection\n        \n        \n\n    def getName(self):\n        \"\"\"\n        Returns the name of this ion species.\n        \"\"\"\n        return self.name\n\n\n    def getR(self):\n        \"\"\"\n        Returns the radial grid on which the ion densities are defined.\n        \"\"\"\n        return self.r\n\n\n    def getSourceTime(self):\n        \"\"\"\n        Returns the time grid on which the ion source is defined.\n        \"\"\"\n        return self.source_t\n\n\n    def getTime(self):\n        \"\"\"\n        Returns the time grid on which the ion densities are defined.\n        \"\"\"\n        return self.t\n\n\n    def getType(self):\n        \"\"\"\n        Returns the type of equation to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.ttype\n        \n\n    def getOpacityMode(self):\n        \"\"\"\n        Returns the opacity mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.opacity_mode\n        \n\n    def getChargedDiffusionMode(self):\n        \"\"\"\n        Returns the charged diffusion mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.charged_diffusion_mode\n        \n\n    def getNeutralDiffusionMode(self):\n        \"\"\"\n        Returns the neutral diffusion mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.neutral_diffusion_mode\n        \n\n    def getChargedAdvectionMode(self):\n        \"\"\"\n        Returns the charged advection mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.charged_advection_mode\n        \n\n    def getNeutralAdvectionMode(self):\n        \"\"\"\n        Returns the neutral advection mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.neutral_advection_mode\n\n\n    def getTemperature(self):\n        \"\"\"\n        Returns the initial temperature array to use for evolving\n        the ion heat of this species \n        \"\"\"\n        return self.T\n\n\n    def getZ(self):\n        \"\"\"\n        Returns the atomic charge for this ion species.\n        \"\"\"\n        return self.Z\n\n\n    def getIsotope(self): return self.isotope\n\n\n    def getSPIMolarFraction(self): return self.SPIMolarFraction\n    \n\n    def setSPIMolarFraction(self, SPIMolarFraction):\n        if np.isscalar(SPIMolarFraction):\n            self.SPIMolarFraction = np.array([SPIMolarFraction])\n        else:\n            self.SPIMolarFraction = SPIMolarFraction\n\n\n    def isHydrogen(self):\n        \"\"\"\n        Returns ``True`` if this ion species is a hydrogen species.\n        \"\"\"\n        return self.hydrogen\n\n\n    def isTritium(self):\n        \"\"\"\n        Returns ``True`` if this ion species is a tritium species.\n        \"\"\"\n        return self.tritium\n\n\n    def initialize_prescribed(self, n=None, r=None, t=None):\n        \"\"\"\n        Prescribes the evolution for this ion species.\n        \"\"\"\n        self.ttype = IONS_PRESCRIBED\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            self.t = np.array([0])\n            self.r = np.array([0,1])\n            self.n = np.ones((self.Z+1,1,2)) * n\n            return\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile (assume fully ionized)\n        if len(n.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed density data has only one dimension.\".format(self.name))\n        # Radial profiles of charge states\n        elif len(n.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed density data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(n.shape) == 3:\n            if t is None:\n                raise EquationException(\"ion_species: '{}': 3D ion density prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z+1 != n.shape[0] or t.size != n.shape[1] or r.size != n.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, n.shape[0], n.shape[1], n.shape[2], self.Z+1, t.size, r.size))\n            self.t = t\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))\n\n\n    def initialize_dynamic(self, n=None, r=None):\n        \"\"\"\n        Evolve ions according to the ion rate equation in DREAM.\n        \"\"\"\n        self.ttype = IONS_DYNAMIC\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n            raise EquationException(\"ion_species: '{}': Initial density must be two dimensional (charge states x radius).\".format(self.name))\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar initial ion density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profiles for all charge states \n        if len(n.shape) == 2:\n            if self.Z+1 != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], self.Z+1, r.size))\n\n            self.t = None\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of initial density: {}.\".format(n.shape).format(self.name))\n\n\n    def initialize_equilibrium(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve ions according to the equilibrium equation in DREAM.\n        \"\"\"\n        self.ttype = IONS_EQUILIBRIUM\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in radius)\n        if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,r.size))\n\n            # For the equilibrium, it doesn't matter which charge state we\n            # put the particles in. They will be placed in the correct state\n            # after the first time step (=> make all particles fully ionized\n            # so that nfree > 0)\n            N[self.Z,:] = n\n            n = N\n        elif r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar initial ion density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profiles for all charge states \n        if len(n.shape) == 2:\n            if self.Z+1 != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], self.Z+1, r.size))\n\n            self.t = None\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of initial density: {}.\".format(self.name, n.shape))\n\n\n    def initialize_dynamic_neutral(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all as neutrals.\n        \"\"\"\n        self.initialize_dynamic_charge_state(0, n=n, r=r, interpr=interpr)\n\n\n    def initialize_dynamic_fully_ionized(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all as fully ionized.\n        \"\"\"\n        self.initialize_dynamic_charge_state(self.Z, n=n, r=r, interpr=interpr)\n\n\n    def initialize_dynamic_charge_state(self, Z0, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all to reside in the specified charge state Z0.\n        \"\"\"\n        if Z0 > self.Z or Z0 < 0:\n            raise EquationException(\"ion_species: '{}': Invalid charge state specified: {}. Ion has charge Z = {}.\".format(self.name, Z0, self.Z))\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        if type(n) == float or np.isscalar(n) or (type(n) == np.ndarray and n.size == 1):\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,r.size))\n            N[Z0,:] = n\n\n            self.initialize_dynamic(n=N, r=r)\n            return\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile\n        if len(n.shape) == 1:\n            if r.size != n.size:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}. Expected {}.\"\n                    .format(self.name, n.shape[0], r.size))\n                \n            N = np.zeros((self.Z+1, r.size))\n            N[Z0,:] = n\n            self.initialize_dynamic(n=N, r=r)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))\n\n\n    def initialize_prescribed_neutral(self, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to be neutral.\n        \"\"\"\n        self.initialize_prescribed_charge_state(0, n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n\n\n    def initialize_prescribed_fully_ionized(self, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to be fully ionized.\n        \"\"\"\n        self.initialize_prescribed_charge_state(self.Z, n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n\n\n    def initialize_prescribed_charge_state(self, Z0, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to all be situated in the specified charge state Z0.\n        \"\"\"\n        if Z0 > self.Z or Z0 < 0:\n            raise EquationException(\"ion_species: '{}': Invalid charge state specified: {}. Ion has charge Z = {}.\".format(self.name, Z0, self.Z))\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            t = interpt if interpt is not None else np.array([0])\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,t.size,r.size))\n            N[Z0,0,:] = n\n\n            self.initialize_prescribed(n=N, t=t, r=r)\n            return\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile\n        if len(n.shape) == 1:\n            if r.size != n.size:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}. Expected {}.\"\n                    .format(self.name, n.shape[0], r.size))\n                \n            t = interpt if interpt is not None else np.array([0])\n            n = np.reshape(n, (t.size,r.size))\n\n        # Radial + temporal profile\n        if len(n.shape) == 2:\n            if t is None:\n                raise EquationException(\"ion_species: '{}': 2D ion density prescribed, but no time coordinates given.\".format(self.name))\n\n            if t.size != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], t.size, r.size))\n\n            N = np.zeros((self.Z+1, t.size, r.size))\n            N[Z0,:,:] = n\n\n            self.initialize_prescribed(n=N, t=t, r=r)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))\n            \n            \n    def initialize_charged_prescribed_diffusion(self, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the charged diffusion coefficients for this ion species.\n        \"\"\"\n        self.charged_diffusion_mode = ION_CHARGED_DIFFUSION_MODE_PRESCRIBED\n        if charged_prescribed_diffusion is None:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(charged_prescribed_diffusion) == list:\n            charged_prescribed_diffusion = np.array(charged_prescribed_diffusion)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(charged_prescribed_diffusion):\n            self.tChargedPrescribedDiffusion = np.array([0])\n            self.rChargedPrescribedDiffusion = np.array([0,1])\n            self.charged_prescribed_diffusion = np.ones((self.Z,1,2)) * charged_prescribed_diffusion\n            return\n        if rChargedPrescribedDiffusion is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(charged_prescribed_diffusion.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficient data has only one dimension.\".format(self.name))\n        elif len(charged_prescribed_diffusion.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficient data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(charged_prescribed_diffusion.shape) == 3:\n            if tChargedPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 3D charged diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z != charged_prescribed_diffusion.shape[0] or tChargedPrescribedDiffusion.size != charged_prescribed_diffusion.shape[1] or rChargedPrescribedDiffusion.size != charged_prescribed_diffusion.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed charged diffusion coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, charged_prescribed_diffusion.shape.shape[0], charged_prescribed_diffusion.shape.shape[1], charged_prescribed_diffusion.shape.shape[2], self.Z, tChargedPrescribedDiffusion.size, rChargedPrescribedDiffusion.size))\n            self.tChargedPrescribedDiffusion = tChargedPrescribedDiffusion\n            self.rChargedPrescribedDiffusion = rChargedPrescribedDiffusion\n            self.charged_prescribed_diffusion = charged_prescribed_diffusion\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed charged diffusion coefficient: {}.\".format(self.name, charged_prescribed_diffusion.shape))\n\n\n    def initialize_neutral_prescribed_diffusion(self, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the neutral diffusion coefficients for this ion species.\n        \"\"\"\n        self.neutral_diffusion_mode = ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED\n        if neutral_prescribed_diffusion is None:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral diffusion coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(neutral_prescribed_diffusion) == list:\n            neutral_prescribed_diffusion = np.array(neutral_prescribed_diffusion)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(neutral_prescribed_diffusion):\n            self.tNeutralPrescribedDiffusion = np.array([0])\n            self.rNeutralPrescribedDiffusion = np.array([0,1])\n            self.neutral_prescribed_diffusion = np.ones((1,1,2)) * neutral_prescribed_diffusion\n            return\n        if rNeutralPrescribedDiffusion is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(neutral_prescribed_diffusion.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral diffusion coefficient data has only one dimension.\".format(self.name))\n        # As there is only one neutral charge state for a single species, all information needed here can actually be provided in a 2D array\n        elif len(neutral_prescribed_diffusion.shape) == 2:\n            if tNeutralPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 2D neutral diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if tNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[0] or rNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral diffusion coefficient: {}x{}. Expected {}x{}\"\n                    .format(self.name, neutral_prescribed_diffusion.shape.shape[0], neutral_prescribed_diffusion.shape.shape[1], tNeutralPrescribedDiffusion.size, rNeutralPrescribedDiffusion.size))\n            self.tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion\n            self.rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion\n            self.neutral_prescribed_diffusion = neutral_prescribed_diffusion.reshape((1,neutral_prescribed_diffusion.shape[0],neutral_prescribed_diffusion.shape[1]))\n        # Full time evolution of radial profiles of charge states\n        elif len(neutral_prescribed_diffusion.shape) == 3:\n            if tNeutralPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 3D neutral diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if neutral_prescribed_diffusion.shape[0] != 1 or tNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[1] or rNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral diffusion coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, neutral_prescribed_diffusion.shape[0], neutral_prescribed_diffusion.shape[1], neutral_prescribed_diffusion.shape[2], self.Z, tNeutralPrescribedDiffusion.size, rNeutralPrescribedDiffusion.size))\n            self.tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion\n            self.rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion\n            self.neutral_prescribed_diffusion = neutral_prescribed_diffusion\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed neutral diffusion coefficient: {}.\".format(self.name, neutral_prescribed_diffusion.shape))\n   \n   \n    def initialize_charged_prescribed_advection(self, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the charged advection coefficients for this ion species.\n        \"\"\"\n        self.charged_advection_mode = ION_CHARGED_ADVECTION_MODE_PRESCRIBED\n        if charged_prescribed_advection is None:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(charged_prescribed_advection) == list:\n            charged_prescribed_advection = np.array(charged_prescribed_advection)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(charged_prescribed_advection):\n            self.tChargedPrescribedAdvection = np.array([0])\n            self.rChargedPrescribedAdvection = np.array([0,1])\n            self.charged_prescribed_advection = np.ones((self.Z,1,2)) * charged_prescribed_advection\n            return\n        if rChargedPrescribedAdvection is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(charged_prescribed_advection.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficient data has only one dimension.\".format(self.name))\n        elif len(charged_prescribed_advection.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficient data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(charged_prescribed_advection.shape) == 3:\n            if tChargedPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 3D charged advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z != charged_prescribed_advection.shape[0] or tChargedPrescribedAdvection.size != charged_prescribed_advection.shape[1] or rChargedPrescribedAdvection.size != charged_prescribed_advection.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed charged advection coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, charged_prescribed_advection.shape.shape[0], charged_prescribed_advection.shape.shape[1], charged_prescribed_advection.shape.shape[2], self.Z, tChargedPrescribedAdvection.size, rChargedPrescribedAdvection.size))\n            self.tChargedPrescribedAdvection = tChargedPrescribedAdvection\n            self.rChargedPrescribedAdvection = rChargedPrescribedAdvection\n            self.charged_prescribed_advection = charged_prescribed_advection\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed charged advection coefficient: {}.\".format(self.name, charged_prescribed_advection.shape))\n\n\n    def initialize_neutral_prescribed_advection(self, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the neutral advection coefficients for this ion species.\n        \"\"\"\n        self.neutral_advection_mode = ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED\n        if neutral_prescribed_advection is None:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral advection coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(neutral_prescribed_advection) == list:\n            neutral_prescribed_advection = np.array(neutral_prescribed_advection)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(neutral_prescribed_advection):\n            self.tNeutralPrescribedAdvection = np.array([0])\n            self.rNeutralPrescribedAdvection = np.array([0,1])\n            self.neutral_prescribed_advection = np.ones((1,1,2)) * neutral_prescribed_advection\n            return\n        if rNeutralPrescribedAdvection is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(neutral_prescribed_advection.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral advection coefficient data has only one dimension.\".format(self.name))\n        # As there is only one neutral charge state for a single species, all information needed here can actually be provided in a 2D array\n        elif len(neutral_prescribed_advection.shape) == 2:\n            if tNeutralPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 2D neutral advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if tNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[0] or rNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral advection coefficient: {}x{}. Expected {}x{}\"\n                    .format(self.name, neutral_prescribed_advection.shape.shape[0], neutral_prescribed_advection.shape.shape[1], tNeutralPrescribedAdvection.size, rNeutralPrescribedAdvection.size))\n            self.tNeutralPrescribedAdvection = tNeutralPrescribedAdvection\n            self.rNeutralPrescribedAdvection = rNeutralPrescribedAdvection\n            self.neutral_prescribed_advection = neutral_prescribed_advection.reshape((1,neutral_prescribed_advection.shape[0],neutral_prescribed_advection.shape[1]))\n        # Full time evolution of radial profiles of charge states\n        elif len(neutral_prescribed_advection.shape) == 3:\n            if tNeutralPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 3D neutral advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if neutral_prescribed_advection.shape[0] != 1 or tNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[1] or rNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral advection coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, neutral_prescribed_advection.shape.shape[0], neutral_prescribed_advection.shape.shape[1], neutral_prescribed_advection.shape.shape[2], self.Z, tNeutralPrescribedAdvection.size, rNeutralPrescribedAdvection.size))\n            self.tNeutralPrescribedAdvection = tNeutralPrescribedAdvection\n            self.rNeutralPrescribedAdvection = rNeutralPrescribedAdvection\n            self.neutral_prescribed_advection = neutral_prescribed_advection\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed neutral advection coefficient: {}.\".format(self.name, neutral_prescribed_advection.shape))\n\n\n    def initialize_source(self, n, t=None, Z0=0):\n        \"\"\"\n        Initialize the ion source term associated with this species.\n        \"\"\"\n        self.source_type = ION_SOURCE_PRESCRIBED\n\n        if n is None:\n            raise EquationException(f\"ion_species: '{self.name}': Input source density must not be 'None'.\")\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            self.source_t = np.array([0])\n            self.source_n = np.zeros((self.Z+1,1))\n            self.source_n[Z0,:] = n\n            return\n\n        # Time evolution of neutral atoms\n        if len(n.shape) == 1:\n            if n.size != t.size:\n                raise EquationException(f\"ion_species: '{self.name}': Time evolving source specified, by shape(n) != shape(t), {n.shape} != {t.shape}.\")\n\n            self.source_t = t\n            self.source_n = np.zeros((self.Z+1, t.size))\n            self.source_n[Z0,:] = n\n        # Time evolution of all charge states\n        elif len(n.shape) == 2:\n            if t is None:\n                raise EquationException(f\"ion_species: '{self.name}': Full ion charge state density source prescribed, but no time coordinates given.\")\n\n            if self.Z+1 != n.shape[0] or t.size != n.shape[1]:\n                raise EquationException(f\"ion_species: '{self.name}': Invalid dimensions of prescribed source density: {n.shape[0]}x{n.shape[1]}x{n.shape[2]}. Expected {self.Z+1}x{t.size}x{r.size}\")\n\n            self.source_t = t\n            self.source_n = n\n        else:\n            raise EquationException(f\"ion_species: '{self.name}': Unrecognized shape of prescribed source density: {n.shape}.\")\n\n\n    def calcTransportCoefficientExpdecaySingleChargeState(self, t_exp, c0, cf = 0, t_start = 0, r = None, t = None):\n        if t is None:\n            t = np.linspace(0,t_start+10*t_exp).reshape(-1,1)\n        if r is None:\n            r = np.linspace(0,self.settings.radialgrid.a)\n        if np.isscalar(c0):\n            Nr = len(r)\n            c0 = c0*np.ones((1,Nr))\n            \n        if np.isscalar(cf):\n            Nr = len(r)\n            cf = cf*np.ones((1,Nr))     \n                    \n        c_single_charge_state = (cf + np.exp(-(t-t_start)/t_exp)*(c0-cf))*(t>t_start)\n        \n        return c_single_charge_state, r.flatten(), t.flatten()\n\n\n    def calcTransportCoefficientExpdecayAllChargedStates(self, t_exp, c0, cf = 0, t_start = 0, r = None, t = None):\n        c_single_charge_state, r, t = self.calcTransportCoefficientExpdecaySingleChargeState(t_exp, c0, cf, t_start, r, t)\n        cCharged = np.zeros((self.Z,len(t),len(c_single_charge_state)))\n        for i in range(self.Z):\n            cCharged[i,:,:]=c_single_charge_state\n        \n        return cCharged, r, t\n\n    \n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this ion species are correctly set.\n        \"\"\"\n        if self.Z < 1:\n            raise EquationException(\"ion_species: '{}': Invalid atomic charge: {}.\".format(self.name, self.Z))\n\n        if self.hydrogen or self.tritium:\n            if self.Z != 1:\n                raise EquationException(f\"ion_species: '{self.name}': Ion indicated as Hydrogen/Tritium, but charge Z = {self.Z}.\")\n\n        if self.ttype == IONS_PRESCRIBED:\n            if self.t.ndim != 1:\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif self.r.ndim != 1:\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif self.n is None or (self.n.shape != (self.Z+1, self.t.size, self.r.size)):\n                raise EquationException(\"ion_species: '{}': Invalid dimensions for input density: {}x{}x{}. Expected {}x{}x{}.\"\n                    .format(self.name, self.n.shape[0], self.n.shape[1], self.n.shape[2], self.Z+1, self.t.size, self.r.size))\n        elif self.ttype == IONS_EQUILIBRIUM or self.ttype == IONS_DYNAMIC:\n            if (self.r is None) or (self.r.ndim != 1):\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif (self.n is None) or (self.n.shape != (self.Z+1, self.r.size)):\n                raise EquationException(\"ion_species: '{}': Invalid dimensions for input density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, self.n.shape[0], self.n.shape[1], self.Z+1, self.r.size))",
  "def __init__(self, settings, name, Z, ttype=0, Z0=None, isotope=0, SPIMolarFraction=-1.0, opacity_mode = ION_OPACITY_MODE_TRANSPARENT, \n        charged_diffusion_mode=ION_CHARGED_DIFFUSION_MODE_NONE, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None,\n        neutral_diffusion_mode=ION_NEUTRAL_DIFFUSION_MODE_NONE, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None,\n        charged_advection_mode=ION_CHARGED_ADVECTION_MODE_NONE, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None,\n        neutral_advection_mode=ION_NEUTRAL_ADVECTION_MODE_NONE, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None,\n        t_transp_expdecay_all_cs = None, t_transp_start_expdecay_all_cs = 0, diffusion_initial_all_cs = None, diffusion_final_all_cs = 0, advection_initial_all_cs = None, advection_final_all_cs = 0, r_expdecay_all_cs = None, t_expdecay_all_cs = None,        \n        T=None, n=None, r=None, t=None, interpr=None, interpt=None, tritium=False, hydrogen=False):\n        \"\"\"\n        Constructor.\n\n        :param DREAMSettings settings: Parent DREAMSettings object.\n        :param str name:               Name by which the ion species will be referred to.\n        :param int Z:                  Ion charge number.\n        :param int isotope:            Ion mass number.\n        :param int ttype:              Method to use for evolving ions in time.\n        :param int Z0:                 Charge state to populate with given density.\n        :param float n:                Ion density (can be either a scalar, 1D array or 2D array, depending on the other input parameters)\n        :param float SPIMolarFraction: Molar fraction of the SPI injection (if any). A negative value means that this species is not part of the SPI injection \n        :param T:                      Ion initial temperature (can be scalar for uniform temperature, otherwise 1D array matching `r` in size)\n        :param numpy.ndarray r:        Radial grid on which the input density is defined.\n        :param numpy.ndarray t:        Time grid on which the input density is defined.\n        :param numpy.ndarray interpr:  Radial grid onto which ion densities should be interpolated.\n        :param numpy.ndarray interpt:  Time grid onto which ion densities should be interpolated.\n        :param bool tritium:           If ``True``, this ion species is treated as Tritium.\n        :param bool hydrogen:          If ``True``, this ion species is treated as Hydrogen.\n        \"\"\"\n        if ';' in name:\n            raise EquationException(\"ion_species: '{}': Invalid character found in ion name: '{}'.\".format(name, ';'))\n\n        self.settings = settings\n        self.name     = name\n        self.Z        = int(Z)\n        self.isotope  = int(isotope)\n        self.ttype    = None\n        self.tritium  = tritium\n        self.hydrogen = hydrogen\n        self.opacity_mode = opacity_mode\n        self.charged_diffusion_mode = None\n        self.neutral_diffusion_mode = None\n        self.charged_advection_mode = None\n        self.neutral_advection_mode = None\n\n        self.setSPIMolarFraction(SPIMolarFraction)\n\n        if self.tritium and self.hydrogen:\n            raise EquationException(\"ion_species: '{}': Ion species indicated as both Tritium and Hydrogen simultaneously.\")\n\n        # Emit warning if 'T' is used as name but 'tritium = False',\n        # as this may indicate a user error\n        if name == 'T' and tritium == False:\n            print(\"WARNING: Ion species with name 'T' added, but 'tritium = False'.\")\n        if name == 'H' and hydrogen == False:\n            print(\"WARNING: Ion species with name 'H' added, but 'hydrogen = False'.\")\n\n        self.source_n = np.zeros((self.Z+1, 1))\n        self.source_t = np.array([0])\n        self.source_type = ION_SOURCE_NONE\n\n        self.n = None\n        self.r = None\n        self.t = None\n        if ttype == IONS_PRESCRIBED:\n            if Z0 is not None:\n                self.initialize_prescribed_charge_state(Z0=Z0, n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n            else:\n                self.initialize_prescribed(n=n, r=r, t=t)\n        elif ttype == IONS_DYNAMIC:\n            if Z0 is not None:\n                self.initialize_dynamic_charge_state(Z0=Z0, n=n, r=r, interpr=interpr)\n            else:\n                self.initialize_dynamic(n=n, r=r)\n        elif ttype == IONS_EQUILIBRIUM:\n            self.initialize_equilibrium(n=n, r=r, Z0=Z0)\n        elif Z0 is not None:\n            print(\"WARNING: Charge state Z0 given, but ion type is not simply 'prescribed', 'dynamic' or 'equilibrium'. Hence, Z0 is ignored.\")\n        \n        # TYPES AVAILABLE ONLY IN THIS INTERFACE\n        elif ttype == IONS_DYNAMIC_NEUTRAL:\n            self.initialize_dynamic_neutral(n=n, r=r, interpr=interpr)\n        elif ttype == IONS_DYNAMIC_FULLY_IONIZED:\n            self.initialize_dynamic_fully_ionized(n=n, r=r, interpr=interpr)\n        elif ttype == IONS_PRESCRIBED_NEUTRAL:\n            self.initialize_prescribed_neutral(n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n        elif ttype == IONS_PRESCRIBED_FULLY_IONIZED:\n            self.initialize_prescribed_fully_ionized(n=n, r=r, t=t, interpr=interpr, interpt=interpt)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized ion type: {}.\".format(self.name, ttype))\n\n        self.T = self.setTemperature(T)\n        \n        # Initialize diffusion\n        self.charged_prescribed_diffusion = None\n        self.rChargedPrescribedDiffusion = None\n        self.tChargedPrescribedDiffusion = None\n        if charged_diffusion_mode == ION_CHARGED_DIFFUSION_MODE_PRESCRIBED:\n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed diffusion coefficients according to this, if nothing else is prescribed\n            if charged_prescribed_diffusion is None and t_transp_expdecay_all_cs is not None:\n                charged_prescribed_diffusion, rChargedPrescribedDiffusion, tChargedPrescribedDiffusion = self.calcTransportCoefficientExpdecayAllChargedStates(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = diffusion_initial_all_cs, cf = diffusion_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_charged_prescribed_diffusion(charged_prescribed_diffusion = charged_prescribed_diffusion, rChargedPrescribedDiffusion = rChargedPrescribedDiffusion,\n                tChargedPrescribedDiffusion = tChargedPrescribedDiffusion, interpr=interpr, interpt=interpt)\n        else:\n            self.charged_diffusion_mode = charged_diffusion_mode\n            \n        self.neutral_prescribed_diffusion = None\n        self.rNeutralPrescribedDiffusion = None\n        self.tNeutralPrescribedDiffusion = None\n        if neutral_diffusion_mode == ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed diffusion coefficients according to this, if nothing else is prescribed\n            if neutral_prescribed_diffusion is None and t_transp_expdecay_all_cs is not None:\n                neutral_prescribed_diffusion, rNeutralPrescribedDiffusion, tNeutralPrescribedDiffusion = self.calcTransportCoefficientExpdecaySingleChargeState(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = diffusion_initial_all_cs, cf = diffusion_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_neutral_prescribed_diffusion(neutral_prescribed_diffusion = neutral_prescribed_diffusion, rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion,\n                tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion, interpr=interpr, interpt=interpt)\n        else:\n            self.neutral_diffusion_mode = neutral_diffusion_mode\n\n        # Initialize advection\n        self.charged_prescribed_advection = None\n        self.rChargedPrescribedAdvection = None\n        self.tChargedPrescribedAdvection = None\n        if charged_advection_mode == ION_CHARGED_ADVECTION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed advection coefficients according to this, if nothing else is prescribed\n            if charged_prescribed_advection is None and t_transp_expdecay_all_cs is not None:\n                charged_prescribed_advection, rChargedPrescribedAdvection, tChargedPrescribedAdvection = self.calcTransportCoefficientExpdecayAllChargedStates(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = advection_initial_all_cs, cf = advection_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_charged_prescribed_advection(charged_prescribed_advection = charged_prescribed_advection, rChargedPrescribedAdvection = rChargedPrescribedAdvection,\n                tChargedPrescribedAdvection = tChargedPrescribedAdvection, interpr=interpr, interpt=interpt)\n        else:\n            self.charged_advection_mode = charged_advection_mode\n            \n        self.neutral_prescribed_advection = None\n        self.rNeutralPrescribedAdvection = None\n        self.tNeutralPrescribedAdvection = None\n        if neutral_advection_mode == ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED:\n        \n            # If an exponential decay of the transport coefficients are prescribed, \n            # set the precribed advection coefficients according to this, if nothing else is prescribed\n            if neutral_prescribed_advection is None and t_transp_expdecay_all_cs is not None:\n                neutral_prescribed_advection, rNeutralPrescribedAdvection, tNeutralPrescribedAdvection = self.calcTransportCoefficientExpdecaySingleChargeState(t_start = t_transp_start_expdecay_all_cs, t_exp = t_transp_expdecay_all_cs, c0 = advection_initial_all_cs, cf = advection_final_all_cs, r = r_expdecay_all_cs, t = t_expdecay_all_cs)\n                \n            self.initialize_neutral_prescribed_advection(neutral_prescribed_advection = neutral_prescribed_advection, rNeutralPrescribedAdvection = rNeutralPrescribedAdvection,\n                tNeutralPrescribedAdvection = tNeutralPrescribedAdvection, interpr=interpr, interpt=interpt)\n        else:\n            self.neutral_advection_mode = neutral_advection_mode",
  "def setTemperature(self, T):\n        \"\"\"\n        Sets the ion temperature from an input value `T`. \n        For scalar T, sets a uniform radial profile,\n        otherwise requires the T profile to be given on the \n        `r` grid which is provided to the IonSpecies constructor.\n        \"\"\"\n        if type(T) == list:\n            T = np.array(T)\n        if T is None:\n            T = np.zeros((1,np.size(self.r)))\n        elif np.isscalar(T):\n            T = np.ones((1, np.size(self.r)))*T\n        elif np.ndim(T)==1:  \n            T = T[None,:]\n        elif T.shape[1] != np.size(self.r):\n             raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion temperature T: {}x{}. Expected {}x{}.\"\n                .format(self.name, T.shape[0], T.shape[1], 1, np.size(self.r)))        \n        return T",
  "def getDensity(self):\n        \"\"\"\n        Returns the prescribed density array for this ion species.\n        \"\"\"\n        return self.n",
  "def getSourceDensity(self):\n        \"\"\"\n        Returns the (time evolution of the) source term used to seed this\n        ion species with new particles.\n        \"\"\"\n        return self.source_n",
  "def getSourceType(self):\n        \"\"\"\n        Returns the type of the source term used.\n        \"\"\"\n        return self.source_type",
  "def getChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.charged_prescribed_diffusion",
  "def getRChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the radial grid for the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.rChargedPrescribedDiffusion",
  "def getTChargedPrescribedDiffusion(self):\n        \"\"\"\n        Returns the time grid for the prescribed charged diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.tChargedPrescribedDiffusion",
  "def getRNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the radial grid for the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.rNeutralPrescribedDiffusion",
  "def getTNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the time grid for the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.tNeutralPrescribedDiffusion",
  "def getNeutralPrescribedDiffusion(self):\n        \"\"\"\n        Returns the prescribed neutral diffusion coefficient array for this ion species.\n        \"\"\"\n        return self.neutral_prescribed_diffusion",
  "def getChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.charged_prescribed_advection",
  "def getRChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the radial grid for the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.rChargedPrescribedAdvection",
  "def getTChargedPrescribedAdvection(self):\n        \"\"\"\n        Returns the time grid for the prescribed charged advection coefficient array for this ion species.\n        \"\"\"\n        return self.tChargedPrescribedAdvection",
  "def getRNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the radial grid for the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.rNeutralPrescribedAdvection",
  "def getTNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the time grid for the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.tNeutralPrescribedAdvection",
  "def getNeutralPrescribedAdvection(self):\n        \"\"\"\n        Returns the prescribed neutral advection coefficient array for this ion species.\n        \"\"\"\n        return self.neutral_prescribed_advection",
  "def getName(self):\n        \"\"\"\n        Returns the name of this ion species.\n        \"\"\"\n        return self.name",
  "def getR(self):\n        \"\"\"\n        Returns the radial grid on which the ion densities are defined.\n        \"\"\"\n        return self.r",
  "def getSourceTime(self):\n        \"\"\"\n        Returns the time grid on which the ion source is defined.\n        \"\"\"\n        return self.source_t",
  "def getTime(self):\n        \"\"\"\n        Returns the time grid on which the ion densities are defined.\n        \"\"\"\n        return self.t",
  "def getType(self):\n        \"\"\"\n        Returns the type of equation to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.ttype",
  "def getOpacityMode(self):\n        \"\"\"\n        Returns the opacity mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.opacity_mode",
  "def getChargedDiffusionMode(self):\n        \"\"\"\n        Returns the charged diffusion mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.charged_diffusion_mode",
  "def getNeutralDiffusionMode(self):\n        \"\"\"\n        Returns the neutral diffusion mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.neutral_diffusion_mode",
  "def getChargedAdvectionMode(self):\n        \"\"\"\n        Returns the charged advection mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.charged_advection_mode",
  "def getNeutralAdvectionMode(self):\n        \"\"\"\n        Returns the neutral advection mode to use for evolving the ion densities\n        for this species.\n        \"\"\"\n        return self.neutral_advection_mode",
  "def getTemperature(self):\n        \"\"\"\n        Returns the initial temperature array to use for evolving\n        the ion heat of this species \n        \"\"\"\n        return self.T",
  "def getZ(self):\n        \"\"\"\n        Returns the atomic charge for this ion species.\n        \"\"\"\n        return self.Z",
  "def getIsotope(self): return self.isotope",
  "def getSPIMolarFraction(self): return self.SPIMolarFraction",
  "def setSPIMolarFraction(self, SPIMolarFraction):\n        if np.isscalar(SPIMolarFraction):\n            self.SPIMolarFraction = np.array([SPIMolarFraction])\n        else:\n            self.SPIMolarFraction = SPIMolarFraction",
  "def isHydrogen(self):\n        \"\"\"\n        Returns ``True`` if this ion species is a hydrogen species.\n        \"\"\"\n        return self.hydrogen",
  "def isTritium(self):\n        \"\"\"\n        Returns ``True`` if this ion species is a tritium species.\n        \"\"\"\n        return self.tritium",
  "def initialize_prescribed(self, n=None, r=None, t=None):\n        \"\"\"\n        Prescribes the evolution for this ion species.\n        \"\"\"\n        self.ttype = IONS_PRESCRIBED\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            self.t = np.array([0])\n            self.r = np.array([0,1])\n            self.n = np.ones((self.Z+1,1,2)) * n\n            return\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile (assume fully ionized)\n        if len(n.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed density data has only one dimension.\".format(self.name))\n        # Radial profiles of charge states\n        elif len(n.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed density data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(n.shape) == 3:\n            if t is None:\n                raise EquationException(\"ion_species: '{}': 3D ion density prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z+1 != n.shape[0] or t.size != n.shape[1] or r.size != n.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, n.shape[0], n.shape[1], n.shape[2], self.Z+1, t.size, r.size))\n            self.t = t\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))",
  "def initialize_dynamic(self, n=None, r=None):\n        \"\"\"\n        Evolve ions according to the ion rate equation in DREAM.\n        \"\"\"\n        self.ttype = IONS_DYNAMIC\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n            raise EquationException(\"ion_species: '{}': Initial density must be two dimensional (charge states x radius).\".format(self.name))\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar initial ion density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profiles for all charge states \n        if len(n.shape) == 2:\n            if self.Z+1 != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], self.Z+1, r.size))\n\n            self.t = None\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of initial density: {}.\".format(n.shape).format(self.name))",
  "def initialize_equilibrium(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve ions according to the equilibrium equation in DREAM.\n        \"\"\"\n        self.ttype = IONS_EQUILIBRIUM\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in radius)\n        if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,r.size))\n\n            # For the equilibrium, it doesn't matter which charge state we\n            # put the particles in. They will be placed in the correct state\n            # after the first time step (=> make all particles fully ionized\n            # so that nfree > 0)\n            N[self.Z,:] = n\n            n = N\n        elif r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar initial ion density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profiles for all charge states \n        if len(n.shape) == 2:\n            if self.Z+1 != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of initial ion density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], self.Z+1, r.size))\n\n            self.t = None\n            self.r = r\n            self.n = n\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of initial density: {}.\".format(self.name, n.shape))",
  "def initialize_dynamic_neutral(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all as neutrals.\n        \"\"\"\n        self.initialize_dynamic_charge_state(0, n=n, r=r, interpr=interpr)",
  "def initialize_dynamic_fully_ionized(self, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all as fully ionized.\n        \"\"\"\n        self.initialize_dynamic_charge_state(self.Z, n=n, r=r, interpr=interpr)",
  "def initialize_dynamic_charge_state(self, Z0, n=None, r=None, interpr=None):\n        \"\"\"\n        Evolve the ions dynamically, initializing them all to reside in the specified charge state Z0.\n        \"\"\"\n        if Z0 > self.Z or Z0 < 0:\n            raise EquationException(\"ion_species: '{}': Invalid charge state specified: {}. Ion has charge Z = {}.\".format(self.name, Z0, self.Z))\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        if type(n) == float or np.isscalar(n) or (type(n) == np.ndarray and n.size == 1):\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,r.size))\n            N[Z0,:] = n\n\n            self.initialize_dynamic(n=N, r=r)\n            return\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile\n        if len(n.shape) == 1:\n            if r.size != n.size:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}. Expected {}.\"\n                    .format(self.name, n.shape[0], r.size))\n                \n            N = np.zeros((self.Z+1, r.size))\n            N[Z0,:] = n\n            self.initialize_dynamic(n=N, r=r)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))",
  "def initialize_prescribed_neutral(self, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to be neutral.\n        \"\"\"\n        self.initialize_prescribed_charge_state(0, n=n, r=r, t=t, interpr=interpr, interpt=interpt)",
  "def initialize_prescribed_fully_ionized(self, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to be fully ionized.\n        \"\"\"\n        self.initialize_prescribed_charge_state(self.Z, n=n, r=r, t=t, interpr=interpr, interpt=interpt)",
  "def initialize_prescribed_charge_state(self, Z0, n=None, r=None, t=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribe the ions to all be situated in the specified charge state Z0.\n        \"\"\"\n        if Z0 > self.Z or Z0 < 0:\n            raise EquationException(\"ion_species: '{}': Invalid charge state specified: {}. Ion has charge Z = {}.\".format(self.name, Z0, self.Z))\n\n        if n is None:\n            raise EquationException(\"ion_species: '{}': Input density must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            t = interpt if interpt is not None else np.array([0])\n            r = interpr if interpr is not None else np.array([0])\n            N = np.zeros((self.Z+1,t.size,r.size))\n            N[Z0,0,:] = n\n\n            self.initialize_prescribed(n=N, t=t, r=r)\n            return\n\n        if r is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        # Radial profile\n        if len(n.shape) == 1:\n            if r.size != n.size:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}. Expected {}.\"\n                    .format(self.name, n.shape[0], r.size))\n                \n            t = interpt if interpt is not None else np.array([0])\n            n = np.reshape(n, (t.size,r.size))\n\n        # Radial + temporal profile\n        if len(n.shape) == 2:\n            if t is None:\n                raise EquationException(\"ion_species: '{}': 2D ion density prescribed, but no time coordinates given.\".format(self.name))\n\n            if t.size != n.shape[0] or r.size != n.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, n.shape[0], n.shape[1], t.size, r.size))\n\n            N = np.zeros((self.Z+1, t.size, r.size))\n            N[Z0,:,:] = n\n\n            self.initialize_prescribed(n=N, t=t, r=r)\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed density: {}.\".format(self.name, n.shape))",
  "def initialize_charged_prescribed_diffusion(self, charged_prescribed_diffusion=None, rChargedPrescribedDiffusion=None, tChargedPrescribedDiffusion=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the charged diffusion coefficients for this ion species.\n        \"\"\"\n        self.charged_diffusion_mode = ION_CHARGED_DIFFUSION_MODE_PRESCRIBED\n        if charged_prescribed_diffusion is None:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(charged_prescribed_diffusion) == list:\n            charged_prescribed_diffusion = np.array(charged_prescribed_diffusion)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(charged_prescribed_diffusion):\n            self.tChargedPrescribedDiffusion = np.array([0])\n            self.rChargedPrescribedDiffusion = np.array([0,1])\n            self.charged_prescribed_diffusion = np.ones((self.Z,1,2)) * charged_prescribed_diffusion\n            return\n        if rChargedPrescribedDiffusion is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(charged_prescribed_diffusion.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficient data has only one dimension.\".format(self.name))\n        elif len(charged_prescribed_diffusion.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed charged diffusion coefficient data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(charged_prescribed_diffusion.shape) == 3:\n            if tChargedPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 3D charged diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z != charged_prescribed_diffusion.shape[0] or tChargedPrescribedDiffusion.size != charged_prescribed_diffusion.shape[1] or rChargedPrescribedDiffusion.size != charged_prescribed_diffusion.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed charged diffusion coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, charged_prescribed_diffusion.shape.shape[0], charged_prescribed_diffusion.shape.shape[1], charged_prescribed_diffusion.shape.shape[2], self.Z, tChargedPrescribedDiffusion.size, rChargedPrescribedDiffusion.size))\n            self.tChargedPrescribedDiffusion = tChargedPrescribedDiffusion\n            self.rChargedPrescribedDiffusion = rChargedPrescribedDiffusion\n            self.charged_prescribed_diffusion = charged_prescribed_diffusion\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed charged diffusion coefficient: {}.\".format(self.name, charged_prescribed_diffusion.shape))",
  "def initialize_neutral_prescribed_diffusion(self, neutral_prescribed_diffusion=None, rNeutralPrescribedDiffusion=None, tNeutralPrescribedDiffusion=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the neutral diffusion coefficients for this ion species.\n        \"\"\"\n        self.neutral_diffusion_mode = ION_NEUTRAL_DIFFUSION_MODE_PRESCRIBED\n        if neutral_prescribed_diffusion is None:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral diffusion coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(neutral_prescribed_diffusion) == list:\n            neutral_prescribed_diffusion = np.array(neutral_prescribed_diffusion)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(neutral_prescribed_diffusion):\n            self.tNeutralPrescribedDiffusion = np.array([0])\n            self.rNeutralPrescribedDiffusion = np.array([0,1])\n            self.neutral_prescribed_diffusion = np.ones((1,1,2)) * neutral_prescribed_diffusion\n            return\n        if rNeutralPrescribedDiffusion is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(neutral_prescribed_diffusion.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral diffusion coefficient data has only one dimension.\".format(self.name))\n        # As there is only one neutral charge state for a single species, all information needed here can actually be provided in a 2D array\n        elif len(neutral_prescribed_diffusion.shape) == 2:\n            if tNeutralPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 2D neutral diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if tNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[0] or rNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral diffusion coefficient: {}x{}. Expected {}x{}\"\n                    .format(self.name, neutral_prescribed_diffusion.shape.shape[0], neutral_prescribed_diffusion.shape.shape[1], tNeutralPrescribedDiffusion.size, rNeutralPrescribedDiffusion.size))\n            self.tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion\n            self.rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion\n            self.neutral_prescribed_diffusion = neutral_prescribed_diffusion.reshape((1,neutral_prescribed_diffusion.shape[0],neutral_prescribed_diffusion.shape[1]))\n        # Full time evolution of radial profiles of charge states\n        elif len(neutral_prescribed_diffusion.shape) == 3:\n            if tNeutralPrescribedDiffusion is None:\n                raise EquationException(\"ion_species: '{}': 3D neutral diffusion coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if neutral_prescribed_diffusion.shape[0] != 1 or tNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[1] or rNeutralPrescribedDiffusion.size != neutral_prescribed_diffusion.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral diffusion coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, neutral_prescribed_diffusion.shape[0], neutral_prescribed_diffusion.shape[1], neutral_prescribed_diffusion.shape[2], self.Z, tNeutralPrescribedDiffusion.size, rNeutralPrescribedDiffusion.size))\n            self.tNeutralPrescribedDiffusion = tNeutralPrescribedDiffusion\n            self.rNeutralPrescribedDiffusion = rNeutralPrescribedDiffusion\n            self.neutral_prescribed_diffusion = neutral_prescribed_diffusion\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed neutral diffusion coefficient: {}.\".format(self.name, neutral_prescribed_diffusion.shape))",
  "def initialize_charged_prescribed_advection(self, charged_prescribed_advection=None, rChargedPrescribedAdvection=None, tChargedPrescribedAdvection=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the charged advection coefficients for this ion species.\n        \"\"\"\n        self.charged_advection_mode = ION_CHARGED_ADVECTION_MODE_PRESCRIBED\n        if charged_prescribed_advection is None:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(charged_prescribed_advection) == list:\n            charged_prescribed_advection = np.array(charged_prescribed_advection)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(charged_prescribed_advection):\n            self.tChargedPrescribedAdvection = np.array([0])\n            self.rChargedPrescribedAdvection = np.array([0,1])\n            self.charged_prescribed_advection = np.ones((self.Z,1,2)) * charged_prescribed_advection\n            return\n        if rChargedPrescribedAdvection is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(charged_prescribed_advection.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficient data has only one dimension.\".format(self.name))\n        elif len(charged_prescribed_advection.shape) == 2:\n            raise EquationException(\"ion_species: '{}': Prescribed charged advection coefficient data has only two dimensions.\".format(self.name))\n        # Full time evolution of radial profiles of charge states\n        elif len(charged_prescribed_advection.shape) == 3:\n            if tChargedPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 3D charged advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if self.Z != charged_prescribed_advection.shape[0] or tChargedPrescribedAdvection.size != charged_prescribed_advection.shape[1] or rChargedPrescribedAdvection.size != charged_prescribed_advection.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed charged advection coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, charged_prescribed_advection.shape.shape[0], charged_prescribed_advection.shape.shape[1], charged_prescribed_advection.shape.shape[2], self.Z, tChargedPrescribedAdvection.size, rChargedPrescribedAdvection.size))\n            self.tChargedPrescribedAdvection = tChargedPrescribedAdvection\n            self.rChargedPrescribedAdvection = rChargedPrescribedAdvection\n            self.charged_prescribed_advection = charged_prescribed_advection\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed charged advection coefficient: {}.\".format(self.name, charged_prescribed_advection.shape))",
  "def initialize_neutral_prescribed_advection(self, neutral_prescribed_advection=None, rNeutralPrescribedAdvection=None, tNeutralPrescribedAdvection=None, interpr=None, interpt=None):\n        \"\"\"\n        Prescribes the evolution of the neutral advection coefficients for this ion species.\n        \"\"\"\n        self.neutral_advection_mode = ION_NEUTRAL_ADVECTION_MODE_PRESCRIBED\n        if neutral_prescribed_advection is None:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral advection coefficients must not be 'None'.\".format(self.name))\n\n        # Convert lists to NumPy arrays\n        if type(neutral_prescribed_advection) == list:\n            neutral_prescribed_advection = np.array(neutral_prescribed_advection)\n\n        # Scalar (assume density constant in spacetime)\n        if np.isscalar(neutral_prescribed_advection):\n            self.tNeutralPrescribedAdvection = np.array([0])\n            self.rNeutralPrescribedAdvection = np.array([0,1])\n            self.neutral_prescribed_advection = np.ones((1,1,2)) * neutral_prescribed_advection\n            return\n        if rNeutralPrescribedAdvection is None:\n            raise EquationException(\"ion_species: '{}': Non-scalar density prescribed, but no radial coordinates given.\".format(self.name))\n\n        if len(neutral_prescribed_advection.shape) == 1:\n            raise EquationException(\"ion_species: '{}': Prescribed neutral advection coefficient data has only one dimension.\".format(self.name))\n        # As there is only one neutral charge state for a single species, all information needed here can actually be provided in a 2D array\n        elif len(neutral_prescribed_advection.shape) == 2:\n            if tNeutralPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 2D neutral advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if tNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[0] or rNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[1]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral advection coefficient: {}x{}. Expected {}x{}\"\n                    .format(self.name, neutral_prescribed_advection.shape.shape[0], neutral_prescribed_advection.shape.shape[1], tNeutralPrescribedAdvection.size, rNeutralPrescribedAdvection.size))\n            self.tNeutralPrescribedAdvection = tNeutralPrescribedAdvection\n            self.rNeutralPrescribedAdvection = rNeutralPrescribedAdvection\n            self.neutral_prescribed_advection = neutral_prescribed_advection.reshape((1,neutral_prescribed_advection.shape[0],neutral_prescribed_advection.shape[1]))\n        # Full time evolution of radial profiles of charge states\n        elif len(neutral_prescribed_advection.shape) == 3:\n            if tNeutralPrescribedAdvection is None:\n                raise EquationException(\"ion_species: '{}': 3D neutral advection coefficient prescribed, but no time coordinates given.\".format(self.name))\n\n            if neutral_prescribed_advection.shape[0] != 1 or tNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[1] or rNeutralPrescribedAdvection.size != neutral_prescribed_advection.shape[2]:\n                raise EquationException(\"ion_species: '{}': Invalid dimensions of prescribed neutral advection coefficient: {}x{}x{}. Expected {}x{}x{}\"\n                    .format(self.name, neutral_prescribed_advection.shape.shape[0], neutral_prescribed_advection.shape.shape[1], neutral_prescribed_advection.shape.shape[2], self.Z, tNeutralPrescribedAdvection.size, rNeutralPrescribedAdvection.size))\n            self.tNeutralPrescribedAdvection = tNeutralPrescribedAdvection\n            self.rNeutralPrescribedAdvection = rNeutralPrescribedAdvection\n            self.neutral_prescribed_advection = neutral_prescribed_advection\n        else:\n            raise EquationException(\"ion_species: '{}': Unrecognized shape of prescribed neutral advection coefficient: {}.\".format(self.name, neutral_prescribed_advection.shape))",
  "def initialize_source(self, n, t=None, Z0=0):\n        \"\"\"\n        Initialize the ion source term associated with this species.\n        \"\"\"\n        self.source_type = ION_SOURCE_PRESCRIBED\n\n        if n is None:\n            raise EquationException(f\"ion_species: '{self.name}': Input source density must not be 'None'.\")\n\n        # Convert lists to NumPy arrays\n        if type(n) == list:\n            n = np.array(n)\n\n        # Scalar (assume density constant in spacetime)\n        #if type(n) == float or (type(n) == np.ndarray and n.size == 1):\n        if np.isscalar(n):\n            self.source_t = np.array([0])\n            self.source_n = np.zeros((self.Z+1,1))\n            self.source_n[Z0,:] = n\n            return\n\n        # Time evolution of neutral atoms\n        if len(n.shape) == 1:\n            if n.size != t.size:\n                raise EquationException(f\"ion_species: '{self.name}': Time evolving source specified, by shape(n) != shape(t), {n.shape} != {t.shape}.\")\n\n            self.source_t = t\n            self.source_n = np.zeros((self.Z+1, t.size))\n            self.source_n[Z0,:] = n\n        # Time evolution of all charge states\n        elif len(n.shape) == 2:\n            if t is None:\n                raise EquationException(f\"ion_species: '{self.name}': Full ion charge state density source prescribed, but no time coordinates given.\")\n\n            if self.Z+1 != n.shape[0] or t.size != n.shape[1]:\n                raise EquationException(f\"ion_species: '{self.name}': Invalid dimensions of prescribed source density: {n.shape[0]}x{n.shape[1]}x{n.shape[2]}. Expected {self.Z+1}x{t.size}x{r.size}\")\n\n            self.source_t = t\n            self.source_n = n\n        else:\n            raise EquationException(f\"ion_species: '{self.name}': Unrecognized shape of prescribed source density: {n.shape}.\")",
  "def calcTransportCoefficientExpdecaySingleChargeState(self, t_exp, c0, cf = 0, t_start = 0, r = None, t = None):\n        if t is None:\n            t = np.linspace(0,t_start+10*t_exp).reshape(-1,1)\n        if r is None:\n            r = np.linspace(0,self.settings.radialgrid.a)\n        if np.isscalar(c0):\n            Nr = len(r)\n            c0 = c0*np.ones((1,Nr))\n            \n        if np.isscalar(cf):\n            Nr = len(r)\n            cf = cf*np.ones((1,Nr))     \n                    \n        c_single_charge_state = (cf + np.exp(-(t-t_start)/t_exp)*(c0-cf))*(t>t_start)\n        \n        return c_single_charge_state, r.flatten(), t.flatten()",
  "def calcTransportCoefficientExpdecayAllChargedStates(self, t_exp, c0, cf = 0, t_start = 0, r = None, t = None):\n        c_single_charge_state, r, t = self.calcTransportCoefficientExpdecaySingleChargeState(t_exp, c0, cf, t_start, r, t)\n        cCharged = np.zeros((self.Z,len(t),len(c_single_charge_state)))\n        for i in range(self.Z):\n            cCharged[i,:,:]=c_single_charge_state\n        \n        return cCharged, r, t",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this ion species are correctly set.\n        \"\"\"\n        if self.Z < 1:\n            raise EquationException(\"ion_species: '{}': Invalid atomic charge: {}.\".format(self.name, self.Z))\n\n        if self.hydrogen or self.tritium:\n            if self.Z != 1:\n                raise EquationException(f\"ion_species: '{self.name}': Ion indicated as Hydrogen/Tritium, but charge Z = {self.Z}.\")\n\n        if self.ttype == IONS_PRESCRIBED:\n            if self.t.ndim != 1:\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif self.r.ndim != 1:\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif self.n is None or (self.n.shape != (self.Z+1, self.t.size, self.r.size)):\n                raise EquationException(\"ion_species: '{}': Invalid dimensions for input density: {}x{}x{}. Expected {}x{}x{}.\"\n                    .format(self.name, self.n.shape[0], self.n.shape[1], self.n.shape[2], self.Z+1, self.t.size, self.r.size))\n        elif self.ttype == IONS_EQUILIBRIUM or self.ttype == IONS_DYNAMIC:\n            if (self.r is None) or (self.r.ndim != 1):\n                raise EquationException(\"ion_species: '{}': The time vector must be 1D.\".format(self.name))\n            elif (self.n is None) or (self.n.shape != (self.Z+1, self.r.size)):\n                raise EquationException(\"ion_species: '{}': Invalid dimensions for input density: {}x{}. Expected {}x{}.\"\n                    .format(self.name, self.n.shape[0], self.n.shape[1], self.Z+1, self.r.size))",
  "class ColdElectronTemperature(PrescribedParameter,PrescribedInitialParameter,UnknownQuantity):\n    \n    def __init__(self, settings, ttype=TYPE_PRESCRIBED, temperature=None, radius=0, times=0, recombination=RECOMBINATION_RADIATION_NEGLECTED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        self.temperature = None\n        self.radius = None\n        self.times  = None\n\n        self.transport = TransportSettings(kinetic=False)\n        self.recombination = recombination\n\n        if (ttype == TYPE_PRESCRIBED) and (temperature is not None):\n            self.setPrescribedData(temperature=temperature, radius=radius, times=times)\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.setInitialProfile(temperature=temperature, radius=radius)\n\n\n    ###################\n    # SETTERS\n    ###################\n    def setInitialProfile(self, temperature, radius=0):\n        \"\"\"\n        Sets the initial temperature profile T=T(r) for when the temperature is\n        evolved self-consistently.\n\n        :param temperature: Scalar or vector giving the initial temperature profile.\n        :param radius: If ``temperature`` is a vector, contains the corresponding radial grid on which ``temperature`` is defined.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=temperature, radius=radius)\n\n        self.temperature = _data\n        self.radius      = _rad\n        self.times       = None\n\n        self.verifySettingsPrescribedInitialData()\n\n\n    def setPrescribedData(self, temperature, radius=0, times=0):\n        \"\"\"\n        Prescribes a temperature evolution in time and space.\n\n        :param temperature: Scalar, vector or matrix giving the temperature throughout the simulation.\n        :param radius: If ``temperature`` is a function of radius, contains the radial grid on which it is defined.\n        :param times: If ``temperature`` is a function of time, contains the time grid on which it is defined.\n        \"\"\"\n        _t, _rad, _tim = self._setPrescribedData(temperature, radius, times)\n        self.temperature = _t\n        self.radius      = _rad\n        self.times       = _tim\n\n        self.verifySettingsPrescribedData()\n\n\n    def setType(self, ttype):\n        \"\"\"\n        Specifies whether to evolve the electron temperature according to a\n        prescribed function, or self-consistently.\n\n        :param ttype: Type of evolution. Can take one of the following values:\n\n        - ``TYPE_PRESCRIBED``: Evolve according to prescribed function.\n        - ``TYPE_SELFCONSISTENT``: Evolve self-consistently.\n        \"\"\"\n        if ttype == TYPE_PRESCRIBED:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n\n            # Set T=0 if 'setInitialProfile' has not been previously called\n            # (if 'setInitialProfile()' has been called, 'self.radius != None'\n            # and 'self.times == None')\n            if (self.radius) is None or (self.times is not None):\n                self.setInitialProfile(temperature=-1)\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))\n\n\n    def setRecombinationRadiation(self, recombination=RECOMBINATION_RADIATION_NEGLECTED):\n        \"\"\"\n        Specify whether or not to include recombination radiation when evolving\n        the temperature self-consistently.\n        \"\"\"\n        self.recombination = recombination\n\n    \n    def fromdict(self, data):\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.temperature = data['data']['x']\n            self.radius = data['data']['r']\n            self.times = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            self.temperature = data['init']['x']\n            self.radius = data['init']['r']\n\n            if 'transport' in data:\n                self.transport.fromdict(data['transport'])\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))\n        if 'recombination' in data:\n            self.recombination = data['recombination']\n\n        self.verifySettings()\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n        data['recombination'] = self.recombination\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.temperature,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            data['init'] = {\n                'x': self.temperature,\n                'r': self.radius\n            }\n            data['transport'] = self.transport.todict()\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.temperature) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no temperature data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            if type(self.temperature) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no temperature data provided.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedInitialData()\n            self.transport.verifySettings()\n        else:\n            raise EquationException(\"T_cold: Unrecognized equation type specified: {}.\".format(self.type))\n\n\n    def verifySettingsPrescribedData(self):\n        self._verifySettingsPrescribedData('T_cold', self.temperature, self.radius, self.times)\n\n    def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('T_cold', data=self.temperature, radius=self.radius)",
  "def __init__(self, settings, ttype=TYPE_PRESCRIBED, temperature=None, radius=0, times=0, recombination=RECOMBINATION_RADIATION_NEGLECTED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.setType(ttype=ttype)\n\n        self.temperature = None\n        self.radius = None\n        self.times  = None\n\n        self.transport = TransportSettings(kinetic=False)\n        self.recombination = recombination\n\n        if (ttype == TYPE_PRESCRIBED) and (temperature is not None):\n            self.setPrescribedData(temperature=temperature, radius=radius, times=times)\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.setInitialProfile(temperature=temperature, radius=radius)",
  "def setInitialProfile(self, temperature, radius=0):\n        \"\"\"\n        Sets the initial temperature profile T=T(r) for when the temperature is\n        evolved self-consistently.\n\n        :param temperature: Scalar or vector giving the initial temperature profile.\n        :param radius: If ``temperature`` is a vector, contains the corresponding radial grid on which ``temperature`` is defined.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=temperature, radius=radius)\n\n        self.temperature = _data\n        self.radius      = _rad\n        self.times       = None\n\n        self.verifySettingsPrescribedInitialData()",
  "def setPrescribedData(self, temperature, radius=0, times=0):\n        \"\"\"\n        Prescribes a temperature evolution in time and space.\n\n        :param temperature: Scalar, vector or matrix giving the temperature throughout the simulation.\n        :param radius: If ``temperature`` is a function of radius, contains the radial grid on which it is defined.\n        :param times: If ``temperature`` is a function of time, contains the time grid on which it is defined.\n        \"\"\"\n        _t, _rad, _tim = self._setPrescribedData(temperature, radius, times)\n        self.temperature = _t\n        self.radius      = _rad\n        self.times       = _tim\n\n        self.verifySettingsPrescribedData()",
  "def setType(self, ttype):\n        \"\"\"\n        Specifies whether to evolve the electron temperature according to a\n        prescribed function, or self-consistently.\n\n        :param ttype: Type of evolution. Can take one of the following values:\n\n        - ``TYPE_PRESCRIBED``: Evolve according to prescribed function.\n        - ``TYPE_SELFCONSISTENT``: Evolve self-consistently.\n        \"\"\"\n        if ttype == TYPE_PRESCRIBED:\n            self.type = ttype\n        elif ttype == TYPE_SELFCONSISTENT:\n            self.type = ttype\n\n            # Set T=0 if 'setInitialProfile' has not been previously called\n            # (if 'setInitialProfile()' has been called, 'self.radius != None'\n            # and 'self.times == None')\n            if (self.radius) is None or (self.times is not None):\n                self.setInitialProfile(temperature=-1)\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))",
  "def setRecombinationRadiation(self, recombination=RECOMBINATION_RADIATION_NEGLECTED):\n        \"\"\"\n        Specify whether or not to include recombination radiation when evolving\n        the temperature self-consistently.\n        \"\"\"\n        self.recombination = recombination",
  "def fromdict(self, data):\n        self.type = data['type']\n\n        if self.type == TYPE_PRESCRIBED:\n            self.temperature = data['data']['x']\n            self.radius = data['data']['r']\n            self.times = data['data']['t']\n        elif self.type == TYPE_SELFCONSISTENT:\n            self.temperature = data['init']['x']\n            self.radius = data['init']['r']\n\n            if 'transport' in data:\n                self.transport.fromdict(data['transport'])\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))\n        if 'recombination' in data:\n            self.recombination = data['recombination']\n\n        self.verifySettings()",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this ColdElectrons object.\n        \"\"\"\n        data = { 'type': self.type }\n        data['recombination'] = self.recombination\n        if self.type == TYPE_PRESCRIBED:\n            data['data'] = {\n                'x': self.temperature,\n                'r': self.radius,\n                't': self.times\n            }\n        elif self.type == TYPE_SELFCONSISTENT:\n            data['init'] = {\n                'x': self.temperature,\n                'r': self.radius\n            }\n            data['transport'] = self.transport.todict()\n        else:\n            raise EquationException(\"T_cold: Unrecognized cold electron temperature type: {}\".format(self.type))\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.type == TYPE_PRESCRIBED:\n            if type(self.temperature) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no temperature data provided.\")\n            elif type(self.times) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no time data provided, or provided in an invalid format.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedData()\n        elif self.type == TYPE_SELFCONSISTENT:\n            if type(self.temperature) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no temperature data provided.\")\n            elif type(self.radius) != np.ndarray:\n                raise EquationException(\"T_cold: Temperature prescribed, but no radial data provided, or provided in an invalid format.\")\n\n            self.verifySettingsPrescribedInitialData()\n            self.transport.verifySettings()\n        else:\n            raise EquationException(\"T_cold: Unrecognized equation type specified: {}.\".format(self.type))",
  "def verifySettingsPrescribedData(self):\n        self._verifySettingsPrescribedData('T_cold', self.temperature, self.radius, self.times)",
  "def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('T_cold', data=self.temperature, radius=self.radius)",
  "class OhmicCurrent(PrescribedParameter,PrescribedInitialParameter,UnknownQuantity):\n    \n    def __init__(self, settings, condMode=CONDUCTIVITY_MODE_SAUTER_COLLISIONLESS, corrCond=CORRECTED_CONDUCTIVITY_ENABLED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.condMode     = condMode\n        self.corrCond     = corrCond\n\n        self.jpres        = None\n        self.jpres_radius = None\n        self.jpres_times  = None\n        self.jpres_Ip0    = None\n\n        self.jpres0        = None\n        self.jpres0_radius = None\n        self.jpres0_Ip0    = None\n\n\n    def setCorrectedConductivity(self, mode):\n        r\"\"\"\n        Specifies whether to use a conductivity correction, which is added\n        to the cold current carried by the distribution function\n        \n        :param int mode:    Type of conductivity correction to use\n        \"\"\"\n        if type(mode) == bool:\n            self.corrCond = CORRECTED_CONDUCTIVITY_ENABLED if mode else CORRECTED_CONDUCTIVITY_DISABLED\n        else:\n            self.corrCond = int(mode) \n\n\n    def setConductivityMode(self, mode):\n        r\"\"\"\n        Specifies the formula to use for the condictivity in the ohmic current. \n        The Sauter models are based on O Sauter, C Angioni, YR Lin-Liu, PoP (1999).\n        The underlying base 'Spitzer' (slab) conductivity used is the relativistic\n        BJ Braams, CFF Karney PoF (1989) formula, where we interpolate in the \n        tabulated values from the paper.\n\n        Possible modes are:\n\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | Name                                   | Description                                                                              |\n        +========================================+==========================================================================================+\n        | CONDUCTIVITY_MODE_BRAAMS               | Uses the base Braams & Karney formula                                                    |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | CONDUCTIVITY_MODE_SAUTER_COLLISIONLESS | Using the Sauter neoclassical correction in the collisionless limit (banana regime).     |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | CONDUCTIVITY_MODE_SAUTER_COLLISIONAL   | Uses the full Sauter model with collisional neoclassical corrections                     |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n\n        :param int mode:    Type of model to use for the plasma conductivity\n        \"\"\"\n        self.condMode = int(mode)\n\n\n    def setCurrentProfile(self, j, radius=0, times=0, Ip0=None):\n        \"\"\"\n        Prescribes a current profile evolution in time and space.\n\n        :param j:      Scalar, vector or matrix giving the current density throughout the simulation.\n        :param radius: If ``j`` is a function of radius, contains the radial grid on which it is defined.\n        :param times:  If ``j`` is a function of time, contains the time grid on which it is defined.\n        \"\"\"\n        _j, _rad, _tim = self._setPrescribedData(j, radius, times)\n        self.jpres  = _j\n        self.jpres_radius = _rad\n        self.jpres_times  = _tim\n        self.jpres_Ip0 = Ip0\n\n        self.jpres0 = None\n\n        self.verifySettingsPrescribedData()\n\n\n    def setInitialProfile(self, j, radius=0, Ip0=None):\n        \"\"\"\n        Prescribes the desired initial current profile j_tot=j_tot(r), for\n        when the electric field evolves self-consistently in time.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=j, radius=radius)\n\n        self.jpres0 = _data\n        self.jpres0_radius = _rad\n        self.jpres0_Ip0 = Ip0\n        \n        self.jpres = None\n\n        self.verifySettingsPrescribedInitialData()\n\n\n    def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'conductivityMode' in data:\n            self.condMode = data['conductivityMode']\n        if 'correctedConductivity' in data:\n            self.corrCond = data['correctedConductivity']\n\n        if 'jpres' in data:\n            self.jpres = data['data']['x']\n            self.jpres_radius = data['data']['r']\n            self.jpres_times = data['data']['t']\n\n            if 'Ip0' in data:\n                self.jpres_Ip0 = data['Ip0']\n        if 'jpres0' in data:\n            self.jpres0 = data['init']['x']\n            self.jpres0_radius = data['init']['r']\n\n            if 'Ip0' in data:\n                self.jpres0_Ip0 = data['Ip0']\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PoloidalFlux object.\n        \"\"\"\n        data = {\n            'conductivityMode': self.condMode,\n            'correctedConductivity': self.corrCond\n        }\n\n        if self.jpres is not None:\n            data['data'] = {\n                'x': self.jpres,\n                'r': self.jpres_radius,\n                't': self.jpres_times\n            }\n            \n            if self.jpres_Ip0 is not None:\n                data['Ip0'] = self.jpres_Ip0\n        elif self.jpres0 is not None:\n            data['init'] = {\n                'x': self.jpres0,\n                'r': self.jpres0_radius\n            }\n\n            if self.jpres0_Ip0 is not None:\n                data['Ip0'] = self.jpres0_Ip0\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.jpres is not None:\n            self.verifySettingsPrescribedData()\n        elif self.jpres0 is not None:\n            self.verifySettingsPrescribedInitialData()\n\n\n    def verifySettingsPrescribedData(self):\n        self._verifySettingsPrescribedData('j_ohm', self.jpres, self.jpres_radius, self.jpres_times)\n\n\n    def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('j_ohm', self.jpres0, self.jpres0_radius)",
  "def __init__(self, settings, condMode=CONDUCTIVITY_MODE_SAUTER_COLLISIONLESS, corrCond=CORRECTED_CONDUCTIVITY_ENABLED):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.condMode     = condMode\n        self.corrCond     = corrCond\n\n        self.jpres        = None\n        self.jpres_radius = None\n        self.jpres_times  = None\n        self.jpres_Ip0    = None\n\n        self.jpres0        = None\n        self.jpres0_radius = None\n        self.jpres0_Ip0    = None",
  "def setCorrectedConductivity(self, mode):\n        r\"\"\"\n        Specifies whether to use a conductivity correction, which is added\n        to the cold current carried by the distribution function\n        \n        :param int mode:    Type of conductivity correction to use\n        \"\"\"\n        if type(mode) == bool:\n            self.corrCond = CORRECTED_CONDUCTIVITY_ENABLED if mode else CORRECTED_CONDUCTIVITY_DISABLED\n        else:\n            self.corrCond = int(mode)",
  "def setConductivityMode(self, mode):\n        r\"\"\"\n        Specifies the formula to use for the condictivity in the ohmic current. \n        The Sauter models are based on O Sauter, C Angioni, YR Lin-Liu, PoP (1999).\n        The underlying base 'Spitzer' (slab) conductivity used is the relativistic\n        BJ Braams, CFF Karney PoF (1989) formula, where we interpolate in the \n        tabulated values from the paper.\n\n        Possible modes are:\n\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | Name                                   | Description                                                                              |\n        +========================================+==========================================================================================+\n        | CONDUCTIVITY_MODE_BRAAMS               | Uses the base Braams & Karney formula                                                    |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | CONDUCTIVITY_MODE_SAUTER_COLLISIONLESS | Using the Sauter neoclassical correction in the collisionless limit (banana regime).     |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n        | CONDUCTIVITY_MODE_SAUTER_COLLISIONAL   | Uses the full Sauter model with collisional neoclassical corrections                     |\n        +----------------------------------------+------------------------------------------------------------------------------------------+\n\n        :param int mode:    Type of model to use for the plasma conductivity\n        \"\"\"\n        self.condMode = int(mode)",
  "def setCurrentProfile(self, j, radius=0, times=0, Ip0=None):\n        \"\"\"\n        Prescribes a current profile evolution in time and space.\n\n        :param j:      Scalar, vector or matrix giving the current density throughout the simulation.\n        :param radius: If ``j`` is a function of radius, contains the radial grid on which it is defined.\n        :param times:  If ``j`` is a function of time, contains the time grid on which it is defined.\n        \"\"\"\n        _j, _rad, _tim = self._setPrescribedData(j, radius, times)\n        self.jpres  = _j\n        self.jpres_radius = _rad\n        self.jpres_times  = _tim\n        self.jpres_Ip0 = Ip0\n\n        self.jpres0 = None\n\n        self.verifySettingsPrescribedData()",
  "def setInitialProfile(self, j, radius=0, Ip0=None):\n        \"\"\"\n        Prescribes the desired initial current profile j_tot=j_tot(r), for\n        when the electric field evolves self-consistently in time.\n        \"\"\"\n        _data, _rad = self._setInitialData(data=j, radius=radius)\n\n        self.jpres0 = _data\n        self.jpres0_radius = _rad\n        self.jpres0_Ip0 = Ip0\n        \n        self.jpres = None\n\n        self.verifySettingsPrescribedInitialData()",
  "def fromdict(self, data):\n        \"\"\"\n        Set all options from a dictionary.\n        \"\"\"\n        if 'conductivityMode' in data:\n            self.condMode = data['conductivityMode']\n        if 'correctedConductivity' in data:\n            self.corrCond = data['correctedConductivity']\n\n        if 'jpres' in data:\n            self.jpres = data['data']['x']\n            self.jpres_radius = data['data']['r']\n            self.jpres_times = data['data']['t']\n\n            if 'Ip0' in data:\n                self.jpres_Ip0 = data['Ip0']\n        if 'jpres0' in data:\n            self.jpres0 = data['init']['x']\n            self.jpres0_radius = data['init']['r']\n\n            if 'Ip0' in data:\n                self.jpres0_Ip0 = data['Ip0']",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of\n        this PoloidalFlux object.\n        \"\"\"\n        data = {\n            'conductivityMode': self.condMode,\n            'correctedConductivity': self.corrCond\n        }\n\n        if self.jpres is not None:\n            data['data'] = {\n                'x': self.jpres,\n                'r': self.jpres_radius,\n                't': self.jpres_times\n            }\n            \n            if self.jpres_Ip0 is not None:\n                data['Ip0'] = self.jpres_Ip0\n        elif self.jpres0 is not None:\n            data['init'] = {\n                'x': self.jpres0,\n                'r': self.jpres0_radius\n            }\n\n            if self.jpres0_Ip0 is not None:\n                data['Ip0'] = self.jpres0_Ip0\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.jpres is not None:\n            self.verifySettingsPrescribedData()\n        elif self.jpres0 is not None:\n            self.verifySettingsPrescribedInitialData()",
  "def verifySettingsPrescribedData(self):\n        self._verifySettingsPrescribedData('j_ohm', self.jpres, self.jpres_radius, self.jpres_times)",
  "def verifySettingsPrescribedInitialData(self):\n        self._verifySettingsPrescribedInitialData('j_ohm', self.jpres0, self.jpres0_radius)",
  "class DistributionFunction(UnknownQuantity):\n    \n\n    def __init__(self, settings, name, grid,\n        f=[0], initr=[0], initp=[0], initxi=[0],\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=BC_PHI_CONST,\n        ad_int_r=AD_INTERP_CENTRED, ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED, ad_jac_r=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        mode = DISTRIBUTION_MODE_NUMERICAL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.name = name\n        self.grid = grid\n\n        self.boundarycondition = bc\n        \n        self.mode = mode\n        self.ripplemode = RIPPLE_MODE_NEGLECT\n        self.synchrotronmode = SYNCHROTRON_MODE_NEGLECT\n        self.timevaryingbmode = TIME_VARYING_B_MODE_NEGLECT\n        self.transport = TransportSettings(kinetic=True)\n        self.fullIonJacobian = True\n\n        self.advectionInterpolation = AdvectionInterpolation.AdvectionInterpolation(\n            kinetic=True,\n            ad_int_r=ad_int_r, ad_int_p1=ad_int_p1, ad_int_p2=ad_int_p2,\n            ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1, ad_jac_p2=ad_jac_p2,\n            fluxlimiterdamping=fluxlimiterdamping)\n\n        self.n0  = rn0\n        self.rn0 = n0\n\n        self.T0  = rT0\n        self.rT0 = T0\n\n        self.init = None\n\n        if f is not None:\n            self.setInitialValue(f, r=initr, p=initp, xi=initxi, ppar=initppar, pperp=initpperp)\n        elif n0 is not None:\n            self.setInitialProfiles(rn0=rn0, n0=n0, rT0=rT0, T0=T0)\n\n\n    def setBoundaryCondition(self, bc):\n        \"\"\"\n        Sets the boundary condition at p=pmax. For 'f_hot', this boundary\n        condition is only used when 'f_re' is disabled.\n\n        :param int bc: Flag specifying which boundary condition to use.\n        \"\"\"\n        self.boundarycondition = bc\n\n    def setAdvectionInterpolationMethod(self,ad_int=None, ad_int_r=AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED, ad_int_p2=AD_INTERP_CENTRED, ad_jac=None, \n        ad_jac_r=AD_INTERP_JACOBIAN_FULL, ad_jac_p1=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p2=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the kinetic equation. To set all three components, provide ad_int and/or ad_jac.\n        Otherwise the three components can use separate interpolation methods.\n        \n        :param int ad_int:               Interpolation method to use for all coordinates.\n        :param int ad_int_r:             Interpolation method to use for the radial coordinate.\n        :param int ad_int_p1:            Interpolation method to use for the first momentum coordinate.\n        :param int ad_int_p2:            Interpolation method to use for the second momentum coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for all coordinates.\n        :param int ad_jac_r:             Jacobian interpolation mode to use for the radial coordinate.\n        :param int ad_jac_p1:            Jacobian interpolation mode to use for the first momentum coordinate.\n        :param int ad_jac_p2:            Jacobian interpolation mode to use for the second momentum coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolation.setMethod(ad_int=ad_int, ad_int_r=ad_int_r,\n            ad_int_p1=ad_int_p1, ad_int_p2=ad_int_p2, ad_jac=ad_jac, \n            ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1,\n            ad_jac_p2=ad_jac_p2, fluxlimiterdamping=fluxlimiterdamping)\n\n\n    def setInitialProfiles(self, n0, T0, rn0=None, rT0=None):\n        \"\"\"\n        Sets the initial density and temperature profiles of the electron\n        population.\n\n        :param rn0: Radial grid on which the density is given.\n        :param n0:  Electron density profile.\n        :param rT0: Radial grid on which the temperature is given.\n        :param T0:  Electron temperature profile.\n        \"\"\"\n        if rn0 is not None:\n            self.rn0 = np.asarray(rn0)\n        else:\n            if not np.isscalar(n0):\n                raise EquationException(\"{}: Non-scalar initial density profile given, but no radial grid specified.\".format(self.name))\n            self.rn0 = np.array([0])\n\n        if rT0 is not None:\n            self.rT0 = np.asarray(rT0)\n        else:\n            if not np.isscalar(T0):\n                raise EquationException(\"{}: Non-scalar initial temperature profile given, but no radial grid specified.\".format(self.name))\n            self.rT0 = np.array([0])\n\n        self.n0  = np.asarray(n0)\n        self.T0  = np.asarray(T0)\n\n        if self.rn0.ndim == 0: self.rn0 = np.asarray([self.rn0])\n        if self.n0.ndim == 0:  self.n0 = np.asarray([self.n0])\n        if self.rT0.ndim == 0: self.rT0 = np.asarray([self.rT0])\n        if self.T0.ndim == 0:  self.T0 = np.asarray([self.T0])\n\n        # Reset numerically provided distribution (if any)\n        self.init = None\n\n        self.verifyInitialProfiles()\n\n\n    def setInitialValue(self, f, r, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the initial value of this electron distribution function. Only one\n        of the pairs (p, xi) and (ppar, pperp) of momentum grids need to be\n        given.\n\n        :param f:     Array representing the distribution function value on the grid (must have size (nr, nxi, np) or (nr, npperp, nppar))\n        :param r:     Radial grid on which the initial distribution is given.\n        :param p:     Momentum grid.\n        :param xi:    Pitch grid.\n        :param ppar:  Parallel momentum grid.\n        :param pperp: Perpendicular momentum grid.\n        \"\"\"\n        self.init = {}\n\n        def conv(v):\n            if type(v) == list:\n                return np.array(v)\n            elif type(v) == float or type(v) == int:\n                return np.array([float(v)])\n            else:\n                return v\n\n        ff = conv(f)\n        self.init['r'] = conv(r)\n\n        if p is not None and xi is not None:\n            self.init['p'] = conv(p)\n            self.init['xi'] = conv(xi)\n            self.init['ppar'] = np.array([])\n            self.init['pperp'] = np.array([])\n\n            if ff.size == 1:\n                ff = ff * np.ones((self.init['r'].size, self.init['xi'].size, self.init['p'].size))\n        elif ppar is not None and pperp is not None:\n            self.init['ppar'] = conv(ppar)\n            self.init['pperp'] = conv(pperp)\n            self.init['p'] = np.array([])\n            self.init['xi'] = np.array([])\n\n            if ff.size == 1:\n                ff = ff * np.ones((self.init['r'].size, self.init['pperp'].size, self.init['ppar'].size))\n        else:\n            raise EquationException(\"{}: No momentum grid given for initial value.\".format(self.name))\n\n        self.init['x'] = ff\n\n        # Reset initial profiles (if any)\n        self.rn0 = self.rT0 = None\n        self.n0 = self.T0 = None\n\n        self.verifyInitialDistribution()\n\n\n    def enableAnalyticalDistribution(self, mode=True):\n        \"\"\"\n        Enables/disables the use of an analytical distribution\n        function to represent the electron population\n        \"\"\"\n        if mode:\n            self.mode = DISTRIBUTION_MODE_ANALYTICAL\n        else:\n            self.mode = DISTRIBUTION_MODE_NUMERICAL\n\n\n    def setRippleMode(self, mode):\n        \"\"\"\n        Enables/disables inclusion of pitch scattering due to the magnetic ripple.\n\n        :param int mode: Flag indicating whether or not to include magnetic ripple effects.\n        \"\"\"\n        if type(mode) == bool:\n            self.ripplemode = RIPPLE_MODE_BOX if mode else RIPPLE_MODE_NEGLECT\n        else:\n            self.ripplemode = int(mode)\n\n\n    def setTimeVaryingB(self, mode):\n        \"\"\"\n        Enables/disable the time-varying magnetic field strength operator.\n\n        :param int mode: Flag indicating whether or not to include the time-varying magnetic field operator.\n        \"\"\"\n        if type(mode) == bool:\n            self.timevaryingbmode = TIME_VARYING_B_MODE_INCLUDE if mode else TIME_VARYING_B_MODE_NEGLECT\n        else:\n            self.timevaryingbmode = int(mode)\n\n\n    def setSynchrotronMode(self, mode):\n        \"\"\"\n        Sets the type of synchrotron losses to have (either enabled or disabled).\n\n        :param int mode: Flag indicating whether or not to enable synchrotron losses (may be bool).\n        \"\"\"\n        if type(mode) == bool:\n            self.synchrotronmode = SYNCHROTRON_MODE_INCLUDE if mode else SYNCHROTRON_MODE_NEGLECT\n        else:\n            self.synchrotronmode = int(mode)\n\n    def enableIonJacobian(self, includeJacobian):\n        \"\"\"\n        Enables/disables the ion jacobian in the kinetic equation.\n\n        :param bool includeJacobian: Flag indicating whether the ion jacobian will be added. True by default, False to disable.\n        \"\"\"\n        self.fullIonJacobian = includeJacobian\n\n    def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n\n        :param dict data: Dictionary to load distribution function from.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        if 'mode' in data:\n            self.mode = data['mode']\n        if 'boundarycondition' in data:\n            self.boundarycondition = data['boundarycondition']\n\n        if 'adv_interp' in data:\n            self.advectionInterpolation.fromdict(data['adv_interp'])\n\n        if 'init' in data:\n            self.init = data['init']\n        elif ('n0' in data) and ('T0' in data):\n            self.rn0 = data['n0']['r']\n            self.n0  = data['n0']['x']\n            self.rT0 = data['T0']['r']\n            self.T0  = data['T0']['x']\n\n        if 'ripplemode' in data:\n            self.ripplemode = int(scal(data['ripplemode']))\n\n        if 'timevaryingbmode' in data:\n            self.timevaryingbmode = int(scal(data['timevaryingbmode']))\n\n        if 'synchrotronmode' in data:\n            self.synchrotronmode = data['synchrotronmode']\n            if type(self.synchrotronmode) != int:\n                self.synchrotronmode = int(self.synchrotronmode[0])\n\n        if 'transport' in data:\n            self.transport.fromdict(data['transport'])\n\n        if 'fullIonJacobian' in data:\n            self.fullIonJacobian = bool(data['fullIonJacobian'])\n\n        self.verifySettings()\n\n\n    def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of this\n        DistributionFunction object.\n\n        :return: a dictionary, containing all settings of this object, which can be directly given to DREAM.\n        \"\"\"\n        data = {}\n        data['mode'] = self.mode\n        if self.grid.enabled:\n            data = {'boundarycondition': self.boundarycondition}\n\n            # Advection interpolation\n            data['adv_interp'] = self.advectionInterpolation.todict()\n\n            if self.init:\n                data['init'] = {}\n                data['init']['x'] = self.init['x']\n                data['init']['r'] = self.init['r']\n\n                if self.init['p'].size > 0 and self.init['xi'].size > 0:\n                    data['init']['p'] = self.init['p']\n                    data['init']['xi'] = self.init['xi']\n                elif self.init['ppar'].size > 0 and self.init['pperp'].size > 0:\n                    data['init']['ppar'] = self.init['ppar']\n                    data['init']['pperp'] = self.init['pperp']\n            elif self.n0 is not None:\n                data['n0'] = { 'r': self.rn0, 'x': self.n0 }\n                data['T0'] = { 'r': self.rT0, 'x': self.T0 }\n            \n            data['ripplemode'] = self.ripplemode\n            data['synchrotronmode'] = self.synchrotronmode\n            data['timevaryingbmode'] = self.timevaryingbmode\n            data['transport'] = self.transport.todict()\n            data['fullIonJacobian'] = self.fullIonJacobian\n\n        if self.mode != DISTRIBUTION_MODE_NUMERICAL:\n            data['n0'] = { 'r': self.rn0, 'x': self.n0 }\n            data['T0'] = { 'r': self.rT0, 'x': self.T0 }\n\n\n        return data\n\n\n    def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.grid.enabled:\n            if self.mode != DISTRIBUTION_MODE_NUMERICAL:\n                raise EquationException(\"{}: Invalid mode set. Must be 'NUMERICAL' when the grid is 'enabled'.\".format(self.name))\n            bc = self.boundarycondition\n            if (bc != BC_F_0) and (bc != BC_PHI_CONST) and (bc != BC_DPHI_CONST):\n                raise EquationException(\"{}: Invalid external boundary condition set: {}.\".format(self.name, bc))\n            if self.init is not None:\n                self.verifyInitialDistribution()\n            elif (self.n0 is not None) or (self.T0 is not None):\n                self.verifyInitialProfiles()\n            else:\n                raise EquationException(\"{}: Invalid/no initial condition set for the distribution function.\".format(self.name))\n\n            self.advectionInterpolation.verifySettings()\n\n            if type(self.ripplemode) == bool:\n                self.setRippleMode(self.ripplemode)\n            elif type(self.ripplemode) != int:\n                raise EquationException(\"{}: Invalid type of ripple mode option: {}\".format(self.name, type(self.ripplemode)))\n            else:\n                opt = [RIPPLE_MODE_NEGLECT, RIPPLE_MODE_BOX, RIPPLE_MODE_GAUSSIAN]\n                if self.ripplemode not in opt:\n                    raise EquationException(\"{}: Invalid option for ripple mode: {}.\".format(self.name, self.ripplemode))\n \n            if type(self.synchrotronmode) == bool:\n                self.setSynchrotronMode(self.synchrotronmode)\n            elif type(self.synchrotronmode) != int:\n                raise EquationException(\"{}: Invalid type of synchrotron mode option: {}\".format(self.name, type(self.synchrotronmode)))\n            else:\n                opt = [SYNCHROTRON_MODE_NEGLECT, SYNCHROTRON_MODE_INCLUDE]\n                if self.synchrotronmode not in opt:\n                    raise EquationException(\"{}: Invalid option for synchrotron mode: {}\".format(self.name, self.synchrotronmode))\n\n            if type(self.timevaryingbmode) == bool:\n                self.setTimeVaryingBMode(self.timevaryingbmode)\n            elif type(self.timevaryingbmode) != int:\n                raise EquationException(f\"{self.name}: Invalid type of time-varying B mode option: {self.timevaryingbmode}.\")\n            else:\n                opt = [TIME_VARYING_B_MODE_NEGLECT, TIME_VARYING_B_MODE_INCLUDE]\n                if self.timevaryingbmode not in opt:\n                    raise EquationException(f\"{self.name}: Invalid option for time-varying B mode: {self.timevaryingbmode}.\")\n\n            self.transport.verifySettings()\n        elif self.mode != DISTRIBUTION_MODE_NUMERICAL:\n            # if fluid mode and analytical distribution,\n            # initial profiles must be provided:\n            self.verifyInitialProfiles()\n\n\n    def verifyInitialDistribution(self):\n        \"\"\"\n        Verifies that the initial distribution function has\n        been set correctly and consistently.\n        \"\"\"\n        if self.init is None:\n            raise EquationException(\"{}: No initial distribution function specified.\".format(self.name))\n\n        nr = self.init['r'].size\n        p1, p2 = None, None\n        p1name, p2name = None, None\n        np1, np2 = 0, 0\n\n        if self.init['p'].size > 0 and self.init['xi'].size > 0:\n            p1name = 'p'\n            p2name = 'xi'\n        elif self.init['ppar'].size > 0 and self.init['pperp'].size > 0:\n            p1name = 'ppar'\n            p2name = 'pperp'\n        else:\n            raise EquationException(\"{}: No momentum grid given for initial value.\".format(self.name))\n\n        p1 = self.init[p1name]\n        p2 = self.init[p2name]\n\n        if len(p1.shape) != 1:\n            raise EquationException(\"{}: Invalid dimensions of momentum grid '{}'. Must be 1D array.\".format(self.name, p1name))\n        elif len(p2.shape) != 1:\n            raise EquationException(\"{}: Invalid dimensions of momentum grid '{}'. Must be 1D array.\".format(self.name, p2name))\n\n        np1 = p1.size\n        np2 = p2.size\n\n        if self.init['x'].shape != (nr, np2, np1):\n            raise EquationException(\"{}: Invalid size of initial distribution function: {}. Expected: {}.\".format(self.name, self.init['x'].shape, (nr, np2, np1)))\n\n\n    def verifyInitialProfiles(self):\n        \"\"\"\n        Verifies that the initial density and temperature profiles\n        are set correctly.\n        \"\"\"\n        if (self.n0 is None) or (self.T0 is None):\n            raise EquationException(\"{}: No initial density and/or temperature profiles specified.\".format(self.name))\n        if (self.rn0 is None) or (self.rT0 is None):\n            raise EquationException(\"{}: No radial grids specified for the density and/or temperature profiles.\".format(self.name))\n\n        if (self.n0.ndim != 1) or (self.rn0.ndim != 1) or (self.n0.size != self.rn0.size):\n            raise EquationException(\"{}: Invalid number of elements of density profile: {}. Corresponding radial grid has {} elements.\"\n                .format(self.name, self.n0.size, self.rn0.size))\n        if (self.T0.ndim != 1) or (self.rT0.ndim != 1) or (self.T0.size != self.rT0.size):\n            raise EquationException(\"{}: Invalid number of elements of temperature profile: {}. Corresponding radial grid has {} elements.\"\n                .format(self.name, self.T0.size, self.rT0.size))",
  "def __init__(self, settings, name, grid,\n        f=[0], initr=[0], initp=[0], initxi=[0],\n        initppar=None, initpperp=None,\n        rn0=None, n0=None, rT0=None, T0=None, bc=BC_PHI_CONST,\n        ad_int_r=AD_INTERP_CENTRED, ad_int_p1=AD_INTERP_CENTRED,\n        ad_int_p2=AD_INTERP_CENTRED, ad_jac_r=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p1=AD_INTERP_JACOBIAN_FULL, ad_jac_p2=AD_INTERP_JACOBIAN_FULL,\n        mode = DISTRIBUTION_MODE_NUMERICAL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__(settings=settings)\n\n        self.name = name\n        self.grid = grid\n\n        self.boundarycondition = bc\n        \n        self.mode = mode\n        self.ripplemode = RIPPLE_MODE_NEGLECT\n        self.synchrotronmode = SYNCHROTRON_MODE_NEGLECT\n        self.timevaryingbmode = TIME_VARYING_B_MODE_NEGLECT\n        self.transport = TransportSettings(kinetic=True)\n        self.fullIonJacobian = True\n\n        self.advectionInterpolation = AdvectionInterpolation.AdvectionInterpolation(\n            kinetic=True,\n            ad_int_r=ad_int_r, ad_int_p1=ad_int_p1, ad_int_p2=ad_int_p2,\n            ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1, ad_jac_p2=ad_jac_p2,\n            fluxlimiterdamping=fluxlimiterdamping)\n\n        self.n0  = rn0\n        self.rn0 = n0\n\n        self.T0  = rT0\n        self.rT0 = T0\n\n        self.init = None\n\n        if f is not None:\n            self.setInitialValue(f, r=initr, p=initp, xi=initxi, ppar=initppar, pperp=initpperp)\n        elif n0 is not None:\n            self.setInitialProfiles(rn0=rn0, n0=n0, rT0=rT0, T0=T0)",
  "def setBoundaryCondition(self, bc):\n        \"\"\"\n        Sets the boundary condition at p=pmax. For 'f_hot', this boundary\n        condition is only used when 'f_re' is disabled.\n\n        :param int bc: Flag specifying which boundary condition to use.\n        \"\"\"\n        self.boundarycondition = bc",
  "def setAdvectionInterpolationMethod(self,ad_int=None, ad_int_r=AD_INTERP_CENTRED,\n        ad_int_p1=AD_INTERP_CENTRED, ad_int_p2=AD_INTERP_CENTRED, ad_jac=None, \n        ad_jac_r=AD_INTERP_JACOBIAN_FULL, ad_jac_p1=AD_INTERP_JACOBIAN_FULL,\n        ad_jac_p2=AD_INTERP_JACOBIAN_FULL, fluxlimiterdamping=1.0):\n        \"\"\"\n        Sets the interpolation method that is used in the advection terms of\n        the kinetic equation. To set all three components, provide ad_int and/or ad_jac.\n        Otherwise the three components can use separate interpolation methods.\n        \n        :param int ad_int:               Interpolation method to use for all coordinates.\n        :param int ad_int_r:             Interpolation method to use for the radial coordinate.\n        :param int ad_int_p1:            Interpolation method to use for the first momentum coordinate.\n        :param int ad_int_p2:            Interpolation method to use for the second momentum coordinate.\n        :param int ad_jac:               Jacobian interpolation mode to use for all coordinates.\n        :param int ad_jac_r:             Jacobian interpolation mode to use for the radial coordinate.\n        :param int ad_jac_p1:            Jacobian interpolation mode to use for the first momentum coordinate.\n        :param int ad_jac_p2:            Jacobian interpolation mode to use for the second momentum coordinate.\n        :param float fluxlimiterdamping: Damping parameter used to under-relax the interpolation coefficients during non-linear iterations (should be between 0 and 1).\n        \"\"\"\n        self.advectionInterpolation.setMethod(ad_int=ad_int, ad_int_r=ad_int_r,\n            ad_int_p1=ad_int_p1, ad_int_p2=ad_int_p2, ad_jac=ad_jac, \n            ad_jac_r=ad_jac_r, ad_jac_p1=ad_jac_p1,\n            ad_jac_p2=ad_jac_p2, fluxlimiterdamping=fluxlimiterdamping)",
  "def setInitialProfiles(self, n0, T0, rn0=None, rT0=None):\n        \"\"\"\n        Sets the initial density and temperature profiles of the electron\n        population.\n\n        :param rn0: Radial grid on which the density is given.\n        :param n0:  Electron density profile.\n        :param rT0: Radial grid on which the temperature is given.\n        :param T0:  Electron temperature profile.\n        \"\"\"\n        if rn0 is not None:\n            self.rn0 = np.asarray(rn0)\n        else:\n            if not np.isscalar(n0):\n                raise EquationException(\"{}: Non-scalar initial density profile given, but no radial grid specified.\".format(self.name))\n            self.rn0 = np.array([0])\n\n        if rT0 is not None:\n            self.rT0 = np.asarray(rT0)\n        else:\n            if not np.isscalar(T0):\n                raise EquationException(\"{}: Non-scalar initial temperature profile given, but no radial grid specified.\".format(self.name))\n            self.rT0 = np.array([0])\n\n        self.n0  = np.asarray(n0)\n        self.T0  = np.asarray(T0)\n\n        if self.rn0.ndim == 0: self.rn0 = np.asarray([self.rn0])\n        if self.n0.ndim == 0:  self.n0 = np.asarray([self.n0])\n        if self.rT0.ndim == 0: self.rT0 = np.asarray([self.rT0])\n        if self.T0.ndim == 0:  self.T0 = np.asarray([self.T0])\n\n        # Reset numerically provided distribution (if any)\n        self.init = None\n\n        self.verifyInitialProfiles()",
  "def setInitialValue(self, f, r, p=None, xi=None, ppar=None, pperp=None):\n        \"\"\"\n        Set the initial value of this electron distribution function. Only one\n        of the pairs (p, xi) and (ppar, pperp) of momentum grids need to be\n        given.\n\n        :param f:     Array representing the distribution function value on the grid (must have size (nr, nxi, np) or (nr, npperp, nppar))\n        :param r:     Radial grid on which the initial distribution is given.\n        :param p:     Momentum grid.\n        :param xi:    Pitch grid.\n        :param ppar:  Parallel momentum grid.\n        :param pperp: Perpendicular momentum grid.\n        \"\"\"\n        self.init = {}\n\n        def conv(v):\n            if type(v) == list:\n                return np.array(v)\n            elif type(v) == float or type(v) == int:\n                return np.array([float(v)])\n            else:\n                return v\n\n        ff = conv(f)\n        self.init['r'] = conv(r)\n\n        if p is not None and xi is not None:\n            self.init['p'] = conv(p)\n            self.init['xi'] = conv(xi)\n            self.init['ppar'] = np.array([])\n            self.init['pperp'] = np.array([])\n\n            if ff.size == 1:\n                ff = ff * np.ones((self.init['r'].size, self.init['xi'].size, self.init['p'].size))\n        elif ppar is not None and pperp is not None:\n            self.init['ppar'] = conv(ppar)\n            self.init['pperp'] = conv(pperp)\n            self.init['p'] = np.array([])\n            self.init['xi'] = np.array([])\n\n            if ff.size == 1:\n                ff = ff * np.ones((self.init['r'].size, self.init['pperp'].size, self.init['ppar'].size))\n        else:\n            raise EquationException(\"{}: No momentum grid given for initial value.\".format(self.name))\n\n        self.init['x'] = ff\n\n        # Reset initial profiles (if any)\n        self.rn0 = self.rT0 = None\n        self.n0 = self.T0 = None\n\n        self.verifyInitialDistribution()",
  "def enableAnalyticalDistribution(self, mode=True):\n        \"\"\"\n        Enables/disables the use of an analytical distribution\n        function to represent the electron population\n        \"\"\"\n        if mode:\n            self.mode = DISTRIBUTION_MODE_ANALYTICAL\n        else:\n            self.mode = DISTRIBUTION_MODE_NUMERICAL",
  "def setRippleMode(self, mode):\n        \"\"\"\n        Enables/disables inclusion of pitch scattering due to the magnetic ripple.\n\n        :param int mode: Flag indicating whether or not to include magnetic ripple effects.\n        \"\"\"\n        if type(mode) == bool:\n            self.ripplemode = RIPPLE_MODE_BOX if mode else RIPPLE_MODE_NEGLECT\n        else:\n            self.ripplemode = int(mode)",
  "def setTimeVaryingB(self, mode):\n        \"\"\"\n        Enables/disable the time-varying magnetic field strength operator.\n\n        :param int mode: Flag indicating whether or not to include the time-varying magnetic field operator.\n        \"\"\"\n        if type(mode) == bool:\n            self.timevaryingbmode = TIME_VARYING_B_MODE_INCLUDE if mode else TIME_VARYING_B_MODE_NEGLECT\n        else:\n            self.timevaryingbmode = int(mode)",
  "def setSynchrotronMode(self, mode):\n        \"\"\"\n        Sets the type of synchrotron losses to have (either enabled or disabled).\n\n        :param int mode: Flag indicating whether or not to enable synchrotron losses (may be bool).\n        \"\"\"\n        if type(mode) == bool:\n            self.synchrotronmode = SYNCHROTRON_MODE_INCLUDE if mode else SYNCHROTRON_MODE_NEGLECT\n        else:\n            self.synchrotronmode = int(mode)",
  "def enableIonJacobian(self, includeJacobian):\n        \"\"\"\n        Enables/disables the ion jacobian in the kinetic equation.\n\n        :param bool includeJacobian: Flag indicating whether the ion jacobian will be added. True by default, False to disable.\n        \"\"\"\n        self.fullIonJacobian = includeJacobian",
  "def fromdict(self, data):\n        \"\"\"\n        Load data for this object from the given dictionary.\n\n        :param dict data: Dictionary to load distribution function from.\n        \"\"\"\n        def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v\n\n        if 'mode' in data:\n            self.mode = data['mode']\n        if 'boundarycondition' in data:\n            self.boundarycondition = data['boundarycondition']\n\n        if 'adv_interp' in data:\n            self.advectionInterpolation.fromdict(data['adv_interp'])\n\n        if 'init' in data:\n            self.init = data['init']\n        elif ('n0' in data) and ('T0' in data):\n            self.rn0 = data['n0']['r']\n            self.n0  = data['n0']['x']\n            self.rT0 = data['T0']['r']\n            self.T0  = data['T0']['x']\n\n        if 'ripplemode' in data:\n            self.ripplemode = int(scal(data['ripplemode']))\n\n        if 'timevaryingbmode' in data:\n            self.timevaryingbmode = int(scal(data['timevaryingbmode']))\n\n        if 'synchrotronmode' in data:\n            self.synchrotronmode = data['synchrotronmode']\n            if type(self.synchrotronmode) != int:\n                self.synchrotronmode = int(self.synchrotronmode[0])\n\n        if 'transport' in data:\n            self.transport.fromdict(data['transport'])\n\n        if 'fullIonJacobian' in data:\n            self.fullIonJacobian = bool(data['fullIonJacobian'])\n\n        self.verifySettings()",
  "def todict(self):\n        \"\"\"\n        Returns a Python dictionary containing all settings of this\n        DistributionFunction object.\n\n        :return: a dictionary, containing all settings of this object, which can be directly given to DREAM.\n        \"\"\"\n        data = {}\n        data['mode'] = self.mode\n        if self.grid.enabled:\n            data = {'boundarycondition': self.boundarycondition}\n\n            # Advection interpolation\n            data['adv_interp'] = self.advectionInterpolation.todict()\n\n            if self.init:\n                data['init'] = {}\n                data['init']['x'] = self.init['x']\n                data['init']['r'] = self.init['r']\n\n                if self.init['p'].size > 0 and self.init['xi'].size > 0:\n                    data['init']['p'] = self.init['p']\n                    data['init']['xi'] = self.init['xi']\n                elif self.init['ppar'].size > 0 and self.init['pperp'].size > 0:\n                    data['init']['ppar'] = self.init['ppar']\n                    data['init']['pperp'] = self.init['pperp']\n            elif self.n0 is not None:\n                data['n0'] = { 'r': self.rn0, 'x': self.n0 }\n                data['T0'] = { 'r': self.rT0, 'x': self.T0 }\n            \n            data['ripplemode'] = self.ripplemode\n            data['synchrotronmode'] = self.synchrotronmode\n            data['timevaryingbmode'] = self.timevaryingbmode\n            data['transport'] = self.transport.todict()\n            data['fullIonJacobian'] = self.fullIonJacobian\n\n        if self.mode != DISTRIBUTION_MODE_NUMERICAL:\n            data['n0'] = { 'r': self.rn0, 'x': self.n0 }\n            data['T0'] = { 'r': self.rT0, 'x': self.T0 }\n\n\n        return data",
  "def verifySettings(self):\n        \"\"\"\n        Verify that the settings of this unknown are correctly set.\n        \"\"\"\n        if self.grid.enabled:\n            if self.mode != DISTRIBUTION_MODE_NUMERICAL:\n                raise EquationException(\"{}: Invalid mode set. Must be 'NUMERICAL' when the grid is 'enabled'.\".format(self.name))\n            bc = self.boundarycondition\n            if (bc != BC_F_0) and (bc != BC_PHI_CONST) and (bc != BC_DPHI_CONST):\n                raise EquationException(\"{}: Invalid external boundary condition set: {}.\".format(self.name, bc))\n            if self.init is not None:\n                self.verifyInitialDistribution()\n            elif (self.n0 is not None) or (self.T0 is not None):\n                self.verifyInitialProfiles()\n            else:\n                raise EquationException(\"{}: Invalid/no initial condition set for the distribution function.\".format(self.name))\n\n            self.advectionInterpolation.verifySettings()\n\n            if type(self.ripplemode) == bool:\n                self.setRippleMode(self.ripplemode)\n            elif type(self.ripplemode) != int:\n                raise EquationException(\"{}: Invalid type of ripple mode option: {}\".format(self.name, type(self.ripplemode)))\n            else:\n                opt = [RIPPLE_MODE_NEGLECT, RIPPLE_MODE_BOX, RIPPLE_MODE_GAUSSIAN]\n                if self.ripplemode not in opt:\n                    raise EquationException(\"{}: Invalid option for ripple mode: {}.\".format(self.name, self.ripplemode))\n \n            if type(self.synchrotronmode) == bool:\n                self.setSynchrotronMode(self.synchrotronmode)\n            elif type(self.synchrotronmode) != int:\n                raise EquationException(\"{}: Invalid type of synchrotron mode option: {}\".format(self.name, type(self.synchrotronmode)))\n            else:\n                opt = [SYNCHROTRON_MODE_NEGLECT, SYNCHROTRON_MODE_INCLUDE]\n                if self.synchrotronmode not in opt:\n                    raise EquationException(\"{}: Invalid option for synchrotron mode: {}\".format(self.name, self.synchrotronmode))\n\n            if type(self.timevaryingbmode) == bool:\n                self.setTimeVaryingBMode(self.timevaryingbmode)\n            elif type(self.timevaryingbmode) != int:\n                raise EquationException(f\"{self.name}: Invalid type of time-varying B mode option: {self.timevaryingbmode}.\")\n            else:\n                opt = [TIME_VARYING_B_MODE_NEGLECT, TIME_VARYING_B_MODE_INCLUDE]\n                if self.timevaryingbmode not in opt:\n                    raise EquationException(f\"{self.name}: Invalid option for time-varying B mode: {self.timevaryingbmode}.\")\n\n            self.transport.verifySettings()\n        elif self.mode != DISTRIBUTION_MODE_NUMERICAL:\n            # if fluid mode and analytical distribution,\n            # initial profiles must be provided:\n            self.verifyInitialProfiles()",
  "def verifyInitialDistribution(self):\n        \"\"\"\n        Verifies that the initial distribution function has\n        been set correctly and consistently.\n        \"\"\"\n        if self.init is None:\n            raise EquationException(\"{}: No initial distribution function specified.\".format(self.name))\n\n        nr = self.init['r'].size\n        p1, p2 = None, None\n        p1name, p2name = None, None\n        np1, np2 = 0, 0\n\n        if self.init['p'].size > 0 and self.init['xi'].size > 0:\n            p1name = 'p'\n            p2name = 'xi'\n        elif self.init['ppar'].size > 0 and self.init['pperp'].size > 0:\n            p1name = 'ppar'\n            p2name = 'pperp'\n        else:\n            raise EquationException(\"{}: No momentum grid given for initial value.\".format(self.name))\n\n        p1 = self.init[p1name]\n        p2 = self.init[p2name]\n\n        if len(p1.shape) != 1:\n            raise EquationException(\"{}: Invalid dimensions of momentum grid '{}'. Must be 1D array.\".format(self.name, p1name))\n        elif len(p2.shape) != 1:\n            raise EquationException(\"{}: Invalid dimensions of momentum grid '{}'. Must be 1D array.\".format(self.name, p2name))\n\n        np1 = p1.size\n        np2 = p2.size\n\n        if self.init['x'].shape != (nr, np2, np1):\n            raise EquationException(\"{}: Invalid size of initial distribution function: {}. Expected: {}.\".format(self.name, self.init['x'].shape, (nr, np2, np1)))",
  "def verifyInitialProfiles(self):\n        \"\"\"\n        Verifies that the initial density and temperature profiles\n        are set correctly.\n        \"\"\"\n        if (self.n0 is None) or (self.T0 is None):\n            raise EquationException(\"{}: No initial density and/or temperature profiles specified.\".format(self.name))\n        if (self.rn0 is None) or (self.rT0 is None):\n            raise EquationException(\"{}: No radial grids specified for the density and/or temperature profiles.\".format(self.name))\n\n        if (self.n0.ndim != 1) or (self.rn0.ndim != 1) or (self.n0.size != self.rn0.size):\n            raise EquationException(\"{}: Invalid number of elements of density profile: {}. Corresponding radial grid has {} elements.\"\n                .format(self.name, self.n0.size, self.rn0.size))\n        if (self.T0.ndim != 1) or (self.rT0.ndim != 1) or (self.T0.size != self.rT0.size):\n            raise EquationException(\"{}: Invalid number of elements of temperature profile: {}. Corresponding radial grid has {} elements.\"\n                .format(self.name, self.T0.size, self.rT0.size))",
  "def conv(v):\n            if type(v) == list:\n                return np.array(v)\n            elif type(v) == float or type(v) == int:\n                return np.array([float(v)])\n            else:\n                return v",
  "def scal(v):\n            if type(v) == np.ndarray: return v[0]\n            else: return v",
  "class PrescribedScalarParameter:\n    \n\n    def _setScalarData(self, data, times=0):\n        \"\"\"\n        Set prescribed scalar data appropriately.\n        \"\"\"\n        if np.isscalar(times):\n            t = np.asarray([times])\n        else: t = np.asarray(times)\n\n        if np.isscalar(data):\n            d = data*np.ones((t.size, ))\n        else: d = np.asarray(data)\n\n        return d, t\n\n\n    def _verifySettingsPrescribedScalarData(self, name, data, times):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed scalar data. Expected one dimension (times).\".format(name))\n        elif len(times.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed scalar data. Expected one dimension.\".format(name))\n        elif data.shape[0] != times.size:\n            raise EquationException(\"{}: Invalid size of prescribed data: {}. Expected {} elements.\"\n                .format(name, data.shape[0], times.size))",
  "def _setScalarData(self, data, times=0):\n        \"\"\"\n        Set prescribed scalar data appropriately.\n        \"\"\"\n        if np.isscalar(times):\n            t = np.asarray([times])\n        else: t = np.asarray(times)\n\n        if np.isscalar(data):\n            d = data*np.ones((t.size, ))\n        else: d = np.asarray(data)\n\n        return d, t",
  "def _verifySettingsPrescribedScalarData(self, name, data, times):\n        \"\"\"\n        Verify the structure of the prescribed data.\n        \"\"\"\n        if len(data.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in prescribed scalar data. Expected one dimension (times).\".format(name))\n        elif len(times.shape) != 1:\n            raise EquationException(\"{}: Invalid number of dimensions in radial grid of prescribed scalar data. Expected one dimension.\".format(name))\n        elif data.shape[0] != times.size:\n            raise EquationException(\"{}: Invalid size of prescribed data: {}. Expected {} elements.\"\n                .format(name, data.shape[0], times.size))",
  "def create_argparser():\n    parser = argparse.ArgumentParser(description=\"DREAM Output CLI\")\n\n    parser.add_argument('-l', '--lazy', help=\"Load the output lazily and only read data on-demand\", dest=\"lazy\", action=\"store_true\")\n    parser.add_argument('-r', '--read', help=\"Load the output to memory immediately (no lazy read)\", dest=\"lazy\", action=\"store_false\")\n    parser.add_argument('-s', '--no-settings', help=\"Do not load settings from the output file\", dest=\"settings\", action=\"store_false\")\n\n    parser.add_argument('output', help=\"DREAM output file to load\", type=str, nargs='?')\n\n    parser.set_defaults(lazy=True, output='output.h5', settings=True)\n\n    return parser.parse_args()",
  "def main():\n    args = create_argparser()\n\n    do = DREAMOutput(args.output, lazy=args.lazy, loadsettings=args.settings)\n    \"\"\"\n    if len(sys.argv) == 1:\n        do = DREAMOutput('output.h5')\n    elif len(sys.argv) == 2:\n        do = DREAMOutput(sys.argv[1])\n    else:\n        print('ERROR: Invalid command line arguments. Expected at most one argument (name of file).')\n        sys.exit(1)\n    \"\"\"\n\n    setup_interactive(do, glob=globals())",
  "def compile_elements(elements, outputfile=None, inttype='len_t', realtype='real_t'):\n    \"\"\"\n    Generate a C++ file containing the given ADAS data.\n    \"\"\"\n    ds = \"\"\n    ss = \"const {0} adas_rate_n = {1};\\nstruct adas_rate adas_rate_table[{1}] = {{\\n\".format(inttype, len(elements))\n    sd = None\n\n    # Write data\n    for elname, ratedata in elements.items():\n        Z = ratedata['Z']\n        A = ratedata['A']\n\n        if sd is not None: sd += \"},\\n\"\n        else: sd = \"\"\n\n        sd += \"\\t{{\\\"{0}\\\",{0}_Z,{0}_A\".format(elname)\n\n        ds += \"/* {} */\\n\".format(elname)\n        ds += \"const {0} {1}_Z = {2};\\n\".format(inttype, elname, Z)\n        ds += \"const {0} {1}_A = {2};\\n\".format(inttype, elname, A)\n\n        # acd, ccd, scd, plt, prb\n        for dt, data in ratedata.items():\n            if dt in ['A', 'Z']: continue\n\n            nn = len(data['n'])\n            nT = len(data['T'])\n\n            ds += \"const {0} {1}_{2}_nn = {3};\\nconst {0} {1}_{2}_nT = {4};\\n\".format(inttype, elname, dt, nn, nT)\n\n            ds += \"const {0} {1}_{2}_n[{3}] = {{\".format(realtype, elname, dt, nn)\n            ds += ','.join(['{:.5f}'.format(x) for x in data['n']])\n            ds += \"};\\n\"\n\n            ds += \"const {0} {1}_{2}_T[{3}] = {{\".format(realtype, elname, dt, nT)\n            ds += ','.join(['{:.5f}'.format(x) for x in data['T']])\n            ds += \"};\\n\"\n\n            ds += \"const {0} {1}_{2}_coeff[{3}] = {{\".format(realtype, elname, dt, Z*nn*nT)\n            ds += ','.join(['{:.5f}'.format(x) for x in data['data'].flatten()])\n            ds += \"};\\n\\n\"\n\n            sd += \",{0}_{1}_nn,{0}_{1}_nT,{0}_{1}_n,{0}_{1}_T,{0}_{1}_coeff\".format(elname, dt)\n\n    sd += \"}\\n};\\n\"\n\n    filecontents  = \"/* This file was auto-generated by 'get_adas.py' on {} */\\n\\n\".format(datetime.datetime.now().isoformat(sep=' ', timespec='seconds'))\n    filecontents += \"#include \\\"DREAM/adasdata.h\\\"\\n\\n\"\n    filecontents += ds + ss + sd\n\n    if outputfile is not None:\n        # Create directory if it doesn't already exists\n        pathlib.Path(outputfile).parent.mkdir(parents=True, exist_ok=True)\n\n        # Write C++ file\n        with open(outputfile, 'w') as f:\n            f.write(filecontents)\n\n    return filecontents",
  "def main(argv):\n    path = pathlib.Path(__file__).parent.absolute()\n    elementsfile = '{}/elements.json'.format(path)\n    outputfile = os.path.abspath('{}/../src/Atomics/adasdata.cpp'.format(path))\n    cachedir = '{}/cache'.format(path)\n\n    parser = argparse.ArgumentParser(description=\"Download and compile rate coefficients from Open-ADAS.\")\n    parser.add_argument('--cachedir', dest='cachedir', action='store', default=cachedir, type=str, help=\"Path to directory in which to store/load cached data files to/from.\")\n    parser.add_argument('--elements', dest='elementsfile', action='store', default=elementsfile, type=str, help=\"Name of file containing ADAS element specifications.\")\n    parser.add_argument('--hdf5', dest='hdf5', action='store', type=str, help=\"Store data in the named HDF5 file\")\n    parser.add_argument('--no-cache', dest='cache', action='store_false', help=\"Forces data to be downloaded from Open-ADAS and prevents Open-ADAS files from being stored locally.\")\n    parser.add_argument('--no-compile', dest='compile', action='store_false', help=\"Do not generate C++ source files with the rate coefficients.\")\n    parser.add_argument('-o', '--output', dest='output', action='store', default=outputfile, help=\"Name of output C++ source file to generate.\")\n    parser.add_argument('--type-int', dest='inttype', action='store', default='len_t', help=\"C++ type to use for integers.\")\n    parser.add_argument('--type-real', dest='realtype', action='store', default='real_t', help=\"C++ type to use for real numbers.\")\n\n    args = parser.parse_args()\n\n    ADAS_ELEMENT_LIST = ADAS.data.load_element_list(args.elementsfile)\n\n    ELEMENTS = {}\n    for element, year in ADAS_ELEMENT_LIST.items():\n        ELEMENTS[element] = ADAS.data.load_element(element, year, cache=args.cache, cachedir=args.cachedir)\n\n    # Compile \n    if args.compile:\n        compile_elements(ELEMENTS, outputfile=args.output, inttype=args.inttype, realtype=args.realtype)\n\n    # Store in HDF5\n    if args.hdf5:\n        ADAS.io.save_dict(ELEMENTS, outputfile=args.hdf5)",
  "def nearest(arr, val):\n    \"\"\"\n    Locate the element in the given array 'arr' which is\n    closest to the specified value 'val'.\n    \"\"\"\n    return arr[np.abs(arr-val).argmin()]",
  "def fitSpecies(species, method='single', visualize=False):\n    \"\"\"\n    Fits the total electron impact ICS to the ADAS coefficients for the\n    given species.\n\n    :param str species:    Name of atomic species to fit ICS for.\n    :param str method:     Name of method to use for fitting: 'single', 'single_3p', or 'double'.\n    :param bool visualize: If ``True``, plots the fit against ADAS data for each charge state.\n    \"\"\"\n    I_scd, Z, _, T, _ = ADAS.data.getIonizationData(species)\n\n    # Fit charge states Z0 = 0, 1, ..., Z-1\n    fit = []\n    for Z0 in range(Z):\n        if Z0 == 0:\n            print('{}'.format(Z0), end=\"\", flush=True)\n        else:\n            print(', {}'.format(Z0), end=\"\", flush=True)\n\n        if species in PARAMETERS and str(Z0) in PARAMETERS[species]:\n            p = PARAMETERS[species][str(Z0)]\n            Tl, Tu = nearest(T, p['Tlow']), nearest(T, p['Tupp'])\n\n            _, _, output = ADAS.fitKineticIonizationForSpecies(species, Z0, method, T_lower=Tl, T_upper=Tu)\n        else:\n            print(\"WARNING: No temperature limits set for species '{}' in charge state Z0={}. This may lead to poor fitting results.\".format(species, Z0))\n            print(\"(use the script 'ADAS/gui/ManualFit.py' to select appropriate temperature limits and add to 'kineticCrossSectionParams.json')\")\n\n            _, _, output = ADAS.fitKineticIonizationForSpecies(species, Z0, method)\n\n        fit.append(output)\n\n        # Show fit?\n        if visualize:\n            I_fit = ADAS.fit.evaluateAveragedCrossSection(method=method, T=T, **output)\n\n            plt.loglog(T, I_scd[Z0,:,0], 'k', label='ADAS')\n            plt.loglog(T, I_fit, 'r--', label='Fit')\n            plt.loglog(T, I_fit, 'rx')\n            plt.title('{} -- $Z_0 = {}$'.format(species, Z0))\n            plt.legend()\n\n            plt.show()\n\n    print('.')\n\n    return fit, Z",
  "def compile_fits(fits, Z, method, outputfile, inttype='len_t', realtype='real_t'):\n    \"\"\"\n    Compile fitted kinetic ionization cross-sections to C++ files.\n    \"\"\"\n    s  = \"/**\\n\"\n    s += \" * This file was automatically generated by 'tools/fit_kineticionization.py'.\\n\"\n    s += \" */\\n\\n\"\n\n    s += \"/* Number of parameters used in fit */\\n\"\n    if method == 'single':\n        s += \"const len_t nParams = 3;\\n\\n\"\n    elif method == 'single3p':\n        s += \"const len_t nParams = 4;\\n\\n\"\n    elif method == 'double':\n        s += \"const len_t nParams = 6;\\n\\n\"\n    else:\n        raise Exception(\"Unrecognized fitting method: '{}'.\".format(method))\n\n    for e in fits.keys():\n        f = fits[e]\n\n        s += \"/* {} */\\n\".format(e)\n        s += \"const {} {}_Z = {};\\n\".format(inttype, e, Z[e])\n        s += \"const {0} {1}_params[nParams*{1}_Z] = {{\\n\".format(realtype, e)\n\n        if method in ['single', 'single3p']:\n            s += \"/*               C                     I                   betaStar */\\n\"\n        elif method == 'double':\n            s += \"/*               C1                  C2                    I1                     I2                  betaStar           beta2 */\\n\"\n\n        for Z0 in range(len(f)):\n            s += \"/* Z0 = {:2d} */   \".format(Z0)\n\n            if method in ['single', 'single3p']:\n                s += \"{:18.15f}, {:21.15f}, {:17.15f}\".format(f[Z0]['C1'], f[Z0]['DI1'], f[Z0]['betaStar'])\n            elif method == 'double':\n                s += \"{:18.15f}, {:18.15f}, {:21.15f}, {:21.15f}, {:17.15f}, {:17.15f}\".format(f[Z0]['C1'], f[Z0]['C2'], f[Z0]['DI1'], f[Z0]['DI2'], f[Z0]['betaStar'], f[Z0]['beta2'])\n\n            if Z0+1 < Z[e]:\n                s += \",\"\n\n            s += \"\\n\"\n\n        s += \"};\\n\\n\"\n\n    s += \"const {} IonKineticIonizationTerm::nParamsForFit = nParams;\\n\".format(inttype)\n    s += \"const {} IonKineticIonizationTerm::kinetic_rate_n = {};\\n\".format(inttype, len(fits))\n    s += \"struct IonKineticIonizationTerm::kinetic_ionization_rate IonKineticIonizationTerm::kinetic_rate_table[{}] = {{\\n\".format(len(fits))\n\n    els = list(fits.keys())\n    for i in range(len(fits)):\n        s += \"    {{\\\"{0}\\\",{0}_Z,{0}_params}}\".format(els[i])\n\n        if i+1 < len(fits):\n            s += \",\"\n\n        s += \"\\n\"\n\n    s += \"};\\n\\n\"\n\n    if outputfile is not None:\n        # Create directory if it doesn't already exist\n        pathlib.Path(outputfile).parent.mkdir(parents=True, exist_ok=True)\n\n        # Write C++ file\n        with open(outputfile, 'w') as f:\n            f.write(s)\n\n    return s",
  "def load_parameters():\n    \"\"\"\n    Load specific fit parameters from the standard JSON file.\n    \"\"\"\n    paramfile = (pathlib.Path(__file__).parent / 'kineticCrossSectionParams.json').resolve()\n    with open(paramfile, 'r') as f:\n        params = json.load(f)\n\n    return params",
  "def main():\n    \"\"\"\n    Program entry point.\n    \"\"\"\n    path = pathlib.Path(__file__).parent.resolve()\n    elementsfile = str((path / 'elements.json').resolve())\n    outputfile = str((path / '../src/Atomics/kineticionizationdata.cpp').resolve())\n\n    parser = argparse.ArgumentParser(description=\"Fit kinetic ionization cross-section to ADAS ionization coefficients\")\n    parser.add_argument('-e', '--elements', dest='elements', action='extend', nargs='*', help=\"Name of elements to include in fitted kinetic ionization cross-section data.\")\n    parser.add_argument('--elementsfile', dest='elementsfile', action='store', default=elementsfile, type=str, help=\"Name of file containing ADAS element specifications.\")\n    parser.add_argument('--method', dest='method', action='store', type=str, default='single', help=\"Fitting method to use (number of free parameters): 'single', 'single3p' or 'double'.\")\n    parser.add_argument('-o', '--output', dest='output', action='store', default=outputfile, help=\"Name of output C++ source file to generate.\")\n    parser.add_argument('--type-int', dest='inttype', action='store', default='len_t', help=\"C++ type to use for integers.\")\n    parser.add_argument('--type-real', dest='realtype', action='store', default='real_t', help=\"C++ type to use for real numbers.\")\n\n    args = parser.parse_args()\n\n    if args.elements is not None:\n        els = [x.lower().capitalize() for x in args.elements]\n        print('Fitting ',end=\"\")\n        for i in range(len(els)):\n            if i > 0:\n                print(', {}'.format(els[i]), end=\"\")\n            else:\n                print('{}'.format(els[i]), end=\"\")\n\n        print(\"\\n\")\n    else:\n        els = []\n\n        e = list(ADAS.data.ELEMENTS.keys())\n        print('Fitting ',end=\"\")\n        for i in range(len(ADAS.data.ELEMENTS.keys())):\n            if i > 0:\n                print(', {}'.format(e[i]), end=\"\")\n            else:\n                print('{}'.format(e[i]), end=\"\")\n\n        print(\"\\n\")\n\n    # Fit each charge state of each species...\n    fits, Z = {}, {}\n    for e in  ADAS.data.ELEMENTS.keys():\n        # Skip elements not requested by user...\n        # (but only if user requested > 0 elements)\n        if len(els) > 0:\n            if e.lower().capitalize() not in els:\n                continue\n\n        print('{:2s}: '.format(e), end=\"\", flush=True)\n        fits[e], Z[e] = fitSpecies(e, method=args.method)\n\n    compile_fits(fits, Z=Z, method=args.method, outputfile=args.output, inttype=args.inttype, realtype=args.realtype)\n\n    return 0",
  "def download_nist(elements, datatype='binding', cache=False, cachedir=None):\n    \"\"\"\n    Downloads the HTML result of making a request using the ionization energy\n    data form from the NIST ASD.\n\n    elements: List of elements to download data for. This should be the name of\n              the atom to download data for (e.g. H, He, Ne, Ar etc.)\n    datatype: Type of data to download (either 'binding' for total binding\n              energy, or 'ionization' for ionization energy)\n    \"\"\"\n    dt = '0' if datatype == 'ionization' else '1'\n    data = {\n        'encodelist': 'XXT2',           # Hard-coded value\n        'spectra': ','.join(elements),  # List of elements to retrieve\n        'units': '1',                   # Energy units (1 = eV, 0 = cm-1, 2 = Rydberg\n        'format': '1',                  # Output format (0 = HTML, 1 = ASCII)\n        'order': '0',                   # Ordering (0 = by Z, 1 = by sequence)\n        'at_num_out': 'on',             # We want the atomic charge number\n        'ion_charge_out': 'on',         # We also want the ion charge as X data\n        'sp_name_out': 'on',            # Spectrum name\n        'e_out': dt,                    # 0 = ionization energy, 1 = total binding energy\n        'submit': 'Retrieve+Data'       # Name of button\n    }\n\n    fname = 'nist_{}.html'.format(datatype)\n    url   = 'https://physics.nist.gov/cgi-bin/ASD/ie.pl'\n\n    if cachedir is not None:\n        fpath = str(pathlib.PurePath(cachedir, fname))\n    else:\n        fpath = ''\n\n    if cache and os.path.isfile(fpath):\n        with open(fpath, 'r') as f:\n            nistdata = f.read()\n    else:\n        dd  = urllib.parse.urlencode(data).encode()\n        #req = urllib.request.Request(url, data=\n        with urllib.request.urlopen(url, data=dd) as f:\n            if f.status != 200:\n                raise Exception(\"Failed to download '{}' from NIST ADS.\".format(url))\n\n            nistdata = f.read().decode('ascii')\n\n        # Save data to disk?\n        if cache:\n            pathlib.Path(cachedir).mkdir(parents=True, exist_ok=True)\n\n            with open(fpath, 'w') as f:\n                f.write(nistdata)\n\n    return nistdata",
  "def remove_html(s):\n    \"\"\"\n    Removes all HTML tags from a string.\n    \"\"\"\n    tmp = s\n    #while (sub := tmp.find('<')) >= 0:\n    sub = tmp.find('<')\n    while sub >= 0:\n        tmp1 = tmp[:sub]\n        tmp2 = tmp[sub:]\n\n        sub = tmp2.find('>')\n        tmp = tmp1 + tmp2[sub+1:]\n\n        sub = tmp.find('<')\n\n    return tmp",
  "def parse_data(nistdata):\n    \"\"\"\n    Parses data downloaded from the NIST Atomic Spectra Database.\n    The data is expected to be of type 'ASCII' and embedded in an\n    HTML document.\n    \"\"\"\n    # Retrieve '<pre></pre>' section\n    preidx = nistdata.find('<pre>')\n    substr = nistdata[preidx+6:]\n    preidx = substr.find('</pre>')\n    substr = substr[:preidx-1]\n\n    names  = []\n    Z      = []\n    data   = []\n\n    # Number of lines to remove from top of table (table header)\n    N_REMOVE_TOP = 3\n    # Number of lines to remove from bottom of table\n    N_REMOVE_BOTTOM = 1\n\n    lines  = substr.split(\"\\n\")\n    while lines[-N_REMOVE_BOTTOM][:4] != '----':\n        N_REMOVE_BOTTOM += 1\n\n    lines  = lines[N_REMOVE_TOP:-N_REMOVE_BOTTOM]\n    arr    = []\n    for line in lines:\n        # Separate X and Y values\n        s = [x.strip() for x in line.split('|')]\n\n        # Get charge number, state and name\n        _Z    = int(s[0])\n        _Z0   = int(s[2])\n        _name = s[1].split()[0]\n\n        # Filter out HTML (and surrounding ()/[])\n        _v = remove_html(s[3])\n        if _v[0] == '[' or _v[0] == '(':\n            _v = _v[1:-1]\n        _v = float(_v)\n\n        #data.append((name, Z, Z0, v))\n\n        if len(Z) == 0 or Z[-1] != _Z:\n            # Push old data\n            if arr:\n                data.append(arr)\n\n            # Add new elements\n            Z.append(_Z)\n            names.append(_name)\n            arr = []\n\n        arr.append(_v)\n\n    data.append(arr)\n\n    return (names, Z, data)",
  "def load_elements(elements, datatype='binding', cache=False, cachedir=None):\n    \"\"\"\n    Load data for the named elements.\n    \"\"\"\n    data = download_nist(elements=elements, datatype=datatype, cache=cache, cachedir=cachedir)\n\n    names, Z, data = parse_data(data)\n\n    # Check that 'elements' is a subset of 'names'\n    for e in elements:\n        if e not in names:\n            if cache:\n                # Force download of elements\n                return load_elements(elements=elements, datatype=datatype, cache=False)\n            else:\n                raise Exception(\"Unable to load NIST data for element '{}'. Element data unavailable.\".format(e))\n\n    # Check whether to return all data or a subset\n    if len(elements) == len(names):\n        return names, Z, data\n    else:\n        # Select only requested elements\n        nnames, nZ, ndata = [], [], []\n        for n,z,d in zip(names,Z,data):\n            if n in elements:\n                nnames.append(n)\n                nZ.append(z)\n                ndata.append(d)\n\n        return nnames, nZ, ndata",
  "def compile_data(nistdata, outputfile, datatype='binding', inttype='int', realtype='double'):\n    \"\"\"\n    Generate a C++ file containing the given NIST data.\n    \"\"\"\n    names, Z, data = nistdata\n    ds = \"\"\n    ss = \"const {0} nist_{2}_n = {1};\\nstruct nist_data nist_{2}_table[{1}] = {{\\n\".format(inttype, len(data), datatype)\n    sd = None\n\n    # Write data\n    for i in range(len(data)):\n        if sd is not None: sd += \"},\\n\"\n        else: sd = \"\"\n        \n        sd += \"\\t{{\\\"{0}\\\",{0}_{1}_Z\".format(names[i], datatype)\n\n        ds += \"/* {} */\\n\".format(names[i])\n        ds += \"const {0} {1}_{2}_Z = {3};\\n\".format(inttype, names[i], datatype, Z[i])\n\n        ds += \"const {0} {1}_{2}_data[{3}] = {{\".format(realtype, names[i], datatype, len(data[i]))\n        ds += ','.join(['{:.10f}'.format(x) for x in data[i]])\n        ds += \"};\\n\"\n\n        sd += \",{0}_{1}_data\".format(names[i], datatype)\n\n    sd += \"}}\\n}};\\n\".format(names[i], datatype)\n\n    filecontents  = \"/* This file was auto-generated by 'get_nist.py' on {} */\\n\\n\".format(datetime.datetime.now().isoformat(sep=' ', timespec='seconds'))\n    filecontents += \"#include \\\"DREAM/nistdata.h\\\"\\n\\n\"\n    filecontents += ds + ss + sd\n\n    if outputfile is not None:\n        # Create directory if it doesn't already exists\n        pathlib.Path(outputfile).parent.mkdir(parents=True, exist_ok=True)\n\n        # Write C++ file\n        with open(outputfile, 'w') as f:\n            f.write(filecontents)\n\n    return filecontents",
  "def main():\n    \"\"\"\n    Program entry point.\n    \"\"\"\n    path       = pathlib.Path(__file__).parent.absolute()\n    cachedir   = '{}/cache'.format(path)\n    #elements   = ['H', 'He', 'Be', 'Ne', 'Ar']\n\n    with open('{}/elements.json'.format(path), 'r') as f:\n        elements = list(json.load(f).keys())\n\n    if 'D' in elements: elements.remove('D')\n    if 'T' in elements: elements.remove('T')\n\n    parser = argparse.ArgumentParser(description=\"Download and compile ionization energies from NIST ADS\")\n    parser.add_argument('--cachedir', dest='cachedir', action='store', default=cachedir, type=str, help=\"Path to directory in which to store/load cached data files to/from.\")\n    parser.add_argument('--hdf5', dest='hdf5', action='store', type=str, help=\"Store data in the named HDF5 file\")\n    parser.add_argument('--ionization', dest='bindingenergy', action='store_false', help=\"Downloads ionization energy data instead of binding energy data\")\n    parser.add_argument('--no-cache', dest='cache', action='store_false', help=\"Forces data to be downloaded from the NIST ADS and prevents files from being stored locally.\")\n    parser.add_argument('--no-compile', dest='compile', action='store_false', help=\"Do not generate C++ source files with the ionization data.\")\n    parser.add_argument('-o', '--output', dest='output', action='store', default='', help=\"Name of output C++ source file to generate.\")\n    parser.add_argument('--type-int', dest='inttype', action='store', default='len_t', help=\"C++ type to use for integers.\")\n    parser.add_argument('--type-real', dest='realtype', action='store', default='real_t', help=\"C++ type to use for real numbers.\")\n\n    args = parser.parse_args()\n\n    datatype = 'binding' if args.bindingenergy else 'ionization'\n\n    data = load_elements(elements, datatype=datatype, cache=args.cache, cachedir=args.cachedir)\n\n    if args.compile:\n        if args.output == '':\n            args.output = os.path.abspath('{}/../src/Atomics/nistdata_{}.cpp'.format(path, datatype))\n\n        # Compile data to C++\n        compile_data(data, outputfile=args.output, datatype=datatype, inttype=args.inttype, realtype=args.realtype)\n\n    # Store in HDF5\n    if args.hdf5:\n        d= {}\n        for i in range(len(data[0])):\n            ion = data[0][i]\n            d[ion] = {\n                'Z': data[1][i],\n                'data': data[2][i]\n            }\n        ADAS.io.save_dict(d, outputfile=args.hdf5)\n\n    return 0",
  "class MainWindow(QtWidgets.QMainWindow):\n    \n\n    def __init__(self, argv):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        QtWidgets.QMainWindow.__init__(self)\n\n        self.ui = MainWindow_design.Ui_EqGet()\n        self.ui.setupUi(self)\n\n        self.equil = None\n\n        # Set up flux surface figure\n        self.canvas = FigureCanvas(Figure())\n        self.fluxSurfaceLayout = QtWidgets.QVBoxLayout(self.ui.frameFluxSurfaces)\n        self.fluxSurfaceLayout.addWidget(self.canvas)\n        self.setupPlot()\n\n        # List of open windows\n        self.windows = {}\n\n        if AUG.isAvailable():\n            self.ui.cbTokamak.addItem('ASDEX Upgrade', AUG)\n\n        self.ui.cbTokamak.addItem('File', EqFile)\n        self.tokamakChanged()\n\n        self.toggleEnabled(False)\n        self.bindEvents()\n\n        if len(argv) == 1:\n            self.parsearg(argv[0])\n\n\n    def bindEvents(self):\n        \"\"\"\n        Bind control events to methods.\n        \"\"\"\n        self.ui.actionExit.triggered.connect(self.exit)\n        self.ui.btnLoad.clicked.connect(self.load)\n\n        self.ui.btnPlotPsi.clicked.connect(self.plotPsi)\n        self.ui.btnPlotB.clicked.connect(self.plotB)\n        self.ui.btnPlotBpol.clicked.connect(self.plotBpol)\n        self.ui.btnPlotBr.clicked.connect(self.plotBr)\n        self.ui.btnPlotBz.clicked.connect(self.plotBz)\n        self.ui.btnPlotBphi.clicked.connect(self.plotBphi)\n\n        self.ui.btnShaping.clicked.connect(self.calculateShaping)\n        self.ui.btnSave.clicked.connect(self.save)\n\n        self.ui.cbTokamak.currentTextChanged.connect(self.tokamakChanged)\n\n\n    def closeEvent(self, event):\n        self.exit()\n\n\n    def exit(self):\n        \"\"\"\n        Close any child windows before exiting.\n        \"\"\"\n        for _, w in self.windows.items():\n            w.close()\n\n        self.close()\n\n\n    def toggleEnabled(self, enabled=True):\n        \"\"\"\n        Toggle the enabled state of controls which require data to be\n        available.\n        \"\"\"\n        self.ui.btnPlotPsi.setEnabled(enabled)\n        self.ui.btnPlotB.setEnabled(enabled)\n        self.ui.btnPlotBpol.setEnabled(enabled)\n        self.ui.btnPlotBr.setEnabled(enabled)\n        self.ui.btnPlotBz.setEnabled(enabled)\n        self.ui.btnPlotBphi.setEnabled(enabled)\n        self.ui.btnShaping.setEnabled(enabled)\n        self.ui.btnSave.setEnabled(enabled)\n\n\n    def tokamakChanged(self, e=None):\n        \"\"\"\n        Event fired when the selected tokamak handler changes.\n        \"\"\"\n        if self.ui.cbTokamak.currentText() == \"File\":\n            self.ui.lblDischarge.setText(\"Equilibrium file\")\n            self.ui.btnLoad.setText(\"Open...\")\n            enbl = False\n        else:\n            self.ui.lblDischarge.setText(\"Discharge\")\n            self.ui.btnLoad.setText(\"Load\")\n            enbl = True\n\n        self.ui.lblTime.setEnabled(enbl)\n        self.ui.tbTime.setEnabled(enbl)\n\n\n    def getShot(self):\n        shot = self.ui.tbShot.text()\n\n        # Try to convert to integer. If that fails, the user may\n        # have provided a file name instead...\n        try: shot = int(shot)\n        except: pass\n\n        return shot\n\n    \n    def load(self):\n        \"\"\"\n        Load data using the selected module.\n        \"\"\"\n        shot = self.getShot()\n\n        if self.ui.cbTokamak.currentText() == \"File\" and not shot:\n            shot, _ = QFileDialog.getOpenFileName(self, caption=\"Open equilibrium file\", filter=\"All supported equilibria (*.geqdsk *.h5 *.mat);;LUKE equilibrium (*.h5 *.mat);;GEQDSK file (*.geqdsk);;All files (*.*)\")\n            if not shot:\n                return\n\n            self.ui.tbShot.setText(shot)\n\n        self._load_internal(shot)\n\n\n    def _load_internal(self, data):\n        try:\n            mod = self.ui.cbTokamak.currentData()\n            self.equil = mod.getLUKE(data)\n            print(\"Loaded '{}'...\".format(data))\n\n            self.plotFluxSurfaces()\n            self.toggleEnabled(True)\n        except Exception as ex:\n            QMessageBox.critical(self, 'Error loading data', f\"The specified data file could not be loaded:\\n\\n{ex}\")\n\n\n    def calculateShaping(self):\n        \"\"\"\n        Calculate shaping parameters for the loaded magnetic equilibrium.\n        \"\"\"\n        pass\n        try:\n            mod = self.ui.cbTokamak.currentData()\n            if not hasattr(mod, 'getShaping'):\n                raise Exception(\"The selected equilibrium handler does not support calculating shaping parameters.\")\n\n            params = mod.getShaping(self.getShot(), equil=self.equil)\n            self.plotShaping(params)\n        except Exception as ex:\n            QMessageBox.critical(self, 'Error loading shot', f\"The specified shot file could not be loaded:\\n\\n{ex}\\n\\n{traceback.format_exc()}\")\n\n\n    def parsearg(self, arg):\n        \"\"\"\n        Parse an input argument.\n        \"\"\"\n        if Path(arg).is_file():\n            self.ui.cbTokamak.setCurrentText('File')\n            self._load_internal(arg)\n\n\n    def plotFluxSurfaces(self):\n        \"\"\"\n        Plot flux surfaces from loaded equilibrium data.\n        \"\"\"\n        ax = self.fluxSurfaceAx\n        ptx = self.equil['ptx']\n        pty = self.equil['pty']\n        Rp  = self.equil['Rp']\n        Zp  = self.equil['Zp']\n\n        ax.plot(ptx[:,:-1]+Rp, pty[:,:-1]+Zp, linewidth=0.7, color=(0.5, 0.5, 0.5))\n        ax.plot(ptx[:,-1]+Rp, pty[:,-1]+Zp, linewidth=2, color='r')\n        ax.plot(Rp, Zp, 's', color='r')\n        ax.axis('equal')\n\n        self.canvas.draw()\n\n\n    def plotPsi(self):\n        \"\"\"\n        Plot poloidal flux as function of minor radius.\n        \"\"\"\n        if 'psi' in self.windows:\n            self.windows['psi'].close()\n\n        w = PlotWindow(600, 400)\n\n        r        = self.equil['ptx'][0,:]\n        psi_apRp = self.equil['psi_apRp']\n        Rp       = self.equil['Rp']\n        ap       = r[-1]\n\n        psi = psi_apRp * (Rp/ap)\n\n        w.ax.plot(r, psi)\n        w.ax.set_xlim([0, ap])\n        w.ax.set_xlabel(r'$r$ (m)')\n        w.ax.set_ylabel(r'Poloidal flux $\\Psi$ (Wb)')\n\n        w.show()\n\n        self.windows['psi'] = w\n\n\n    def plot2D(self, name, data):\n        \"\"\"\n        Plot the given magnetic field.\n        \"\"\"\n        if name in self.windows:\n            self.windows[name].close()\n\n        w = PlotWindow()\n\n        Rp = self.equil['Rp']\n        Zp = self.equil['Zp']\n        R  = self.equil['ptx'] + Rp\n        Z  = self.equil['pty'] + Zp\n\n        cnt = w.ax.contourf(R, Z, data, cmap='GeriMap', levels=40)\n        cbar = w.figure.colorbar(cnt)\n        w.ax.set_xlabel('$R$ (m)')\n        w.ax.set_ylabel('$Z$ (m)')\n        w.ax.axis('equal')\n\n        cbar.set_label('{} (T)'.format(name))\n\n        w.show()\n\n        self.windows[name] = w\n\n\n    def plotB(self):\n        \"\"\"\n        Plot the magnetic field strength in (R, Z).\n        \"\"\"\n        Br = self.equil['ptBx']\n        Bz = self.equil['ptBy']\n        Bp = self.equil['ptBPHI']\n\n        self.plot2D('$|B|$', np.sqrt(Br**2 + Bz**2 + Bp**2))\n\n\n    def plotBpol(self):\n        \"\"\"\n        Plot the poloidal magnetic field.\n        \"\"\"\n        Br = self.equil['ptBx']\n        Bz = self.equil['ptBy']\n\n        self.plot2D(r'$B_{\\rm pol}$', np.sqrt(Br**2 + Bz**2))\n\n\n    def plotBr(self):\n        \"\"\"\n        Plot the radial magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_r$', self.equil['ptBx'])\n\n\n    def plotBz(self):\n        \"\"\"\n        Plot the radial magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_z$', self.equil['ptBy'])\n\n\n    def plotBphi(self):\n        \"\"\"\n        Plot the toroidal magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_\\varphi$', self.equil['ptBPHI'])\n\n\n    def plotShaping(self, params):\n        \"\"\"\n        Plot the DREAM shaping parameters.\n        \"\"\"\n        if 'shaping' in self.windows:\n            self.windows['shaping'].close()\n\n        w = PlotShapingWindow(params)\n        w.show()\n        self.windows['shaping'] = w\n\n\n    def save(self):\n        \"\"\"\n        Save the loaded equilibrium to file.\n        \"\"\"\n        filename, _ = QFileDialog.getSaveFileName(self, caption=\"Save LUKE equilibrium file\", filter='HDF5 file (*.h5)')\n\n        if filename:\n            DREAMIO.SaveDictAsHDF5(filename, {'equil': self.equil})\n            QMessageBox.information(self, \"Equilibrium file saved\", \"The magnetic equilibrium data was saved to the file '{}'.\".format(filename))\n\n\n    def setupPlot(self):\n        self.fluxSurfaceAx = self.canvas.figure.subplots()\n        self.fluxSurfaceAx.set_xlabel(r'$R$ (m)')\n        self.fluxSurfaceAx.set_ylabel(r'$Z$ (m)')\n        self.fluxSurfaceAx.figure.tight_layout()",
  "def __init__(self, argv):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        QtWidgets.QMainWindow.__init__(self)\n\n        self.ui = MainWindow_design.Ui_EqGet()\n        self.ui.setupUi(self)\n\n        self.equil = None\n\n        # Set up flux surface figure\n        self.canvas = FigureCanvas(Figure())\n        self.fluxSurfaceLayout = QtWidgets.QVBoxLayout(self.ui.frameFluxSurfaces)\n        self.fluxSurfaceLayout.addWidget(self.canvas)\n        self.setupPlot()\n\n        # List of open windows\n        self.windows = {}\n\n        if AUG.isAvailable():\n            self.ui.cbTokamak.addItem('ASDEX Upgrade', AUG)\n\n        self.ui.cbTokamak.addItem('File', EqFile)\n        self.tokamakChanged()\n\n        self.toggleEnabled(False)\n        self.bindEvents()\n\n        if len(argv) == 1:\n            self.parsearg(argv[0])",
  "def bindEvents(self):\n        \"\"\"\n        Bind control events to methods.\n        \"\"\"\n        self.ui.actionExit.triggered.connect(self.exit)\n        self.ui.btnLoad.clicked.connect(self.load)\n\n        self.ui.btnPlotPsi.clicked.connect(self.plotPsi)\n        self.ui.btnPlotB.clicked.connect(self.plotB)\n        self.ui.btnPlotBpol.clicked.connect(self.plotBpol)\n        self.ui.btnPlotBr.clicked.connect(self.plotBr)\n        self.ui.btnPlotBz.clicked.connect(self.plotBz)\n        self.ui.btnPlotBphi.clicked.connect(self.plotBphi)\n\n        self.ui.btnShaping.clicked.connect(self.calculateShaping)\n        self.ui.btnSave.clicked.connect(self.save)\n\n        self.ui.cbTokamak.currentTextChanged.connect(self.tokamakChanged)",
  "def closeEvent(self, event):\n        self.exit()",
  "def exit(self):\n        \"\"\"\n        Close any child windows before exiting.\n        \"\"\"\n        for _, w in self.windows.items():\n            w.close()\n\n        self.close()",
  "def toggleEnabled(self, enabled=True):\n        \"\"\"\n        Toggle the enabled state of controls which require data to be\n        available.\n        \"\"\"\n        self.ui.btnPlotPsi.setEnabled(enabled)\n        self.ui.btnPlotB.setEnabled(enabled)\n        self.ui.btnPlotBpol.setEnabled(enabled)\n        self.ui.btnPlotBr.setEnabled(enabled)\n        self.ui.btnPlotBz.setEnabled(enabled)\n        self.ui.btnPlotBphi.setEnabled(enabled)\n        self.ui.btnShaping.setEnabled(enabled)\n        self.ui.btnSave.setEnabled(enabled)",
  "def tokamakChanged(self, e=None):\n        \"\"\"\n        Event fired when the selected tokamak handler changes.\n        \"\"\"\n        if self.ui.cbTokamak.currentText() == \"File\":\n            self.ui.lblDischarge.setText(\"Equilibrium file\")\n            self.ui.btnLoad.setText(\"Open...\")\n            enbl = False\n        else:\n            self.ui.lblDischarge.setText(\"Discharge\")\n            self.ui.btnLoad.setText(\"Load\")\n            enbl = True\n\n        self.ui.lblTime.setEnabled(enbl)\n        self.ui.tbTime.setEnabled(enbl)",
  "def getShot(self):\n        shot = self.ui.tbShot.text()\n\n        # Try to convert to integer. If that fails, the user may\n        # have provided a file name instead...\n        try: shot = int(shot)\n        except: pass\n\n        return shot",
  "def load(self):\n        \"\"\"\n        Load data using the selected module.\n        \"\"\"\n        shot = self.getShot()\n\n        if self.ui.cbTokamak.currentText() == \"File\" and not shot:\n            shot, _ = QFileDialog.getOpenFileName(self, caption=\"Open equilibrium file\", filter=\"All supported equilibria (*.geqdsk *.h5 *.mat);;LUKE equilibrium (*.h5 *.mat);;GEQDSK file (*.geqdsk);;All files (*.*)\")\n            if not shot:\n                return\n\n            self.ui.tbShot.setText(shot)\n\n        self._load_internal(shot)",
  "def _load_internal(self, data):\n        try:\n            mod = self.ui.cbTokamak.currentData()\n            self.equil = mod.getLUKE(data)\n            print(\"Loaded '{}'...\".format(data))\n\n            self.plotFluxSurfaces()\n            self.toggleEnabled(True)\n        except Exception as ex:\n            QMessageBox.critical(self, 'Error loading data', f\"The specified data file could not be loaded:\\n\\n{ex}\")",
  "def calculateShaping(self):\n        \"\"\"\n        Calculate shaping parameters for the loaded magnetic equilibrium.\n        \"\"\"\n        pass\n        try:\n            mod = self.ui.cbTokamak.currentData()\n            if not hasattr(mod, 'getShaping'):\n                raise Exception(\"The selected equilibrium handler does not support calculating shaping parameters.\")\n\n            params = mod.getShaping(self.getShot(), equil=self.equil)\n            self.plotShaping(params)\n        except Exception as ex:\n            QMessageBox.critical(self, 'Error loading shot', f\"The specified shot file could not be loaded:\\n\\n{ex}\\n\\n{traceback.format_exc()}\")",
  "def parsearg(self, arg):\n        \"\"\"\n        Parse an input argument.\n        \"\"\"\n        if Path(arg).is_file():\n            self.ui.cbTokamak.setCurrentText('File')\n            self._load_internal(arg)",
  "def plotFluxSurfaces(self):\n        \"\"\"\n        Plot flux surfaces from loaded equilibrium data.\n        \"\"\"\n        ax = self.fluxSurfaceAx\n        ptx = self.equil['ptx']\n        pty = self.equil['pty']\n        Rp  = self.equil['Rp']\n        Zp  = self.equil['Zp']\n\n        ax.plot(ptx[:,:-1]+Rp, pty[:,:-1]+Zp, linewidth=0.7, color=(0.5, 0.5, 0.5))\n        ax.plot(ptx[:,-1]+Rp, pty[:,-1]+Zp, linewidth=2, color='r')\n        ax.plot(Rp, Zp, 's', color='r')\n        ax.axis('equal')\n\n        self.canvas.draw()",
  "def plotPsi(self):\n        \"\"\"\n        Plot poloidal flux as function of minor radius.\n        \"\"\"\n        if 'psi' in self.windows:\n            self.windows['psi'].close()\n\n        w = PlotWindow(600, 400)\n\n        r        = self.equil['ptx'][0,:]\n        psi_apRp = self.equil['psi_apRp']\n        Rp       = self.equil['Rp']\n        ap       = r[-1]\n\n        psi = psi_apRp * (Rp/ap)\n\n        w.ax.plot(r, psi)\n        w.ax.set_xlim([0, ap])\n        w.ax.set_xlabel(r'$r$ (m)')\n        w.ax.set_ylabel(r'Poloidal flux $\\Psi$ (Wb)')\n\n        w.show()\n\n        self.windows['psi'] = w",
  "def plot2D(self, name, data):\n        \"\"\"\n        Plot the given magnetic field.\n        \"\"\"\n        if name in self.windows:\n            self.windows[name].close()\n\n        w = PlotWindow()\n\n        Rp = self.equil['Rp']\n        Zp = self.equil['Zp']\n        R  = self.equil['ptx'] + Rp\n        Z  = self.equil['pty'] + Zp\n\n        cnt = w.ax.contourf(R, Z, data, cmap='GeriMap', levels=40)\n        cbar = w.figure.colorbar(cnt)\n        w.ax.set_xlabel('$R$ (m)')\n        w.ax.set_ylabel('$Z$ (m)')\n        w.ax.axis('equal')\n\n        cbar.set_label('{} (T)'.format(name))\n\n        w.show()\n\n        self.windows[name] = w",
  "def plotB(self):\n        \"\"\"\n        Plot the magnetic field strength in (R, Z).\n        \"\"\"\n        Br = self.equil['ptBx']\n        Bz = self.equil['ptBy']\n        Bp = self.equil['ptBPHI']\n\n        self.plot2D('$|B|$', np.sqrt(Br**2 + Bz**2 + Bp**2))",
  "def plotBpol(self):\n        \"\"\"\n        Plot the poloidal magnetic field.\n        \"\"\"\n        Br = self.equil['ptBx']\n        Bz = self.equil['ptBy']\n\n        self.plot2D(r'$B_{\\rm pol}$', np.sqrt(Br**2 + Bz**2))",
  "def plotBr(self):\n        \"\"\"\n        Plot the radial magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_r$', self.equil['ptBx'])",
  "def plotBz(self):\n        \"\"\"\n        Plot the radial magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_z$', self.equil['ptBy'])",
  "def plotBphi(self):\n        \"\"\"\n        Plot the toroidal magnetic field component.\n        \"\"\"\n        self.plot2D(r'$B_\\varphi$', self.equil['ptBPHI'])",
  "def plotShaping(self, params):\n        \"\"\"\n        Plot the DREAM shaping parameters.\n        \"\"\"\n        if 'shaping' in self.windows:\n            self.windows['shaping'].close()\n\n        w = PlotShapingWindow(params)\n        w.show()\n        self.windows['shaping'] = w",
  "def save(self):\n        \"\"\"\n        Save the loaded equilibrium to file.\n        \"\"\"\n        filename, _ = QFileDialog.getSaveFileName(self, caption=\"Save LUKE equilibrium file\", filter='HDF5 file (*.h5)')\n\n        if filename:\n            DREAMIO.SaveDictAsHDF5(filename, {'equil': self.equil})\n            QMessageBox.information(self, \"Equilibrium file saved\", \"The magnetic equilibrium data was saved to the file '{}'.\".format(filename))",
  "def setupPlot(self):\n        self.fluxSurfaceAx = self.canvas.figure.subplots()\n        self.fluxSurfaceAx.set_xlabel(r'$R$ (m)')\n        self.fluxSurfaceAx.set_ylabel(r'$Z$ (m)')\n        self.fluxSurfaceAx.figure.tight_layout()",
  "def parametrize_equilibrium(psi_apRp, ptBPHI, ptx, pty, Rp, Zp, *args, **kwargs):\n    \"\"\"\n    Parametrizes the given numeric equilibrium using the\n    DREAM shaping parameters:\n\n      kappa   -- Elongation\n      delta   -- Triangularity\n      Delta   -- Shafranov shift\n      GOverR0 -- Toroidal magnetic field function\n      psi     -- Poloidal flux\n    \"\"\"\n    n = psi_apRp.size\n\n    kappa, delta, Delta, GOverR0 = [], [], [], []\n    for i in range(n):\n        a = ptx[0,i]\n\n        Zind = np.argmax(pty[:,i])\n        R_upper = ptx[Zind,i]+Rp\n\n        k = (np.amax(pty[:,i])-np.amin(pty[:,i])) / (2*a)\n        #d = (ptx[0,i]+Rp-R_upper) / a\n        D = (np.amax(ptx[:,i])+np.amin(ptx[:,i]))/2\n        d = (Rp+D-R_upper) / a\n        G = (ptx[0,i]+Rp)*ptBPHI[0,i] / Rp\n\n        if np.isinf(k):\n            k = 0\n\n        kappa.append(k)\n        delta.append(d)\n        Delta.append(D)\n        GOverR0.append(G)\n\n    return {\n        'R0': Rp,\n        'r': np.array(ptx[0,:]),\n        'kappa': np.array(kappa),\n        'delta': np.array(delta),\n        'Delta': np.array(Delta),\n        'GOverR0': np.array(GOverR0),\n        'psi': psi_apRp * ptx[0,-1]\n    }",
  "class PlotShapingWindow(QtWidgets.QFrame):\n    def __init__(self, params, width=900, height=500, parent=None):\n        super(PlotShapingWindow, self).__init__(parent)\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.ax = self.figure.subplots(2,3)\n        self.setWindowTitle('Shaping parameters')\n\n        self.btnSave = QtWidgets.QPushButton(self)\n        self.btnSave.setObjectName(\"btnSave\")\n        self.btnSave.setText(\"Save parameters\")\n        self.btnSave.clicked.connect(self.saveParameters)\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n        layout.addWidget(self.btnSave)\n        self.setLayout(layout)\n        self.resize(width,height)\n\n        self.parameters = params\n\n        self.plotShaping(params)\n\n\n    def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()\n\n    \n    def plotShaping(self, params):\n        self.plotParameter(self.ax[0,0], params['r'], params['psi'], r'$\\psi$', 'Poloidal flux')\n        self.plotParameter(self.ax[0,1], params['r'], params['kappa'], r'$\\kappa$', 'Elongation')\n        self.plotParameter(self.ax[0,2], params['r'], params['delta'], r'$\\delta$', 'Triangularity')\n        self.plotParameter(self.ax[1,0], params['r'], params['Delta'], r'$\\Delta$', 'Shafranov shift')\n        self.plotParameter(self.ax[1,1], params['r'], params['GOverR0'], r'$G/R_0$', 'Toroidal magnetic field function')\n        self.figure.delaxes(self.ax[1,2])\n\n        self.figure.tight_layout()\n\n\n    def plotParameter(self, ax, r, p, name, title):\n        \"\"\"\n        Plot a single shaping parameter on the specified axes.\n        \"\"\"\n        ax.plot(r, p, 'r')\n        ax.set_xlim([0, np.amax(r)])\n\n        if np.amin(p) >= 0:\n            ax.set_ylim([0, 1.1*np.amax(p)])\n\n        ax.set_xlabel(r'$r$')\n        ax.set_ylabel(name)\n        ax.set_title(title)\n\n\n    def saveParameters(self):\n        filename, _ = QFileDialog.getSaveFileName(self, caption=\"Save shaping parameters to HDF5\", filter=\"HDF5 file (*.h5)\")\n\n        if filename:\n            DREAMIO.SaveDictAsHDF5(filename, self.parameters)\n            QMessageBox.information(self, \"Parameters successfully saved\", f\"The equilibrium shaping parameters were successfully saved to '{filename}'.\")",
  "def __init__(self, params, width=900, height=500, parent=None):\n        super(PlotShapingWindow, self).__init__(parent)\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.ax = self.figure.subplots(2,3)\n        self.setWindowTitle('Shaping parameters')\n\n        self.btnSave = QtWidgets.QPushButton(self)\n        self.btnSave.setObjectName(\"btnSave\")\n        self.btnSave.setText(\"Save parameters\")\n        self.btnSave.clicked.connect(self.saveParameters)\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n        layout.addWidget(self.btnSave)\n        self.setLayout(layout)\n        self.resize(width,height)\n\n        self.parameters = params\n\n        self.plotShaping(params)",
  "def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()",
  "def plotShaping(self, params):\n        self.plotParameter(self.ax[0,0], params['r'], params['psi'], r'$\\psi$', 'Poloidal flux')\n        self.plotParameter(self.ax[0,1], params['r'], params['kappa'], r'$\\kappa$', 'Elongation')\n        self.plotParameter(self.ax[0,2], params['r'], params['delta'], r'$\\delta$', 'Triangularity')\n        self.plotParameter(self.ax[1,0], params['r'], params['Delta'], r'$\\Delta$', 'Shafranov shift')\n        self.plotParameter(self.ax[1,1], params['r'], params['GOverR0'], r'$G/R_0$', 'Toroidal magnetic field function')\n        self.figure.delaxes(self.ax[1,2])\n\n        self.figure.tight_layout()",
  "def plotParameter(self, ax, r, p, name, title):\n        \"\"\"\n        Plot a single shaping parameter on the specified axes.\n        \"\"\"\n        ax.plot(r, p, 'r')\n        ax.set_xlim([0, np.amax(r)])\n\n        if np.amin(p) >= 0:\n            ax.set_ylim([0, 1.1*np.amax(p)])\n\n        ax.set_xlabel(r'$r$')\n        ax.set_ylabel(name)\n        ax.set_title(title)",
  "def saveParameters(self):\n        filename, _ = QFileDialog.getSaveFileName(self, caption=\"Save shaping parameters to HDF5\", filter=\"HDF5 file (*.h5)\")\n\n        if filename:\n            DREAMIO.SaveDictAsHDF5(filename, self.parameters)\n            QMessageBox.information(self, \"Parameters successfully saved\", f\"The equilibrium shaping parameters were successfully saved to '{filename}'.\")",
  "def isAvailable():\n    \"\"\"\n    Returns ``True`` if this module can be used to fetch equilibrium data\n    on this system.\n    \"\"\"\n    global AVAILABLE\n    return AVAILABLE",
  "def getLUKE(shot, time, npsi=80, ntheta=80, filename=None):\n    \"\"\"\n    Returns magnetic equilibrium data for the given time of the specified \n    AUG shot. If ``filename`` is provided, the data is also saved to the\n    named LUKE equilibrium data file.\n\n    The shape of the returned 2D arrays are (ntheta, npsi).\n\n    :param shot: ASDEX Upgrade shot to fetch equilibrium data for.\n    :param time: Time to fetch equilibrium data for.\n    :param filename: Name of file to store data in.\n    \"\"\"\n    equ = EQU(shot)\n\n    # Radial grid (in normalized poloidal flux)\n    rhop = np.linspace(0, 1, npsi+1)[1:]\n    # Poloidal angle\n    theta = np.linspace(0, 2*np.pi, ntheta)\n\n    # Flux surface (R, Z) coordinates\n    R, Z = meq.rhoTheta2rz(equ, rhop, theta, t_in=time, coord_in='rho_pol')\n    R = R[0,:]\n    Z = Z[0,:]\n\n    # Poloidal flux psi\n    psi = meq.rho2rho(equ, rhop, t_in=time, coord_in='rho_pol', coord_out='Psi')[0,:]\n\n    # Calculate aspect ratio and normalize poloidal flux\n    tidx = meq.get_nearest_index(equ.time, [time])[0][0]\n    Rp   = equ.Rmag[tidx]\n    Zp   = equ.Zmag[tidx]\n    a    = R[0,-1]-Rp\n    ieps = Rp / a\n\n    psi_apRp = psi / ieps\n\n    # Magnetic field components\n    Br, Bz, Bphi = meq.rz2brzt(equ, r_in=R.flatten(), z_in=Z.flatten(), t_in=time)\n    Br = Br[0,:].reshape(R.shape)\n    Bz = Bz[0,:].reshape(R.shape)\n    Bphi = Bphi[0,:].reshape(R.shape)\n\n    equil = {\n        'id': 'ASDEX Upgrade #{} t={:.4f}s'.format(shot, time),\n        'Rp': np.array([Rp]), 'Zp': np.array([Zp]),\n        'psi_apRp': psi_apRp,\n        'theta': theta,\n        'ptx': R-Rp, 'pty': Z-Zp,\n        'ptBx': Br, 'ptBy': Bz, 'ptBPHI': Bphi\n    }\n\n    if filename:\n        with h5py.File(filename, 'w') as f:\n            f.create_group('equil')\n            \n            for key in equil.keys():\n                f['equil/{}'.format(key)] = equil[key]\n\n    return equil",
  "def getShaping(shot, time, npsi=80, ntheta=80, filename=None, equil=None):\n    if equil is None:\n        equil = getLUKE(shot=shot, time=time, npsi=npsi, ntheta=ntheta)\n\n    return eqhelpers.parametrize_equilibrium(**equil)",
  "def getVolume(shot, time, filename=None):\n    \"\"\"\n    Returns the plasma volume enclosed by a given flux surface.\n    \"\"\"\n    tidx = meq.get_nearest_index(equ.time, [time])[0][0]\n\n    data = {'psiN': equ.psiN[tidx,:], 'vol': equ.vol[tidx,:]}\n\n    if filename:\n        np.savez(filename, **data)\n\n    return data",
  "class PlotWindow(QtWidgets.QFrame):\n    def __init__(self, width=600, height=800, parent=None):\n        super(PlotWindow, self).__init__(parent)\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.ax = self.figure.subplots()\n        self.setWindowTitle('Plot window')\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n        self.setLayout(layout)\n        self.resize(width,height)\n\n    def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()",
  "def __init__(self, width=600, height=800, parent=None):\n        super(PlotWindow, self).__init__(parent)\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n        self.ax = self.figure.subplots()\n        self.setWindowTitle('Plot window')\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n        self.setLayout(layout)\n        self.resize(width,height)",
  "def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()",
  "def main(argv):\n    app = QtWidgets.QApplication(sys.argv)\n\n    win = MainWindow(argv)\n    win.show()\n    return app.exec_()",
  "class GEQDSK:\n    \n\n    def __init__(self, filename):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.load(filename)\n\n\n    def _next_value(self, fh):\n        \"\"\"\n        Load the next value from the text stream 'fh'.\n        \"\"\"\n        pattern = re.compile(r\"[ +\\-]?\\d+(?:\\.\\d+(?:[Ee][\\+\\-]\\d\\d)?)?\")\n\n        for line in fh:\n            matches = pattern.findall(line)\n            for m in matches:\n                if \".\" in m:\n                    yield float(m)\n                else:\n                    yield int(m)\n\n\n    def get_flux_surface(self, psi_n, theta=None, closedContourTol = 1e-6):\n        \"\"\"\n        Trace the flux surface for the given normalized psi.\n        \"\"\"\n        #vertices, _ = self.contour_generator.create_contour(psi_n)\n        #v = self.contour_generator.create_contour(psi_n)\n        #if len(v) == 1:\n        #    vertices = v\n        #else:\n        #    vertices = v[-1]\n            \n        vertices = self.contour_generator.create_contour(psi_n)\n        \n        iClosedContour = None\n        for i in range(len(vertices)):\n            if len(vertices[i].shape)==2:\n                if np.sqrt((vertices[i][0,0]-vertices[i][-1,0])**2 + (vertices[i][0,1]-vertices[i][-1,1])**2)<closedContourTol:\n                    iClosedContour = i\n                \n        if iClosedContour is not None:\n            R, Z = vertices[iClosedContour][:,0], vertices[iClosedContour][:,1]\n        else:\n            raise ValueError('No closed flux surface was found for psi_n={}'.format(psi_n))\n            \n\n        if theta is not None:\n            _theta = np.arctan2(R-self.R0, Z-self.Z0)\n            #_theta[-1] = _theta[0] + 2*np.pi\n            i = -1\n            while _theta[i] < 0:\n                _theta[i] += 2*np.pi\n                i -= 1\n\n            for i in range(1, _theta.size):\n                # The contour finding routine may sometimes give us the\n                # same point multiple times, so we have to remove them\n                # manually...\n                if _theta[i] == _theta[i-1]:\n                    _tt = np.zeros((_theta.size-1,))\n                    _tt[:i] = _theta[:i]\n                    _tt[i:] = _theta[(i+1):]\n\n                    _r = np.zeros((_theta.size-1,))\n                    _r[:i] = R[:i]\n                    _r[i:] = R[(i+1):]\n\n                    _z = np.zeros((_theta.size-1,))\n                    _z[:i] = Z[:i]\n                    _z[i:] = Z[(i+1):]\n\n                    _theta = _tt\n                    R = _r\n                    Z = _z\n                    break\n\n            _R = CubicSpline(_theta, R, bc_type='periodic')\n            _Z = CubicSpline(_theta, Z, bc_type='periodic')\n\n            R = _R(theta+np.pi/2)\n            Z = _Z(theta+np.pi/2)\n\n        return R, Z\n\n\n    def parametrize_equilibrium(self, psi_n=None, npsi=40):\n        \"\"\"\n        Calculates the magnetic equilibrum parameters used by the\n        analytical magnetic field in DREAM for a range of flux surfaces.\n\n        :param psi_n: List of normalized poloidal flux for which to calculate the parameters.\n        :param npsi:  Number of psi points to calculate parameters for (uniformly spaced between (0, 1]).\n        \"\"\"\n        if psi_n is None:\n            psi_n = np.linspace(0, 1, npsi+1)[1:]\n\n        radius, psi, kappa, delta, Delta, GOverR0, R, Z = [], [], [], [], [], [], [], []\n        for p in psi_n:\n            params = self._get_eq_parameters(p)\n\n            radius.append(params['r_minor'])\n            psi.append(params['psi'])\n            kappa.append(params['kappa'])\n            delta.append(params['delta'])\n            Delta.append(params['Delta'])\n            GOverR0.append(params['GOverR0'])\n            R.append(params['R'])\n            Z.append(params['Z'])\n\n        radius = np.array(radius)\n        psi = np.array(psi) * 2*np.pi / self.R0\n        kappa = np.array(kappa)\n        delta = np.array(delta)\n        Delta = np.array(Delta)\n        GOverR0 = np.array(GOverR0)\n\n        return {\n            'R0': self.R0,\n            'r': radius,\n            'psi': psi,\n            'kappa': kappa,\n            'delta': delta,\n            'Delta': Delta,\n            'GOverR0': GOverR0\n        }\n\n\n    def _get_eq_parameters(self, psi_n):\n        \"\"\"\n        Calculates the magnetic equilibrium parameters used by the\n        analytical magnetic field in DREAM for a *SINGLE* flux surface.\n        \"\"\"\n        R, Z = self.get_flux_surface(psi_n)\n\n        rho = self.rho(psi_n)\n        r_minor = rho * self.a_minor\n        Zind = np.argmax(abs(Z))\n\n        R_upper = R[Zind]\n        drho_dpsi = self.rho.derivative()(psi_n)\n        R0 = self.R0\n        R_major = self.R_major(psi_n)\n\n        # Shaping parameters\n        psi = self.psi(R[0], Z[0])[0,0]\n        kappa = (max(Z)-min(Z)) / (2*r_minor)\n        delta = (R_major - R_upper) / r_minor\n        #Delta = self.R_major.derivative()(psi_n) / drho_dpsi / self.a_minor\n        Delta = (max(R)+min(R))/2 - R0\n        GOverR0 = self.f_psi(psi_n) / R0\n\n        return {\n            'r_minor': r_minor,\n            'psi': psi,\n            'kappa': kappa,\n            'delta': delta,\n            'Delta': Delta,\n            'GOverR0': GOverR0,\n            'R': R,\n            'Z': Z\n        }\n\n\n    def get_Br(self, R, Z):\n        \"\"\"\n        Return the radial magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        Br = 1/R * self.psi(R, Z, dy=1, grid=False)\n        return Br\n\n\n    def get_Bz(self, R, Z):\n        \"\"\"\n        Return the vertical magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        Bz = 1/R * self.psi(R, Z, dx=1, grid=False)\n        return Bz\n\n\n    def get_Btor(self, R, Z):\n        \"\"\"\n        Return the toroidal magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        psi = self.psi(R, Z, grid=False)\n        psi_n = (psi - self.psi_axis) / (self.psi_bdry - self.psi_axis)\n\n        f  = self.f_psi(psi_n)\n        Btor = f / R\n\n        return Btor\n\n\n    def load(self, filename):\n        \"\"\"\n        Load data from the named GEQDSK file to this object.\n        \"\"\"\n        data = self.load_geqdsk(filename)\n        self.process_data(data)\n\n\n    def load_geqdsk(self, filename, cocos=1):\n        \"\"\"\n        Load the named GEQDSK file.\n        \"\"\"\n        with open(filename) as fh:\n            header = fh.readline()\n            words = header.split()\n            if len(words) < 3:\n                raise ValueError(\"Expected at least 3 numbers on first line\")\n\n            nx, ny = int(words[-2]), int(words[-1])\n            \n            data = {\"nx\": nx, \"ny\": ny}\n            fields = [\"rdim\", \"zdim\", \"rcentr\", \"rleft\", \"zmid\", \"rmagx\",\n                      \"zmagx\", \"simagx\", \"sibdry\", \"bcentr\", \"cpasma\", \"simagx\",\n                      None, \"rmagx\", None, \"zmagx\", None, \"sibdry\", None, None]\n\n            values = self._next_value(fh)\n            \n            for f in fields:\n                val = next(values)\n                if f:\n                    data[f] = val\n\n            def _read_1d(n):\n                \"\"\"\n                Read a 1D array of length n from the GEQDSK file.\n                \"\"\"\n                val = np.zeros(n)\n                for i in range(n):\n                    val[i] = next(values)\n\n                return val\n\n\n            def _read_2d(n, m):\n                \"\"\"\n                Read a 2D (n,m) array in Fortran order\n                \"\"\"\n                val = np.zeros((n, m))\n                for j in range(m):\n                    for i in range(n):\n                        val[i, j] = next(values)\n\n                return val\n\n\n            data[\"fpol\"] = _read_1d(nx)\n            data[\"pres\"] = _read_1d(nx)\n            data[\"ffprime\"] = _read_1d(nx)\n            data[\"pprime\"] = _read_1d(nx)\n\n            data[\"psi\"] = _read_2d(nx, ny)\n\n            data[\"qpsi\"] = _read_1d(nx)\n\n            # Ensure that psi is divided by 2pi\n            if cocos > 10:\n                for var in [\"psi\", \"simagx\", \"sibdry\"]:\n                    data[var] /= 2 * pi\n\n            nbdry = next(values)\n            nlim = next(values)\n\n            if nbdry > 0:\n                data[\"rbdry\"] = np.zeros(nbdry)\n                data[\"zbdry\"] = np.zeros(nbdry)\n                for i in range(nbdry):\n                    data[\"rbdry\"][i] = next(values)\n                    data[\"zbdry\"][i] = next(values)\n\n            if nlim > 0:\n                data[\"rlim\"] = np.zeros(nlim)\n                data[\"zlim\"] = np.zeros(nlim)\n                for i in range(nlim):\n                    data[\"rlim\"][i] = next(values)\n                    data[\"zlim\"][i] = next(values)\n\n            return data\n\n\n    def process_data(self, data):\n        \"\"\"\n        Load data from the given GEQDSK dictionary.\n        \"\"\"\n        self.nr = data['nx']\n        self.nz = data['ny']\n\n        psi = data['psi']\n        self.bcentr = data['bcentr']\n        self.psi_axis = data['simagx']\n        self.psi_bdry = data['sibdry']\n\n        psi_n = np.linspace(0, 1, self.nr)\n\n        self.f_psi    = InterpolatedUnivariateSpline(psi_n, data[\"fpol\"])\n        self.ff_prime = InterpolatedUnivariateSpline(psi_n, data[\"ffprime\"])\n        self.q        = InterpolatedUnivariateSpline(psi_n, data[\"qpsi\"])\n        self.pressure = InterpolatedUnivariateSpline(psi_n, data[\"pres\"])\n        self.p_prime  = self.pressure.derivative()\n\n        self.Z0 = data['zmagx']\n        self.R = np.linspace(data[\"rleft\"], data[\"rleft\"]+data[\"rdim\"], self.nr)\n        self.Z = np.linspace(data[\"zmid\"]-data[\"zdim\"]/2, data[\"zmid\"]+data[\"zdim\"]/2, self.nz)\n\n        self.psi = RectBivariateSpline(self.R, self.Z, psi)\n\n        # Set up contour generator\n        psi2d = np.transpose(self.psi(self.R, self.Z))\n        psin2d = (psi2d - self.psi_axis) / (self.psi_bdry - self.psi_axis)\n        R, Z = np.meshgrid(self.R, self.Z)\n        self.contour_generator = QuadContourGenerator(R, Z, psin2d, None, True, 0)\n\n        rho = np.zeros(psi_n.shape)\n        R_major = np.zeros(psi_n.shape)\n\n        for i, i_psiN in enumerate(psi_n[1:]):\n            surface_R, surface_Z = self.get_flux_surface(psi_n=i_psiN)\n\n            rho[i+1] = (max(surface_R)-min(surface_R)) / 2\n            R_major[i+1] = (max(surface_R)+min(surface_R)) / 2\n\n        self.lcfs_R = surface_R\n        self.lcfs_Z = surface_Z\n\n        self.a_minor = rho[-1]\n\n        rho = rho / rho[-1]\n\n        R_major[0] = R_major[1] + psi_n[1] * (R_major[2]-R_major[1]) / (psi_n[2]-psi_n[1])\n\n        self.rho = InterpolatedUnivariateSpline(psi_n, rho)\n        self.R_major = InterpolatedUnivariateSpline(psi_n, R_major)\n\n        self.R0 = self.R_major(0)\n\n\n    def plot_flux_surfaces(self, ax=None, nr=10, ntheta=200, fit=True, *args, **kwargs):\n        \"\"\"\n        Plot the flux surfaces of this magnetic equilibrium.\n\n        :param ax:       Matplotlib Axes object to use for drawing.\n        :param nr:       Number of flux surfaces to plot.\n        :param ntheta:   Number of poloidal angles to plot (for contour fit).\n        :param fit:      If ``True``, plots the DREAM parameter fit surfaces instead of the actual flux surfaces.\n        :param *args:    Arguments for ``ax.plot()``.\n        :param **kwargs: Keyword arguments for ``ax.plot()``.\n        \"\"\"\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        if fit:\n            theta = np.linspace(0, 2*np.pi, ntheta)\n            p = self.parametrize_equilibrium(npsi=nr)\n\n            for i in range(p['r'].size):\n                R = p['R0'] + p['Delta'][i] + p['r'][i]*np.cos(theta + p['delta'][i]*np.sin(theta))\n                Z = p['r'][i]*p['kappa'][i]*np.sin(theta)\n\n                ax.plot(R, Z, *args, **kwargs)\n            ax.axis('equal')\n        else:\n            psi_n = np.linspace(0, 1, nr+1)[1:]\n            for p in psi_n:\n                R, Z = self.get_flux_surface(p)\n                ax.plot(R, Z, *args, **kwargs)\n            ax.axis('equal')\n\n        return ax\n\n\n    def get_LUKE(self, npsi=80, ntheta=90):\n        \"\"\"\n        Returns equilibrium data in the LUKE equilibrium format.\n        \"\"\"\n        theta = np.linspace(0, 2*np.pi, ntheta)\n        psi_n = np.linspace(0, 1, npsi+1)[1:]\n\n        Rp, Zp = self.R0, self.Z0\n        psi_apRp = 2*np.pi * self.psi(Rp+self.rho(psi_n), self.Z0) * self.a_minor / Rp\n\n        ptx = np.zeros((psi_n.size, ntheta))\n        pty = np.zeros((psi_n.size, ntheta))\n        for i in range(npsi):\n            ptx[i,:], pty[i,:] = self.get_flux_surface(psi_n[i], theta=theta)\n\n\n        ptBx = self.get_Br(ptx, pty)\n        ptBy = self.get_Bz(ptx, pty)\n        ptBPHI = self.get_Btor(ptx, pty)\n\n        return {\n            'id': 'GEQDSK data',\n            'Rp': np.array([Rp]), 'Zp': np.array([Zp]),\n            'psi_apRp': psi_apRp,\n            'theta': theta,\n            'ptx': ptx.T-Rp, 'pty': pty.T-Zp,\n            'ptBx': ptBx.T, 'ptBy': ptBy.T, 'ptBPHI': ptBPHI.T\n        }\n\n\n    def save_eq_parameters(self, filename, nr=40):\n        \"\"\"\n        Save the DREAM analytical equilibrium parameters corresponding to this\n        GEQDSK file to an HDF5 file named ``filename``.\n        \"\"\"\n        params = self.parametrize_equilibrium(npsi=nr)\n\n        with h5py.File(filename, 'w') as f:\n            f['r'] = params['r']\n            f['Delta'] = params['Delta']\n            f['delta'] = params['delta']\n            f['GOverR0'] = params['GOverR0']\n            f['kappa'] = params['kappa']\n            f['psi_p'] = params['psi']\n\n    \n    def save_LUKE(self, filename, npsi=80, ntheta=90):\n        \"\"\"\n        Save this equilibrium in a LUKE compatible equilibrium file.\n        \"\"\"\n        equil = self.get_LUKE(npsi=npsi, ntheta=ntheta)\n\n        with h5py.File(filename, 'w') as f:\n            f.create_group('equil')\n\n            for key in equil.keys():\n                f[f'equil/{key}'] = equil[key]",
  "def __init__(self, filename):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.load(filename)",
  "def _next_value(self, fh):\n        \"\"\"\n        Load the next value from the text stream 'fh'.\n        \"\"\"\n        pattern = re.compile(r\"[ +\\-]?\\d+(?:\\.\\d+(?:[Ee][\\+\\-]\\d\\d)?)?\")\n\n        for line in fh:\n            matches = pattern.findall(line)\n            for m in matches:\n                if \".\" in m:\n                    yield float(m)\n                else:\n                    yield int(m)",
  "def get_flux_surface(self, psi_n, theta=None, closedContourTol = 1e-6):\n        \"\"\"\n        Trace the flux surface for the given normalized psi.\n        \"\"\"\n        #vertices, _ = self.contour_generator.create_contour(psi_n)\n        #v = self.contour_generator.create_contour(psi_n)\n        #if len(v) == 1:\n        #    vertices = v\n        #else:\n        #    vertices = v[-1]\n            \n        vertices = self.contour_generator.create_contour(psi_n)\n        \n        iClosedContour = None\n        for i in range(len(vertices)):\n            if len(vertices[i].shape)==2:\n                if np.sqrt((vertices[i][0,0]-vertices[i][-1,0])**2 + (vertices[i][0,1]-vertices[i][-1,1])**2)<closedContourTol:\n                    iClosedContour = i\n                \n        if iClosedContour is not None:\n            R, Z = vertices[iClosedContour][:,0], vertices[iClosedContour][:,1]\n        else:\n            raise ValueError('No closed flux surface was found for psi_n={}'.format(psi_n))\n            \n\n        if theta is not None:\n            _theta = np.arctan2(R-self.R0, Z-self.Z0)\n            #_theta[-1] = _theta[0] + 2*np.pi\n            i = -1\n            while _theta[i] < 0:\n                _theta[i] += 2*np.pi\n                i -= 1\n\n            for i in range(1, _theta.size):\n                # The contour finding routine may sometimes give us the\n                # same point multiple times, so we have to remove them\n                # manually...\n                if _theta[i] == _theta[i-1]:\n                    _tt = np.zeros((_theta.size-1,))\n                    _tt[:i] = _theta[:i]\n                    _tt[i:] = _theta[(i+1):]\n\n                    _r = np.zeros((_theta.size-1,))\n                    _r[:i] = R[:i]\n                    _r[i:] = R[(i+1):]\n\n                    _z = np.zeros((_theta.size-1,))\n                    _z[:i] = Z[:i]\n                    _z[i:] = Z[(i+1):]\n\n                    _theta = _tt\n                    R = _r\n                    Z = _z\n                    break\n\n            _R = CubicSpline(_theta, R, bc_type='periodic')\n            _Z = CubicSpline(_theta, Z, bc_type='periodic')\n\n            R = _R(theta+np.pi/2)\n            Z = _Z(theta+np.pi/2)\n\n        return R, Z",
  "def parametrize_equilibrium(self, psi_n=None, npsi=40):\n        \"\"\"\n        Calculates the magnetic equilibrum parameters used by the\n        analytical magnetic field in DREAM for a range of flux surfaces.\n\n        :param psi_n: List of normalized poloidal flux for which to calculate the parameters.\n        :param npsi:  Number of psi points to calculate parameters for (uniformly spaced between (0, 1]).\n        \"\"\"\n        if psi_n is None:\n            psi_n = np.linspace(0, 1, npsi+1)[1:]\n\n        radius, psi, kappa, delta, Delta, GOverR0, R, Z = [], [], [], [], [], [], [], []\n        for p in psi_n:\n            params = self._get_eq_parameters(p)\n\n            radius.append(params['r_minor'])\n            psi.append(params['psi'])\n            kappa.append(params['kappa'])\n            delta.append(params['delta'])\n            Delta.append(params['Delta'])\n            GOverR0.append(params['GOverR0'])\n            R.append(params['R'])\n            Z.append(params['Z'])\n\n        radius = np.array(radius)\n        psi = np.array(psi) * 2*np.pi / self.R0\n        kappa = np.array(kappa)\n        delta = np.array(delta)\n        Delta = np.array(Delta)\n        GOverR0 = np.array(GOverR0)\n\n        return {\n            'R0': self.R0,\n            'r': radius,\n            'psi': psi,\n            'kappa': kappa,\n            'delta': delta,\n            'Delta': Delta,\n            'GOverR0': GOverR0\n        }",
  "def _get_eq_parameters(self, psi_n):\n        \"\"\"\n        Calculates the magnetic equilibrium parameters used by the\n        analytical magnetic field in DREAM for a *SINGLE* flux surface.\n        \"\"\"\n        R, Z = self.get_flux_surface(psi_n)\n\n        rho = self.rho(psi_n)\n        r_minor = rho * self.a_minor\n        Zind = np.argmax(abs(Z))\n\n        R_upper = R[Zind]\n        drho_dpsi = self.rho.derivative()(psi_n)\n        R0 = self.R0\n        R_major = self.R_major(psi_n)\n\n        # Shaping parameters\n        psi = self.psi(R[0], Z[0])[0,0]\n        kappa = (max(Z)-min(Z)) / (2*r_minor)\n        delta = (R_major - R_upper) / r_minor\n        #Delta = self.R_major.derivative()(psi_n) / drho_dpsi / self.a_minor\n        Delta = (max(R)+min(R))/2 - R0\n        GOverR0 = self.f_psi(psi_n) / R0\n\n        return {\n            'r_minor': r_minor,\n            'psi': psi,\n            'kappa': kappa,\n            'delta': delta,\n            'Delta': Delta,\n            'GOverR0': GOverR0,\n            'R': R,\n            'Z': Z\n        }",
  "def get_Br(self, R, Z):\n        \"\"\"\n        Return the radial magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        Br = 1/R * self.psi(R, Z, dy=1, grid=False)\n        return Br",
  "def get_Bz(self, R, Z):\n        \"\"\"\n        Return the vertical magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        Bz = 1/R * self.psi(R, Z, dx=1, grid=False)\n        return Bz",
  "def get_Btor(self, R, Z):\n        \"\"\"\n        Return the toroidal magnetic field component on the given (R,Z) grid.\n        \"\"\"\n        psi = self.psi(R, Z, grid=False)\n        psi_n = (psi - self.psi_axis) / (self.psi_bdry - self.psi_axis)\n\n        f  = self.f_psi(psi_n)\n        Btor = f / R\n\n        return Btor",
  "def load(self, filename):\n        \"\"\"\n        Load data from the named GEQDSK file to this object.\n        \"\"\"\n        data = self.load_geqdsk(filename)\n        self.process_data(data)",
  "def load_geqdsk(self, filename, cocos=1):\n        \"\"\"\n        Load the named GEQDSK file.\n        \"\"\"\n        with open(filename) as fh:\n            header = fh.readline()\n            words = header.split()\n            if len(words) < 3:\n                raise ValueError(\"Expected at least 3 numbers on first line\")\n\n            nx, ny = int(words[-2]), int(words[-1])\n            \n            data = {\"nx\": nx, \"ny\": ny}\n            fields = [\"rdim\", \"zdim\", \"rcentr\", \"rleft\", \"zmid\", \"rmagx\",\n                      \"zmagx\", \"simagx\", \"sibdry\", \"bcentr\", \"cpasma\", \"simagx\",\n                      None, \"rmagx\", None, \"zmagx\", None, \"sibdry\", None, None]\n\n            values = self._next_value(fh)\n            \n            for f in fields:\n                val = next(values)\n                if f:\n                    data[f] = val\n\n            def _read_1d(n):\n                \"\"\"\n                Read a 1D array of length n from the GEQDSK file.\n                \"\"\"\n                val = np.zeros(n)\n                for i in range(n):\n                    val[i] = next(values)\n\n                return val\n\n\n            def _read_2d(n, m):\n                \"\"\"\n                Read a 2D (n,m) array in Fortran order\n                \"\"\"\n                val = np.zeros((n, m))\n                for j in range(m):\n                    for i in range(n):\n                        val[i, j] = next(values)\n\n                return val\n\n\n            data[\"fpol\"] = _read_1d(nx)\n            data[\"pres\"] = _read_1d(nx)\n            data[\"ffprime\"] = _read_1d(nx)\n            data[\"pprime\"] = _read_1d(nx)\n\n            data[\"psi\"] = _read_2d(nx, ny)\n\n            data[\"qpsi\"] = _read_1d(nx)\n\n            # Ensure that psi is divided by 2pi\n            if cocos > 10:\n                for var in [\"psi\", \"simagx\", \"sibdry\"]:\n                    data[var] /= 2 * pi\n\n            nbdry = next(values)\n            nlim = next(values)\n\n            if nbdry > 0:\n                data[\"rbdry\"] = np.zeros(nbdry)\n                data[\"zbdry\"] = np.zeros(nbdry)\n                for i in range(nbdry):\n                    data[\"rbdry\"][i] = next(values)\n                    data[\"zbdry\"][i] = next(values)\n\n            if nlim > 0:\n                data[\"rlim\"] = np.zeros(nlim)\n                data[\"zlim\"] = np.zeros(nlim)\n                for i in range(nlim):\n                    data[\"rlim\"][i] = next(values)\n                    data[\"zlim\"][i] = next(values)\n\n            return data",
  "def process_data(self, data):\n        \"\"\"\n        Load data from the given GEQDSK dictionary.\n        \"\"\"\n        self.nr = data['nx']\n        self.nz = data['ny']\n\n        psi = data['psi']\n        self.bcentr = data['bcentr']\n        self.psi_axis = data['simagx']\n        self.psi_bdry = data['sibdry']\n\n        psi_n = np.linspace(0, 1, self.nr)\n\n        self.f_psi    = InterpolatedUnivariateSpline(psi_n, data[\"fpol\"])\n        self.ff_prime = InterpolatedUnivariateSpline(psi_n, data[\"ffprime\"])\n        self.q        = InterpolatedUnivariateSpline(psi_n, data[\"qpsi\"])\n        self.pressure = InterpolatedUnivariateSpline(psi_n, data[\"pres\"])\n        self.p_prime  = self.pressure.derivative()\n\n        self.Z0 = data['zmagx']\n        self.R = np.linspace(data[\"rleft\"], data[\"rleft\"]+data[\"rdim\"], self.nr)\n        self.Z = np.linspace(data[\"zmid\"]-data[\"zdim\"]/2, data[\"zmid\"]+data[\"zdim\"]/2, self.nz)\n\n        self.psi = RectBivariateSpline(self.R, self.Z, psi)\n\n        # Set up contour generator\n        psi2d = np.transpose(self.psi(self.R, self.Z))\n        psin2d = (psi2d - self.psi_axis) / (self.psi_bdry - self.psi_axis)\n        R, Z = np.meshgrid(self.R, self.Z)\n        self.contour_generator = QuadContourGenerator(R, Z, psin2d, None, True, 0)\n\n        rho = np.zeros(psi_n.shape)\n        R_major = np.zeros(psi_n.shape)\n\n        for i, i_psiN in enumerate(psi_n[1:]):\n            surface_R, surface_Z = self.get_flux_surface(psi_n=i_psiN)\n\n            rho[i+1] = (max(surface_R)-min(surface_R)) / 2\n            R_major[i+1] = (max(surface_R)+min(surface_R)) / 2\n\n        self.lcfs_R = surface_R\n        self.lcfs_Z = surface_Z\n\n        self.a_minor = rho[-1]\n\n        rho = rho / rho[-1]\n\n        R_major[0] = R_major[1] + psi_n[1] * (R_major[2]-R_major[1]) / (psi_n[2]-psi_n[1])\n\n        self.rho = InterpolatedUnivariateSpline(psi_n, rho)\n        self.R_major = InterpolatedUnivariateSpline(psi_n, R_major)\n\n        self.R0 = self.R_major(0)",
  "def plot_flux_surfaces(self, ax=None, nr=10, ntheta=200, fit=True, *args, **kwargs):\n        \"\"\"\n        Plot the flux surfaces of this magnetic equilibrium.\n\n        :param ax:       Matplotlib Axes object to use for drawing.\n        :param nr:       Number of flux surfaces to plot.\n        :param ntheta:   Number of poloidal angles to plot (for contour fit).\n        :param fit:      If ``True``, plots the DREAM parameter fit surfaces instead of the actual flux surfaces.\n        :param *args:    Arguments for ``ax.plot()``.\n        :param **kwargs: Keyword arguments for ``ax.plot()``.\n        \"\"\"\n        fig = None\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.figure\n\n        if fit:\n            theta = np.linspace(0, 2*np.pi, ntheta)\n            p = self.parametrize_equilibrium(npsi=nr)\n\n            for i in range(p['r'].size):\n                R = p['R0'] + p['Delta'][i] + p['r'][i]*np.cos(theta + p['delta'][i]*np.sin(theta))\n                Z = p['r'][i]*p['kappa'][i]*np.sin(theta)\n\n                ax.plot(R, Z, *args, **kwargs)\n            ax.axis('equal')\n        else:\n            psi_n = np.linspace(0, 1, nr+1)[1:]\n            for p in psi_n:\n                R, Z = self.get_flux_surface(p)\n                ax.plot(R, Z, *args, **kwargs)\n            ax.axis('equal')\n\n        return ax",
  "def get_LUKE(self, npsi=80, ntheta=90):\n        \"\"\"\n        Returns equilibrium data in the LUKE equilibrium format.\n        \"\"\"\n        theta = np.linspace(0, 2*np.pi, ntheta)\n        psi_n = np.linspace(0, 1, npsi+1)[1:]\n\n        Rp, Zp = self.R0, self.Z0\n        psi_apRp = 2*np.pi * self.psi(Rp+self.rho(psi_n), self.Z0) * self.a_minor / Rp\n\n        ptx = np.zeros((psi_n.size, ntheta))\n        pty = np.zeros((psi_n.size, ntheta))\n        for i in range(npsi):\n            ptx[i,:], pty[i,:] = self.get_flux_surface(psi_n[i], theta=theta)\n\n\n        ptBx = self.get_Br(ptx, pty)\n        ptBy = self.get_Bz(ptx, pty)\n        ptBPHI = self.get_Btor(ptx, pty)\n\n        return {\n            'id': 'GEQDSK data',\n            'Rp': np.array([Rp]), 'Zp': np.array([Zp]),\n            'psi_apRp': psi_apRp,\n            'theta': theta,\n            'ptx': ptx.T-Rp, 'pty': pty.T-Zp,\n            'ptBx': ptBx.T, 'ptBy': ptBy.T, 'ptBPHI': ptBPHI.T\n        }",
  "def save_eq_parameters(self, filename, nr=40):\n        \"\"\"\n        Save the DREAM analytical equilibrium parameters corresponding to this\n        GEQDSK file to an HDF5 file named ``filename``.\n        \"\"\"\n        params = self.parametrize_equilibrium(npsi=nr)\n\n        with h5py.File(filename, 'w') as f:\n            f['r'] = params['r']\n            f['Delta'] = params['Delta']\n            f['delta'] = params['delta']\n            f['GOverR0'] = params['GOverR0']\n            f['kappa'] = params['kappa']\n            f['psi_p'] = params['psi']",
  "def save_LUKE(self, filename, npsi=80, ntheta=90):\n        \"\"\"\n        Save this equilibrium in a LUKE compatible equilibrium file.\n        \"\"\"\n        equil = self.get_LUKE(npsi=npsi, ntheta=ntheta)\n\n        with h5py.File(filename, 'w') as f:\n            f.create_group('equil')\n\n            for key in equil.keys():\n                f[f'equil/{key}'] = equil[key]",
  "def _read_1d(n):\n                \"\"\"\n                Read a 1D array of length n from the GEQDSK file.\n                \"\"\"\n                val = np.zeros(n)\n                for i in range(n):\n                    val[i] = next(values)\n\n                return val",
  "def _read_2d(n, m):\n                \"\"\"\n                Read a 2D (n,m) array in Fortran order\n                \"\"\"\n                val = np.zeros((n, m))\n                for j in range(m):\n                    for i in range(n):\n                        val[i, j] = next(values)\n\n                return val",
  "def isAvailable():\n    \"\"\"\n    Magnetic fields from file are always available, regardless of the\n    computer system.\n    \"\"\"\n    return True",
  "def getLUKE(file, *args, **kwargs):\n    \"\"\"\n    Returns magnetic equilibrium data from the named file.\n\n    :param file: Name of file to load data from.\n    \"\"\"\n    if file.endswith('.geqdsk'):\n        mf = GEQDSK(file)\n        return mf.get_LUKE(*args, **kwargs)\n    else:\n        # Assume LUKE format...\n        mf = LUKEMagneticField(file)\n\n        equil = {\n            'id': mf.id,\n            'Rp': mf.Rp,\n            'Zp': mf.Zp,\n            'psi_apRp': mf.psi_apRp,\n            'theta': mf.theta,\n            'ptx': mf.ptx,\n            'pty': mf.pty,\n            'ptBx': mf.ptBx,\n            'ptBy': mf.ptBy,\n            'ptBPHI': mf.ptBPHI\n        }\n\n        return equil",
  "def getShaping(file, *args, equil=None, **kwargs):\n    \"\"\"\n    Calculates DREAM shaping parameters corresponding to the given\n    magnetic equilibrium.\n    \"\"\"\n    if file.endswith('.geqdsk'):\n        mf = GEQDSK(file)\n        return mf.parametrize_equilibrium(*args, **kwargs)\n    else:\n        if equil is None:\n            equil = getLUKE(file, *args, **kwargs)\n        return eqhelpers.parametrize_equilibrium(**equil)",
  "class Ui_EqGet(object):\n    def setupUi(self, EqGet):\n        EqGet.setObjectName(\"EqGet\")\n        EqGet.resize(600, 750)\n        self.centralwidget = QtWidgets.QWidget(EqGet)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.cbTokamak = QtWidgets.QComboBox(self.centralwidget)\n        self.cbTokamak.setObjectName(\"cbTokamak\")\n        self.verticalLayout.addWidget(self.cbTokamak)\n        self.gridLayout = QtWidgets.QGridLayout()\n        self.gridLayout.setContentsMargins(-1, 0, -1, -1)\n        self.gridLayout.setObjectName(\"gridLayout\")\n        self.tbShot = QtWidgets.QLineEdit(self.centralwidget)\n        self.tbShot.setObjectName(\"tbShot\")\n        self.gridLayout.addWidget(self.tbShot, 1, 0, 1, 1)\n        self.lblDischarge = QtWidgets.QLabel(self.centralwidget)\n        self.lblDischarge.setObjectName(\"lblDischarge\")\n        self.gridLayout.addWidget(self.lblDischarge, 0, 0, 1, 1)\n        self.lblTime = QtWidgets.QLabel(self.centralwidget)\n        self.lblTime.setObjectName(\"lblTime\")\n        self.gridLayout.addWidget(self.lblTime, 0, 1, 1, 1)\n        self.tbTime = QtWidgets.QLineEdit(self.centralwidget)\n        self.tbTime.setObjectName(\"tbTime\")\n        self.gridLayout.addWidget(self.tbTime, 1, 1, 1, 1)\n        self.btnLoad = QtWidgets.QPushButton(self.centralwidget)\n        self.btnLoad.setObjectName(\"btnLoad\")\n        self.gridLayout.addWidget(self.btnLoad, 1, 2, 1, 1)\n        self.gridLayout.setColumnStretch(0, 5)\n        self.gridLayout.setColumnStretch(1, 1)\n        self.verticalLayout.addLayout(self.gridLayout)\n        self.frameFluxSurfaces = QtWidgets.QFrame(self.centralwidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.frameFluxSurfaces.sizePolicy().hasHeightForWidth())\n        self.frameFluxSurfaces.setSizePolicy(sizePolicy)\n        self.frameFluxSurfaces.setFrameShape(QtWidgets.QFrame.StyledPanel)\n        self.frameFluxSurfaces.setFrameShadow(QtWidgets.QFrame.Raised)\n        self.frameFluxSurfaces.setObjectName(\"frameFluxSurfaces\")\n        self.verticalLayout.addWidget(self.frameFluxSurfaces)\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_2.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n        self.btnPlotPsi = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotPsi.setObjectName(\"btnPlotPsi\")\n        self.horizontalLayout_2.addWidget(self.btnPlotPsi)\n        self.btnPlotB = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotB.setObjectName(\"btnPlotB\")\n        self.horizontalLayout_2.addWidget(self.btnPlotB)\n        self.btnPlotBpol = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBpol.setObjectName(\"btnPlotBpol\")\n        self.horizontalLayout_2.addWidget(self.btnPlotBpol)\n        self.verticalLayout.addLayout(self.horizontalLayout_2)\n        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_3.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout_3.setObjectName(\"horizontalLayout_3\")\n        self.btnPlotBr = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBr.setObjectName(\"btnPlotBr\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBr)\n        self.btnPlotBz = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBz.setObjectName(\"btnPlotBz\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBz)\n        self.btnPlotBphi = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBphi.setObjectName(\"btnPlotBphi\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBphi)\n        self.verticalLayout.addLayout(self.horizontalLayout_3)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.btnShaping = QtWidgets.QPushButton(self.centralwidget)\n        self.btnShaping.setObjectName(\"btnShaping\")\n        self.horizontalLayout.addWidget(self.btnShaping)\n        self.btnSave = QtWidgets.QPushButton(self.centralwidget)\n        self.btnSave.setObjectName(\"btnSave\")\n        self.horizontalLayout.addWidget(self.btnSave)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        EqGet.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(EqGet)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 600, 26))\n        self.menubar.setObjectName(\"menubar\")\n        self.menuFile = QtWidgets.QMenu(self.menubar)\n        self.menuFile.setObjectName(\"menuFile\")\n        EqGet.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(EqGet)\n        self.statusbar.setObjectName(\"statusbar\")\n        EqGet.setStatusBar(self.statusbar)\n        self.actionExit = QtWidgets.QAction(EqGet)\n        self.actionExit.setObjectName(\"actionExit\")\n        self.menuFile.addAction(self.actionExit)\n        self.menubar.addAction(self.menuFile.menuAction())\n\n        self.retranslateUi(EqGet)\n        QtCore.QMetaObject.connectSlotsByName(EqGet)\n\n    def retranslateUi(self, EqGet):\n        _translate = QtCore.QCoreApplication.translate\n        EqGet.setWindowTitle(_translate(\"EqGet\", \"DREAM Equilibrium Tool - LUKE format\"))\n        self.lblDischarge.setText(_translate(\"EqGet\", \"Discharge:\"))\n        self.lblTime.setText(_translate(\"EqGet\", \"Time:\"))\n        self.tbTime.setText(_translate(\"EqGet\", \"1.0\"))\n        self.btnLoad.setText(_translate(\"EqGet\", \"Load\"))\n        self.btnPlotPsi.setText(_translate(\"EqGet\", \"Plot Psi\"))\n        self.btnPlotB.setText(_translate(\"EqGet\", \"Plot B\"))\n        self.btnPlotBpol.setText(_translate(\"EqGet\", \"Plot Bpol\"))\n        self.btnPlotBr.setText(_translate(\"EqGet\", \"Plot Br\"))\n        self.btnPlotBz.setText(_translate(\"EqGet\", \"Plot Bz\"))\n        self.btnPlotBphi.setText(_translate(\"EqGet\", \"Plot Bphi\"))\n        self.btnShaping.setText(_translate(\"EqGet\", \"Calculate shaping parameters\"))\n        self.btnSave.setText(_translate(\"EqGet\", \"Save\"))\n        self.menuFile.setTitle(_translate(\"EqGet\", \"File\"))\n        self.actionExit.setText(_translate(\"EqGet\", \"Exit\"))",
  "def setupUi(self, EqGet):\n        EqGet.setObjectName(\"EqGet\")\n        EqGet.resize(600, 750)\n        self.centralwidget = QtWidgets.QWidget(EqGet)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.cbTokamak = QtWidgets.QComboBox(self.centralwidget)\n        self.cbTokamak.setObjectName(\"cbTokamak\")\n        self.verticalLayout.addWidget(self.cbTokamak)\n        self.gridLayout = QtWidgets.QGridLayout()\n        self.gridLayout.setContentsMargins(-1, 0, -1, -1)\n        self.gridLayout.setObjectName(\"gridLayout\")\n        self.tbShot = QtWidgets.QLineEdit(self.centralwidget)\n        self.tbShot.setObjectName(\"tbShot\")\n        self.gridLayout.addWidget(self.tbShot, 1, 0, 1, 1)\n        self.lblDischarge = QtWidgets.QLabel(self.centralwidget)\n        self.lblDischarge.setObjectName(\"lblDischarge\")\n        self.gridLayout.addWidget(self.lblDischarge, 0, 0, 1, 1)\n        self.lblTime = QtWidgets.QLabel(self.centralwidget)\n        self.lblTime.setObjectName(\"lblTime\")\n        self.gridLayout.addWidget(self.lblTime, 0, 1, 1, 1)\n        self.tbTime = QtWidgets.QLineEdit(self.centralwidget)\n        self.tbTime.setObjectName(\"tbTime\")\n        self.gridLayout.addWidget(self.tbTime, 1, 1, 1, 1)\n        self.btnLoad = QtWidgets.QPushButton(self.centralwidget)\n        self.btnLoad.setObjectName(\"btnLoad\")\n        self.gridLayout.addWidget(self.btnLoad, 1, 2, 1, 1)\n        self.gridLayout.setColumnStretch(0, 5)\n        self.gridLayout.setColumnStretch(1, 1)\n        self.verticalLayout.addLayout(self.gridLayout)\n        self.frameFluxSurfaces = QtWidgets.QFrame(self.centralwidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.frameFluxSurfaces.sizePolicy().hasHeightForWidth())\n        self.frameFluxSurfaces.setSizePolicy(sizePolicy)\n        self.frameFluxSurfaces.setFrameShape(QtWidgets.QFrame.StyledPanel)\n        self.frameFluxSurfaces.setFrameShadow(QtWidgets.QFrame.Raised)\n        self.frameFluxSurfaces.setObjectName(\"frameFluxSurfaces\")\n        self.verticalLayout.addWidget(self.frameFluxSurfaces)\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_2.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n        self.btnPlotPsi = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotPsi.setObjectName(\"btnPlotPsi\")\n        self.horizontalLayout_2.addWidget(self.btnPlotPsi)\n        self.btnPlotB = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotB.setObjectName(\"btnPlotB\")\n        self.horizontalLayout_2.addWidget(self.btnPlotB)\n        self.btnPlotBpol = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBpol.setObjectName(\"btnPlotBpol\")\n        self.horizontalLayout_2.addWidget(self.btnPlotBpol)\n        self.verticalLayout.addLayout(self.horizontalLayout_2)\n        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_3.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout_3.setObjectName(\"horizontalLayout_3\")\n        self.btnPlotBr = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBr.setObjectName(\"btnPlotBr\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBr)\n        self.btnPlotBz = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBz.setObjectName(\"btnPlotBz\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBz)\n        self.btnPlotBphi = QtWidgets.QPushButton(self.centralwidget)\n        self.btnPlotBphi.setObjectName(\"btnPlotBphi\")\n        self.horizontalLayout_3.addWidget(self.btnPlotBphi)\n        self.verticalLayout.addLayout(self.horizontalLayout_3)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setContentsMargins(-1, 0, -1, -1)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.btnShaping = QtWidgets.QPushButton(self.centralwidget)\n        self.btnShaping.setObjectName(\"btnShaping\")\n        self.horizontalLayout.addWidget(self.btnShaping)\n        self.btnSave = QtWidgets.QPushButton(self.centralwidget)\n        self.btnSave.setObjectName(\"btnSave\")\n        self.horizontalLayout.addWidget(self.btnSave)\n        self.verticalLayout.addLayout(self.horizontalLayout)\n        EqGet.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(EqGet)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 600, 26))\n        self.menubar.setObjectName(\"menubar\")\n        self.menuFile = QtWidgets.QMenu(self.menubar)\n        self.menuFile.setObjectName(\"menuFile\")\n        EqGet.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(EqGet)\n        self.statusbar.setObjectName(\"statusbar\")\n        EqGet.setStatusBar(self.statusbar)\n        self.actionExit = QtWidgets.QAction(EqGet)\n        self.actionExit.setObjectName(\"actionExit\")\n        self.menuFile.addAction(self.actionExit)\n        self.menubar.addAction(self.menuFile.menuAction())\n\n        self.retranslateUi(EqGet)\n        QtCore.QMetaObject.connectSlotsByName(EqGet)",
  "def retranslateUi(self, EqGet):\n        _translate = QtCore.QCoreApplication.translate\n        EqGet.setWindowTitle(_translate(\"EqGet\", \"DREAM Equilibrium Tool - LUKE format\"))\n        self.lblDischarge.setText(_translate(\"EqGet\", \"Discharge:\"))\n        self.lblTime.setText(_translate(\"EqGet\", \"Time:\"))\n        self.tbTime.setText(_translate(\"EqGet\", \"1.0\"))\n        self.btnLoad.setText(_translate(\"EqGet\", \"Load\"))\n        self.btnPlotPsi.setText(_translate(\"EqGet\", \"Plot Psi\"))\n        self.btnPlotB.setText(_translate(\"EqGet\", \"Plot B\"))\n        self.btnPlotBpol.setText(_translate(\"EqGet\", \"Plot Bpol\"))\n        self.btnPlotBr.setText(_translate(\"EqGet\", \"Plot Br\"))\n        self.btnPlotBz.setText(_translate(\"EqGet\", \"Plot Bz\"))\n        self.btnPlotBphi.setText(_translate(\"EqGet\", \"Plot Bphi\"))\n        self.btnShaping.setText(_translate(\"EqGet\", \"Calculate shaping parameters\"))\n        self.btnSave.setText(_translate(\"EqGet\", \"Save\"))\n        self.menuFile.setTitle(_translate(\"EqGet\", \"File\"))\n        self.actionExit.setText(_translate(\"EqGet\", \"Exit\"))",
  "def cmpres(F1, F2, show=True, log=False, eqsys=None):\n    \"\"\"\n    Compare two residual vectors.\n    \"\"\"\n    dF = np.abs(F2 / F1 - 1)\n\n    if show:\n        plotres(dF, show=show, log=log, eqsys=eqsys)",
  "def loadres(filename):\n    \"\"\"\n    Load a residual vector from the given MAT file.\n    \"\"\"\n    with h5py.File(filename, 'r') as f:\n        F = f['F'][:]\n\n    return F",
  "def plotres(res, *args, log=True, show=True, legend=None, eqsys=None):\n    \"\"\"\n    Plot the given residual.\n    \"\"\"\n    labels = ['Residual 1']\n\n\n    if log:\n        p = lambda x : plt.semilogy(np.abs(x))\n    else:\n        p = lambda x : plt.plot(x)\n\n    p(res)\n\n    i = 2\n    for arg in args:\n        p(arg)\n        labels.append('Residual {}'.format(i))\n        i += 1\n\n    if HASMPLCURSORS:\n        cursor = mplcursors.cursor()\n        cursor.connect('add', lambda sel : _mplcursors_frmt1d(sel, eqsys=eqsys))\n\n    if legend:\n        plt.legend(legend)\n    else:\n        plt.legend(labels)\n\n    if show:\n        plt.show(block=False)",
  "class DREAMEqsys:\n    \"\"\"\n    This class loads the equation system stdout output from a DREAM\n    simulation, parses it and allows you to map unknowns by name to\n    matrix indices.\n    \"\"\"\n\n    def __init__(self, filename, nions=None):\n        \"\"\"\n        Constructor.\n\n        :param nions: Number of ion species in simulation (not required if 'N_i' and/or 'W_i' is present in the equation system).\n        \"\"\"\n        self.unknowns = []\n        self.nr = None\n        self.nions = nions\n        self.nZ0 = None\n        self.hot_npnxi = None\n        self.hot_np = None\n        self.hot_nxi = None\n        self.re_npnxi = None\n        self.re_np = None\n        self.re_nxi = None\n\n        with open(filename, 'r') as f:\n            for line in f:\n                l = [s for s in line.strip().split() if s]\n\n                id = int(l[0])\n                name  = l[1]\n                size  = int(l[2])\n                descr = ' '.join(l[3:])\n\n                self.add(id=id, name=name, size=size, description=descr)\n\n        self.initialize_sizes()\n\n\n    def __contains__(self, name):\n        \"\"\"\n        Check if this equation system contains the named unknown.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == name:\n                return True\n\n        return False\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns the unknown with the given name or at the specified\n        matrix index.\n        \"\"\"\n        if type(index) == str:\n            return self.get(index)\n        else:\n            return self.at(index)\n\n\n    def at(self, index):\n        \"\"\"\n        Returns the name of the unknown at the specified index.\n        \"\"\"\n        for u in self.unknowns:\n            if u.at(index):\n                return u\n\n        return None\n\n\n    def add(self, id, name, size, description):\n        \"\"\"\n        Add an unknown to the equation system.\n        \"\"\"\n        if len(self.unknowns) > 0:\n            offset = self.unknowns[-1].getNextOffset()\n        else:\n            offset = 0\n\n        self.unknowns.append(DREAMEqsysUnknown(id=id, offset=offset, name=name, size=size, description=description))\n\n\n    def get(self, name):\n        \"\"\"\n        Return the unknown with the given name.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == name:\n                return u\n\n        return None\n\n\n    def getnames(self):\n        \"\"\"\n        Return the name of each unknown in a list.\n        \"\"\"\n        return [u.name for u in self.unknowns]\n\n\n    def getr(self, index):\n        \"\"\"\n        Returns the radial index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getr(index)\n\n    \n    def getp(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getp(index)\n\n\n    def getxi(self, index):\n        \"\"\"\n        Returns the pitch index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getxi(index)\n\n\n    def getion(self, index):\n        \"\"\"\n        Returns the ion index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getion(index)\n\n\n    def getZ0(self, index):\n        \"\"\"\n        Returns the charge state index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getZ0(index)\n\n\n    def getoffsets(self):\n        \"\"\"\n        Return the offset of each unknown in a list.\n        \"\"\"\n        return [u.offset for u in self.unknowns]\n\n\n    def initialize_sizes(self):\n        \"\"\"\n        Determine grid resolution.\n        \"\"\"\n        # Determine NR\n        fluid = ['n_cold', 'n_hot', 'n_re', 'E_field', 'T_cold']\n        for f in fluid:\n            if f in self:\n                self.nr = self[f].size\n                break\n\n        # Number of charge states\n        if 'n_i' in self:\n            self.nZ0 = self['n_i'].size / self.nr\n\n        # Number of ion species\n        if 'N_i' in self:\n            self.nions = self['N_i'].size / self.nr\n        elif 'W_i' in self:\n            self.nions = self['W_i'].size / self.nr\n\n        # Hot np*nxi\n        if 'f_hot' in self:\n            self.hot_npnxi = self['f_hot'].size / self.nr\n\n        # Runaway np*nxi\n        if 'f_re' in self:\n            self.re_npnxi = self['f_re'].size / self.nr\n\n        self.update_unknown_sizes()\n\n\n    def setHot(self, np=None, nxi=None):\n        \"\"\"\n        Set hot grid resolution. Usually, only one of the parameters needs to be\n        specified; the other one can be deduced from the size of 'f_hot'.\n        \"\"\"\n        if np is None and nxi is None:\n            return\n\n        if np is not None:\n            self.hot_np = np\n            self.hot_nxi = self.hot_npnxi / np\n\n        if nxi is not None:\n            self.hot_nxi = nxi\n            \n            if self.hot_np is None:\n                self.hot_np = self.hot_npnxi / nxi\n\n        if self.hot_np*self.hot_nxi != self.hot_npnxi:\n            raise Exception(\"Invalid size of f_hot specified. np*nxi should be {}.\".format(self.hot_npnxi))\n\n        self.update_unknown_sizes()\n\n\n    def setRE(self, np=None, nxi=None):\n        \"\"\"\n        Set hot grid resolution. Usually, only one of the parameters needs to be\n        specified; the other one can be deduced from the size of 'f_re'.\n        \"\"\"\n        if np is None and nxi is None:\n            return\n\n        if np is not None:\n            self.re_np = np\n            self.re_nxi = self.re_npnxi / np\n\n        if nxi is not None:\n            self.re_nxi = nxi\n            \n            if self.re_np is None:\n                self.re_np = self.re_npnxi / nxi\n\n        if self.re_np*self.re_nxi != self.re_npnxi:\n            raise Exception(\"Invalid size of f_re specified. np*nxi should be {}.\".format(self.re_npnxi))\n\n        self.update_unknown_sizes()\n\n\n    def update_unknown_sizes(self):\n        \"\"\"\n        Updates the size variables of all unknowns.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == 'f_hot':\n                u.setSizes(nr=self.nr, nxi=self.hot_nxi, np=self.hot_np)\n            elif u.name == 'f_re':\n                u.setSizes(nr=self.nr, nxi=self.re_nxi, np=self.re_np)\n            elif u.name == 'n_i':\n                u.setSizes(nZ0=self.nZ0, nr=self.nr)\n            elif u.size == self.nr:     # Fluid quantity\n                u.setSizes(nr=self.nr)\n            elif u.size == self.nions*self.nr:      # N_i or W_i\n                u.setSizes(nions=self.nions, nr=self.nr)\n\n\n    def __str__(self):\n        \"\"\"\n        String representation.\n        \"\"\"\n        s = \"ID   NAME                START   DESCRIPTION\\n\"\n        for u in self.unknowns:\n            s += \"{:3d}  {:15s} {:9d}   {}\\n\".format(u.id, u.name, u.offset, u.description)\n\n        return s",
  "def __init__(self, filename, nions=None):\n        \"\"\"\n        Constructor.\n\n        :param nions: Number of ion species in simulation (not required if 'N_i' and/or 'W_i' is present in the equation system).\n        \"\"\"\n        self.unknowns = []\n        self.nr = None\n        self.nions = nions\n        self.nZ0 = None\n        self.hot_npnxi = None\n        self.hot_np = None\n        self.hot_nxi = None\n        self.re_npnxi = None\n        self.re_np = None\n        self.re_nxi = None\n\n        with open(filename, 'r') as f:\n            for line in f:\n                l = [s for s in line.strip().split() if s]\n\n                id = int(l[0])\n                name  = l[1]\n                size  = int(l[2])\n                descr = ' '.join(l[3:])\n\n                self.add(id=id, name=name, size=size, description=descr)\n\n        self.initialize_sizes()",
  "def __contains__(self, name):\n        \"\"\"\n        Check if this equation system contains the named unknown.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == name:\n                return True\n\n        return False",
  "def __getitem__(self, index):\n        \"\"\"\n        Returns the unknown with the given name or at the specified\n        matrix index.\n        \"\"\"\n        if type(index) == str:\n            return self.get(index)\n        else:\n            return self.at(index)",
  "def at(self, index):\n        \"\"\"\n        Returns the name of the unknown at the specified index.\n        \"\"\"\n        for u in self.unknowns:\n            if u.at(index):\n                return u\n\n        return None",
  "def add(self, id, name, size, description):\n        \"\"\"\n        Add an unknown to the equation system.\n        \"\"\"\n        if len(self.unknowns) > 0:\n            offset = self.unknowns[-1].getNextOffset()\n        else:\n            offset = 0\n\n        self.unknowns.append(DREAMEqsysUnknown(id=id, offset=offset, name=name, size=size, description=description))",
  "def get(self, name):\n        \"\"\"\n        Return the unknown with the given name.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == name:\n                return u\n\n        return None",
  "def getnames(self):\n        \"\"\"\n        Return the name of each unknown in a list.\n        \"\"\"\n        return [u.name for u in self.unknowns]",
  "def getr(self, index):\n        \"\"\"\n        Returns the radial index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getr(index)",
  "def getp(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getp(index)",
  "def getxi(self, index):\n        \"\"\"\n        Returns the pitch index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getxi(index)",
  "def getion(self, index):\n        \"\"\"\n        Returns the ion index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getion(index)",
  "def getZ0(self, index):\n        \"\"\"\n        Returns the charge state index corresponding to the given global matrix index.\n        \"\"\"\n        return self.at(index).getZ0(index)",
  "def getoffsets(self):\n        \"\"\"\n        Return the offset of each unknown in a list.\n        \"\"\"\n        return [u.offset for u in self.unknowns]",
  "def initialize_sizes(self):\n        \"\"\"\n        Determine grid resolution.\n        \"\"\"\n        # Determine NR\n        fluid = ['n_cold', 'n_hot', 'n_re', 'E_field', 'T_cold']\n        for f in fluid:\n            if f in self:\n                self.nr = self[f].size\n                break\n\n        # Number of charge states\n        if 'n_i' in self:\n            self.nZ0 = self['n_i'].size / self.nr\n\n        # Number of ion species\n        if 'N_i' in self:\n            self.nions = self['N_i'].size / self.nr\n        elif 'W_i' in self:\n            self.nions = self['W_i'].size / self.nr\n\n        # Hot np*nxi\n        if 'f_hot' in self:\n            self.hot_npnxi = self['f_hot'].size / self.nr\n\n        # Runaway np*nxi\n        if 'f_re' in self:\n            self.re_npnxi = self['f_re'].size / self.nr\n\n        self.update_unknown_sizes()",
  "def setHot(self, np=None, nxi=None):\n        \"\"\"\n        Set hot grid resolution. Usually, only one of the parameters needs to be\n        specified; the other one can be deduced from the size of 'f_hot'.\n        \"\"\"\n        if np is None and nxi is None:\n            return\n\n        if np is not None:\n            self.hot_np = np\n            self.hot_nxi = self.hot_npnxi / np\n\n        if nxi is not None:\n            self.hot_nxi = nxi\n            \n            if self.hot_np is None:\n                self.hot_np = self.hot_npnxi / nxi\n\n        if self.hot_np*self.hot_nxi != self.hot_npnxi:\n            raise Exception(\"Invalid size of f_hot specified. np*nxi should be {}.\".format(self.hot_npnxi))\n\n        self.update_unknown_sizes()",
  "def setRE(self, np=None, nxi=None):\n        \"\"\"\n        Set hot grid resolution. Usually, only one of the parameters needs to be\n        specified; the other one can be deduced from the size of 'f_re'.\n        \"\"\"\n        if np is None and nxi is None:\n            return\n\n        if np is not None:\n            self.re_np = np\n            self.re_nxi = self.re_npnxi / np\n\n        if nxi is not None:\n            self.re_nxi = nxi\n            \n            if self.re_np is None:\n                self.re_np = self.re_npnxi / nxi\n\n        if self.re_np*self.re_nxi != self.re_npnxi:\n            raise Exception(\"Invalid size of f_re specified. np*nxi should be {}.\".format(self.re_npnxi))\n\n        self.update_unknown_sizes()",
  "def update_unknown_sizes(self):\n        \"\"\"\n        Updates the size variables of all unknowns.\n        \"\"\"\n        for u in self.unknowns:\n            if u.name == 'f_hot':\n                u.setSizes(nr=self.nr, nxi=self.hot_nxi, np=self.hot_np)\n            elif u.name == 'f_re':\n                u.setSizes(nr=self.nr, nxi=self.re_nxi, np=self.re_np)\n            elif u.name == 'n_i':\n                u.setSizes(nZ0=self.nZ0, nr=self.nr)\n            elif u.size == self.nr:     # Fluid quantity\n                u.setSizes(nr=self.nr)\n            elif u.size == self.nions*self.nr:      # N_i or W_i\n                u.setSizes(nions=self.nions, nr=self.nr)",
  "def __str__(self):\n        \"\"\"\n        String representation.\n        \"\"\"\n        s = \"ID   NAME                START   DESCRIPTION\\n\"\n        for u in self.unknowns:\n            s += \"{:3d}  {:15s} {:9d}   {}\\n\".format(u.id, u.name, u.offset, u.description)\n\n        return s",
  "def cmp(m1, m2, show=True, tollow=None, tolup=None, eqsys=None):\n    \"\"\"\n    Compare two matrices\n\n    m1, m2: Matrices to compare.\n    tollow: Lower tolerance for an element to be considered different.\n    tolup:  Upper tolerance for an element to be considered \"extremely\" different.\n    \"\"\"\n    r, c = sparse.find(m1)[:-1]\n\n    dm  = m1.copy()\n    dm[r,c] = np.abs(m2[r,c] / m1[r,c] - 1)\n\n    if tollow is not None:\n        r, c, _ = sparse.find(dm > tollow)\n        dm2 = sparse.csr_matrix(dm.shape)\n        dm2[r,c] = dm[r,c]\n        dm = dm2\n\n    spy(dm, show=False, markersize=1, eqsys=eqsys)\n\n    if tolup is not None:\n        r, c, _ = sparse.find(dm > tolup)\n        plt.plot(c, r, 'ro')\n\n    if show:\n        plt.show(block=False)\n\n    return dm",
  "def load(filename):\n    \"\"\"\n    Loads the named PETSc binary matrix.\n    \"\"\"\n    pbio = PetscBinaryIO.PetscBinaryIO()\n    mat = pbio.readBinaryFile(filename)[0]\n    return sparse.csr_matrix((mat[1][2], mat[1][1], mat[1][0]))",
  "def _mplcursors_frmt1d(sel, eqsys=None):\n    \"\"\"\n    Matplotlib cursor format for regular 1D plots.\n    \"\"\"\n    x, y = sel.target\n\n    rx = int(np.round(x))\n\n    sx = 'x: {:d}'.format(rx)\n    sy = 'y: {:.5e}'.format(y)\n\n    if eqsys is not None:\n        sx += ' ({})'.format(eqsys[rx].toxstring(rx))\n\n    s = sx + '\\n' + sy\n\n    sel.annotation.set_text(s)",
  "def _mplcursors_frmt2d(sel, mat=None, eqsys=None):\n    \"\"\"\n    Matplotlib cursor format for spy() on sparse matrices.\n    \"\"\"\n    c, r = sel.target\n    \n    sr = 'Row: {:d}'.format(int(r))\n    sc = 'Col: {:d}'.format(int(c))\n\n    if eqsys is not None:\n        sr += ' ({})'.format(eqsys[r].toxstring(r))\n        sc += ' ({})'.format(eqsys[c].toxstring(c))\n\n    s = sr + '\\n' + sc\n\n    if mat is not None:\n        sv = 'Val: {:.4e}'.format(mat[r,c])\n        s += '\\n' + sv\n\n    sel.annotation.set_text(s)",
  "def plotcol(m1, m2=None, col=None, log=False, show=True, legend=None, eqsys=None):\n    \"\"\"\n    Plot the specified rows of the matrices.\n    \"\"\"\n    if col is None:\n        raise Exception(\"Parameter 'col' not specified.\")\n\n    if log:\n        plt.semilogy(np.abs(m1[:,col].A))\n        if m2 is not None: plt.semilogy(np.abs(m2[:,col].A))\n    else:\n        plt.plot(m1[:,col].A)\n        if m2 is not None: plt.plot(m2[:,col].A)\n\n    if HASMPLCURSORS:\n        cursor = mplcursors.cursor()\n        cursor.connect('add', lambda sel : _mplcursors_frmt1d(sel, eqsys=eqsys))\n\n    if legend:\n        plt.legend(legend)\n    else:\n        if m2 is not None: plt.legend(['Matrix 1', 'Matrix 2'])\n\n    if show:\n        plt.show(block=False)",
  "def plotcoll(*args, **kwargs):\n    plotcol(*args, log=True, **kwargs)",
  "def plotrow(m1, m2=None, row=None, *args, **kwargs):\n    if m2 is None:\n        plotcol(m1.T, None, col=row, *args, **kwargs)\n    else:\n        plotcol(m1.T, m2.T, col=row, *args, **kwargs)",
  "def plotrowl(*args, **kwargs):\n    plotrow(*args, log=True, **kwargs)",
  "def setxlabels(dreameqsys, ax=None):\n    \"\"\"\n    Set x labels of current plot based on the given DREAMEqsys object.\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n\n    ax.set_xticks(dreameqsys.getoffsets())\n    ax.set_xticklabels(dreameqsys.getnames())\n\n    plt.gcf().canvas.draw()",
  "def solve(A, b, **kwargs):\n    \"\"\"\n    Solves the sparse linear system\n\n      Ax = b\n    \n    and returns the vector x.\n    \"\"\"\n    return scipy.sparse.linalg.spsolve(A, b, **kwargs)",
  "def spy(m, show=True, aspect='auto', eqsys=None, *args, **kwargs):\n    \"\"\"\n    Spy on sparse matrix.\n    \"\"\"\n    global HASMPLCURSORS\n    x = plt.spy(m, aspect=aspect, *args, **kwargs)\n\n    if HASMPLCURSORS:\n        cursor = mplcursors.cursor()\n        cursor.connect('add', lambda sel : _mplcursors_frmt2d(sel, mat=m, eqsys=eqsys))\n\n    if show:\n        plt.show(block=False)\n\n    return x",
  "class DREAMEqsysUnknown:\n    \n\n    def __init__(self, id, offset, name, size, description):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.id = id\n        self.offset = offset\n        self.name  = name\n        self.size  = size\n        self.description = description\n\n        self.nr = None\n        self.np = None\n        self.nxi = None\n        self.nZ0 = None\n        self.nions = None\n\n\n    def __repr__(self):\n        return self.__str__()\n\n\n    def __str__(self):\n        \"\"\"\n        String representation.\n        \"\"\"\n        return self.name\n\n\n    def at(self, index):\n        return (self.offset <= index and index < self.offset+self.size)\n\n\n    def getNextOffset(self):\n        \"\"\"\n        Returns the index offset for the next unknown, following this one.\n        \"\"\"\n        return self.offset + self.size\n\n\n    def getr(self, index):\n        \"\"\"\n        Returns the radial index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nr is None:\n            return None\n\n        idx = index-self.offset\n        sz  = self.size\n\n        if self.nions is not None:\n            idx -= int(self.getion(index) * (self.size/self.nions))\n            sz  /= self.nions\n        elif self.nZ0 is not None:\n            idx -= int(self.getZ0(index) * (self.size/self.nZ0))\n            sz  /= self.nZ0\n            \n        return int(idx / (sz / self.nr))\n\n    \n    def getp(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        if self.np is None:\n            return None\n\n        idx = index-self.offset\n\n        idx -= int(self.getr(index) * (self.size/self.nr))\n        idx -= int(self.getxi(index) * (self.size/self.nr/self.nxi))\n\n        return int(idx)\n\n\n    def getxi(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nxi is None:\n            return None\n\n        idx = index-self.offset\n\n        idx -= int(self.getr(index) * (self.size/self.nr))\n\n        return int(idx / (self.size / self.nr/self.nxi))\n\n\n    def getion(self, index):\n        \"\"\"\n        Returns the ion index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nions is None:\n            return None\n\n        idx = int((index-self.offset) / (self.size/self.nions))\n\n        return idx\n\n\n    def getZ0(self, index):\n        \"\"\"\n        Returns the charge state index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nZ0 is None:\n            return None\n\n        idx = int((index-self.offset) / (self.size/self.nZ0))\n\n        return idx\n\n\n    def setSizes(self, nions=None, nZ0=None, nr=None, nxi=None, np=None):\n        \"\"\"\n        Sets the size of this unknown in various dimensions.\n        \"\"\"\n        self.nions = nions\n        self.nZ0 = nZ0\n        self.nr = nr\n        self.nxi = nxi\n        self.np = np\n\n\n    def toxstring(self, index):\n        \"\"\"\n        Convert to extended string. Includes name of unknown as\n        well as (Z0,r,xi,p) indices.\n\n        :param int index: Long format index into matrix/vector.\n        \"\"\"\n        s = '{} ('.format(self.name)\n\n        ii = self.getion(index)\n        iz = self.getZ0(index)\n        ir = self.getr(index)\n        ix = self.getxi(index)\n        ip = self.getp(index)\n\n        if ii is not None: s += 'ion={}, '.format(ii)\n        if iz is not None: s += 'Z0={}, '.format(iz)\n        if ir is not None: s += 'r={}, '.format(ir)\n        if ix is not None: s += 'xi={}, '.format(ix)\n        if ip is not None: s += 'p={}, '.format(ip)\n\n        return s[:-2] + ')'",
  "def __init__(self, id, offset, name, size, description):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.id = id\n        self.offset = offset\n        self.name  = name\n        self.size  = size\n        self.description = description\n\n        self.nr = None\n        self.np = None\n        self.nxi = None\n        self.nZ0 = None\n        self.nions = None",
  "def __repr__(self):\n        return self.__str__()",
  "def __str__(self):\n        \"\"\"\n        String representation.\n        \"\"\"\n        return self.name",
  "def at(self, index):\n        return (self.offset <= index and index < self.offset+self.size)",
  "def getNextOffset(self):\n        \"\"\"\n        Returns the index offset for the next unknown, following this one.\n        \"\"\"\n        return self.offset + self.size",
  "def getr(self, index):\n        \"\"\"\n        Returns the radial index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nr is None:\n            return None\n\n        idx = index-self.offset\n        sz  = self.size\n\n        if self.nions is not None:\n            idx -= int(self.getion(index) * (self.size/self.nions))\n            sz  /= self.nions\n        elif self.nZ0 is not None:\n            idx -= int(self.getZ0(index) * (self.size/self.nZ0))\n            sz  /= self.nZ0\n            \n        return int(idx / (sz / self.nr))",
  "def getp(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        if self.np is None:\n            return None\n\n        idx = index-self.offset\n\n        idx -= int(self.getr(index) * (self.size/self.nr))\n        idx -= int(self.getxi(index) * (self.size/self.nr/self.nxi))\n\n        return int(idx)",
  "def getxi(self, index):\n        \"\"\"\n        Returns the momentum index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nxi is None:\n            return None\n\n        idx = index-self.offset\n\n        idx -= int(self.getr(index) * (self.size/self.nr))\n\n        return int(idx / (self.size / self.nr/self.nxi))",
  "def getion(self, index):\n        \"\"\"\n        Returns the ion index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nions is None:\n            return None\n\n        idx = int((index-self.offset) / (self.size/self.nions))\n\n        return idx",
  "def getZ0(self, index):\n        \"\"\"\n        Returns the charge state index corresponding to the given global matrix index.\n        \"\"\"\n        if self.nZ0 is None:\n            return None\n\n        idx = int((index-self.offset) / (self.size/self.nZ0))\n\n        return idx",
  "def setSizes(self, nions=None, nZ0=None, nr=None, nxi=None, np=None):\n        \"\"\"\n        Sets the size of this unknown in various dimensions.\n        \"\"\"\n        self.nions = nions\n        self.nZ0 = nZ0\n        self.nr = nr\n        self.nxi = nxi\n        self.np = np",
  "def toxstring(self, index):\n        \"\"\"\n        Convert to extended string. Includes name of unknown as\n        well as (Z0,r,xi,p) indices.\n\n        :param int index: Long format index into matrix/vector.\n        \"\"\"\n        s = '{} ('.format(self.name)\n\n        ii = self.getion(index)\n        iz = self.getZ0(index)\n        ir = self.getr(index)\n        ix = self.getxi(index)\n        ip = self.getp(index)\n\n        if ii is not None: s += 'ion={}, '.format(ii)\n        if iz is not None: s += 'Z0={}, '.format(iz)\n        if ir is not None: s += 'r={}, '.format(ir)\n        if ix is not None: s += 'xi={}, '.format(ix)\n        if ip is not None: s += 'p={}, '.format(ip)\n\n        return s[:-2] + ')'",
  "def save_dict(elements, outputfile):\n    \"\"\"\n    Save the ADAS data to an HDF5 file.\n    \"\"\"\n    with h5py.File(outputfile, 'w') as f:\n        _save_internal(elements, f)",
  "def _save_internal(dct, f, path=''):\n    \"\"\"\n    Internal function for saving data to HDF5.\n    \"\"\"\n    for k in dct.keys():\n        if type(dct[k]) == dict:\n            o = f.create_group(k)\n            _save_internal(dct[k], o, path=path+'/'+k)\n        elif type(dct[k]) == float:\n            f.create_dataset(k, (1,), data=dct[k])\n        elif type(dct[k]) == int:\n            f.create_dataset(k, (1,), data=dct[k], dtype='i8')\n        elif type(dct[k]) == float:\n            v = 1 if dct[k] else 0\n            f.create_dataset(k, (1,), data=v, dtype='i4')\n        elif type(dct[k]) == str:\n            dset = f.create_dataset(k, (1,), dtype='S'+str(len(dct[k])))\n            dset[0:l] = np.string_(dct[k])\n        elif type(dct[k]) == list:\n            f.create_dataset(k, (len(dct[k]),), data=dct[k])\n        elif type(dct[k]) == np.ndarray:\n            f.create_dataset(k, dct[k].shape, data=dct[k])\n        else:\n            raise Exception(\"Unrecognized data type of entry '{}/{}': {}.\".format(path, k, type(dct[k])))",
  "def fitKineticIonizationForSpecies(species, Z0, fittype, T_lower=2, T_upper=100):\n    \"\"\"\n    Fits a kinetic ionization cross section for the given charge state Z0\n    of the named ion species.\n\n    :param species: Name of ion species.\n    :param Z0:      Ion charge state.\n    :param fittype: Method to use for fitting.\n    \"\"\"\n    I_ADAS, Z, _, T, E_ion = getIonizationData(species)\n\n    if Z0 >= Z:\n        raise Exception(\"Invalid charge state specified: {}. Charge state must be strictly less than the atomic charge Z = {}.\".format(Z0, Z))\n\n    K1 = (T>T_lower).nonzero()[0][0]\n    K2 = (T>T_upper).nonzero()[0]\n\n    if K2.size == 0: K2 = T.size\n    else: K2 = K2[0]\n\n    I_A = I_ADAS[Z0,K1:K2,0]\n    T_trunc = T[K1:K2]\n\n    C_lo = 1e-4\n    C_up = 200\n    C_s  = 15\n    betaStar_lo = 0\n    betaStar_up = 1\n    betaStar_s  = 0.5\n    DI_lo = E_ion[0]\n    DI_up = 100*DI_lo\n    DI_s  = 10*DI_lo\n    tolX  = 1e-6\n\n    # Select fitting method\n    outp = {'C1': None, 'C2': None, 'DI1': None, 'DI2': None, 'betaStar': None, 'beta2': None}\n    if fittype == 'single':\n        fo, goodness, output = _inner_fit(\n            T_trunc.T, np.log(I_A), DI1=E_ion[Z0],\n            fittype='single',\n            lower=(C_lo, betaStar_lo), upper=(C_up, betaStar_up),\n            guess=(C_s, betaStar_s), tolx=tolX\n        )\n\n        outp['C1'] = output[0]\n        outp['DI1'] = E_ion[Z0]\n        outp['betaStar'] = output[1]\n    elif fittype == 'single_3p':\n        fo, goodness, output = _inner_fit(\n            T_trunc.T, np.log(I_A),\n            fittype='single_3p',\n            lower=(C_lo, betaStar_lo, E_ion[Z0]/3),\n            upper=(C_up, betaStar_up, E_ion[Z0]*3),\n            guess=(20, betaStar_s, E_ion[Z0]), tolx=tolX\n        )\n\n        outp['C1'] = output[0]\n        outp['DI1'] = output[2]\n        outp['betaStar'] = output[1]\n    elif fittype == 'double':\n        fo, goodness, output = _inner_fit(\n            T_trunc.T, np.log(I_A), DI1=E_ion[Z0], beta2=0,\n            fittype='double',\n            lower=(C_lo, C_lo, betaStar_lo, DI_lo),\n            upper=(C_up, C_up, betaStar_up, DI_up),\n            guess=(C_s, C_s, betaStar_s, DI_s), tolx=tolX\n        )\n        outp['C1'] = output[0]\n        outp['C2'] = output[1]\n        outp['DI1'] = E_ion[Z0]\n        outp['DI2'] = output[3]\n        outp['betaStar'] = output[2]\n        outp['beta2'] = 0\n    else:\n        raise Exception(\"Unrecognized 'fittype' specified: '{}'.\".format(fittype))\n\n    return fo, goodness, outp",
  "def evaluateAveragedCrossSection(T, C1, DI1, betaStar, method='single', C2=None, DI2=None, beta2=None):\n    \"\"\"\n    Evaluate the averaged ionization cross section using the specified\n    evaluation method and provided fit parameters.\n    \"\"\"\n    if method in ['single', 'single_3p']:\n        return averagedIonizationCrossSection(T, C1, DI1, betaStar)\n    elif method == 'double':\n        a1 = averagedIonizationCrossSection(T, C1, DI1, betaStar)\n        a2 = averagedIonizationCrossSection(T, C2, DI2, beta2)\n        return a1 + a2\n    else:\n        raise Exception(\"Unrecognized fitting method '{}'.\".format(method))",
  "def _inner_fit(x, y, lower, upper, guess, tolx, fittype='single', DI1=None, beta2=None):\n    \"\"\"\n    Inner routine for fitting.\n    \"\"\"\n    def f_single(x, T, y, DI1=None):\n        C1 = x[0]\n        betaStar = x[1]\n\n        if DI1 is None:\n            DI1 = x[2]\n\n        v = np.log(evaluateAveragedCrossSection(T=T, C1=C1, DI1=DI1, betaStar=betaStar))-y\n\n        # Remove points with ICS identically zero\n        v[np.where(np.isinf(v))] = 0\n\n        return v\n\n    def f_double(x, T, y, DI1=None, beta2=None):\n        C1 = x[0]\n        C2 = x[1]\n        betaStar = x[2]\n        DI2 = x[3]\n\n        if DI1 is None:\n            DI1 = x[4]\n            beta2 = x[5]\n\n        #a1 = averagedIonizationCrossSection(T, C1, DI1, betaStar)\n        #a2 = averagedIonizationCrossSection(T, C2, DI2, beta2)\n        v = np.log(evaluateAveragedCrossSection(T=T, C1=C1, C2=C2, DI1=DI1, DI2=DI2, betaStar=betaStar, beta2=beta2, method='double'))-y\n\n        # Remove points with ICS identically zero\n        v[np.where(np.isinf(v))] = 0\n\n        return v\n\n    if fittype in ['single', 'single_3p']:\n        f = f_single\n    elif fittype == 'double':\n        f = f_double\n\n    # Are DI1 and beta2 given explicitly, or are they free parameters?\n    kwargs = {'T': x, 'y': y}\n    if DI1 is not None: kwargs['DI1'] = DI1\n    if beta2 is not None: kwargs['beta2'] = beta2\n\n    result = least_squares(f, x0=guess, bounds=(lower, upper), ftol=0, xtol=tolx, kwargs=kwargs)\n\n    return result, result.optimality, result.x",
  "def f_single(x, T, y, DI1=None):\n        C1 = x[0]\n        betaStar = x[1]\n\n        if DI1 is None:\n            DI1 = x[2]\n\n        v = np.log(evaluateAveragedCrossSection(T=T, C1=C1, DI1=DI1, betaStar=betaStar))-y\n\n        # Remove points with ICS identically zero\n        v[np.where(np.isinf(v))] = 0\n\n        return v",
  "def f_double(x, T, y, DI1=None, beta2=None):\n        C1 = x[0]\n        C2 = x[1]\n        betaStar = x[2]\n        DI2 = x[3]\n\n        if DI1 is None:\n            DI1 = x[4]\n            beta2 = x[5]\n\n        #a1 = averagedIonizationCrossSection(T, C1, DI1, betaStar)\n        #a2 = averagedIonizationCrossSection(T, C2, DI2, beta2)\n        v = np.log(evaluateAveragedCrossSection(T=T, C1=C1, C2=C2, DI1=DI1, DI2=DI2, betaStar=betaStar, beta2=beta2, method='double'))-y\n\n        # Remove points with ICS identically zero\n        v[np.where(np.isinf(v))] = 0\n\n        return v",
  "def getIonizationData(species):\n    \"\"\"\n    Get ionization data for the named ion species.\n    \"\"\"\n    global CACHEDIR\n\n    Z, n, T, I_scd = _loadADAS(species, 'scd')\n    _, _, E_ion    = get_nist.load_elements([species], 'ionization', cache=True, cachedir=CACHEDIR)\n\n    n     = np.power(10, n)\n    T     = np.power(10, T)\n    I_scd = np.power(10, I_scd)\n    E_ion = E_ion[0]\n\n    return I_scd, Z, n, T, E_ion",
  "def load_element_list(filename):\n    \"\"\"\n    Load the list of elements in the ADAS database as\n    defined for this script in the 'elemenets.json' file,\n    located in the same directory as this script.\n\n    elements.json:\n      Define which datasets to use. The value indicates which year\n      the dataset corresponds to. Please check the Open_ADAS documentation\n      (https://open.adas.ac.uk/man/appxa-11.pdf) for the quality of\n      the dataset before adding it to this list.\n    \"\"\"\n\n    ELEMENTS = None\n    with open(filename, 'r') as f:\n        ELEMENTS = json.load(f)\n\n    return ELEMENTS",
  "def _initADAS():\n    \"\"\"\n    Initialize this module.\n    \"\"\"\n    global CACHEDIR, ELEMENTS\n\n    p = pathlib.Path(__file__).parent.parent.absolute()\n\n    CACHEDIR = '{}/cache'.format(p)\n    ELEMENTS = load_element_list(str(p / 'elements.json'))",
  "def _loadADAS(species, datatype, cache=True):\n    \"\"\"\n    Load the specified data for the given species from ADAS.\n\n    :param str species:  Name of ion species to load data for.\n    :param str datatype: Name of datatype to load ('acd', 'scd', 'plt', 'prb', 'ccd')\n\n    :returns: Atomic number ``Z``, density vector ``n``, temperature vector ``T``, coefficient values ``v``\n    Note that ``n``, ``T`` and ``v`` contain base-10 logarithm values and must be exponentiated before use.\n    \"\"\"\n    global CACHEDIR, ELEMENTS\n\n    year = ELEMENTS[species]\n    if type(year) == dict:\n        y = year[datatype]\n    else:\n        y = year\n\n    Z, n, T, v = parse_adas(download_adas(species, y, datatype, cache=cache, cachedir=CACHEDIR))\n\n    return Z, n, T, v",
  "def download_adas(element, year, datatype, cache=False, cachedir=None):\n    \"\"\"\n    Downloads data of the specified type for the specified element,\n    for the given year. The 'datatype' parameter may be either of the following:\n\n      acd  -- Effective recombination coefficients\n      scd  -- Effective ionization coefficients\n      ccd  -- Charge exchange effective recombination coefficients\n      plt  -- Line power driven by excitation of dominant ions\n      prb  -- Continuum and line power driven by recombination\n              and Bremsstrahlung of dominant ions\n\n    If 'cache' is True, the downloaded data is stored in a text\n    file in the specified cache directory. Alternatively, if the\n    file already exists in the specified cache directory, data is\n    read from it.\n    \"\"\"\n    # The year may also be the name of a specific file to load\n    yearIsFile = (len(year) > 3 and year[-4:] == '.dat')\n    if yearIsFile:\n        fname = year\n    else:\n        fname = '{0}{1}_{2}.dat'.format(datatype.lower(), year, element.lower())\n\n    # Construct ADAS data url\n    dt = datatype.lower()\n    url = 'https://open.adas.ac.uk/download/adf11/{0}{1}/{2}'.format(dt, year, fname)\n\n    data = None\n    fpath = pathlib.PurePath(cachedir, fname)\n    if (cache and os.path.isfile(fpath)) or yearIsFile:\n        with open(fpath, 'r') as f:\n            data = f.read()\n    else:   # Load from open.adas.ac.uk\n        with urllib.request.urlopen(url) as f:\n            if f.status != 200:\n                raise Exception(\"Failed to download '{}' from Open-ADAS.\".format(url))\n\n            data = f.read().decode('ascii')\n\n        # Save data to disk?\n        if cache:\n            # Create cache directory if it doesn't exist\n            pathlib.Path(cachedir).mkdir(parents=True, exist_ok=True)\n\n            with open(fpath, 'w') as f:\n                f.write(data)\n\n    if data.startswith('<!DOCTYPE'):\n        raise Exception(\"Failed to download '{}' from Open-ADAS. The file does not appear to exist.\".format(url))\n\n    return data",
  "def parse_adas(data):\n    \"\"\"\n    Parses the given ADAS data file. This function expects the\n    data to be in exactly the same format as obtained through\n    the Open ADAS database.\n    \"\"\"\n    lines = data.splitlines()\n\n    # Get dimensions\n    dims = lines[0].split()\n\n    Z  = int(dims[0])\n    nn = int(dims[1])\n    nT = int(dims[2])\n\n    # Density\n    i = 2\n    n = []\n    while len(n) < nn:\n        # +6: convert from cm^-3 to m^-3\n        n += [float(x)+6 for x in lines[i].split()]\n        i += 1\n\n    # Temperature\n    T = []\n    while not lines[i].strip(' C').startswith('--'):\n        T += [float(x) for x in lines[i].split()]\n        i += 1\n\n    # Skip ' ---' line...\n    i += 1\n\n    # Load data for each charge state\n    data = []\n    while lines[i][0] != 'C':\n        ldata = []\n        # Load data corresponding to single charge state\n        while not lines[i].strip(' C').startswith('--') and lines[i] != ' ':\n            # -6: convert from cm^3 to m^3\n            ldata += [float(x)-6 for x in lines[i].split()]\n            i += 1\n\n        data.append(ldata)\n        # Skip ' --'...\n        i += 1\n\n    data = np.reshape(np.array(data), (Z, nT, nn))\n    n = np.array(n)\n    T = np.array(T)\n\n    return Z, n, T, data",
  "def load_element(element, year, cache=True, cachedir=None):\n    \"\"\"\n    Load all rate coefficient data for the specified element.\n    \"\"\"\n    data = {'acd': None, 'ccd': None, 'scd': None, 'plt': None, 'prb': None}\n\n    print(\"Loading data for element '{}'... \".format(element), end=\"\")\n    Z = 0\n    t = time.time()\n    for key in data:\n        if type(year) == dict:\n            y = year[key]\n        else:\n            y = year\n            \n        # For rates other than CCD (charge-exchange), we use\n        # data for H also for its isotopes D and T.\n        el = element\n        if key != 'ccd' and el in ['D', 'T']:\n            el = 'H'\n\n        Z, n, T, v = parse_adas(download_adas(el, y, key, cache=cache, cachedir=cachedir))\n\n        data[key] = {\n            'n': n,\n            'T': T,\n            'data': v\n        }\n\n    data['Z'] = Z\n\n    # Handle hydrogen isotope mass numbers specifically...\n    if element == 'H': data['A'] = 1\n    elif element == 'D': data['A'] = 2\n    elif element == 'T': data['A'] = 3\n    else: data['A'] = 2*Z\n\n    print(\"{} ms\".format((time.time()-t)*1e3))\n\n    return data",
  "def averagedIonizationCrossSection(T, C, DI_eV, betaStar):\n    \"\"\"\n    \"\"\"\n    c = 299792458.0\n    nT = T.size\n    I_i = np.zeros(nT)\n\n    def intg(p, temperature):\n        pf = p**3 / np.sqrt(1+p**2)\n        kic = kineticIonizationContribution(p, C, DI_eV, betaStar)\n        fMe = maxwellJuttnerDistribution(p, 1, temperature)\n        return pf*kic*fMe\n\n    for k in range(nT):\n        # SciPy's \"quad()\" seems to sometimes have problems with this integrand\n        # over the infinite interval, so we split the integral into two parts:\n        # one over an interval which should contain most, if not all, of the\n        # interesting bits of the integrand, and one part covering the rest.\n        pmax = np.sqrt((800*T[k]/mc2 + 1)**2 - 1)\n        q = quad(lambda p : intg(p, T[k]), 0, pmax, epsabs=0)[0] + quad(lambda p : intg(p, T[k]), pmax, np.inf, epsabs=0)[0]\n        I_i[k] = 4*pi*c*q\n\n    return I_i",
  "def maxwellJuttnerDistribution(p, n, T):\n    \"\"\"\n    Evaluates a Maxwell-J\u00fcttner distribution function at the\n    given momentum, density and temperature, normalized such that\n      \n      integral( 4*pi*p^2 * fMe, 0, inf)\n    \n    yields the density ``n`` for all values of ``T``.\n    \"\"\"\n    global mc2\n    Theta = T / mc2\n\n    tK2exp = 4*pi*Theta*kve(2, 1/Theta)\n\n    gamma = np.sqrt(1+p**2)\n    gMinus1 = p*p/(gamma+1)\n\n    fMe = n/tK2exp * np.exp(-gMinus1/Theta)\n\n    return fMe",
  "def kineticIonizationContribution(p, C, DI_eV, betaStar):\n    \"\"\"\n    Evaluates the  total electron impact ionization cross-section.\n\n    :param p:        Incident electron momentum in units mc2.\n    :param C:        Pre-factor (undetermined by the theory, or order ~1-10).\n    :param DI_eV:    Ionization energy in eV.\n    :param betaStar: Parameter which sets the near-threshold modification to\n                     the cross-section.\n    \"\"\"\n    global mc2\n    a0  = 5.29e-11\n    Ry  = 13.6 / mc2\n\n    gamma = np.sqrt(1+p**2)\n    Ek    = p*p/(gamma+1)\n    DI    = DI_eV/mc2\n\n    if DI <= 0:\n        raise Exception('Invalid ionization energy provided (<=0)')\n    \n    U = Ek/DI\n\n    if np.isscalar(U):  # handle vector momentum vector input\n        if U > 1:\n            I_nonRel = pi*a0**2*C*(Ry/DI)**2 * np.log(U)**(1+betaStar/U)/U\n        else:\n            I_nonRel = 0\n    else:\n        I_nonRel = pi*a0**2*C*(Ry/DI)**2 * np.log(U)**(1+betaStar/U)/U\n        I_nonRel[np.where(U<=1)] = 0\n\n    # v/c\n    beta  = p/gamma\n    # Fine structure constant\n    alpha = 1/137\n    # Expression appearing inside the log term of\n    # the ultra-relativistic formula\n    logArg    = p**2/(2*DI)\n    if np.isscalar(U):\n        if U > 1:\n            I_rel = pi*a0**2*alpha**2 * C*(Ry/DI) * (np.log(logArg) - beta**2)\n        else:\n            I_rel = 0\n    else:\n        I_rel = pi*a0**2*alpha**2 * C*(Ry/DI) * (np.log(logArg) - beta**2)\n        I_rel[np.where(U<=1)] = 0\n\n    Ek_eV     = Ek*mc2\n    S         = 1/(1+np.exp(1-Ek_eV*1e-5))\n    I_kinetic = (1-S)*I_nonRel + S*I_rel\n\n    return I_kinetic",
  "def intg(p, temperature):\n        pf = p**3 / np.sqrt(1+p**2)\n        kic = kineticIonizationContribution(p, C, DI_eV, betaStar)\n        fMe = maxwellJuttnerDistribution(p, 1, temperature)\n        return pf*kic*fMe",
  "class ManualFit(QtWidgets.QMainWindow):\n    \n\n    def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        QtWidgets.QMainWindow.__init__(self)\n\n        self.ui = ManualFit_design.Ui_ManualFit()\n        self.ui.setupUi(self)\n\n        self.element_I, self.element_T = None, None\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.ax = self.figure.add_subplot(111)\n\n        self.fitLayout = QtWidgets.QVBoxLayout(self.ui.widget)\n        self.fitLayout.addWidget(self.canvas)\n\n        self.ui.cbMethod.addItem('Single cross-section')\n        self.ui.cbMethod.addItem('Single cross-section, 3-parameter')\n        self.ui.cbMethod.addItem('Double cross-sections')\n        self.ui.cbMethod.setCurrentIndex(0)\n\n        self.showParams({'C1': None, 'C2': None, 'DI1': None, 'DI2': None, 'betaStar': None, 'beta2': None})\n\n        self.loadElements()\n\n        self.bindEvents()\n\n    \n    def bindEvents(self):\n        \"\"\"\n        Bind to control events.\n        \"\"\"\n        self.ui.cbElements.currentIndexChanged.connect(self.elementSelected)\n        self.ui.cbCS.currentIndexChanged.connect(self.chargeStateSelected)\n\n        self.ui.hsTlower.valueChanged.connect(self.TlowerChanged)\n        self.ui.hsTupper.valueChanged.connect(self.TupperChanged)\n\n        self.ui.btnFit.clicked.connect(self.doFit)\n\n\n    def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()\n\n\n    def loadElements(self):\n        \"\"\"\n        Load the element named in the 'Element' text box.\n        \"\"\"\n        for e in ADAS.data.ELEMENTS.keys():\n            self.ui.cbElements.addItem(e)\n\n        self.ui.cbElements.setCurrentIndex(0)\n        self.elementSelected()\n\n\n    def elementSelected(self):\n        \"\"\"\n        A new element has been selected in the element combobox.\n        \"\"\"\n        global ROOT\n\n        el = self.ui.cbElements.currentText()\n        self.element_I, self.element_Z, _, self.element_T, _ = ADAS.data.getIonizationData(el)\n\n        self.ui.hsTlower.setMaximum(self.element_T.size)\n        self.ui.hsTupper.setMaximum(self.element_T.size)\n\n        self.TlowerChanged()\n        self.TupperChanged()\n\n        self.updateChargeStates()\n\n\n    def updateChargeStates(self):\n        \"\"\"\n        Update the list of available charge states.\n        \"\"\"\n        Z = int(self.element_Z)\n        \n        self.ui.cbCS.clear()\n\n        for i in range(Z):\n            self.ui.cbCS.addItem(str(i))\n\n        self.ui.cbCS.setCurrentIndex(0)\n        self.chargeStateSelected()\n\n\n    def chargeStateSelected(self):\n        \"\"\"\n        A new charge state as been selected in the charge state combobox.\n        \"\"\"\n        pass\n\n\n    def getElement(self):\n        \"\"\"\n        Returns the name of the currently selected element.\n        \"\"\"\n        return self.ui.cbElements.currentText()\n\n\n    def getTlower(self):\n        \"\"\"\n        Returns the currently selected lower temperature cut-off.\n        \"\"\"\n        return self.element_T[self.ui.hsTlower.value()]\n\n\n    def getTupper(self):\n        \"\"\"\n        Returns the currently selected upper temperature cut-off.\n        \"\"\"\n        return self.element_T[self.element_T.size - self.ui.hsTupper.value() - 1]\n\n\n    def getZ0(self):\n        \"\"\"\n        Returns the currently selected charge state.\n        \"\"\"\n        return int(self.ui.cbCS.currentText())\n\n\n    def TlowerChanged(self):\n        \"\"\"\n        Lower temperature bound changed.\n        \"\"\"\n        Tlower = self.getTlower()\n        self.ui.lblTlower.setText('{:.3f} eV'.format(Tlower))\n\n\n    def TupperChanged(self):\n        \"\"\"\n        Upper temperature bound changed.\n        \"\"\"\n        Tupper = self.getTupper()\n        self.ui.lblTupper.setText('{:.3f} eV'.format(Tupper))\n\n\n    def doFit(self):\n        \"\"\"\n        Fit the cross section to the selected element/charge state,\n        using the specified model on the chosen temperature interval.\n        \"\"\"\n        species = self.getElement()\n        Z0 = self.getZ0()\n\n        T_lower = self.getTlower()\n        T_upper = self.getTupper()\n\n        if T_lower >= T_upper:\n            QMessageBox.critical(self,\n                \"Invalid temperature range selected\",\n                \"The lower temperature cut-off must be strictly less than the upper temperature cut-off.\")\n            return\n        \n        idx = self.ui.cbMethod.currentIndex()\n        if idx == 0:\n            method = 'single'\n        elif idx == 1:\n            method = 'single3p'\n        elif idx == 2:\n            method = 'double'\n        else:\n            QMessageBox.critical(self,\n                \"Unrecognized fitting method\",\n                \"Unrecognized fitting method selected: '{}'.\".format(self.ui.cbMethod.currentText()))\n\n        _, _, params = ADAS.fit.fitKineticIonizationForSpecies(species, Z0=Z0, fittype=method, T_lower=T_lower, T_upper=T_upper)\n\n        self.drawFit(params)\n        self.showParams(params)\n\n\n    def drawFit(self, params):\n        \"\"\"\n        Plot the curves resulting from a fit.\n        \"\"\"\n        I_fit = ADAS.fit.evaluateAveragedCrossSection(T=self.element_T, **params)\n\n        Z0 = self.getZ0()\n        self.ax.clear()\n\n        self.ax.loglog(self.element_T, self.element_I[Z0,:,0], 'k')\n        self.ax.loglog(self.element_T, I_fit, 'r--')\n        self.ax.loglog(self.element_T, I_fit, 'rx')\n\n        Tmin, Tmax = self.element_T[0], self.element_T[-1]\n        ymin, ymax = 1e-25, 1e-10\n\n        Tl, Tu = self.getTlower(), self.getTupper()\n        self.ax.loglog([Tl, Tl], [ymin, ymax], 'c--')\n        self.ax.loglog([Tu, Tu], [ymin, ymax], 'c--')\n\n        self.ax.legend(['ADAS', 'Fit'])\n        self.ax.set_title('{}$^{{{}+}}$'.format(self.getElement(), Z0))\n\n        self.ax.set_xlim([Tmin, Tmax])\n        self.ax.set_ylim([ymin, ymax])\n\n        self.drawSafe()\n\n\n    def showParams(self, params):\n        \"\"\"\n        Visualize the resulting fit parameters.\n        \"\"\"\n        def show(val, lbl1, lbl2):\n            s = val is not None\n            if s:\n                lbl2.setText('{:.12f}'.format(val))\n\n            lbl1.setVisible(s)\n            lbl2.setVisible(s)\n\n        show(params['C1'], self.ui.lblC1l, self.ui.lblC1)\n        show(params['C2'], self.ui.lblC2l, self.ui.lblC2)\n        show(params['DI1'], self.ui.lblDI1l, self.ui.lblDI1)\n        show(params['DI2'], self.ui.lblDI2l, self.ui.lblDI2)\n        show(params['betaStar'], self.ui.lblBetaStarl, self.ui.lblBetaStar)\n        show(params['beta2'], self.ui.lblBeta2l, self.ui.lblBeta2)",
  "def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        QtWidgets.QMainWindow.__init__(self)\n\n        self.ui = ManualFit_design.Ui_ManualFit()\n        self.ui.setupUi(self)\n\n        self.element_I, self.element_T = None, None\n\n        self.figure = Figure(tight_layout=True)\n        self.canvas = FigureCanvas(self.figure)\n        self.ax = self.figure.add_subplot(111)\n\n        self.fitLayout = QtWidgets.QVBoxLayout(self.ui.widget)\n        self.fitLayout.addWidget(self.canvas)\n\n        self.ui.cbMethod.addItem('Single cross-section')\n        self.ui.cbMethod.addItem('Single cross-section, 3-parameter')\n        self.ui.cbMethod.addItem('Double cross-sections')\n        self.ui.cbMethod.setCurrentIndex(0)\n\n        self.showParams({'C1': None, 'C2': None, 'DI1': None, 'DI2': None, 'betaStar': None, 'beta2': None})\n\n        self.loadElements()\n\n        self.bindEvents()",
  "def bindEvents(self):\n        \"\"\"\n        Bind to control events.\n        \"\"\"\n        self.ui.cbElements.currentIndexChanged.connect(self.elementSelected)\n        self.ui.cbCS.currentIndexChanged.connect(self.chargeStateSelected)\n\n        self.ui.hsTlower.valueChanged.connect(self.TlowerChanged)\n        self.ui.hsTupper.valueChanged.connect(self.TupperChanged)\n\n        self.ui.btnFit.clicked.connect(self.doFit)",
  "def drawSafe(self):\n        try:\n            self.canvas.draw()\n        except RuntimeError as e:\n            msg = QMessageBox()\n            msg.setIcon(QMessageBox.Critical)\n            msg.setText(e.strerror)\n            msg.setWindowTitle('Runtime Error')\n            msg.setStandardButtons(QMessageBox.Ok)\n            msg.exec_()",
  "def loadElements(self):\n        \"\"\"\n        Load the element named in the 'Element' text box.\n        \"\"\"\n        for e in ADAS.data.ELEMENTS.keys():\n            self.ui.cbElements.addItem(e)\n\n        self.ui.cbElements.setCurrentIndex(0)\n        self.elementSelected()",
  "def elementSelected(self):\n        \"\"\"\n        A new element has been selected in the element combobox.\n        \"\"\"\n        global ROOT\n\n        el = self.ui.cbElements.currentText()\n        self.element_I, self.element_Z, _, self.element_T, _ = ADAS.data.getIonizationData(el)\n\n        self.ui.hsTlower.setMaximum(self.element_T.size)\n        self.ui.hsTupper.setMaximum(self.element_T.size)\n\n        self.TlowerChanged()\n        self.TupperChanged()\n\n        self.updateChargeStates()",
  "def updateChargeStates(self):\n        \"\"\"\n        Update the list of available charge states.\n        \"\"\"\n        Z = int(self.element_Z)\n        \n        self.ui.cbCS.clear()\n\n        for i in range(Z):\n            self.ui.cbCS.addItem(str(i))\n\n        self.ui.cbCS.setCurrentIndex(0)\n        self.chargeStateSelected()",
  "def chargeStateSelected(self):\n        \"\"\"\n        A new charge state as been selected in the charge state combobox.\n        \"\"\"\n        pass",
  "def getElement(self):\n        \"\"\"\n        Returns the name of the currently selected element.\n        \"\"\"\n        return self.ui.cbElements.currentText()",
  "def getTlower(self):\n        \"\"\"\n        Returns the currently selected lower temperature cut-off.\n        \"\"\"\n        return self.element_T[self.ui.hsTlower.value()]",
  "def getTupper(self):\n        \"\"\"\n        Returns the currently selected upper temperature cut-off.\n        \"\"\"\n        return self.element_T[self.element_T.size - self.ui.hsTupper.value() - 1]",
  "def getZ0(self):\n        \"\"\"\n        Returns the currently selected charge state.\n        \"\"\"\n        return int(self.ui.cbCS.currentText())",
  "def TlowerChanged(self):\n        \"\"\"\n        Lower temperature bound changed.\n        \"\"\"\n        Tlower = self.getTlower()\n        self.ui.lblTlower.setText('{:.3f} eV'.format(Tlower))",
  "def TupperChanged(self):\n        \"\"\"\n        Upper temperature bound changed.\n        \"\"\"\n        Tupper = self.getTupper()\n        self.ui.lblTupper.setText('{:.3f} eV'.format(Tupper))",
  "def doFit(self):\n        \"\"\"\n        Fit the cross section to the selected element/charge state,\n        using the specified model on the chosen temperature interval.\n        \"\"\"\n        species = self.getElement()\n        Z0 = self.getZ0()\n\n        T_lower = self.getTlower()\n        T_upper = self.getTupper()\n\n        if T_lower >= T_upper:\n            QMessageBox.critical(self,\n                \"Invalid temperature range selected\",\n                \"The lower temperature cut-off must be strictly less than the upper temperature cut-off.\")\n            return\n        \n        idx = self.ui.cbMethod.currentIndex()\n        if idx == 0:\n            method = 'single'\n        elif idx == 1:\n            method = 'single3p'\n        elif idx == 2:\n            method = 'double'\n        else:\n            QMessageBox.critical(self,\n                \"Unrecognized fitting method\",\n                \"Unrecognized fitting method selected: '{}'.\".format(self.ui.cbMethod.currentText()))\n\n        _, _, params = ADAS.fit.fitKineticIonizationForSpecies(species, Z0=Z0, fittype=method, T_lower=T_lower, T_upper=T_upper)\n\n        self.drawFit(params)\n        self.showParams(params)",
  "def drawFit(self, params):\n        \"\"\"\n        Plot the curves resulting from a fit.\n        \"\"\"\n        I_fit = ADAS.fit.evaluateAveragedCrossSection(T=self.element_T, **params)\n\n        Z0 = self.getZ0()\n        self.ax.clear()\n\n        self.ax.loglog(self.element_T, self.element_I[Z0,:,0], 'k')\n        self.ax.loglog(self.element_T, I_fit, 'r--')\n        self.ax.loglog(self.element_T, I_fit, 'rx')\n\n        Tmin, Tmax = self.element_T[0], self.element_T[-1]\n        ymin, ymax = 1e-25, 1e-10\n\n        Tl, Tu = self.getTlower(), self.getTupper()\n        self.ax.loglog([Tl, Tl], [ymin, ymax], 'c--')\n        self.ax.loglog([Tu, Tu], [ymin, ymax], 'c--')\n\n        self.ax.legend(['ADAS', 'Fit'])\n        self.ax.set_title('{}$^{{{}+}}$'.format(self.getElement(), Z0))\n\n        self.ax.set_xlim([Tmin, Tmax])\n        self.ax.set_ylim([ymin, ymax])\n\n        self.drawSafe()",
  "def showParams(self, params):\n        \"\"\"\n        Visualize the resulting fit parameters.\n        \"\"\"\n        def show(val, lbl1, lbl2):\n            s = val is not None\n            if s:\n                lbl2.setText('{:.12f}'.format(val))\n\n            lbl1.setVisible(s)\n            lbl2.setVisible(s)\n\n        show(params['C1'], self.ui.lblC1l, self.ui.lblC1)\n        show(params['C2'], self.ui.lblC2l, self.ui.lblC2)\n        show(params['DI1'], self.ui.lblDI1l, self.ui.lblDI1)\n        show(params['DI2'], self.ui.lblDI2l, self.ui.lblDI2)\n        show(params['betaStar'], self.ui.lblBetaStarl, self.ui.lblBetaStar)\n        show(params['beta2'], self.ui.lblBeta2l, self.ui.lblBeta2)",
  "def show(val, lbl1, lbl2):\n            s = val is not None\n            if s:\n                lbl2.setText('{:.12f}'.format(val))\n\n            lbl1.setVisible(s)\n            lbl2.setVisible(s)",
  "class Ui_ManualFit(object):\n    def setupUi(self, ManualFit):\n        ManualFit.setObjectName(\"ManualFit\")\n        ManualFit.resize(505, 745)\n        self.centralwidget = QtWidgets.QWidget(ManualFit)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.widget = QtWidgets.QWidget(self.centralwidget)\n        self.widget.setMinimumSize(QtCore.QSize(0, 120))\n        self.widget.setObjectName(\"widget\")\n        self.verticalLayout.addWidget(self.widget)\n        self.label_5 = QtWidgets.QLabel(self.centralwidget)\n        self.label_5.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.label_5.setObjectName(\"label_5\")\n        self.verticalLayout.addWidget(self.label_5)\n        self.cbElements = QtWidgets.QComboBox(self.centralwidget)\n        self.cbElements.setObjectName(\"cbElements\")\n        self.verticalLayout.addWidget(self.cbElements)\n        self.lblZ0 = QtWidgets.QLabel(self.centralwidget)\n        self.lblZ0.setEnabled(True)\n        self.lblZ0.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblZ0.setObjectName(\"lblZ0\")\n        self.verticalLayout.addWidget(self.lblZ0)\n        self.cbCS = QtWidgets.QComboBox(self.centralwidget)\n        self.cbCS.setEnabled(True)\n        self.cbCS.setObjectName(\"cbCS\")\n        self.verticalLayout.addWidget(self.cbCS)\n        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)\n        self.groupBox.setEnabled(True)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())\n        self.groupBox.setSizePolicy(sizePolicy)\n        self.groupBox.setObjectName(\"groupBox\")\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.label_15 = QtWidgets.QLabel(self.groupBox)\n        self.label_15.setObjectName(\"label_15\")\n        self.verticalLayout_2.addWidget(self.label_15)\n        self.cbMethod = QtWidgets.QComboBox(self.groupBox)\n        self.cbMethod.setObjectName(\"cbMethod\")\n        self.verticalLayout_2.addWidget(self.cbMethod)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)\n        self.horizontalLayout.setSpacing(1)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.label = QtWidgets.QLabel(self.groupBox)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())\n        self.label.setSizePolicy(sizePolicy)\n        self.label.setMaximumSize(QtCore.QSize(16777215, 20))\n        font = QtGui.QFont()\n        font.setBold(False)\n        font.setWeight(50)\n        self.label.setFont(font)\n        self.label.setObjectName(\"label\")\n        self.horizontalLayout.addWidget(self.label)\n        self.lblTlower = QtWidgets.QLabel(self.groupBox)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.lblTlower.sizePolicy().hasHeightForWidth())\n        self.lblTlower.setSizePolicy(sizePolicy)\n        self.lblTlower.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblTlower.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.lblTlower.setObjectName(\"lblTlower\")\n        self.horizontalLayout.addWidget(self.lblTlower)\n        self.verticalLayout_2.addLayout(self.horizontalLayout)\n        self.hsTlower = QtWidgets.QSlider(self.groupBox)\n        self.hsTlower.setMaximum(10)\n        self.hsTlower.setOrientation(QtCore.Qt.Horizontal)\n        self.hsTlower.setInvertedAppearance(False)\n        self.hsTlower.setTickPosition(QtWidgets.QSlider.TicksBelow)\n        self.hsTlower.setTickInterval(1)\n        self.hsTlower.setObjectName(\"hsTlower\")\n        self.verticalLayout_2.addWidget(self.hsTlower)\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_2.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n        self.label_3 = QtWidgets.QLabel(self.groupBox)\n        self.label_3.setMaximumSize(QtCore.QSize(16777215, 20))\n        font = QtGui.QFont()\n        font.setBold(False)\n        font.setWeight(50)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(\"label_3\")\n        self.horizontalLayout_2.addWidget(self.label_3)\n        self.lblTupper = QtWidgets.QLabel(self.groupBox)\n        self.lblTupper.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblTupper.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.lblTupper.setObjectName(\"lblTupper\")\n        self.horizontalLayout_2.addWidget(self.lblTupper)\n        self.verticalLayout_2.addLayout(self.horizontalLayout_2)\n        self.hsTupper = QtWidgets.QSlider(self.groupBox)\n        self.hsTupper.setMaximum(10)\n        self.hsTupper.setOrientation(QtCore.Qt.Horizontal)\n        self.hsTupper.setInvertedAppearance(True)\n        self.hsTupper.setInvertedControls(False)\n        self.hsTupper.setTickPosition(QtWidgets.QSlider.TicksBelow)\n        self.hsTupper.setTickInterval(1)\n        self.hsTupper.setObjectName(\"hsTupper\")\n        self.verticalLayout_2.addWidget(self.hsTupper)\n        self.verticalLayout.addWidget(self.groupBox)\n        self.btnFit = QtWidgets.QPushButton(self.centralwidget)\n        self.btnFit.setObjectName(\"btnFit\")\n        self.verticalLayout.addWidget(self.btnFit)\n        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)\n        self.groupBox_2.setEnabled(True)\n        self.groupBox_2.setObjectName(\"groupBox_2\")\n        self.gridLayout = QtWidgets.QGridLayout(self.groupBox_2)\n        self.gridLayout.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(\"gridLayout\")\n        self.lblC1l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC1l.setObjectName(\"lblC1l\")\n        self.gridLayout.addWidget(self.lblC1l, 0, 0, 1, 1)\n        self.lblBetaStarl = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBetaStarl.setObjectName(\"lblBetaStarl\")\n        self.gridLayout.addWidget(self.lblBetaStarl, 4, 0, 1, 1)\n        self.lblC2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC2l.setObjectName(\"lblC2l\")\n        self.gridLayout.addWidget(self.lblC2l, 1, 0, 1, 1)\n        self.lblC1 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC1.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblC1.setObjectName(\"lblC1\")\n        self.gridLayout.addWidget(self.lblC1, 0, 1, 1, 1)\n        self.lblDI1l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI1l.setObjectName(\"lblDI1l\")\n        self.gridLayout.addWidget(self.lblDI1l, 2, 0, 1, 1)\n        self.lblC2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC2.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblC2.setObjectName(\"lblC2\")\n        self.gridLayout.addWidget(self.lblC2, 1, 1, 1, 1)\n        self.lblDI2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI2l.setObjectName(\"lblDI2l\")\n        self.gridLayout.addWidget(self.lblDI2l, 3, 0, 1, 1)\n        self.lblBetaStar = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBetaStar.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblBetaStar.setObjectName(\"lblBetaStar\")\n        self.gridLayout.addWidget(self.lblBetaStar, 4, 1, 1, 1)\n        self.lblDI2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI2.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblDI2.setObjectName(\"lblDI2\")\n        self.gridLayout.addWidget(self.lblDI2, 3, 1, 1, 1)\n        self.lblDI1 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI1.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblDI1.setObjectName(\"lblDI1\")\n        self.gridLayout.addWidget(self.lblDI1, 2, 1, 1, 1)\n        self.lblBeta2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBeta2l.setObjectName(\"lblBeta2l\")\n        self.gridLayout.addWidget(self.lblBeta2l, 5, 0, 1, 1)\n        self.lblBeta2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBeta2.setObjectName(\"lblBeta2\")\n        self.gridLayout.addWidget(self.lblBeta2, 5, 1, 1, 1)\n        self.verticalLayout.addWidget(self.groupBox_2)\n        ManualFit.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(ManualFit)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 505, 26))\n        self.menubar.setObjectName(\"menubar\")\n        ManualFit.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(ManualFit)\n        self.statusbar.setObjectName(\"statusbar\")\n        ManualFit.setStatusBar(self.statusbar)\n\n        self.retranslateUi(ManualFit)\n        self.cbMethod.setCurrentIndex(-1)\n        QtCore.QMetaObject.connectSlotsByName(ManualFit)\n\n    def retranslateUi(self, ManualFit):\n        _translate = QtCore.QCoreApplication.translate\n        ManualFit.setWindowTitle(_translate(\"ManualFit\", \"Manual Kinetic ICS Fit\"))\n        self.label_5.setText(_translate(\"ManualFit\", \"Element\"))\n        self.lblZ0.setText(_translate(\"ManualFit\", \"<html><head/><body><p>Charge state Z<span style=\\\" vertical-align:sub;\\\">0</span></p></body></html>\"))\n        self.groupBox.setTitle(_translate(\"ManualFit\", \"Fit input parameters\"))\n        self.label_15.setText(_translate(\"ManualFit\", \"Fitting method\"))\n        self.label.setText(_translate(\"ManualFit\", \"Lower temperature cut-off\"))\n        self.lblTlower.setText(_translate(\"ManualFit\", \"0\"))\n        self.label_3.setText(_translate(\"ManualFit\", \"Upper temperature cut-off\"))\n        self.lblTupper.setText(_translate(\"ManualFit\", \"10000\"))\n        self.btnFit.setText(_translate(\"ManualFit\", \"FIT!\"))\n        self.groupBox_2.setTitle(_translate(\"ManualFit\", \"Fit output parameters\"))\n        self.lblC1l.setText(_translate(\"ManualFit\", \"C1\"))\n        self.lblBetaStarl.setText(_translate(\"ManualFit\", \"betaStar\"))\n        self.lblC2l.setText(_translate(\"ManualFit\", \"C2\"))\n        self.lblC1.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI1l.setText(_translate(\"ManualFit\", \"DI1\"))\n        self.lblC2.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI2l.setText(_translate(\"ManualFit\", \"DI2\"))\n        self.lblBetaStar.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI2.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI1.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblBeta2l.setText(_translate(\"ManualFit\", \"beta2\"))\n        self.lblBeta2.setText(_translate(\"ManualFit\", \"N/A\"))",
  "def setupUi(self, ManualFit):\n        ManualFit.setObjectName(\"ManualFit\")\n        ManualFit.resize(505, 745)\n        self.centralwidget = QtWidgets.QWidget(ManualFit)\n        self.centralwidget.setObjectName(\"centralwidget\")\n        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)\n        self.verticalLayout.setObjectName(\"verticalLayout\")\n        self.widget = QtWidgets.QWidget(self.centralwidget)\n        self.widget.setMinimumSize(QtCore.QSize(0, 120))\n        self.widget.setObjectName(\"widget\")\n        self.verticalLayout.addWidget(self.widget)\n        self.label_5 = QtWidgets.QLabel(self.centralwidget)\n        self.label_5.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.label_5.setObjectName(\"label_5\")\n        self.verticalLayout.addWidget(self.label_5)\n        self.cbElements = QtWidgets.QComboBox(self.centralwidget)\n        self.cbElements.setObjectName(\"cbElements\")\n        self.verticalLayout.addWidget(self.cbElements)\n        self.lblZ0 = QtWidgets.QLabel(self.centralwidget)\n        self.lblZ0.setEnabled(True)\n        self.lblZ0.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblZ0.setObjectName(\"lblZ0\")\n        self.verticalLayout.addWidget(self.lblZ0)\n        self.cbCS = QtWidgets.QComboBox(self.centralwidget)\n        self.cbCS.setEnabled(True)\n        self.cbCS.setObjectName(\"cbCS\")\n        self.verticalLayout.addWidget(self.cbCS)\n        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)\n        self.groupBox.setEnabled(True)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())\n        self.groupBox.setSizePolicy(sizePolicy)\n        self.groupBox.setObjectName(\"groupBox\")\n        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox)\n        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n        self.label_15 = QtWidgets.QLabel(self.groupBox)\n        self.label_15.setObjectName(\"label_15\")\n        self.verticalLayout_2.addWidget(self.label_15)\n        self.cbMethod = QtWidgets.QComboBox(self.groupBox)\n        self.cbMethod.setObjectName(\"cbMethod\")\n        self.verticalLayout_2.addWidget(self.cbMethod)\n        self.horizontalLayout = QtWidgets.QHBoxLayout()\n        self.horizontalLayout.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)\n        self.horizontalLayout.setSpacing(1)\n        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n        self.label = QtWidgets.QLabel(self.groupBox)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())\n        self.label.setSizePolicy(sizePolicy)\n        self.label.setMaximumSize(QtCore.QSize(16777215, 20))\n        font = QtGui.QFont()\n        font.setBold(False)\n        font.setWeight(50)\n        self.label.setFont(font)\n        self.label.setObjectName(\"label\")\n        self.horizontalLayout.addWidget(self.label)\n        self.lblTlower = QtWidgets.QLabel(self.groupBox)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.lblTlower.sizePolicy().hasHeightForWidth())\n        self.lblTlower.setSizePolicy(sizePolicy)\n        self.lblTlower.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblTlower.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.lblTlower.setObjectName(\"lblTlower\")\n        self.horizontalLayout.addWidget(self.lblTlower)\n        self.verticalLayout_2.addLayout(self.horizontalLayout)\n        self.hsTlower = QtWidgets.QSlider(self.groupBox)\n        self.hsTlower.setMaximum(10)\n        self.hsTlower.setOrientation(QtCore.Qt.Horizontal)\n        self.hsTlower.setInvertedAppearance(False)\n        self.hsTlower.setTickPosition(QtWidgets.QSlider.TicksBelow)\n        self.hsTlower.setTickInterval(1)\n        self.hsTlower.setObjectName(\"hsTlower\")\n        self.verticalLayout_2.addWidget(self.hsTlower)\n        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()\n        self.horizontalLayout_2.setSizeConstraint(QtWidgets.QLayout.SetMinimumSize)\n        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n        self.label_3 = QtWidgets.QLabel(self.groupBox)\n        self.label_3.setMaximumSize(QtCore.QSize(16777215, 20))\n        font = QtGui.QFont()\n        font.setBold(False)\n        font.setWeight(50)\n        self.label_3.setFont(font)\n        self.label_3.setObjectName(\"label_3\")\n        self.horizontalLayout_2.addWidget(self.label_3)\n        self.lblTupper = QtWidgets.QLabel(self.groupBox)\n        self.lblTupper.setMaximumSize(QtCore.QSize(16777215, 20))\n        self.lblTupper.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.lblTupper.setObjectName(\"lblTupper\")\n        self.horizontalLayout_2.addWidget(self.lblTupper)\n        self.verticalLayout_2.addLayout(self.horizontalLayout_2)\n        self.hsTupper = QtWidgets.QSlider(self.groupBox)\n        self.hsTupper.setMaximum(10)\n        self.hsTupper.setOrientation(QtCore.Qt.Horizontal)\n        self.hsTupper.setInvertedAppearance(True)\n        self.hsTupper.setInvertedControls(False)\n        self.hsTupper.setTickPosition(QtWidgets.QSlider.TicksBelow)\n        self.hsTupper.setTickInterval(1)\n        self.hsTupper.setObjectName(\"hsTupper\")\n        self.verticalLayout_2.addWidget(self.hsTupper)\n        self.verticalLayout.addWidget(self.groupBox)\n        self.btnFit = QtWidgets.QPushButton(self.centralwidget)\n        self.btnFit.setObjectName(\"btnFit\")\n        self.verticalLayout.addWidget(self.btnFit)\n        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)\n        self.groupBox_2.setEnabled(True)\n        self.groupBox_2.setObjectName(\"groupBox_2\")\n        self.gridLayout = QtWidgets.QGridLayout(self.groupBox_2)\n        self.gridLayout.setSizeConstraint(QtWidgets.QLayout.SetDefaultConstraint)\n        self.gridLayout.setVerticalSpacing(0)\n        self.gridLayout.setObjectName(\"gridLayout\")\n        self.lblC1l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC1l.setObjectName(\"lblC1l\")\n        self.gridLayout.addWidget(self.lblC1l, 0, 0, 1, 1)\n        self.lblBetaStarl = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBetaStarl.setObjectName(\"lblBetaStarl\")\n        self.gridLayout.addWidget(self.lblBetaStarl, 4, 0, 1, 1)\n        self.lblC2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC2l.setObjectName(\"lblC2l\")\n        self.gridLayout.addWidget(self.lblC2l, 1, 0, 1, 1)\n        self.lblC1 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC1.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblC1.setObjectName(\"lblC1\")\n        self.gridLayout.addWidget(self.lblC1, 0, 1, 1, 1)\n        self.lblDI1l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI1l.setObjectName(\"lblDI1l\")\n        self.gridLayout.addWidget(self.lblDI1l, 2, 0, 1, 1)\n        self.lblC2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblC2.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblC2.setObjectName(\"lblC2\")\n        self.gridLayout.addWidget(self.lblC2, 1, 1, 1, 1)\n        self.lblDI2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI2l.setObjectName(\"lblDI2l\")\n        self.gridLayout.addWidget(self.lblDI2l, 3, 0, 1, 1)\n        self.lblBetaStar = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBetaStar.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblBetaStar.setObjectName(\"lblBetaStar\")\n        self.gridLayout.addWidget(self.lblBetaStar, 4, 1, 1, 1)\n        self.lblDI2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI2.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblDI2.setObjectName(\"lblDI2\")\n        self.gridLayout.addWidget(self.lblDI2, 3, 1, 1, 1)\n        self.lblDI1 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblDI1.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByKeyboard|QtCore.Qt.TextSelectableByMouse)\n        self.lblDI1.setObjectName(\"lblDI1\")\n        self.gridLayout.addWidget(self.lblDI1, 2, 1, 1, 1)\n        self.lblBeta2l = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBeta2l.setObjectName(\"lblBeta2l\")\n        self.gridLayout.addWidget(self.lblBeta2l, 5, 0, 1, 1)\n        self.lblBeta2 = QtWidgets.QLabel(self.groupBox_2)\n        self.lblBeta2.setObjectName(\"lblBeta2\")\n        self.gridLayout.addWidget(self.lblBeta2, 5, 1, 1, 1)\n        self.verticalLayout.addWidget(self.groupBox_2)\n        ManualFit.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(ManualFit)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 505, 26))\n        self.menubar.setObjectName(\"menubar\")\n        ManualFit.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(ManualFit)\n        self.statusbar.setObjectName(\"statusbar\")\n        ManualFit.setStatusBar(self.statusbar)\n\n        self.retranslateUi(ManualFit)\n        self.cbMethod.setCurrentIndex(-1)\n        QtCore.QMetaObject.connectSlotsByName(ManualFit)",
  "def retranslateUi(self, ManualFit):\n        _translate = QtCore.QCoreApplication.translate\n        ManualFit.setWindowTitle(_translate(\"ManualFit\", \"Manual Kinetic ICS Fit\"))\n        self.label_5.setText(_translate(\"ManualFit\", \"Element\"))\n        self.lblZ0.setText(_translate(\"ManualFit\", \"<html><head/><body><p>Charge state Z<span style=\\\" vertical-align:sub;\\\">0</span></p></body></html>\"))\n        self.groupBox.setTitle(_translate(\"ManualFit\", \"Fit input parameters\"))\n        self.label_15.setText(_translate(\"ManualFit\", \"Fitting method\"))\n        self.label.setText(_translate(\"ManualFit\", \"Lower temperature cut-off\"))\n        self.lblTlower.setText(_translate(\"ManualFit\", \"0\"))\n        self.label_3.setText(_translate(\"ManualFit\", \"Upper temperature cut-off\"))\n        self.lblTupper.setText(_translate(\"ManualFit\", \"10000\"))\n        self.btnFit.setText(_translate(\"ManualFit\", \"FIT!\"))\n        self.groupBox_2.setTitle(_translate(\"ManualFit\", \"Fit output parameters\"))\n        self.lblC1l.setText(_translate(\"ManualFit\", \"C1\"))\n        self.lblBetaStarl.setText(_translate(\"ManualFit\", \"betaStar\"))\n        self.lblC2l.setText(_translate(\"ManualFit\", \"C2\"))\n        self.lblC1.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI1l.setText(_translate(\"ManualFit\", \"DI1\"))\n        self.lblC2.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI2l.setText(_translate(\"ManualFit\", \"DI2\"))\n        self.lblBetaStar.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI2.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblDI1.setText(_translate(\"ManualFit\", \"N/A\"))\n        self.lblBeta2l.setText(_translate(\"ManualFit\", \"beta2\"))\n        self.lblBeta2.setText(_translate(\"ManualFit\", \"N/A\"))"
]