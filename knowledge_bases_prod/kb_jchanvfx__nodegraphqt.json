[
  "class MyNode(Node):\n    \"\"\"\n    This is a example test node.\n    \"\"\"\n\n    # set a unique node identifier.\n    __identifier__ = 'com.chantasticvfx'\n\n    # set the initial default node name.\n    NODE_NAME = 'My Node'\n\n    def __init__(self):\n        super(MyNode, self).__init__()\n        self.set_color(81, 54, 88)\n        self.add_checkbox('cb_hello', '', 'Hello', True)\n        self.add_checkbox('cb_world', '', 'World', False)\n        self.add_input('in')\n        self.add_output('out')",
  "def __init__(self):\n        super(MyNode, self).__init__()\n        self.set_color(81, 54, 88)\n        self.add_checkbox('cb_hello', '', 'Hello', True)\n        self.add_checkbox('cb_world', '', 'World', False)\n        self.add_input('in')\n        self.add_output('out')",
  "class TabSearchCompleter(QtWidgets.QCompleter):\n    \"\"\"\n    QCompleter adapted from:\n    https://stackoverflow.com/questions/5129211/qcompleter-custom-completion-rules\n    \"\"\"\n\n    def __init__(self, nodes=None, parent=None):\n        super(TabSearchCompleter, self).__init__(nodes, parent)\n        self.setCompletionMode(self.PopupCompletion)\n        self.setCaseSensitivity(QtCore.Qt.CaseInsensitive)\n        self._local_completion_prefix = ''\n        self._using_orig_model = False\n        self._source_model = None\n        self._filter_model = None\n\n    def splitPath(self, path):\n        self._local_completion_prefix = path\n        self.updateModel()\n        if self._filter_model.rowCount() == 0:\n            self._using_orig_model = False\n            self._filter_model.setSourceModel(QtCore.QStringListModel([path]))\n            return [path]\n        return []\n\n    def updateModel(self):\n        if not self._using_orig_model:\n            self._filter_model.setSourceModel(self._source_model)\n\n        pattern = QtCore.QRegExp(self._local_completion_prefix,\n                                 QtCore.Qt.CaseInsensitive,\n                                 QtCore.QRegExp.FixedString)\n        self._filter_model.setFilterRegExp(pattern)\n\n    def setModel(self, model):\n        self._source_model = model\n        self._filter_model = QtCore.QSortFilterProxyModel(self)\n        self._filter_model.setSourceModel(self._source_model)\n        super(TabSearchCompleter, self).setModel(self._filter_model)\n        self.popup().setStyleSheet(STYLE_TABSEARCH_LIST)\n        self._using_orig_model = True",
  "class TabSearchWidget(QtWidgets.QLineEdit):\n\n    search_submitted = QtCore.Signal(str)\n\n    def __init__(self, parent=None, node_dict=None):\n        super(TabSearchWidget, self).__init__(parent)\n        self.setAttribute(QtCore.Qt.WA_MacShowFocusRect, 0)\n        self.setStyleSheet(STYLE_TABSEARCH)\n        self.setMinimumSize(200, 22)\n        self.setTextMargins(2, 0, 2, 0)\n        self.hide()\n\n        self._node_dict = node_dict or {}\n\n        node_names = sorted(self._node_dict.keys())\n        self._model = QtCore.QStringListModel(node_names, self)\n\n        self._completer = TabSearchCompleter()\n        self._completer.setModel(self._model)\n        self.setCompleter(self._completer)\n\n        self.returnPressed.connect(self._on_search_submitted)\n\n    def _on_search_submitted(self):\n        text = self.text()\n        node_type = self._node_dict.get(text)\n        if node_type:\n            self.search_submitted.emit(node_type)\n        self.close()\n        self.parentWidget().clearFocus()\n\n    def showEvent(self, event):\n        super(TabSearchWidget, self).showEvent(event)\n        self.setSelection(0, len(self.text()))\n        self.setFocus()\n\n    def set_nodes(self, node_dict=None):\n        self._node_dict = node_dict or {}\n        node_names = sorted(self._node_dict.keys())\n        self._model.setStringList(node_names)\n        self._completer.setModel(self._model)",
  "def __init__(self, nodes=None, parent=None):\n        super(TabSearchCompleter, self).__init__(nodes, parent)\n        self.setCompletionMode(self.PopupCompletion)\n        self.setCaseSensitivity(QtCore.Qt.CaseInsensitive)\n        self._local_completion_prefix = ''\n        self._using_orig_model = False\n        self._source_model = None\n        self._filter_model = None",
  "def splitPath(self, path):\n        self._local_completion_prefix = path\n        self.updateModel()\n        if self._filter_model.rowCount() == 0:\n            self._using_orig_model = False\n            self._filter_model.setSourceModel(QtCore.QStringListModel([path]))\n            return [path]\n        return []",
  "def updateModel(self):\n        if not self._using_orig_model:\n            self._filter_model.setSourceModel(self._source_model)\n\n        pattern = QtCore.QRegExp(self._local_completion_prefix,\n                                 QtCore.Qt.CaseInsensitive,\n                                 QtCore.QRegExp.FixedString)\n        self._filter_model.setFilterRegExp(pattern)",
  "def setModel(self, model):\n        self._source_model = model\n        self._filter_model = QtCore.QSortFilterProxyModel(self)\n        self._filter_model.setSourceModel(self._source_model)\n        super(TabSearchCompleter, self).setModel(self._filter_model)\n        self.popup().setStyleSheet(STYLE_TABSEARCH_LIST)\n        self._using_orig_model = True",
  "def __init__(self, parent=None, node_dict=None):\n        super(TabSearchWidget, self).__init__(parent)\n        self.setAttribute(QtCore.Qt.WA_MacShowFocusRect, 0)\n        self.setStyleSheet(STYLE_TABSEARCH)\n        self.setMinimumSize(200, 22)\n        self.setTextMargins(2, 0, 2, 0)\n        self.hide()\n\n        self._node_dict = node_dict or {}\n\n        node_names = sorted(self._node_dict.keys())\n        self._model = QtCore.QStringListModel(node_names, self)\n\n        self._completer = TabSearchCompleter()\n        self._completer.setModel(self._model)\n        self.setCompleter(self._completer)\n\n        self.returnPressed.connect(self._on_search_submitted)",
  "def _on_search_submitted(self):\n        text = self.text()\n        node_type = self._node_dict.get(text)\n        if node_type:\n            self.search_submitted.emit(node_type)\n        self.close()\n        self.parentWidget().clearFocus()",
  "def showEvent(self, event):\n        super(TabSearchWidget, self).showEvent(event)\n        self.setSelection(0, len(self.text()))\n        self.setFocus()",
  "def set_nodes(self, node_dict=None):\n        self._node_dict = node_dict or {}\n        node_names = sorted(self._node_dict.keys())\n        self._model.setStringList(node_names)\n        self._completer.setModel(self._model)",
  "class _NodeGroubBox(QtWidgets.QGroupBox):\n\n    def __init__(self, label, parent=None):\n        super(_NodeGroubBox, self).__init__(parent)\n        margin = (0, 0, 0, 0)\n        padding_top = '14px'\n        if label == '':\n            margin = (0, 2, 0, 0)\n            padding_top = '2px'\n        style = STYLE_QGROUPBOX.replace('$PADDING_TOP', padding_top)\n        self.setMaximumSize(120, 50)\n        self.setTitle(label)\n        self.setStyleSheet(style)\n\n        self._layout = QtWidgets.QVBoxLayout(self)\n        self._layout.setContentsMargins(*margin)\n        self._layout.setSpacing(1)\n\n    def add_node_widget(self, widget):\n        self._layout.addWidget(widget)",
  "class NodeBaseWidget(QtWidgets.QGraphicsProxyWidget):\n    \"\"\"\n    Base Node Widget.\n    \"\"\"\n\n    value_changed = QtCore.Signal(str, object)\n\n    def __init__(self, parent=None, name='widget', label=''):\n        super(NodeBaseWidget, self).__init__(parent)\n        self.setZValue(Z_VAL_NODE_WIDGET)\n        self._name = name\n        self._label = label\n\n    def _value_changed(self):\n        self.value_changed.emit(self.name, self.value)\n\n    def setToolTip(self, tooltip):\n        tooltip = tooltip.replace('\\n', '<br/>')\n        tooltip = '<b>{}</b><br/>{}'.format(self.name, tooltip)\n        super(NodeBaseWidget, self).setToolTip(tooltip)\n\n    @property\n    def widget(self):\n        raise NotImplementedError\n\n    @property\n    def value(self):\n        raise NotImplementedError\n\n    @value.setter\n    def value(self, text):\n        raise NotImplementedError\n\n    @property\n    def label(self):\n        return self._label\n\n    @label.setter\n    def label(self, label):\n        self._label = label\n\n    @property\n    def type(self):\n        return str(self.__class__.__name__)\n\n    @property\n    def node(self):\n        self.parentItem()\n\n    @property\n    def name(self):\n        return self._name",
  "class NodeComboBox(NodeBaseWidget):\n    \"\"\"\n    ComboBox Node Widget.\n    \"\"\"\n\n    def __init__(self, parent=None, name='', label='', items=None):\n        super(NodeComboBox, self).__init__(parent, name, label)\n        self.setZValue(Z_VAL_NODE_WIDGET + 1)\n        self._combo = QtWidgets.QComboBox()\n        self._combo.setStyleSheet(STYLE_QCOMBOBOX)\n        self._combo.setMinimumHeight(24)\n        self._combo.activated.connect(self._value_changed)\n        list_view = QtWidgets.QListView(self._combo)\n        list_view.setStyleSheet(STYLE_QLISTVIEW)\n        self._combo.setView(list_view)\n        self._combo.clearFocus()\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._combo)\n        self.setWidget(group)\n        self.add_items(items)\n\n    @property\n    def type(self):\n        return 'ComboNodeWidget'\n\n    @property\n    def widget(self):\n        return self._combo\n\n    @property\n    def value(self):\n        return str(self._combo.currentText())\n\n    @value.setter\n    def value(self, text=''):\n        index = self._combo.findText(text, QtCore.Qt.MatchExactly)\n        self._combo.setCurrentIndex(index)\n\n    def add_item(self, item):\n        self._combo.addItem(item)\n\n    def add_items(self, items=None):\n        if items:\n            self._combo.addItems(items)\n\n    def all_items(self):\n        return [self._combo.itemText(i) for i in range(self._combo.count)]\n\n    def sort_items(self):\n        items = sorted(self.all_items())\n        self._combo.clear()\n        self._combo.addItems(items)\n\n    def clear(self):\n        self._combo.clear()",
  "class NodeLineEdit(NodeBaseWidget):\n    \"\"\"\n    LineEdit Node Widget.\n    \"\"\"\n\n    def __init__(self, parent=None, name='', label='', text=''):\n        super(NodeLineEdit, self).__init__(parent, name, label)\n        self._ledit = QtWidgets.QLineEdit()\n        self._ledit.setStyleSheet(STYLE_QLINEEDIT)\n        self._ledit.setAlignment(QtCore.Qt.AlignCenter)\n        self._ledit.textChanged.connect(self._value_changed)\n        self._ledit.clearFocus()\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._ledit)\n        self.setWidget(group)\n        self.text = text\n\n    @property\n    def type(self):\n        return 'LineEditNodeWidget'\n\n    @property\n    def widget(self):\n        return self._ledit\n\n    @property\n    def value(self):\n        return str(self._ledit.text())\n\n    @value.setter\n    def value(self, text=''):\n        self._ledit.setText(text)",
  "class NodeCheckBox(NodeBaseWidget):\n    \"\"\"\n    CheckBox Node Widget.\n    \"\"\"\n\n    def __init__(self, parent=None, name='', label='', text='', state=False):\n        super(NodeCheckBox, self).__init__(parent, name, label)\n        self._cbox = QtWidgets.QCheckBox(text)\n        self._cbox.setChecked(state)\n        self._cbox.setMinimumWidth(80)\n        self._cbox.setStyleSheet(STYLE_QCHECKBOX)\n        font = self._cbox.font()\n        font.setPointSize(11)\n        self._cbox.setFont(font)\n        self._cbox.stateChanged.connect(self._value_changed)\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._cbox)\n        self.setWidget(group)\n        self.text = text\n        self.state = state\n\n    @property\n    def type(self):\n        return 'CheckboxNodeWidget'\n\n    @property\n    def widget(self):\n        return self._cbox\n\n    @property\n    def value(self):\n        return self._cbox.isChecked()\n\n    @value.setter\n    def value(self, state=False):\n        self._cbox.setChecked(state)",
  "def __init__(self, label, parent=None):\n        super(_NodeGroubBox, self).__init__(parent)\n        margin = (0, 0, 0, 0)\n        padding_top = '14px'\n        if label == '':\n            margin = (0, 2, 0, 0)\n            padding_top = '2px'\n        style = STYLE_QGROUPBOX.replace('$PADDING_TOP', padding_top)\n        self.setMaximumSize(120, 50)\n        self.setTitle(label)\n        self.setStyleSheet(style)\n\n        self._layout = QtWidgets.QVBoxLayout(self)\n        self._layout.setContentsMargins(*margin)\n        self._layout.setSpacing(1)",
  "def add_node_widget(self, widget):\n        self._layout.addWidget(widget)",
  "def __init__(self, parent=None, name='widget', label=''):\n        super(NodeBaseWidget, self).__init__(parent)\n        self.setZValue(Z_VAL_NODE_WIDGET)\n        self._name = name\n        self._label = label",
  "def _value_changed(self):\n        self.value_changed.emit(self.name, self.value)",
  "def setToolTip(self, tooltip):\n        tooltip = tooltip.replace('\\n', '<br/>')\n        tooltip = '<b>{}</b><br/>{}'.format(self.name, tooltip)\n        super(NodeBaseWidget, self).setToolTip(tooltip)",
  "def widget(self):\n        raise NotImplementedError",
  "def value(self):\n        raise NotImplementedError",
  "def value(self, text):\n        raise NotImplementedError",
  "def label(self):\n        return self._label",
  "def label(self, label):\n        self._label = label",
  "def type(self):\n        return str(self.__class__.__name__)",
  "def node(self):\n        self.parentItem()",
  "def name(self):\n        return self._name",
  "def __init__(self, parent=None, name='', label='', items=None):\n        super(NodeComboBox, self).__init__(parent, name, label)\n        self.setZValue(Z_VAL_NODE_WIDGET + 1)\n        self._combo = QtWidgets.QComboBox()\n        self._combo.setStyleSheet(STYLE_QCOMBOBOX)\n        self._combo.setMinimumHeight(24)\n        self._combo.activated.connect(self._value_changed)\n        list_view = QtWidgets.QListView(self._combo)\n        list_view.setStyleSheet(STYLE_QLISTVIEW)\n        self._combo.setView(list_view)\n        self._combo.clearFocus()\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._combo)\n        self.setWidget(group)\n        self.add_items(items)",
  "def type(self):\n        return 'ComboNodeWidget'",
  "def widget(self):\n        return self._combo",
  "def value(self):\n        return str(self._combo.currentText())",
  "def value(self, text=''):\n        index = self._combo.findText(text, QtCore.Qt.MatchExactly)\n        self._combo.setCurrentIndex(index)",
  "def add_item(self, item):\n        self._combo.addItem(item)",
  "def add_items(self, items=None):\n        if items:\n            self._combo.addItems(items)",
  "def all_items(self):\n        return [self._combo.itemText(i) for i in range(self._combo.count)]",
  "def sort_items(self):\n        items = sorted(self.all_items())\n        self._combo.clear()\n        self._combo.addItems(items)",
  "def clear(self):\n        self._combo.clear()",
  "def __init__(self, parent=None, name='', label='', text=''):\n        super(NodeLineEdit, self).__init__(parent, name, label)\n        self._ledit = QtWidgets.QLineEdit()\n        self._ledit.setStyleSheet(STYLE_QLINEEDIT)\n        self._ledit.setAlignment(QtCore.Qt.AlignCenter)\n        self._ledit.textChanged.connect(self._value_changed)\n        self._ledit.clearFocus()\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._ledit)\n        self.setWidget(group)\n        self.text = text",
  "def type(self):\n        return 'LineEditNodeWidget'",
  "def widget(self):\n        return self._ledit",
  "def value(self):\n        return str(self._ledit.text())",
  "def value(self, text=''):\n        self._ledit.setText(text)",
  "def __init__(self, parent=None, name='', label='', text='', state=False):\n        super(NodeCheckBox, self).__init__(parent, name, label)\n        self._cbox = QtWidgets.QCheckBox(text)\n        self._cbox.setChecked(state)\n        self._cbox.setMinimumWidth(80)\n        self._cbox.setStyleSheet(STYLE_QCHECKBOX)\n        font = self._cbox.font()\n        font.setPointSize(11)\n        self._cbox.setFont(font)\n        self._cbox.stateChanged.connect(self._value_changed)\n        group = _NodeGroubBox(label)\n        group.add_node_widget(self._cbox)\n        self.setWidget(group)\n        self.text = text\n        self.state = state",
  "def type(self):\n        return 'CheckboxNodeWidget'",
  "def widget(self):\n        return self._cbox",
  "def value(self):\n        return self._cbox.isChecked()",
  "def value(self, state=False):\n        self._cbox.setChecked(state)",
  "class ContextMenu(object):\n\n    def __init__(self, view, menu):\n        self.__view = view\n        self.__menu = menu\n\n    @property\n    def _menu_obj(self):\n        return self.__menu\n\n    def get_menu(self, name):\n        ctx_menu = self.__view.context_menu()\n        root_menu = ctx_menu._menu_obj\n        for action in root_menu.actions():\n            if action.text() != name:\n                continue\n            menu = action.menu()\n            return ContextMenu(self.__view, menu)\n\n    def add_action(self, action):\n        action.setShortcutVisibleInContextMenu(True)\n        self.__menu.addAction(action)\n\n    def add_menu(self, name):\n        menu = QtWidgets.QMenu(None, title=name)\n        menu.setStyleSheet(STYLE_QMENU)\n        self.__menu.addMenu(menu)\n        return ContextMenu(self.__view, menu)\n\n    def add_command(self, name, func=None, shortcut=None):\n        action = QtWidgets.QAction(name, self.__view)\n        action.setShortcutVisibleInContextMenu(True)\n        if shortcut:\n            action.setShortcut(shortcut)\n        if func:\n            action.triggered.connect(func)\n        self.__menu.addAction(action, shortcut=shortcut)\n\n    def add_separator(self):\n        self.__menu.addSeparator()",
  "class NodeViewer(QtWidgets.QGraphicsView):\n\n    moved_nodes = QtCore.Signal(dict)\n    search_triggered = QtCore.Signal(str, tuple)\n    connection_changed = QtCore.Signal(list, list)\n    node_selected = QtCore.Signal(str)\n\n    def __init__(self, parent=None):\n        super(NodeViewer, self).__init__(parent)\n        scene_area = 8000.0\n        scene_pos = (scene_area / 2) * -1\n        self.setScene(NodeScene(self))\n        self.setSceneRect(scene_pos, scene_pos, scene_area, scene_area)\n        self.setRenderHint(QtGui.QPainter.Antialiasing, True)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)\n        self._pipe_layout = PIPE_LAYOUT_CURVED\n        self._live_pipe = None\n        self._detached_port = None\n        self._start_port = None\n        self._origin_pos = None\n        self._previous_pos = QtCore.QPoint(self.width(), self.height())\n        self._prev_selection = []\n        self._node_positions = {}\n        self._rubber_band = QtWidgets.QRubberBand(\n            QtWidgets.QRubberBand.Rectangle, self\n        )\n        self._undo_stack = QtWidgets.QUndoStack(self)\n        self._context_menu = QtWidgets.QMenu('nodes', self)\n        self._context_menu.setStyleSheet(STYLE_QMENU)\n        self._search_widget = TabSearchWidget(self)\n        self._search_widget.search_submitted.connect(self._on_search_submitted)\n\n        # workaround fix on OSX shortcuts from the non-native menu actions\n        # don't seem to trigger so we create a dummy menu bar.\n        if platform == 'darwin':\n            menu_bar = QtWidgets.QMenuBar(self)\n            menu_bar.setNativeMenuBar(False)\n            menu_bar.resize(0, 0)\n            menu_bar.addMenu(self._context_menu)\n\n        self.acyclic = True\n        self.LMB_state = False\n        self.RMB_state = False\n        self.MMB_state = False\n\n    def __str__(self):\n        return '{}.{}()'.format(\n            self.__module__, self.__class__.__name__)\n\n    def __repr__(self):\n        return '{}.{}()'.format(\n            self.__module__, self.__class__.__name__)\n\n    # --- private methods ---\n\n    def _set_viewer_zoom(self, value):\n        if value == 0.0:\n            return\n        scale = 0.9 if value < 0.0 else 1.1\n        zoom = self.get_zoom()\n        if ZOOM_MIN >= zoom:\n            if scale == 0.9:\n                return\n        if ZOOM_MAX <= zoom:\n            if scale == 1.1:\n                return\n        self.scale(scale, scale)\n\n    def _set_viewer_pan(self, pos_x, pos_y):\n        scroll_x = self.horizontalScrollBar()\n        scroll_y = self.verticalScrollBar()\n        scroll_x.setValue(scroll_x.value() - pos_x)\n        scroll_y.setValue(scroll_y.value() - pos_y)\n\n    def _combined_rect(self, nodes):\n        group = self.scene().createItemGroup(nodes)\n        rect = group.boundingRect()\n        self.scene().destroyItemGroup(group)\n        return rect\n\n    def _items_near(self, pos, item_type=None, width=20, height=20):\n        x, y = pos.x() - width, pos.y() - height\n        rect = QtCore.QRect(x, y, width, height)\n        items = []\n        for item in self.scene().items(rect):\n            if not item_type or isinstance(item, item_type):\n                items.append(item)\n        return items\n\n    def _on_search_submitted(self, node_type):\n        pos = self.mapToScene(self._previous_pos)\n        self.search_triggered.emit(node_type, (pos.x(), pos.y()))\n\n    # --- re-implemented methods ---\n\n    def resizeEvent(self, event):\n        super(NodeViewer, self).resizeEvent(event)\n\n    def contextMenuEvent(self, event):\n        self.RMB_state = False\n        self._context_menu.exec_(event.globalPos())\n\n    def mousePressEvent(self, event):\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if event.button() == QtCore.Qt.LeftButton:\n            self.LMB_state = True\n        elif event.button() == QtCore.Qt.RightButton:\n            self.RMB_state = True\n        elif event.button() == QtCore.Qt.MiddleButton:\n            self.MMB_state = True\n        self._origin_pos = event.pos()\n        self._previous_pos = event.pos()\n        self._prev_selection = self.selected_nodes()\n\n        # close tab search\n        if self._search_widget.isVisible():\n            self.tab_search_toggle()\n\n        if alt_modifier:\n            return\n\n        items = self._items_near(self.mapToScene(event.pos()), None, 20, 20)\n        nodes = [i for i in items if isinstance(i, AbstractNodeItem)]\n\n        # toggle extend node selection.\n        if shift_modifier:\n            for node in nodes:\n                node.selected = not node.selected\n\n        # update the recorded node positions.\n        self._node_positions.update({n: n.pos for n in self.selected_nodes()})\n\n        # show selection selection marquee\n        if self.LMB_state and not items:\n            rect = QtCore.QRect(self._previous_pos, QtCore.QSize())\n            rect = rect.normalized()\n            map_rect = self.mapToScene(rect).boundingRect()\n            self.scene().update(map_rect)\n            self._rubber_band.setGeometry(rect)\n            self._rubber_band.show()\n\n        if not shift_modifier:\n            super(NodeViewer, self).mousePressEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if event.button() == QtCore.Qt.LeftButton:\n            self.LMB_state = False\n        elif event.button() == QtCore.Qt.RightButton:\n            self.RMB_state = False\n        elif event.button() == QtCore.Qt.MiddleButton:\n            self.MMB_state = False\n\n        # hide selection marquee\n        if self._rubber_band.isVisible():\n            rect = self._rubber_band.rect()\n            map_rect = self.mapToScene(rect).boundingRect()\n            self._rubber_band.hide()\n            self.scene().update(map_rect)\n\n        # find position changed nodes and emit signal.\n        moved_nodes = {\n            n: pos for n, pos in self._node_positions.items() if n.pos != pos}\n        if moved_nodes:\n            self.moved_nodes.emit(moved_nodes)\n\n        # reset recorded positions.\n        self._node_positions = {}\n\n        super(NodeViewer, self).mouseReleaseEvent(event)\n\n    def mouseMoveEvent(self, event):\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if self.MMB_state or (self.LMB_state and alt_modifier):\n            pos_x = (event.x() - self._previous_pos.x())\n            pos_y = (event.y() - self._previous_pos.y())\n            self._set_viewer_pan(pos_x, pos_y)\n        elif self.RMB_state:\n            pos_x = (event.x() - self._previous_pos.x())\n            zoom = 0.1 if pos_x > 0 else -0.1\n            self._set_viewer_zoom(zoom)\n\n        if self.LMB_state and self._rubber_band.isVisible():\n            rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()\n            map_rect = self.mapToScene(rect).boundingRect()\n            path = QtGui.QPainterPath()\n            path.addRect(map_rect)\n            self._rubber_band.setGeometry(rect)\n            self.scene().setSelectionArea(path, QtCore.Qt.IntersectsItemShape)\n            self.scene().update(map_rect)\n\n            if shift_modifier and self._prev_selection:\n                for node in self._prev_selection:\n                    if node not in self.selected_nodes():\n                        node.selected = True\n\n        self._previous_pos = event.pos()\n        super(NodeViewer, self).mouseMoveEvent(event)\n\n    def wheelEvent(self, event):\n        adjust = (event.delta() / 120) * 0.1\n        self._set_viewer_zoom(adjust)\n\n    # def dropEvent(self, event):\n    #     if event.mimeData().hasFormat('component/name'):\n    #         drop_str = str(event.mimeData().data('component/name'))\n    #         drop_pos = event.pos()\n\n    # def dragEnterEvent(self, event):\n    #     if event.mimeData().hasFormat('component/name'):\n    #         event.accept()\n\n    # def dragMoveEvent(self, event):\n    #     if event.mimeData().hasFormat('component/name'):\n    #         event.accept()\n\n    # --- viewer methods ---\n\n    def start_live_connection(self, selected_port):\n        \"\"\"\n        create new pipe for the connection.\n        \"\"\"\n        if not selected_port:\n            return\n        self._start_port = selected_port\n        self._live_pipe = Pipe()\n        self._live_pipe.activate()\n        self._live_pipe.style = PIPE_STYLE_DASHED\n        if self._start_port.type == IN_PORT:\n            self._live_pipe.input_port = self._start_port\n        elif self._start_port == OUT_PORT:\n            self._live_pipe.output_port = self._start_port\n        self.scene().addItem(self._live_pipe)\n\n    def end_live_connection(self):\n        \"\"\"\n        delete live connection pipe and reset start port.\n        \"\"\"\n        if self._live_pipe:\n            self._live_pipe.delete()\n            self._live_pipe = None\n        self._start_port = None\n\n    def establish_connection(self, start_port, end_port):\n        \"\"\"\n        establish a new pipe connection.\n        \"\"\"\n        pipe = Pipe()\n        self.scene().addItem(pipe)\n        pipe.set_connections(start_port, end_port)\n        pipe.draw_path(pipe.input_port, pipe.output_port)\n\n    def acyclic_check(self, start_port, end_port):\n        \"\"\"\n        validate the connection doesn't loop itself and\n        returns True if port connection is valid.\n        \"\"\"\n        start_node = start_port.node\n        check_nodes = [end_port.node]\n        io_types = {IN_PORT: 'outputs', OUT_PORT: 'inputs'}\n        while check_nodes:\n            check_node = check_nodes.pop(0)\n            for check_port in getattr(check_node, io_types[end_port.port_type]):\n                if check_port.connected_ports:\n                    for port in check_port.connected_ports:\n                        if port.node != start_node:\n                            check_nodes.append(port.node)\n                        else:\n                            return False\n        return True\n\n    def sceneMouseMoveEvent(self, event):\n        \"\"\"\n        triggered mouse move event for the scene.\n         - redraw the connection pipe.\n\n        Args:\n            event (QtWidgets.QGraphicsSceneMouseEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        if not self._live_pipe:\n            return\n        if not self._start_port:\n            return\n        pos = event.scenePos()\n        self._live_pipe.draw_path(self._start_port, None, pos)\n\n    def sceneMousePressEvent(self, event):\n        \"\"\"\n        triggered mouse press event for the scene (takes priority over viewer).\n         - detect selected pipe and start connection.\n         - remap Shift and Ctrl modifier.\n\n        Args:\n            event (QtWidgets.QGraphicsScenePressEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        ctrl_modifier = event.modifiers() == QtCore.Qt.ControlModifier\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if shift_modifier:\n            event.setModifiers(QtCore.Qt.ControlModifier)\n        elif ctrl_modifier:\n            event.setModifiers(QtCore.Qt.ShiftModifier)\n\n        if not alt_modifier:\n            pos = event.scenePos()\n            port_items = self._items_near(pos, PortItem, 5, 5)\n            if port_items:\n                port = port_items[0]\n                if not port.multi_connection and port.connected_ports:\n                    self._detached_port = port.connected_ports[0]\n                self.start_live_connection(port)\n                if not port.multi_connection:\n                    [p.delete() for p in port.connected_pipes]\n                return\n\n            node_items = self._items_near(pos, AbstractNodeItem, 3, 3)\n            if node_items:\n                node = node_items[0]\n\n                # record the node positions at selection time.\n                for n in node_items:\n                    self._node_positions[n] = n.pos\n\n                # emit selected node id with LMB.\n                if event.button() == QtCore.Qt.LeftButton:\n                    self.node_selected.emit(node.id)\n\n                if not isinstance(node, BackdropNodeItem):\n                    return\n\n            pipe_items = self._items_near(pos, Pipe, 3, 3)\n            if pipe_items:\n                pipe = pipe_items[0]\n                attr = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n                from_port = pipe.port_from_pos(pos, True)\n                to_port = getattr(pipe, attr[from_port.port_type])\n                if not from_port.multi_connection and from_port.connected_ports:\n                    self._detached_port = from_port.connected_ports[0]\n                elif not to_port.multi_connection:\n                    self._detached_port = to_port\n\n                self.start_live_connection(from_port)\n                self._live_pipe.draw_path(self._start_port, None, pos)\n                pipe.delete()\n\n    def sceneMouseReleaseEvent(self, event):\n        \"\"\"\n        triggered mouse release event for the scene.\n         - verify to make a the connection Pipe.\n        \n        Args:\n            event (QtWidgets.QGraphicsSceneMouseEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        if event.modifiers() == QtCore.Qt.ShiftModifier:\n            event.setModifiers(QtCore.Qt.ControlModifier)\n\n        if not self._live_pipe:\n            return\n\n        # find the end port.\n        end_port = None\n        for item in self.scene().items(event.scenePos()):\n            if isinstance(item, PortItem):\n                end_port = item\n                break\n\n        connected = []\n        disconnected = []\n\n        # if port disconnected from existing pipe.\n        if end_port is None:\n            if self._detached_port:\n                disconnected.append((self._start_port, self._detached_port))\n                self.connection_changed.emit(disconnected, connected)\n\n            self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # restore connection check.\n        restore_connection = any([\n            # if same port type.\n            end_port.port_type == self._start_port.port_type,\n            # if connection to itself.\n            end_port.node == self._start_port.node,\n            # if end port is the start port.\n            end_port == self._start_port,\n            # if detached port is the end port.\n            self._detached_port == end_port\n        ])\n        if restore_connection:\n            if self._detached_port:\n                to_port = self._detached_port or end_port\n                self.establish_connection(self._start_port, to_port)\n                self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # register as disconnected if not acyclic.\n        if self.acyclic and not self.acyclic_check(self._start_port, end_port):\n            if self._detached_port:\n                disconnected.append((self._start_port, self._detached_port))\n\n            self.connection_changed.emit(disconnected, connected)\n\n            self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # make connection.\n        if not end_port.multi_connection and end_port.connected_ports:\n            dettached_end = end_port.connected_ports[0]\n            disconnected.append((end_port, dettached_end))\n\n        if self._detached_port:\n            disconnected.append((self._start_port, self._detached_port))\n\n        connected.append((self._start_port, end_port))\n\n        self.connection_changed.emit(disconnected, connected)\n\n        self._detached_port = None\n        self.end_live_connection()\n\n    def tab_search_set_nodes(self, nodes):\n        self._search_widget.set_nodes(nodes)\n\n    def tab_search_toggle(self):\n        pos = self._previous_pos\n        state = not self._search_widget.isVisible()\n        if state:\n            rect = self._search_widget.rect()\n            new_pos = QtCore.QPoint(pos.x() - rect.width() / 2,\n                                    pos.y() - rect.height() / 2)\n            self._search_widget.move(new_pos)\n            self._search_widget.setVisible(state)\n            rect = self.mapToScene(rect).boundingRect()\n            self.scene().update(rect)\n        else:\n            self._search_widget.setVisible(state)\n            self.clearFocus()\n\n    def context_menu(self):\n        return ContextMenu(self, self._context_menu)\n\n    def question_dialog(self, title, text):\n        dlg = QtWidgets.QMessageBox.question(\n            self, title, text,\n            QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)\n        return dlg == QtWidgets.QMessageBox.Yes\n\n    def message_dialog(self, text, title='node graph'):\n        QtWidgets.QMessageBox.information(\n            self, title, text, QtWidgets.QMessageBox.Ok)\n\n    def all_pipes(self):\n        pipes = []\n        for item in self.scene().items():\n            if isinstance(item, Pipe):\n                pipes.append(item)\n        return pipes\n\n    def all_nodes(self):\n        nodes = []\n        for item in self.scene().items():\n            if isinstance(item, AbstractNodeItem):\n                nodes.append(item)\n        return nodes\n\n    def selected_nodes(self):\n        nodes = []\n        for item in self.scene().selectedItems():\n            if isinstance(item, AbstractNodeItem):\n                nodes.append(item)\n        return nodes\n\n    def add_node(self, node, pos=None):\n        pos = pos or (self._previous_pos.x(), self._previous_pos.y())\n        node.pre_init(self, pos)\n        self.scene().addItem(node)\n        node.post_init(self, pos)\n\n    def remove_node(self, node):\n        if isinstance(node, AbstractNodeItem):\n            node.delete()\n\n    def move_nodes(self, nodes, pos=None, offset=None):\n        group = self.scene().createItemGroup(nodes)\n        group_rect = group.boundingRect()\n        if pos:\n            x, y = pos\n        else:\n            pos = self.mapToScene(self._previous_pos)\n            x = pos.x() - group_rect.center().x()\n            y = pos.y() - group_rect.center().y()\n        if offset:\n            x += offset[0]\n            y += offset[1]\n        group.setPos(x, y)\n        self.scene().destroyItemGroup(group)\n\n    def get_pipes_from_nodes(self, nodes=None):\n        nodes = nodes or self.selected_nodes()\n        if not nodes:\n            return\n        pipes = []\n        for node in nodes:\n            n_inputs = node.inputs if hasattr(node, 'inputs') else []\n            n_outputs = node.outputs if hasattr(node, 'outputs') else []\n\n            for port in n_inputs:\n                for pipe in port.connected_pipes:\n                    connected_node = pipe.output_port.node\n                    if connected_node in nodes:\n                        pipes.append(pipe)\n            for port in n_outputs:\n                for pipe in port.connected_pipes:\n                    connected_node = pipe.input_port.node\n                    if connected_node in nodes:\n                        pipes.append(pipe)\n        return pipes\n\n    def center_selection(self, nodes=None):\n        if not nodes:\n            if self.selected_nodes():\n                nodes = self.selected_nodes()\n            elif self.all_nodes():\n                nodes = self.all_nodes()\n        if len(nodes) == 1:\n            self.centerOn(nodes[0])\n        else:\n            rect = self._combined_rect(nodes)\n            self.centerOn(rect.center().x(), rect.center().y())\n\n    def get_pipe_layout(self):\n        return self._pipe_layout\n\n    def set_pipe_layout(self, layout=''):\n        layout_types = {\n            'curved': PIPE_LAYOUT_CURVED,\n            'straight': PIPE_LAYOUT_STRAIGHT\n        }\n        self._pipe_layout = layout_types.get(layout, 'curved')\n        for pipe in self.all_pipes():\n            pipe.draw_path(pipe.input_port, pipe.output_port)\n\n    def reset_zoom(self):\n        self.scale(1.0, 1.0)\n        self.resetMatrix()\n\n    def get_zoom(self):\n        transform = self.transform()\n        cur_scale = (transform.m11(), transform.m22())\n        return float('{:0.2f}'.format(cur_scale[0] - 1.0))\n\n    def set_zoom(self, value=0.0):\n        if value == 0.0:\n            self.reset_zoom()\n            return\n        zoom = self.get_zoom()\n        if zoom < 0.0:\n            if not (ZOOM_MIN <= zoom <= ZOOM_MAX):\n                return\n        else:\n            if not (ZOOM_MIN <= value <= ZOOM_MAX):\n                return\n        value = value - zoom\n        self._set_viewer_zoom(value)\n\n    def zoom_to_nodes(self, nodes):\n        rect = self._combined_rect(nodes)\n        self.fitInView(rect, QtCore.Qt.KeepAspectRatio)\n        if self.get_zoom() > 0.1:\n            self.reset_zoom()",
  "def __init__(self, view, menu):\n        self.__view = view\n        self.__menu = menu",
  "def _menu_obj(self):\n        return self.__menu",
  "def get_menu(self, name):\n        ctx_menu = self.__view.context_menu()\n        root_menu = ctx_menu._menu_obj\n        for action in root_menu.actions():\n            if action.text() != name:\n                continue\n            menu = action.menu()\n            return ContextMenu(self.__view, menu)",
  "def add_action(self, action):\n        action.setShortcutVisibleInContextMenu(True)\n        self.__menu.addAction(action)",
  "def add_menu(self, name):\n        menu = QtWidgets.QMenu(None, title=name)\n        menu.setStyleSheet(STYLE_QMENU)\n        self.__menu.addMenu(menu)\n        return ContextMenu(self.__view, menu)",
  "def add_command(self, name, func=None, shortcut=None):\n        action = QtWidgets.QAction(name, self.__view)\n        action.setShortcutVisibleInContextMenu(True)\n        if shortcut:\n            action.setShortcut(shortcut)\n        if func:\n            action.triggered.connect(func)\n        self.__menu.addAction(action, shortcut=shortcut)",
  "def add_separator(self):\n        self.__menu.addSeparator()",
  "def __init__(self, parent=None):\n        super(NodeViewer, self).__init__(parent)\n        scene_area = 8000.0\n        scene_pos = (scene_area / 2) * -1\n        self.setScene(NodeScene(self))\n        self.setSceneRect(scene_pos, scene_pos, scene_area, scene_area)\n        self.setRenderHint(QtGui.QPainter.Antialiasing, True)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)\n        self._pipe_layout = PIPE_LAYOUT_CURVED\n        self._live_pipe = None\n        self._detached_port = None\n        self._start_port = None\n        self._origin_pos = None\n        self._previous_pos = QtCore.QPoint(self.width(), self.height())\n        self._prev_selection = []\n        self._node_positions = {}\n        self._rubber_band = QtWidgets.QRubberBand(\n            QtWidgets.QRubberBand.Rectangle, self\n        )\n        self._undo_stack = QtWidgets.QUndoStack(self)\n        self._context_menu = QtWidgets.QMenu('nodes', self)\n        self._context_menu.setStyleSheet(STYLE_QMENU)\n        self._search_widget = TabSearchWidget(self)\n        self._search_widget.search_submitted.connect(self._on_search_submitted)\n\n        # workaround fix on OSX shortcuts from the non-native menu actions\n        # don't seem to trigger so we create a dummy menu bar.\n        if platform == 'darwin':\n            menu_bar = QtWidgets.QMenuBar(self)\n            menu_bar.setNativeMenuBar(False)\n            menu_bar.resize(0, 0)\n            menu_bar.addMenu(self._context_menu)\n\n        self.acyclic = True\n        self.LMB_state = False\n        self.RMB_state = False\n        self.MMB_state = False",
  "def __str__(self):\n        return '{}.{}()'.format(\n            self.__module__, self.__class__.__name__)",
  "def __repr__(self):\n        return '{}.{}()'.format(\n            self.__module__, self.__class__.__name__)",
  "def _set_viewer_zoom(self, value):\n        if value == 0.0:\n            return\n        scale = 0.9 if value < 0.0 else 1.1\n        zoom = self.get_zoom()\n        if ZOOM_MIN >= zoom:\n            if scale == 0.9:\n                return\n        if ZOOM_MAX <= zoom:\n            if scale == 1.1:\n                return\n        self.scale(scale, scale)",
  "def _set_viewer_pan(self, pos_x, pos_y):\n        scroll_x = self.horizontalScrollBar()\n        scroll_y = self.verticalScrollBar()\n        scroll_x.setValue(scroll_x.value() - pos_x)\n        scroll_y.setValue(scroll_y.value() - pos_y)",
  "def _combined_rect(self, nodes):\n        group = self.scene().createItemGroup(nodes)\n        rect = group.boundingRect()\n        self.scene().destroyItemGroup(group)\n        return rect",
  "def _items_near(self, pos, item_type=None, width=20, height=20):\n        x, y = pos.x() - width, pos.y() - height\n        rect = QtCore.QRect(x, y, width, height)\n        items = []\n        for item in self.scene().items(rect):\n            if not item_type or isinstance(item, item_type):\n                items.append(item)\n        return items",
  "def _on_search_submitted(self, node_type):\n        pos = self.mapToScene(self._previous_pos)\n        self.search_triggered.emit(node_type, (pos.x(), pos.y()))",
  "def resizeEvent(self, event):\n        super(NodeViewer, self).resizeEvent(event)",
  "def contextMenuEvent(self, event):\n        self.RMB_state = False\n        self._context_menu.exec_(event.globalPos())",
  "def mousePressEvent(self, event):\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if event.button() == QtCore.Qt.LeftButton:\n            self.LMB_state = True\n        elif event.button() == QtCore.Qt.RightButton:\n            self.RMB_state = True\n        elif event.button() == QtCore.Qt.MiddleButton:\n            self.MMB_state = True\n        self._origin_pos = event.pos()\n        self._previous_pos = event.pos()\n        self._prev_selection = self.selected_nodes()\n\n        # close tab search\n        if self._search_widget.isVisible():\n            self.tab_search_toggle()\n\n        if alt_modifier:\n            return\n\n        items = self._items_near(self.mapToScene(event.pos()), None, 20, 20)\n        nodes = [i for i in items if isinstance(i, AbstractNodeItem)]\n\n        # toggle extend node selection.\n        if shift_modifier:\n            for node in nodes:\n                node.selected = not node.selected\n\n        # update the recorded node positions.\n        self._node_positions.update({n: n.pos for n in self.selected_nodes()})\n\n        # show selection selection marquee\n        if self.LMB_state and not items:\n            rect = QtCore.QRect(self._previous_pos, QtCore.QSize())\n            rect = rect.normalized()\n            map_rect = self.mapToScene(rect).boundingRect()\n            self.scene().update(map_rect)\n            self._rubber_band.setGeometry(rect)\n            self._rubber_band.show()\n\n        if not shift_modifier:\n            super(NodeViewer, self).mousePressEvent(event)",
  "def mouseReleaseEvent(self, event):\n        if event.button() == QtCore.Qt.LeftButton:\n            self.LMB_state = False\n        elif event.button() == QtCore.Qt.RightButton:\n            self.RMB_state = False\n        elif event.button() == QtCore.Qt.MiddleButton:\n            self.MMB_state = False\n\n        # hide selection marquee\n        if self._rubber_band.isVisible():\n            rect = self._rubber_band.rect()\n            map_rect = self.mapToScene(rect).boundingRect()\n            self._rubber_band.hide()\n            self.scene().update(map_rect)\n\n        # find position changed nodes and emit signal.\n        moved_nodes = {\n            n: pos for n, pos in self._node_positions.items() if n.pos != pos}\n        if moved_nodes:\n            self.moved_nodes.emit(moved_nodes)\n\n        # reset recorded positions.\n        self._node_positions = {}\n\n        super(NodeViewer, self).mouseReleaseEvent(event)",
  "def mouseMoveEvent(self, event):\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if self.MMB_state or (self.LMB_state and alt_modifier):\n            pos_x = (event.x() - self._previous_pos.x())\n            pos_y = (event.y() - self._previous_pos.y())\n            self._set_viewer_pan(pos_x, pos_y)\n        elif self.RMB_state:\n            pos_x = (event.x() - self._previous_pos.x())\n            zoom = 0.1 if pos_x > 0 else -0.1\n            self._set_viewer_zoom(zoom)\n\n        if self.LMB_state and self._rubber_band.isVisible():\n            rect = QtCore.QRect(self._origin_pos, event.pos()).normalized()\n            map_rect = self.mapToScene(rect).boundingRect()\n            path = QtGui.QPainterPath()\n            path.addRect(map_rect)\n            self._rubber_band.setGeometry(rect)\n            self.scene().setSelectionArea(path, QtCore.Qt.IntersectsItemShape)\n            self.scene().update(map_rect)\n\n            if shift_modifier and self._prev_selection:\n                for node in self._prev_selection:\n                    if node not in self.selected_nodes():\n                        node.selected = True\n\n        self._previous_pos = event.pos()\n        super(NodeViewer, self).mouseMoveEvent(event)",
  "def wheelEvent(self, event):\n        adjust = (event.delta() / 120) * 0.1\n        self._set_viewer_zoom(adjust)",
  "def start_live_connection(self, selected_port):\n        \"\"\"\n        create new pipe for the connection.\n        \"\"\"\n        if not selected_port:\n            return\n        self._start_port = selected_port\n        self._live_pipe = Pipe()\n        self._live_pipe.activate()\n        self._live_pipe.style = PIPE_STYLE_DASHED\n        if self._start_port.type == IN_PORT:\n            self._live_pipe.input_port = self._start_port\n        elif self._start_port == OUT_PORT:\n            self._live_pipe.output_port = self._start_port\n        self.scene().addItem(self._live_pipe)",
  "def end_live_connection(self):\n        \"\"\"\n        delete live connection pipe and reset start port.\n        \"\"\"\n        if self._live_pipe:\n            self._live_pipe.delete()\n            self._live_pipe = None\n        self._start_port = None",
  "def establish_connection(self, start_port, end_port):\n        \"\"\"\n        establish a new pipe connection.\n        \"\"\"\n        pipe = Pipe()\n        self.scene().addItem(pipe)\n        pipe.set_connections(start_port, end_port)\n        pipe.draw_path(pipe.input_port, pipe.output_port)",
  "def acyclic_check(self, start_port, end_port):\n        \"\"\"\n        validate the connection doesn't loop itself and\n        returns True if port connection is valid.\n        \"\"\"\n        start_node = start_port.node\n        check_nodes = [end_port.node]\n        io_types = {IN_PORT: 'outputs', OUT_PORT: 'inputs'}\n        while check_nodes:\n            check_node = check_nodes.pop(0)\n            for check_port in getattr(check_node, io_types[end_port.port_type]):\n                if check_port.connected_ports:\n                    for port in check_port.connected_ports:\n                        if port.node != start_node:\n                            check_nodes.append(port.node)\n                        else:\n                            return False\n        return True",
  "def sceneMouseMoveEvent(self, event):\n        \"\"\"\n        triggered mouse move event for the scene.\n         - redraw the connection pipe.\n\n        Args:\n            event (QtWidgets.QGraphicsSceneMouseEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        if not self._live_pipe:\n            return\n        if not self._start_port:\n            return\n        pos = event.scenePos()\n        self._live_pipe.draw_path(self._start_port, None, pos)",
  "def sceneMousePressEvent(self, event):\n        \"\"\"\n        triggered mouse press event for the scene (takes priority over viewer).\n         - detect selected pipe and start connection.\n         - remap Shift and Ctrl modifier.\n\n        Args:\n            event (QtWidgets.QGraphicsScenePressEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        ctrl_modifier = event.modifiers() == QtCore.Qt.ControlModifier\n        alt_modifier = event.modifiers() == QtCore.Qt.AltModifier\n        shift_modifier = event.modifiers() == QtCore.Qt.ShiftModifier\n        if shift_modifier:\n            event.setModifiers(QtCore.Qt.ControlModifier)\n        elif ctrl_modifier:\n            event.setModifiers(QtCore.Qt.ShiftModifier)\n\n        if not alt_modifier:\n            pos = event.scenePos()\n            port_items = self._items_near(pos, PortItem, 5, 5)\n            if port_items:\n                port = port_items[0]\n                if not port.multi_connection and port.connected_ports:\n                    self._detached_port = port.connected_ports[0]\n                self.start_live_connection(port)\n                if not port.multi_connection:\n                    [p.delete() for p in port.connected_pipes]\n                return\n\n            node_items = self._items_near(pos, AbstractNodeItem, 3, 3)\n            if node_items:\n                node = node_items[0]\n\n                # record the node positions at selection time.\n                for n in node_items:\n                    self._node_positions[n] = n.pos\n\n                # emit selected node id with LMB.\n                if event.button() == QtCore.Qt.LeftButton:\n                    self.node_selected.emit(node.id)\n\n                if not isinstance(node, BackdropNodeItem):\n                    return\n\n            pipe_items = self._items_near(pos, Pipe, 3, 3)\n            if pipe_items:\n                pipe = pipe_items[0]\n                attr = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n                from_port = pipe.port_from_pos(pos, True)\n                to_port = getattr(pipe, attr[from_port.port_type])\n                if not from_port.multi_connection and from_port.connected_ports:\n                    self._detached_port = from_port.connected_ports[0]\n                elif not to_port.multi_connection:\n                    self._detached_port = to_port\n\n                self.start_live_connection(from_port)\n                self._live_pipe.draw_path(self._start_port, None, pos)\n                pipe.delete()",
  "def sceneMouseReleaseEvent(self, event):\n        \"\"\"\n        triggered mouse release event for the scene.\n         - verify to make a the connection Pipe.\n        \n        Args:\n            event (QtWidgets.QGraphicsSceneMouseEvent):\n                The event handler from the QtWidgets.QGraphicsScene\n        \"\"\"\n        if event.modifiers() == QtCore.Qt.ShiftModifier:\n            event.setModifiers(QtCore.Qt.ControlModifier)\n\n        if not self._live_pipe:\n            return\n\n        # find the end port.\n        end_port = None\n        for item in self.scene().items(event.scenePos()):\n            if isinstance(item, PortItem):\n                end_port = item\n                break\n\n        connected = []\n        disconnected = []\n\n        # if port disconnected from existing pipe.\n        if end_port is None:\n            if self._detached_port:\n                disconnected.append((self._start_port, self._detached_port))\n                self.connection_changed.emit(disconnected, connected)\n\n            self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # restore connection check.\n        restore_connection = any([\n            # if same port type.\n            end_port.port_type == self._start_port.port_type,\n            # if connection to itself.\n            end_port.node == self._start_port.node,\n            # if end port is the start port.\n            end_port == self._start_port,\n            # if detached port is the end port.\n            self._detached_port == end_port\n        ])\n        if restore_connection:\n            if self._detached_port:\n                to_port = self._detached_port or end_port\n                self.establish_connection(self._start_port, to_port)\n                self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # register as disconnected if not acyclic.\n        if self.acyclic and not self.acyclic_check(self._start_port, end_port):\n            if self._detached_port:\n                disconnected.append((self._start_port, self._detached_port))\n\n            self.connection_changed.emit(disconnected, connected)\n\n            self._detached_port = None\n            self.end_live_connection()\n            return\n\n        # make connection.\n        if not end_port.multi_connection and end_port.connected_ports:\n            dettached_end = end_port.connected_ports[0]\n            disconnected.append((end_port, dettached_end))\n\n        if self._detached_port:\n            disconnected.append((self._start_port, self._detached_port))\n\n        connected.append((self._start_port, end_port))\n\n        self.connection_changed.emit(disconnected, connected)\n\n        self._detached_port = None\n        self.end_live_connection()",
  "def tab_search_set_nodes(self, nodes):\n        self._search_widget.set_nodes(nodes)",
  "def tab_search_toggle(self):\n        pos = self._previous_pos\n        state = not self._search_widget.isVisible()\n        if state:\n            rect = self._search_widget.rect()\n            new_pos = QtCore.QPoint(pos.x() - rect.width() / 2,\n                                    pos.y() - rect.height() / 2)\n            self._search_widget.move(new_pos)\n            self._search_widget.setVisible(state)\n            rect = self.mapToScene(rect).boundingRect()\n            self.scene().update(rect)\n        else:\n            self._search_widget.setVisible(state)\n            self.clearFocus()",
  "def context_menu(self):\n        return ContextMenu(self, self._context_menu)",
  "def question_dialog(self, title, text):\n        dlg = QtWidgets.QMessageBox.question(\n            self, title, text,\n            QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)\n        return dlg == QtWidgets.QMessageBox.Yes",
  "def message_dialog(self, text, title='node graph'):\n        QtWidgets.QMessageBox.information(\n            self, title, text, QtWidgets.QMessageBox.Ok)",
  "def all_pipes(self):\n        pipes = []\n        for item in self.scene().items():\n            if isinstance(item, Pipe):\n                pipes.append(item)\n        return pipes",
  "def all_nodes(self):\n        nodes = []\n        for item in self.scene().items():\n            if isinstance(item, AbstractNodeItem):\n                nodes.append(item)\n        return nodes",
  "def selected_nodes(self):\n        nodes = []\n        for item in self.scene().selectedItems():\n            if isinstance(item, AbstractNodeItem):\n                nodes.append(item)\n        return nodes",
  "def add_node(self, node, pos=None):\n        pos = pos or (self._previous_pos.x(), self._previous_pos.y())\n        node.pre_init(self, pos)\n        self.scene().addItem(node)\n        node.post_init(self, pos)",
  "def remove_node(self, node):\n        if isinstance(node, AbstractNodeItem):\n            node.delete()",
  "def move_nodes(self, nodes, pos=None, offset=None):\n        group = self.scene().createItemGroup(nodes)\n        group_rect = group.boundingRect()\n        if pos:\n            x, y = pos\n        else:\n            pos = self.mapToScene(self._previous_pos)\n            x = pos.x() - group_rect.center().x()\n            y = pos.y() - group_rect.center().y()\n        if offset:\n            x += offset[0]\n            y += offset[1]\n        group.setPos(x, y)\n        self.scene().destroyItemGroup(group)",
  "def get_pipes_from_nodes(self, nodes=None):\n        nodes = nodes or self.selected_nodes()\n        if not nodes:\n            return\n        pipes = []\n        for node in nodes:\n            n_inputs = node.inputs if hasattr(node, 'inputs') else []\n            n_outputs = node.outputs if hasattr(node, 'outputs') else []\n\n            for port in n_inputs:\n                for pipe in port.connected_pipes:\n                    connected_node = pipe.output_port.node\n                    if connected_node in nodes:\n                        pipes.append(pipe)\n            for port in n_outputs:\n                for pipe in port.connected_pipes:\n                    connected_node = pipe.input_port.node\n                    if connected_node in nodes:\n                        pipes.append(pipe)\n        return pipes",
  "def center_selection(self, nodes=None):\n        if not nodes:\n            if self.selected_nodes():\n                nodes = self.selected_nodes()\n            elif self.all_nodes():\n                nodes = self.all_nodes()\n        if len(nodes) == 1:\n            self.centerOn(nodes[0])\n        else:\n            rect = self._combined_rect(nodes)\n            self.centerOn(rect.center().x(), rect.center().y())",
  "def get_pipe_layout(self):\n        return self._pipe_layout",
  "def set_pipe_layout(self, layout=''):\n        layout_types = {\n            'curved': PIPE_LAYOUT_CURVED,\n            'straight': PIPE_LAYOUT_STRAIGHT\n        }\n        self._pipe_layout = layout_types.get(layout, 'curved')\n        for pipe in self.all_pipes():\n            pipe.draw_path(pipe.input_port, pipe.output_port)",
  "def reset_zoom(self):\n        self.scale(1.0, 1.0)\n        self.resetMatrix()",
  "def get_zoom(self):\n        transform = self.transform()\n        cur_scale = (transform.m11(), transform.m22())\n        return float('{:0.2f}'.format(cur_scale[0] - 1.0))",
  "def set_zoom(self, value=0.0):\n        if value == 0.0:\n            self.reset_zoom()\n            return\n        zoom = self.get_zoom()\n        if zoom < 0.0:\n            if not (ZOOM_MIN <= zoom <= ZOOM_MAX):\n                return\n        else:\n            if not (ZOOM_MIN <= value <= ZOOM_MAX):\n                return\n        value = value - zoom\n        self._set_viewer_zoom(value)",
  "def zoom_to_nodes(self, nodes):\n        rect = self._combined_rect(nodes)\n        self.fitInView(rect, QtCore.Qt.KeepAspectRatio)\n        if self.get_zoom() > 0.1:\n            self.reset_zoom()",
  "class AbstractNodeItem(QGraphicsItem):\n    \"\"\"\n    The abstract base class of a node.\n    \"\"\"\n\n    def __init__(self, name='node', parent=None):\n        super(AbstractNodeItem, self).__init__(parent)\n        self.setFlags(self.ItemIsSelectable | self.ItemIsMovable)\n        self.setZValue(Z_VAL_NODE)\n        self._properties = {\n            'id': None,\n            'name': name.strip(),\n            'color': (48, 58, 69, 255),\n            'border_color': (85, 100, 100, 255),\n            'text_color': (255, 255, 255, 180),\n            'type': 'AbstractBaseNode',\n            'selected': False,\n            'disabled': False,\n        }\n        self._width = 120\n        self._height = 80\n\n    def __str__(self):\n        return '{}.{}(\\'{}\\')'.format(\n            self.__module__, self.__class__.__name__, self.name)\n\n    def __repr__(self):\n        return '{}.{}(\\'{}\\')'.format(\n            self.__module__, self.__class__.__name__, self.name)\n\n    def boundingRect(self):\n        return QRectF(0.0, 0.0, self._width, self._height)\n\n    def mousePressEvent(self, event):\n        self._properties['selected'] = True\n        super(AbstractNodeItem, self).mousePressEvent(event)\n\n    def setSelected(self, selected):\n        self._properties['selected'] = selected\n        super(AbstractNodeItem, self).setSelected(selected)\n\n    def pre_init(self, viewer, pos=None):\n        \"\"\"\n        Called before node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer.\n            pos (tuple): the cursor pos if node is called with tab search.\n        \"\"\"\n        pass\n\n    def post_init(self, viewer, pos=None):\n        \"\"\"\n        Called after node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer\n            pos (tuple): the cursor pos if node is called with tab search.\n        \"\"\"\n        pass\n\n    @property\n    def id(self):\n        return self._properties['id']\n\n    @id.setter\n    def id(self, unique_id=''):\n        self._properties['id'] = unique_id\n\n    @property\n    def type(self):\n        return self._properties['type']\n\n    @type.setter\n    def type(self, node_type='NODE'):\n        self._properties['type'] = node_type\n\n    @property\n    def size(self):\n        return self._width, self._height\n\n    @property\n    def width(self):\n        return self._width\n\n    @width.setter\n    def width(self, width=0.0):\n        self._width = width\n\n    @property\n    def height(self):\n        return self._height\n\n    @height.setter\n    def height(self, height=0.0):\n        self._height = height\n\n    @property\n    def color(self):\n        return self._properties['color']\n\n    @color.setter\n    def color(self, color=(0, 0, 0, 255)):\n        self._properties['color'] = color\n\n    @property\n    def text_color(self):\n        return self._properties['text_color']\n\n    @text_color.setter\n    def text_color(self, color=(100, 100, 100, 255)):\n        self._properties['text_color'] = color\n\n    @property\n    def border_color(self):\n        return self._properties['border_color']\n\n    @border_color.setter\n    def border_color(self, color=(0, 0, 0, 255)):\n        self._properties['border_color'] = color\n\n    @property\n    def disabled(self):\n        return self._properties['disabled']\n\n    @disabled.setter\n    def disabled(self, state=False):\n        self._properties['disabled'] = state\n\n    @property\n    def selected(self):\n        return self.isSelected()\n\n    @selected.setter\n    def selected(self, selected=False):\n        self.setSelected(selected)\n\n    @property\n    def pos(self):\n        return float(self.scenePos().x()), float(self.scenePos().y())\n\n    @pos.setter\n    def pos(self, pos=None):\n        pos = pos or [0.0, 0.0]\n        self.setPos(pos[0], pos[1])\n\n    @property\n    def name(self):\n        return self._properties['name']\n\n    @name.setter\n    def name(self, name=''):\n        self._properties['name'] = name\n        self.setToolTip('node: {}'.format(name))\n\n    @property\n    def properties(self):\n        \"\"\"\n        return the node view attributes.\n\n        Returns:\n            dict: {property_name: property_value}\n        \"\"\"\n        props = {'width': self.width,\n                 'height': self.height,\n                 'pos':  self.pos}\n        props.update(self._properties)\n        return props\n\n    def viewer(self):\n        \"\"\"\n        return the main viewer.\n\n        Returns:\n            NodeGraphQt.widgets.viewer.NodeViewer: viewer object.\n        \"\"\"\n        if self.scene():\n            return self.scene().viewer()\n\n    def delete(self):\n        \"\"\"\n        remove node view from the scene.\n        \"\"\"\n        if self.scene():\n            self.scene().removeItem(self)\n\n    def from_dict(self, node_dict):\n        \"\"\"\n        set the node view attributes from the dictionary.\n\n        Args:\n            node_dict (dict): serialized node dict.\n        \"\"\"\n        node_attrs = list(self._properties.keys()) + ['width', 'height']\n        for name, value in node_dict.items():\n            if name in node_attrs:\n                setattr(self, name, value)",
  "def __init__(self, name='node', parent=None):\n        super(AbstractNodeItem, self).__init__(parent)\n        self.setFlags(self.ItemIsSelectable | self.ItemIsMovable)\n        self.setZValue(Z_VAL_NODE)\n        self._properties = {\n            'id': None,\n            'name': name.strip(),\n            'color': (48, 58, 69, 255),\n            'border_color': (85, 100, 100, 255),\n            'text_color': (255, 255, 255, 180),\n            'type': 'AbstractBaseNode',\n            'selected': False,\n            'disabled': False,\n        }\n        self._width = 120\n        self._height = 80",
  "def __str__(self):\n        return '{}.{}(\\'{}\\')'.format(\n            self.__module__, self.__class__.__name__, self.name)",
  "def __repr__(self):\n        return '{}.{}(\\'{}\\')'.format(\n            self.__module__, self.__class__.__name__, self.name)",
  "def boundingRect(self):\n        return QRectF(0.0, 0.0, self._width, self._height)",
  "def mousePressEvent(self, event):\n        self._properties['selected'] = True\n        super(AbstractNodeItem, self).mousePressEvent(event)",
  "def setSelected(self, selected):\n        self._properties['selected'] = selected\n        super(AbstractNodeItem, self).setSelected(selected)",
  "def pre_init(self, viewer, pos=None):\n        \"\"\"\n        Called before node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer.\n            pos (tuple): the cursor pos if node is called with tab search.\n        \"\"\"\n        pass",
  "def post_init(self, viewer, pos=None):\n        \"\"\"\n        Called after node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer\n            pos (tuple): the cursor pos if node is called with tab search.\n        \"\"\"\n        pass",
  "def id(self):\n        return self._properties['id']",
  "def id(self, unique_id=''):\n        self._properties['id'] = unique_id",
  "def type(self):\n        return self._properties['type']",
  "def type(self, node_type='NODE'):\n        self._properties['type'] = node_type",
  "def size(self):\n        return self._width, self._height",
  "def width(self):\n        return self._width",
  "def width(self, width=0.0):\n        self._width = width",
  "def height(self):\n        return self._height",
  "def height(self, height=0.0):\n        self._height = height",
  "def color(self):\n        return self._properties['color']",
  "def color(self, color=(0, 0, 0, 255)):\n        self._properties['color'] = color",
  "def text_color(self):\n        return self._properties['text_color']",
  "def text_color(self, color=(100, 100, 100, 255)):\n        self._properties['text_color'] = color",
  "def border_color(self):\n        return self._properties['border_color']",
  "def border_color(self, color=(0, 0, 0, 255)):\n        self._properties['border_color'] = color",
  "def disabled(self):\n        return self._properties['disabled']",
  "def disabled(self, state=False):\n        self._properties['disabled'] = state",
  "def selected(self):\n        return self.isSelected()",
  "def selected(self, selected=False):\n        self.setSelected(selected)",
  "def pos(self):\n        return float(self.scenePos().x()), float(self.scenePos().y())",
  "def pos(self, pos=None):\n        pos = pos or [0.0, 0.0]\n        self.setPos(pos[0], pos[1])",
  "def name(self):\n        return self._properties['name']",
  "def name(self, name=''):\n        self._properties['name'] = name\n        self.setToolTip('node: {}'.format(name))",
  "def properties(self):\n        \"\"\"\n        return the node view attributes.\n\n        Returns:\n            dict: {property_name: property_value}\n        \"\"\"\n        props = {'width': self.width,\n                 'height': self.height,\n                 'pos':  self.pos}\n        props.update(self._properties)\n        return props",
  "def viewer(self):\n        \"\"\"\n        return the main viewer.\n\n        Returns:\n            NodeGraphQt.widgets.viewer.NodeViewer: viewer object.\n        \"\"\"\n        if self.scene():\n            return self.scene().viewer()",
  "def delete(self):\n        \"\"\"\n        remove node view from the scene.\n        \"\"\"\n        if self.scene():\n            self.scene().removeItem(self)",
  "def from_dict(self, node_dict):\n        \"\"\"\n        set the node view attributes from the dictionary.\n\n        Args:\n            node_dict (dict): serialized node dict.\n        \"\"\"\n        node_attrs = list(self._properties.keys()) + ['width', 'height']\n        for name, value in node_dict.items():\n            if name in node_attrs:\n                setattr(self, name, value)",
  "class NodePropertyChangedCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node property changed.\n    \"\"\"\n\n    def __init__(self, node, name, value):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('modified node \"{}\"'.format(name))\n        self.node = node\n        self.name = name\n        self.old_val = self.node.get_property(name)\n        self.new_val = value\n\n    def undo(self):\n        self.node.set_property(self.name, self.old_val)\n\n    def redo(self):\n        self.node.set_property(self.name, self.new_val)",
  "class NodeDisabledCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node enabled/disabled.\n    \"\"\"\n\n    def __init__(self, node):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.node = node\n        self.mode = node.disabled\n        mode = 'enabled' if self.mode else 'disabled'\n        self.setText('{} node'.format(mode))\n\n    def undo(self):\n        self.node.disabled = not self.mode\n\n    def redo(self):\n        self.node.disabled = self.mode",
  "class NodeCreatedCommand(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node created command.\n    \"\"\"\n\n    def __init__(self, node, scene):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('created node')\n        self.scene = scene\n        self.node = node\n\n    def undo(self):\n        self.node.delete()\n\n    def redo(self):\n        self.scene.addItem(self.node)",
  "class NodeDeletedCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node deleted command.\n    \"\"\"\n\n    def __init__(self, node, scene):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('deleted node')\n        self.scene = scene\n        self.node = node\n        self.inputs = {}\n        self.outputs = {}\n        if hasattr(self.node, 'inputs'):\n            self.inputs = {p: p.connected_ports for p in self.node.inputs}\n        if hasattr(self.node, 'outputs'):\n            self.outputs = {p: p.connected_ports for p in self.node.outputs}\n\n    def undo(self):\n        self.scene.addItem(self.node)\n        for p, ports in self.inputs.items():\n            [p.connect_to(cp) for cp in ports]\n        for p, ports in self.outputs.items():\n            [p.connect_to(cp) for cp in ports]\n\n    def redo(self):\n        self.node.delete()",
  "class NodeConnectedCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Port connected command.\n    \"\"\"\n\n    def __init__(self, start_port, end_port):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('connected node')\n        self.start_port = start_port\n        self.end_port = end_port\n        self.pipe = Pipe()\n\n    def establish_connection(self, start_port, end_port, pipe):\n        ports = {\n            start_port.port_type: start_port,\n            end_port.port_type: end_port\n        }\n        scene = start_port.scene()\n        scene.addItem(pipe)\n        pipe.set_connections(ports[IN_PORT], ports[OUT_PORT])\n        pipe.draw_path(pipe.input_port, pipe.output_port)\n\n    def undo(self):\n        self.pipe.delete()\n\n    def redo(self):\n        if self.end_port in self.start_port.connected_ports:\n            return\n        self.establish_connection(self.start_port,\n                                  self.end_port,\n                                  self.pipe)",
  "class NodeDisconnectedCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node disconnected command.\n    \"\"\"\n\n    def __init__(self, start_port, end_port):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('disconnected node')\n        self.start_port = start_port\n        self.end_port = end_port\n        self.pipe = Pipe()\n\n    def establish_connection(self, start_port, end_port, pipe):\n        ports = {\n            start_port.port_type: start_port,\n            end_port.port_type: end_port\n        }\n        scene = start_port.scene()\n        scene.addItem(pipe)\n        pipe.set_connections(ports[IN_PORT], ports[OUT_PORT])\n        pipe.draw_path(pipe.input_port, pipe.output_port)\n\n    def undo(self):\n        self.establish_connection(self.start_port,\n                                  self.end_port,\n                                  self.pipe)\n\n    def redo(self):\n        if self.end_port not in self.start_port.connected_ports:\n            return\n        for pipe in self.start_port.connected_pipes:\n            if self.end_port in [pipe.input_port, pipe.output_port]:\n                self.pipe = pipe\n                self.pipe.delete()\n                break",
  "class NodePositionChangedCmd(QtWidgets.QUndoCommand):\n    \"\"\"\n    Node position changed.\n    \"\"\"\n\n    def __init__(self, node):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('node position changed')\n        self.node = node\n        self.pos = node.pos\n        self.prev_pos = node.prev_pos\n\n    def undo(self):\n        self.node.pos = self.prev_pos\n\n    def redo(self):\n        self.node.pos = self.pos",
  "def __init__(self, node, name, value):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('modified node \"{}\"'.format(name))\n        self.node = node\n        self.name = name\n        self.old_val = self.node.get_property(name)\n        self.new_val = value",
  "def undo(self):\n        self.node.set_property(self.name, self.old_val)",
  "def redo(self):\n        self.node.set_property(self.name, self.new_val)",
  "def __init__(self, node):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.node = node\n        self.mode = node.disabled\n        mode = 'enabled' if self.mode else 'disabled'\n        self.setText('{} node'.format(mode))",
  "def undo(self):\n        self.node.disabled = not self.mode",
  "def redo(self):\n        self.node.disabled = self.mode",
  "def __init__(self, node, scene):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('created node')\n        self.scene = scene\n        self.node = node",
  "def undo(self):\n        self.node.delete()",
  "def redo(self):\n        self.scene.addItem(self.node)",
  "def __init__(self, node, scene):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('deleted node')\n        self.scene = scene\n        self.node = node\n        self.inputs = {}\n        self.outputs = {}\n        if hasattr(self.node, 'inputs'):\n            self.inputs = {p: p.connected_ports for p in self.node.inputs}\n        if hasattr(self.node, 'outputs'):\n            self.outputs = {p: p.connected_ports for p in self.node.outputs}",
  "def undo(self):\n        self.scene.addItem(self.node)\n        for p, ports in self.inputs.items():\n            [p.connect_to(cp) for cp in ports]\n        for p, ports in self.outputs.items():\n            [p.connect_to(cp) for cp in ports]",
  "def redo(self):\n        self.node.delete()",
  "def __init__(self, start_port, end_port):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('connected node')\n        self.start_port = start_port\n        self.end_port = end_port\n        self.pipe = Pipe()",
  "def establish_connection(self, start_port, end_port, pipe):\n        ports = {\n            start_port.port_type: start_port,\n            end_port.port_type: end_port\n        }\n        scene = start_port.scene()\n        scene.addItem(pipe)\n        pipe.set_connections(ports[IN_PORT], ports[OUT_PORT])\n        pipe.draw_path(pipe.input_port, pipe.output_port)",
  "def undo(self):\n        self.pipe.delete()",
  "def redo(self):\n        if self.end_port in self.start_port.connected_ports:\n            return\n        self.establish_connection(self.start_port,\n                                  self.end_port,\n                                  self.pipe)",
  "def __init__(self, start_port, end_port):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('disconnected node')\n        self.start_port = start_port\n        self.end_port = end_port\n        self.pipe = Pipe()",
  "def establish_connection(self, start_port, end_port, pipe):\n        ports = {\n            start_port.port_type: start_port,\n            end_port.port_type: end_port\n        }\n        scene = start_port.scene()\n        scene.addItem(pipe)\n        pipe.set_connections(ports[IN_PORT], ports[OUT_PORT])\n        pipe.draw_path(pipe.input_port, pipe.output_port)",
  "def undo(self):\n        self.establish_connection(self.start_port,\n                                  self.end_port,\n                                  self.pipe)",
  "def redo(self):\n        if self.end_port not in self.start_port.connected_ports:\n            return\n        for pipe in self.start_port.connected_pipes:\n            if self.end_port in [pipe.input_port, pipe.output_port]:\n                self.pipe = pipe\n                self.pipe.delete()\n                break",
  "def __init__(self, node):\n        QtWidgets.QUndoCommand.__init__(self)\n        self.setText('node position changed')\n        self.node = node\n        self.pos = node.pos\n        self.prev_pos = node.prev_pos",
  "def undo(self):\n        self.node.pos = self.prev_pos",
  "def redo(self):\n        self.node.pos = self.pos",
  "class PortItem(QtWidgets.QGraphicsItem):\n    \"\"\"\n    Base Port Item.\n    \"\"\"\n\n    def __init__(self, parent=None):\n        super(PortItem, self).__init__(parent)\n        self.setAcceptHoverEvents(True)\n        self.setFlag(self.ItemIsSelectable, False)\n        self.setFlag(self.ItemSendsScenePositionChanges, True)\n        self.setZValue(Z_VAL_PORT)\n        self._pipes = []\n        self._width = 10.0\n        self._height = 10.0\n        self._hovered = False\n        self._name = 'port'\n        self._display_name = True\n        self._color = (49, 115, 100, 255)\n        self._border_color = (29, 202, 151, 255)\n        self._border_size = 1\n        self._port_type = None\n        self._multi_connection = False\n\n    def __str__(self):\n        return '{}.PortItem(\"{}\")'.format(self.__module__, self.name)\n\n    def __repr__(self):\n        return '{}.PortItem(\"{}\")'.format(self.__module__, self.name)\n\n    def boundingRect(self):\n        return QtCore.QRectF(0.0, 0.0, self._width, self._height)\n\n    def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = QtCore.QRectF(0.0, 0.8, self._width, self._height)\n        painter.setBrush(QtGui.QColor(0, 0, 0, 200))\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 255), 1.8))\n        path = QtGui.QPainterPath()\n        path.addEllipse(rect)\n        painter.drawPath(path)\n\n        if self._hovered:\n            color = QtGui.QColor(*PORT_HOVER_COLOR)\n            border_color = QtGui.QColor(*PORT_HOVER_BORDER_COLOR)\n        elif self.connected_pipes:\n            color = QtGui.QColor(*PORT_ACTIVE_COLOR)\n            border_color = QtGui.QColor(*PORT_ACTIVE_BORDER_COLOR)\n        else:\n            color = QtGui.QColor(*self.color)\n            border_color = QtGui.QColor(*self.border_color)\n\n        painter.setBrush(color)\n        pen = QtGui.QPen(border_color, 1.5)\n        painter.setPen(pen)\n        painter.drawEllipse(self.boundingRect())\n\n        painter.restore()\n\n    def itemChange(self, change, value):\n        if change == self.ItemScenePositionHasChanged:\n            self.redraw_connected_pipes()\n        return super(PortItem, self).itemChange(change, value)\n\n    def mousePressEvent(self, event):\n        if event.modifiers() != QtCore.Qt.AltModifier:\n            self.viewer_start_connection()\n        super(PortItem, self).mousePressEvent(event)\n        \n    def mouseReleaseEvent(self, event):\n        super(PortItem, self).mouseReleaseEvent(event)\n        \n    def hoverEnterEvent(self, event):\n        self._hovered = True\n        super(PortItem, self).hoverEnterEvent(event)\n        \n    def hoverLeaveEvent(self, event):\n        self._hovered = False\n        super(PortItem, self).hoverLeaveEvent(event)\n\n    def viewer_start_connection(self):\n        viewer = self.scene().viewer()\n        viewer.start_live_connection(self)\n\n    def redraw_connected_pipes(self):\n        if not self.connected_pipes:\n            return\n        for pipe in self.connected_pipes:\n            if self.port_type == IN_PORT:\n                pipe.draw_path(self, pipe.output_port)\n            elif self.port_type == OUT_PORT:\n                pipe.draw_path(pipe.input_port, self)\n\n    def add_pipe(self, pipe):\n        self._pipes.append(pipe)\n\n    def remove_pipe(self, pipe):\n        self._pipes.remove(pipe)\n\n    @property\n    def connected_pipes(self):\n        return self._pipes\n\n    @property\n    def connected_ports(self):\n        ports = []\n        port_types = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n        for pipe in self.connected_pipes:\n            ports.append(getattr(pipe, port_types[self.port_type]))\n        return ports\n\n    @property\n    def node(self):\n        return self.parentItem()\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name=''):\n        self._name = name.strip()\n\n    @property\n    def display_name(self):\n        return self._display_name\n\n    @display_name.setter\n    def display_name(self, display=True):\n        self._display_name = display\n\n    @property\n    def color(self):\n        return self._color\n\n    @color.setter\n    def color(self, color=(0, 0, 0, 255)):\n        self._color = color\n\n    @property\n    def border_color(self):\n        return self._border_color\n\n    @border_color.setter\n    def border_color(self, color=(0, 0, 0, 255)):\n        self._border_color = color\n\n    @property\n    def border_size(self):\n        return self._border_size\n\n    @border_size.setter\n    def border_size(self, size=2):\n        self._border_size = size\n\n    @property\n    def multi_connection(self):\n        return self._multi_connection\n\n    @multi_connection.setter\n    def multi_connection(self, mode=False):\n        conn_type = 'multi' if mode else 'single'\n        self.setToolTip('{}: ({})'.format(self.name, conn_type))\n        self._multi_connection = mode\n\n    @property\n    def port_type(self):\n        return self._port_type\n\n    @port_type.setter\n    def port_type(self, port_type):\n        self._port_type = port_type\n\n    def delete(self):\n        for pipe in self.connected_pipes:\n            pipe.delete()\n\n    def connect_to(self, port):\n        if not port:\n            for pipe in self.connected_pipes:\n                pipe.delete()\n            return\n        if self.scene():\n            viewer = self.scene().viewer()\n            viewer.establish_connection(self, port)\n\n    def disconnect_from(self, port):\n        port_types = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n        for pipe in self.connected_pipes:\n            connected_port = getattr(pipe, port_types[self.port_type])\n            if connected_port == port:\n                pipe.delete()\n                break",
  "def __init__(self, parent=None):\n        super(PortItem, self).__init__(parent)\n        self.setAcceptHoverEvents(True)\n        self.setFlag(self.ItemIsSelectable, False)\n        self.setFlag(self.ItemSendsScenePositionChanges, True)\n        self.setZValue(Z_VAL_PORT)\n        self._pipes = []\n        self._width = 10.0\n        self._height = 10.0\n        self._hovered = False\n        self._name = 'port'\n        self._display_name = True\n        self._color = (49, 115, 100, 255)\n        self._border_color = (29, 202, 151, 255)\n        self._border_size = 1\n        self._port_type = None\n        self._multi_connection = False",
  "def __str__(self):\n        return '{}.PortItem(\"{}\")'.format(self.__module__, self.name)",
  "def __repr__(self):\n        return '{}.PortItem(\"{}\")'.format(self.__module__, self.name)",
  "def boundingRect(self):\n        return QtCore.QRectF(0.0, 0.0, self._width, self._height)",
  "def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = QtCore.QRectF(0.0, 0.8, self._width, self._height)\n        painter.setBrush(QtGui.QColor(0, 0, 0, 200))\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 255), 1.8))\n        path = QtGui.QPainterPath()\n        path.addEllipse(rect)\n        painter.drawPath(path)\n\n        if self._hovered:\n            color = QtGui.QColor(*PORT_HOVER_COLOR)\n            border_color = QtGui.QColor(*PORT_HOVER_BORDER_COLOR)\n        elif self.connected_pipes:\n            color = QtGui.QColor(*PORT_ACTIVE_COLOR)\n            border_color = QtGui.QColor(*PORT_ACTIVE_BORDER_COLOR)\n        else:\n            color = QtGui.QColor(*self.color)\n            border_color = QtGui.QColor(*self.border_color)\n\n        painter.setBrush(color)\n        pen = QtGui.QPen(border_color, 1.5)\n        painter.setPen(pen)\n        painter.drawEllipse(self.boundingRect())\n\n        painter.restore()",
  "def itemChange(self, change, value):\n        if change == self.ItemScenePositionHasChanged:\n            self.redraw_connected_pipes()\n        return super(PortItem, self).itemChange(change, value)",
  "def mousePressEvent(self, event):\n        if event.modifiers() != QtCore.Qt.AltModifier:\n            self.viewer_start_connection()\n        super(PortItem, self).mousePressEvent(event)",
  "def mouseReleaseEvent(self, event):\n        super(PortItem, self).mouseReleaseEvent(event)",
  "def hoverEnterEvent(self, event):\n        self._hovered = True\n        super(PortItem, self).hoverEnterEvent(event)",
  "def hoverLeaveEvent(self, event):\n        self._hovered = False\n        super(PortItem, self).hoverLeaveEvent(event)",
  "def viewer_start_connection(self):\n        viewer = self.scene().viewer()\n        viewer.start_live_connection(self)",
  "def redraw_connected_pipes(self):\n        if not self.connected_pipes:\n            return\n        for pipe in self.connected_pipes:\n            if self.port_type == IN_PORT:\n                pipe.draw_path(self, pipe.output_port)\n            elif self.port_type == OUT_PORT:\n                pipe.draw_path(pipe.input_port, self)",
  "def add_pipe(self, pipe):\n        self._pipes.append(pipe)",
  "def remove_pipe(self, pipe):\n        self._pipes.remove(pipe)",
  "def connected_pipes(self):\n        return self._pipes",
  "def connected_ports(self):\n        ports = []\n        port_types = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n        for pipe in self.connected_pipes:\n            ports.append(getattr(pipe, port_types[self.port_type]))\n        return ports",
  "def node(self):\n        return self.parentItem()",
  "def name(self):\n        return self._name",
  "def name(self, name=''):\n        self._name = name.strip()",
  "def display_name(self):\n        return self._display_name",
  "def display_name(self, display=True):\n        self._display_name = display",
  "def color(self):\n        return self._color",
  "def color(self, color=(0, 0, 0, 255)):\n        self._color = color",
  "def border_color(self):\n        return self._border_color",
  "def border_color(self, color=(0, 0, 0, 255)):\n        self._border_color = color",
  "def border_size(self):\n        return self._border_size",
  "def border_size(self, size=2):\n        self._border_size = size",
  "def multi_connection(self):\n        return self._multi_connection",
  "def multi_connection(self, mode=False):\n        conn_type = 'multi' if mode else 'single'\n        self.setToolTip('{}: ({})'.format(self.name, conn_type))\n        self._multi_connection = mode",
  "def port_type(self):\n        return self._port_type",
  "def port_type(self, port_type):\n        self._port_type = port_type",
  "def delete(self):\n        for pipe in self.connected_pipes:\n            pipe.delete()",
  "def connect_to(self, port):\n        if not port:\n            for pipe in self.connected_pipes:\n                pipe.delete()\n            return\n        if self.scene():\n            viewer = self.scene().viewer()\n            viewer.establish_connection(self, port)",
  "def disconnect_from(self, port):\n        port_types = {IN_PORT: 'output_port', OUT_PORT: 'input_port'}\n        for pipe in self.connected_pipes:\n            connected_port = getattr(pipe, port_types[self.port_type])\n            if connected_port == port:\n                pipe.delete()\n                break",
  "class XDisabledItem(QGraphicsItem):\n\n    def __init__(self, parent=None, text=None):\n        super(XDisabledItem, self).__init__(parent)\n        self.setZValue(Z_VAL_NODE_WIDGET + 2)\n        self.setVisible(False)\n        self.color = (0, 0, 0, 255)\n        self.text = text\n\n    def boundingRect(self):\n        return self.parentItem().boundingRect()\n\n    def paint(self, painter, option, widget):\n        painter.save()\n\n        margin = 20\n        rect = self.boundingRect()\n        dis_rect = QtCore.QRectF(rect.left() - (margin / 2),\n                                 rect.top() - (margin / 2),\n                                 rect.width() + margin,\n                                 rect.height() + margin)\n        pen = QtGui.QPen(QtGui.QColor(*self.color), 8)\n        pen.setCapStyle(QtCore.Qt.RoundCap)\n        painter.setPen(pen)\n        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())\n        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())\n\n        bg_color = QtGui.QColor(*self.color)\n        bg_color.setAlpha(100)\n        bg_margin = -0.5\n        bg_rect = QtCore.QRectF(dis_rect.left() - (bg_margin / 2),\n                                dis_rect.top() - (bg_margin / 2),\n                                dis_rect.width() + bg_margin,\n                                dis_rect.height() + bg_margin)\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 0)))\n        painter.setBrush(bg_color)\n        painter.drawRoundedRect(bg_rect, 5, 5)\n\n        pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 0.7)\n        painter.setPen(pen)\n        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())\n        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())\n\n        point_size = 4.0\n        point_pos = (dis_rect.topLeft(), dis_rect.topRight(),\n                     dis_rect.bottomLeft(), dis_rect.bottomRight())\n        painter.setBrush(QtGui.QColor(255, 0, 0, 255))\n        for p in point_pos:\n            p.setX(p.x() - (point_size / 2))\n            p.setY(p.y() - (point_size / 2))\n            point_rect = QtCore.QRectF(\n                p, QtCore.QSizeF(point_size, point_size))\n            painter.drawEllipse(point_rect)\n\n        if self.text:\n            font = painter.font()\n            font.setPointSize(10)\n\n            painter.setFont(font)\n            font_metrics = QtGui.QFontMetrics(font)\n            font_width = font_metrics.width(self.text)\n            font_height = font_metrics.height()\n            txt_w = font_width * 1.25\n            txt_h = font_height * 2.25\n            text_bg_rect = QtCore.QRectF((rect.width() / 2) - (txt_w / 2),\n                                         (rect.height() / 2) - (txt_h / 2),\n                                         txt_w, txt_h)\n            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 0.5))\n            painter.setBrush(QtGui.QColor(*self.color))\n            painter.drawRoundedRect(text_bg_rect, 2, 2)\n\n            text_rect = QtCore.QRectF((rect.width() / 2) - (font_width / 2),\n                                      (rect.height() / 2) - (font_height / 2),\n                                      txt_w * 2, font_height * 2)\n\n            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 1))\n            painter.drawText(text_rect, self.text)\n\n        painter.restore()",
  "class NodeItem(AbstractNodeItem):\n    \"\"\"\n    Base Node item.\n    \"\"\"\n\n    def __init__(self, name='node', parent=None):\n        super(NodeItem, self).__init__(name, parent)\n        pixmap = QtGui.QPixmap(ICON_NODE_BASE)\n        pixmap = pixmap.scaledToHeight(NODE_ICON_SIZE,\n                                       QtCore.Qt.SmoothTransformation)\n        self._properties['icon'] = ICON_NODE_BASE\n        self._icon_item = QGraphicsPixmapItem(pixmap, self)\n        self._text_item = QGraphicsTextItem(self.name, self)\n        self._x_item = XDisabledItem(self, 'node disabled')\n        self._input_items = {}\n        self._output_items = {}\n        self._widgets = {}\n\n    def paint(self, painter, option, widget):\n        painter.save()\n\n        bg_border = 1.0\n        rect = QtCore.QRectF(0.5 - (bg_border / 2),\n                             0.5 - (bg_border / 2),\n                             self._width + bg_border,\n                             self._height + bg_border)\n        radius_x = 5\n        radius_y = 5\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(rect, radius_x, radius_y)\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 255), 1.5))\n        painter.drawPath(path)\n\n        rect = self.boundingRect()\n        bg_color = QtGui.QColor(*self.color)\n        painter.setBrush(bg_color)\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRoundRect(rect, radius_x, radius_y)\n\n        if self.selected and NODE_SEL_COLOR:\n            painter.setBrush(QtGui.QColor(*NODE_SEL_COLOR))\n            painter.drawRoundRect(rect, radius_x, radius_y)\n\n        label_rect = QtCore.QRectF(rect.left() + (radius_x / 2),\n                                   rect.top() + (radius_x / 2),\n                                   self._width - (radius_x / 1.25),\n                                   28)\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(label_rect, radius_x / 1.5, radius_y / 1.5)\n        painter.setBrush(QtGui.QColor(0, 0, 0, 50))\n        painter.fillPath(path, painter.brush())\n\n        border_width = 0.8\n        border_color = QtGui.QColor(*self.border_color)\n        if self.selected and NODE_SEL_BORDER_COLOR:\n            border_width = 1.2\n            border_color = QtGui.QColor(*NODE_SEL_BORDER_COLOR)\n        border_rect = QtCore.QRectF(rect.left() - (border_width / 2),\n                                    rect.top() - (border_width / 2),\n                                    rect.width() + border_width,\n                                    rect.height() + border_width)\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(border_rect, radius_x, radius_y)\n        painter.setBrush(QtCore.Qt.NoBrush)\n        painter.setPen(QtGui.QPen(border_color, border_width))\n        painter.drawPath(path)\n\n        painter.restore()\n\n    def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            start = PortItem().boundingRect().width()\n            end = self.boundingRect().width() - start\n            x_pos = event.pos().x()\n            if not start <= x_pos <= end:\n                event.ignore()\n        super(NodeItem, self).mousePressEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if event.modifiers() == QtCore.Qt.AltModifier:\n            event.ignore()\n            return\n        super(NodeItem, self).mouseReleaseEvent(event)\n\n    def itemChange(self, change, value):\n        if change == self.ItemSelectedChange and self.scene():\n            self.reset_pipes()\n            if value:\n                self.hightlight_pipes()\n            self.setZValue(Z_VAL_NODE)\n            if not self.selected:\n                self.setZValue(Z_VAL_NODE + 1)\n\n        return super(NodeItem, self).itemChange(change, value)\n\n    def _tooltip_disable(self, state):\n        tooltip = '<b>{}</b>'.format(self._properties['name'])\n        if state:\n            tooltip += ' <font color=\"red\"><b>(DISABLED)</b></font>'\n        tooltip += '<br/>{}<br/>'.format(self._properties['type'])\n        self.setToolTip(tooltip)\n\n    def _set_base_size(self):\n        \"\"\"\n        setup initial base size.\n        \"\"\"\n        width, height = self.calc_size()\n        if width > self._width:\n            self._width = width\n        if height > self._height:\n            self._height = height\n\n    def _set_text_color(self, color):\n        \"\"\"\n        set text color.\n\n        Args:\n            color (tuple): color value in (r, g, b, a).\n        \"\"\"\n        text_color = QtGui.QColor(*color)\n        for port, text in self._input_items.items():\n            text.setDefaultTextColor(text_color)\n        for port, text in self._output_items.items():\n            text.setDefaultTextColor(text_color)\n        self._text_item.setDefaultTextColor(text_color)\n\n    def activate_pipes(self):\n        \"\"\"\n        active pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.activate()\n\n    def hightlight_pipes(self):\n        \"\"\"\n        highlight pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.highlight()\n\n    def reset_pipes(self):\n        \"\"\"\n        reset the pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.reset()\n\n    def calc_size(self):\n        \"\"\"\n        calculate minimum node size.\n        \"\"\"\n        width = 0.0\n        if self._widgets:\n            widget_widths = [\n                w.boundingRect().width() for w in self._widgets.values()]\n            width = max(widget_widths)\n        if self._text_item.boundingRect().width() > width:\n            width = self._text_item.boundingRect().width()\n\n        port_height = 0.0\n        if self._input_items:\n            input_widths = []\n            for port, text in self._input_items.items():\n                input_width = port.boundingRect().width() * 2\n                if text.isVisible():\n                    input_width += text.boundingRect().width()\n                input_widths.append(input_width)\n            width += max(input_widths)\n            port = list(self._input_items.keys())[0]\n            port_height = port.boundingRect().height() * 2\n        if self._output_items:\n            output_widths = []\n            for port, text in self._output_items.items():\n                output_width = port.boundingRect().width() * 2\n                if text.isVisible():\n                    output_width += text.boundingRect().width()\n                output_widths.append(output_width)\n            width += max(output_widths)\n            port = list(self._output_items.keys())[0]\n            port_height = port.boundingRect().height() * 2\n\n        height = port_height * (max([len(self.inputs), len(self.outputs)]) + 2)\n        if self._widgets:\n            wid_height = sum(\n                [w.boundingRect().height() for w in self._widgets.values()])\n            if wid_height > height:\n                height = wid_height + (wid_height / len(self._widgets))\n\n        height += 10\n\n        return width, height\n\n    def arrange_icon(self):\n        \"\"\"\n        Arrange node icon to the default top left of the node.\n        \"\"\"\n        self._icon_item.setPos(2.0, 2.0)\n\n    def arrange_label(self):\n        \"\"\"\n        Arrange node label to the default top center of the node.\n        \"\"\"\n        text_rect = self._text_item.boundingRect()\n        text_x = (self._width / 2) - (text_rect.width() / 2)\n        self._text_item.setPos(text_x, 1.0)\n\n    def arrange_widgets(self):\n        \"\"\"\n        Arrange node widgets to the default center of the node.\n        \"\"\"\n        if not self._widgets:\n            return\n        wid_heights = sum(\n            [w.boundingRect().height() for w in self._widgets.values()])\n        pos_y = self._height / 2\n        pos_y -= wid_heights / 2\n        for name, widget in self._widgets.items():\n            rect = widget.boundingRect()\n            pos_x = (self._width / 2) - (rect.width() / 2)\n            widget.setPos(pos_x, pos_y)\n            pos_y += rect.height()\n\n    def arrange_ports(self, padding_x=0.0, padding_y=0.0):\n        \"\"\"\n        Arrange input, output ports in the node layout.\n    \n        Args:\n            padding_x (float): horizontal padding.\n            padding_y: (float): vertical padding.\n        \"\"\"\n        width = self._width - padding_x\n        height = self._height - padding_y\n\n        # adjust input position\n        if self.inputs:\n            port_width = self.inputs[0].boundingRect().width()\n            port_height = self.inputs[0].boundingRect().height()\n            chunk = (height / len(self.inputs))\n            port_x = (port_width / 2) * -1\n            port_y = (chunk / 2) - (port_height / 2)\n            for port in self.inputs:\n                port.setPos(port_x + padding_x, port_y + (padding_y / 2))\n                port_y += chunk\n        # adjust input text position\n        for port, text in self._input_items.items():\n            txt_height = text.boundingRect().height() - 8.0\n            txt_x = port.x() + port.boundingRect().width()\n            txt_y = port.y() - (txt_height / 2)\n            text.setPos(txt_x + 3.0, txt_y)\n        # adjust output position\n        if self.outputs:\n            port_width = self.outputs[0].boundingRect().width()\n            port_height = self.outputs[0].boundingRect().height()\n            chunk = height / len(self.outputs)\n            port_x = width - (port_width / 2)\n            port_y = (chunk / 2) - (port_height / 2)\n            for port in self.outputs:\n                port.setPos(port_x, port_y + (padding_y / 2))\n                port_y += chunk\n        # adjust output text position\n        for port, text in self._output_items.items():\n            txt_width = text.boundingRect().width()\n            txt_height = text.boundingRect().height() - 8.0\n            txt_x = width - txt_width - (port.boundingRect().width() / 2)\n            txt_y = port.y() - (txt_height / 2)\n            text.setPos(txt_x - 1.0, txt_y)\n\n    def offset_icon(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the icon in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        if self._icon_item:\n            icon_x = self._icon_item.pos().x() + x\n            icon_y = self._icon_item.pos().y() + y\n            self._icon_item.setPos(icon_x, icon_y)\n\n    def offset_label(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the label in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        icon_x = self._text_item.pos().x() + x\n        icon_y = self._text_item.pos().y() + y\n        self._text_item.setPos(icon_x, icon_y)\n\n    def offset_widgets(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the node widgets in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        for name, widget in self._widgets.items():\n            pos_x = widget.pos().x()\n            pos_y = widget.pos().y()\n            widget.setPos(pos_x + x, pos_y + y)\n\n    def offset_ports(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the ports in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        for port, text in self._input_items.items():\n            port_x, port_y = port.pos().x(), port.pos().y()\n            text_x, text_y = text.pos().x(), text.pos().y()\n            port.setPos(port_x + x, port_y + y)\n            text.setPos(text_x + x, text_y + y)\n        for port, text in self._output_items.items():\n            port_x, port_y = port.pos().x(), port.pos().y()\n            text_x, text_y = text.pos().x(), text.pos().y()\n            port.setPos(port_x + x, port_y + y)\n            text.setPos(text_x + x, text_y + y)\n\n    def post_init(self, viewer=None, pos=None):\n        \"\"\"\n        Called after node has been added into the scene.\n        Adjust the node layout and form after the node has been added.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): not used\n            pos (tuple): cursor position.\n        \"\"\"\n        # set initial node position.\n        if pos:\n            self.setPos(pos[0], pos[1])\n\n        # setup initial base size.\n        self._set_base_size()\n        # set text color when node is initialized.\n        self._set_text_color(self.text_color)\n        # set the tooltip\n        self._tooltip_disable(self.disabled)\n\n        # setup node layout\n        # =================\n\n        # arrange label text\n        self.arrange_label()\n        self.offset_label(0.0, 5.0)\n\n        # arrange icon\n        self.arrange_icon()\n        self.offset_icon(5.0, 2.0)\n\n        # arrange node widgets\n        self.arrange_widgets()\n        self.offset_widgets(0.0, 10.0)\n\n        # arrange input and output ports.\n        self.arrange_ports(padding_y=35.0)\n        self.offset_ports(0.0, 15.0)\n\n    @property\n    def icon(self):\n        return self._properties['icon']\n\n    @icon.setter\n    def icon(self, path=None):\n        self._properties['icon'] = path\n        path = path or ICON_NODE_BASE\n        pixmap = QtGui.QPixmap(path)\n        pixmap = pixmap.scaledToHeight(NODE_ICON_SIZE,\n                                       QtCore.Qt.SmoothTransformation)\n        self._icon_item.setPixmap(pixmap)\n        if self.scene():\n            self.post_init()\n\n    @AbstractNodeItem.width.setter\n    def width(self, width=0.0):\n        w, h = self.calc_size()\n        # self._width = width if width > w else w\n        width = width if width > w else w\n        AbstractNodeItem.width.fset(self, width)\n\n    @AbstractNodeItem.height.setter\n    def height(self, height=0.0):\n        w, h = self.calc_size()\n        h = 70 if h < 70 else h\n        # self._height = height if height > h else h\n        height = height if height > h else h\n        AbstractNodeItem.height.fset(self, height)\n\n    @AbstractNodeItem.disabled.setter\n    def disabled(self, state=False):\n        AbstractNodeItem.disabled.fset(self, state)\n        for n, w in self._widgets.items():\n            w.widget.setDisabled(state)\n        self._tooltip_disable(state)\n        self._x_item.setVisible(state)\n\n    @AbstractNodeItem.selected.setter\n    def selected(self, selected=False):\n        AbstractNodeItem.selected.fset(self, selected)\n        if selected:\n            self.hightlight_pipes()\n\n    @AbstractNodeItem.name.setter\n    def name(self, name=''):\n        AbstractNodeItem.name.fset(self, name)\n        self._text_item.setPlainText(name)\n        if self.scene():\n            self.post_init()\n\n    @property\n    def inputs(self):\n        return list(self._input_items.keys())\n\n    @property\n    def outputs(self):\n        return list(self._output_items.keys())\n\n    def add_input(self, name='input', multi_port=False, display_name=True):\n        \"\"\"\n        Args:\n            name (str): name for the port.\n            multi_port (bool): allow multiple connections.\n            display_name (bool): display the port name. \n\n        Returns:\n            PortItem: input item widget\n        \"\"\"\n        port = PortItem(self)\n        port.name = name\n        port.port_type = IN_PORT\n        port.multi_connection = multi_port\n        port.display_name = display_name\n        text = QGraphicsTextItem(port.name, self)\n        text.font().setPointSize(8)\n        text.setFont(text.font())\n        text.setVisible(display_name)\n        self._input_items[port] = text\n        if self.scene():\n            self.post_init()\n        return port\n\n    def add_output(self, name='output', multi_port=False, display_name=True):\n        \"\"\"\n        Args:\n            name (str): name for the port.\n            multi_port (bool): allow multiple connections.\n            display_name (bool): display the port name. \n\n        Returns:\n            PortItem: output item widget\n        \"\"\"\n        port = PortItem(self)\n        port.name = name\n        port.port_type = OUT_PORT\n        port.multi_connection = multi_port\n        port.display_name = display_name\n        text = QGraphicsTextItem(port.name, self)\n        text.font().setPointSize(8)\n        text.setFont(text.font())\n        text.setVisible(display_name)\n        self._output_items[port] = text\n        if self.scene():\n            self.post_init()\n        return port\n\n    @property\n    def widgets(self):\n        return dict(self._widgets)\n\n    def add_combo_menu(self, name='', label='', items=None, tooltip=''):\n        items = items or []\n        widget = NodeComboBox(self, name, label, items)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget\n\n    def add_text_input(self, name='', label='', text='', tooltip=''):\n        widget = NodeLineEdit(self, name, label, text)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget\n\n    def add_checkbox(self, name='', label='', text='', state=False, tooltip=''):\n        widget = NodeCheckBox(self, name, label, text, state)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget\n\n    def add_widget(self, widget):\n        if isinstance(widget, NodeBaseWidget):\n            self._widgets[widget.name] = widget\n        else:\n            raise TypeError('{} is not an instance of a node widget.')\n\n    def get_widget(self, name):\n        widget = self._widgets.get(name)\n        if widget:\n            return widget\n        raise KeyError('node has no widget \"{}\"'.format(name))\n\n    def delete(self):\n        for port, text in self._input_items.items():\n            port.delete()\n        for port, text in self._output_items.items():\n            port.delete()\n        super(NodeItem, self).delete()\n\n    def from_dict(self, node_dict):\n        super(NodeItem, self).from_dict(node_dict)\n        widgets = node_dict.pop('widgets', {})\n        for name, value in widgets.items():\n            if self._widgets.get(name):\n                self._widgets[name].value = value",
  "def __init__(self, parent=None, text=None):\n        super(XDisabledItem, self).__init__(parent)\n        self.setZValue(Z_VAL_NODE_WIDGET + 2)\n        self.setVisible(False)\n        self.color = (0, 0, 0, 255)\n        self.text = text",
  "def boundingRect(self):\n        return self.parentItem().boundingRect()",
  "def paint(self, painter, option, widget):\n        painter.save()\n\n        margin = 20\n        rect = self.boundingRect()\n        dis_rect = QtCore.QRectF(rect.left() - (margin / 2),\n                                 rect.top() - (margin / 2),\n                                 rect.width() + margin,\n                                 rect.height() + margin)\n        pen = QtGui.QPen(QtGui.QColor(*self.color), 8)\n        pen.setCapStyle(QtCore.Qt.RoundCap)\n        painter.setPen(pen)\n        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())\n        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())\n\n        bg_color = QtGui.QColor(*self.color)\n        bg_color.setAlpha(100)\n        bg_margin = -0.5\n        bg_rect = QtCore.QRectF(dis_rect.left() - (bg_margin / 2),\n                                dis_rect.top() - (bg_margin / 2),\n                                dis_rect.width() + bg_margin,\n                                dis_rect.height() + bg_margin)\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 0)))\n        painter.setBrush(bg_color)\n        painter.drawRoundedRect(bg_rect, 5, 5)\n\n        pen = QtGui.QPen(QtGui.QColor(155, 0, 0, 255), 0.7)\n        painter.setPen(pen)\n        painter.drawLine(dis_rect.topLeft(), dis_rect.bottomRight())\n        painter.drawLine(dis_rect.topRight(), dis_rect.bottomLeft())\n\n        point_size = 4.0\n        point_pos = (dis_rect.topLeft(), dis_rect.topRight(),\n                     dis_rect.bottomLeft(), dis_rect.bottomRight())\n        painter.setBrush(QtGui.QColor(255, 0, 0, 255))\n        for p in point_pos:\n            p.setX(p.x() - (point_size / 2))\n            p.setY(p.y() - (point_size / 2))\n            point_rect = QtCore.QRectF(\n                p, QtCore.QSizeF(point_size, point_size))\n            painter.drawEllipse(point_rect)\n\n        if self.text:\n            font = painter.font()\n            font.setPointSize(10)\n\n            painter.setFont(font)\n            font_metrics = QtGui.QFontMetrics(font)\n            font_width = font_metrics.width(self.text)\n            font_height = font_metrics.height()\n            txt_w = font_width * 1.25\n            txt_h = font_height * 2.25\n            text_bg_rect = QtCore.QRectF((rect.width() / 2) - (txt_w / 2),\n                                         (rect.height() / 2) - (txt_h / 2),\n                                         txt_w, txt_h)\n            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 0.5))\n            painter.setBrush(QtGui.QColor(*self.color))\n            painter.drawRoundedRect(text_bg_rect, 2, 2)\n\n            text_rect = QtCore.QRectF((rect.width() / 2) - (font_width / 2),\n                                      (rect.height() / 2) - (font_height / 2),\n                                      txt_w * 2, font_height * 2)\n\n            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0), 1))\n            painter.drawText(text_rect, self.text)\n\n        painter.restore()",
  "def __init__(self, name='node', parent=None):\n        super(NodeItem, self).__init__(name, parent)\n        pixmap = QtGui.QPixmap(ICON_NODE_BASE)\n        pixmap = pixmap.scaledToHeight(NODE_ICON_SIZE,\n                                       QtCore.Qt.SmoothTransformation)\n        self._properties['icon'] = ICON_NODE_BASE\n        self._icon_item = QGraphicsPixmapItem(pixmap, self)\n        self._text_item = QGraphicsTextItem(self.name, self)\n        self._x_item = XDisabledItem(self, 'node disabled')\n        self._input_items = {}\n        self._output_items = {}\n        self._widgets = {}",
  "def paint(self, painter, option, widget):\n        painter.save()\n\n        bg_border = 1.0\n        rect = QtCore.QRectF(0.5 - (bg_border / 2),\n                             0.5 - (bg_border / 2),\n                             self._width + bg_border,\n                             self._height + bg_border)\n        radius_x = 5\n        radius_y = 5\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(rect, radius_x, radius_y)\n        painter.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 255), 1.5))\n        painter.drawPath(path)\n\n        rect = self.boundingRect()\n        bg_color = QtGui.QColor(*self.color)\n        painter.setBrush(bg_color)\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRoundRect(rect, radius_x, radius_y)\n\n        if self.selected and NODE_SEL_COLOR:\n            painter.setBrush(QtGui.QColor(*NODE_SEL_COLOR))\n            painter.drawRoundRect(rect, radius_x, radius_y)\n\n        label_rect = QtCore.QRectF(rect.left() + (radius_x / 2),\n                                   rect.top() + (radius_x / 2),\n                                   self._width - (radius_x / 1.25),\n                                   28)\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(label_rect, radius_x / 1.5, radius_y / 1.5)\n        painter.setBrush(QtGui.QColor(0, 0, 0, 50))\n        painter.fillPath(path, painter.brush())\n\n        border_width = 0.8\n        border_color = QtGui.QColor(*self.border_color)\n        if self.selected and NODE_SEL_BORDER_COLOR:\n            border_width = 1.2\n            border_color = QtGui.QColor(*NODE_SEL_BORDER_COLOR)\n        border_rect = QtCore.QRectF(rect.left() - (border_width / 2),\n                                    rect.top() - (border_width / 2),\n                                    rect.width() + border_width,\n                                    rect.height() + border_width)\n        path = QtGui.QPainterPath()\n        path.addRoundedRect(border_rect, radius_x, radius_y)\n        painter.setBrush(QtCore.Qt.NoBrush)\n        painter.setPen(QtGui.QPen(border_color, border_width))\n        painter.drawPath(path)\n\n        painter.restore()",
  "def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            start = PortItem().boundingRect().width()\n            end = self.boundingRect().width() - start\n            x_pos = event.pos().x()\n            if not start <= x_pos <= end:\n                event.ignore()\n        super(NodeItem, self).mousePressEvent(event)",
  "def mouseReleaseEvent(self, event):\n        if event.modifiers() == QtCore.Qt.AltModifier:\n            event.ignore()\n            return\n        super(NodeItem, self).mouseReleaseEvent(event)",
  "def itemChange(self, change, value):\n        if change == self.ItemSelectedChange and self.scene():\n            self.reset_pipes()\n            if value:\n                self.hightlight_pipes()\n            self.setZValue(Z_VAL_NODE)\n            if not self.selected:\n                self.setZValue(Z_VAL_NODE + 1)\n\n        return super(NodeItem, self).itemChange(change, value)",
  "def _tooltip_disable(self, state):\n        tooltip = '<b>{}</b>'.format(self._properties['name'])\n        if state:\n            tooltip += ' <font color=\"red\"><b>(DISABLED)</b></font>'\n        tooltip += '<br/>{}<br/>'.format(self._properties['type'])\n        self.setToolTip(tooltip)",
  "def _set_base_size(self):\n        \"\"\"\n        setup initial base size.\n        \"\"\"\n        width, height = self.calc_size()\n        if width > self._width:\n            self._width = width\n        if height > self._height:\n            self._height = height",
  "def _set_text_color(self, color):\n        \"\"\"\n        set text color.\n\n        Args:\n            color (tuple): color value in (r, g, b, a).\n        \"\"\"\n        text_color = QtGui.QColor(*color)\n        for port, text in self._input_items.items():\n            text.setDefaultTextColor(text_color)\n        for port, text in self._output_items.items():\n            text.setDefaultTextColor(text_color)\n        self._text_item.setDefaultTextColor(text_color)",
  "def activate_pipes(self):\n        \"\"\"\n        active pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.activate()",
  "def hightlight_pipes(self):\n        \"\"\"\n        highlight pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.highlight()",
  "def reset_pipes(self):\n        \"\"\"\n        reset the pipe color.\n        \"\"\"\n        ports = self.inputs + self.outputs\n        for port in ports:\n            for pipe in port.connected_pipes:\n                pipe.reset()",
  "def calc_size(self):\n        \"\"\"\n        calculate minimum node size.\n        \"\"\"\n        width = 0.0\n        if self._widgets:\n            widget_widths = [\n                w.boundingRect().width() for w in self._widgets.values()]\n            width = max(widget_widths)\n        if self._text_item.boundingRect().width() > width:\n            width = self._text_item.boundingRect().width()\n\n        port_height = 0.0\n        if self._input_items:\n            input_widths = []\n            for port, text in self._input_items.items():\n                input_width = port.boundingRect().width() * 2\n                if text.isVisible():\n                    input_width += text.boundingRect().width()\n                input_widths.append(input_width)\n            width += max(input_widths)\n            port = list(self._input_items.keys())[0]\n            port_height = port.boundingRect().height() * 2\n        if self._output_items:\n            output_widths = []\n            for port, text in self._output_items.items():\n                output_width = port.boundingRect().width() * 2\n                if text.isVisible():\n                    output_width += text.boundingRect().width()\n                output_widths.append(output_width)\n            width += max(output_widths)\n            port = list(self._output_items.keys())[0]\n            port_height = port.boundingRect().height() * 2\n\n        height = port_height * (max([len(self.inputs), len(self.outputs)]) + 2)\n        if self._widgets:\n            wid_height = sum(\n                [w.boundingRect().height() for w in self._widgets.values()])\n            if wid_height > height:\n                height = wid_height + (wid_height / len(self._widgets))\n\n        height += 10\n\n        return width, height",
  "def arrange_icon(self):\n        \"\"\"\n        Arrange node icon to the default top left of the node.\n        \"\"\"\n        self._icon_item.setPos(2.0, 2.0)",
  "def arrange_label(self):\n        \"\"\"\n        Arrange node label to the default top center of the node.\n        \"\"\"\n        text_rect = self._text_item.boundingRect()\n        text_x = (self._width / 2) - (text_rect.width() / 2)\n        self._text_item.setPos(text_x, 1.0)",
  "def arrange_widgets(self):\n        \"\"\"\n        Arrange node widgets to the default center of the node.\n        \"\"\"\n        if not self._widgets:\n            return\n        wid_heights = sum(\n            [w.boundingRect().height() for w in self._widgets.values()])\n        pos_y = self._height / 2\n        pos_y -= wid_heights / 2\n        for name, widget in self._widgets.items():\n            rect = widget.boundingRect()\n            pos_x = (self._width / 2) - (rect.width() / 2)\n            widget.setPos(pos_x, pos_y)\n            pos_y += rect.height()",
  "def arrange_ports(self, padding_x=0.0, padding_y=0.0):\n        \"\"\"\n        Arrange input, output ports in the node layout.\n    \n        Args:\n            padding_x (float): horizontal padding.\n            padding_y: (float): vertical padding.\n        \"\"\"\n        width = self._width - padding_x\n        height = self._height - padding_y\n\n        # adjust input position\n        if self.inputs:\n            port_width = self.inputs[0].boundingRect().width()\n            port_height = self.inputs[0].boundingRect().height()\n            chunk = (height / len(self.inputs))\n            port_x = (port_width / 2) * -1\n            port_y = (chunk / 2) - (port_height / 2)\n            for port in self.inputs:\n                port.setPos(port_x + padding_x, port_y + (padding_y / 2))\n                port_y += chunk\n        # adjust input text position\n        for port, text in self._input_items.items():\n            txt_height = text.boundingRect().height() - 8.0\n            txt_x = port.x() + port.boundingRect().width()\n            txt_y = port.y() - (txt_height / 2)\n            text.setPos(txt_x + 3.0, txt_y)\n        # adjust output position\n        if self.outputs:\n            port_width = self.outputs[0].boundingRect().width()\n            port_height = self.outputs[0].boundingRect().height()\n            chunk = height / len(self.outputs)\n            port_x = width - (port_width / 2)\n            port_y = (chunk / 2) - (port_height / 2)\n            for port in self.outputs:\n                port.setPos(port_x, port_y + (padding_y / 2))\n                port_y += chunk\n        # adjust output text position\n        for port, text in self._output_items.items():\n            txt_width = text.boundingRect().width()\n            txt_height = text.boundingRect().height() - 8.0\n            txt_x = width - txt_width - (port.boundingRect().width() / 2)\n            txt_y = port.y() - (txt_height / 2)\n            text.setPos(txt_x - 1.0, txt_y)",
  "def offset_icon(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the icon in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        if self._icon_item:\n            icon_x = self._icon_item.pos().x() + x\n            icon_y = self._icon_item.pos().y() + y\n            self._icon_item.setPos(icon_x, icon_y)",
  "def offset_label(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the label in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        icon_x = self._text_item.pos().x() + x\n        icon_y = self._text_item.pos().y() + y\n        self._text_item.setPos(icon_x, icon_y)",
  "def offset_widgets(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the node widgets in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        for name, widget in self._widgets.items():\n            pos_x = widget.pos().x()\n            pos_y = widget.pos().y()\n            widget.setPos(pos_x + x, pos_y + y)",
  "def offset_ports(self, x=0.0, y=0.0):\n        \"\"\"\n        offset the ports in the node layout.\n\n        Args:\n            x (float): horizontal x offset\n            y (float): vertical y offset\n        \"\"\"\n        for port, text in self._input_items.items():\n            port_x, port_y = port.pos().x(), port.pos().y()\n            text_x, text_y = text.pos().x(), text.pos().y()\n            port.setPos(port_x + x, port_y + y)\n            text.setPos(text_x + x, text_y + y)\n        for port, text in self._output_items.items():\n            port_x, port_y = port.pos().x(), port.pos().y()\n            text_x, text_y = text.pos().x(), text.pos().y()\n            port.setPos(port_x + x, port_y + y)\n            text.setPos(text_x + x, text_y + y)",
  "def post_init(self, viewer=None, pos=None):\n        \"\"\"\n        Called after node has been added into the scene.\n        Adjust the node layout and form after the node has been added.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): not used\n            pos (tuple): cursor position.\n        \"\"\"\n        # set initial node position.\n        if pos:\n            self.setPos(pos[0], pos[1])\n\n        # setup initial base size.\n        self._set_base_size()\n        # set text color when node is initialized.\n        self._set_text_color(self.text_color)\n        # set the tooltip\n        self._tooltip_disable(self.disabled)\n\n        # setup node layout\n        # =================\n\n        # arrange label text\n        self.arrange_label()\n        self.offset_label(0.0, 5.0)\n\n        # arrange icon\n        self.arrange_icon()\n        self.offset_icon(5.0, 2.0)\n\n        # arrange node widgets\n        self.arrange_widgets()\n        self.offset_widgets(0.0, 10.0)\n\n        # arrange input and output ports.\n        self.arrange_ports(padding_y=35.0)\n        self.offset_ports(0.0, 15.0)",
  "def icon(self):\n        return self._properties['icon']",
  "def icon(self, path=None):\n        self._properties['icon'] = path\n        path = path or ICON_NODE_BASE\n        pixmap = QtGui.QPixmap(path)\n        pixmap = pixmap.scaledToHeight(NODE_ICON_SIZE,\n                                       QtCore.Qt.SmoothTransformation)\n        self._icon_item.setPixmap(pixmap)\n        if self.scene():\n            self.post_init()",
  "def width(self, width=0.0):\n        w, h = self.calc_size()\n        # self._width = width if width > w else w\n        width = width if width > w else w\n        AbstractNodeItem.width.fset(self, width)",
  "def height(self, height=0.0):\n        w, h = self.calc_size()\n        h = 70 if h < 70 else h\n        # self._height = height if height > h else h\n        height = height if height > h else h\n        AbstractNodeItem.height.fset(self, height)",
  "def disabled(self, state=False):\n        AbstractNodeItem.disabled.fset(self, state)\n        for n, w in self._widgets.items():\n            w.widget.setDisabled(state)\n        self._tooltip_disable(state)\n        self._x_item.setVisible(state)",
  "def selected(self, selected=False):\n        AbstractNodeItem.selected.fset(self, selected)\n        if selected:\n            self.hightlight_pipes()",
  "def name(self, name=''):\n        AbstractNodeItem.name.fset(self, name)\n        self._text_item.setPlainText(name)\n        if self.scene():\n            self.post_init()",
  "def inputs(self):\n        return list(self._input_items.keys())",
  "def outputs(self):\n        return list(self._output_items.keys())",
  "def add_input(self, name='input', multi_port=False, display_name=True):\n        \"\"\"\n        Args:\n            name (str): name for the port.\n            multi_port (bool): allow multiple connections.\n            display_name (bool): display the port name. \n\n        Returns:\n            PortItem: input item widget\n        \"\"\"\n        port = PortItem(self)\n        port.name = name\n        port.port_type = IN_PORT\n        port.multi_connection = multi_port\n        port.display_name = display_name\n        text = QGraphicsTextItem(port.name, self)\n        text.font().setPointSize(8)\n        text.setFont(text.font())\n        text.setVisible(display_name)\n        self._input_items[port] = text\n        if self.scene():\n            self.post_init()\n        return port",
  "def add_output(self, name='output', multi_port=False, display_name=True):\n        \"\"\"\n        Args:\n            name (str): name for the port.\n            multi_port (bool): allow multiple connections.\n            display_name (bool): display the port name. \n\n        Returns:\n            PortItem: output item widget\n        \"\"\"\n        port = PortItem(self)\n        port.name = name\n        port.port_type = OUT_PORT\n        port.multi_connection = multi_port\n        port.display_name = display_name\n        text = QGraphicsTextItem(port.name, self)\n        text.font().setPointSize(8)\n        text.setFont(text.font())\n        text.setVisible(display_name)\n        self._output_items[port] = text\n        if self.scene():\n            self.post_init()\n        return port",
  "def widgets(self):\n        return dict(self._widgets)",
  "def add_combo_menu(self, name='', label='', items=None, tooltip=''):\n        items = items or []\n        widget = NodeComboBox(self, name, label, items)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget",
  "def add_text_input(self, name='', label='', text='', tooltip=''):\n        widget = NodeLineEdit(self, name, label, text)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget",
  "def add_checkbox(self, name='', label='', text='', state=False, tooltip=''):\n        widget = NodeCheckBox(self, name, label, text, state)\n        widget.setToolTip(tooltip)\n        self.add_widget(widget)\n        return widget",
  "def add_widget(self, widget):\n        if isinstance(widget, NodeBaseWidget):\n            self._widgets[widget.name] = widget\n        else:\n            raise TypeError('{} is not an instance of a node widget.')",
  "def get_widget(self, name):\n        widget = self._widgets.get(name)\n        if widget:\n            return widget\n        raise KeyError('node has no widget \"{}\"'.format(name))",
  "def delete(self):\n        for port, text in self._input_items.items():\n            port.delete()\n        for port, text in self._output_items.items():\n            port.delete()\n        super(NodeItem, self).delete()",
  "def from_dict(self, node_dict):\n        super(NodeItem, self).from_dict(node_dict)\n        widgets = node_dict.pop('widgets', {})\n        for name, value in widgets.items():\n            if self._widgets.get(name):\n                self._widgets[name].value = value",
  "class BackdropSizer(QGraphicsItem):\n\n    def __init__(self, parent=None, size=6.0):\n        super(BackdropSizer, self).__init__(parent)\n        self.setFlag(self.ItemIsSelectable, True)\n        self.setFlag(self.ItemIsMovable, True)\n        self.setFlag(self.ItemSendsScenePositionChanges, True)\n        self.setCursor(QtGui.QCursor(QtCore.Qt.SizeFDiagCursor))\n        self.setToolTip('double-click auto resize')\n        self._size = size\n\n    @property\n    def size(self):\n        return self._size\n\n    def set_pos(self, x, y):\n        x -= self._size\n        y -= self._size\n        self.setPos(x, y)\n\n    def boundingRect(self):\n        return QtCore.QRectF(0.5, 0.5, self._size, self._size)\n\n    def itemChange(self, change, value):\n        if change == self.ItemPositionChange:\n            item = self.parentItem()\n            mx, my = item.minimum_size\n            x = mx if value.x() < mx else value.x()\n            y = my if value.y() < my else value.y()\n            value = QtCore.QPointF(x, y)\n            item.on_sizer_pos_changed(value)\n            return value\n        return super(BackdropSizer, self).itemChange(change, value)\n\n    def mouseDoubleClickEvent(self, event):\n        item = self.parentItem()\n        item.on_sizer_double_clicked()\n\n    def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = self.boundingRect()\n        item = self.parentItem()\n        if item and item.selected:\n            color = QtGui.QColor(*NODE_SEL_BORDER_COLOR)\n        else:\n            color = QtGui.QColor(*item.color)\n            color = color.darker(110)\n        path = QtGui.QPainterPath()\n        path.moveTo(rect.topRight())\n        path.lineTo(rect.bottomRight())\n        path.lineTo(rect.bottomLeft())\n        painter.setBrush(color)\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.fillPath(path, painter.brush())\n\n        painter.restore()",
  "class BackdropNodeItem(AbstractNodeItem):\n    \"\"\"\n    Base Backdrop item.\n    \"\"\"\n\n    def __init__(self, name='backdrop', text='', parent=None):\n        super(BackdropNodeItem, self).__init__(name, parent)\n        self.setZValue(Z_VAL_PIPE - 1)\n        self._properties['backdrop_text'] = text\n        self._min_size = 80, 80\n        self._sizer = BackdropSizer(self, 20.0)\n        self._sizer.set_pos(*self._min_size)\n        self._nodes = [self]\n\n    def _combined_rect(self, nodes):\n        group = self.scene().createItemGroup(nodes)\n        rect = group.boundingRect()\n        self.scene().destroyItemGroup(group)\n        return rect\n\n    def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            pos = event.scenePos()\n            rect = QtCore.QRectF(pos.x() - 5, pos.y() - 5, 10, 10)\n            item = self.scene().items(rect)[0]\n\n            if isinstance(item, (PortItem, Pipe)):\n                self.setFlag(self.ItemIsMovable, False)\n                return\n            if self.selected:\n                return\n\n            viewer = self.viewer()\n            [n.setSelected(False) for n in viewer.selected_nodes()]\n\n            self._nodes += self.get_nodes(False)\n            [n.setSelected(True) for n in self._nodes]\n\n    def mouseReleaseEvent(self, event):\n        super(BackdropNodeItem, self).mouseReleaseEvent(event)\n        self.setFlag(self.ItemIsMovable, True)\n        [n.setSelected(True) for n in self._nodes]\n        self._nodes = [self]\n\n    def on_sizer_pos_changed(self, pos):\n        self._width = pos.x() + self._sizer.size\n        self._height = pos.y() + self._sizer.size\n\n    def on_sizer_double_clicked(self):\n        self.auto_resize()\n\n    def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = self.boundingRect()\n        color = (self.color[0], self.color[1], self.color[2], 50)\n        painter.setBrush(QtGui.QColor(*color))\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRect(rect)\n\n        top_rect = QtCore.QRectF(0.0, 0.0, rect.width(), 20.0)\n        painter.setBrush(QtGui.QColor(*self.color))\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRect(top_rect)\n\n        if self.selected and NODE_SEL_COLOR:\n            sel_color = [x for x in NODE_SEL_COLOR]\n            sel_color[-1] = 10\n            painter.setBrush(QtGui.QColor(*sel_color))\n            painter.setPen(QtCore.Qt.NoPen)\n            painter.drawRect(rect)\n\n        txt_rect = QtCore.QRectF(top_rect.x(), top_rect.y() + 1.5,\n                                 rect.width(), top_rect.height())\n        painter.setPen(QtGui.QColor(*self.text_color))\n        painter.drawText(txt_rect, QtCore.Qt.AlignCenter, self.name)\n\n        path = QtGui.QPainterPath()\n        path.addRect(rect)\n        border_color = self.color\n        if self.selected and NODE_SEL_BORDER_COLOR:\n            border_color = NODE_SEL_BORDER_COLOR\n        painter.setBrush(QtCore.Qt.NoBrush)\n        painter.setPen(QtGui.QPen(QtGui.QColor(*border_color), 1))\n        painter.drawPath(path)\n\n        painter.restore()\n\n    def get_nodes(self, inc_intersects=False):\n        mode = {True: QtCore.Qt.IntersectsItemShape,\n                False: QtCore.Qt.ContainsItemShape}\n        nodes = []\n        if self.scene():\n            polygon = self.mapToScene(self.boundingRect())\n            rect = polygon.boundingRect()\n            items = self.scene().items(rect, mode=mode[inc_intersects])\n            for item in items:\n                if item == self or item == self._sizer:\n                    continue\n                if isinstance(item, AbstractNodeItem):\n                    nodes.append(item)\n        return nodes\n\n    def auto_resize(self, nodes=None):\n        nodes = nodes or self.get_nodes(True)\n        if nodes:\n            padding = 40\n            nodes_rect = self._combined_rect(nodes)\n            self.pos = [nodes_rect.x() - padding, nodes_rect.y() - padding]\n            self._sizer.set_pos(nodes_rect.width() + (padding * 2),\n                                nodes_rect.height() + (padding * 2))\n            return\n\n        width, height = self._min_size\n        self._sizer.set_pos(width, height)\n\n    def pre_init(self, viewer, pos=None):\n        \"\"\"\n        Called before node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer.\n            pos (tuple): cursor pos.\n        \"\"\"\n        nodes = viewer.selected_nodes()\n        if nodes:\n            padding = 40\n            scene = viewer.scene()\n            group = scene.createItemGroup(nodes)\n            rect = group.boundingRect()\n            scene.destroyItemGroup(group)\n            self.pos = [rect.x() - padding, rect.y() - padding]\n            self._sizer.set_pos(rect.width() + (padding * 2),\n                                rect.height() + (padding * 2))\n        else:\n            self.pos = pos\n\n    @property\n    def minimum_size(self):\n        return self._min_size\n\n    @minimum_size.setter\n    def minimum_size(self, size=(50, 50)):\n        self._min_size = size\n\n    @property\n    def backdrop_text(self):\n        return self._properties['backdrop_text']\n\n    @backdrop_text.setter\n    def backdrop_text(self, text):\n        self._properties['backdrop_text'] = text\n\n    @AbstractNodeItem.width.setter\n    def width(self, width=0.0):\n        AbstractNodeItem.width.fset(self, width)\n        self._sizer.set_pos(self._width, self._height)\n\n    @AbstractNodeItem.height.setter\n    def height(self, height=0.0):\n        AbstractNodeItem.height.fset(self, height)\n        self._sizer.set_pos(self._width, self._height)",
  "def __init__(self, parent=None, size=6.0):\n        super(BackdropSizer, self).__init__(parent)\n        self.setFlag(self.ItemIsSelectable, True)\n        self.setFlag(self.ItemIsMovable, True)\n        self.setFlag(self.ItemSendsScenePositionChanges, True)\n        self.setCursor(QtGui.QCursor(QtCore.Qt.SizeFDiagCursor))\n        self.setToolTip('double-click auto resize')\n        self._size = size",
  "def size(self):\n        return self._size",
  "def set_pos(self, x, y):\n        x -= self._size\n        y -= self._size\n        self.setPos(x, y)",
  "def boundingRect(self):\n        return QtCore.QRectF(0.5, 0.5, self._size, self._size)",
  "def itemChange(self, change, value):\n        if change == self.ItemPositionChange:\n            item = self.parentItem()\n            mx, my = item.minimum_size\n            x = mx if value.x() < mx else value.x()\n            y = my if value.y() < my else value.y()\n            value = QtCore.QPointF(x, y)\n            item.on_sizer_pos_changed(value)\n            return value\n        return super(BackdropSizer, self).itemChange(change, value)",
  "def mouseDoubleClickEvent(self, event):\n        item = self.parentItem()\n        item.on_sizer_double_clicked()",
  "def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = self.boundingRect()\n        item = self.parentItem()\n        if item and item.selected:\n            color = QtGui.QColor(*NODE_SEL_BORDER_COLOR)\n        else:\n            color = QtGui.QColor(*item.color)\n            color = color.darker(110)\n        path = QtGui.QPainterPath()\n        path.moveTo(rect.topRight())\n        path.lineTo(rect.bottomRight())\n        path.lineTo(rect.bottomLeft())\n        painter.setBrush(color)\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.fillPath(path, painter.brush())\n\n        painter.restore()",
  "def __init__(self, name='backdrop', text='', parent=None):\n        super(BackdropNodeItem, self).__init__(name, parent)\n        self.setZValue(Z_VAL_PIPE - 1)\n        self._properties['backdrop_text'] = text\n        self._min_size = 80, 80\n        self._sizer = BackdropSizer(self, 20.0)\n        self._sizer.set_pos(*self._min_size)\n        self._nodes = [self]",
  "def _combined_rect(self, nodes):\n        group = self.scene().createItemGroup(nodes)\n        rect = group.boundingRect()\n        self.scene().destroyItemGroup(group)\n        return rect",
  "def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            pos = event.scenePos()\n            rect = QtCore.QRectF(pos.x() - 5, pos.y() - 5, 10, 10)\n            item = self.scene().items(rect)[0]\n\n            if isinstance(item, (PortItem, Pipe)):\n                self.setFlag(self.ItemIsMovable, False)\n                return\n            if self.selected:\n                return\n\n            viewer = self.viewer()\n            [n.setSelected(False) for n in viewer.selected_nodes()]\n\n            self._nodes += self.get_nodes(False)\n            [n.setSelected(True) for n in self._nodes]",
  "def mouseReleaseEvent(self, event):\n        super(BackdropNodeItem, self).mouseReleaseEvent(event)\n        self.setFlag(self.ItemIsMovable, True)\n        [n.setSelected(True) for n in self._nodes]\n        self._nodes = [self]",
  "def on_sizer_pos_changed(self, pos):\n        self._width = pos.x() + self._sizer.size\n        self._height = pos.y() + self._sizer.size",
  "def on_sizer_double_clicked(self):\n        self.auto_resize()",
  "def paint(self, painter, option, widget):\n        painter.save()\n\n        rect = self.boundingRect()\n        color = (self.color[0], self.color[1], self.color[2], 50)\n        painter.setBrush(QtGui.QColor(*color))\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRect(rect)\n\n        top_rect = QtCore.QRectF(0.0, 0.0, rect.width(), 20.0)\n        painter.setBrush(QtGui.QColor(*self.color))\n        painter.setPen(QtCore.Qt.NoPen)\n        painter.drawRect(top_rect)\n\n        if self.selected and NODE_SEL_COLOR:\n            sel_color = [x for x in NODE_SEL_COLOR]\n            sel_color[-1] = 10\n            painter.setBrush(QtGui.QColor(*sel_color))\n            painter.setPen(QtCore.Qt.NoPen)\n            painter.drawRect(rect)\n\n        txt_rect = QtCore.QRectF(top_rect.x(), top_rect.y() + 1.5,\n                                 rect.width(), top_rect.height())\n        painter.setPen(QtGui.QColor(*self.text_color))\n        painter.drawText(txt_rect, QtCore.Qt.AlignCenter, self.name)\n\n        path = QtGui.QPainterPath()\n        path.addRect(rect)\n        border_color = self.color\n        if self.selected and NODE_SEL_BORDER_COLOR:\n            border_color = NODE_SEL_BORDER_COLOR\n        painter.setBrush(QtCore.Qt.NoBrush)\n        painter.setPen(QtGui.QPen(QtGui.QColor(*border_color), 1))\n        painter.drawPath(path)\n\n        painter.restore()",
  "def get_nodes(self, inc_intersects=False):\n        mode = {True: QtCore.Qt.IntersectsItemShape,\n                False: QtCore.Qt.ContainsItemShape}\n        nodes = []\n        if self.scene():\n            polygon = self.mapToScene(self.boundingRect())\n            rect = polygon.boundingRect()\n            items = self.scene().items(rect, mode=mode[inc_intersects])\n            for item in items:\n                if item == self or item == self._sizer:\n                    continue\n                if isinstance(item, AbstractNodeItem):\n                    nodes.append(item)\n        return nodes",
  "def auto_resize(self, nodes=None):\n        nodes = nodes or self.get_nodes(True)\n        if nodes:\n            padding = 40\n            nodes_rect = self._combined_rect(nodes)\n            self.pos = [nodes_rect.x() - padding, nodes_rect.y() - padding]\n            self._sizer.set_pos(nodes_rect.width() + (padding * 2),\n                                nodes_rect.height() + (padding * 2))\n            return\n\n        width, height = self._min_size\n        self._sizer.set_pos(width, height)",
  "def pre_init(self, viewer, pos=None):\n        \"\"\"\n        Called before node has been added into the scene.\n\n        Args:\n            viewer (NodeGraphQt.widgets.viewer.NodeViewer): main viewer.\n            pos (tuple): cursor pos.\n        \"\"\"\n        nodes = viewer.selected_nodes()\n        if nodes:\n            padding = 40\n            scene = viewer.scene()\n            group = scene.createItemGroup(nodes)\n            rect = group.boundingRect()\n            scene.destroyItemGroup(group)\n            self.pos = [rect.x() - padding, rect.y() - padding]\n            self._sizer.set_pos(rect.width() + (padding * 2),\n                                rect.height() + (padding * 2))\n        else:\n            self.pos = pos",
  "def minimum_size(self):\n        return self._min_size",
  "def minimum_size(self, size=(50, 50)):\n        self._min_size = size",
  "def backdrop_text(self):\n        return self._properties['backdrop_text']",
  "def backdrop_text(self, text):\n        self._properties['backdrop_text'] = text",
  "def width(self, width=0.0):\n        AbstractNodeItem.width.fset(self, width)\n        self._sizer.set_pos(self._width, self._height)",
  "def height(self, height=0.0):\n        AbstractNodeItem.height.fset(self, height)\n        self._sizer.set_pos(self._width, self._height)",
  "class NodeScene(QtWidgets.QGraphicsScene):\n\n    def __init__(self, parent=None):\n        super(NodeScene, self).__init__(parent)\n        self.background_color = VIEWER_BG_COLOR\n        self.grid = VIEWER_GRID_OVERLAY\n        self.grid_color = VIEWER_GRID_COLOR\n\n    def __repr__(self):\n        return '{}.{}(\\'{}\\')'.format(self.__module__,\n                                      self.__class__.__name__,\n                                      self.viewer())\n\n    def _draw_grid(self, painter, rect, pen, grid_size):\n        lines = []\n        left = int(rect.left()) - (int(rect.left()) % grid_size)\n        top = int(rect.top()) - (int(rect.top()) % grid_size)\n        x = left\n        while x < rect.right():\n            x += grid_size\n            lines.append(QtCore.QLineF(x, rect.top(), x, rect.bottom()))\n        y = top\n        while y < rect.bottom():\n            y += grid_size\n            lines.append(QtCore.QLineF(rect.left(), y, rect.right(), y))\n        painter.setPen(pen)\n        painter.drawLines(lines)\n\n    def drawBackground(self, painter, rect):\n        painter.save()\n        color = QtGui.QColor(*self._bg_color)\n        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)\n        painter.setBrush(color)\n        painter.drawRect(rect.normalized())\n        if not self._grid:\n            return\n        zoom = self.viewer().get_zoom()\n        grid_size = 20\n        if zoom > -0.5:\n            color = QtGui.QColor(*self.grid_color)\n            pen = QtGui.QPen(color, 0.65)\n            self._draw_grid(painter, rect, pen, grid_size)\n        color = QtGui.QColor(*VIEWER_BG_COLOR)\n        color = color.darker(130)\n        if zoom < -0.0:\n            color = color.darker(100 - int(zoom * 110))\n        pen = QtGui.QPen(color, 0.65)\n        self._draw_grid(painter, rect, pen, grid_size * 8)\n        painter.restore()\n\n    def mousePressEvent(self, event):\n        selected_nodes = self.viewer().selected_nodes()\n        if self.viewer():\n            self.viewer().sceneMousePressEvent(event)\n        super(NodeScene, self).mousePressEvent(event)\n        keep_selection = any([\n            event.button() == QtCore.Qt.MiddleButton,\n            event.button() == QtCore.Qt.RightButton,\n            event.modifiers() == QtCore.Qt.AltModifier\n        ])\n        if keep_selection:\n            for node in selected_nodes:\n                node.setSelected(True)\n\n    def mouseMoveEvent(self, event):\n        if self.viewer():\n            self.viewer().sceneMouseMoveEvent(event)\n        super(NodeScene, self).mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if self.viewer():\n            self.viewer().sceneMouseReleaseEvent(event)\n        super(NodeScene, self).mouseReleaseEvent(event)\n\n    def viewer(self):\n        return self.views()[0] if self.views() else None\n\n    @property\n    def grid(self):\n        return self._grid\n\n    @grid.setter\n    def grid(self, mode=True):\n        self._grid = mode\n\n    @property\n    def grid_color(self):\n        return self._grid_color\n\n    @grid_color.setter\n    def grid_color(self, color=(0, 0, 0)):\n        self._grid_color = color\n\n    @property\n    def background_color(self):\n        return self._bg_color\n\n    @background_color.setter\n    def background_color(self, color=(0, 0, 0)):\n        self._bg_color = color",
  "def __init__(self, parent=None):\n        super(NodeScene, self).__init__(parent)\n        self.background_color = VIEWER_BG_COLOR\n        self.grid = VIEWER_GRID_OVERLAY\n        self.grid_color = VIEWER_GRID_COLOR",
  "def __repr__(self):\n        return '{}.{}(\\'{}\\')'.format(self.__module__,\n                                      self.__class__.__name__,\n                                      self.viewer())",
  "def _draw_grid(self, painter, rect, pen, grid_size):\n        lines = []\n        left = int(rect.left()) - (int(rect.left()) % grid_size)\n        top = int(rect.top()) - (int(rect.top()) % grid_size)\n        x = left\n        while x < rect.right():\n            x += grid_size\n            lines.append(QtCore.QLineF(x, rect.top(), x, rect.bottom()))\n        y = top\n        while y < rect.bottom():\n            y += grid_size\n            lines.append(QtCore.QLineF(rect.left(), y, rect.right(), y))\n        painter.setPen(pen)\n        painter.drawLines(lines)",
  "def drawBackground(self, painter, rect):\n        painter.save()\n        color = QtGui.QColor(*self._bg_color)\n        painter.setRenderHint(QtGui.QPainter.Antialiasing, False)\n        painter.setBrush(color)\n        painter.drawRect(rect.normalized())\n        if not self._grid:\n            return\n        zoom = self.viewer().get_zoom()\n        grid_size = 20\n        if zoom > -0.5:\n            color = QtGui.QColor(*self.grid_color)\n            pen = QtGui.QPen(color, 0.65)\n            self._draw_grid(painter, rect, pen, grid_size)\n        color = QtGui.QColor(*VIEWER_BG_COLOR)\n        color = color.darker(130)\n        if zoom < -0.0:\n            color = color.darker(100 - int(zoom * 110))\n        pen = QtGui.QPen(color, 0.65)\n        self._draw_grid(painter, rect, pen, grid_size * 8)\n        painter.restore()",
  "def mousePressEvent(self, event):\n        selected_nodes = self.viewer().selected_nodes()\n        if self.viewer():\n            self.viewer().sceneMousePressEvent(event)\n        super(NodeScene, self).mousePressEvent(event)\n        keep_selection = any([\n            event.button() == QtCore.Qt.MiddleButton,\n            event.button() == QtCore.Qt.RightButton,\n            event.modifiers() == QtCore.Qt.AltModifier\n        ])\n        if keep_selection:\n            for node in selected_nodes:\n                node.setSelected(True)",
  "def mouseMoveEvent(self, event):\n        if self.viewer():\n            self.viewer().sceneMouseMoveEvent(event)\n        super(NodeScene, self).mouseMoveEvent(event)",
  "def mouseReleaseEvent(self, event):\n        if self.viewer():\n            self.viewer().sceneMouseReleaseEvent(event)\n        super(NodeScene, self).mouseReleaseEvent(event)",
  "def viewer(self):\n        return self.views()[0] if self.views() else None",
  "def grid(self):\n        return self._grid",
  "def grid(self, mode=True):\n        self._grid = mode",
  "def grid_color(self):\n        return self._grid_color",
  "def grid_color(self, color=(0, 0, 0)):\n        self._grid_color = color",
  "def background_color(self):\n        return self._bg_color",
  "def background_color(self, color=(0, 0, 0)):\n        self._bg_color = color",
  "class Pipe(QtWidgets.QGraphicsPathItem):\n    \"\"\"\n    Base Pipe Item.\n    \"\"\"\n\n    def __init__(self, input_port=None, output_port=None):\n        super(Pipe, self).__init__()\n        self.setZValue(Z_VAL_PIPE)\n        self.setAcceptHoverEvents(True)\n        self._color = PIPE_DEFAULT_COLOR\n        self._style = PIPE_STYLE_DEFAULT\n        self._active = False\n        self._highlight = False\n        self._input_port = input_port\n        self._output_port = output_port\n\n    def __str__(self):\n        in_name = self._input_port.name if self._input_port else ''\n        out_name = self._output_port.name if self._output_port else ''\n        return '{}.Pipe(\\'{}\\', \\'{}\\')'.format(\n            self.__module__, in_name, out_name)\n\n    def __repr__(self):\n        in_name = self._input_port.name if self._input_port else ''\n        out_name = self._output_port.name if self._output_port else ''\n        return '{}.Pipe(\\'{}\\', \\'{}\\')'.format(\n            self.__module__, in_name, out_name)\n\n    def hoverEnterEvent(self, event):\n        self.activate()\n\n    def hoverLeaveEvent(self, event):\n        self.reset()\n        if self.input_port.node.selected:\n            self.highlight()\n        elif self.output_port.node.selected:\n            self.highlight()\n\n    def paint(self, painter, option, widget):\n        color = QtGui.QColor(*self._color)\n        pen_style = PIPE_STYLES.get(self.style)\n        pen_width = PIPE_WIDTH\n        if self._active:\n            color = QtGui.QColor(*PIPE_ACTIVE_COLOR)\n        elif self._highlight:\n            color = QtGui.QColor(*PIPE_HIGHLIGHT_COLOR)\n            pen_style = PIPE_STYLES.get(PIPE_STYLE_DEFAULT)\n\n        if self.input_port and self.output_port:\n            in_node = self.input_port.node\n            out_node = self.output_port.node\n            if in_node.disabled or out_node.disabled:\n                color.setAlpha(200)\n                pen_width += 0.2\n                pen_style = PIPE_STYLES.get(PIPE_STYLE_DOTTED)\n\n        pen = QtGui.QPen(color, pen_width)\n        pen.setStyle(pen_style)\n        pen.setCapStyle(QtCore.Qt.RoundCap)\n\n        painter.setPen(pen)\n        painter.setRenderHint(painter.Antialiasing, True)\n        painter.drawPath(self.path())\n\n    def draw_path(self, start_port, end_port, cursor_pos=None):\n        if not start_port:\n            return\n        offset = (start_port.boundingRect().width() / 2)\n        pos1 = start_port.scenePos()\n        pos1.setX(pos1.x() + offset)\n        pos1.setY(pos1.y() + offset)\n        if cursor_pos:\n            pos2 = cursor_pos\n        elif end_port:\n            offset = start_port.boundingRect().width() / 2\n            pos2 = end_port.scenePos()\n            pos2.setX(pos2.x() + offset)\n            pos2.setY(pos2.y() + offset)\n        else:\n            return\n\n        line = QtCore.QLineF(pos1, pos2)\n        path = QtGui.QPainterPath()\n        path.moveTo(line.x1(), line.y1())\n\n        if self.viewer_pipe_layout() == PIPE_LAYOUT_STRAIGHT:\n            path.lineTo(pos2)\n            self.setPath(path)\n            return\n\n        ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()\n        tangent = ctr_offset_x1 - ctr_offset_x2\n        tangent = (tangent * -1) if tangent < 0 else tangent\n\n        max_width = start_port.node.boundingRect().width() / 2\n        tangent = max_width if tangent > max_width else tangent\n\n        if start_port.port_type == IN_PORT:\n            ctr_offset_x1 -= tangent\n            ctr_offset_x2 += tangent\n        elif start_port.port_type == OUT_PORT:\n            ctr_offset_x1 += tangent\n            ctr_offset_x2 -= tangent\n\n        ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())\n        ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())\n        path.cubicTo(ctr_point1, ctr_point2, pos2)\n        self.setPath(path)\n\n    def calc_distance(self, p1, p2):\n        x = math.pow((p2.x() - p1.x()), 2)\n        y = math.pow((p2.y() - p1.y()), 2)\n        return math.sqrt(x + y)\n\n    def port_from_pos(self, pos, reverse=False):\n        inport_pos = self.input_port.scenePos()\n        outport_pos = self.output_port.scenePos()\n        input_dist = self.calc_distance(inport_pos, pos)\n        output_dist = self.calc_distance(outport_pos, pos)\n        if input_dist < output_dist:\n            port = self.output_port if reverse else self.input_port\n        else:\n            port = self.input_port if reverse else self.output_port\n        return port\n\n    def viewer_pipe_layout(self):\n        if self.scene():\n            viewer = self.scene().viewer()\n            return viewer.get_pipe_layout()\n\n    def activate(self):\n        self._active = True\n        pen = QtGui.QPen(QtGui.QColor(*PIPE_ACTIVE_COLOR), 2)\n        pen.setStyle(PIPE_STYLES.get(PIPE_STYLE_DEFAULT))\n        self.setPen(pen)\n\n    def active(self):\n        return self._active\n\n    def highlight(self):\n        self._highlight = True\n        pen = QtGui.QPen(QtGui.QColor(*PIPE_HIGHLIGHT_COLOR), 2)\n        pen.setStyle(PIPE_STYLES.get(PIPE_STYLE_DEFAULT))\n        self.setPen(pen)\n\n    def highlighted(self):\n        return self._highlight\n\n    def reset(self):\n        self._active = False\n        self._highlight = False\n        pen = QtGui.QPen(QtGui.QColor(*self.color), 2)\n        pen.setStyle(PIPE_STYLES.get(self.style))\n        self.setPen(pen)\n\n    def set_connections(self, port1, port2):\n        ports = {\n            port1.port_type: port1,\n            port2.port_type: port2\n        }\n        self.input_port = ports[IN_PORT]\n        self.output_port = ports[OUT_PORT]\n        ports[IN_PORT].add_pipe(self)\n        ports[OUT_PORT].add_pipe(self)\n\n    @property\n    def input_port(self):\n        return self._input_port\n\n    @input_port.setter\n    def input_port(self, port):\n        if isinstance(port, PortItem) or not port:\n            self._input_port = port\n        else:\n            self._input_port = None\n\n    @property\n    def output_port(self):\n        return self._output_port\n\n    @output_port.setter\n    def output_port(self, port):\n        if isinstance(port, PortItem) or not port:\n            self._output_port = port\n        else:\n            self._output_port = None\n\n    @property\n    def color(self):\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        self._color = color\n\n    @property\n    def style(self):\n        return self._style\n\n    @style.setter\n    def style(self, style):\n        self._style = style\n\n    def delete(self):\n        if self.input_port and self.input_port.connected_pipes:\n            self.input_port.remove_pipe(self)\n        if self.output_port and self.output_port.connected_pipes:\n            self.output_port.remove_pipe(self)\n        if self.scene():\n            self.scene().removeItem(self)\n        # TODO: not sure if we need this...?\n        del self",
  "def __init__(self, input_port=None, output_port=None):\n        super(Pipe, self).__init__()\n        self.setZValue(Z_VAL_PIPE)\n        self.setAcceptHoverEvents(True)\n        self._color = PIPE_DEFAULT_COLOR\n        self._style = PIPE_STYLE_DEFAULT\n        self._active = False\n        self._highlight = False\n        self._input_port = input_port\n        self._output_port = output_port",
  "def __str__(self):\n        in_name = self._input_port.name if self._input_port else ''\n        out_name = self._output_port.name if self._output_port else ''\n        return '{}.Pipe(\\'{}\\', \\'{}\\')'.format(\n            self.__module__, in_name, out_name)",
  "def __repr__(self):\n        in_name = self._input_port.name if self._input_port else ''\n        out_name = self._output_port.name if self._output_port else ''\n        return '{}.Pipe(\\'{}\\', \\'{}\\')'.format(\n            self.__module__, in_name, out_name)",
  "def hoverEnterEvent(self, event):\n        self.activate()",
  "def hoverLeaveEvent(self, event):\n        self.reset()\n        if self.input_port.node.selected:\n            self.highlight()\n        elif self.output_port.node.selected:\n            self.highlight()",
  "def paint(self, painter, option, widget):\n        color = QtGui.QColor(*self._color)\n        pen_style = PIPE_STYLES.get(self.style)\n        pen_width = PIPE_WIDTH\n        if self._active:\n            color = QtGui.QColor(*PIPE_ACTIVE_COLOR)\n        elif self._highlight:\n            color = QtGui.QColor(*PIPE_HIGHLIGHT_COLOR)\n            pen_style = PIPE_STYLES.get(PIPE_STYLE_DEFAULT)\n\n        if self.input_port and self.output_port:\n            in_node = self.input_port.node\n            out_node = self.output_port.node\n            if in_node.disabled or out_node.disabled:\n                color.setAlpha(200)\n                pen_width += 0.2\n                pen_style = PIPE_STYLES.get(PIPE_STYLE_DOTTED)\n\n        pen = QtGui.QPen(color, pen_width)\n        pen.setStyle(pen_style)\n        pen.setCapStyle(QtCore.Qt.RoundCap)\n\n        painter.setPen(pen)\n        painter.setRenderHint(painter.Antialiasing, True)\n        painter.drawPath(self.path())",
  "def draw_path(self, start_port, end_port, cursor_pos=None):\n        if not start_port:\n            return\n        offset = (start_port.boundingRect().width() / 2)\n        pos1 = start_port.scenePos()\n        pos1.setX(pos1.x() + offset)\n        pos1.setY(pos1.y() + offset)\n        if cursor_pos:\n            pos2 = cursor_pos\n        elif end_port:\n            offset = start_port.boundingRect().width() / 2\n            pos2 = end_port.scenePos()\n            pos2.setX(pos2.x() + offset)\n            pos2.setY(pos2.y() + offset)\n        else:\n            return\n\n        line = QtCore.QLineF(pos1, pos2)\n        path = QtGui.QPainterPath()\n        path.moveTo(line.x1(), line.y1())\n\n        if self.viewer_pipe_layout() == PIPE_LAYOUT_STRAIGHT:\n            path.lineTo(pos2)\n            self.setPath(path)\n            return\n\n        ctr_offset_x1, ctr_offset_x2 = pos1.x(), pos2.x()\n        tangent = ctr_offset_x1 - ctr_offset_x2\n        tangent = (tangent * -1) if tangent < 0 else tangent\n\n        max_width = start_port.node.boundingRect().width() / 2\n        tangent = max_width if tangent > max_width else tangent\n\n        if start_port.port_type == IN_PORT:\n            ctr_offset_x1 -= tangent\n            ctr_offset_x2 += tangent\n        elif start_port.port_type == OUT_PORT:\n            ctr_offset_x1 += tangent\n            ctr_offset_x2 -= tangent\n\n        ctr_point1 = QtCore.QPointF(ctr_offset_x1, pos1.y())\n        ctr_point2 = QtCore.QPointF(ctr_offset_x2, pos2.y())\n        path.cubicTo(ctr_point1, ctr_point2, pos2)\n        self.setPath(path)",
  "def calc_distance(self, p1, p2):\n        x = math.pow((p2.x() - p1.x()), 2)\n        y = math.pow((p2.y() - p1.y()), 2)\n        return math.sqrt(x + y)",
  "def port_from_pos(self, pos, reverse=False):\n        inport_pos = self.input_port.scenePos()\n        outport_pos = self.output_port.scenePos()\n        input_dist = self.calc_distance(inport_pos, pos)\n        output_dist = self.calc_distance(outport_pos, pos)\n        if input_dist < output_dist:\n            port = self.output_port if reverse else self.input_port\n        else:\n            port = self.input_port if reverse else self.output_port\n        return port",
  "def viewer_pipe_layout(self):\n        if self.scene():\n            viewer = self.scene().viewer()\n            return viewer.get_pipe_layout()",
  "def activate(self):\n        self._active = True\n        pen = QtGui.QPen(QtGui.QColor(*PIPE_ACTIVE_COLOR), 2)\n        pen.setStyle(PIPE_STYLES.get(PIPE_STYLE_DEFAULT))\n        self.setPen(pen)",
  "def active(self):\n        return self._active",
  "def highlight(self):\n        self._highlight = True\n        pen = QtGui.QPen(QtGui.QColor(*PIPE_HIGHLIGHT_COLOR), 2)\n        pen.setStyle(PIPE_STYLES.get(PIPE_STYLE_DEFAULT))\n        self.setPen(pen)",
  "def highlighted(self):\n        return self._highlight",
  "def reset(self):\n        self._active = False\n        self._highlight = False\n        pen = QtGui.QPen(QtGui.QColor(*self.color), 2)\n        pen.setStyle(PIPE_STYLES.get(self.style))\n        self.setPen(pen)",
  "def set_connections(self, port1, port2):\n        ports = {\n            port1.port_type: port1,\n            port2.port_type: port2\n        }\n        self.input_port = ports[IN_PORT]\n        self.output_port = ports[OUT_PORT]\n        ports[IN_PORT].add_pipe(self)\n        ports[OUT_PORT].add_pipe(self)",
  "def input_port(self):\n        return self._input_port",
  "def input_port(self, port):\n        if isinstance(port, PortItem) or not port:\n            self._input_port = port\n        else:\n            self._input_port = None",
  "def output_port(self):\n        return self._output_port",
  "def output_port(self, port):\n        if isinstance(port, PortItem) or not port:\n            self._output_port = port\n        else:\n            self._output_port = None",
  "def color(self):\n        return self._color",
  "def color(self, color):\n        self._color = color",
  "def style(self):\n        return self._style",
  "def style(self, style):\n        self._style = style",
  "def delete(self):\n        if self.input_port and self.input_port.connected_pipes:\n            self.input_port.remove_pipe(self)\n        if self.output_port and self.output_port.connected_pipes:\n            self.output_port.remove_pipe(self)\n        if self.scene():\n            self.scene().removeItem(self)\n        # TODO: not sure if we need this...?\n        del self",
  "class PortModel(object):\n\n    def __init__(self, node):\n        self.node = node\n        self.type = ''\n        self.name = 'port'\n        self.display_name = True\n        self.multi_connection = False\n        self.connected_ports = defaultdict(list)\n\n    def __repr__(self):\n        return '{}(\\'{}\\')'.format(self.__class__.__name__, self.name)\n\n    @property\n    def to_dict(self):\n        \"\"\"\n        serialize model information to a dictionary.\n\n        Returns:\n            dict: node port dictionary eg.\n                {\n                    'type': 'in',\n                    'name': 'port',\n                    'display_name': True,\n                    'multi_connection': False,\n                    'connected_ports': {<node_id>: [<port_name>, <port_name>]}\n                }\n        \"\"\"\n        props = self.__dict__.copy()\n        props.pop('node')\n        props['connected_ports'] = dict(props.pop('connected_ports'))\n        return props",
  "class NodeModel(object):\n\n    def __init__(self):\n        self.type = None\n        self.id = hex(id(self))\n        self.icon = None\n        self.name = 'node'\n        self.color = (48, 58, 69, 255)\n        self.border_color = (85, 100, 100, 255)\n        self.text_color = (255, 255, 255, 180)\n        self.disabled = False\n        self.selected = False\n        self.width = 100.0\n        self.height = 80.0\n        self.pos = (0.0, 0.0)\n        self.inputs = {}\n        self.outputs = {}\n        self._properties = {}\n\n    @property\n    def properties(self):\n        \"\"\"\n        return all default node properties.\n\n        Returns:\n            dict: default node properties.\n        \"\"\"\n        props = self.__dict__.copy()\n        props.pop('_properties')\n        return props\n\n    @property\n    def custom_properties(self):\n        \"\"\"\n        return all custom properties specified by the user.\n\n        Returns:\n            dict: user defined properties.\n        \"\"\"\n        return self._properties\n\n    @property\n    def to_dict(self):\n        \"\"\"\n        serialize model information to a dictionary.\n\n        Returns:\n            dict: node id as the key and properties as the values eg.\n                {'0x106cf75a8': {\n                    'name': 'foo node',\n                    'color': (48, 58, 69, 255),\n                    'border_color': (85, 100, 100, 255),\n                    'text_color': (255, 255, 255, 180),\n                    'type': 'com.chantasticvfx.FooNode',\n                    'selected': False,\n                    'disabled': False,\n                    'inputs': {\n                        <port_name>: {<node_id>: [<port_name>, <port_name>]}},\n                    'outputs': {\n                        <port_name>: {<node_id>: [<port_name>, <port_name>]}},\n                    'width': 0.0,\n                    'height: 0.0,\n                    'pos': (0.0, 0.0),\n                    'custom': {},\n                    }\n                }\n        \"\"\"\n        node_dict = self.__dict__.copy()\n        node_id = node_dict.pop('id')\n\n        inputs = {}\n        outputs = {}\n        for name, model in node_dict.pop('inputs').items():\n            connected_ports = model.to_dict['connected_ports']\n            if connected_ports:\n                inputs[name] = connected_ports\n        for name, model in node_dict.pop('outputs').items():\n            connected_ports = model.to_dict['connected_ports']\n            if connected_ports:\n                outputs[name] = connected_ports\n        if inputs:\n            node_dict['inputs'] = inputs\n        if outputs:\n            node_dict['outputs'] = outputs\n\n        custom_props = node_dict.pop('_properties', {})\n        if custom_props:\n            node_dict['custom'] = custom_props\n\n        return {node_id: node_dict}\n\n    @property\n    def serial(self):\n        \"\"\"\n        Serialize model information to a string.\n\n        Returns:\n            str: serialized JSON string.\n        \"\"\"\n        model_dict = self.to_dict\n        return json.dumps(model_dict)",
  "class NodeGraphModel(object):\n\n    def __init__(self):\n        self.nodes = {}\n        self.session = ''\n        self.acyclic = True",
  "def __init__(self, node):\n        self.node = node\n        self.type = ''\n        self.name = 'port'\n        self.display_name = True\n        self.multi_connection = False\n        self.connected_ports = defaultdict(list)",
  "def __repr__(self):\n        return '{}(\\'{}\\')'.format(self.__class__.__name__, self.name)",
  "def to_dict(self):\n        \"\"\"\n        serialize model information to a dictionary.\n\n        Returns:\n            dict: node port dictionary eg.\n                {\n                    'type': 'in',\n                    'name': 'port',\n                    'display_name': True,\n                    'multi_connection': False,\n                    'connected_ports': {<node_id>: [<port_name>, <port_name>]}\n                }\n        \"\"\"\n        props = self.__dict__.copy()\n        props.pop('node')\n        props['connected_ports'] = dict(props.pop('connected_ports'))\n        return props",
  "def __init__(self):\n        self.type = None\n        self.id = hex(id(self))\n        self.icon = None\n        self.name = 'node'\n        self.color = (48, 58, 69, 255)\n        self.border_color = (85, 100, 100, 255)\n        self.text_color = (255, 255, 255, 180)\n        self.disabled = False\n        self.selected = False\n        self.width = 100.0\n        self.height = 80.0\n        self.pos = (0.0, 0.0)\n        self.inputs = {}\n        self.outputs = {}\n        self._properties = {}",
  "def properties(self):\n        \"\"\"\n        return all default node properties.\n\n        Returns:\n            dict: default node properties.\n        \"\"\"\n        props = self.__dict__.copy()\n        props.pop('_properties')\n        return props",
  "def custom_properties(self):\n        \"\"\"\n        return all custom properties specified by the user.\n\n        Returns:\n            dict: user defined properties.\n        \"\"\"\n        return self._properties",
  "def to_dict(self):\n        \"\"\"\n        serialize model information to a dictionary.\n\n        Returns:\n            dict: node id as the key and properties as the values eg.\n                {'0x106cf75a8': {\n                    'name': 'foo node',\n                    'color': (48, 58, 69, 255),\n                    'border_color': (85, 100, 100, 255),\n                    'text_color': (255, 255, 255, 180),\n                    'type': 'com.chantasticvfx.FooNode',\n                    'selected': False,\n                    'disabled': False,\n                    'inputs': {\n                        <port_name>: {<node_id>: [<port_name>, <port_name>]}},\n                    'outputs': {\n                        <port_name>: {<node_id>: [<port_name>, <port_name>]}},\n                    'width': 0.0,\n                    'height: 0.0,\n                    'pos': (0.0, 0.0),\n                    'custom': {},\n                    }\n                }\n        \"\"\"\n        node_dict = self.__dict__.copy()\n        node_id = node_dict.pop('id')\n\n        inputs = {}\n        outputs = {}\n        for name, model in node_dict.pop('inputs').items():\n            connected_ports = model.to_dict['connected_ports']\n            if connected_ports:\n                inputs[name] = connected_ports\n        for name, model in node_dict.pop('outputs').items():\n            connected_ports = model.to_dict['connected_ports']\n            if connected_ports:\n                outputs[name] = connected_ports\n        if inputs:\n            node_dict['inputs'] = inputs\n        if outputs:\n            node_dict['outputs'] = outputs\n\n        custom_props = node_dict.pop('_properties', {})\n        if custom_props:\n            node_dict['custom'] = custom_props\n\n        return {node_id: node_dict}",
  "def serial(self):\n        \"\"\"\n        Serialize model information to a string.\n\n        Returns:\n            str: serialized JSON string.\n        \"\"\"\n        model_dict = self.to_dict\n        return json.dumps(model_dict)",
  "def __init__(self):\n        self.nodes = {}\n        self.session = ''\n        self.acyclic = True",
  "class NodeGraph(QtCore.QObject):\n  \n    node_selected = QtCore.Signal(NodeObject)\n\n    def __init__(self, parent=None):\n        super(NodeGraph, self).__init__(parent)\n        self._model = NodeGraphModel()\n        self._viewer = NodeViewer()\n        self._undo_stack = QUndoStack(self)\n        self._init_actions()\n        self._wire_signals()\n\n    def _wire_signals(self):\n        self._viewer.moved_nodes.connect(self._on_nodes_moved)\n        self._viewer.search_triggered.connect(self._on_search_triggered)\n        self._viewer.connection_changed.connect(self._on_connection_changed)\n        self._viewer.node_selected.connect(self._on_node_selected)\n\n    def _init_actions(self):\n        # setup tab search shortcut.\n        tab = QAction('Search Nodes', self)\n        tab.setShortcut('tab')\n        tab.triggered.connect(self._toggle_tab_search)\n        self._viewer.addAction(tab)\n        setup_actions(self)\n\n    def _toggle_tab_search(self):\n        \"\"\"\n        toggle the tab search widget.\n        \"\"\"\n        self._viewer.tab_search_set_nodes(NodeVendor.names)\n        self._viewer.tab_search_toggle()\n\n    def _on_nodes_moved(self, node_data):\n        \"\"\"\n        called when selected nodes in the viewer has changed position.\n\n        Args:\n            node_data (dict): {<node_view>: <previous_pos>}\n        \"\"\"\n        self._undo_stack.beginMacro('moved nodes')\n        for node_view, prev_pos in node_data.items():\n            node = self._model.nodes[node_view.id]\n            self._undo_stack.push(NodeMovedCmd(node, node.pos(), prev_pos))\n        self._undo_stack.endMacro()\n\n    def _on_node_selected(self, node_id):\n        \"\"\"\n        called when a node in the viewer is selected on left click.\n        (emits the node object when the node is clicked)\n\n        Args:\n            node_id (str): node id emitted by the viewer.\n        \"\"\"\n        node = self.get_node_by_id(node_id)\n        self.node_selected.emit(node)\n\n    def _on_search_triggered(self, node_type, pos):\n        \"\"\"\n        called when the tab search widget is triggered in the viewer.\n\n        Args:\n            node_type (str): node identifier.\n            pos (tuple): x,y position for the node.\n        \"\"\"\n        self.create_node(node_type, pos=pos)\n\n    def _on_connection_changed(self, disconnected, connected):\n        \"\"\"\n        called when a pipe connection has been changed in the viewer.\n\n        Args:\n            disconnected (list[list[widgets.port.PortItem]):\n                pair list of port view items.\n            connected (list[list[widgets.port.PortItem]]):\n                pair list of port view items.\n        \"\"\"\n        if not (disconnected or connected):\n            return\n\n        label = 'connected node(s)' if connected else 'disconnected node(s)'\n        ptypes = {'in': 'inputs', 'out': 'outputs'}\n\n        self._undo_stack.beginMacro(label)\n        for p1_view, p2_view in disconnected:\n            node1 = self._model.nodes[p1_view.node.id]\n            node2 = self._model.nodes[p2_view.node.id]\n            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]\n            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]\n            port1.disconnect_from(port2)\n        for p1_view, p2_view in connected:\n            node1 = self._model.nodes[p1_view.node.id]\n            node2 = self._model.nodes[p2_view.node.id]\n            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]\n            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]\n            port1.connect_to(port2)\n        self._undo_stack.endMacro()\n\n    @property\n    def model(self):\n        \"\"\"\n        Return the node graph model.\n\n        Returns:\n            NodeGraphModel: model object.\n        \"\"\"\n        return self._model\n\n    def show(self):\n        \"\"\"\n        Show node graph viewer widget.\n        \"\"\"\n        self._viewer.show()\n\n    def hide(self):\n        \"\"\"\n        Hide node graph viewer widget.\n        \"\"\"\n        self._viewer.hide()\n\n    def close(self):\n        \"\"\"\n        Close node graph viewer widget.\n        \"\"\"\n        self._viewer.close()\n\n    def viewer(self):\n        \"\"\"\n        Return the node graph viewer widget object.\n\n        Returns:\n            NodeGraphQt.widgets.viewer.NodeViewer: viewer widget.\n        \"\"\"\n        return self._viewer\n\n    def scene(self):\n        \"\"\"\n        Return the scene object.\n\n        Returns:\n            NodeGraphQt.widgets.scene.NodeScene: node scene.\n        \"\"\"\n        return self._viewer.scene()\n\n    def undo_stack(self):\n        \"\"\"\n        Returns the undo stack used in the node graph\n\n        Returns:\n            QUndoStack: undo stack.\n        \"\"\"\n        return self._undo_stack\n\n    def begin_undo(self, name='undo'):\n        \"\"\"\n        Start of an undo block followed by a end_undo().\n\n        Args:\n            name (str): name for the undo block.\n        \"\"\"\n        self._undo_stack.beginMacro(name)\n\n    def end_undo(self):\n        \"\"\"\n        End of an undo block started by begin_undo().\n        \"\"\"\n        self._undo_stack.endMacro()\n\n    def context_menu(self):\n        \"\"\"\n        Returns a node graph context menu object.\n\n        Returns:\n            ContextMenu: node graph context menu object instance.\n        \"\"\"\n        return self._viewer.context_menu()\n\n    def acyclic(self):\n        \"\"\"\n        Returns true if the current node graph is acyclic.\n\n        Returns:\n            bool: true if acyclic.\n        \"\"\"\n        return self._model.acyclic\n\n    def set_acyclic(self, mode=True):\n        \"\"\"\n        Set the node graph to be acyclic or not. (default=True)\n\n        Args:\n            mode (bool): false to disable acyclic.\n        \"\"\"\n        self._model.acyclic = mode\n        self._viewer.acyclic = mode\n\n    def set_pipe_layout(self, layout='curved'):\n        \"\"\"\n        Set node graph pipes to be drawn straight or curved by default\n        all pipes are set curved. (default='curved')\n\n        Args:\n            layout (str): 'straight' or 'curved'\n        \"\"\"\n        self._viewer.set_pipe_layout(layout)\n\n    def fit_to_selection(self):\n        \"\"\"\n        Sets the zoom level to fit selected nodes.\n        If no nodes are selected then all nodes in the graph will be framed.\n        \"\"\"\n        nodes = self.selected_nodes() or self.all_nodes()\n        if not nodes:\n            return\n        self._viewer.zoom_to_nodes([n.view for n in nodes])\n\n    def reset_zoom(self):\n        \"\"\"\n        Reset the zoom level\n        \"\"\"\n        self._viewer.reset_zoom()\n\n    def set_zoom(self, zoom=0):\n        \"\"\"\n        Set the zoom factor of the Node Graph the default is 0.0\n\n        Args:\n            zoom (float): zoom factor max zoom out -0.9 max zoom in 2.0\n        \"\"\"\n        self._viewer.set_zoom(zoom)\n\n    def get_zoom(self):\n        \"\"\"\n        Get the current zoom level of the node graph.\n\n        Returns:\n            float: the current zoom level.\n        \"\"\"\n        return self._viewer.get_zoom()\n\n    def center_on(self, nodes=None):\n        \"\"\"\n        Center the node graph on the given nodes or all nodes by default.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): a list of nodes.\n        \"\"\"\n        self._viewer.center_selection(nodes)\n\n    def center_selection(self):\n        \"\"\"\n        Center the node graph on the current selected nodes.\n        \"\"\"\n        nodes = self._viewer.selected_nodes()\n        self._viewer.center_selection(nodes)\n\n    def registered_nodes(self):\n        \"\"\"\n        Return a list of all node types that have been registered.\n        To register a node see \"NodeGraphWidget.register_node()\"\n\n        Returns:\n            list[str]: node types.\n        \"\"\"\n        return sorted(NodeVendor.nodes.keys())\n\n    def register_node(self, node, alias=None):\n        \"\"\"\n        Register a node.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n            alias (str): custom alias name for the node type.\n        \"\"\"\n        NodeVendor.register_node(node, alias)\n\n    def create_node(self, node_type, name=None, selected=True, color=None, pos=None):\n        \"\"\"\n        Create a new node in the node graph.\n        To list all node types see \"NodeGraphWidget.registered_nodes()\"\n\n        Args:\n            node_type (str): node instance type.\n            name (str): set name of the node.\n            selected (bool): set created node to be selected.\n            color (tuple or str): node color (255, 255, 255) or '#FFFFFF'.\n            pos (tuple): set position of the node (x, y).\n\n        Returns:\n            NodeGraphQt.Node: created instance of a node.\n        \"\"\"\n        NodeInstance = NodeVendor.create_node_instance(node_type)\n        if NodeInstance:\n            node = NodeInstance()\n            node._graph = self\n            node.update()\n\n            self._undo_stack.beginMacro('created node')\n            self._undo_stack.push(NodeAddedCmd(self, node, pos))\n            if name:\n                node.set_name(name)\n            else:\n                node.set_name(node.NODE_NAME)\n            if color:\n                if isinstance(color, str):\n                    color = color[1:] if color[0] is '#' else color\n                    color = tuple(int(color[i:i + 2], 16) for i in (0, 2, 4))\n                node.set_color(*color)\n            node.set_selected(selected)\n            self._undo_stack.endMacro()\n            return node\n        raise Exception('\\n\\n>> Cannot find node:\\t\"{}\"\\n'.format(node_type))\n\n    def add_node(self, node):\n        \"\"\"\n        Add a node into the node graph.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n        \"\"\"\n        assert isinstance(node, NodeObject), 'node must be a Node instance.'\n        node._graph = self\n        node.NODE_NAME = self.get_unique_name(node.NODE_NAME)\n        node.model.name = node.NODE_NAME\n        node.update()\n        self._undo_stack.push(NodeAddedCmd(self, node))\n\n    def delete_node(self, node):\n        \"\"\"\n        Remove the node from the node graph.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n        \"\"\"\n        assert isinstance(node, NodeObject), \\\n            'node must be a instance of a NodeObject.'\n        self._undo_stack.push(NodeRemovedCmd(self, node))\n\n    def delete_nodes(self, nodes):\n        \"\"\"\n        Remove a list of nodes from the node graph.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n        \"\"\"\n        self._undo_stack.beginMacro('deleted nodes')\n        [self.delete_node(n) for n in nodes]\n        self._undo_stack.endMacro()\n\n    def all_nodes(self):\n        \"\"\"\n        Return all nodes in the node graph.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of nodes.\n        \"\"\"\n        return list(self._model.nodes.values())\n\n    def selected_nodes(self):\n        \"\"\"\n        Return all selected nodes that are in the node graph.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of nodes.\n        \"\"\"\n        nodes = []\n        for item in self._viewer.selected_nodes():\n            node = self._model.nodes[item.id]\n            nodes.append(node)\n        return nodes\n\n    def select_all(self):\n        \"\"\"\n        Select all nodes in the current node graph.\n        \"\"\"\n        self._undo_stack.beginMacro('select all')\n        for node in self.all_nodes():\n            node.set_selected(True)\n        self._undo_stack.endMacro()\n\n    def clear_selection(self):\n        \"\"\"\n        Clears the selection in the node graph.\n        \"\"\"\n        self._undo_stack.beginMacro('deselected nodes')\n        for node in self.all_nodes():\n            node.set_selected(False)\n        self._undo_stack.endMacro()\n\n    def get_node_by_id(self, node_id=None):\n        \"\"\"\n        Get the node object by it's id.\n\n        Args:\n            node_id (str): node id\n\n        Returns:\n            NodeGraphQt.NodeObject: node object.\n        \"\"\"\n        return self._model.nodes.get(node_id)\n\n    def get_node_by_name(self, name):\n        \"\"\"\n        Returns node object that matches the name.\n\n        Args:\n            name (str): name of the node.\n        Returns:\n            NodeGraphQt.Node: node object.\n        \"\"\"\n        for node_id, node in self._model.nodes.items():\n            if node.name() == name:\n                return node\n\n    def get_unique_name(self, name):\n        \"\"\"\n        return a unique node name for the node.\n\n        Args:\n            name (str): node name.\n\n        Returns:\n            str: unique node name.\n        \"\"\"\n        name = ' '.join(name.split())\n        node_names = [n.name() for n in self.all_nodes()]\n        if name not in node_names:\n            return name\n\n        regex = re.compile('[\\w ]+(?: )*(\\d+)')\n        search = regex.search(name)\n        if not search:\n            for x in range(1, len(node_names) + 1):\n                new_name = '{} {}'.format(name, x)\n                if new_name not in node_names:\n                    return new_name\n\n        version = search.group(1)\n        name = name[:len(version) * -1].strip()\n        for x in range(1, len(node_names) + 1):\n            new_name = '{} {}'.format(name, x)\n            if new_name not in node_names:\n                return new_name\n\n    def current_session(self):\n        \"\"\"\n        returns the file path to the currently loaded session.\n\n        Returns:\n            str: path to the currently loaded session\n        \"\"\"\n        return self._model.session\n\n    def clear_session(self):\n        \"\"\"\n        clear the loaded node layout session.\n        \"\"\"\n        for n in self.all_nodes():\n            self.delete_node(n)\n        self._undo_stack.clear()\n        self._model.session = None\n\n    def _serialize(self, nodes):\n        \"\"\"\n        serialize nodes to a dict.\n\n        Args:\n            nodes (list[NodeGraphQt.Nodes]): list of node instances.\n\n        Returns:\n            dict: serialized data.\n        \"\"\"\n        serial_data = {'nodes': {}, 'connections': []}\n        nodes_data = {}\n        for n in nodes:\n\n            # update the node model.\n            n.update_model()\n\n            nodes_data.update(n.model.to_dict)\n\n        for n_id, n_data in nodes_data.items():\n            serial_data['nodes'][n_id] = n_data\n\n            inputs = n_data.pop('inputs') if n_data.get('inputs') else {}\n            outputs = n_data.pop('outputs') if n_data.get('outputs') else {}\n\n            for pname, conn_data in inputs.items():\n                for conn_id, prt_names in conn_data.items():\n                    for conn_prt in prt_names:\n                        pipe = {'in': [n_id, pname], 'out': [conn_id, conn_prt]}\n                        if pipe not in serial_data['connections']:\n                            serial_data['connections'].append(pipe)\n\n            for pname, conn_data in outputs.items():\n                for conn_id, prt_names in conn_data.items():\n                    for conn_prt in prt_names:\n                        pipe = {'out': [n_id, pname], 'in': [conn_id, conn_prt]}\n                        if pipe not in serial_data['connections']:\n                            serial_data['connections'].append(pipe)\n\n        if not serial_data['connections']:\n            serial_data.pop('connections')\n\n        return serial_data\n\n    def _deserialize(self, data, relative_pos=False, pos=None):\n        \"\"\"\n        deserialize node data.\n\n        Args:\n            data (dict): node data.\n            relative_pos (bool): position node relative to the cursor.\n\n        Returns:\n            list[NodeGraphQt.Nodes]: list of node instances.\n        \"\"\"\n        nodes = {}\n\n        # build the nodes.\n        for n_id, n_data in data.get('nodes', {}).items():\n            identifier = n_data['type']\n            NodeInstance = NodeVendor.create_node_instance(identifier)\n            if NodeInstance:\n                node = NodeInstance()\n                node._graph = self\n\n                name = self.get_unique_name(n_data.get('name', node.NODE_NAME))\n                n_data['name'] = name\n\n                # set properties.\n                for prop, val in node.model.properties.items():\n                    if prop in n_data.keys():\n                        setattr(node.model, prop, n_data[prop])\n\n                # set custom properties.\n                for prop, val in n_data.get('custom', {}).items():\n                    if prop in node.model.custom_properties.keys():\n                        node.model.custom_properties[prop] = val\n\n                node.update()\n\n                self._undo_stack.push(\n                    NodeAddedCmd(self, node, n_data.get('pos'))\n                )\n                nodes[n_id] = node\n\n        # build the connections.\n        for connection in data.get('connections', []):\n            nid, pname = connection.get('in', ('', ''))\n            in_node = nodes.get(nid)\n            if not in_node:\n                continue\n            in_port = in_node.inputs().get(pname) if in_node else None\n\n            nid, pname = connection.get('out', ('', ''))\n            out_node = nodes.get(nid)\n            if not out_node:\n                continue\n            out_port = out_node.outputs().get(pname) if out_node else None\n\n            if in_port and out_port:\n                self._undo_stack.push(PortConnectedCmd(in_port, out_port))\n\n        node_objs = list(nodes.values())\n        if relative_pos:\n            self._viewer.move_nodes([n.view for n in node_objs])\n            [setattr(n.model, 'pos', n.view.pos) for n in node_objs]\n        elif pos:\n            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)\n\n        return node_objs\n\n    def save_session(self, file_path):\n        \"\"\"\n        Saves the current node graph session layout to a JSON formatted file.\n\n        Args:\n            file_path (str): path to the saved node layout.\n        \"\"\"\n        serliazed_data = self._serialize(self.selected_nodes())\n        file_path = file_path.strip()\n        with open(file_path, 'w') as file_out:\n            json.dump(serliazed_data, file_out, indent=2, separators=(',', ':'))\n\n    def load_session(self, file_path):\n        \"\"\"\n        Load node graph session layout file.\n\n        Args:\n            file_path (str): path to the serialized layout file.\n        \"\"\"\n        file_path = file_path.strip()\n        if not os.path.isfile(file_path):\n            raise IOError('file does not exist.')\n\n        self.clear_session()\n\n        try:\n            with open(file_path) as data_file:\n                layout_data = json.load(data_file)\n        except Exception as e:\n            layout_data = None\n            print('Cannot read data from file.\\n{}'.format(e))\n\n        if not layout_data:\n            return\n\n        self._deserialize(layout_data)\n        self._undo_stack.clear()\n        self._model.session = file_path\n\n    def copy_nodes(self, nodes=None):\n        \"\"\"\n        copy nodes to the clipboard by default this method copies\n        the selected nodes from the node graph.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n        \"\"\"\n        nodes = nodes or self.selected_nodes()\n        if not nodes:\n            return False\n        clipboard = QClipboard()\n        serial_data = self._serialize(nodes)\n        serial_str = json.dumps(serial_data)\n        if serial_str:\n            clipboard.setText(serial_str)\n            return True\n        return False\n\n    def paste_nodes(self):\n        \"\"\"\n        Pastes nodes from the clipboard.\n        \"\"\"\n        clipboard = QClipboard()\n        cb_string = clipboard.text()\n        if not cb_string:\n            return\n\n        self._undo_stack.beginMacro('pasted nodes')\n        serial_data = json.loads(cb_string)\n        self.clear_selection()\n        nodes = self._deserialize(serial_data, True)\n        [n.set_selected(True) for n in nodes]\n        self._undo_stack.endMacro()\n\n    def duplicate_nodes(self, nodes):\n        \"\"\"\n        Create duplicates nodes.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node objects.\n        Returns:\n            list[NodeGraphQt.Node]: list of duplicated node instances.\n        \"\"\"\n        if not nodes:\n            return\n\n        self._undo_stack.beginMacro('duplicated nodes')\n\n        self.clear_selection()\n        serial = self._serialize(nodes)\n        new_nodes = self._deserialize(serial)\n        offset = 50\n        for n in new_nodes:\n            x, y = n.pos()\n            n.set_pos(x + offset, y + offset)\n            n.set_property('selected', True)\n\n        self._undo_stack.endMacro()\n        return new_nodes\n\n    def disable_nodes(self, nodes, mode=None):\n        \"\"\"\n        Disable/Enable specified nodes.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n            mode (bool): (optional) disable state of the nodes.\n        \"\"\"\n        if not nodes:\n            return\n        if mode is None:\n            mode = not nodes[0].disabled()\n        if len(nodes) > 1:\n            text = {False: 'enabled', True: 'disabled'}[mode]\n            text = '{} ({}) nodes'.format(text, len(nodes))\n            self._undo_stack.beginMacro(text)\n            [n.set_disabled(mode) for n in nodes]\n            self._undo_stack.endMacro()\n            return\n        nodes[0].set_disabled(mode)",
  "def __init__(self, parent=None):\n        super(NodeGraph, self).__init__(parent)\n        self._model = NodeGraphModel()\n        self._viewer = NodeViewer()\n        self._undo_stack = QUndoStack(self)\n        self._init_actions()\n        self._wire_signals()",
  "def _wire_signals(self):\n        self._viewer.moved_nodes.connect(self._on_nodes_moved)\n        self._viewer.search_triggered.connect(self._on_search_triggered)\n        self._viewer.connection_changed.connect(self._on_connection_changed)\n        self._viewer.node_selected.connect(self._on_node_selected)",
  "def _init_actions(self):\n        # setup tab search shortcut.\n        tab = QAction('Search Nodes', self)\n        tab.setShortcut('tab')\n        tab.triggered.connect(self._toggle_tab_search)\n        self._viewer.addAction(tab)\n        setup_actions(self)",
  "def _toggle_tab_search(self):\n        \"\"\"\n        toggle the tab search widget.\n        \"\"\"\n        self._viewer.tab_search_set_nodes(NodeVendor.names)\n        self._viewer.tab_search_toggle()",
  "def _on_nodes_moved(self, node_data):\n        \"\"\"\n        called when selected nodes in the viewer has changed position.\n\n        Args:\n            node_data (dict): {<node_view>: <previous_pos>}\n        \"\"\"\n        self._undo_stack.beginMacro('moved nodes')\n        for node_view, prev_pos in node_data.items():\n            node = self._model.nodes[node_view.id]\n            self._undo_stack.push(NodeMovedCmd(node, node.pos(), prev_pos))\n        self._undo_stack.endMacro()",
  "def _on_node_selected(self, node_id):\n        \"\"\"\n        called when a node in the viewer is selected on left click.\n        (emits the node object when the node is clicked)\n\n        Args:\n            node_id (str): node id emitted by the viewer.\n        \"\"\"\n        node = self.get_node_by_id(node_id)\n        self.node_selected.emit(node)",
  "def _on_search_triggered(self, node_type, pos):\n        \"\"\"\n        called when the tab search widget is triggered in the viewer.\n\n        Args:\n            node_type (str): node identifier.\n            pos (tuple): x,y position for the node.\n        \"\"\"\n        self.create_node(node_type, pos=pos)",
  "def _on_connection_changed(self, disconnected, connected):\n        \"\"\"\n        called when a pipe connection has been changed in the viewer.\n\n        Args:\n            disconnected (list[list[widgets.port.PortItem]):\n                pair list of port view items.\n            connected (list[list[widgets.port.PortItem]]):\n                pair list of port view items.\n        \"\"\"\n        if not (disconnected or connected):\n            return\n\n        label = 'connected node(s)' if connected else 'disconnected node(s)'\n        ptypes = {'in': 'inputs', 'out': 'outputs'}\n\n        self._undo_stack.beginMacro(label)\n        for p1_view, p2_view in disconnected:\n            node1 = self._model.nodes[p1_view.node.id]\n            node2 = self._model.nodes[p2_view.node.id]\n            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]\n            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]\n            port1.disconnect_from(port2)\n        for p1_view, p2_view in connected:\n            node1 = self._model.nodes[p1_view.node.id]\n            node2 = self._model.nodes[p2_view.node.id]\n            port1 = getattr(node1, ptypes[p1_view.port_type])()[p1_view.name]\n            port2 = getattr(node2, ptypes[p2_view.port_type])()[p2_view.name]\n            port1.connect_to(port2)\n        self._undo_stack.endMacro()",
  "def model(self):\n        \"\"\"\n        Return the node graph model.\n\n        Returns:\n            NodeGraphModel: model object.\n        \"\"\"\n        return self._model",
  "def show(self):\n        \"\"\"\n        Show node graph viewer widget.\n        \"\"\"\n        self._viewer.show()",
  "def hide(self):\n        \"\"\"\n        Hide node graph viewer widget.\n        \"\"\"\n        self._viewer.hide()",
  "def close(self):\n        \"\"\"\n        Close node graph viewer widget.\n        \"\"\"\n        self._viewer.close()",
  "def viewer(self):\n        \"\"\"\n        Return the node graph viewer widget object.\n\n        Returns:\n            NodeGraphQt.widgets.viewer.NodeViewer: viewer widget.\n        \"\"\"\n        return self._viewer",
  "def scene(self):\n        \"\"\"\n        Return the scene object.\n\n        Returns:\n            NodeGraphQt.widgets.scene.NodeScene: node scene.\n        \"\"\"\n        return self._viewer.scene()",
  "def undo_stack(self):\n        \"\"\"\n        Returns the undo stack used in the node graph\n\n        Returns:\n            QUndoStack: undo stack.\n        \"\"\"\n        return self._undo_stack",
  "def begin_undo(self, name='undo'):\n        \"\"\"\n        Start of an undo block followed by a end_undo().\n\n        Args:\n            name (str): name for the undo block.\n        \"\"\"\n        self._undo_stack.beginMacro(name)",
  "def end_undo(self):\n        \"\"\"\n        End of an undo block started by begin_undo().\n        \"\"\"\n        self._undo_stack.endMacro()",
  "def context_menu(self):\n        \"\"\"\n        Returns a node graph context menu object.\n\n        Returns:\n            ContextMenu: node graph context menu object instance.\n        \"\"\"\n        return self._viewer.context_menu()",
  "def acyclic(self):\n        \"\"\"\n        Returns true if the current node graph is acyclic.\n\n        Returns:\n            bool: true if acyclic.\n        \"\"\"\n        return self._model.acyclic",
  "def set_acyclic(self, mode=True):\n        \"\"\"\n        Set the node graph to be acyclic or not. (default=True)\n\n        Args:\n            mode (bool): false to disable acyclic.\n        \"\"\"\n        self._model.acyclic = mode\n        self._viewer.acyclic = mode",
  "def set_pipe_layout(self, layout='curved'):\n        \"\"\"\n        Set node graph pipes to be drawn straight or curved by default\n        all pipes are set curved. (default='curved')\n\n        Args:\n            layout (str): 'straight' or 'curved'\n        \"\"\"\n        self._viewer.set_pipe_layout(layout)",
  "def fit_to_selection(self):\n        \"\"\"\n        Sets the zoom level to fit selected nodes.\n        If no nodes are selected then all nodes in the graph will be framed.\n        \"\"\"\n        nodes = self.selected_nodes() or self.all_nodes()\n        if not nodes:\n            return\n        self._viewer.zoom_to_nodes([n.view for n in nodes])",
  "def reset_zoom(self):\n        \"\"\"\n        Reset the zoom level\n        \"\"\"\n        self._viewer.reset_zoom()",
  "def set_zoom(self, zoom=0):\n        \"\"\"\n        Set the zoom factor of the Node Graph the default is 0.0\n\n        Args:\n            zoom (float): zoom factor max zoom out -0.9 max zoom in 2.0\n        \"\"\"\n        self._viewer.set_zoom(zoom)",
  "def get_zoom(self):\n        \"\"\"\n        Get the current zoom level of the node graph.\n\n        Returns:\n            float: the current zoom level.\n        \"\"\"\n        return self._viewer.get_zoom()",
  "def center_on(self, nodes=None):\n        \"\"\"\n        Center the node graph on the given nodes or all nodes by default.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): a list of nodes.\n        \"\"\"\n        self._viewer.center_selection(nodes)",
  "def center_selection(self):\n        \"\"\"\n        Center the node graph on the current selected nodes.\n        \"\"\"\n        nodes = self._viewer.selected_nodes()\n        self._viewer.center_selection(nodes)",
  "def registered_nodes(self):\n        \"\"\"\n        Return a list of all node types that have been registered.\n        To register a node see \"NodeGraphWidget.register_node()\"\n\n        Returns:\n            list[str]: node types.\n        \"\"\"\n        return sorted(NodeVendor.nodes.keys())",
  "def register_node(self, node, alias=None):\n        \"\"\"\n        Register a node.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n            alias (str): custom alias name for the node type.\n        \"\"\"\n        NodeVendor.register_node(node, alias)",
  "def create_node(self, node_type, name=None, selected=True, color=None, pos=None):\n        \"\"\"\n        Create a new node in the node graph.\n        To list all node types see \"NodeGraphWidget.registered_nodes()\"\n\n        Args:\n            node_type (str): node instance type.\n            name (str): set name of the node.\n            selected (bool): set created node to be selected.\n            color (tuple or str): node color (255, 255, 255) or '#FFFFFF'.\n            pos (tuple): set position of the node (x, y).\n\n        Returns:\n            NodeGraphQt.Node: created instance of a node.\n        \"\"\"\n        NodeInstance = NodeVendor.create_node_instance(node_type)\n        if NodeInstance:\n            node = NodeInstance()\n            node._graph = self\n            node.update()\n\n            self._undo_stack.beginMacro('created node')\n            self._undo_stack.push(NodeAddedCmd(self, node, pos))\n            if name:\n                node.set_name(name)\n            else:\n                node.set_name(node.NODE_NAME)\n            if color:\n                if isinstance(color, str):\n                    color = color[1:] if color[0] is '#' else color\n                    color = tuple(int(color[i:i + 2], 16) for i in (0, 2, 4))\n                node.set_color(*color)\n            node.set_selected(selected)\n            self._undo_stack.endMacro()\n            return node\n        raise Exception('\\n\\n>> Cannot find node:\\t\"{}\"\\n'.format(node_type))",
  "def add_node(self, node):\n        \"\"\"\n        Add a node into the node graph.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n        \"\"\"\n        assert isinstance(node, NodeObject), 'node must be a Node instance.'\n        node._graph = self\n        node.NODE_NAME = self.get_unique_name(node.NODE_NAME)\n        node.model.name = node.NODE_NAME\n        node.update()\n        self._undo_stack.push(NodeAddedCmd(self, node))",
  "def delete_node(self, node):\n        \"\"\"\n        Remove the node from the node graph.\n\n        Args:\n            node (NodeGraphQt.Node): node object.\n        \"\"\"\n        assert isinstance(node, NodeObject), \\\n            'node must be a instance of a NodeObject.'\n        self._undo_stack.push(NodeRemovedCmd(self, node))",
  "def delete_nodes(self, nodes):\n        \"\"\"\n        Remove a list of nodes from the node graph.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n        \"\"\"\n        self._undo_stack.beginMacro('deleted nodes')\n        [self.delete_node(n) for n in nodes]\n        self._undo_stack.endMacro()",
  "def all_nodes(self):\n        \"\"\"\n        Return all nodes in the node graph.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of nodes.\n        \"\"\"\n        return list(self._model.nodes.values())",
  "def selected_nodes(self):\n        \"\"\"\n        Return all selected nodes that are in the node graph.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of nodes.\n        \"\"\"\n        nodes = []\n        for item in self._viewer.selected_nodes():\n            node = self._model.nodes[item.id]\n            nodes.append(node)\n        return nodes",
  "def select_all(self):\n        \"\"\"\n        Select all nodes in the current node graph.\n        \"\"\"\n        self._undo_stack.beginMacro('select all')\n        for node in self.all_nodes():\n            node.set_selected(True)\n        self._undo_stack.endMacro()",
  "def clear_selection(self):\n        \"\"\"\n        Clears the selection in the node graph.\n        \"\"\"\n        self._undo_stack.beginMacro('deselected nodes')\n        for node in self.all_nodes():\n            node.set_selected(False)\n        self._undo_stack.endMacro()",
  "def get_node_by_id(self, node_id=None):\n        \"\"\"\n        Get the node object by it's id.\n\n        Args:\n            node_id (str): node id\n\n        Returns:\n            NodeGraphQt.NodeObject: node object.\n        \"\"\"\n        return self._model.nodes.get(node_id)",
  "def get_node_by_name(self, name):\n        \"\"\"\n        Returns node object that matches the name.\n\n        Args:\n            name (str): name of the node.\n        Returns:\n            NodeGraphQt.Node: node object.\n        \"\"\"\n        for node_id, node in self._model.nodes.items():\n            if node.name() == name:\n                return node",
  "def get_unique_name(self, name):\n        \"\"\"\n        return a unique node name for the node.\n\n        Args:\n            name (str): node name.\n\n        Returns:\n            str: unique node name.\n        \"\"\"\n        name = ' '.join(name.split())\n        node_names = [n.name() for n in self.all_nodes()]\n        if name not in node_names:\n            return name\n\n        regex = re.compile('[\\w ]+(?: )*(\\d+)')\n        search = regex.search(name)\n        if not search:\n            for x in range(1, len(node_names) + 1):\n                new_name = '{} {}'.format(name, x)\n                if new_name not in node_names:\n                    return new_name\n\n        version = search.group(1)\n        name = name[:len(version) * -1].strip()\n        for x in range(1, len(node_names) + 1):\n            new_name = '{} {}'.format(name, x)\n            if new_name not in node_names:\n                return new_name",
  "def current_session(self):\n        \"\"\"\n        returns the file path to the currently loaded session.\n\n        Returns:\n            str: path to the currently loaded session\n        \"\"\"\n        return self._model.session",
  "def clear_session(self):\n        \"\"\"\n        clear the loaded node layout session.\n        \"\"\"\n        for n in self.all_nodes():\n            self.delete_node(n)\n        self._undo_stack.clear()\n        self._model.session = None",
  "def _serialize(self, nodes):\n        \"\"\"\n        serialize nodes to a dict.\n\n        Args:\n            nodes (list[NodeGraphQt.Nodes]): list of node instances.\n\n        Returns:\n            dict: serialized data.\n        \"\"\"\n        serial_data = {'nodes': {}, 'connections': []}\n        nodes_data = {}\n        for n in nodes:\n\n            # update the node model.\n            n.update_model()\n\n            nodes_data.update(n.model.to_dict)\n\n        for n_id, n_data in nodes_data.items():\n            serial_data['nodes'][n_id] = n_data\n\n            inputs = n_data.pop('inputs') if n_data.get('inputs') else {}\n            outputs = n_data.pop('outputs') if n_data.get('outputs') else {}\n\n            for pname, conn_data in inputs.items():\n                for conn_id, prt_names in conn_data.items():\n                    for conn_prt in prt_names:\n                        pipe = {'in': [n_id, pname], 'out': [conn_id, conn_prt]}\n                        if pipe not in serial_data['connections']:\n                            serial_data['connections'].append(pipe)\n\n            for pname, conn_data in outputs.items():\n                for conn_id, prt_names in conn_data.items():\n                    for conn_prt in prt_names:\n                        pipe = {'out': [n_id, pname], 'in': [conn_id, conn_prt]}\n                        if pipe not in serial_data['connections']:\n                            serial_data['connections'].append(pipe)\n\n        if not serial_data['connections']:\n            serial_data.pop('connections')\n\n        return serial_data",
  "def _deserialize(self, data, relative_pos=False, pos=None):\n        \"\"\"\n        deserialize node data.\n\n        Args:\n            data (dict): node data.\n            relative_pos (bool): position node relative to the cursor.\n\n        Returns:\n            list[NodeGraphQt.Nodes]: list of node instances.\n        \"\"\"\n        nodes = {}\n\n        # build the nodes.\n        for n_id, n_data in data.get('nodes', {}).items():\n            identifier = n_data['type']\n            NodeInstance = NodeVendor.create_node_instance(identifier)\n            if NodeInstance:\n                node = NodeInstance()\n                node._graph = self\n\n                name = self.get_unique_name(n_data.get('name', node.NODE_NAME))\n                n_data['name'] = name\n\n                # set properties.\n                for prop, val in node.model.properties.items():\n                    if prop in n_data.keys():\n                        setattr(node.model, prop, n_data[prop])\n\n                # set custom properties.\n                for prop, val in n_data.get('custom', {}).items():\n                    if prop in node.model.custom_properties.keys():\n                        node.model.custom_properties[prop] = val\n\n                node.update()\n\n                self._undo_stack.push(\n                    NodeAddedCmd(self, node, n_data.get('pos'))\n                )\n                nodes[n_id] = node\n\n        # build the connections.\n        for connection in data.get('connections', []):\n            nid, pname = connection.get('in', ('', ''))\n            in_node = nodes.get(nid)\n            if not in_node:\n                continue\n            in_port = in_node.inputs().get(pname) if in_node else None\n\n            nid, pname = connection.get('out', ('', ''))\n            out_node = nodes.get(nid)\n            if not out_node:\n                continue\n            out_port = out_node.outputs().get(pname) if out_node else None\n\n            if in_port and out_port:\n                self._undo_stack.push(PortConnectedCmd(in_port, out_port))\n\n        node_objs = list(nodes.values())\n        if relative_pos:\n            self._viewer.move_nodes([n.view for n in node_objs])\n            [setattr(n.model, 'pos', n.view.pos) for n in node_objs]\n        elif pos:\n            self._viewer.move_nodes([n.view for n in node_objs], pos=pos)\n\n        return node_objs",
  "def save_session(self, file_path):\n        \"\"\"\n        Saves the current node graph session layout to a JSON formatted file.\n\n        Args:\n            file_path (str): path to the saved node layout.\n        \"\"\"\n        serliazed_data = self._serialize(self.selected_nodes())\n        file_path = file_path.strip()\n        with open(file_path, 'w') as file_out:\n            json.dump(serliazed_data, file_out, indent=2, separators=(',', ':'))",
  "def load_session(self, file_path):\n        \"\"\"\n        Load node graph session layout file.\n\n        Args:\n            file_path (str): path to the serialized layout file.\n        \"\"\"\n        file_path = file_path.strip()\n        if not os.path.isfile(file_path):\n            raise IOError('file does not exist.')\n\n        self.clear_session()\n\n        try:\n            with open(file_path) as data_file:\n                layout_data = json.load(data_file)\n        except Exception as e:\n            layout_data = None\n            print('Cannot read data from file.\\n{}'.format(e))\n\n        if not layout_data:\n            return\n\n        self._deserialize(layout_data)\n        self._undo_stack.clear()\n        self._model.session = file_path",
  "def copy_nodes(self, nodes=None):\n        \"\"\"\n        copy nodes to the clipboard by default this method copies\n        the selected nodes from the node graph.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n        \"\"\"\n        nodes = nodes or self.selected_nodes()\n        if not nodes:\n            return False\n        clipboard = QClipboard()\n        serial_data = self._serialize(nodes)\n        serial_str = json.dumps(serial_data)\n        if serial_str:\n            clipboard.setText(serial_str)\n            return True\n        return False",
  "def paste_nodes(self):\n        \"\"\"\n        Pastes nodes from the clipboard.\n        \"\"\"\n        clipboard = QClipboard()\n        cb_string = clipboard.text()\n        if not cb_string:\n            return\n\n        self._undo_stack.beginMacro('pasted nodes')\n        serial_data = json.loads(cb_string)\n        self.clear_selection()\n        nodes = self._deserialize(serial_data, True)\n        [n.set_selected(True) for n in nodes]\n        self._undo_stack.endMacro()",
  "def duplicate_nodes(self, nodes):\n        \"\"\"\n        Create duplicates nodes.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node objects.\n        Returns:\n            list[NodeGraphQt.Node]: list of duplicated node instances.\n        \"\"\"\n        if not nodes:\n            return\n\n        self._undo_stack.beginMacro('duplicated nodes')\n\n        self.clear_selection()\n        serial = self._serialize(nodes)\n        new_nodes = self._deserialize(serial)\n        offset = 50\n        for n in new_nodes:\n            x, y = n.pos()\n            n.set_pos(x + offset, y + offset)\n            n.set_property('selected', True)\n\n        self._undo_stack.endMacro()\n        return new_nodes",
  "def disable_nodes(self, nodes, mode=None):\n        \"\"\"\n        Disable/Enable specified nodes.\n\n        Args:\n            nodes (list[NodeGraphQt.Node]): list of node instances.\n            mode (bool): (optional) disable state of the nodes.\n        \"\"\"\n        if not nodes:\n            return\n        if mode is None:\n            mode = not nodes[0].disabled()\n        if len(nodes) > 1:\n            text = {False: 'enabled', True: 'disabled'}[mode]\n            text = '{} ({}) nodes'.format(text, len(nodes))\n            self._undo_stack.beginMacro(text)\n            [n.set_disabled(mode) for n in nodes]\n            self._undo_stack.endMacro()\n            return\n        nodes[0].set_disabled(mode)",
  "class PropertyChangedCmd(QUndoCommand):\n    \"\"\"\n    Node property changed command.\n    \"\"\"\n\n    def __init__(self, node, name, value):\n        QUndoCommand.__init__(self)\n        self.setText('set {} ({})'.format(name, node.name()))\n        self.node = node\n        self.name = name\n        self.old_val = node.get_property(name)\n        self.new_val = value\n\n    def set_node_prop(self, name, value):\n        # set model data.\n        model = self.node.model\n        if name in model.properties.keys():\n            setattr(model, name, value)\n        elif name in model.custom_properties.keys():\n            model.custom_properties[name] = value\n        else:\n            raise KeyError('No property \"{}\"'.format(name))\n\n        # set view data.\n        view = self.node.view\n\n        # view widgets.\n        if hasattr(view, 'widgets') and name in view.widgets.keys():\n            view.widgets[name].value = value\n\n        # view properties.\n        if name in view.properties.keys():\n            setattr(view, name, value)\n\n    def undo(self):\n        if self.old_val != self.new_val:\n            self.set_node_prop(self.name, self.old_val)\n\n    def redo(self):\n        if self.old_val != self.new_val:\n            self.set_node_prop(self.name, self.new_val)",
  "class NodeMovedCmd(QUndoCommand):\n    \"\"\"\n    Node moved command.\n    \"\"\"\n\n    def __init__(self, node, pos, prev_pos):\n        QUndoCommand.__init__(self)\n        self.node = node\n        self.pos = pos\n        self.prev_pos = prev_pos\n\n    def undo(self):\n        self.node.view.pos = self.prev_pos\n        self.node.model.pos = self.prev_pos\n\n    def redo(self):\n        if self.pos == self.prev_pos:\n            return\n        self.node.view.pos = self.pos\n        self.node.model.pos = self.pos",
  "class NodeAddedCmd(QUndoCommand):\n    \"\"\"\n    Node added command.\n    \"\"\"\n\n    def __init__(self, graph, node, pos=None):\n        QUndoCommand.__init__(self)\n        self.setText('added node')\n        self.graph = graph\n        self.node = node\n        self.pos = pos\n\n    def undo(self):\n        self.pos = self.pos or self.node.pos()\n        self.graph.model.nodes.pop(self.node.id)\n        self.node.view.delete()\n\n    def redo(self):\n        self.graph.model.nodes[self.node.id] = self.node\n        self.graph.viewer().add_node(self.node.view, self.pos)",
  "class NodeRemovedCmd(QUndoCommand):\n    \"\"\"\n    Node deleted command.\n    \"\"\"\n\n    def __init__(self, graph, node):\n        QUndoCommand.__init__(self)\n        self.setText('deleted node')\n        self.graph = graph\n        self.node = node\n        self.inputs = []\n        self.outputs = []\n        if hasattr(self.node, 'inputs'):\n            input_ports = self.node.inputs().values()\n            self.inputs = [(p, p.connected_ports()) for p in input_ports]\n        if hasattr(self.node, 'outputs'):\n            output_ports = self.node.outputs().values()\n            self.outputs = [(p, p.connected_ports()) for p in output_ports]\n\n    def undo(self):\n        self.graph.model.nodes[self.node.id] = self.node\n        self.graph.scene().addItem(self.node.view)\n        for port, connected_ports in self.inputs:\n            [port.connect_to(p) for p in connected_ports]\n        for port, connected_ports in self.outputs:\n            [port.connect_to(p) for p in connected_ports]\n\n    def redo(self):\n        for port, connected_ports in self.inputs:\n            [port.disconnect_from(p) for p in connected_ports]\n        for port, connected_ports in self.outputs:\n            [port.disconnect_from(p) for p in connected_ports]\n        self.graph.model.nodes.pop(self.node.id)\n        self.node.view.delete()",
  "class PortConnectedCmd(QUndoCommand):\n    \"\"\"\n    Port connected command.\n    \"\"\"\n\n    def __init__(self, src_port, trg_port):\n        QUndoCommand.__init__(self)\n        self.source = src_port\n        self.target = trg_port\n\n    def undo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        port_names = src_model.connected_ports.get(trg_id)\n        if port_names is []:\n            del src_model.connected_ports[trg_id]\n        if port_names and self.target.name() in port_names:\n            port_names.remove(self.target.name())\n\n        port_names = trg_model.connected_ports.get(src_id)\n        if port_names is []:\n            del trg_model.connected_ports[src_id]\n        if port_names and self.source.name() in port_names:\n            port_names.remove(self.source.name())\n\n        self.source.view.disconnect_from(self.target.view)\n\n    def redo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        src_model.connected_ports[trg_id].append(self.target.name())\n        trg_model.connected_ports[src_id].append(self.source.name())\n\n        self.source.view.connect_to(self.target.view)",
  "class PortDisconnectedCmd(QUndoCommand):\n    \"\"\"\n    Port disconnected command.\n    \"\"\"\n\n    def __init__(self, src_port, trg_port):\n        QUndoCommand.__init__(self)\n        self.source = src_port\n        self.target = trg_port\n\n    def undo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        src_model.connected_ports[trg_id].append(self.target.name())\n        trg_model.connected_ports[src_id].append(self.source.name())\n\n        self.source.view.connect_to(self.target.view)\n\n    def redo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        port_names = src_model.connected_ports.get(trg_id)\n        if port_names is []:\n            del src_model.connected_ports[trg_id]\n        if port_names and self.target.name() in port_names:\n            port_names.remove(self.target.name())\n\n        port_names = trg_model.connected_ports.get(src_id)\n        if port_names is []:\n            del trg_model.connected_ports[src_id]\n        if port_names and self.source.name() in port_names:\n            port_names.remove(self.source.name())\n\n        self.source.view.disconnect_from(self.target.view)",
  "def __init__(self, node, name, value):\n        QUndoCommand.__init__(self)\n        self.setText('set {} ({})'.format(name, node.name()))\n        self.node = node\n        self.name = name\n        self.old_val = node.get_property(name)\n        self.new_val = value",
  "def set_node_prop(self, name, value):\n        # set model data.\n        model = self.node.model\n        if name in model.properties.keys():\n            setattr(model, name, value)\n        elif name in model.custom_properties.keys():\n            model.custom_properties[name] = value\n        else:\n            raise KeyError('No property \"{}\"'.format(name))\n\n        # set view data.\n        view = self.node.view\n\n        # view widgets.\n        if hasattr(view, 'widgets') and name in view.widgets.keys():\n            view.widgets[name].value = value\n\n        # view properties.\n        if name in view.properties.keys():\n            setattr(view, name, value)",
  "def undo(self):\n        if self.old_val != self.new_val:\n            self.set_node_prop(self.name, self.old_val)",
  "def redo(self):\n        if self.old_val != self.new_val:\n            self.set_node_prop(self.name, self.new_val)",
  "def __init__(self, node, pos, prev_pos):\n        QUndoCommand.__init__(self)\n        self.node = node\n        self.pos = pos\n        self.prev_pos = prev_pos",
  "def undo(self):\n        self.node.view.pos = self.prev_pos\n        self.node.model.pos = self.prev_pos",
  "def redo(self):\n        if self.pos == self.prev_pos:\n            return\n        self.node.view.pos = self.pos\n        self.node.model.pos = self.pos",
  "def __init__(self, graph, node, pos=None):\n        QUndoCommand.__init__(self)\n        self.setText('added node')\n        self.graph = graph\n        self.node = node\n        self.pos = pos",
  "def undo(self):\n        self.pos = self.pos or self.node.pos()\n        self.graph.model.nodes.pop(self.node.id)\n        self.node.view.delete()",
  "def redo(self):\n        self.graph.model.nodes[self.node.id] = self.node\n        self.graph.viewer().add_node(self.node.view, self.pos)",
  "def __init__(self, graph, node):\n        QUndoCommand.__init__(self)\n        self.setText('deleted node')\n        self.graph = graph\n        self.node = node\n        self.inputs = []\n        self.outputs = []\n        if hasattr(self.node, 'inputs'):\n            input_ports = self.node.inputs().values()\n            self.inputs = [(p, p.connected_ports()) for p in input_ports]\n        if hasattr(self.node, 'outputs'):\n            output_ports = self.node.outputs().values()\n            self.outputs = [(p, p.connected_ports()) for p in output_ports]",
  "def undo(self):\n        self.graph.model.nodes[self.node.id] = self.node\n        self.graph.scene().addItem(self.node.view)\n        for port, connected_ports in self.inputs:\n            [port.connect_to(p) for p in connected_ports]\n        for port, connected_ports in self.outputs:\n            [port.connect_to(p) for p in connected_ports]",
  "def redo(self):\n        for port, connected_ports in self.inputs:\n            [port.disconnect_from(p) for p in connected_ports]\n        for port, connected_ports in self.outputs:\n            [port.disconnect_from(p) for p in connected_ports]\n        self.graph.model.nodes.pop(self.node.id)\n        self.node.view.delete()",
  "def __init__(self, src_port, trg_port):\n        QUndoCommand.__init__(self)\n        self.source = src_port\n        self.target = trg_port",
  "def undo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        port_names = src_model.connected_ports.get(trg_id)\n        if port_names is []:\n            del src_model.connected_ports[trg_id]\n        if port_names and self.target.name() in port_names:\n            port_names.remove(self.target.name())\n\n        port_names = trg_model.connected_ports.get(src_id)\n        if port_names is []:\n            del trg_model.connected_ports[src_id]\n        if port_names and self.source.name() in port_names:\n            port_names.remove(self.source.name())\n\n        self.source.view.disconnect_from(self.target.view)",
  "def redo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        src_model.connected_ports[trg_id].append(self.target.name())\n        trg_model.connected_ports[src_id].append(self.source.name())\n\n        self.source.view.connect_to(self.target.view)",
  "def __init__(self, src_port, trg_port):\n        QUndoCommand.__init__(self)\n        self.source = src_port\n        self.target = trg_port",
  "def undo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        src_model.connected_ports[trg_id].append(self.target.name())\n        trg_model.connected_ports[src_id].append(self.source.name())\n\n        self.source.view.connect_to(self.target.view)",
  "def redo(self):\n        src_model = self.source.model\n        trg_model = self.target.model\n        src_id = self.source.node().id\n        trg_id = self.target.node().id\n\n        port_names = src_model.connected_ports.get(trg_id)\n        if port_names is []:\n            del src_model.connected_ports[trg_id]\n        if port_names and self.target.name() in port_names:\n            port_names.remove(self.target.name())\n\n        port_names = trg_model.connected_ports.get(src_id)\n        if port_names is []:\n            del trg_model.connected_ports[src_id]\n        if port_names and self.source.name() in port_names:\n            port_names.remove(self.source.name())\n\n        self.source.view.disconnect_from(self.target.view)",
  "class Port(object):\n\n    def __init__(self, node, port):\n        \"\"\"\n        Args:\n            node (NodeGraphQt.NodeObject): parent node object.\n            port (NodeGraphQt.widgets.port.PortItem): port view item.\n        \"\"\"\n        self.__view = port\n        self.__model = PortModel(node)\n\n    def __repr__(self):\n        module = str(self.__class__.__module__)\n        port = str(self.__class__.__name__)\n        return '{}.{}(\\'{}\\')'.format(module, port, self.name())\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.node().id() == other.node().id()\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    @property\n    def view(self):\n        \"\"\"\n        returns the view item used in the scene.\n\n        Returns:\n            PortItem: port item.\n        \"\"\"\n        return self.__view\n\n    @property\n    def model(self):\n        \"\"\"\n        returns the port model.\n\n        Returns:\n            PortModel: port model.\n        \"\"\"\n        return self.__model\n\n    def type(self):\n        \"\"\"\n        Returns the port type.\n\n        Returns:\n            str: 'in' for input port or 'out' for output port.\n        \"\"\"\n        return self.model.type\n\n    def multi_connection(self):\n        \"\"\"\n        Returns if the ports is a single connection or not.\n\n        Returns:\n            bool: false if port is a single connection port\n        \"\"\"\n        return self.model.multi_connection\n\n    def node(self):\n        \"\"\"\n        Return the parent node of the port.\n\n        Returns:\n            NodeGraphQt.NodeObject: parent node object.\n        \"\"\"\n        return self.model.node\n\n    def name(self):\n        \"\"\"\n        name of the port.\n\n        Returns:\n            str: port name.\n        \"\"\"\n        return self.model.name\n\n    def connected_ports(self):\n        \"\"\"\n        Returns all connected ports.\n\n        Returns:\n            list[NodeGraphQt.Port]: list of connected ports.\n        \"\"\"\n        ports = []\n        graph = self.node().graph\n        for node_id, port_names in self.model.connected_ports.items():\n            for port_name in port_names:\n                node = graph.get_node_by_id(node_id)\n                if self.type() == 'in':\n                    ports.append(node.outputs()[port_name])\n                elif self.type() == 'out':\n                    ports.append(node.inputs()[port_name])\n        return ports\n\n    def connect_to(self, port=None):\n        \"\"\"\n        Create connection to the specified port.\n\n        Args:\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        if not port:\n            return\n\n        graph = self.node().graph\n        viewer = graph.viewer()\n        undo_stack = graph.undo_stack()\n\n        undo_stack.beginMacro('connected port')\n\n        pre_conn_port = None\n        src_conn_ports = self.connected_ports()\n        if not self.multi_connection() and src_conn_ports:\n            pre_conn_port = src_conn_ports[0]\n\n        if not port:\n            if pre_conn_port:\n                undo_stack.push(PortDisconnectedCmd(self, port))\n            return\n\n        if graph.acyclic() and viewer.acyclic_check(self.view, port.view):\n            if pre_conn_port:\n                undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))\n                return\n\n        trg_conn_ports = port.connected_ports()\n        if not port.multi_connection() and trg_conn_ports:\n            dettached_port = trg_conn_ports[0]\n            undo_stack.push(PortDisconnectedCmd(port, dettached_port))\n        if pre_conn_port:\n            undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))\n\n        undo_stack.push(PortConnectedCmd(self, port))\n        undo_stack.endMacro()\n\n    def disconnect_from(self, port=None):\n        \"\"\"\n        Disconnect from the specified port.\n\n        Args:\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        if not port:\n            return\n        graph = self.node().graph\n        graph._undo_stack.push(PortDisconnectedCmd(self, port))",
  "def __init__(self, node, port):\n        \"\"\"\n        Args:\n            node (NodeGraphQt.NodeObject): parent node object.\n            port (NodeGraphQt.widgets.port.PortItem): port view item.\n        \"\"\"\n        self.__view = port\n        self.__model = PortModel(node)",
  "def __repr__(self):\n        module = str(self.__class__.__module__)\n        port = str(self.__class__.__name__)\n        return '{}.{}(\\'{}\\')'.format(module, port, self.name())",
  "def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.node().id() == other.node().id()\n        return False",
  "def __ne__(self, other):\n        return not self.__eq__(other)",
  "def view(self):\n        \"\"\"\n        returns the view item used in the scene.\n\n        Returns:\n            PortItem: port item.\n        \"\"\"\n        return self.__view",
  "def model(self):\n        \"\"\"\n        returns the port model.\n\n        Returns:\n            PortModel: port model.\n        \"\"\"\n        return self.__model",
  "def type(self):\n        \"\"\"\n        Returns the port type.\n\n        Returns:\n            str: 'in' for input port or 'out' for output port.\n        \"\"\"\n        return self.model.type",
  "def multi_connection(self):\n        \"\"\"\n        Returns if the ports is a single connection or not.\n\n        Returns:\n            bool: false if port is a single connection port\n        \"\"\"\n        return self.model.multi_connection",
  "def node(self):\n        \"\"\"\n        Return the parent node of the port.\n\n        Returns:\n            NodeGraphQt.NodeObject: parent node object.\n        \"\"\"\n        return self.model.node",
  "def name(self):\n        \"\"\"\n        name of the port.\n\n        Returns:\n            str: port name.\n        \"\"\"\n        return self.model.name",
  "def connected_ports(self):\n        \"\"\"\n        Returns all connected ports.\n\n        Returns:\n            list[NodeGraphQt.Port]: list of connected ports.\n        \"\"\"\n        ports = []\n        graph = self.node().graph\n        for node_id, port_names in self.model.connected_ports.items():\n            for port_name in port_names:\n                node = graph.get_node_by_id(node_id)\n                if self.type() == 'in':\n                    ports.append(node.outputs()[port_name])\n                elif self.type() == 'out':\n                    ports.append(node.inputs()[port_name])\n        return ports",
  "def connect_to(self, port=None):\n        \"\"\"\n        Create connection to the specified port.\n\n        Args:\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        if not port:\n            return\n\n        graph = self.node().graph\n        viewer = graph.viewer()\n        undo_stack = graph.undo_stack()\n\n        undo_stack.beginMacro('connected port')\n\n        pre_conn_port = None\n        src_conn_ports = self.connected_ports()\n        if not self.multi_connection() and src_conn_ports:\n            pre_conn_port = src_conn_ports[0]\n\n        if not port:\n            if pre_conn_port:\n                undo_stack.push(PortDisconnectedCmd(self, port))\n            return\n\n        if graph.acyclic() and viewer.acyclic_check(self.view, port.view):\n            if pre_conn_port:\n                undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))\n                return\n\n        trg_conn_ports = port.connected_ports()\n        if not port.multi_connection() and trg_conn_ports:\n            dettached_port = trg_conn_ports[0]\n            undo_stack.push(PortDisconnectedCmd(port, dettached_port))\n        if pre_conn_port:\n            undo_stack.push(PortDisconnectedCmd(self, pre_conn_port))\n\n        undo_stack.push(PortConnectedCmd(self, port))\n        undo_stack.endMacro()",
  "def disconnect_from(self, port=None):\n        \"\"\"\n        Disconnect from the specified port.\n\n        Args:\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        if not port:\n            return\n        graph = self.node().graph\n        graph._undo_stack.push(PortDisconnectedCmd(self, port))",
  "class _NodeVendor(object):\n    \"\"\"\n    Node manager that stores all the node types.\n    \"\"\"\n\n    def __init__(self):\n        self._aliases = {}\n        self._names = {}\n        self._nodes = {}\n\n    @property\n    def names(self):\n        return self._names\n\n    @property\n    def aliases(self):\n        return self._aliases\n\n    @property\n    def nodes(self):\n        return self._nodes\n\n    def create_node_instance(self, node_type=None, alias=None):\n        \"\"\"\n        create node class by the node type identifier or alias.\n\n        Args:\n            node_type (str): node type.\n            alias (str): alias name (optional).\n\n        Returns:\n            NodeGraphQt.Node: new node instance object.\n        \"\"\"\n        if alias and self.aliases.get(alias):\n            node_type = self.aliases[alias]\n\n        NodeInstance = self._nodes.get(node_type)\n        if not NodeInstance:\n            print('can\\'t find node type {}'.format(node_type))\n        return NodeInstance\n\n    def register_node(self, node, alias=None):\n        \"\"\"\n        register the node.\n\n        Args:\n            node (Node): node item\n            alias (str): custom alias for the node (optional).\n        \"\"\"\n        if node is None:\n            return\n\n        name = node.NODE_NAME\n        node_type = node.type\n\n        if self._nodes.get(node_type):\n            raise AssertionError(\n                'Node: {} already exists! '\n                'Please specify a new plugin class name or identifier.'\n                .format(node_type))\n        self._nodes[node_type] = node\n\n        if self._names.get(node_type):\n            raise AssertionError(\n                'Node Name: {} already exists!'\n                'Please specify a new node name for node: {}'\n                .format(name, node_type))\n        self._names[name] = node_type\n\n        if alias:\n            if self._aliases.get(alias):\n                raise AssertionError(\n                    'Node Alias: {} already taken!'.format(alias))\n            self._aliases[alias] = node_type\n            \n    def clear_registered_nodes(self):\n       \"\"\"\n       clear out registered nodes, to prevent conflicts on reset\n       \"\"\"\n       self._nodes.clear()\n       self._names.clear()\n       self._aliases.clear()",
  "def __init__(self):\n        self._aliases = {}\n        self._names = {}\n        self._nodes = {}",
  "def names(self):\n        return self._names",
  "def aliases(self):\n        return self._aliases",
  "def nodes(self):\n        return self._nodes",
  "def create_node_instance(self, node_type=None, alias=None):\n        \"\"\"\n        create node class by the node type identifier or alias.\n\n        Args:\n            node_type (str): node type.\n            alias (str): alias name (optional).\n\n        Returns:\n            NodeGraphQt.Node: new node instance object.\n        \"\"\"\n        if alias and self.aliases.get(alias):\n            node_type = self.aliases[alias]\n\n        NodeInstance = self._nodes.get(node_type)\n        if not NodeInstance:\n            print('can\\'t find node type {}'.format(node_type))\n        return NodeInstance",
  "def register_node(self, node, alias=None):\n        \"\"\"\n        register the node.\n\n        Args:\n            node (Node): node item\n            alias (str): custom alias for the node (optional).\n        \"\"\"\n        if node is None:\n            return\n\n        name = node.NODE_NAME\n        node_type = node.type\n\n        if self._nodes.get(node_type):\n            raise AssertionError(\n                'Node: {} already exists! '\n                'Please specify a new plugin class name or identifier.'\n                .format(node_type))\n        self._nodes[node_type] = node\n\n        if self._names.get(node_type):\n            raise AssertionError(\n                'Node Name: {} already exists!'\n                'Please specify a new node name for node: {}'\n                .format(name, node_type))\n        self._names[name] = node_type\n\n        if alias:\n            if self._aliases.get(alias):\n                raise AssertionError(\n                    'Node Alias: {} already taken!'.format(alias))\n            self._aliases[alias] = node_type",
  "def clear_registered_nodes(self):\n       \"\"\"\n       clear out registered nodes, to prevent conflicts on reset\n       \"\"\"\n       self._nodes.clear()\n       self._names.clear()\n       self._aliases.clear()",
  "def setup_actions(graph):\n    \"\"\"\n    build the base node graph menu commands.\n\n    Args:\n        graph (NodeGraphQt.NodeGraph):\n    \"\"\"\n    root_menu = graph.context_menu()\n    file_menu = root_menu.add_menu('&File')\n    edit_menu = root_menu.add_menu('&Edit')\n\n    # File menu.\n    file_menu.add_command('Open...',\n                          lambda: open_session(graph),\n                          QtGui.QKeySequence.Open)\n    file_menu.add_command('Save...',\n                          lambda: save_session(graph),\n                          QtGui.QKeySequence.Save)\n    file_menu.add_command('Save As...',\n                          lambda: save_session_as(graph),\n                          QtGui.QKeySequence.SaveAs)\n    file_menu.add_command('Clear', lambda: clear_session(graph))\n\n    file_menu.add_separator()\n\n    file_menu.add_command('Zoom In', lambda: zoom_in(graph), '=')\n    file_menu.add_command('Zoom Out', lambda: zoom_out(graph), '-')\n    file_menu.add_command('Reset Zoom', graph.reset_zoom, 'h')\n\n    # Edit menu.\n    undo_actn = graph.undo_stack().createUndoAction(graph.viewer(), '&Undo')\n    undo_actn.setShortcuts(QtGui.QKeySequence.Undo)\n    edit_menu.add_action(undo_actn)\n\n    redo_actn = graph.undo_stack().createRedoAction(graph.viewer(), '&Redo')\n    redo_actn.setShortcuts(QtGui.QKeySequence.Redo)\n    edit_menu.add_action(redo_actn)\n\n    edit_menu.add_separator()\n\n    edit_menu.add_command('Copy', graph.copy_nodes, QtGui.QKeySequence.Copy)\n    edit_menu.add_command('Paste', graph.paste_nodes, QtGui.QKeySequence.Paste)\n    edit_menu.add_command('Delete',\n                          lambda: graph.delete_nodes(graph.selected_nodes()),\n                          QtGui.QKeySequence.Delete)\n\n    edit_menu.add_separator()\n\n    edit_menu.add_command('Select all', graph.select_all, 'Ctrl+A')\n    edit_menu.add_command('Deselect all', graph.clear_selection, 'Ctrl+Shift+A')\n    edit_menu.add_command('Enable/Disable',\n                          lambda: graph.disable_nodes(graph.selected_nodes()),\n                          'd')\n\n    edit_menu.add_command('Duplicate',\n                          lambda: graph.duplicate_nodes(graph.selected_nodes()),\n                          'Alt+c')\n    edit_menu.add_command('Center Selection',\n                          graph.fit_to_selection,\n                          'f')\n\n    edit_menu.add_separator()",
  "def zoom_in(graph):\n    zoom = graph.get_zoom() + 0.1\n    graph.set_zoom(zoom)",
  "def zoom_out(graph):\n    zoom = graph.get_zoom() - 0.2\n    graph.set_zoom(zoom)",
  "def open_session(graph):\n    file_dlg = QFileDialog.getOpenFileName(\n        graph.viewer(),\n        caption='Open Session Setup',\n        filter='Node Graph (*json) All Files (*)')\n    file_path = file_dlg[0]\n    if file_path:\n        graph.load_session(file_path)",
  "def save_session(graph):\n    current = graph.current_session()\n    if current:\n        graph.save_session(current)\n    else:\n        save_session_as(graph)",
  "def save_session_as(graph):\n    file_dlg = QFileDialog.getSaveFileName(\n        graph.viewer(),\n        caption='Save Session',\n        filter='Node Graph (*json})')\n    file_path = file_dlg[0]\n    if not file_path:\n        return\n    graph.save_session(file_path)",
  "def clear_session(graph):\n    viewer = graph.viewer()\n    if viewer.question_dialog('clear session', 'Clear current session?'):\n        graph.clear_session()",
  "class classproperty(object):\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, instance, owner):\n        return self.f(owner)",
  "class NodeObject(object):\n    \"\"\"\n    The base object of a node.\n    \"\"\"\n\n    __identifier__ = 'nodeGraphQt.nodes'\n\n    NODE_NAME = None\n\n    def __init__(self, node=None):\n        assert node, 'node cannot be None.'\n        self._graph = None\n        self._model = NodeModel()\n        self._model.type = self.type\n        self._model.name = self.NODE_NAME\n        self._view = node\n        self._view.type = self.type\n        self._view.name = self.model.name\n        self._view.id = self._model.id\n\n    def __repr__(self):\n        return '{}(\\'{}\\')'.format(self.type, self.NODE_NAME)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.id == other.id\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    @classproperty\n    def type(cls):\n        \"\"\"\n        node type identifier followed by the class name.\n        eg. com.chantasticvfx.FooNode\n\n        Returns:\n            str: node type.\n        \"\"\"\n        return cls.__identifier__ + '.' + cls.__name__\n\n    @property\n    def graph(self):\n        \"\"\"\n        The parent node graph.\n\n        Returns:\n            NodeGraphQt.NodeGraph: node graph.\n        \"\"\"\n        return self._graph\n\n    @property\n    def view(self):\n        \"\"\"\n        View item used in the scene.\n\n        Returns:\n            QtWidgets.QGraphicsItem: node item.\n        \"\"\"\n        return self._view\n\n    def set_view(self, item):\n        \"\"\"\n        set the view item for the scene.\n\n        Args:\n            item (AbstractNodeItem): node view item.\n        \"\"\"\n        self._view = item\n        self._view.id = self.model.id\n        self.NODE_NAME = self._view.name\n\n    @property\n    def model(self):\n        \"\"\"\n        returns the node model.\n\n        Returns:\n            NodeModel: node model object.\n        \"\"\"\n        return self._model\n\n    def set_model(self, model):\n        self._model = model\n        self._model.type = self.type\n        self._model.id = self.view.id\n\n    @property\n    def id(self):\n        \"\"\"\n        The node unique id.\n\n        Returns:\n            str: unique id string.\n        \"\"\"\n        return self.model.id\n\n    def update_model(self):\n        \"\"\"\n        update the node model from view.\n        \"\"\"\n        for name, val in self.view.properties.items():\n            if name in self.model.properties.keys():\n                setattr(self.model, name, val)\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = val\n\n    def update(self):\n        \"\"\"\n        Update the node view from model.\n        \"\"\"\n        settings = self.model.to_dict[self.model.id]\n        settings['id'] = self.model.id\n        if settings.get('custom'):\n            settings['widgets'] = settings.pop('custom')\n\n        self.view.from_dict(settings)\n\n    def name(self):\n        \"\"\"\n        Name of the node.\n\n        Returns:\n            str: name of the node.\n        \"\"\"\n        return self.model.name\n\n    def set_name(self, name=''):\n        \"\"\"\n        Set the name of the node.\n\n        Args:\n            name (str): name for the node.\n        \"\"\"\n        self.set_property('name', name)\n\n    def color(self):\n        \"\"\"\n        Returns the node color in (red, green, blue) value.\n\n        Returns:\n            tuple: (r, g, b) from 0-255 range.\n        \"\"\"\n        r, g, b, a = self.model.color\n        return r, g, b\n\n    def set_color(self, r=0, g=0, b=0):\n        \"\"\"\n        Sets the color of the node in (red, green, blue) value.\n\n        Args:\n            r (int): red value 0-255 range.\n            g (int): green value 0-255 range.\n            b (int): blue value 0-255 range.\n        \"\"\"\n        self.set_property('color', (r, g, b, 255))\n\n    def disabled(self):\n        \"\"\"\n        returns weather the node is enabled or disabled.\n\n        Returns:\n            bool: true if the node is disabled.\n        \"\"\"\n        return self.model.disabled\n\n    def set_disabled(self, mode=False):\n        \"\"\"\n        disables the node.\n\n        Args (bool): true to disable node.\n        \"\"\"\n        self.set_property('disabled', mode)\n\n    def selected(self):\n        \"\"\"\n        Returns the selected state of the node.\n\n        Returns:\n            bool: True if the node is selected.\n        \"\"\"\n        self.model.selected = self.view.isSelected()\n        return self.model.selected\n\n    def set_selected(self, selected=True):\n        \"\"\"\n        Set the node to be selected or not selected.\n\n        Args:\n            selected (bool): True to select the node.\n        \"\"\"\n        self.set_property('selected', selected)\n\n    def create_property(self, name, value):\n        \"\"\"\n        adds new property to the node.\n\n        Args:\n            name (str): name of the attribute.\n            value (str, int, float): data\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError('name must of str type.')\n        if not isinstance(value, (str, int, float, bool)):\n            err = 'value must be of type (String, Integer, Float, Bool)'\n            raise TypeError(err)\n        elif name in self.view.properties.keys():\n            raise KeyError('\"{}\" property already exists.'.format(name))\n        elif name in self.model.properties.keys():\n            raise KeyError('\"{}\" property already exists.'.format(name))\n        self.model.custom_properties[name] = value\n\n    def properties(self):\n        \"\"\"\n        Returns all the node properties.\n\n        Returns:\n            dict: a dictionary of node properties.\n        \"\"\"\n        return self.model.to_dict\n\n    def get_property(self, name):\n        \"\"\"\n        Return the node custom property.\n\n        Args:\n            name (str): name of the property.\n\n        Returns:\n            str, int or float: value of the node property.\n        \"\"\"\n        if name in self.model.custom_properties.keys():\n            if name == 'selected':\n                self.model.custom_properties[name] = self.view.selected\n            return self.model.custom_properties[name]\n        return self.model.properties.get(name)\n\n    def set_property(self, name, value):\n        \"\"\"\n        Set the value on the node custom property.\n\n        Args:\n            name (str): name of the property.\n            value: the new property value.\n        \"\"\"\n        if self.graph and name == 'name':\n            value = self.graph.get_unique_name(value)\n            self.NODE_NAME = value\n\n        exists = any([name in self.model.properties.keys(),\n                      name in self.model.custom_properties.keys()])\n        if not exists:\n            raise KeyError('No property \"{}\"'.format(name))\n\n        if self.graph:\n            undo_stack = self.graph.undo_stack()\n            undo_stack.push(PropertyChangedCmd(self, name, value))\n        else:\n            setattr(self.view, name, value)\n            if name in self.model.properties.keys():\n                setattr(self.model, name, value)\n            elif name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = value\n\n    def has_property(self, name):\n        \"\"\"\n        Check if node custom property exists.\n\n        Args:\n            name (str): name of the node.\n\n        Returns:\n            bool: true if property name exists in the Node.\n        \"\"\"\n        return name in self.model.properties.keys()\n\n    def set_x_pos(self, x=0.0):\n        \"\"\"\n        Set the node horizontal X position in the node graph.\n\n        Args:\n            x (float): node x position:\n        \"\"\"\n        y = self.pos()[1]\n        self.set_pos(x, y)\n\n    def set_y_pos(self, y=0.0):\n        \"\"\"\n        Set the node horizontal Y position in the node graph.\n\n        Args:\n            y (float): node x position:\n        \"\"\"\n\n        x = self.pos()[0]\n        self.set_pos(x, y)\n\n    def set_pos(self, x=0.0, y=0.0):\n        \"\"\"\n        Set the node X and Y position in the node graph.\n\n        Args:\n            x (float): node X position.\n            y (float): node Y position.\n        \"\"\"\n        self.set_property('pos', (x, y))\n        # self.view.pos = [x, y]\n        # self.model.pos = (x, y)\n\n    def x_pos(self):\n        \"\"\"\n        Get the node X position in the node graph.\n\n        Returns:\n            float: x position.\n        \"\"\"\n        return self.model.pos[0]\n\n    def y_pos(self):\n        \"\"\"\n        Get the node Y position in the node graph.\n\n        Returns:\n            float: y position.\n        \"\"\"\n        return self.model.pos[1]\n\n    def pos(self):\n        \"\"\"\n        Get the node XY position in the node graph.\n\n        Returns:\n            tuple(float, float): x, y position.\n        \"\"\"\n        if self.view.pos and self.view.pos != self.model.pos:\n            self.model.pos = self.view.pos\n\n        return self.model.pos",
  "class Node(NodeObject):\n    \"\"\"\n    Base class of a typical Node\n    \"\"\"\n\n    NODE_NAME = 'Base Node'\n\n    def __init__(self):\n        super(Node, self).__init__(NodeItem())\n        self._inputs = []\n        self._outputs = []\n\n    def _on_widget_changed(self, name, value):\n        self.model.custom_properties[name] = value\n\n    def update_model(self):\n        \"\"\"\n        update the node model from view.\n        \"\"\"\n        for name, val in self.view.properties.items():\n            if name in ['inputs', 'outputs']:\n                continue\n            if name in self.model.properties.keys():\n                setattr(self.model, name, val)\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = val\n        for name, widget in self.view.widgets.items():\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = widget.value\n\n    def set_property(self, name, value, update_widget=True):\n        \"\"\"\n        Set the value on the node custom property and updates the node widget.\n\n        Args:\n            name (str): name of the property.\n            value: the new property value.\n            update_widget (bool): update the node widget (default=True).\n        \"\"\"\n        node_widget = self.view.widgets.get(name)\n        if node_widget and update_widget:\n            node_widget.value = value\n        super(Node, self).set_property(name, value)\n\n    def set_icon(self, icon=None):\n        \"\"\"\n        Set the node icon.\n\n        Args:\n            icon (str): path to the icon image. \n        \"\"\"\n        self.set_property('icon', icon)\n\n    def icon(self):\n        \"\"\"\n        Node icon path.\n\n        Returns:\n            str: icon image file path.\n        \"\"\"\n        return self.model.icon\n\n    def add_input(self, name='input', multi_input=False, display_name=True):\n        \"\"\"\n        Add input port to node.\n\n        Args:\n            name (str): name for the input port. \n            multi_input (bool): allow port to have more than one connection.\n            display_name (bool): display the port name on the node.\n            \n        Returns:\n            NodeGraphQt.Port: the created port object.\n        \"\"\"\n        view = self.view.add_input(name, multi_input, display_name)\n        port = Port(self, view)\n        port.model.type = 'in'\n        port.model.name = name\n        port.model.display_name = display_name\n        port.model.multi_connection = multi_input\n        self._inputs.append(port)\n        self.model.inputs[port.name()] = port.model\n        return port\n\n    def add_output(self, name='output', multi_output=True, display_name=True):\n        \"\"\"\n        Add output port to node.\n\n        Args:\n            name (str): name for the output port. \n            multi_output (bool): allow port to have more than one connection.\n            display_name (bool): display the port name on the node.\n             \n        Returns:\n            NodeGraphQt.Port: the created port object.\n        \"\"\"\n        view = self.view.add_output(name, multi_output, display_name)\n        port = Port(self, view)\n        port.model.type = 'out'\n        port.model.name = name\n        port.model.display_name = display_name\n        port.model.multi_connection = multi_output\n        self._outputs.append(port)\n        self.model.outputs[port.name()] = port.model\n        return port\n\n    def add_combo_menu(self, name='', label='', items=None):\n        \"\"\"\n        Embed a NodeComboBox widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            items (list[str]): items to be added into the menu.\n        \"\"\"\n        items = items or []\n        self.create_property(name, items[0] if items else '')\n        widget = self.view.add_combo_menu(name, label, items)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))\n\n    def add_text_input(self, name='', label='', text=''):\n        \"\"\"\n        Embed a NodeLineEdit widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            text (str): pre filled text.\n        \"\"\"\n        self.create_property(name, text)\n        widget = self.view.add_text_input(name, label, text)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))\n\n    def add_checkbox(self, name='', label='', text='', state=False):\n        \"\"\"\n        Embed a NodeCheckBox widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            text (str): checkbox text.\n            state (bool): pre-check.\n        \"\"\"\n        self.create_property(name, state)\n        widget = self.view.add_checkbox(name, label, text, state)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))\n\n    def inputs(self):\n        \"\"\"\n        Returns all the input port for the node.\n        \n        Returns:\n            dict: {<port_name>: <port_object>}\n        \"\"\"\n        return {p.name(): p for p in self._inputs}\n\n    def outputs(self):\n        \"\"\"\n        Returns all the output port for the node.\n\n        Returns:\n            dict: {<port_name>: <port_object>}\n        \"\"\"\n        return {p.name(): p for p in self._outputs}\n\n    def input(self, index):\n        \"\"\"\n        Return the input port with the matching index.\n\n        Args:\n            index (int): index of the input port.\n\n        Returns:\n            NodeGraphQt.Port: port object.\n        \"\"\"\n        return self._inputs[index]\n\n    def set_input(self, index, port):\n        \"\"\"\n        Creates a connection pipe to the targeted output port.\n\n        Args:\n            index (int): index of the port.\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        src_port = self.input(index)\n        src_port.connect_to(port)\n\n    def output(self, index):\n        \"\"\"\n        Return the output port with the matching index.\n\n        Args:\n            index (int): index of the output port.\n\n        Returns:\n            NodeGraphQt.Port: port object.\n        \"\"\"\n        return self._outputs[index]\n\n    def set_output(self, index, port):\n        \"\"\"\n        Creates a connection pipe to the targeted input port.\n\n        Args:\n            index (int): index of the port.\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        src_port = self.output(index)\n        src_port.connect_to(port)",
  "class Backdrop(NodeObject):\n    \"\"\"\n    Base class of a Backdrop.\n    \"\"\"\n\n    NODE_NAME = 'Backdrop'\n\n    def __init__(self):\n        super(Backdrop, self).__init__(BackdropNodeItem())\n        # override base default color.\n        self.model.color = (5, 129, 138, 255)\n        self.create_property('bg_text', '')\n\n    def auto_size(self):\n        \"\"\"\n        Auto resize the backdrop node to fit around the intersecting nodes.\n        \"\"\"\n        self.view.auto_resize()\n\n    def nodes(self):\n        \"\"\"\n        Returns nodes wrapped within the backdrop node.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of node under the backdrop.\n        \"\"\"\n        node_ids = [n.id for n in self.view.get_nodes()]\n        return [self.graph.get_node_by_id(nid) for nid in node_ids]\n\n    def set_text(self, text=''):\n        \"\"\"\n        Sets the text to be displayed in the backdrop node.\n\n        Args:\n            text (str): text string.\n        \"\"\"\n        self.set_property('backdrop_text', text)\n\n    def text(self):\n        \"\"\"\n        Returns the text on the backdrop node.\n\n        Returns:\n            str: text string.\n        \"\"\"\n        return self.get_property('backdrop_text')\n\n    def set_size(self, size=None):\n        \"\"\"\n        Sets the backdrop size.\n\n        Args:\n            size (tuple): width, height size.\n        \"\"\"\n        if size:\n            if self.graph:\n                self.graph.begin_undo('backdrop size')\n                self.set_property('width', size[0])\n                self.set_property('height', size[1])\n                self.graph.end_undo()\n                return\n            self.view.width, self.view.height = size\n            self.model.width, self.model.height = size\n\n    def size(self):\n        \"\"\"\n        Returns the current size of the node.\n\n        Returns:\n            tuple: node width, height\n        \"\"\"\n        self.model.width = self.view.width\n        self.model.height = self.view.height\n        return self.model.width, self.model.height",
  "def __init__(self, f):\n        self.f = f",
  "def __get__(self, instance, owner):\n        return self.f(owner)",
  "def __init__(self, node=None):\n        assert node, 'node cannot be None.'\n        self._graph = None\n        self._model = NodeModel()\n        self._model.type = self.type\n        self._model.name = self.NODE_NAME\n        self._view = node\n        self._view.type = self.type\n        self._view.name = self.model.name\n        self._view.id = self._model.id",
  "def __repr__(self):\n        return '{}(\\'{}\\')'.format(self.type, self.NODE_NAME)",
  "def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self.id == other.id\n        return False",
  "def __ne__(self, other):\n        return not self.__eq__(other)",
  "def type(cls):\n        \"\"\"\n        node type identifier followed by the class name.\n        eg. com.chantasticvfx.FooNode\n\n        Returns:\n            str: node type.\n        \"\"\"\n        return cls.__identifier__ + '.' + cls.__name__",
  "def graph(self):\n        \"\"\"\n        The parent node graph.\n\n        Returns:\n            NodeGraphQt.NodeGraph: node graph.\n        \"\"\"\n        return self._graph",
  "def view(self):\n        \"\"\"\n        View item used in the scene.\n\n        Returns:\n            QtWidgets.QGraphicsItem: node item.\n        \"\"\"\n        return self._view",
  "def set_view(self, item):\n        \"\"\"\n        set the view item for the scene.\n\n        Args:\n            item (AbstractNodeItem): node view item.\n        \"\"\"\n        self._view = item\n        self._view.id = self.model.id\n        self.NODE_NAME = self._view.name",
  "def model(self):\n        \"\"\"\n        returns the node model.\n\n        Returns:\n            NodeModel: node model object.\n        \"\"\"\n        return self._model",
  "def set_model(self, model):\n        self._model = model\n        self._model.type = self.type\n        self._model.id = self.view.id",
  "def id(self):\n        \"\"\"\n        The node unique id.\n\n        Returns:\n            str: unique id string.\n        \"\"\"\n        return self.model.id",
  "def update_model(self):\n        \"\"\"\n        update the node model from view.\n        \"\"\"\n        for name, val in self.view.properties.items():\n            if name in self.model.properties.keys():\n                setattr(self.model, name, val)\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = val",
  "def update(self):\n        \"\"\"\n        Update the node view from model.\n        \"\"\"\n        settings = self.model.to_dict[self.model.id]\n        settings['id'] = self.model.id\n        if settings.get('custom'):\n            settings['widgets'] = settings.pop('custom')\n\n        self.view.from_dict(settings)",
  "def name(self):\n        \"\"\"\n        Name of the node.\n\n        Returns:\n            str: name of the node.\n        \"\"\"\n        return self.model.name",
  "def set_name(self, name=''):\n        \"\"\"\n        Set the name of the node.\n\n        Args:\n            name (str): name for the node.\n        \"\"\"\n        self.set_property('name', name)",
  "def color(self):\n        \"\"\"\n        Returns the node color in (red, green, blue) value.\n\n        Returns:\n            tuple: (r, g, b) from 0-255 range.\n        \"\"\"\n        r, g, b, a = self.model.color\n        return r, g, b",
  "def set_color(self, r=0, g=0, b=0):\n        \"\"\"\n        Sets the color of the node in (red, green, blue) value.\n\n        Args:\n            r (int): red value 0-255 range.\n            g (int): green value 0-255 range.\n            b (int): blue value 0-255 range.\n        \"\"\"\n        self.set_property('color', (r, g, b, 255))",
  "def disabled(self):\n        \"\"\"\n        returns weather the node is enabled or disabled.\n\n        Returns:\n            bool: true if the node is disabled.\n        \"\"\"\n        return self.model.disabled",
  "def set_disabled(self, mode=False):\n        \"\"\"\n        disables the node.\n\n        Args (bool): true to disable node.\n        \"\"\"\n        self.set_property('disabled', mode)",
  "def selected(self):\n        \"\"\"\n        Returns the selected state of the node.\n\n        Returns:\n            bool: True if the node is selected.\n        \"\"\"\n        self.model.selected = self.view.isSelected()\n        return self.model.selected",
  "def set_selected(self, selected=True):\n        \"\"\"\n        Set the node to be selected or not selected.\n\n        Args:\n            selected (bool): True to select the node.\n        \"\"\"\n        self.set_property('selected', selected)",
  "def create_property(self, name, value):\n        \"\"\"\n        adds new property to the node.\n\n        Args:\n            name (str): name of the attribute.\n            value (str, int, float): data\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError('name must of str type.')\n        if not isinstance(value, (str, int, float, bool)):\n            err = 'value must be of type (String, Integer, Float, Bool)'\n            raise TypeError(err)\n        elif name in self.view.properties.keys():\n            raise KeyError('\"{}\" property already exists.'.format(name))\n        elif name in self.model.properties.keys():\n            raise KeyError('\"{}\" property already exists.'.format(name))\n        self.model.custom_properties[name] = value",
  "def properties(self):\n        \"\"\"\n        Returns all the node properties.\n\n        Returns:\n            dict: a dictionary of node properties.\n        \"\"\"\n        return self.model.to_dict",
  "def get_property(self, name):\n        \"\"\"\n        Return the node custom property.\n\n        Args:\n            name (str): name of the property.\n\n        Returns:\n            str, int or float: value of the node property.\n        \"\"\"\n        if name in self.model.custom_properties.keys():\n            if name == 'selected':\n                self.model.custom_properties[name] = self.view.selected\n            return self.model.custom_properties[name]\n        return self.model.properties.get(name)",
  "def set_property(self, name, value):\n        \"\"\"\n        Set the value on the node custom property.\n\n        Args:\n            name (str): name of the property.\n            value: the new property value.\n        \"\"\"\n        if self.graph and name == 'name':\n            value = self.graph.get_unique_name(value)\n            self.NODE_NAME = value\n\n        exists = any([name in self.model.properties.keys(),\n                      name in self.model.custom_properties.keys()])\n        if not exists:\n            raise KeyError('No property \"{}\"'.format(name))\n\n        if self.graph:\n            undo_stack = self.graph.undo_stack()\n            undo_stack.push(PropertyChangedCmd(self, name, value))\n        else:\n            setattr(self.view, name, value)\n            if name in self.model.properties.keys():\n                setattr(self.model, name, value)\n            elif name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = value",
  "def has_property(self, name):\n        \"\"\"\n        Check if node custom property exists.\n\n        Args:\n            name (str): name of the node.\n\n        Returns:\n            bool: true if property name exists in the Node.\n        \"\"\"\n        return name in self.model.properties.keys()",
  "def set_x_pos(self, x=0.0):\n        \"\"\"\n        Set the node horizontal X position in the node graph.\n\n        Args:\n            x (float): node x position:\n        \"\"\"\n        y = self.pos()[1]\n        self.set_pos(x, y)",
  "def set_y_pos(self, y=0.0):\n        \"\"\"\n        Set the node horizontal Y position in the node graph.\n\n        Args:\n            y (float): node x position:\n        \"\"\"\n\n        x = self.pos()[0]\n        self.set_pos(x, y)",
  "def set_pos(self, x=0.0, y=0.0):\n        \"\"\"\n        Set the node X and Y position in the node graph.\n\n        Args:\n            x (float): node X position.\n            y (float): node Y position.\n        \"\"\"\n        self.set_property('pos', (x, y))",
  "def x_pos(self):\n        \"\"\"\n        Get the node X position in the node graph.\n\n        Returns:\n            float: x position.\n        \"\"\"\n        return self.model.pos[0]",
  "def y_pos(self):\n        \"\"\"\n        Get the node Y position in the node graph.\n\n        Returns:\n            float: y position.\n        \"\"\"\n        return self.model.pos[1]",
  "def pos(self):\n        \"\"\"\n        Get the node XY position in the node graph.\n\n        Returns:\n            tuple(float, float): x, y position.\n        \"\"\"\n        if self.view.pos and self.view.pos != self.model.pos:\n            self.model.pos = self.view.pos\n\n        return self.model.pos",
  "def __init__(self):\n        super(Node, self).__init__(NodeItem())\n        self._inputs = []\n        self._outputs = []",
  "def _on_widget_changed(self, name, value):\n        self.model.custom_properties[name] = value",
  "def update_model(self):\n        \"\"\"\n        update the node model from view.\n        \"\"\"\n        for name, val in self.view.properties.items():\n            if name in ['inputs', 'outputs']:\n                continue\n            if name in self.model.properties.keys():\n                setattr(self.model, name, val)\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = val\n        for name, widget in self.view.widgets.items():\n            if name in self.model.custom_properties.keys():\n                self.model.custom_properties[name] = widget.value",
  "def set_property(self, name, value, update_widget=True):\n        \"\"\"\n        Set the value on the node custom property and updates the node widget.\n\n        Args:\n            name (str): name of the property.\n            value: the new property value.\n            update_widget (bool): update the node widget (default=True).\n        \"\"\"\n        node_widget = self.view.widgets.get(name)\n        if node_widget and update_widget:\n            node_widget.value = value\n        super(Node, self).set_property(name, value)",
  "def set_icon(self, icon=None):\n        \"\"\"\n        Set the node icon.\n\n        Args:\n            icon (str): path to the icon image. \n        \"\"\"\n        self.set_property('icon', icon)",
  "def icon(self):\n        \"\"\"\n        Node icon path.\n\n        Returns:\n            str: icon image file path.\n        \"\"\"\n        return self.model.icon",
  "def add_input(self, name='input', multi_input=False, display_name=True):\n        \"\"\"\n        Add input port to node.\n\n        Args:\n            name (str): name for the input port. \n            multi_input (bool): allow port to have more than one connection.\n            display_name (bool): display the port name on the node.\n            \n        Returns:\n            NodeGraphQt.Port: the created port object.\n        \"\"\"\n        view = self.view.add_input(name, multi_input, display_name)\n        port = Port(self, view)\n        port.model.type = 'in'\n        port.model.name = name\n        port.model.display_name = display_name\n        port.model.multi_connection = multi_input\n        self._inputs.append(port)\n        self.model.inputs[port.name()] = port.model\n        return port",
  "def add_output(self, name='output', multi_output=True, display_name=True):\n        \"\"\"\n        Add output port to node.\n\n        Args:\n            name (str): name for the output port. \n            multi_output (bool): allow port to have more than one connection.\n            display_name (bool): display the port name on the node.\n             \n        Returns:\n            NodeGraphQt.Port: the created port object.\n        \"\"\"\n        view = self.view.add_output(name, multi_output, display_name)\n        port = Port(self, view)\n        port.model.type = 'out'\n        port.model.name = name\n        port.model.display_name = display_name\n        port.model.multi_connection = multi_output\n        self._outputs.append(port)\n        self.model.outputs[port.name()] = port.model\n        return port",
  "def add_combo_menu(self, name='', label='', items=None):\n        \"\"\"\n        Embed a NodeComboBox widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            items (list[str]): items to be added into the menu.\n        \"\"\"\n        items = items or []\n        self.create_property(name, items[0] if items else '')\n        widget = self.view.add_combo_menu(name, label, items)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))",
  "def add_text_input(self, name='', label='', text=''):\n        \"\"\"\n        Embed a NodeLineEdit widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            text (str): pre filled text.\n        \"\"\"\n        self.create_property(name, text)\n        widget = self.view.add_text_input(name, label, text)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))",
  "def add_checkbox(self, name='', label='', text='', state=False):\n        \"\"\"\n        Embed a NodeCheckBox widget into the node.\n\n        Args:\n            name (str): name for the custom property.\n            label (str): label to be displayed.\n            text (str): checkbox text.\n            state (bool): pre-check.\n        \"\"\"\n        self.create_property(name, state)\n        widget = self.view.add_checkbox(name, label, text, state)\n        widget.value_changed.connect(lambda k, v: self._on_widget_changed(k, v))",
  "def inputs(self):\n        \"\"\"\n        Returns all the input port for the node.\n        \n        Returns:\n            dict: {<port_name>: <port_object>}\n        \"\"\"\n        return {p.name(): p for p in self._inputs}",
  "def outputs(self):\n        \"\"\"\n        Returns all the output port for the node.\n\n        Returns:\n            dict: {<port_name>: <port_object>}\n        \"\"\"\n        return {p.name(): p for p in self._outputs}",
  "def input(self, index):\n        \"\"\"\n        Return the input port with the matching index.\n\n        Args:\n            index (int): index of the input port.\n\n        Returns:\n            NodeGraphQt.Port: port object.\n        \"\"\"\n        return self._inputs[index]",
  "def set_input(self, index, port):\n        \"\"\"\n        Creates a connection pipe to the targeted output port.\n\n        Args:\n            index (int): index of the port.\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        src_port = self.input(index)\n        src_port.connect_to(port)",
  "def output(self, index):\n        \"\"\"\n        Return the output port with the matching index.\n\n        Args:\n            index (int): index of the output port.\n\n        Returns:\n            NodeGraphQt.Port: port object.\n        \"\"\"\n        return self._outputs[index]",
  "def set_output(self, index, port):\n        \"\"\"\n        Creates a connection pipe to the targeted input port.\n\n        Args:\n            index (int): index of the port.\n            port (NodeGraphQt.Port): port object.\n        \"\"\"\n        src_port = self.output(index)\n        src_port.connect_to(port)",
  "def __init__(self):\n        super(Backdrop, self).__init__(BackdropNodeItem())\n        # override base default color.\n        self.model.color = (5, 129, 138, 255)\n        self.create_property('bg_text', '')",
  "def auto_size(self):\n        \"\"\"\n        Auto resize the backdrop node to fit around the intersecting nodes.\n        \"\"\"\n        self.view.auto_resize()",
  "def nodes(self):\n        \"\"\"\n        Returns nodes wrapped within the backdrop node.\n\n        Returns:\n            list[NodeGraphQt.Node]: list of node under the backdrop.\n        \"\"\"\n        node_ids = [n.id for n in self.view.get_nodes()]\n        return [self.graph.get_node_by_id(nid) for nid in node_ids]",
  "def set_text(self, text=''):\n        \"\"\"\n        Sets the text to be displayed in the backdrop node.\n\n        Args:\n            text (str): text string.\n        \"\"\"\n        self.set_property('backdrop_text', text)",
  "def text(self):\n        \"\"\"\n        Returns the text on the backdrop node.\n\n        Returns:\n            str: text string.\n        \"\"\"\n        return self.get_property('backdrop_text')",
  "def set_size(self, size=None):\n        \"\"\"\n        Sets the backdrop size.\n\n        Args:\n            size (tuple): width, height size.\n        \"\"\"\n        if size:\n            if self.graph:\n                self.graph.begin_undo('backdrop size')\n                self.set_property('width', size[0])\n                self.set_property('height', size[1])\n                self.graph.end_undo()\n                return\n            self.view.width, self.view.height = size\n            self.model.width, self.model.height = size",
  "def size(self):\n        \"\"\"\n        Returns the current size of the node.\n\n        Returns:\n            tuple: node width, height\n        \"\"\"\n        self.model.width = self.view.width\n        self.model.height = self.view.height\n        return self.model.width, self.model.height"
]