[
  "def set_builtin(name, value):\n    if isinstance(__builtins__, dict):\n        __builtins__[name] = value\n    else:\n        setattr(__builtins__, name, value)",
  "def _custom_edit_url(github_user, github_repo, github_version, doc_path, file_name, default_edit_page_url_template):\n    \"\"\"Create custom 'edit' URLs for API modules since they are dynamically generated.\"\"\"\n    if file_name.startswith(\"api/\"):\n        # this is a dynamically generated API page, link to actual Python source\n        modpath = os.sep.join(os.path.splitext(file_name[4:])[0].split(\".\"))\n        if modpath == \"modules\":\n            # main package listing\n            modpath = \"vispy\"\n        rel_modpath = os.path.join(\"..\", modpath)\n        if os.path.isdir(rel_modpath):\n            doc_path = modpath + \"/\"\n            file_name = \"__init__.py\"\n        elif os.path.isfile(rel_modpath + \".py\"):\n            doc_path = os.path.dirname(modpath)\n            file_name = os.path.basename(modpath) + \".py\"\n        else:\n            warnings.warn(f\"Not sure how to generate the API URL for: {file_name}\")\n    return default_edit_page_url_template.format(github_user=github_user,\n                                                 github_repo=github_repo,\n                                                 github_version=github_version,\n                                                 doc_path=doc_path,\n                                                 file_name=file_name)",
  "def setup(app):\n    # Add custom CSS\n    app.add_css_file('style.css')",
  "class Maker:\n    \"\"\"Collection of make commands.\n\n    To create a new command, create a method with a short name, give it\n    a docstring, and make it do something useful :)\n\n    \"\"\"\n\n    def __init__(self, argv):\n        \"\"\" Parse command line arguments. \"\"\"\n        # Get function to call\n        if len(argv) == 1:\n            func, arg = self.help, ''\n        else:\n            command = argv[1].strip()\n            arg = ' '.join(argv[2:]).strip()\n            func = getattr(self, command, None)\n        # Call it if we can\n        if func is not None:\n            func(arg)\n        else:\n            sys.exit('Invalid command: \"%s\"' % command)\n\n    def coverage_html(self, arg):\n        \"\"\"Generate html report from .coverage and launch\"\"\"\n        print('Generating HTML...')\n        from coverage import coverage\n        cov = coverage(auto_data=False, branch=True, data_suffix=None,\n                       source=['vispy'])  # should match testing/_coverage.py\n        cov.combine()\n        cov.load()\n        cov.html_report()\n        print('Done, launching browser.')\n        fname = op.join(os.getcwd(), 'htmlcov', 'index.html')\n        if not op.isfile(fname):\n            raise IOError('Generated file not found: %s' % fname)\n        webbrowser.open_new_tab(fname)\n\n    def help(self, arg):\n        \"\"\" Show help message. Use 'help X' to get more help on command X. \"\"\"\n        if arg:\n            command = arg\n            func = getattr(self, command, None)\n            if func is not None:\n                doc = getattr(self, command).__doc__.strip()\n                print('make.py %s [arg]\\n\\n        %s' % (command, doc))\n                print()\n            else:\n                sys.exit('Cannot show help on unknown command: \"%s\"' % command)\n\n        else:\n            print(__doc__.strip() + '\\n\\nCommands:\\n')\n            for command in sorted(dir(self)):\n                if command.startswith('_'):\n                    continue\n                preamble = command.ljust(11)  # longest command is 9 or 10\n                # doc = getattr(self, command).__doc__.splitlines()[0].strip()\n                doc = getattr(self, command).__doc__.strip()\n                print(' %s  %s' % (preamble, doc))\n            print()\n\n    def test(self, arg):\n        \"\"\" Run tests:\n                * full - run all tests\n                * unit - run tests (also for each backend)\n                * any backend name (e.g. pyside2, pyside, pyqt4, etc.) -\n                  run tests for the given backend\n                * nobackend - run tests that do not require a backend\n                * extra - run extra tests (line endings and style)\n                * lineendings - test line ending consistency\n                * flake - flake style testing (PEP8 and more)\n                * docs - test docstring parameters for correctness\n                * examples - run all examples\n                * examples [examples paths] - run given examples\n        \"\"\"\n        # Note: By default, \"python make full\" *will* produce coverage data,\n        # whereas vispy.test('full') will not. This is because users won't\n        # really care about coveraged, but developers will.\n        if not arg:\n            return self.help('test')\n        from vispy import test\n        try:\n            args = arg.split(' ')\n            test(args[0], ' '.join(args[1:]), coverage=True)\n        except Exception as err:\n            print(err)\n            if not isinstance(err, RuntimeError):\n                type_, value, tb = sys.exc_info()\n                traceback.print_exception(type, value, tb)\n            raise SystemExit(1)",
  "def __init__(self, argv):\n        \"\"\" Parse command line arguments. \"\"\"\n        # Get function to call\n        if len(argv) == 1:\n            func, arg = self.help, ''\n        else:\n            command = argv[1].strip()\n            arg = ' '.join(argv[2:]).strip()\n            func = getattr(self, command, None)\n        # Call it if we can\n        if func is not None:\n            func(arg)\n        else:\n            sys.exit('Invalid command: \"%s\"' % command)",
  "def coverage_html(self, arg):\n        \"\"\"Generate html report from .coverage and launch\"\"\"\n        print('Generating HTML...')\n        from coverage import coverage\n        cov = coverage(auto_data=False, branch=True, data_suffix=None,\n                       source=['vispy'])  # should match testing/_coverage.py\n        cov.combine()\n        cov.load()\n        cov.html_report()\n        print('Done, launching browser.')\n        fname = op.join(os.getcwd(), 'htmlcov', 'index.html')\n        if not op.isfile(fname):\n            raise IOError('Generated file not found: %s' % fname)\n        webbrowser.open_new_tab(fname)",
  "def help(self, arg):\n        \"\"\" Show help message. Use 'help X' to get more help on command X. \"\"\"\n        if arg:\n            command = arg\n            func = getattr(self, command, None)\n            if func is not None:\n                doc = getattr(self, command).__doc__.strip()\n                print('make.py %s [arg]\\n\\n        %s' % (command, doc))\n                print()\n            else:\n                sys.exit('Cannot show help on unknown command: \"%s\"' % command)\n\n        else:\n            print(__doc__.strip() + '\\n\\nCommands:\\n')\n            for command in sorted(dir(self)):\n                if command.startswith('_'):\n                    continue\n                preamble = command.ljust(11)  # longest command is 9 or 10\n                # doc = getattr(self, command).__doc__.splitlines()[0].strip()\n                doc = getattr(self, command).__doc__.strip()\n                print(' %s  %s' % (preamble, doc))\n            print()",
  "def test(self, arg):\n        \"\"\" Run tests:\n                * full - run all tests\n                * unit - run tests (also for each backend)\n                * any backend name (e.g. pyside2, pyside, pyqt4, etc.) -\n                  run tests for the given backend\n                * nobackend - run tests that do not require a backend\n                * extra - run extra tests (line endings and style)\n                * lineendings - test line ending consistency\n                * flake - flake style testing (PEP8 and more)\n                * docs - test docstring parameters for correctness\n                * examples - run all examples\n                * examples [examples paths] - run given examples\n        \"\"\"\n        # Note: By default, \"python make full\" *will* produce coverage data,\n        # whereas vispy.test('full') will not. This is because users won't\n        # really care about coveraged, but developers will.\n        if not arg:\n            return self.help('test')\n        from vispy import test\n        try:\n            args = arg.split(' ')\n            test(args[0], ' '.join(args[1:]), coverage=True)\n        except Exception as err:\n            print(err)\n            if not isinstance(err, RuntimeError):\n                type_, value, tb = sys.exc_info()\n                traceback.print_exception(type, value, tb)\n            raise SystemExit(1)",
  "def pytest_configure(config):\n    config.addinivalue_line(\n        'markers',\n        'vispy_app_test: Tests that require a valid GUI application.')\n    warning_lines = \"\"\"\n    ignore:.*imp module.*:\n    ignore:Using or importing the ABCs.*:\n    \"\"\"  # noqa: E501\n    for warning_line in warning_lines.split('\\n'):\n        warning_line = warning_line.strip()\n        if warning_line and not warning_line.startswith('#'):\n            config.addinivalue_line('filterwarnings', warning_line)",
  "def _get_sg_image_scraper():\n    from .util.gallery_scraper import VisPyGalleryScraper\n    return VisPyGalleryScraper()",
  "class SpatialFilter:\n    def __init__(self, radius=1):\n        self.radius = math.ceil(radius)\n\n    def weight(self, x):\n        \"\"\"\n        Return filter weight for a distance x.\n\n        :Parameters:\n            ``x`` : 0 < float < ceil(self.radius)\n                Distance to be used to compute weight.\n        \"\"\"\n        raise NotImplementedError\n\n    def kernel(self, size=4 * 512):\n        samples = int(size / self.radius)\n        n = size  # r*samples\n        kernel = np.zeros(n)\n        X = np.linspace(0, self.radius, n)\n        for i in range(n):\n            kernel[i] = self.weight(X[i])\n        N = np.zeros(samples)\n        for i in range(self.radius):\n            N += kernel[::+1][i * samples:(i + 1) * samples]\n            N += kernel[::-1][i * samples:(i + 1) * samples]\n        for i in range(self.radius):\n            kernel[i * samples:(i + 1) * samples] /= N\n        return kernel\n\n    def call_code(self, index):\n        code = cleandoc(f'''\n            vec4 {self.__class__.__name__}2D(sampler2D texture, vec2 shape, vec2 uv) {{\n                return filter2D_radius{self.radius}(texture, u_kernel, {index}, uv, 1 / shape);\n            }}\n\n            vec4 {self.__class__.__name__}3D(sampler3D texture, vec3 shape, vec3 uv) {{\n                return filter3D_radius{self.radius}(texture, u_kernel, {index}, uv, 1 / shape);\n            }}\n        ''')\n\n        return code",
  "class Linear(SpatialFilter):\n    \"\"\"\n    Linear filter (radius = 1).\n\n    Weight function::\n\n      w(x) = 1 - x\n\n    \"\"\"\n\n    def weight(self, x):\n        return 1 - x",
  "class Hanning(SpatialFilter):\n    \"\"\"\n    Hanning filter (radius = 1).\n\n    Weight function::\n\n      w(x) = 0.5 + 0.5 * cos(pi * x)\n\n    \"\"\"\n\n    def weight(self, x):\n        return 0.5 + 0.5 * math.cos(math.pi * x)",
  "class Hamming(SpatialFilter):\n    \"\"\"\n    Hamming filter (radius = 1).\n\n    Weight function::\n\n      w(x) = 0.54 + 0.46 * cos(pi * x)\n\n    \"\"\"\n\n    def weight(self, x):\n        return 0.54 + 0.46 * math.cos(math.pi * x)",
  "class Hermite(SpatialFilter):\n    \"\"\"Hermite filter (radius = 1).\n\n    Weight function::\n\n      w(x) = (2*x-3)*x^2 + 1\n\n    \"\"\"\n\n    def weight(self, x):\n        return (2 * x - 3) * x**2 + 1",
  "class Quadric(SpatialFilter):\n    \"\"\"\n    Quadric filter (radius = 1.5).\n\n    Weight function::\n\n             |  0 \u2264 x < 0.5: 0.75 - x*x\n      w(x) = |  0.5 \u2264 x < 1.5: 0.5 - (x-1.5)^2\n             |  1.5 \u2264 x      : 0\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=1.5)\n\n    def weight(self, x):\n        if x < 0.75:\n            return 0.75 - x**2\n        elif x < 1.5:\n            t = x - 1.5\n            return 0.5 * t**2\n        return 0",
  "class Cubic(SpatialFilter):\n    \"\"\"\n    Cubic filter (radius = 2).\n\n    Weight function::\n\n      w(x) = 1/6((x+2)^3 - 4*(x+1)^3 + 6*x^3 -4*(x-1)^3)\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=2)\n\n    def weight(self, x):\n        return (1 / 6) * (\n            (x + 2)**3\n            - 4 * (x + 1)**3\n            + 6 * x**3\n            - 4 * (x - 1)**3\n        )",
  "class Kaiser(SpatialFilter):\n    \"\"\"\n    Kaiser filter (radius = 1).\n\n\n    Weight function::\n\n      w(x) = bessel_i0(a sqrt(1-x^2)* 1/bessel_i0(b)\n\n    \"\"\"\n\n    def __init__(self, b=6.33):\n        self.a = b\n        self.epsilon = 1e-12\n        self.i0a = 1 / self.bessel_i0(b)\n        super().__init__(radius=1)\n\n    def bessel_i0(self, x):\n        s = 1\n        y = x**2 / 4\n        t = y\n        i = 2\n        while t > self.epsilon:\n            s += t\n            t *= float(y) / i**2\n            i += 1\n        return s\n\n    def weight(self, x):\n        if x > 1:\n            return 0\n        return self.bessel_i0(self.a * math.sqrt(1 - x**2)) * self.i0a",
  "class CatRom(SpatialFilter):\n    \"\"\"\n    Catmull-Rom filter (radius = 2).\n\n    Weight function::\n\n             |  0 \u2264 x < 1: 0.5*(2 + x^2*(-5+x*3))\n      w(x) = |  1 \u2264 x < 2: 0.5*(4 + x*(-8+x*(5-x)))\n             |  2 \u2264 x    : 0\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=2)\n\n    def weight(self, x):\n        if x < 1:\n            return 0.5 * (2 + x**2 * (-5 + x * 3))\n        elif x < 2:\n            return 0.5 * (4 + x * (-8 + x * (5 - x)))\n        else:\n            return 0",
  "class Mitchell(SpatialFilter):\n    \"\"\"\n    Mitchell-Netravali filter (radius = 2).\n\n    Weight function::\n\n             |  0 \u2264 x < 1: p0 + x^2*(p2 + x*p3)\n      w(x) = |  1 \u2264 x < 2: q0 + x*(q1 + x*(q2 + x*q3))\n             |  2 \u2264 x    : 0\n\n    \"\"\"\n\n    def __init__(self, b=1/3, c=1/3):\n        self.p0 = (6 - 2 * b) / 6\n        self.p2 = (-18 + 12 * b + 6 * c) / 6\n        self.p3 = (12 - 9 * b - 6 * c) / 6\n        self.q0 = (8 * b + 24 * c) / 6\n        self.q1 = (-12 * b - 48 * c) / 6\n        self.q2 = (6 * b + 30 * c) / 6\n        self.q3 = (-b - 6 * c) / 6\n        super().__init__(radius=2)\n\n    def weight(self, x):\n        if x < 1:\n            return self.p0 + x**2 * (self.p2 + x * self.p3)\n        elif x < 2:\n            return self.q0 + x * (self.q1 + x * (self.q2 + x * self.q3))\n        else:\n            return 0",
  "class Spline16(SpatialFilter):\n    \"\"\"\n    Spline16 filter (radius = 2).\n\n    Weight function::\n\n             |  0 \u2264 x < 1: ((x-9/5)*x - 1/5)*x + 1\n      w(x) = |\n             |  1 \u2264 x < 2: ((-1/3*(x-1) + 4/5)*(x-1) - 7/15 )*(x-1)\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=2)\n\n    def weight(self, x):\n        if x < 1:\n            return ((x - 9/5) * x - 1/5) * x + 1\n        else:\n            return ((-1/3 * (x - 1) + 4/5) * (x - 1) - 7/15) * (x - 1)",
  "class Spline36(SpatialFilter):\n    \"\"\"\n    Spline36 filter (radius = 3).\n\n    Weight function::\n\n             |  0 \u2264 x < 1: ((13/11*x - 453/209)*x -3/209)*x +1\n      w(x) = |  1 \u2264 x < 2: ((-6/11*(x-1) - 270/209)*(x-1) -156/209)*(x-1)\n             |  2 \u2264 x < 3: (( 1/11*(x-2) - 45/209)*(x-2) + 26/209)*(x-2)\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=3)\n\n    def weight(self, x):\n        if x < 1:\n            return ((13/11 * x - 453/209) * x - 3/209) * x + 1\n        elif x < 2:\n            return ((-6/11 * (x - 1) + 270/209) * (x - 1) - 156 / 209) * (x - 1)\n        else:\n            return ((1/11 * (x - 2) - 45/209) * (x - 2) + 26/209) * (x - 2)",
  "class Gaussian(SpatialFilter):\n    \"\"\"\n    Gaussian filter (radius = 2).\n\n    Weight function::\n\n      w(x) = exp(-2x^2) * sqrt(2/pi)\n\n    Note::\n\n      This filter does not seem to be correct since:\n\n        x = np.linspace(0, 1, 100 )\n        f = weight\n        z = f(x+1)+f(x)+f(1-x)+f(2-x)\n\n        z should be 1 everywhere but it is not the case and it produces \"grid\n        effects\".\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(radius=2)\n\n    def weight(self, x):\n        return math.exp(-2 * x**2) * math.sqrt(2 / math.pi)",
  "class Bessel(SpatialFilter):\n    \"\"\"Bessel filter (radius = 3.2383).\"\"\"\n\n    def __init__(self):\n        super().__init__(radius=3.2383)\n\n    def besj(self, x, n):\n        \"\"\"Function BESJ calculates Bessel function of first kind of order n.\n\n        Parameters\n        ----------\n        x: int\n            value at which the Bessel function is required\n        n : int\n            an integer (>=0), the order\n\n        Notes\n        -----\n        C++ Mathematical Library\n        Converted from equivalent FORTRAN library\n        Converted by Gareth Walker for use by course 392 computational project\n        All functions tested and yield the same results as the corresponding\n        FORTRAN versions.\n\n        If you have any problems using these functions please report them to\n        M.Muldoon@UMIST.ac.uk\n\n        Documentation available on the web\n        http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html\n        Version 1.0   8/98\n        29 October, 1999\n\n        Adapted for use in AGG library by\n                    Andy Wilk (castor.vulgaris@gmail.com)\n        Adapted for use in vispy library by\n                    Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n\n        \"\"\"\n        if n < 0:\n            return 0\n        x = float(x)  # force float type\n\n        d = 1e-6\n        b = 0\n        if math.fabs(x) <= d:\n            if n != 0:\n                return 0\n            return 1\n\n        b1 = 0  # b1 is the value from the previous iteration\n        # Set up a starting order for recurrence\n        m1 = int(math.fabs(x)) + 6\n        if math.fabs(x) > 5:\n            m1 = int(math.fabs(1.4 * x + 60 / x))\n\n        m2 = int(n + 2 + math.fabs(x) / 4)\n        if m1 > m2:\n            m2 = m1\n\n        # Apply recurrence down from current max order\n        while True:\n            c3 = 0\n            c2 = 1e-30\n            c4 = 0\n            m8 = 1\n            if m2 // 2 * 2 == m2:\n                m8 = -1\n\n            imax = m2 - 2\n            for i in range(1, imax + 1):\n                c6 = 2 * (m2 - i) * c2 / x - c3\n                c3 = c2\n                c2 = c6\n                if m2 - i - 1 == n:\n                    b = c6\n                m8 = -1 * m8\n                if m8 > 0:\n                    c4 = c4 + 2 * c6\n\n            c6 = 2 * c2 / x - c3\n            if n == 0:\n                b = c6\n            c4 += c6\n            b /= c4\n            if math.fabs(b - b1) < d:\n                return b\n            b1 = b\n            m2 += 3\n\n    def weight(self, x):\n        if x == 0:\n            return math.pi / 4\n        else:\n            return self.besj(math.pi * x, 1) / (2 * x)",
  "class Sinc(SpatialFilter):\n    \"\"\"Sinc filter (radius = 4).\"\"\"\n\n    def __init__(self):\n        super().__init__(radius=4)\n\n    def weight(self, x):\n        if x == 0:\n            return 1\n        x *= math.pi\n        return (math.sin(x) / x)",
  "class Lanczos(SpatialFilter):\n    \"\"\"Lanczos filter (radius = 4).\"\"\"\n\n    def __init__(self):\n        super().__init__(radius=4)\n\n    def weight(self, x):\n        if x == 0:\n            return 1\n        elif x > self.radius:\n            return 0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (math.sin(xr) / xr)",
  "class Blackman(SpatialFilter):\n    \"\"\"Blackman filter (radius = 4).\"\"\"\n\n    def __init__(self):\n        super().__init__(radius=4)\n\n    def weight(self, x):\n        if x == 0:\n            return 1\n        elif x > self.radius:\n            return 0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (0.42 + 0.5 * math.cos(xr) + 0.08 * math.cos(2 * xr))",
  "def generate_filter_code(radius):\n    n = int(math.ceil(radius))\n\n    nl = '\\n'  # cannot use backslash in fstring\n    code = cleandoc(f'''\n    vec4 filter1D_radius{n}(sampler2D kernel, float index, float x{''.join(f', vec4 c{i}' for i in range(n * 2))}) {{\n        float w, w_sum = 0;\n        vec4 r = vec4(0);\n        {''.join(f\"\"\"\n        w = unpack_interpolate(kernel, vec2({1 - (i + 1) / n} + (x / {n}), index));\n        w = w * kernel_scale + kernel_bias;\n        r += c{i} * w;\n        w = unpack_interpolate(kernel, vec2({(i + 1) / n} - (x / {n}), index));\n        w = w * kernel_scale + kernel_bias;\n        r += c{i + n} * w;\"\"\"\n        for i in range(n))}\n        return r;\n    }}\n\n    vec4 filter2D_radius{n}(sampler2D texture, sampler2D kernel, float index, vec2 uv, vec2 pixel) {{\n        vec2 texel = uv / pixel - vec2(0.5);\n        vec2 f = fract(texel);\n        texel = (texel - fract(texel) + vec2(0.001)) * pixel;\n        {''.join(f\"\"\"\n        vec4 t{i} = filter1D_radius{n}(kernel, index, f.x{f''.join(\n            f',{nl}            texture2D(texture, texel + vec2({-n + 1 + j}, {-n + 1 + i}) * pixel)'\n            for j in range(n * 2))});\"\"\"\n        for i in range(n * 2))}\n        return filter1D_radius{n}(kernel, index, f.y{''.join(f', t{i}' for i in range(2*n))});\n    }}\n\n    vec4 filter3D_radius{n}(sampler3D texture, sampler2D kernel, float index, vec3 uv, vec3 pixel) {{\n        vec3 texel = uv / pixel - vec3(0.5);\n        vec3 f = fract(texel);\n        texel = (texel - fract(texel) + vec3(0.001)) * pixel;\n        {''.join(f\"\"\"\n        vec4 t{i}{j} = filter1D_radius{n}(kernel, index, f.x{f''.join(\n            f',{nl}            texture3D(texture, texel + vec3({-n + 1 + k}, {-n + 1 + j}, {-n + 1 + i}) * pixel)'\n            for k in range(n * 2))});\"\"\"\n        for i, j in product(range(n * 2), range(n * 2)))}\n        {f''.join(f\"\"\"\n        vec4 t{i} = filter1D_radius{n}(kernel, index, f.y{\"\".join(\n            f\", t{i}{j}\" for j in range(n * 2))});\"\"\"\n        for i in range(n * 2))}\n        return filter1D_radius{n}(kernel, index, f.z{''.join(f', t{i}' for i in range(2*n))});\n    }}\n    ''')\n\n    return code",
  "def main():\n    # Generate kernels texture (16 x 1024)\n    filters = [Linear(), Hanning(), Hamming(), Hermite(), Kaiser(), Quadric(),\n               Cubic(), CatRom(), Mitchell(), Spline16(), Spline36(), Gaussian(),\n               Bessel(), Sinc(), Lanczos(), Blackman()]\n\n    n = 1024\n    K = np.zeros((len(filters), n))\n    for i, f in enumerate(filters):\n        K[i] = f.kernel(n)\n\n    bias = K.min()\n    scale = K.max() - K.min()\n    K = (K - bias) / scale\n    np.save(\"spatial-filters.npy\", K.astype(np.float32))\n\n    code = cleandoc(f'''\n        // ------------------------------------\n        // Automatically generated, do not edit\n        // ------------------------------------\n        const float kernel_bias  = {bias};\n        const float kernel_scale = {scale};\n        const float kernel_size = {n};\n        const vec4 bits = vec4(1, {1 / 256}, {1 / (256 * 256)}, {1 / (256 * 256 * 256)});\n        uniform sampler2D u_kernel;\n    ''')\n\n    # add basic unpack functions\n    code += '\\n\\n' + cleandoc('''\n        float unpack_unit(vec4 rgba) {\n            // return rgba.r;  // uncomment this for r32f debugging\n            return dot(rgba, bits);\n        }\n\n        float unpack_ieee(vec4 rgba) {\n            // return rgba.r;  // uncomment this for r32f debugging\n            rgba.rgba = rgba.abgr * 255;\n            float sign = 1 - step(128 , rgba[0]) * 2;\n            float exponent = 2 * mod(rgba[0] , 128) + step(128 , rgba[1]) - 127;\n            float mantissa = mod(rgba[1] , 128) * 65536 + rgba[2] * 256 + rgba[3] + float(0x800000);\n            return sign * exp2(exponent) * (mantissa * exp2(-23.));\n        }\n\n\n        float unpack_interpolate(sampler2D kernel, vec2 uv) {\n            // return texture2D(kernel, uv).r;  //uncomment this for r32f debug without interpolation\n            float kpixel = 1. / kernel_size;\n            float u = uv.x / kpixel;\n            float v = uv.y;\n            float uf = fract(u);\n            u = (u - uf) * kpixel;\n            float d0 = unpack_unit(texture2D(kernel, vec2(u, v)));\n            float d1 = unpack_unit(texture2D(kernel, vec2(u + 1. * kpixel, v)));\n            return mix(d0, d1, uf);\n        }\n    ''')\n\n    # add 1d, 2d and 3d filter code\n    for radius in range(4):\n        code += '\\n\\n' + generate_filter_code(radius + 1)\n\n    # add call functions for 2D and 3D filters\n    # special case for nearest\n    code += '\\n\\n' + cleandoc('''\n        vec4 Nearest2D(sampler2D texture, vec2 shape, vec2 uv) {\n            return texture2D(texture, uv);\n        }\n\n        vec4 Nearest3D(sampler3D texture, vec3 shape, vec3 uv) {\n            return texture3D(texture, uv);\n        }\n    ''')\n\n    for i, f in enumerate(filters):\n        code += '\\n\\n' + f.call_code((i + 0.5) / 16)\n\n    print(code)",
  "def __init__(self, radius=1):\n        self.radius = math.ceil(radius)",
  "def weight(self, x):\n        \"\"\"\n        Return filter weight for a distance x.\n\n        :Parameters:\n            ``x`` : 0 < float < ceil(self.radius)\n                Distance to be used to compute weight.\n        \"\"\"\n        raise NotImplementedError",
  "def kernel(self, size=4 * 512):\n        samples = int(size / self.radius)\n        n = size  # r*samples\n        kernel = np.zeros(n)\n        X = np.linspace(0, self.radius, n)\n        for i in range(n):\n            kernel[i] = self.weight(X[i])\n        N = np.zeros(samples)\n        for i in range(self.radius):\n            N += kernel[::+1][i * samples:(i + 1) * samples]\n            N += kernel[::-1][i * samples:(i + 1) * samples]\n        for i in range(self.radius):\n            kernel[i * samples:(i + 1) * samples] /= N\n        return kernel",
  "def call_code(self, index):\n        code = cleandoc(f'''\n            vec4 {self.__class__.__name__}2D(sampler2D texture, vec2 shape, vec2 uv) {{\n                return filter2D_radius{self.radius}(texture, u_kernel, {index}, uv, 1 / shape);\n            }}\n\n            vec4 {self.__class__.__name__}3D(sampler3D texture, vec3 shape, vec3 uv) {{\n                return filter3D_radius{self.radius}(texture, u_kernel, {index}, uv, 1 / shape);\n            }}\n        ''')\n\n        return code",
  "def weight(self, x):\n        return 1 - x",
  "def weight(self, x):\n        return 0.5 + 0.5 * math.cos(math.pi * x)",
  "def weight(self, x):\n        return 0.54 + 0.46 * math.cos(math.pi * x)",
  "def weight(self, x):\n        return (2 * x - 3) * x**2 + 1",
  "def __init__(self):\n        super().__init__(radius=1.5)",
  "def weight(self, x):\n        if x < 0.75:\n            return 0.75 - x**2\n        elif x < 1.5:\n            t = x - 1.5\n            return 0.5 * t**2\n        return 0",
  "def __init__(self):\n        super().__init__(radius=2)",
  "def weight(self, x):\n        return (1 / 6) * (\n            (x + 2)**3\n            - 4 * (x + 1)**3\n            + 6 * x**3\n            - 4 * (x - 1)**3\n        )",
  "def __init__(self, b=6.33):\n        self.a = b\n        self.epsilon = 1e-12\n        self.i0a = 1 / self.bessel_i0(b)\n        super().__init__(radius=1)",
  "def bessel_i0(self, x):\n        s = 1\n        y = x**2 / 4\n        t = y\n        i = 2\n        while t > self.epsilon:\n            s += t\n            t *= float(y) / i**2\n            i += 1\n        return s",
  "def weight(self, x):\n        if x > 1:\n            return 0\n        return self.bessel_i0(self.a * math.sqrt(1 - x**2)) * self.i0a",
  "def __init__(self):\n        super().__init__(radius=2)",
  "def weight(self, x):\n        if x < 1:\n            return 0.5 * (2 + x**2 * (-5 + x * 3))\n        elif x < 2:\n            return 0.5 * (4 + x * (-8 + x * (5 - x)))\n        else:\n            return 0",
  "def __init__(self, b=1/3, c=1/3):\n        self.p0 = (6 - 2 * b) / 6\n        self.p2 = (-18 + 12 * b + 6 * c) / 6\n        self.p3 = (12 - 9 * b - 6 * c) / 6\n        self.q0 = (8 * b + 24 * c) / 6\n        self.q1 = (-12 * b - 48 * c) / 6\n        self.q2 = (6 * b + 30 * c) / 6\n        self.q3 = (-b - 6 * c) / 6\n        super().__init__(radius=2)",
  "def weight(self, x):\n        if x < 1:\n            return self.p0 + x**2 * (self.p2 + x * self.p3)\n        elif x < 2:\n            return self.q0 + x * (self.q1 + x * (self.q2 + x * self.q3))\n        else:\n            return 0",
  "def __init__(self):\n        super().__init__(radius=2)",
  "def weight(self, x):\n        if x < 1:\n            return ((x - 9/5) * x - 1/5) * x + 1\n        else:\n            return ((-1/3 * (x - 1) + 4/5) * (x - 1) - 7/15) * (x - 1)",
  "def __init__(self):\n        super().__init__(radius=3)",
  "def weight(self, x):\n        if x < 1:\n            return ((13/11 * x - 453/209) * x - 3/209) * x + 1\n        elif x < 2:\n            return ((-6/11 * (x - 1) + 270/209) * (x - 1) - 156 / 209) * (x - 1)\n        else:\n            return ((1/11 * (x - 2) - 45/209) * (x - 2) + 26/209) * (x - 2)",
  "def __init__(self):\n        super().__init__(radius=2)",
  "def weight(self, x):\n        return math.exp(-2 * x**2) * math.sqrt(2 / math.pi)",
  "def __init__(self):\n        super().__init__(radius=3.2383)",
  "def besj(self, x, n):\n        \"\"\"Function BESJ calculates Bessel function of first kind of order n.\n\n        Parameters\n        ----------\n        x: int\n            value at which the Bessel function is required\n        n : int\n            an integer (>=0), the order\n\n        Notes\n        -----\n        C++ Mathematical Library\n        Converted from equivalent FORTRAN library\n        Converted by Gareth Walker for use by course 392 computational project\n        All functions tested and yield the same results as the corresponding\n        FORTRAN versions.\n\n        If you have any problems using these functions please report them to\n        M.Muldoon@UMIST.ac.uk\n\n        Documentation available on the web\n        http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html\n        Version 1.0   8/98\n        29 October, 1999\n\n        Adapted for use in AGG library by\n                    Andy Wilk (castor.vulgaris@gmail.com)\n        Adapted for use in vispy library by\n                    Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n\n        \"\"\"\n        if n < 0:\n            return 0\n        x = float(x)  # force float type\n\n        d = 1e-6\n        b = 0\n        if math.fabs(x) <= d:\n            if n != 0:\n                return 0\n            return 1\n\n        b1 = 0  # b1 is the value from the previous iteration\n        # Set up a starting order for recurrence\n        m1 = int(math.fabs(x)) + 6\n        if math.fabs(x) > 5:\n            m1 = int(math.fabs(1.4 * x + 60 / x))\n\n        m2 = int(n + 2 + math.fabs(x) / 4)\n        if m1 > m2:\n            m2 = m1\n\n        # Apply recurrence down from current max order\n        while True:\n            c3 = 0\n            c2 = 1e-30\n            c4 = 0\n            m8 = 1\n            if m2 // 2 * 2 == m2:\n                m8 = -1\n\n            imax = m2 - 2\n            for i in range(1, imax + 1):\n                c6 = 2 * (m2 - i) * c2 / x - c3\n                c3 = c2\n                c2 = c6\n                if m2 - i - 1 == n:\n                    b = c6\n                m8 = -1 * m8\n                if m8 > 0:\n                    c4 = c4 + 2 * c6\n\n            c6 = 2 * c2 / x - c3\n            if n == 0:\n                b = c6\n            c4 += c6\n            b /= c4\n            if math.fabs(b - b1) < d:\n                return b\n            b1 = b\n            m2 += 3",
  "def weight(self, x):\n        if x == 0:\n            return math.pi / 4\n        else:\n            return self.besj(math.pi * x, 1) / (2 * x)",
  "def __init__(self):\n        super().__init__(radius=4)",
  "def weight(self, x):\n        if x == 0:\n            return 1\n        x *= math.pi\n        return (math.sin(x) / x)",
  "def __init__(self):\n        super().__init__(radius=4)",
  "def weight(self, x):\n        if x == 0:\n            return 1\n        elif x > self.radius:\n            return 0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (math.sin(xr) / xr)",
  "def __init__(self):\n        super().__init__(radius=4)",
  "def weight(self, x):\n        if x == 0:\n            return 1\n        elif x > self.radius:\n            return 0\n        x *= math.pi\n        xr = x / self.radius\n        return (math.sin(x) / x) * (0.42 + 0.5 * math.cos(xr) + 0.08 * math.cos(2 * xr))",
  "def find(name):\n    \"\"\"Locate a filename into the shader library.\"\"\"\n    if op.exists(name):\n        return name\n\n    path = op.dirname(__file__) or '.'\n\n    paths = [path] + config['include_path']\n\n    for path in paths:\n        filename = op.abspath(op.join(path, name))\n        if op.exists(filename):\n            return filename\n\n        for d in os.listdir(path):\n            fullpath = op.abspath(op.join(path, d))\n            if op.isdir(fullpath):\n                filename = op.abspath(op.join(fullpath, name))\n                if op.exists(filename):\n                    return filename\n\n    return None",
  "def get(name):\n    \"\"\"Retrieve code from the given filename.\"\"\"\n    filename = find(name)\n    if filename is None:\n        raise RuntimeError('Could not find %s' % name)\n    with open(filename) as fid:\n        return fid.read()",
  "def get(filename):\n    for path in [\"..\", \".\"]:\n        filepath = os.path.join(path, filename)\n        if os.path.exists(filepath):\n            with open(filepath) as infile:\n                code = infile.read()\n                # comment = '#line 0 // Start of \"%s\"\\n' % filename\n                comment = '// --- start of \"%s\" ---\\n' % filename\n            return comment + code\n    return '#error \"%s\" not found !\\n' % filename",
  "def replace(match):\n    filename = match.group(\"filename\")\n    if filename not in includes:\n        includes.append(filename)\n        text = get(filename)\n        # lineno = code.count(\"\\n\",0,match.start())+1\n        # text += '\\n#line %d // End of \"%s\"' % (lineno, filename)\n        text += '// --- end of \"%s\" ---\\n' % filename\n        return text\n    return ''",
  "def _vector_or_scalar(x, type='row'):\n    \"\"\"Convert an object to either a scalar or a row or column vector.\"\"\"\n    if isinstance(x, (list, tuple)):\n        x = np.array(x)\n    if isinstance(x, np.ndarray):\n        assert x.ndim == 1\n        if type == 'column':\n            x = x[:, None]\n    return x",
  "def _vector(x, type='row'):\n    \"\"\"Convert an object to a row or column vector.\"\"\"\n    if isinstance(x, (list, tuple)):\n        x = np.array(x, dtype=np.float32)\n    elif not isinstance(x, np.ndarray):\n        x = np.array([x], dtype=np.float32)\n    assert x.ndim == 1\n    if type == 'column':\n        x = x[:, None]\n    return x",
  "def _find_controls(x, controls=None, clip=None):\n    x_controls = np.clip(np.searchsorted(controls, x) - 1, 0, clip)\n    return x_controls.astype(np.int32)",
  "def _normalize(x, cmin=None, cmax=None, clip=True):\n    \"\"\"Normalize an array from the range [cmin, cmax] to [0,1],\n    with optional clipping.\n    \"\"\"\n    if not isinstance(x, np.ndarray):\n        x = np.array(x)\n    if cmin is None:\n        cmin = x.min()\n    if cmax is None:\n        cmax = x.max()\n    if cmin == cmax:\n        return .5 * np.ones(x.shape)\n    else:\n        cmin, cmax = float(cmin), float(cmax)\n        y = (x - cmin) * 1. / (cmax - cmin)\n        if clip:\n            y = np.clip(y, 0., 1.)\n        return y",
  "def _mix_simple(a, b, x):\n    \"\"\"Mix b (with proportion x) with a.\"\"\"\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x)*a + x*b",
  "def _interpolate_multi(colors, x, controls):\n    x = x.ravel()\n    n = len(colors)\n    # For each element in x, the control index of its bin's left boundary.\n    x_step = _find_controls(x, controls, n-2)\n    # The length of each bin.\n    controls_length = np.diff(controls).astype(np.float32)\n    # Prevent division by zero error.\n    controls_length[controls_length == 0.] = 1.\n    # Like x, but relative to each bin.\n    _to_clip = x - controls[x_step]\n    _to_clip /= controls_length[x_step]\n    x_rel = np.clip(_to_clip, 0., 1.)\n    return (colors[x_step],\n            colors[x_step + 1],\n            x_rel[:, None])",
  "def mix(colors, x, controls=None):\n    a, b, x_rel = _interpolate_multi(colors, x, controls)\n    return _mix_simple(a, b, x_rel)",
  "def smoothstep(edge0, edge1, x):\n    \"\"\"Performs smooth Hermite interpolation\n    between 0 and 1 when edge0 < x < edge1.\n    \"\"\"\n    # Scale, bias and saturate x to 0..1 range\n    x = np.clip((x - edge0)/(edge1 - edge0), 0.0, 1.0)\n    # Evaluate polynomial\n    return x*x*(3 - 2*x)",
  "def step(colors, x, controls=None):\n    x = x.ravel()\n    \"\"\"Step interpolation from a set of colors. x belongs in [0, 1].\"\"\"\n    assert (controls[0], controls[-1]) == (0., 1.)\n    ncolors = len(colors)\n    assert ncolors == len(controls) - 1\n    assert ncolors >= 2\n    x_step = _find_controls(x, controls, ncolors-1)\n    return colors[x_step, ...]",
  "def _glsl_mix(controls=None, colors=None, texture_map_data=None):\n    \"\"\"Generate a GLSL template function from a given interpolation patterns\n    and control points.\n\n    Parameters\n    ----------\n    colors : array-like, shape (n_colors, 4)\n        The control colors used by the colormap.\n        Elements of colors must be convertible to an instance of Color-class.\n\n    controls : list\n        The list of control points for the given colors. It should be\n        an increasing list of floating-point number between 0.0 and 1.0.\n        The first control point must be 0.0. The last control point must be\n        1.0. The number of control points depends on the interpolation scheme.\n\n    texture_map_data : ndarray, shape(texture_len, 4)\n        Numpy array of size of 1D texture lookup data\n        for luminance to RGBA conversion.\n    \"\"\"\n    assert (controls[0], controls[-1]) == (0., 1.)\n    ncolors = len(controls)\n    assert ncolors >= 2\n    assert (texture_map_data is not None)\n\n    LUT = texture_map_data\n    texture_len = texture_map_data.shape[0]\n\n    # Perform linear interpolation for each RGBA color component.\n    c_rgba = ColorArray(colors)._rgba\n    x = np.linspace(0.0, 1.0, texture_len)\n    LUT[:, 0, 0] = np.interp(x, controls, c_rgba[:, 0])\n    LUT[:, 0, 1] = np.interp(x, controls, c_rgba[:, 1])\n    LUT[:, 0, 2] = np.interp(x, controls, c_rgba[:, 2])\n    LUT[:, 0, 3] = np.interp(x, controls, c_rgba[:, 3])\n\n    s2 = \"uniform sampler2D texture2D_LUT;\"\n    s = \"{\\n return texture2D(texture2D_LUT, \\\n          vec2(0.0, clamp(t, 0.0, 1.0)));\\n} \"\n\n    return \"%s\\nvec4 colormap(float t) {\\n%s\\n}\" % (s2, s)",
  "def _glsl_step(controls=None, colors=None, texture_map_data=None):\n    assert (controls[0], controls[-1]) == (0., 1.)\n    ncolors = len(controls) - 1\n    assert ncolors >= 2\n    assert (texture_map_data is not None)\n\n    LUT = texture_map_data\n    texture_len = texture_map_data.shape[0]\n    LUT_tex_idx = np.linspace(0.0, 1.0, texture_len)\n\n    # Replicate indices to colormap texture.\n    # The resulting matrix has size of (texture_len,len(controls)).\n    # It is used to perform piecewise constant interpolation\n    # for each RGBA color component.\n    t2 = np.repeat(LUT_tex_idx[:, np.newaxis], len(controls), 1)\n\n    # Perform element-wise comparison to find\n    # control points for all LUT colors.\n    bn = np.sum(controls.transpose() <= t2, axis=1)\n\n    j = np.clip(bn-1, 0, ncolors-1)\n\n    # Copying color data from ColorArray to array-like\n    # makes data assignment to LUT faster.\n    colors_rgba = ColorArray(colors[:])._rgba\n    LUT[:, 0, :] = colors_rgba[j]\n\n    s2 = \"uniform sampler2D texture2D_LUT;\"\n    s = \"{\\n return texture2D(texture2D_LUT, \\\n           vec2(0.0, clamp(t, 0.0, 1.0)));\\n} \"\n\n    return \"%s\\nvec4 colormap(float t) {\\n%s\\n}\" % (s2, s)",
  "def _process_glsl_template(template, colors):\n    \"\"\"Replace $color_i by color #i in the GLSL template.\"\"\"\n    for i in range(len(colors) - 1, -1, -1):\n        color = colors[i]\n        assert len(color) == 4\n        vec4_color = 'vec4(%.3f, %.3f, %.3f, %.3f)' % tuple(color)\n        template = template.replace('$color_%d' % i, vec4_color)\n    return template",
  "class BaseColormap(object):\n    u\"\"\"Class representing a colormap:\n\n        t in [0, 1] --> rgba_color\n\n    Parameters\n    ----------\n    colors : list of lists, tuples, or ndarrays\n        The control colors used by the colormap (shape = (ncolors, 4)).\n\n    Notes\n    -----\n    Must be overriden. Child classes need to implement:\n\n    glsl_map : string\n        The GLSL function for the colormap. Use $color_0 to refer\n        to the first color in `colors`, and so on. These are vec4 vectors.\n    map(item) : function\n        Takes a (N, 1) vector of values in [0, 1], and returns a rgba array\n        of size (N, 4).\n    \"\"\"\n\n    # Control colors used by the colormap.\n    colors = None\n\n    # GLSL string with a function implementing the color map.\n    glsl_map = None\n\n    # Texture map data used by the 'colormap' GLSL function\n    # for luminance to RGBA conversion.\n    texture_map_data = None\n\n    def __init__(self, colors=None):\n        # Ensure the colors are arrays.\n        if colors is not None:\n            self.colors = colors\n        if not isinstance(self.colors, ColorArray):\n            self.colors = ColorArray(self.colors)\n        # Process the GLSL map function by replacing $color_i by the\n        if len(self.colors) > 0:\n            self.glsl_map = _process_glsl_template(self.glsl_map,\n                                                   self.colors.rgba)\n\n    def map(self, item):\n        \"\"\"Return a rgba array for the requested items.\n\n        This function must be overriden by child classes.\n\n        This function doesn't need to implement argument checking on `item`.\n        It can always assume that `item` is a (N, 1) array of values between\n        0 and 1.\n\n        Parameters\n        ----------\n        item : ndarray\n            An array of values in [0,1].\n\n        Returns\n        -------\n        rgba : ndarray\n            An array with rgba values, with one color per item. The shape\n            should be ``item.shape + (4,)``.\n\n        Notes\n        -----\n        Users are expected to use a colormap with ``__getitem__()`` rather\n        than ``map()`` (which implements a lower-level API).\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def texture_lut(self):\n        \"\"\"Return a texture2D object for LUT after its value is set. Can be None.\"\"\"\n        return None\n\n    def __getitem__(self, item):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        # Ensure item is either a scalar or a column vector.\n        item = _vector(item, type='column')\n        # Clip the values in [0, 1].\n        item = np.clip(item, 0., 1.)\n        colors = self.map(item)\n        return ColorArray(colors)\n\n    def __setitem__(self, item, value):\n        raise RuntimeError(\"It is not possible to set items to \"\n                           \"BaseColormap instances.\")\n\n    def _repr_html_(self):\n        n = 100\n        html = (\"\"\"\n                <style>\n                    table.vispy_colormap {\n                        height: 30px;\n                        border: 0;\n                        margin: 0;\n                        padding: 0;\n                    }\n\n                    table.vispy_colormap td {\n                        width: 3px;\n                        border: 0;\n                        margin: 0;\n                        padding: 0;\n                    }\n                </style>\n                <table class=\"vispy_colormap\">\n                \"\"\" +\n                '\\n'.join([((\"\"\"<td style=\"background-color: %s;\"\n                                 title=\"%s\"></td>\"\"\") % (color, color))\n                           for color in self[np.linspace(0., 1., n)].hex]) +\n                \"\"\"\n                </table>\n                \"\"\")\n        return html",
  "def _default_controls(ncolors):\n    \"\"\"Generate linearly spaced control points from a set of colors.\"\"\"\n    return np.linspace(0., 1., ncolors)",
  "class Colormap(BaseColormap):\n    \"\"\"A colormap defining several control colors and an interpolation scheme.\n\n    Parameters\n    ----------\n    colors : list of colors | ColorArray\n        The list of control colors. If not a ``ColorArray``, a new\n        ``ColorArray`` instance is created from this list. See the\n        documentation of ``ColorArray``.\n    controls : array-like\n        The list of control points for the given colors. It should be\n        an increasing list of floating-point number between 0.0 and 1.0.\n        The first control point must be 0.0. The last control point must be\n        1.0. The number of control points depends on the interpolation scheme.\n    interpolation : str\n        The interpolation mode of the colormap. Default: 'linear'. Can also\n        be 'zero'.\n        If 'linear', ncontrols = ncolors (one color per control point).\n        If 'zero', ncontrols = ncolors+1 (one color per bin).\n\n    Examples\n    --------\n    Here is a basic example:\n\n        >>> from vispy.color import Colormap\n        >>> cm = Colormap(['r', 'g', 'b'])\n        >>> cm[0.], cm[0.5], cm[np.linspace(0., 1., 100)]\n\n    \"\"\"\n\n    def __init__(self, colors, controls=None, interpolation='linear'):\n        self.interpolation = interpolation\n        ncontrols = self._ncontrols(len(colors))\n        # Default controls.\n        if controls is None:\n            controls = _default_controls(ncontrols)\n        assert len(controls) == ncontrols\n        self._controls = np.array(controls, dtype=np.float32)\n        # use texture map for luminance to RGBA conversion\n        self.texture_map_data = np.zeros((LUT_len, 1, 4), dtype=np.float32)\n        self.glsl_map = self._glsl_map_generator(self._controls, colors,\n                                                 self.texture_map_data)\n        super(Colormap, self).__init__(colors)\n\n    @property\n    def interpolation(self):\n        \"\"\"The interpolation mode of the colormap\"\"\"\n        return self._interpolation\n\n    @interpolation.setter\n    def interpolation(self, val):\n        if val not in _interpolation_info:\n            raise ValueError('The interpolation mode can only be one of: ' +\n                             ', '.join(sorted(_interpolation_info.keys())))\n        # Get the information of the interpolation mode.\n        info = _interpolation_info[val]\n        # Get the function that generates the GLSL map, as a function of the\n        # controls array.\n        self._glsl_map_generator = info['glsl_map']\n        # Number of controls as a function of the number of colors.\n        self._ncontrols = info['ncontrols']\n        # Python map function.\n        self._map_function = info['map']\n        self._interpolation = val\n\n    def map(self, x):\n        \"\"\"The Python mapping function from the [0,1] interval to a\n        list of rgba colors\n\n        Parameters\n        ----------\n        x : array-like\n            The values to map.\n\n        Returns\n        -------\n        colors : list\n            List of rgba colors.\n        \"\"\"\n        return self._map_function(self.colors.rgba, x, self._controls)\n\n    def texture_lut(self):\n        \"\"\"Return a texture2D object for LUT after its value is set. Can be None.\"\"\"\n        if self.texture_map_data is None:\n            return None\n        interp = 'linear' if self.interpolation == 'linear' else 'nearest'\n        texture_LUT = vispy.gloo.Texture2D(np.zeros(self.texture_map_data.shape),\n                                           interpolation=interp)\n        texture_LUT.set_data(self.texture_map_data, offset=None, copy=True)\n        return texture_LUT",
  "class MatplotlibColormap(Colormap):\n    \"\"\"Use matplotlib colormaps if installed.\n\n    Parameters\n    ----------\n    name : string\n        Name of the colormap.\n    \"\"\"\n\n    def __init__(self, name):\n        from matplotlib.cm import ScalarMappable\n\n        vec = ScalarMappable(cmap=name).to_rgba(np.arange(LUT_len))\n        Colormap.__init__(self, vec)",
  "class CubeHelixColormap(Colormap):\n    def __init__(self, start=0.5, rot=1, gamma=1.0, reverse=True, nlev=32,\n                 minSat=1.2, maxSat=1.2, minLight=0., maxLight=1., **kwargs):\n        \"\"\"Cube helix colormap\n\n        A full implementation of Dave Green's \"cubehelix\" for Matplotlib.\n        Based on the FORTRAN 77 code provided in\n        D.A. Green, 2011, BASI, 39, 289.\n\n        http://adsabs.harvard.edu/abs/2011arXiv1108.5083G\n\n        User can adjust all parameters of the cubehelix algorithm.\n        This enables much greater flexibility in choosing color maps, while\n        always ensuring the color map scales in intensity from black\n        to white. A few simple examples:\n\n        Default color map settings produce the standard \"cubehelix\".\n\n        Create color map in only blues by setting rot=0 and start=0.\n\n        Create reverse (white to black) backwards through the rainbow once\n        by setting rot=1 and reverse=True.\n\n        Parameters\n        ----------\n        start : scalar, optional\n            Sets the starting position in the color space. 0=blue, 1=red,\n            2=green. Defaults to 0.5.\n        rot : scalar, optional\n            The number of rotations through the rainbow. Can be positive\n            or negative, indicating direction of rainbow. Negative values\n            correspond to Blue->Red direction. Defaults to -1.5\n        gamma : scalar, optional\n            The gamma correction for intensity. Defaults to 1.0\n        reverse : boolean, optional\n            Set to True to reverse the color map. Will go from black to\n            white. Good for density plots where shade~density. Defaults to\n            False\n        nlev : scalar, optional\n            Defines the number of discrete levels to render colors at.\n            Defaults to 32.\n        sat : scalar, optional\n            The saturation intensity factor. Defaults to 1.2\n            NOTE: this was formerly known as \"hue\" parameter\n        minSat : scalar, optional\n            Sets the minimum-level saturation. Defaults to 1.2\n        maxSat : scalar, optional\n            Sets the maximum-level saturation. Defaults to 1.2\n        startHue : scalar, optional\n            Sets the starting color, ranging from [0, 360], as in\n            D3 version by @mbostock\n            NOTE: overrides values in start parameter\n        endHue : scalar, optional\n            Sets the ending color, ranging from [0, 360], as in\n            D3 version by @mbostock\n            NOTE: overrides values in rot parameter\n        minLight : scalar, optional\n            Sets the minimum lightness value. Defaults to 0.\n        maxLight : scalar, optional\n            Sets the maximum lightness value. Defaults to 1.\n        \"\"\"\n        super(CubeHelixColormap, self).__init__(\n            cubehelix(start=start, rot=rot, gamma=gamma, reverse=reverse,\n                      nlev=nlev, minSat=minSat, maxSat=maxSat,\n                      minLight=minLight, maxLight=maxLight, **kwargs))",
  "class _Fire(BaseColormap):\n    colors = [(1.0, 1.0, 1.0, 1.0),\n              (1.0, 1.0, 0.0, 1.0),\n              (1.0, 0.0, 0.0, 1.0)]\n\n    glsl_map = \"\"\"\n    vec4 fire(float t) {\n        return mix(mix($color_0, $color_1, t),\n                   mix($color_1, $color_2, t*t), t);\n    }\n    \"\"\"\n\n    def map(self, t):\n        a, b, d = self.colors.rgba\n        c = _mix_simple(a, b, t)\n        e = _mix_simple(b, d, t**2)\n        return _mix_simple(c, e, t)",
  "class _Grays(BaseColormap):\n    glsl_map = \"\"\"\n    vec4 grays(float t) {\n        return vec4(t, t, t, 1.0);\n    }\n    \"\"\"\n\n    def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack([t, t, t, np.ones(t.shape)]).astype(np.float32)\n        else:\n            return np.array([t, t, t, 1.0], dtype=np.float32)",
  "class _Ice(BaseColormap):\n    glsl_map = \"\"\"\n    vec4 ice(float t) {\n        return vec4(t, t, 1.0, 1.0);\n    }\n    \"\"\"\n\n    def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack([t, t, np.ones(t.shape),\n                              np.ones(t.shape)]).astype(np.float32)\n        else:\n            return np.array([t, t, 1.0, 1.0], dtype=np.float32)",
  "class _Hot(BaseColormap):\n    colors = [(0., .33, .66, 1.0),\n              (.33, .66, 1., 1.0)]\n\n    glsl_map = \"\"\"\n    vec4 hot(float t) {\n        return vec4(smoothstep($color_0.rgb, $color_1.rgb, vec3(t, t, t)),\n                    1.0);\n    }\n    \"\"\"\n\n    def map(self, t):\n        rgba = self.colors.rgba\n        smoothed = smoothstep(rgba[0, :3], rgba[1, :3], t)\n        return np.hstack((smoothed, np.ones((len(t), 1))))",
  "class _Winter(BaseColormap):\n    colors = [(0.0, 0.0, 1.0, 1.0),\n              (0.0, 1.0, 0.5, 1.0)]\n\n    glsl_map = \"\"\"\n    vec4 winter(float t) {\n        return mix($color_0, $color_1, sqrt(t));\n    }\n    \"\"\"\n\n    def map(self, t):\n        return _mix_simple(self.colors.rgba[0],\n                           self.colors.rgba[1],\n                           np.sqrt(t))",
  "class SingleHue(Colormap):\n    \"\"\"A colormap which is solely defined by the given hue and value.\n\n    Given the color hue and value, this color map increases the saturation\n    of a color. The start color is almost white but still contains a hint of\n    the given color, and at the end the color is fully saturated.\n\n    Parameters\n    ----------\n    hue : scalar, optional\n        The hue refers to a \"true\" color, without any shading or tinting.\n        Must be in the range [0, 360]. Defaults to 200 (blue).\n    saturation_range : array-like, optional\n        The saturation represents how \"pure\" a color is. Less saturation means\n        more white light mixed in the color. A fully saturated color means\n        the pure color defined by the hue. No saturation means completely\n        white. This colormap changes the saturation, and with this parameter\n        you can specify the lower and upper bound. Default is [0.2, 0.8].\n    value : scalar, optional\n        The value defines the \"brightness\" of a color: a value of 0.0 means\n        completely black while a value of 1.0 means the color defined by the\n        hue without shading. Must be in the range [0, 1.0]. The default value\n        is 1.0.\n\n    Notes\n    -----\n    For more information about the hue values see the `wikipedia page`_.\n\n    .. _wikipedia page: https://en.wikipedia.org/wiki/Hue\n    \"\"\"\n\n    def __init__(self, hue=200, saturation_range=[0.1, 0.8], value=1.0):\n        colors = ColorArray([\n            (hue, saturation_range[0], value),\n            (hue, saturation_range[1], value)\n        ], color_space='hsv')\n        super(SingleHue, self).__init__(colors)",
  "class HSL(Colormap):\n    \"\"\"A colormap which is defined by n evenly spaced points in a circular color space.\n\n    This means that we change the hue value while keeping the\n    saturation and value constant.\n\n    Parameters\n    ----------\n    n_colors : int, optional\n        The number of colors to generate.\n    hue_start : int, optional\n        The hue start value. Must be in the range [0, 360], the default is 0.\n    saturation : float, optional\n        The saturation component of the colors to generate. The default is\n        fully saturated (1.0). Must be in the range [0, 1.0].\n    value : float, optional\n        The value (brightness) component of the colors to generate. Must\n        be in the range [0, 1.0], and the default is 1.0\n    controls : array-like, optional\n        The list of control points for the colors to generate. It should be\n        an increasing list of floating-point number between 0.0 and 1.0.\n        The first control point must be 0.0. The last control point must be\n        1.0. The number of control points depends on the interpolation scheme.\n    interpolation : str, optional\n        The interpolation mode of the colormap. Default: 'linear'. Can also\n        be 'zero'.\n        If 'linear', ncontrols = ncolors (one color per control point).\n        If 'zero', ncontrols = ncolors+1 (one color per bin).\n    \"\"\"\n\n    def __init__(self, ncolors=6, hue_start=0, saturation=1.0, value=1.0,\n                 controls=None, interpolation='linear'):\n        hues = np.linspace(0, 360, ncolors + 1)[:-1]\n        hues += hue_start\n        hues %= 360\n\n        colors = ColorArray([(hue, saturation, value) for hue in hues],\n                            color_space='hsv')\n\n        super(HSL, self).__init__(colors, controls=controls,\n                                  interpolation=interpolation)",
  "class HSLuv(Colormap):\n    \"\"\"A colormap which is defined by n evenly spaced points in the HSLuv space.\n\n    Parameters\n    ----------\n    n_colors : int, optional\n        The number of colors to generate.\n    hue_start : int, optional\n        The hue start value. Must be in the range [0, 360], the default is 0.\n    saturation : float, optional\n        The saturation component of the colors to generate. The default is\n        fully saturated (1.0). Must be in the range [0, 1.0].\n    value : float, optional\n        The value component of the colors to generate or \"brightness\". Must\n        be in the range [0, 1.0], and the default is 0.7.\n    controls : array-like, optional\n        The list of control points for the colors to generate. It should be\n        an increasing list of floating-point number between 0.0 and 1.0.\n        The first control point must be 0.0. The last control point must be\n        1.0. The number of control points depends on the interpolation scheme.\n    interpolation : str, optional\n        The interpolation mode of the colormap. Default: 'linear'. Can also\n        be 'zero'.\n        If 'linear', ncontrols = ncolors (one color per control point).\n        If 'zero', ncontrols = ncolors+1 (one color per bin).\n\n    Notes\n    -----\n    For more information about HSLuv colors see https://www.hsluv.org/\n    \"\"\"\n\n    def __init__(self, ncolors=6, hue_start=0, saturation=1.0, value=0.7,\n                 controls=None, interpolation='linear'):\n        hues = np.linspace(0, 360, ncolors + 1)[:-1]\n        hues += hue_start\n        hues %= 360\n\n        saturation *= 99\n        value *= 99\n\n        colors = ColorArray(\n            [hsluv_to_rgb([hue, saturation, value]) for hue in hues],\n        )\n\n        super(HSLuv, self).__init__(colors, controls=controls,\n                                    interpolation=interpolation)",
  "class _HUSL(HSLuv):\n    \"\"\"Deprecated.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\"_HUSL Colormap is deprecated. Please use 'HSLuv' instead.\")\n        super().__init__(*args, **kwargs)",
  "class Diverging(Colormap):\n\n    def __init__(self, h_pos=20, h_neg=250, saturation=1.0, value=0.7,\n                 center=\"light\"):\n        saturation *= 99\n        value *= 99\n\n        start = hsluv_to_rgb([h_neg, saturation, value])\n        mid = ((0.133, 0.133, 0.133) if center == \"dark\" else\n               (0.92, 0.92, 0.92))\n        end = hsluv_to_rgb([h_pos, saturation, value])\n\n        colors = ColorArray([start, mid, end])\n\n        super(Diverging, self).__init__(colors)",
  "class RedYellowBlueCyan(Colormap):\n    \"\"\"A colormap which goes red-yellow positive and blue-cyan negative\n\n    Parameters\n    ----------\n    limits : array-like, optional\n        The limits for the fully transparent, opaque red, and yellow points.\n    \"\"\"\n\n    def __init__(self, limits=(0.33, 0.66, 1.0)):\n        limits = np.array(limits, float).ravel()\n        if len(limits) != 3:\n            raise ValueError('limits must have 3 values')\n        if (np.diff(limits) < 0).any() or (limits <= 0).any():\n            raise ValueError('limits must be strictly increasing and positive')\n        controls = np.array([-limits[2], -limits[1], -limits[0],\n                             limits[0], limits[1], limits[2]])\n        controls = ((controls / limits[2]) + 1) / 2.\n        colors = [(0., 1., 1., 1.), (0., 0., 1., 1.), (0., 0., 1., 0.),\n                  (1., 0., 0., 0.), (1., 0., 0., 1.), (1., 1., 0., 1.)]\n        colors = ColorArray(colors)\n        super(RedYellowBlueCyan, self).__init__(\n            colors, controls=controls, interpolation='linear')",
  "def get_colormap(name, *args, **kwargs):\n    \"\"\"Obtain a colormap.\n\n    Parameters\n    ----------\n    name : str | Colormap\n        Colormap name. Can also be a Colormap for pass-through.\n    *args:\n        Deprecated.\n    **kwargs\n        Deprecated.\n\n    Examples\n    --------\n    >>> get_colormap('autumn')\n    >>> get_colormap('single_hue')\n\n    .. versionchanged: 0.7\n\n        Additional args/kwargs are no longer accepted. Colormap classes are\n        no longer created on the fly. To create a ``cubehelix``\n        (``CubeHelixColormap``), ``single_hue`` (``SingleHue``), ``hsl``\n        (``HSL``), ``husl`` (``HSLuv``), ``diverging`` (``Diverging``), or\n        ``RdYeBuCy`` (``RedYellowBlueCyan``) colormap you must import and\n        instantiate it directly from the ``vispy.color.colormap`` module.\n\n    \"\"\"\n    if args or kwargs:\n        warnings.warn(\"Creating a Colormap instance with 'get_colormap' is \"\n                      \"no longer supported. No additional arguments or \"\n                      \"keyword arguments should be passed.\", DeprecationWarning)\n    if isinstance(name, BaseColormap):\n        return name\n\n    if not isinstance(name, str):\n        raise TypeError('colormap must be a Colormap or string name')\n    if name in _colormaps:  # vispy cmap\n        cmap = _colormaps[name]\n        if name in (\"cubehelix\", \"single_hue\", \"hsl\", \"husl\", \"diverging\", \"RdYeBuCy\"):\n            warnings.warn(\n                f\"Colormap '{name}' has been deprecated since vispy 0.7. \"\n                f\"Please import and create 'vispy.color.colormap.{cmap.__class__.__name__}' \"\n                \"directly instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n    elif has_matplotlib():  # matplotlib cmap\n        try:\n            cmap = MatplotlibColormap(name)\n        except ValueError:\n            raise KeyError('colormap name %s not found' % name)\n    else:\n        raise KeyError('colormap name %s not found' % name)\n    return cmap",
  "def get_colormaps():\n    \"\"\"Return the list of colormap names.\"\"\"\n    return _colormaps.copy()",
  "def __init__(self, colors=None):\n        # Ensure the colors are arrays.\n        if colors is not None:\n            self.colors = colors\n        if not isinstance(self.colors, ColorArray):\n            self.colors = ColorArray(self.colors)\n        # Process the GLSL map function by replacing $color_i by the\n        if len(self.colors) > 0:\n            self.glsl_map = _process_glsl_template(self.glsl_map,\n                                                   self.colors.rgba)",
  "def map(self, item):\n        \"\"\"Return a rgba array for the requested items.\n\n        This function must be overriden by child classes.\n\n        This function doesn't need to implement argument checking on `item`.\n        It can always assume that `item` is a (N, 1) array of values between\n        0 and 1.\n\n        Parameters\n        ----------\n        item : ndarray\n            An array of values in [0,1].\n\n        Returns\n        -------\n        rgba : ndarray\n            An array with rgba values, with one color per item. The shape\n            should be ``item.shape + (4,)``.\n\n        Notes\n        -----\n        Users are expected to use a colormap with ``__getitem__()`` rather\n        than ``map()`` (which implements a lower-level API).\n\n        \"\"\"\n        raise NotImplementedError()",
  "def texture_lut(self):\n        \"\"\"Return a texture2D object for LUT after its value is set. Can be None.\"\"\"\n        return None",
  "def __getitem__(self, item):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        # Ensure item is either a scalar or a column vector.\n        item = _vector(item, type='column')\n        # Clip the values in [0, 1].\n        item = np.clip(item, 0., 1.)\n        colors = self.map(item)\n        return ColorArray(colors)",
  "def __setitem__(self, item, value):\n        raise RuntimeError(\"It is not possible to set items to \"\n                           \"BaseColormap instances.\")",
  "def _repr_html_(self):\n        n = 100\n        html = (\"\"\"\n                <style>\n                    table.vispy_colormap {\n                        height: 30px;\n                        border: 0;\n                        margin: 0;\n                        padding: 0;\n                    }\n\n                    table.vispy_colormap td {\n                        width: 3px;\n                        border: 0;\n                        margin: 0;\n                        padding: 0;\n                    }\n                </style>\n                <table class=\"vispy_colormap\">\n                \"\"\" +\n                '\\n'.join([((\"\"\"<td style=\"background-color: %s;\"\n                                 title=\"%s\"></td>\"\"\") % (color, color))\n                           for color in self[np.linspace(0., 1., n)].hex]) +\n                \"\"\"\n                </table>\n                \"\"\")\n        return html",
  "def __init__(self, colors, controls=None, interpolation='linear'):\n        self.interpolation = interpolation\n        ncontrols = self._ncontrols(len(colors))\n        # Default controls.\n        if controls is None:\n            controls = _default_controls(ncontrols)\n        assert len(controls) == ncontrols\n        self._controls = np.array(controls, dtype=np.float32)\n        # use texture map for luminance to RGBA conversion\n        self.texture_map_data = np.zeros((LUT_len, 1, 4), dtype=np.float32)\n        self.glsl_map = self._glsl_map_generator(self._controls, colors,\n                                                 self.texture_map_data)\n        super(Colormap, self).__init__(colors)",
  "def interpolation(self):\n        \"\"\"The interpolation mode of the colormap\"\"\"\n        return self._interpolation",
  "def interpolation(self, val):\n        if val not in _interpolation_info:\n            raise ValueError('The interpolation mode can only be one of: ' +\n                             ', '.join(sorted(_interpolation_info.keys())))\n        # Get the information of the interpolation mode.\n        info = _interpolation_info[val]\n        # Get the function that generates the GLSL map, as a function of the\n        # controls array.\n        self._glsl_map_generator = info['glsl_map']\n        # Number of controls as a function of the number of colors.\n        self._ncontrols = info['ncontrols']\n        # Python map function.\n        self._map_function = info['map']\n        self._interpolation = val",
  "def map(self, x):\n        \"\"\"The Python mapping function from the [0,1] interval to a\n        list of rgba colors\n\n        Parameters\n        ----------\n        x : array-like\n            The values to map.\n\n        Returns\n        -------\n        colors : list\n            List of rgba colors.\n        \"\"\"\n        return self._map_function(self.colors.rgba, x, self._controls)",
  "def texture_lut(self):\n        \"\"\"Return a texture2D object for LUT after its value is set. Can be None.\"\"\"\n        if self.texture_map_data is None:\n            return None\n        interp = 'linear' if self.interpolation == 'linear' else 'nearest'\n        texture_LUT = vispy.gloo.Texture2D(np.zeros(self.texture_map_data.shape),\n                                           interpolation=interp)\n        texture_LUT.set_data(self.texture_map_data, offset=None, copy=True)\n        return texture_LUT",
  "def __init__(self, name):\n        from matplotlib.cm import ScalarMappable\n\n        vec = ScalarMappable(cmap=name).to_rgba(np.arange(LUT_len))\n        Colormap.__init__(self, vec)",
  "def __init__(self, start=0.5, rot=1, gamma=1.0, reverse=True, nlev=32,\n                 minSat=1.2, maxSat=1.2, minLight=0., maxLight=1., **kwargs):\n        \"\"\"Cube helix colormap\n\n        A full implementation of Dave Green's \"cubehelix\" for Matplotlib.\n        Based on the FORTRAN 77 code provided in\n        D.A. Green, 2011, BASI, 39, 289.\n\n        http://adsabs.harvard.edu/abs/2011arXiv1108.5083G\n\n        User can adjust all parameters of the cubehelix algorithm.\n        This enables much greater flexibility in choosing color maps, while\n        always ensuring the color map scales in intensity from black\n        to white. A few simple examples:\n\n        Default color map settings produce the standard \"cubehelix\".\n\n        Create color map in only blues by setting rot=0 and start=0.\n\n        Create reverse (white to black) backwards through the rainbow once\n        by setting rot=1 and reverse=True.\n\n        Parameters\n        ----------\n        start : scalar, optional\n            Sets the starting position in the color space. 0=blue, 1=red,\n            2=green. Defaults to 0.5.\n        rot : scalar, optional\n            The number of rotations through the rainbow. Can be positive\n            or negative, indicating direction of rainbow. Negative values\n            correspond to Blue->Red direction. Defaults to -1.5\n        gamma : scalar, optional\n            The gamma correction for intensity. Defaults to 1.0\n        reverse : boolean, optional\n            Set to True to reverse the color map. Will go from black to\n            white. Good for density plots where shade~density. Defaults to\n            False\n        nlev : scalar, optional\n            Defines the number of discrete levels to render colors at.\n            Defaults to 32.\n        sat : scalar, optional\n            The saturation intensity factor. Defaults to 1.2\n            NOTE: this was formerly known as \"hue\" parameter\n        minSat : scalar, optional\n            Sets the minimum-level saturation. Defaults to 1.2\n        maxSat : scalar, optional\n            Sets the maximum-level saturation. Defaults to 1.2\n        startHue : scalar, optional\n            Sets the starting color, ranging from [0, 360], as in\n            D3 version by @mbostock\n            NOTE: overrides values in start parameter\n        endHue : scalar, optional\n            Sets the ending color, ranging from [0, 360], as in\n            D3 version by @mbostock\n            NOTE: overrides values in rot parameter\n        minLight : scalar, optional\n            Sets the minimum lightness value. Defaults to 0.\n        maxLight : scalar, optional\n            Sets the maximum lightness value. Defaults to 1.\n        \"\"\"\n        super(CubeHelixColormap, self).__init__(\n            cubehelix(start=start, rot=rot, gamma=gamma, reverse=reverse,\n                      nlev=nlev, minSat=minSat, maxSat=maxSat,\n                      minLight=minLight, maxLight=maxLight, **kwargs))",
  "def map(self, t):\n        a, b, d = self.colors.rgba\n        c = _mix_simple(a, b, t)\n        e = _mix_simple(b, d, t**2)\n        return _mix_simple(c, e, t)",
  "def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack([t, t, t, np.ones(t.shape)]).astype(np.float32)\n        else:\n            return np.array([t, t, t, 1.0], dtype=np.float32)",
  "def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack([t, t, np.ones(t.shape),\n                              np.ones(t.shape)]).astype(np.float32)\n        else:\n            return np.array([t, t, 1.0, 1.0], dtype=np.float32)",
  "def map(self, t):\n        rgba = self.colors.rgba\n        smoothed = smoothstep(rgba[0, :3], rgba[1, :3], t)\n        return np.hstack((smoothed, np.ones((len(t), 1))))",
  "def map(self, t):\n        return _mix_simple(self.colors.rgba[0],\n                           self.colors.rgba[1],\n                           np.sqrt(t))",
  "def __init__(self, hue=200, saturation_range=[0.1, 0.8], value=1.0):\n        colors = ColorArray([\n            (hue, saturation_range[0], value),\n            (hue, saturation_range[1], value)\n        ], color_space='hsv')\n        super(SingleHue, self).__init__(colors)",
  "def __init__(self, ncolors=6, hue_start=0, saturation=1.0, value=1.0,\n                 controls=None, interpolation='linear'):\n        hues = np.linspace(0, 360, ncolors + 1)[:-1]\n        hues += hue_start\n        hues %= 360\n\n        colors = ColorArray([(hue, saturation, value) for hue in hues],\n                            color_space='hsv')\n\n        super(HSL, self).__init__(colors, controls=controls,\n                                  interpolation=interpolation)",
  "def __init__(self, ncolors=6, hue_start=0, saturation=1.0, value=0.7,\n                 controls=None, interpolation='linear'):\n        hues = np.linspace(0, 360, ncolors + 1)[:-1]\n        hues += hue_start\n        hues %= 360\n\n        saturation *= 99\n        value *= 99\n\n        colors = ColorArray(\n            [hsluv_to_rgb([hue, saturation, value]) for hue in hues],\n        )\n\n        super(HSLuv, self).__init__(colors, controls=controls,\n                                    interpolation=interpolation)",
  "def __init__(self, *args, **kwargs):\n        warnings.warn(\"_HUSL Colormap is deprecated. Please use 'HSLuv' instead.\")\n        super().__init__(*args, **kwargs)",
  "def __init__(self, h_pos=20, h_neg=250, saturation=1.0, value=0.7,\n                 center=\"light\"):\n        saturation *= 99\n        value *= 99\n\n        start = hsluv_to_rgb([h_neg, saturation, value])\n        mid = ((0.133, 0.133, 0.133) if center == \"dark\" else\n               (0.92, 0.92, 0.92))\n        end = hsluv_to_rgb([h_pos, saturation, value])\n\n        colors = ColorArray([start, mid, end])\n\n        super(Diverging, self).__init__(colors)",
  "def __init__(self, limits=(0.33, 0.66, 1.0)):\n        limits = np.array(limits, float).ravel()\n        if len(limits) != 3:\n            raise ValueError('limits must have 3 values')\n        if (np.diff(limits) < 0).any() or (limits <= 0).any():\n            raise ValueError('limits must be strictly increasing and positive')\n        controls = np.array([-limits[2], -limits[1], -limits[0],\n                             limits[0], limits[1], limits[2]])\n        controls = ((controls / limits[2]) + 1) / 2.\n        colors = [(0., 1., 1., 1.), (0., 0., 1., 1.), (0., 0., 1., 0.),\n                  (1., 0., 0., 0.), (1., 0., 0., 1.), (1., 1., 0., 1.)]\n        colors = ColorArray(colors)\n        super(RedYellowBlueCyan, self).__init__(\n            colors, controls=controls, interpolation='linear')",
  "def _check_color_dim(val):\n    \"\"\"Ensure val is Nx(n_col), usually Nx3\"\"\"\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError('Value must have second dimension of size 3 or 4')\n    return val, val.shape[1]",
  "def _hex_to_rgba(hexs):\n    \"\"\"Convert hex to rgba, permitting alpha values in hex\"\"\"\n    hexs = np.atleast_1d(np.array(hexs, '|U9'))\n    out = np.ones((len(hexs), 4), np.float32)\n    for hi, h in enumerate(hexs):\n        assert isinstance(h, str)\n        off = 1 if h[0] == '#' else 0\n        assert len(h) in (6+off, 8+off)\n        e = (len(h)-off) // 2\n        out[hi, :e] = [int(h[i:i+2], 16) / 255.\n                       for i in range(off, len(h), 2)]\n    return out",
  "def _rgb_to_hex(rgbs):\n    \"\"\"Convert rgb to hex triplet\"\"\"\n    rgbs, n_dim = _check_color_dim(rgbs)\n    return np.array(['#%02x%02x%02x' % tuple((255*rgb[:3]).astype(np.uint8))\n                     for rgb in rgbs], '|U7')",
  "def _rgb_to_hsv(rgbs):\n    \"\"\"Convert Nx3 or Nx4 rgb to hsv\"\"\"\n    rgbs, n_dim = _check_color_dim(rgbs)\n    hsvs = list()\n    for rgb in rgbs:\n        rgb = rgb[:3]  # don't use alpha here\n        idx = np.argmax(rgb)\n        val = rgb[idx]\n        c = val - np.min(rgb)\n        if c == 0:\n            hue = 0\n            sat = 0\n        else:\n            if idx == 0:  # R == max\n                hue = ((rgb[1] - rgb[2]) / c) % 6\n            elif idx == 1:  # G == max\n                hue = (rgb[2] - rgb[0]) / c + 2\n            else:  # B == max\n                hue = (rgb[0] - rgb[1]) / c + 4\n            hue *= 60\n            sat = c / val\n        hsv = [hue, sat, val]\n        hsvs.append(hsv)\n    hsvs = np.array(hsvs, dtype=np.float32)\n    if n_dim == 4:\n        hsvs = np.concatenate((hsvs, rgbs[:, 3]), axis=1)\n    return hsvs",
  "def _hsv_to_rgb(hsvs):\n    \"\"\"Convert Nx3 or Nx4 hsv to rgb\"\"\"\n    hsvs, n_dim = _check_color_dim(hsvs)\n    # In principle, we *might* be able to vectorize this, but might as well\n    # wait until a compelling use case appears\n    rgbs = list()\n    for hsv in hsvs:\n        c = hsv[1] * hsv[2]\n        m = hsv[2] - c\n        hp = hsv[0] / 60\n        x = c * (1 - abs(hp % 2 - 1))\n        if 0 <= hp < 1:\n            r, g, b = c, x, 0\n        elif hp < 2:\n            r, g, b = x, c, 0\n        elif hp < 3:\n            r, g, b = 0, c, x\n        elif hp < 4:\n            r, g, b = 0, x, c\n        elif hp < 5:\n            r, g, b = x, 0, c\n        else:\n            r, g, b = c, 0, x\n        rgb = [r + m, g + m, b + m]\n        rgbs.append(rgb)\n    rgbs = np.array(rgbs, dtype=np.float32)\n    if n_dim == 4:\n        rgbs = np.concatenate((rgbs, hsvs[:, 3]), axis=1)\n    return rgbs",
  "def _rgb_to_lab(rgbs):\n    rgbs, n_dim = _check_color_dim(rgbs)\n    # convert RGB->XYZ\n    xyz = rgbs[:, :3].copy()  # a misnomer for now but will end up being XYZ\n    over = xyz > 0.04045\n    xyz[over] = ((xyz[over] + 0.055) / 1.055) ** 2.4\n    xyz[~over] /= 12.92\n    xyz = np.dot(xyz, _rgb2xyz_norm)\n    over = xyz > 0.008856\n    xyz[over] = xyz[over] ** (1. / 3.)\n    xyz[~over] = 7.787 * xyz[~over] + 0.13793103448275862\n\n    # Convert XYZ->LAB\n    L = (116. * xyz[:, 1]) - 16\n    a = 500 * (xyz[:, 0] - xyz[:, 1])\n    b = 200 * (xyz[:, 1] - xyz[:, 2])\n    labs = [L, a, b]\n    # Append alpha if necessary\n    if n_dim == 4:\n        labs.append(np.atleast1d(rgbs[:, 3]))\n    labs = np.array(labs, order='F').T  # Becomes 'C' order b/c of .T\n    return labs",
  "def _lab_to_rgb(labs):\n    \"\"\"Convert Nx3 or Nx4 lab to rgb\"\"\"\n    # adapted from BSD-licensed work in MATLAB by Mark Ruzon\n    # Based on ITU-R Recommendation BT.709 using the D65\n    labs, n_dim = _check_color_dim(labs)\n\n    # Convert Lab->XYZ (silly indexing used to preserve dimensionality)\n    y = (labs[:, 0] + 16.) / 116.\n    x = (labs[:, 1] / 500.) + y\n    z = y - (labs[:, 2] / 200.)\n    xyz = np.concatenate(([x], [y], [z]))  # 3xN\n    over = xyz > 0.2068966\n    xyz[over] = xyz[over] ** 3.\n    xyz[~over] = (xyz[~over] - 0.13793103448275862) / 7.787\n\n    # Convert XYZ->LAB\n    rgbs = np.dot(_xyz2rgb_norm, xyz).T\n    over = rgbs > 0.0031308\n    rgbs[over] = 1.055 * (rgbs[over] ** (1. / 2.4)) - 0.055\n    rgbs[~over] *= 12.92\n    if n_dim == 4:\n        rgbs = np.concatenate((rgbs, labs[:, 3]), axis=1)\n    rgbs = np.clip(rgbs, 0., 1.)\n    return rgbs",
  "def get_color_names():\n    \"\"\"Get the known color names\n\n    Returns\n    -------\n    names : list\n        List of color names known by Vispy.\n    \"\"\"\n    names = sorted(_color_dict.keys())\n    return names",
  "def get_color_dict():\n    \"\"\"Get the known colors\n\n    Returns\n    -------\n    color_dict : dict\n        Dict of colors known by Vispy {name: #rgb}.\n    \"\"\"\n    return _color_dict.copy()",
  "def _string_to_rgb(color):\n    \"\"\"Convert user string or hex color to color array (length 3 or 4)\"\"\"\n    if not color.startswith('#'):\n        if color.lower() not in _color_dict:\n            raise ValueError('Color \"%s\" unknown' % color)\n        color = _color_dict[color]\n        assert color[0] == '#'\n    # hex color\n    color = color[1:]\n    lc = len(color)\n    if lc in (3, 4):\n        color = ''.join(c + c for c in color)\n        lc = len(color)\n    if lc not in (6, 8):\n        raise ValueError('Hex color must have exactly six or eight '\n                         'elements following the # sign')\n    color = np.array([int(color[i:i+2], 16) / 255. for i in range(0, lc, 2)])\n    return color",
  "def _user_to_rgba(color, expand=True, clip=False):\n    \"\"\"Convert color(s) from any set of fmts (str/hex/arr) to RGB(A) array\"\"\"\n    if color is None:\n        color = np.zeros(4, np.float32)\n    if isinstance(color, str):\n        color = _string_to_rgb(color)\n    elif isinstance(color, ColorArray):\n        color = color.rgba\n    # We have to treat this specially\n    elif isinstance(color, (list, tuple)):\n        if any(isinstance(c, (str, ColorArray)) for c in color):\n            color = [_user_to_rgba(c, expand=expand, clip=clip) for c in color]\n            if any(len(c) > 1 for c in color):\n                raise RuntimeError('could not parse colors, are they nested?')\n            color = [c[0] for c in color]\n    color = np.atleast_2d(color).astype(np.float32)\n    if color.shape[1] not in (3, 4):\n        raise ValueError('color must have three or four elements')\n    if expand and color.shape[1] == 3:  # only expand if requested\n        color = np.concatenate((color, np.ones((color.shape[0], 1))),\n                               axis=1)\n    if color.min() < 0 or color.max() > 1:\n        if clip:\n            color = np.clip(color, 0, 1)\n        else:\n            raise ValueError(\"Color values must be between 0 and 1 (or use \"\n                             \"clip=True to automatically clip the values).\")\n    return color",
  "def _array_clip_val(val):\n    \"\"\"Helper to turn val into array and clip between 0 and 1\"\"\"\n    val = np.array(val)\n    if val.max() > 1 or val.min() < 0:\n        logger.warning('value will be clipped between 0 and 1')\n    val[...] = np.clip(val, 0, 1)\n    return val",
  "class ColorArray(object):\n    \"\"\"An array of colors\n\n    Parameters\n    ----------\n    color : str | tuple | list of colors\n        If str, can be any of the names in ``vispy.color.get_color_names``.\n        Can also be a hex value if it starts with ``'#'`` as ``'#ff0000'``.\n        If array-like, it must be an Nx3 or Nx4 array-like object.\n        Can also be a list of colors, such as\n        ``['red', '#00ff00', ColorArray('blue')]``.\n    alpha : float | None\n        If no alpha is not supplied in ``color`` entry and ``alpha`` is None,\n        then this will default to 1.0 (opaque). If float, it will override\n        any alpha values in ``color``, if provided.\n    clip : bool\n        Clip the color value.\n    color_space : 'rgb' | 'hsv'\n       'rgb' (default) : color tuples are interpreted as (r, g, b) components.\n       'hsv' : color tuples are interpreted as (h, s, v) components.\n\n    Examples\n    --------\n    There are many ways to define colors. Here are some basic cases:\n\n        >>> from vispy.color import ColorArray\n        >>> r = ColorArray('red')  # using string name\n        >>> r\n        <ColorArray: 1 color ((1.0, 0.0, 0.0, 1.0))>\n        >>> g = ColorArray((0, 1, 0, 1))  # RGBA tuple\n        >>> b = ColorArray('#0000ff')  # hex color\n        >>> w = ColorArray()  # defaults to black\n        >>> w.rgb = r.rgb + g.rgb + b.rgb\n        >>>hsv_color = ColorArray(color_space=\"hsv\", color=(0, 0, 0.5))\n        >>>hsv_color\n        <ColorArray: 1 color ((0.5, 0.5, 0.5, 1.0))>\n        >>> w == ColorArray('white')\n        True\n        >>> w.alpha = 0\n        >>> w\n        <ColorArray: 1 color ((1.0, 1.0, 1.0, 0.0))>\n        >>> rgb = ColorArray(['r', (0, 1, 0), '#0000FFFF'])\n        >>> rgb\n        <ColorArray: 3 colors ((1.0, 0.0, 0.0, 1.0) ... (1.0, 0.0, 0.0, 1.0))>\n        >>> rgb == ColorArray(['red', '#00ff00', ColorArray('blue')])\n        True\n\n    Notes\n    -----\n    Under the hood, this class stores data in RGBA format suitable for use\n    on the GPU.\n    \"\"\"\n\n    def __init__(self, color=(0., 0., 0.), alpha=None,\n                 clip=False, color_space='rgb'):\n\n        # if color is RGB, then set the default color to black\n        color = (0,) * 4 if color is None else color\n        if color_space == 'hsv':\n            # if the color space is hsv, convert hsv to rgb\n            color = _hsv_to_rgb(color)\n        elif color_space != 'rgb':\n            raise ValueError('color_space should be either \"rgb\" or'\n                             '\"hsv\", it is ' + color_space)\n\n        # Parse input type, and set attribute\"\"\"\n        rgba = _user_to_rgba(color, clip=clip)\n\n        if alpha is not None:\n            rgba[:, 3] = alpha\n        self._rgba = None\n        self.rgba = rgba\n\n    ###########################################################################\n    # Builtins and utilities\n    def copy(self):\n        \"\"\"Return a copy\"\"\"\n        return deepcopy(self)\n\n    @classmethod\n    def _name(cls):\n        \"\"\"Helper to get the class name once it's been created\"\"\"\n        return cls.__name__\n\n    def __len__(self):\n        return self._rgba.shape[0]\n\n    def __repr__(self):\n        nice_str = str(tuple(self._rgba[0]))\n        plural = ''\n        if len(self) > 1:\n            plural = 's'\n            nice_str += ' ... ' + str(tuple(self.rgba[-1]))\n        # use self._name() here instead of hard-coding name in case\n        # we eventually subclass this class\n        return ('<%s: %i color%s (%s)>' % (self._name(), len(self),\n                                           plural, nice_str))\n\n    def __eq__(self, other):\n        return np.array_equal(self._rgba, other._rgba)\n\n    ###########################################################################\n    def __getitem__(self, item):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        subrgba = self._rgba[item]\n        if subrgba.ndim == 1:\n            assert len(subrgba) == 4\n        elif subrgba.ndim == 2:\n            assert subrgba.shape[1] in (3, 4)\n        return ColorArray(subrgba)\n\n    def __setitem__(self, item, value):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        # value should be a RGBA array, or a ColorArray instance\n        if isinstance(value, ColorArray):\n            value = value.rgba\n        self._rgba[item] = value\n\n    def extend(self, colors):\n        \"\"\"Extend a ColorArray with new colors\n\n        Parameters\n        ----------\n        colors : instance of ColorArray\n            The new colors.\n        \"\"\"\n        colors = ColorArray(colors)\n        self._rgba = np.vstack((self._rgba, colors._rgba))\n        return self\n\n    # RGB(A)\n    @property\n    def rgba(self):\n        \"\"\"Nx4 array of RGBA floats\"\"\"\n        return self._rgba.copy()\n\n    @rgba.setter\n    def rgba(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA floats\"\"\"\n        # Note: all other attribute sets get routed here!\n        # This method is meant to do the heavy lifting of setting data\n        rgba = _user_to_rgba(val, expand=False)\n        if self._rgba is None:\n            self._rgba = rgba  # only on init\n        else:\n            self._rgba[:, :rgba.shape[1]] = rgba\n\n    @property\n    def rgb(self):\n        \"\"\"Nx3 array of RGB floats\"\"\"\n        return self._rgba[:, :3].copy()\n\n    @rgb.setter\n    def rgb(self, val):\n        \"\"\"Set the color using an Nx3 array of RGB floats\"\"\"\n        self.rgba = val\n\n    @property\n    def RGBA(self):\n        \"\"\"Nx4 array of RGBA uint8s\"\"\"\n        return (self._rgba * 255).astype(np.uint8)\n\n    @RGBA.setter\n    def RGBA(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255\n        self.rgba = val\n\n    @property\n    def RGB(self):\n        \"\"\"Nx3 array of RGBA uint8s\"\"\"\n        return np.round(self._rgba[:, :3] * 255).astype(int)\n\n    @RGB.setter\n    def RGB(self, val):\n        \"\"\"Set the color using an Nx3 array of RGB uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255.\n        self.rgba = val\n\n    @property\n    def alpha(self):\n        \"\"\"Length-N array of alpha floats\"\"\"\n        return self._rgba[:, 3]\n\n    @alpha.setter\n    def alpha(self, val):\n        \"\"\"Set the color using alpha\"\"\"\n        self._rgba[:, 3] = _array_clip_val(val)\n\n    ###########################################################################\n    # HEX\n    @property\n    def hex(self):\n        \"\"\"Numpy array with N elements, each one a hex triplet string\"\"\"\n        return _rgb_to_hex(self._rgba)\n\n    @hex.setter\n    def hex(self, val):\n        \"\"\"Set the color values using a list of hex strings\"\"\"\n        self.rgba = _hex_to_rgba(val)\n\n    ###########################################################################\n    # HSV\n    @property\n    def hsv(self):\n        \"\"\"Nx3 array of HSV floats\"\"\"\n        return self._hsv\n\n    @hsv.setter\n    def hsv(self, val):\n        \"\"\"Set the color values using an Nx3 array of HSV floats\"\"\"\n        self.rgba = _hsv_to_rgb(val)\n\n    @property\n    def _hsv(self):\n        \"\"\"Nx3 array of HSV floats\"\"\"\n        # this is done privately so that overriding functions work\n        return _rgb_to_hsv(self._rgba[:, :3])\n\n    @property\n    def value(self):\n        \"\"\"Length-N array of color HSV values\"\"\"\n        return self._hsv[:, 2]\n\n    @value.setter\n    def value(self, val):\n        \"\"\"Set the color using length-N array of (from HSV)\"\"\"\n        hsv = self._hsv\n        hsv[:, 2] = _array_clip_val(val)\n        self.rgba = _hsv_to_rgb(hsv)\n\n    def lighter(self, dv=0.1, copy=True):\n        \"\"\"Produce a lighter color (if possible)\n\n        Parameters\n        ----------\n        dv : float\n            Amount to increase the color value by.\n        copy : bool\n            If False, operation will be carried out in-place.\n\n        Returns\n        -------\n        color : instance of ColorArray\n            The lightened Color.\n        \"\"\"\n        color = self.copy() if copy else self\n        color.value += dv\n        return color\n\n    def darker(self, dv=0.1, copy=True):\n        \"\"\"Produce a darker color (if possible)\n\n        Parameters\n        ----------\n        dv : float\n            Amount to decrease the color value by.\n        copy : bool\n            If False, operation will be carried out in-place.\n\n        Returns\n        -------\n        color : instance of ColorArray\n            The darkened Color.\n        \"\"\"\n        color = self.copy() if copy else self\n        color.value -= dv\n        return color\n\n    ###########################################################################\n    # Lab\n    @property\n    def lab(self):\n        return _rgb_to_lab(self._rgba[:, :3])\n\n    @lab.setter\n    def lab(self, val):\n        self.rgba = _lab_to_rgb(val)",
  "class Color(ColorArray):\n    \"\"\"A single color\n\n    Parameters\n    ----------\n    color : str | tuple\n        If str, can be any of the names in ``vispy.color.get_color_names``.\n        Can also be a hex value if it starts with ``'#'`` as ``'#ff0000'``.\n        If array-like, it must be an 1-dimensional array with 3 or 4 elements.\n    alpha : float | None\n        If no alpha is not supplied in ``color`` entry and ``alpha`` is None,\n        then this will default to 1.0 (opaque). If float, it will override\n        the alpha value in ``color``, if provided.\n    clip : bool\n        If True, clip the color values.\n    \"\"\"\n\n    def __init__(self, color='black', alpha=None, clip=False):\n        \"\"\"Parse input type, and set attribute\"\"\"\n        if isinstance(color, (list, tuple)):\n            color = np.array(color, np.float32)\n        rgba = _user_to_rgba(color, clip=clip)\n        if rgba.shape[0] != 1:\n            raise ValueError('color must be of correct shape')\n        if alpha is not None:\n            rgba[:, 3] = alpha\n        self._rgba = None\n        self.rgba = rgba.ravel()\n\n    @ColorArray.rgba.getter\n    def rgba(self):\n        return super(Color, self).rgba[0]\n\n    @ColorArray.rgb.getter\n    def rgb(self):\n        return super(Color, self).rgb[0]\n\n    @ColorArray.RGBA.getter\n    def RGBA(self):\n        return super(Color, self).RGBA[0]\n\n    @ColorArray.RGB.getter\n    def RGB(self):\n        return super(Color, self).RGB[0]\n\n    @ColorArray.alpha.getter\n    def alpha(self):\n        return super(Color, self).alpha[0]\n\n    @ColorArray.hex.getter\n    def hex(self):\n        return super(Color, self).hex[0]\n\n    @ColorArray.hsv.getter\n    def hsv(self):\n        return super(Color, self).hsv[0]\n\n    @ColorArray.value.getter\n    def value(self):\n        return super(Color, self).value[0]\n\n    @ColorArray.lab.getter\n    def lab(self):\n        return super(Color, self).lab[0]\n\n    @property\n    def is_blank(self):\n        \"\"\"Boolean indicating whether the color is invisible.\"\"\"\n        return self.rgba[3] == 0\n\n    def __repr__(self):\n        nice_str = str(tuple(self._rgba[0]))\n        return ('<%s: %s>' % (self._name(), nice_str))",
  "def __init__(self, color=(0., 0., 0.), alpha=None,\n                 clip=False, color_space='rgb'):\n\n        # if color is RGB, then set the default color to black\n        color = (0,) * 4 if color is None else color\n        if color_space == 'hsv':\n            # if the color space is hsv, convert hsv to rgb\n            color = _hsv_to_rgb(color)\n        elif color_space != 'rgb':\n            raise ValueError('color_space should be either \"rgb\" or'\n                             '\"hsv\", it is ' + color_space)\n\n        # Parse input type, and set attribute\"\"\"\n        rgba = _user_to_rgba(color, clip=clip)\n\n        if alpha is not None:\n            rgba[:, 3] = alpha\n        self._rgba = None\n        self.rgba = rgba",
  "def copy(self):\n        \"\"\"Return a copy\"\"\"\n        return deepcopy(self)",
  "def _name(cls):\n        \"\"\"Helper to get the class name once it's been created\"\"\"\n        return cls.__name__",
  "def __len__(self):\n        return self._rgba.shape[0]",
  "def __repr__(self):\n        nice_str = str(tuple(self._rgba[0]))\n        plural = ''\n        if len(self) > 1:\n            plural = 's'\n            nice_str += ' ... ' + str(tuple(self.rgba[-1]))\n        # use self._name() here instead of hard-coding name in case\n        # we eventually subclass this class\n        return ('<%s: %i color%s (%s)>' % (self._name(), len(self),\n                                           plural, nice_str))",
  "def __eq__(self, other):\n        return np.array_equal(self._rgba, other._rgba)",
  "def __getitem__(self, item):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        subrgba = self._rgba[item]\n        if subrgba.ndim == 1:\n            assert len(subrgba) == 4\n        elif subrgba.ndim == 2:\n            assert subrgba.shape[1] in (3, 4)\n        return ColorArray(subrgba)",
  "def __setitem__(self, item, value):\n        if isinstance(item, tuple):\n            raise ValueError('ColorArray indexing is only allowed along '\n                             'the first dimension.')\n        # value should be a RGBA array, or a ColorArray instance\n        if isinstance(value, ColorArray):\n            value = value.rgba\n        self._rgba[item] = value",
  "def extend(self, colors):\n        \"\"\"Extend a ColorArray with new colors\n\n        Parameters\n        ----------\n        colors : instance of ColorArray\n            The new colors.\n        \"\"\"\n        colors = ColorArray(colors)\n        self._rgba = np.vstack((self._rgba, colors._rgba))\n        return self",
  "def rgba(self):\n        \"\"\"Nx4 array of RGBA floats\"\"\"\n        return self._rgba.copy()",
  "def rgba(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA floats\"\"\"\n        # Note: all other attribute sets get routed here!\n        # This method is meant to do the heavy lifting of setting data\n        rgba = _user_to_rgba(val, expand=False)\n        if self._rgba is None:\n            self._rgba = rgba  # only on init\n        else:\n            self._rgba[:, :rgba.shape[1]] = rgba",
  "def rgb(self):\n        \"\"\"Nx3 array of RGB floats\"\"\"\n        return self._rgba[:, :3].copy()",
  "def rgb(self, val):\n        \"\"\"Set the color using an Nx3 array of RGB floats\"\"\"\n        self.rgba = val",
  "def RGBA(self):\n        \"\"\"Nx4 array of RGBA uint8s\"\"\"\n        return (self._rgba * 255).astype(np.uint8)",
  "def RGBA(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255\n        self.rgba = val",
  "def RGB(self):\n        \"\"\"Nx3 array of RGBA uint8s\"\"\"\n        return np.round(self._rgba[:, :3] * 255).astype(int)",
  "def RGB(self, val):\n        \"\"\"Set the color using an Nx3 array of RGB uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255.\n        self.rgba = val",
  "def alpha(self):\n        \"\"\"Length-N array of alpha floats\"\"\"\n        return self._rgba[:, 3]",
  "def alpha(self, val):\n        \"\"\"Set the color using alpha\"\"\"\n        self._rgba[:, 3] = _array_clip_val(val)",
  "def hex(self):\n        \"\"\"Numpy array with N elements, each one a hex triplet string\"\"\"\n        return _rgb_to_hex(self._rgba)",
  "def hex(self, val):\n        \"\"\"Set the color values using a list of hex strings\"\"\"\n        self.rgba = _hex_to_rgba(val)",
  "def hsv(self):\n        \"\"\"Nx3 array of HSV floats\"\"\"\n        return self._hsv",
  "def hsv(self, val):\n        \"\"\"Set the color values using an Nx3 array of HSV floats\"\"\"\n        self.rgba = _hsv_to_rgb(val)",
  "def _hsv(self):\n        \"\"\"Nx3 array of HSV floats\"\"\"\n        # this is done privately so that overriding functions work\n        return _rgb_to_hsv(self._rgba[:, :3])",
  "def value(self):\n        \"\"\"Length-N array of color HSV values\"\"\"\n        return self._hsv[:, 2]",
  "def value(self, val):\n        \"\"\"Set the color using length-N array of (from HSV)\"\"\"\n        hsv = self._hsv\n        hsv[:, 2] = _array_clip_val(val)\n        self.rgba = _hsv_to_rgb(hsv)",
  "def lighter(self, dv=0.1, copy=True):\n        \"\"\"Produce a lighter color (if possible)\n\n        Parameters\n        ----------\n        dv : float\n            Amount to increase the color value by.\n        copy : bool\n            If False, operation will be carried out in-place.\n\n        Returns\n        -------\n        color : instance of ColorArray\n            The lightened Color.\n        \"\"\"\n        color = self.copy() if copy else self\n        color.value += dv\n        return color",
  "def darker(self, dv=0.1, copy=True):\n        \"\"\"Produce a darker color (if possible)\n\n        Parameters\n        ----------\n        dv : float\n            Amount to decrease the color value by.\n        copy : bool\n            If False, operation will be carried out in-place.\n\n        Returns\n        -------\n        color : instance of ColorArray\n            The darkened Color.\n        \"\"\"\n        color = self.copy() if copy else self\n        color.value -= dv\n        return color",
  "def lab(self):\n        return _rgb_to_lab(self._rgba[:, :3])",
  "def lab(self, val):\n        self.rgba = _lab_to_rgb(val)",
  "def __init__(self, color='black', alpha=None, clip=False):\n        \"\"\"Parse input type, and set attribute\"\"\"\n        if isinstance(color, (list, tuple)):\n            color = np.array(color, np.float32)\n        rgba = _user_to_rgba(color, clip=clip)\n        if rgba.shape[0] != 1:\n            raise ValueError('color must be of correct shape')\n        if alpha is not None:\n            rgba[:, 3] = alpha\n        self._rgba = None\n        self.rgba = rgba.ravel()",
  "def rgba(self):\n        return super(Color, self).rgba[0]",
  "def rgb(self):\n        return super(Color, self).rgb[0]",
  "def RGBA(self):\n        return super(Color, self).RGBA[0]",
  "def RGB(self):\n        return super(Color, self).RGB[0]",
  "def alpha(self):\n        return super(Color, self).alpha[0]",
  "def hex(self):\n        return super(Color, self).hex[0]",
  "def hsv(self):\n        return super(Color, self).hsv[0]",
  "def value(self):\n        return super(Color, self).value[0]",
  "def lab(self):\n        return super(Color, self).lab[0]",
  "def is_blank(self):\n        \"\"\"Boolean indicating whether the color is invisible.\"\"\"\n        return self.rgba[3] == 0",
  "def __repr__(self):\n        nice_str = str(tuple(self._rgba[0]))\n        return ('<%s: %s>' % (self._name(), nice_str))",
  "class BaseApplicationBackend(object):\n    \"\"\"BaseApplicationBackend()\n\n    Abstract class that provides an interface between backends and Application.\n    Each backend must implement a subclass of ApplicationBackend, and\n    implement all its _vispy_xxx methods.\n    \"\"\"\n\n    def _vispy_get_backend_name(self):\n        raise NotImplementedError()\n\n    def _vispy_process_events(self):\n        raise NotImplementedError()\n\n    def _vispy_run(self):\n        raise NotImplementedError()\n\n    def _vispy_reuse(self):\n        # Does nothing by default.\n        pass\n\n    def _vispy_quit(self):\n        raise NotImplementedError()\n\n    def _vispy_get_native_app(self):\n        # Should return the native application object\n        return self\n\n    # is called by inputhook.py for pauses\n    # to remove CPU stress\n    # this is virtual so that some backends which have specialize\n    # functionality to deal with user input / latency can use those methods\n    def _vispy_sleep(self, duration_sec):\n        time.sleep(duration_sec)",
  "class BaseCanvasBackend(object):\n    \"\"\"BaseCanvasBackend(vispy_canvas, capability, context_type)\n\n    Abstract class that provides an interface between backends and Canvas.\n    Each backend must implement a subclass of CanvasBackend, and\n    implement all its _vispy_xxx methods. Also, a backend must\n    make sure to generate the following events: 'initialize', 'resize',\n    'draw', 'mouse_press', 'mouse_release', 'mouse_move',\n    'mouse_wheel', 'key_press', 'key_release'. When a backend detects\n    that the canvas should be closed, the backend should call\n    'self._vispy_canvas.close', because the close event is handled within\n    the canvas itself.\n    \"\"\"\n\n    def __init__(self, vispy_canvas):\n        # Note: it is the responsibility of the subclass to call\n        # the __init__ of the mro - we don't call super().__init__() here.\n\n        from .canvas import Canvas  # Avoid circular import\n        assert isinstance(vispy_canvas, Canvas)\n        self._vispy_canvas = vispy_canvas\n        self._last_time = 0\n\n        # We set the _backend attribute of the vispy_canvas to self,\n        # because at the end of the __init__ of the CanvasBackend\n        # implementation there might be a call to show or draw. By\n        # setting it here, we ensure that the Canvas is \"ready to go\".\n        vispy_canvas._backend = self\n\n        # Data used in the construction of new mouse events\n        self._vispy_mouse_data = {\n            'buttons': [],\n            'press_event': None,\n            'last_event': None,\n            'last_mouse_press': None,\n        }\n\n    def _process_backend_kwargs(self, kwargs):\n        \"\"\"Simple utility to retrieve kwargs in predetermined order.\n        Also checks whether the values of the backend arguments do not\n        violate the backend capabilities.\n        \"\"\"\n        # Verify given argument with capability of the backend\n        app = self._vispy_canvas.app\n        capability = app.backend_module.capability\n        if kwargs['context'].shared.name:  # name already assigned: shared\n            if not capability['context']:\n                raise RuntimeError('Cannot share context with this backend')\n        for key in [key for (key, val) in capability.items() if not val]:\n            if key in ['context', 'multi_window', 'scroll']:\n                continue\n            invert = key in ['resizable', 'decorate']\n            if bool(kwargs[key]) - invert:\n                raise RuntimeError('Config %s is not supported by backend %s'\n                                   % (key, app.backend_name))\n\n        # Return items in sequence\n        out = SimpleBunch()\n        keys = ['title', 'size', 'position', 'show', 'vsync', 'resizable',\n                'decorate', 'fullscreen', 'parent', 'context', 'always_on_top',\n                ]\n        for key in keys:\n            out[key] = kwargs[key]\n        return out\n\n    def _vispy_set_current(self):\n        # Make this the current context\n        raise NotImplementedError()\n\n    def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        raise NotImplementedError()\n\n    def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        raise NotImplementedError()\n\n    def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        raise NotImplementedError()\n\n    def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        raise NotImplementedError()\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        raise NotImplementedError()\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        # Set fullscreen mode\n        raise NotImplementedError()\n\n    def _vispy_update(self):\n        # Invoke a redraw\n        raise NotImplementedError()\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        raise NotImplementedError()\n\n    def _vispy_get_size(self):\n        # Should return widget size\n        raise NotImplementedError()\n\n    def _vispy_get_physical_size(self):\n        # Should return physical widget size (actual number of screen pixels).\n        # This may differ from _vispy_get_size on backends that expose HiDPI\n        # screens. If not overriden, return the logical sizeself.\n        return self._vispy_get_size()\n\n    def _vispy_get_position(self):\n        # Should return widget position\n        raise NotImplementedError()\n\n    def _vispy_get_fullscreen(self):\n        # Should return bool for fullscreen status\n        raise NotImplementedError()\n\n    def _vispy_get_geometry(self):\n        # Should return widget (x, y, w, h)\n        x, y = self._vispy_get_position()\n        w, h = self._vispy_get_size()\n        return x, y, w, h\n\n    def _vispy_get_native_canvas(self):\n        # Should return the native widget object\n        # Most backends would not need to implement this\n        return self\n\n    def _vispy_get_fb_bind_location(self):\n        # Should return the default FrameBuffer bind location\n        # Most backends would not need to implement this\n        return 0\n\n    def _vispy_mouse_press(self, **kwargs):\n        # default method for delivering mouse press events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n        ev = self._vispy_canvas.events.mouse_press(**kwargs)\n        if self._vispy_mouse_data['press_event'] is None:\n            self._vispy_mouse_data['press_event'] = ev\n\n        self._vispy_mouse_data['buttons'].append(ev.button)\n        self._vispy_mouse_data['last_event'] = ev\n\n        if not getattr(self, '_double_click_supported', False):\n            # double-click events are not supported by this backend, so we\n            # detect them manually\n            self._vispy_detect_double_click(ev)\n\n        return ev\n\n    def _vispy_mouse_move(self, **kwargs):\n        if default_timer() - self._last_time < .01:\n            return\n        self._last_time = default_timer()\n\n        # default method for delivering mouse move events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        # Break the chain of prior mouse events if no buttons are pressed\n        # (this means that during a mouse drag, we have full access to every\n        # move event generated since the drag started)\n        if self._vispy_mouse_data['press_event'] is None:\n            last_event = self._vispy_mouse_data['last_event']\n            if last_event is not None:\n                last_event._forget_last_event()\n        else:\n            kwargs['button'] = self._vispy_mouse_data['press_event'].button\n\n        ev = self._vispy_canvas.events.mouse_move(**kwargs)\n        self._vispy_mouse_data['last_event'] = ev\n        return ev\n\n    def _vispy_mouse_release(self, **kwargs):\n        # default method for delivering mouse release events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        ev = self._vispy_canvas.events.mouse_release(**kwargs)\n        if (self._vispy_mouse_data['press_event']\n                and self._vispy_mouse_data['press_event'].button == ev.button):\n            self._vispy_mouse_data['press_event'] = None\n\n        if ev.button in self._vispy_mouse_data['buttons']:\n            self._vispy_mouse_data['buttons'].remove(ev.button)\n        self._vispy_mouse_data['last_event'] = ev\n\n        return ev\n\n    def _vispy_mouse_double_click(self, **kwargs):\n        # default method for delivering double-click events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        ev = self._vispy_canvas.events.mouse_double_click(**kwargs)\n        self._vispy_mouse_data['last_event'] = ev\n        return ev\n\n    def _vispy_detect_double_click(self, ev, **kwargs):\n        # Called on every mouse_press or mouse_release, and calls\n        # _vispy_mouse_double_click if a double-click is calculated.\n        # Should be overridden with an empty function on backends which\n        # natively support double-clicking.\n\n        dt_max = 0.3  # time in seconds for a double-click detection\n\n        lastev = self._vispy_mouse_data['last_mouse_press']\n\n        if lastev is None:\n            self._vispy_mouse_data['last_mouse_press'] = ev\n            return\n\n        assert lastev.type == 'mouse_press'\n        assert ev.type == 'mouse_press'\n\n        # For a double-click to be detected, the button should be the same,\n        # the position should be the same, and the two mouse-presses should\n        # be within dt_max.\n        if ((ev.time - lastev.time <= dt_max) &\n            (lastev.pos[0] - ev.pos[0] == 0) &\n            (lastev.pos[1] - ev.pos[1] == 0) &\n                (lastev.button == ev.button)):\n            self._vispy_mouse_double_click(**kwargs)\n\n        self._vispy_mouse_data['last_mouse_press'] = ev",
  "class BaseTimerBackend(object):\n    \"\"\"BaseTimerBackend(vispy_timer)\n\n    Abstract class that provides an interface between backends and Timer.\n    Each backend must implement a subclass of TimerBackend, and\n    implement all its _vispy_xxx methods.\n    \"\"\"\n\n    def __init__(self, vispy_timer):\n        # Note: it is the responsibility of the subclass to call\n        # the __init__ of the mro - we don't call super().__init__() here.\n        self._vispy_timer = vispy_timer\n\n    def _vispy_start(self, interval):\n        raise NotImplementedError\n\n    def _vispy_stop(self):\n        raise NotImplementedError\n\n    def _vispy_get_native_timer(self):\n        # Should return the native timer object\n        # Most backends would not need to implement this\n        return self",
  "def _vispy_get_backend_name(self):\n        raise NotImplementedError()",
  "def _vispy_process_events(self):\n        raise NotImplementedError()",
  "def _vispy_run(self):\n        raise NotImplementedError()",
  "def _vispy_reuse(self):\n        # Does nothing by default.\n        pass",
  "def _vispy_quit(self):\n        raise NotImplementedError()",
  "def _vispy_get_native_app(self):\n        # Should return the native application object\n        return self",
  "def _vispy_sleep(self, duration_sec):\n        time.sleep(duration_sec)",
  "def __init__(self, vispy_canvas):\n        # Note: it is the responsibility of the subclass to call\n        # the __init__ of the mro - we don't call super().__init__() here.\n\n        from .canvas import Canvas  # Avoid circular import\n        assert isinstance(vispy_canvas, Canvas)\n        self._vispy_canvas = vispy_canvas\n        self._last_time = 0\n\n        # We set the _backend attribute of the vispy_canvas to self,\n        # because at the end of the __init__ of the CanvasBackend\n        # implementation there might be a call to show or draw. By\n        # setting it here, we ensure that the Canvas is \"ready to go\".\n        vispy_canvas._backend = self\n\n        # Data used in the construction of new mouse events\n        self._vispy_mouse_data = {\n            'buttons': [],\n            'press_event': None,\n            'last_event': None,\n            'last_mouse_press': None,\n        }",
  "def _process_backend_kwargs(self, kwargs):\n        \"\"\"Simple utility to retrieve kwargs in predetermined order.\n        Also checks whether the values of the backend arguments do not\n        violate the backend capabilities.\n        \"\"\"\n        # Verify given argument with capability of the backend\n        app = self._vispy_canvas.app\n        capability = app.backend_module.capability\n        if kwargs['context'].shared.name:  # name already assigned: shared\n            if not capability['context']:\n                raise RuntimeError('Cannot share context with this backend')\n        for key in [key for (key, val) in capability.items() if not val]:\n            if key in ['context', 'multi_window', 'scroll']:\n                continue\n            invert = key in ['resizable', 'decorate']\n            if bool(kwargs[key]) - invert:\n                raise RuntimeError('Config %s is not supported by backend %s'\n                                   % (key, app.backend_name))\n\n        # Return items in sequence\n        out = SimpleBunch()\n        keys = ['title', 'size', 'position', 'show', 'vsync', 'resizable',\n                'decorate', 'fullscreen', 'parent', 'context', 'always_on_top',\n                ]\n        for key in keys:\n            out[key] = kwargs[key]\n        return out",
  "def _vispy_set_current(self):\n        # Make this the current context\n        raise NotImplementedError()",
  "def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        raise NotImplementedError()",
  "def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        raise NotImplementedError()",
  "def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        raise NotImplementedError()",
  "def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        raise NotImplementedError()",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        raise NotImplementedError()",
  "def _vispy_set_fullscreen(self, fullscreen):\n        # Set fullscreen mode\n        raise NotImplementedError()",
  "def _vispy_update(self):\n        # Invoke a redraw\n        raise NotImplementedError()",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        raise NotImplementedError()",
  "def _vispy_get_size(self):\n        # Should return widget size\n        raise NotImplementedError()",
  "def _vispy_get_physical_size(self):\n        # Should return physical widget size (actual number of screen pixels).\n        # This may differ from _vispy_get_size on backends that expose HiDPI\n        # screens. If not overriden, return the logical sizeself.\n        return self._vispy_get_size()",
  "def _vispy_get_position(self):\n        # Should return widget position\n        raise NotImplementedError()",
  "def _vispy_get_fullscreen(self):\n        # Should return bool for fullscreen status\n        raise NotImplementedError()",
  "def _vispy_get_geometry(self):\n        # Should return widget (x, y, w, h)\n        x, y = self._vispy_get_position()\n        w, h = self._vispy_get_size()\n        return x, y, w, h",
  "def _vispy_get_native_canvas(self):\n        # Should return the native widget object\n        # Most backends would not need to implement this\n        return self",
  "def _vispy_get_fb_bind_location(self):\n        # Should return the default FrameBuffer bind location\n        # Most backends would not need to implement this\n        return 0",
  "def _vispy_mouse_press(self, **kwargs):\n        # default method for delivering mouse press events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n        ev = self._vispy_canvas.events.mouse_press(**kwargs)\n        if self._vispy_mouse_data['press_event'] is None:\n            self._vispy_mouse_data['press_event'] = ev\n\n        self._vispy_mouse_data['buttons'].append(ev.button)\n        self._vispy_mouse_data['last_event'] = ev\n\n        if not getattr(self, '_double_click_supported', False):\n            # double-click events are not supported by this backend, so we\n            # detect them manually\n            self._vispy_detect_double_click(ev)\n\n        return ev",
  "def _vispy_mouse_move(self, **kwargs):\n        if default_timer() - self._last_time < .01:\n            return\n        self._last_time = default_timer()\n\n        # default method for delivering mouse move events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        # Break the chain of prior mouse events if no buttons are pressed\n        # (this means that during a mouse drag, we have full access to every\n        # move event generated since the drag started)\n        if self._vispy_mouse_data['press_event'] is None:\n            last_event = self._vispy_mouse_data['last_event']\n            if last_event is not None:\n                last_event._forget_last_event()\n        else:\n            kwargs['button'] = self._vispy_mouse_data['press_event'].button\n\n        ev = self._vispy_canvas.events.mouse_move(**kwargs)\n        self._vispy_mouse_data['last_event'] = ev\n        return ev",
  "def _vispy_mouse_release(self, **kwargs):\n        # default method for delivering mouse release events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        ev = self._vispy_canvas.events.mouse_release(**kwargs)\n        if (self._vispy_mouse_data['press_event']\n                and self._vispy_mouse_data['press_event'].button == ev.button):\n            self._vispy_mouse_data['press_event'] = None\n\n        if ev.button in self._vispy_mouse_data['buttons']:\n            self._vispy_mouse_data['buttons'].remove(ev.button)\n        self._vispy_mouse_data['last_event'] = ev\n\n        return ev",
  "def _vispy_mouse_double_click(self, **kwargs):\n        # default method for delivering double-click events to the canvas\n        kwargs.update(self._vispy_mouse_data)\n\n        ev = self._vispy_canvas.events.mouse_double_click(**kwargs)\n        self._vispy_mouse_data['last_event'] = ev\n        return ev",
  "def _vispy_detect_double_click(self, ev, **kwargs):\n        # Called on every mouse_press or mouse_release, and calls\n        # _vispy_mouse_double_click if a double-click is calculated.\n        # Should be overridden with an empty function on backends which\n        # natively support double-clicking.\n\n        dt_max = 0.3  # time in seconds for a double-click detection\n\n        lastev = self._vispy_mouse_data['last_mouse_press']\n\n        if lastev is None:\n            self._vispy_mouse_data['last_mouse_press'] = ev\n            return\n\n        assert lastev.type == 'mouse_press'\n        assert ev.type == 'mouse_press'\n\n        # For a double-click to be detected, the button should be the same,\n        # the position should be the same, and the two mouse-presses should\n        # be within dt_max.\n        if ((ev.time - lastev.time <= dt_max) &\n            (lastev.pos[0] - ev.pos[0] == 0) &\n            (lastev.pos[1] - ev.pos[1] == 0) &\n                (lastev.button == ev.button)):\n            self._vispy_mouse_double_click(**kwargs)\n\n        self._vispy_mouse_data['last_mouse_press'] = ev",
  "def __init__(self, vispy_timer):\n        # Note: it is the responsibility of the subclass to call\n        # the __init__ of the mro - we don't call super().__init__() here.\n        self._vispy_timer = vispy_timer",
  "def _vispy_start(self, interval):\n        raise NotImplementedError",
  "def _vispy_stop(self):\n        raise NotImplementedError",
  "def _vispy_get_native_timer(self):\n        # Should return the native timer object\n        # Most backends would not need to implement this\n        return self",
  "class Canvas(object):\n    \"\"\"Representation of a GUI element with an OpenGL context\n\n    Parameters\n    ----------\n    title : str\n        The widget title\n    size : (width, height)\n        The size of the window.\n    position : (x, y)\n        The position of the window in screen coordinates.\n    show : bool\n        Whether to show the widget immediately. Default False.\n    autoswap : bool\n        Whether to swap the buffers automatically after a draw event.\n        Default True. If True, the ``swap_buffers`` Canvas method will\n        be called last (by default) by the ``canvas.draw`` event handler.\n    app : Application | str\n        Give vispy Application instance to use as a backend.\n        (vispy.app is used by default.) If str, then an application\n        using the chosen backend (e.g., 'pyglet') will be created.\n        Note the canvas application can be accessed at ``canvas.app``.\n    create_native : bool\n        Whether to create the widget immediately. Default True.\n    vsync : bool\n        Enable vertical synchronization.\n    resizable : bool\n        Allow the window to be resized.\n    decorate : bool\n        Decorate the window. Default True.\n    fullscreen : bool | int\n        If False, windowed mode is used (default). If True, the default\n        monitor is used. If int, the given monitor number is used.\n    config : dict\n        A dict with OpenGL configuration options, which is combined\n        with the default configuration options and used to initialize\n        the context. See ``canvas.context.config`` for possible\n        options.\n    shared : Canvas | GLContext | None\n        An existing canvas or context to share OpenGL objects with.\n    keys : str | dict | None\n        Default key mapping to use. If 'interactive', escape and F11 will\n        close the canvas and toggle full-screen mode, respectively.\n        If dict, maps keys to functions. If dict values are strings,\n        they are assumed to be ``Canvas`` methods, otherwise they should\n        be callable.\n    parent : widget-object\n        The parent widget if this makes sense for the used backend.\n    dpi : float | None\n        Resolution in dots-per-inch to use for the canvas. If dpi is None,\n        then the value will be determined by querying the global config first,\n        and then the operating system.\n    always_on_top : bool\n        If True, try to create the window in always-on-top mode.\n    px_scale : int > 0\n        A scale factor to apply between logical and physical pixels in addition\n        to the actual scale factor determined by the backend. This option\n        allows the scale factor to be adjusted for testing.\n    backend_kwargs : dict\n        Keyword arguments to be supplied to the backend canvas object.\n\n    Notes\n    -----\n    The `Canvas` receives the following events:\n\n        * initialize\n        * resize\n        * draw\n        * mouse_press\n        * mouse_release\n        * mouse_double_click\n        * mouse_move\n        * mouse_wheel\n        * key_press\n        * key_release\n        * stylus\n        * touch\n        * close\n\n    The ordering of the mouse_double_click, mouse_press, and mouse_release\n    events are not guaranteed to be consistent between backends. Only certain\n    backends natively support double-clicking (currently Qt and WX); on other\n    backends, they are detected manually with a fixed time delay.\n    This can cause problems with accessibility, as increasing the OS detection\n    time or using a dedicated double-click button will not be respected.\n\n    Backend-specific arguments can be given through the `backend_kwargs`\n    argument.\n    \"\"\"\n\n    def __init__(self, title='VisPy canvas', size=(800, 600), position=None,\n                 show=False, autoswap=True, app=None, create_native=True,\n                 vsync=False, resizable=True, decorate=True, fullscreen=False,\n                 config=None, shared=None, keys=None, parent=None, dpi=None,\n                 always_on_top=False, px_scale=1, backend_kwargs=None):\n\n        size = tuple(int(s) * px_scale for s in size)\n        if len(size) != 2:\n            raise ValueError('size must be a 2-element list')\n        title = str(title)\n        if not isinstance(fullscreen, (bool, int)):\n            raise TypeError('fullscreen must be bool or int')\n\n        # Initialize some values\n        self._autoswap = autoswap\n        self._title = title\n        self._frame_count = 0\n        self._fps = 0\n        self._basetime = time()\n        self._fps_callback = None\n        self._backend = None\n        self._closed = False\n        self._fps_window = 0.\n        self._px_scale = int(px_scale)\n\n        if dpi is None:\n            dpi = util_config['dpi']\n        if dpi is None:\n            dpi = get_dpi(raise_error=False)\n        self.dpi = dpi\n\n        # Create events\n        self.events = EmitterGroup(source=self,\n                                   initialize=Event,\n                                   resize=ResizeEvent,\n                                   draw=DrawEvent,\n                                   mouse_press=MouseEvent,\n                                   mouse_release=MouseEvent,\n                                   mouse_double_click=MouseEvent,\n                                   mouse_move=MouseEvent,\n                                   mouse_wheel=MouseEvent,\n                                   key_press=KeyEvent,\n                                   key_release=KeyEvent,\n                                   stylus=Event,\n                                   touch=Event,\n                                   close=Event)\n\n        # Deprecated paint emitter\n        emitter = WarningEmitter('Canvas.events.paint and Canvas.on_paint are '\n                                 'deprecated; use Canvas.events.draw and '\n                                 'Canvas.on_draw instead.',\n                                 source=self, type='draw',\n                                 event_class=DrawEvent)\n        self.events.add(paint=emitter)\n        self.events.draw.connect(self.events.paint)\n\n        # Get app instance\n        if app is None:\n            self._app = use_app(call_reuse=False)\n        elif isinstance(app, Application):\n            self._app = app\n        elif isinstance(app, str):\n            self._app = Application(app)\n        else:\n            raise ValueError('Invalid value for app %r' % app)\n\n        # Check shared and context\n        if shared is None:\n            pass\n        elif isinstance(shared, Canvas):\n            shared = shared.context.shared\n        elif isinstance(shared, GLContext):\n            shared = shared.shared\n        else:\n            raise TypeError('shared must be a Canvas, not %s' % type(shared))\n        config = config or {}\n        if not isinstance(config, dict):\n            raise TypeError('config must be a dict, not %s' % type(config))\n\n        # Create new context\n        self._context = GLContext(config, shared)\n\n        # Deal with special keys\n        self._set_keys(keys)\n\n        # store arguments that get set on Canvas init\n        self._backend_kwargs = dict(\n            title=title, size=size, position=position, show=show,\n            vsync=vsync, resizable=resizable, decorate=decorate,\n            fullscreen=fullscreen, context=self._context,\n            parent=parent, always_on_top=always_on_top)\n        if backend_kwargs is not None:\n            self._backend_kwargs.update(**backend_kwargs)\n\n        # Create widget now (always do this *last*, after all err checks)\n        if create_native:\n            self.create_native()\n\n            # Now we're ready to become current\n            self.set_current()\n\n        if '--vispy-fps' in sys.argv:\n            self.measure_fps()\n\n    def create_native(self):\n        \"\"\"Create the native widget if not already done so. If the widget\n        is already created, this function does nothing.\n        \"\"\"\n        if self._backend is not None:\n            return\n        # Make sure that the app is active\n        assert self._app.native\n        # Instantiate the backend with the right class\n        self._app.backend_module.CanvasBackend(self, **self._backend_kwargs)\n        # self._backend = set by BaseCanvasBackend\n        self._backend_kwargs = None  # Clean up\n\n        # Connect to draw event (append to the end)\n        # Process GLIR commands at each paint event\n        self.events.draw.connect(self.context.flush_commands, position='last')\n        if self._autoswap:\n            self.events.draw.connect((self, 'swap_buffers'),\n                                     ref=True, position='last')\n\n    def _set_keys(self, keys):\n        if keys is not None:\n            if isinstance(keys, str):\n                if keys != 'interactive':\n                    raise ValueError('keys, if string, must be \"interactive\", '\n                                     'not %s' % (keys,))\n\n                def toggle_fs():\n                    self.fullscreen = not self.fullscreen\n                keys = dict(escape='close', F11=toggle_fs)\n        else:\n            keys = {}\n        if not isinstance(keys, dict):\n            raise TypeError('keys must be a dict, str, or None')\n        if len(keys) > 0:\n            lower_keys = {}\n            # ensure all are callable\n            for key, val in keys.items():\n                if isinstance(val, str):\n                    new_val = getattr(self, val, None)\n                    if new_val is None:\n                        raise ValueError('value %s is not an attribute of '\n                                         'Canvas' % val)\n                    val = new_val\n                if not hasattr(val, '__call__'):\n                    raise TypeError('Entry for key %s is not callable' % key)\n                # convert to lower-case representation\n                lower_keys[key.lower()] = val\n            self._keys_check = lower_keys\n\n            def keys_check(event):\n                if event.key is not None:\n                    use_name = event.key.name.lower()\n                    if use_name in self._keys_check:\n                        self._keys_check[use_name]()\n            self.events.key_press.connect(keys_check, ref=True)\n\n    @property\n    def context(self):\n        \"\"\"The OpenGL context of the native widget\n\n        It gives access to OpenGL functions to call on this canvas object,\n        and to the shared context namespace.\n        \"\"\"\n        return self._context\n\n    @property\n    def app(self):\n        \"\"\"The vispy Application instance on which this Canvas is based.\"\"\"\n        return self._app\n\n    @property\n    def native(self):\n        \"\"\"The native widget object on which this Canvas is based.\"\"\"\n        return self._backend._vispy_get_native_canvas()\n\n    @property\n    def dpi(self):\n        \"\"\"The physical resolution of the canvas in dots per inch.\"\"\"\n        return self._dpi\n\n    @dpi.setter\n    def dpi(self, dpi):\n        self._dpi = float(dpi)\n        self.update()\n\n    def connect(self, fun):\n        \"\"\"Connect a function to an event\n\n        The name of the function\n        should be on_X, with X the name of the event (e.g. 'on_draw').\n\n        This method is typically used as a decorator on a function\n        definition for an event handler.\n\n        Parameters\n        ----------\n        fun : callable\n            The function.\n        \"\"\"\n        # Get and check name\n        name = fun.__name__\n        if not name.startswith('on_'):\n            raise ValueError('When connecting a function based on its name, '\n                             'the name should start with \"on_\"')\n        eventname = name[3:]\n        # Get emitter\n        try:\n            emitter = self.events[eventname]\n        except KeyError:\n            raise ValueError(\n                'Event \"%s\" not available on this canvas.' %\n                eventname)\n        # Connect\n        emitter.connect(fun)\n\n    # ---------------------------------------------------------------- size ---\n    @property\n    def size(self):\n        \"\"\"The size of canvas/window.\"\"\"\n        # Note that _px_scale is an additional factor applied in addition to\n        # the scale factor imposed by the backend.\n        size = self._backend._vispy_get_size()\n        return (size[0] // self._px_scale, size[1] // self._px_scale)\n\n    @size.setter\n    def size(self, size):\n        return self._backend._vispy_set_size(size[0] * self._px_scale,\n                                             size[1] * self._px_scale)\n\n    @property\n    def physical_size(self):\n        \"\"\"The physical size of the canvas/window, which may differ from the\n        size property on backends that expose HiDPI.\n        \"\"\"\n        return self._backend._vispy_get_physical_size()\n\n    @property\n    def pixel_scale(self):\n        \"\"\"The ratio between the number of logical pixels, or 'points', and\n        the physical pixels on the device. In most cases this will be 1.0,\n        but on certain backends this will be greater than 1. This should be\n        used as a scaling factor when writing your own visualisations\n        with gloo (make a copy and multiply all your logical pixel values\n        by it). When writing Visuals or SceneGraph visualisations, this value\n        is exposed as `TransformSystem.px_scale`.\n        \"\"\"\n        return self.physical_size[0] / self.size[0]\n\n    @property\n    def fullscreen(self):\n        return self._backend._vispy_get_fullscreen()\n\n    @fullscreen.setter\n    def fullscreen(self, fullscreen):\n        return self._backend._vispy_set_fullscreen(fullscreen)\n\n    # ------------------------------------------------------------ position ---\n    @property\n    def position(self):\n        \"\"\"The position of canvas/window relative to screen.\"\"\"\n        return self._backend._vispy_get_position()\n\n    @position.setter\n    def position(self, position):\n        assert len(position) == 2\n        return self._backend._vispy_set_position(position[0], position[1])\n\n    # --------------------------------------------------------------- title ---\n    @property\n    def title(self):\n        \"\"\"The title of canvas/window.\"\"\"\n        return self._title\n\n    @title.setter\n    def title(self, title):\n        self._title = title\n        self._backend._vispy_set_title(title)\n\n    # ----------------------------------------------------------------- fps ---\n    @property\n    def fps(self):\n        \"\"\"The fps of canvas/window, as the rate that events.draw is emitted.\"\"\"\n        return self._fps\n\n    def set_current(self, event=None):\n        \"\"\"Make this the active GL canvas\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        self._backend._vispy_set_current()\n        set_current_canvas(self)\n\n    def swap_buffers(self, event=None):\n        \"\"\"Swap GL buffers such that the offscreen buffer becomes visible\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        self._backend._vispy_swap_buffers()\n\n    def show(self, visible=True, run=False):\n        \"\"\"Show or hide the canvas\n\n        Parameters\n        ----------\n        visible : bool\n            Make the canvas visible.\n        run : bool\n            Run the backend event loop.\n        \"\"\"\n        self._backend._vispy_set_visible(visible)\n        if run:\n            self.app.run()\n\n    def update(self, event=None):\n        \"\"\"Inform the backend that the Canvas needs to be redrawn\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        if self._backend is not None:\n            self._backend._vispy_update()\n\n    def close(self):\n        \"\"\"Close the canvas\n\n        Notes\n        -----\n        This will usually destroy the GL context. For Qt, the context\n        (and widget) will be destroyed only if the widget is top-level.\n        To avoid having the widget destroyed (more like standard Qt\n        behavior), consider making the widget a sub-widget.\n        \"\"\"\n        if self._backend is not None and not self._closed:\n            logger.debug('Closing canvas %s' % (self,))\n            self._closed = True\n            self.events.close()\n            self._backend._vispy_close()\n        forget_canvas(self)\n\n    def _update_fps(self, event):\n        \"\"\"Update the fps after every window\"\"\"\n        self._frame_count += 1\n        diff = time() - self._basetime\n        if (diff > self._fps_window):\n            self._fps = self._frame_count / diff\n            self._basetime = time()\n            self._frame_count = 0\n            self._fps_callback(self.fps)\n\n    def measure_fps(self, window=1, callback='%1.1f FPS'):\n        \"\"\"Measure the current FPS\n\n        Sets the update window, connects the draw event to update_fps\n        and sets the callback function.\n\n        Parameters\n        ----------\n        window : float\n            The time-window (in seconds) to calculate FPS. Default 1.0.\n        callback : function | str\n            The function to call with the float FPS value, or the string\n            to be formatted with the fps value and then printed. The\n            default is ``'%1.1f FPS'``. If callback evaluates to False, the\n            FPS measurement is stopped.\n        \"\"\"\n        # Connect update_fps function to draw\n        self.events.draw.disconnect(self._update_fps)\n        if callback:\n            if isinstance(callback, str):\n                callback_str = callback  # because callback gets overwritten\n\n                def callback(x):\n                    print(callback_str % x)\n\n            self._fps_window = window\n            self.events.draw.connect(self._update_fps)\n            self._fps_callback = callback\n        else:\n            self._fps_callback = None\n\n    # ---------------------------------------------------------------- misc ---\n    def __repr__(self):\n        return ('<%s (%s) at %s>'\n                % (self.__class__.__name__,\n                   self.app.backend_name, hex(id(self))))\n\n    def _repr_mimebundle_(self, *args, **kwargs):\n        \"\"\"If the backend implements _repr_mimebundle_, we proxy it here.\n        \"\"\"\n        # See https://ipython.readthedocs.io/en/stable/config/integrating.html\n        f = getattr(self._backend, \"_repr_mimebundle_\", None)\n        if f is not None:\n            return f(*args, **kwargs)\n        else:\n            # Let Jupyter know this failed - otherwise the standard repr is not shown\n            raise NotImplementedError()\n\n    def _ipython_display_(self):\n        \"\"\"If the backend implements _ipython_display_, we proxy it here.\n        \"\"\"\n        # See https://ipython.readthedocs.io/en/stable/config/integrating.html\n        f = getattr(self._backend, \"_ipython_display_\", None)\n        if f is not None:\n            return f()\n        else:\n            # Let Jupyter know this failed - otherwise the standard repr is not shown\n            raise NotImplementedError()\n\n    def __enter__(self):\n        logger.debug('Context manager enter starting for %s' % (self,))\n        self.show()\n        self._backend._vispy_warmup()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        # ensure all GL calls are complete\n        logger.debug('Context manager exit starting for %s' % (self,))\n        if not self._closed:\n            self._backend._vispy_set_current()\n            self.context.finish()\n            self.close()\n        sleep(0.1)  # ensure window is really closed/destroyed\n        logger.debug('Context manager exit complete for %s' % (self,))\n\n    def render(self, alpha=True):\n        \"\"\"Render the canvas to an offscreen buffer and return the image array.\n\n        Parameters\n        ----------\n        alpha : bool\n            If True (default) produce an RGBA array (M, N, 4). If False,\n            remove the Alpha channel and return the RGB array (M, N, 3).\n            This may be useful if blending of various elements requires a\n            solid background to produce the expected visualization.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region. If ``alpha`` is ``False``,\n            then only 3 channels will be returned (RGB).\n\n\n        \"\"\"\n        self.set_current()\n        size = self.physical_size\n        fbo = FrameBuffer(color=RenderBuffer(size[::-1]),\n                          depth=RenderBuffer(size[::-1]))\n\n        try:\n            fbo.activate()\n            self.events.draw()\n            result = fbo.read()\n        finally:\n            fbo.deactivate()\n\n        if not alpha:\n            result = result[..., :3]\n        return result",
  "class MouseEvent(Event):\n    \"\"\"Mouse event class\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below, as well as a \"time\" attribute with the event's\n    precision start time.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    pos : (int, int)\n        The position of the mouse (in screen coordinates).\n    button : int | None\n        The button that generated this event (can be None).\n        Left=1, right=2, middle=3. During a mouse drag, this\n        will return the button that started the drag (same thing as\n        ``event.press_event.button``).\n    buttons : [int, ...]\n        The list of buttons pressed during this event.\n    modifiers : tuple of Key instances\n        Tuple that specifies which modifier keys were pressed down at the\n        time of the event (shift, control, alt, meta).\n    delta : (float, float)\n        The amount of scrolling in horizontal and vertical direction. One\n        \"tick\" corresponds to a delta of 1.0.\n    press_event : MouseEvent\n        The press event that was generated at the start of the current drag,\n        if any.\n    last_event : MouseEvent\n        The MouseEvent immediately preceding the current event. During drag\n        operations, all generated events retain their last_event properties,\n        allowing the entire drag to be reconstructed.\n    native : object (optional)\n       The native GUI event object\n    **kwargs : keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    \"\"\"\n\n    def __init__(self, type, pos=None, button=None, buttons=None,\n                 modifiers=None, delta=None, last_event=None, press_event=None,\n                 **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._pos = np.array([0, 0]) if (pos is None) else np.array(pos)\n        self._button = int(button) if (button is not None) else None\n        # Explicitly add button to buttons if newly pressed, check #2344 for more reference\n        newly_pressed_buttons = [button] if button is not None and type == 'mouse_press' else []\n        self._buttons = [] if (buttons is None) else buttons + newly_pressed_buttons\n        self._modifiers = tuple(modifiers or ())\n        self._delta = np.zeros(2) if (delta is None) else np.array(delta)\n        self._last_event = last_event\n        self._press_event = press_event\n        self._time = time()\n\n    @property\n    def pos(self):\n        return self._pos\n\n    @property\n    def button(self):\n        return self._button\n\n    @property\n    def buttons(self):\n        return self._buttons\n\n    @property\n    def modifiers(self):\n        return self._modifiers\n\n    @property\n    def delta(self):\n        return self._delta\n\n    @property\n    def press_event(self):\n        return self._press_event\n\n    @property\n    def last_event(self):\n        return self._last_event\n\n    @property\n    def time(self):\n        return self._time\n\n    def _forget_last_event(self):\n        # Needed to break otherwise endless last-event chains\n        self._last_event = None\n\n    @property\n    def is_dragging(self):\n        \"\"\"Indicates whether this event is part of a mouse drag operation.\"\"\"\n        return self.press_event is not None\n\n    def drag_events(self):\n        \"\"\"Return a list of all mouse events in the current drag operation.\n\n        Returns None if there is no current drag operation.\n        \"\"\"\n        if not self.is_dragging:\n            return None\n\n        event = self\n        events = []\n        while True:\n            # mouse_press events can only be the start of a trail\n            if event is None or event.type == 'mouse_press':\n                break\n            events.append(event)\n            event = event.last_event\n\n        return events[::-1]\n\n    def trail(self):\n        \"\"\"Return an (N, 2) array of mouse coordinates for every event in the\n        current mouse drag operation.\n\n        Returns None if there is no current drag operation.\n        \"\"\"\n        events = self.drag_events()\n        if events is None:\n            return None\n\n        trail = np.empty((len(events), 2), dtype=int)\n        for i, ev in enumerate(events):\n            trail[i] = ev.pos\n\n        return trail",
  "class KeyEvent(Event):\n    \"\"\"Key event class\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    key : vispy.keys.Key instance\n        The Key object for this event. Can be compared to string names.\n    text : str\n        The text representation of the key (can be an empty string).\n    modifiers : tuple of Key instances\n        Tuple that specifies which modifier keys were pressed down at the\n        time of the event (shift, control, alt, meta).\n    native : object (optional)\n       The native GUI event object\n    **kwargs : keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    \"\"\"\n\n    def __init__(self, type, key=None, text='', modifiers=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._key = key\n        self._text = text\n        self._modifiers = tuple(modifiers or ())\n\n    @property\n    def key(self):\n        return self._key\n\n    @property\n    def text(self):\n        return self._text\n\n    @property\n    def modifiers(self):\n        return self._modifiers",
  "class ResizeEvent(Event):\n    \"\"\"Resize event class\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    size : (int, int)\n        The new size of the Canvas, in points (logical pixels).\n    physical_size : (int, int)\n        The new physical size of the Canvas, in pixels.\n    native : object (optional)\n       The native GUI event object\n    **kwargs : extra keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    \"\"\"\n\n    def __init__(self, type, size=None, physical_size=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._size = tuple(size)\n        if physical_size is None:\n            self._physical_size = self._size\n        else:\n            self._physical_size = tuple(physical_size)\n\n    @property\n    def size(self):\n        return self._size\n\n    @property\n    def physical_size(self):\n        return self._physical_size",
  "class DrawEvent(Event):\n    \"\"\"Draw event class\n\n    This type of event is sent to Canvas.events.draw when a redraw\n    is required.\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    region : (int, int, int, int) or None\n        The region of the canvas which needs to be redrawn (x, y, w, h).\n        If None, the entire canvas must be redrawn.\n    native : object (optional)\n       The native GUI event object\n    **kwargs : extra keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    \"\"\"\n\n    def __init__(self, type, region=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._region = region\n\n    @property\n    def region(self):\n        return self._region",
  "def __init__(self, title='VisPy canvas', size=(800, 600), position=None,\n                 show=False, autoswap=True, app=None, create_native=True,\n                 vsync=False, resizable=True, decorate=True, fullscreen=False,\n                 config=None, shared=None, keys=None, parent=None, dpi=None,\n                 always_on_top=False, px_scale=1, backend_kwargs=None):\n\n        size = tuple(int(s) * px_scale for s in size)\n        if len(size) != 2:\n            raise ValueError('size must be a 2-element list')\n        title = str(title)\n        if not isinstance(fullscreen, (bool, int)):\n            raise TypeError('fullscreen must be bool or int')\n\n        # Initialize some values\n        self._autoswap = autoswap\n        self._title = title\n        self._frame_count = 0\n        self._fps = 0\n        self._basetime = time()\n        self._fps_callback = None\n        self._backend = None\n        self._closed = False\n        self._fps_window = 0.\n        self._px_scale = int(px_scale)\n\n        if dpi is None:\n            dpi = util_config['dpi']\n        if dpi is None:\n            dpi = get_dpi(raise_error=False)\n        self.dpi = dpi\n\n        # Create events\n        self.events = EmitterGroup(source=self,\n                                   initialize=Event,\n                                   resize=ResizeEvent,\n                                   draw=DrawEvent,\n                                   mouse_press=MouseEvent,\n                                   mouse_release=MouseEvent,\n                                   mouse_double_click=MouseEvent,\n                                   mouse_move=MouseEvent,\n                                   mouse_wheel=MouseEvent,\n                                   key_press=KeyEvent,\n                                   key_release=KeyEvent,\n                                   stylus=Event,\n                                   touch=Event,\n                                   close=Event)\n\n        # Deprecated paint emitter\n        emitter = WarningEmitter('Canvas.events.paint and Canvas.on_paint are '\n                                 'deprecated; use Canvas.events.draw and '\n                                 'Canvas.on_draw instead.',\n                                 source=self, type='draw',\n                                 event_class=DrawEvent)\n        self.events.add(paint=emitter)\n        self.events.draw.connect(self.events.paint)\n\n        # Get app instance\n        if app is None:\n            self._app = use_app(call_reuse=False)\n        elif isinstance(app, Application):\n            self._app = app\n        elif isinstance(app, str):\n            self._app = Application(app)\n        else:\n            raise ValueError('Invalid value for app %r' % app)\n\n        # Check shared and context\n        if shared is None:\n            pass\n        elif isinstance(shared, Canvas):\n            shared = shared.context.shared\n        elif isinstance(shared, GLContext):\n            shared = shared.shared\n        else:\n            raise TypeError('shared must be a Canvas, not %s' % type(shared))\n        config = config or {}\n        if not isinstance(config, dict):\n            raise TypeError('config must be a dict, not %s' % type(config))\n\n        # Create new context\n        self._context = GLContext(config, shared)\n\n        # Deal with special keys\n        self._set_keys(keys)\n\n        # store arguments that get set on Canvas init\n        self._backend_kwargs = dict(\n            title=title, size=size, position=position, show=show,\n            vsync=vsync, resizable=resizable, decorate=decorate,\n            fullscreen=fullscreen, context=self._context,\n            parent=parent, always_on_top=always_on_top)\n        if backend_kwargs is not None:\n            self._backend_kwargs.update(**backend_kwargs)\n\n        # Create widget now (always do this *last*, after all err checks)\n        if create_native:\n            self.create_native()\n\n            # Now we're ready to become current\n            self.set_current()\n\n        if '--vispy-fps' in sys.argv:\n            self.measure_fps()",
  "def create_native(self):\n        \"\"\"Create the native widget if not already done so. If the widget\n        is already created, this function does nothing.\n        \"\"\"\n        if self._backend is not None:\n            return\n        # Make sure that the app is active\n        assert self._app.native\n        # Instantiate the backend with the right class\n        self._app.backend_module.CanvasBackend(self, **self._backend_kwargs)\n        # self._backend = set by BaseCanvasBackend\n        self._backend_kwargs = None  # Clean up\n\n        # Connect to draw event (append to the end)\n        # Process GLIR commands at each paint event\n        self.events.draw.connect(self.context.flush_commands, position='last')\n        if self._autoswap:\n            self.events.draw.connect((self, 'swap_buffers'),\n                                     ref=True, position='last')",
  "def _set_keys(self, keys):\n        if keys is not None:\n            if isinstance(keys, str):\n                if keys != 'interactive':\n                    raise ValueError('keys, if string, must be \"interactive\", '\n                                     'not %s' % (keys,))\n\n                def toggle_fs():\n                    self.fullscreen = not self.fullscreen\n                keys = dict(escape='close', F11=toggle_fs)\n        else:\n            keys = {}\n        if not isinstance(keys, dict):\n            raise TypeError('keys must be a dict, str, or None')\n        if len(keys) > 0:\n            lower_keys = {}\n            # ensure all are callable\n            for key, val in keys.items():\n                if isinstance(val, str):\n                    new_val = getattr(self, val, None)\n                    if new_val is None:\n                        raise ValueError('value %s is not an attribute of '\n                                         'Canvas' % val)\n                    val = new_val\n                if not hasattr(val, '__call__'):\n                    raise TypeError('Entry for key %s is not callable' % key)\n                # convert to lower-case representation\n                lower_keys[key.lower()] = val\n            self._keys_check = lower_keys\n\n            def keys_check(event):\n                if event.key is not None:\n                    use_name = event.key.name.lower()\n                    if use_name in self._keys_check:\n                        self._keys_check[use_name]()\n            self.events.key_press.connect(keys_check, ref=True)",
  "def context(self):\n        \"\"\"The OpenGL context of the native widget\n\n        It gives access to OpenGL functions to call on this canvas object,\n        and to the shared context namespace.\n        \"\"\"\n        return self._context",
  "def app(self):\n        \"\"\"The vispy Application instance on which this Canvas is based.\"\"\"\n        return self._app",
  "def native(self):\n        \"\"\"The native widget object on which this Canvas is based.\"\"\"\n        return self._backend._vispy_get_native_canvas()",
  "def dpi(self):\n        \"\"\"The physical resolution of the canvas in dots per inch.\"\"\"\n        return self._dpi",
  "def dpi(self, dpi):\n        self._dpi = float(dpi)\n        self.update()",
  "def connect(self, fun):\n        \"\"\"Connect a function to an event\n\n        The name of the function\n        should be on_X, with X the name of the event (e.g. 'on_draw').\n\n        This method is typically used as a decorator on a function\n        definition for an event handler.\n\n        Parameters\n        ----------\n        fun : callable\n            The function.\n        \"\"\"\n        # Get and check name\n        name = fun.__name__\n        if not name.startswith('on_'):\n            raise ValueError('When connecting a function based on its name, '\n                             'the name should start with \"on_\"')\n        eventname = name[3:]\n        # Get emitter\n        try:\n            emitter = self.events[eventname]\n        except KeyError:\n            raise ValueError(\n                'Event \"%s\" not available on this canvas.' %\n                eventname)\n        # Connect\n        emitter.connect(fun)",
  "def size(self):\n        \"\"\"The size of canvas/window.\"\"\"\n        # Note that _px_scale is an additional factor applied in addition to\n        # the scale factor imposed by the backend.\n        size = self._backend._vispy_get_size()\n        return (size[0] // self._px_scale, size[1] // self._px_scale)",
  "def size(self, size):\n        return self._backend._vispy_set_size(size[0] * self._px_scale,\n                                             size[1] * self._px_scale)",
  "def physical_size(self):\n        \"\"\"The physical size of the canvas/window, which may differ from the\n        size property on backends that expose HiDPI.\n        \"\"\"\n        return self._backend._vispy_get_physical_size()",
  "def pixel_scale(self):\n        \"\"\"The ratio between the number of logical pixels, or 'points', and\n        the physical pixels on the device. In most cases this will be 1.0,\n        but on certain backends this will be greater than 1. This should be\n        used as a scaling factor when writing your own visualisations\n        with gloo (make a copy and multiply all your logical pixel values\n        by it). When writing Visuals or SceneGraph visualisations, this value\n        is exposed as `TransformSystem.px_scale`.\n        \"\"\"\n        return self.physical_size[0] / self.size[0]",
  "def fullscreen(self):\n        return self._backend._vispy_get_fullscreen()",
  "def fullscreen(self, fullscreen):\n        return self._backend._vispy_set_fullscreen(fullscreen)",
  "def position(self):\n        \"\"\"The position of canvas/window relative to screen.\"\"\"\n        return self._backend._vispy_get_position()",
  "def position(self, position):\n        assert len(position) == 2\n        return self._backend._vispy_set_position(position[0], position[1])",
  "def title(self):\n        \"\"\"The title of canvas/window.\"\"\"\n        return self._title",
  "def title(self, title):\n        self._title = title\n        self._backend._vispy_set_title(title)",
  "def fps(self):\n        \"\"\"The fps of canvas/window, as the rate that events.draw is emitted.\"\"\"\n        return self._fps",
  "def set_current(self, event=None):\n        \"\"\"Make this the active GL canvas\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        self._backend._vispy_set_current()\n        set_current_canvas(self)",
  "def swap_buffers(self, event=None):\n        \"\"\"Swap GL buffers such that the offscreen buffer becomes visible\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        self._backend._vispy_swap_buffers()",
  "def show(self, visible=True, run=False):\n        \"\"\"Show or hide the canvas\n\n        Parameters\n        ----------\n        visible : bool\n            Make the canvas visible.\n        run : bool\n            Run the backend event loop.\n        \"\"\"\n        self._backend._vispy_set_visible(visible)\n        if run:\n            self.app.run()",
  "def update(self, event=None):\n        \"\"\"Inform the backend that the Canvas needs to be redrawn\n\n        Parameters\n        ----------\n        event : None\n            Not used.\n        \"\"\"\n        if self._backend is not None:\n            self._backend._vispy_update()",
  "def close(self):\n        \"\"\"Close the canvas\n\n        Notes\n        -----\n        This will usually destroy the GL context. For Qt, the context\n        (and widget) will be destroyed only if the widget is top-level.\n        To avoid having the widget destroyed (more like standard Qt\n        behavior), consider making the widget a sub-widget.\n        \"\"\"\n        if self._backend is not None and not self._closed:\n            logger.debug('Closing canvas %s' % (self,))\n            self._closed = True\n            self.events.close()\n            self._backend._vispy_close()\n        forget_canvas(self)",
  "def _update_fps(self, event):\n        \"\"\"Update the fps after every window\"\"\"\n        self._frame_count += 1\n        diff = time() - self._basetime\n        if (diff > self._fps_window):\n            self._fps = self._frame_count / diff\n            self._basetime = time()\n            self._frame_count = 0\n            self._fps_callback(self.fps)",
  "def measure_fps(self, window=1, callback='%1.1f FPS'):\n        \"\"\"Measure the current FPS\n\n        Sets the update window, connects the draw event to update_fps\n        and sets the callback function.\n\n        Parameters\n        ----------\n        window : float\n            The time-window (in seconds) to calculate FPS. Default 1.0.\n        callback : function | str\n            The function to call with the float FPS value, or the string\n            to be formatted with the fps value and then printed. The\n            default is ``'%1.1f FPS'``. If callback evaluates to False, the\n            FPS measurement is stopped.\n        \"\"\"\n        # Connect update_fps function to draw\n        self.events.draw.disconnect(self._update_fps)\n        if callback:\n            if isinstance(callback, str):\n                callback_str = callback  # because callback gets overwritten\n\n                def callback(x):\n                    print(callback_str % x)\n\n            self._fps_window = window\n            self.events.draw.connect(self._update_fps)\n            self._fps_callback = callback\n        else:\n            self._fps_callback = None",
  "def __repr__(self):\n        return ('<%s (%s) at %s>'\n                % (self.__class__.__name__,\n                   self.app.backend_name, hex(id(self))))",
  "def _repr_mimebundle_(self, *args, **kwargs):\n        \"\"\"If the backend implements _repr_mimebundle_, we proxy it here.\n        \"\"\"\n        # See https://ipython.readthedocs.io/en/stable/config/integrating.html\n        f = getattr(self._backend, \"_repr_mimebundle_\", None)\n        if f is not None:\n            return f(*args, **kwargs)\n        else:\n            # Let Jupyter know this failed - otherwise the standard repr is not shown\n            raise NotImplementedError()",
  "def _ipython_display_(self):\n        \"\"\"If the backend implements _ipython_display_, we proxy it here.\n        \"\"\"\n        # See https://ipython.readthedocs.io/en/stable/config/integrating.html\n        f = getattr(self._backend, \"_ipython_display_\", None)\n        if f is not None:\n            return f()\n        else:\n            # Let Jupyter know this failed - otherwise the standard repr is not shown\n            raise NotImplementedError()",
  "def __enter__(self):\n        logger.debug('Context manager enter starting for %s' % (self,))\n        self.show()\n        self._backend._vispy_warmup()\n        return self",
  "def __exit__(self, type, value, traceback):\n        # ensure all GL calls are complete\n        logger.debug('Context manager exit starting for %s' % (self,))\n        if not self._closed:\n            self._backend._vispy_set_current()\n            self.context.finish()\n            self.close()\n        sleep(0.1)  # ensure window is really closed/destroyed\n        logger.debug('Context manager exit complete for %s' % (self,))",
  "def render(self, alpha=True):\n        \"\"\"Render the canvas to an offscreen buffer and return the image array.\n\n        Parameters\n        ----------\n        alpha : bool\n            If True (default) produce an RGBA array (M, N, 4). If False,\n            remove the Alpha channel and return the RGB array (M, N, 3).\n            This may be useful if blending of various elements requires a\n            solid background to produce the expected visualization.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region. If ``alpha`` is ``False``,\n            then only 3 channels will be returned (RGB).\n\n\n        \"\"\"\n        self.set_current()\n        size = self.physical_size\n        fbo = FrameBuffer(color=RenderBuffer(size[::-1]),\n                          depth=RenderBuffer(size[::-1]))\n\n        try:\n            fbo.activate()\n            self.events.draw()\n            result = fbo.read()\n        finally:\n            fbo.deactivate()\n\n        if not alpha:\n            result = result[..., :3]\n        return result",
  "def __init__(self, type, pos=None, button=None, buttons=None,\n                 modifiers=None, delta=None, last_event=None, press_event=None,\n                 **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._pos = np.array([0, 0]) if (pos is None) else np.array(pos)\n        self._button = int(button) if (button is not None) else None\n        # Explicitly add button to buttons if newly pressed, check #2344 for more reference\n        newly_pressed_buttons = [button] if button is not None and type == 'mouse_press' else []\n        self._buttons = [] if (buttons is None) else buttons + newly_pressed_buttons\n        self._modifiers = tuple(modifiers or ())\n        self._delta = np.zeros(2) if (delta is None) else np.array(delta)\n        self._last_event = last_event\n        self._press_event = press_event\n        self._time = time()",
  "def pos(self):\n        return self._pos",
  "def button(self):\n        return self._button",
  "def buttons(self):\n        return self._buttons",
  "def modifiers(self):\n        return self._modifiers",
  "def delta(self):\n        return self._delta",
  "def press_event(self):\n        return self._press_event",
  "def last_event(self):\n        return self._last_event",
  "def time(self):\n        return self._time",
  "def _forget_last_event(self):\n        # Needed to break otherwise endless last-event chains\n        self._last_event = None",
  "def is_dragging(self):\n        \"\"\"Indicates whether this event is part of a mouse drag operation.\"\"\"\n        return self.press_event is not None",
  "def drag_events(self):\n        \"\"\"Return a list of all mouse events in the current drag operation.\n\n        Returns None if there is no current drag operation.\n        \"\"\"\n        if not self.is_dragging:\n            return None\n\n        event = self\n        events = []\n        while True:\n            # mouse_press events can only be the start of a trail\n            if event is None or event.type == 'mouse_press':\n                break\n            events.append(event)\n            event = event.last_event\n\n        return events[::-1]",
  "def trail(self):\n        \"\"\"Return an (N, 2) array of mouse coordinates for every event in the\n        current mouse drag operation.\n\n        Returns None if there is no current drag operation.\n        \"\"\"\n        events = self.drag_events()\n        if events is None:\n            return None\n\n        trail = np.empty((len(events), 2), dtype=int)\n        for i, ev in enumerate(events):\n            trail[i] = ev.pos\n\n        return trail",
  "def __init__(self, type, key=None, text='', modifiers=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._key = key\n        self._text = text\n        self._modifiers = tuple(modifiers or ())",
  "def key(self):\n        return self._key",
  "def text(self):\n        return self._text",
  "def modifiers(self):\n        return self._modifiers",
  "def __init__(self, type, size=None, physical_size=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._size = tuple(size)\n        if physical_size is None:\n            self._physical_size = self._size\n        else:\n            self._physical_size = tuple(physical_size)",
  "def size(self):\n        return self._size",
  "def physical_size(self):\n        return self._physical_size",
  "def __init__(self, type, region=None, **kwargs):\n        Event.__init__(self, type, **kwargs)\n        self._region = region",
  "def region(self):\n        return self._region",
  "def keys_check(event):\n                if event.key is not None:\n                    use_name = event.key.name.lower()\n                    if use_name in self._keys_check:\n                        self._keys_check[use_name]()",
  "def toggle_fs():\n                    self.fullscreen = not self.fullscreen",
  "def callback(x):\n                    print(callback_str % x)",
  "class QtCanvas(QWidget):\n    \"\"\"Qt widget containing a vispy Canvas.\n\n    This is a convenience class that allows a vispy canvas to be embedded\n    directly into a Qt application.\n    All methods and properties of the Canvas are wrapped by this class.\n\n    Parameters\n    ----------\n    parent : QWidget or None\n        The Qt parent to assign to this widget.\n    canvas : instance or subclass of Canvas\n        The vispy Canvas to display inside this widget, or a Canvas subclass\n        to instantiate using any remaining keyword arguments.\n    \"\"\"\n\n    def __init__(self, parent=None, canvas=None, **kwargs):\n        from .canvas import Canvas\n        if canvas is None:\n            canvas = Canvas\n        if issubclass(canvas, Canvas):\n            canvas = canvas(**kwargs)\n        elif len(**kwargs) > 0:\n            raise TypeError('Invalid keyword arguments: %s' %\n                            list(kwargs.keys()))\n        if not isinstance(canvas, Canvas):\n            raise TypeError('canvas argument must be an instance or subclass '\n                            'of Canvas.')\n\n        QWidget.__init__(self, parent)\n        self.layout = QGridLayout()\n        self.setLayout(self.layout)\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self._canvas = canvas\n        self.layout.addWidget(canvas.native)\n        self.setSizePolicy(canvas.native.sizePolicy())\n\n    def __getattr__(self, attr):\n        if hasattr(self._canvas, attr):\n            return getattr(self._canvas, attr)\n        else:\n            raise AttributeError(attr)\n\n    def update(self):\n        \"\"\"Call update() on both this widget and the internal canvas.\"\"\"\n        QWidget.update(self)\n        self._canvas.update()",
  "class QtSceneCanvas(QtCanvas):\n    \"\"\"Convenience class embedding a vispy SceneCanvas inside a QWidget.\n    See QtCanvas.\n    \"\"\"\n\n    def __init__(self, parent=None, **kwargs):\n        from ..scene.canvas import SceneCanvas\n        QtCanvas.__init__(self, parent, canvas=SceneCanvas, **kwargs)",
  "def __init__(self, parent=None, canvas=None, **kwargs):\n        from .canvas import Canvas\n        if canvas is None:\n            canvas = Canvas\n        if issubclass(canvas, Canvas):\n            canvas = canvas(**kwargs)\n        elif len(**kwargs) > 0:\n            raise TypeError('Invalid keyword arguments: %s' %\n                            list(kwargs.keys()))\n        if not isinstance(canvas, Canvas):\n            raise TypeError('canvas argument must be an instance or subclass '\n                            'of Canvas.')\n\n        QWidget.__init__(self, parent)\n        self.layout = QGridLayout()\n        self.setLayout(self.layout)\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self._canvas = canvas\n        self.layout.addWidget(canvas.native)\n        self.setSizePolicy(canvas.native.sizePolicy())",
  "def __getattr__(self, attr):\n        if hasattr(self._canvas, attr):\n            return getattr(self._canvas, attr)\n        else:\n            raise AttributeError(attr)",
  "def update(self):\n        \"\"\"Call update() on both this widget and the internal canvas.\"\"\"\n        QWidget.update(self)\n        self._canvas.update()",
  "def __init__(self, parent=None, **kwargs):\n        from ..scene.canvas import SceneCanvas\n        QtCanvas.__init__(self, parent, canvas=SceneCanvas, **kwargs)",
  "def _get_running_interactive_framework():\n    \"\"\"\n    Return the interactive framework whose event loop is currently running, if\n    any, or \"headless\" if no event loop can be started, or None.\n    Returns\n    -------\n    Optional[str]\n        One of the following values: \"qt5\", \"qt4\", \"gtk3\", \"wx\", \"tk\",\n        \"macosx\", \"headless\", ``None``.\n    \"\"\"\n    QtWidgets = (sys.modules.get(\"PyQt5.QtWidgets\")\n                 or sys.modules.get(\"PySide2.QtWidgets\"))\n    if QtWidgets and QtWidgets.QApplication.instance():\n        return \"qt5\"\n    QtGui = (sys.modules.get(\"PyQt4.QtGui\")\n             or sys.modules.get(\"PySide.QtGui\"))\n    if QtGui and QtGui.QApplication.instance():\n        return \"qt4\"\n    Gtk = sys.modules.get(\"gi.repository.Gtk\")\n    if Gtk and Gtk.main_level():\n        return \"gtk3\"\n    wx = sys.modules.get(\"wx\")\n    if wx and wx.GetApp():\n        return \"wx\"\n    tkinter = sys.modules.get(\"tkinter\")\n    if tkinter:\n        for frame in sys._current_frames().values():\n            while frame:\n                if frame.f_code == tkinter.mainloop.__code__:\n                    return \"tk\"\n                frame = frame.f_back\n    if 'matplotlib.backends._macosx' in sys.modules:\n        if sys.modules[\"matplotlib.backends._macosx\"].event_loop_is_running():\n            return \"macosx\"\n    if sys.platform.startswith(\"linux\") and not os.environ.get(\"DISPLAY\"):\n        return \"headless\"\n    return None",
  "def use_app(backend_name=None, call_reuse=True):\n    \"\"\"Get/create the default Application object\n\n    It is safe to call this function multiple times, as long as\n    backend_name is None or matches the already selected backend.\n\n    Parameters\n    ----------\n    backend_name : str | None\n        The name of the backend application to use. If not specified, Vispy\n        tries to select a backend automatically. See ``vispy.use()`` for\n        details.\n    call_reuse : bool\n        Whether to call the backend's `reuse()` function (True by default).\n        Not implemented by default, but some backends need it. For example,\n        the notebook backends need to inject some JavaScript in a notebook as\n        soon as `use_app()` is called.\n\n    \"\"\"\n    global default_app\n\n    # If we already have a default_app, raise error or return\n    if default_app is not None:\n        names = default_app.backend_name.lower().replace('(', ' ').strip(') ')\n        names = [name for name in names.split(' ') if name]\n        if backend_name and backend_name.lower() not in names:\n            raise RuntimeError('Can only select a backend once, already using '\n                               '%s.' % names)\n        else:\n            if call_reuse:\n                default_app.reuse()\n            return default_app  # Current backend matches backend_name\n\n    # Create default app\n    default_app = Application(backend_name)\n    return default_app",
  "def create():\n    \"\"\"Create the native application.\"\"\"\n    use_app(call_reuse=False)\n    return default_app.create()",
  "def run():\n    \"\"\"Enter the native GUI event loop.\"\"\"\n    use_app(call_reuse=False)\n    return default_app.run()",
  "def quit():\n    \"\"\"Quit the native GUI event loop.\"\"\"\n    use_app(call_reuse=False)\n    return default_app.quit()",
  "def process_events():\n    \"\"\"Process all pending GUI events\n\n    If the mainloop is not running, this should be done regularly to\n    keep the visualization interactive and to keep the event system going.\n    \"\"\"\n    use_app(call_reuse=False)\n    return default_app.process_events()",
  "class Application(object):\n    \"\"\"Representation of the vispy application\n\n    This wraps a native GUI application instance. Vispy has a default\n    instance of this class that can be created/obtained via\n    `vispy.app.use_app()`.\n\n    Parameters\n    ----------\n    backend_name : str | None\n        The name of the backend application to use. If not specified,\n        Vispy tries to select a backend automatically. See ``vispy.use()``\n        for details.\n\n    Notes\n    -----\n    Upon creating an Application object, a backend is selected, but the\n    native backend application object is only created when `create()`\n    is called or `native` is used. The Canvas and Timer do this\n    automatically.\n\n    \"\"\"\n\n    def __init__(self, backend_name=None):\n        self._backend_module = None\n        self._backend = None\n        self._use(backend_name)\n\n    def __repr__(self):\n        name = self.backend_name\n        if not name:\n            return '<Vispy app with no backend>'\n        else:\n            return '<Vispy app, wrapping the %s GUI toolkit>' % name\n\n    @property\n    def backend_name(self):\n        \"\"\"The name of the GUI backend that this app wraps.\"\"\"\n        if self._backend is not None:\n            return self._backend._vispy_get_backend_name()\n        else:\n            return ''\n\n    @property\n    def backend_module(self):\n        \"\"\"The module object that defines the backend.\"\"\"\n        return self._backend_module\n\n    def process_events(self):\n        \"\"\"Process all pending GUI events. If the mainloop is not\n        running, this should be done regularly to keep the visualization\n        interactive and to keep the event system going.\n        \"\"\"\n        return self._backend._vispy_process_events()\n\n    def sleep(self, duration_sec):\n        \"\"\"Sleep for the given duration in seconds.\n\n        This is used to reduce\n        CPU stress when VisPy is run in interactive mode.\n\n        Parameters\n        ----------\n        duration_sec: float\n            Time to sleep in seconds\n        \"\"\"\n        self._backend._vispy_sleep(duration_sec)\n\n    def create(self):\n        \"\"\"Create the native application.\"\"\"\n        # Ensure that the native app exists\n        self.native\n\n    def is_interactive(self):\n        \"\"\"Determine if the user requested interactive mode.\"\"\"\n        # The Python interpreter sets sys.flags correctly, so use them!\n        if sys.flags.interactive:\n            return True\n\n        # IPython does not set sys.flags when -i is specified, so first\n        # check it if it is already imported.\n        if not hasattr(builtins, '__IPYTHON__'):\n            return False\n\n        # Then we check the application singleton and determine based on\n        # a variable it sets.\n        try:\n            try:\n                # ipython >=3.0\n                from traitlets.config.application import Application as App\n            except ImportError:\n                # ipython <3.0\n                from IPython.config.application import Application as App\n            return App.initialized() and App.instance().interact\n        except (ImportError, AttributeError):\n            return False\n\n    def is_notebook(self):\n        \"\"\"Determine if the user is executing in a Jupyter Notebook\"\"\"\n        try:\n            # 'get_ipython' is available in globals when running from\n            # IPython/Jupyter\n            ip = get_ipython()\n            if ip.has_trait('kernel'):\n                # There doesn't seem to be an easy way to detect the frontend\n                # That said, if using a kernel, the user can choose to have an\n                # event loop, we therefore make sure the event loop isn't\n                # specified before assuming it is a notebook\n                # https://github.com/vispy/vispy/issues/1708\n                # https://github.com/ipython/ipython/issues/11920\n                return _get_running_interactive_framework() is None\n            else:\n                # `jupyter console` is used\n                return False\n        except NameError:\n            return False\n\n    def run(self, allow_interactive=True):\n        \"\"\"Enter the native GUI event loop.\n\n        Parameters\n        ----------\n        allow_interactive : bool\n            Is the application allowed to handle interactive mode for console\n            terminals?  By default, typing ``python -i main.py`` results in\n            an interactive shell that also regularly calls the VisPy event\n            loop.  In this specific case, the run() function will terminate\n            immediately and rely on the interpreter's input loop to be run\n            after script execution.\n        \"\"\"\n        if os.getenv(\"_VISPY_RUNNING_GALLERY_EXAMPLES\"):\n            # Custom sphinx-gallery scraper in doc/conf.py will handle\n            # rendering/running the application. To make example scripts look\n            # like what a user actually has to run to view the window, we let\n            # them run \"app.run()\" but immediately return here.\n            # Without this the application would block until someone closed the\n            # window that opens.\n            return 0\n        elif not allow_interactive or not self.is_interactive():\n            return self._backend._vispy_run()\n\n    def reuse(self):\n        \"\"\"Called when the application is reused in an interactive session.\n        This allow the backend to do stuff in the client when `use_app()` is\n        called multiple times by the user. For example, the notebook backends\n        need to inject JavaScript code as soon as `use_app()` is called.\n        \"\"\"\n        return self._backend._vispy_reuse()\n\n    def quit(self):\n        \"\"\"Quit the native GUI event loop.\"\"\"\n        return self._backend._vispy_quit()\n\n    @property\n    def native(self):\n        \"\"\"The native GUI application instance.\"\"\"\n        return self._backend._vispy_get_native_app()\n\n    def _use(self, backend_name=None):\n        \"\"\"Select a backend by name. See class docstring for details.\"\"\"\n        # See if we're in a specific testing mode, if so DONT check to see\n        # if it's a valid backend. If it isn't, it's a good thing we\n        # get an error later because we should have decorated our test\n        # with requires_application()\n        test_name = os.getenv('_VISPY_TESTING_APP', None)\n\n        # Check whether the given name is valid\n        if backend_name is not None:\n            if backend_name.lower() == 'default':\n                backend_name = None  # Explicitly use default, avoid using test\n            elif backend_name.lower() not in BACKENDMAP:\n                raise ValueError('backend_name must be one of %s or None, not '\n                                 '%r' % (BACKEND_NAMES, backend_name))\n        elif test_name is not None:\n            backend_name = test_name.lower()\n            assert backend_name in BACKENDMAP\n        elif self.is_notebook():\n            backend_name = 'jupyter_rfb'\n\n        # Should we try and load any backend, or just this specific one?\n        try_others = backend_name is None\n\n        # Get backends to try ...\n        imported_toolkits = []  # Backends for which the native lib is imported\n        backends_to_try = []\n        if not try_others:\n            # We should never hit this, since we check above\n            assert backend_name.lower() in BACKENDMAP.keys()\n            # Add it\n            backends_to_try.append(backend_name.lower())\n        else:\n            # See if a backend is loaded\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                if native_module_name and native_module_name in sys.modules:\n                    imported_toolkits.append(name.lower())\n                    backends_to_try.append(name.lower())\n            # See if a default is given\n            default_backend = config['default_backend'].lower()\n            if default_backend.lower() in BACKENDMAP.keys():\n                if default_backend not in backends_to_try:\n                    backends_to_try.append(default_backend)\n            # After this, try each one\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                name = name.lower()\n                if name not in backends_to_try:\n                    backends_to_try.append(name)\n\n        # Now try each one\n        for key in backends_to_try:\n            name, module_name, native_module_name = BACKENDMAP[key]\n            TRIED_BACKENDS.append(name)\n            mod_name = 'backends.' + module_name\n            __import__(mod_name, globals(), level=1)\n            mod = getattr(backends, module_name)\n            if not mod.available:\n                msg = ('Could not import backend \"%s\":\\n%s'\n                       % (name, str(mod.why_not)))\n                if not try_others:\n                    # Fail if user wanted to use a specific backend\n                    raise RuntimeError(msg)\n                elif key in imported_toolkits:\n                    # Warn if were unable to use an already imported toolkit\n                    msg = ('Although %s is already imported, the %s backend '\n                           'could not\\nbe used (\"%s\"). \\nNote that running '\n                           'multiple GUI toolkits simultaneously can cause '\n                           'side effects.' %\n                           (native_module_name, name, str(mod.why_not)))\n                    logger.warning(msg)\n                elif backend_name is not None:\n                    # Inform only if one isn't available\n                    logger.warning(msg)\n            else:\n                # Success!\n                self._backend_module = mod\n                logger.info('Selected backend %s' % module_name)\n                break\n        else:\n            raise RuntimeError('Could not import any of the backends. '\n                               'You need to install any of %s. We recommend '\n                               'PyQt' % [b[0] for b in CORE_BACKENDS])\n\n        # Store classes for app backend and canvas backend\n        self._backend = self.backend_module.ApplicationBackend()",
  "def __init__(self, backend_name=None):\n        self._backend_module = None\n        self._backend = None\n        self._use(backend_name)",
  "def __repr__(self):\n        name = self.backend_name\n        if not name:\n            return '<Vispy app with no backend>'\n        else:\n            return '<Vispy app, wrapping the %s GUI toolkit>' % name",
  "def backend_name(self):\n        \"\"\"The name of the GUI backend that this app wraps.\"\"\"\n        if self._backend is not None:\n            return self._backend._vispy_get_backend_name()\n        else:\n            return ''",
  "def backend_module(self):\n        \"\"\"The module object that defines the backend.\"\"\"\n        return self._backend_module",
  "def process_events(self):\n        \"\"\"Process all pending GUI events. If the mainloop is not\n        running, this should be done regularly to keep the visualization\n        interactive and to keep the event system going.\n        \"\"\"\n        return self._backend._vispy_process_events()",
  "def sleep(self, duration_sec):\n        \"\"\"Sleep for the given duration in seconds.\n\n        This is used to reduce\n        CPU stress when VisPy is run in interactive mode.\n\n        Parameters\n        ----------\n        duration_sec: float\n            Time to sleep in seconds\n        \"\"\"\n        self._backend._vispy_sleep(duration_sec)",
  "def create(self):\n        \"\"\"Create the native application.\"\"\"\n        # Ensure that the native app exists\n        self.native",
  "def is_interactive(self):\n        \"\"\"Determine if the user requested interactive mode.\"\"\"\n        # The Python interpreter sets sys.flags correctly, so use them!\n        if sys.flags.interactive:\n            return True\n\n        # IPython does not set sys.flags when -i is specified, so first\n        # check it if it is already imported.\n        if not hasattr(builtins, '__IPYTHON__'):\n            return False\n\n        # Then we check the application singleton and determine based on\n        # a variable it sets.\n        try:\n            try:\n                # ipython >=3.0\n                from traitlets.config.application import Application as App\n            except ImportError:\n                # ipython <3.0\n                from IPython.config.application import Application as App\n            return App.initialized() and App.instance().interact\n        except (ImportError, AttributeError):\n            return False",
  "def is_notebook(self):\n        \"\"\"Determine if the user is executing in a Jupyter Notebook\"\"\"\n        try:\n            # 'get_ipython' is available in globals when running from\n            # IPython/Jupyter\n            ip = get_ipython()\n            if ip.has_trait('kernel'):\n                # There doesn't seem to be an easy way to detect the frontend\n                # That said, if using a kernel, the user can choose to have an\n                # event loop, we therefore make sure the event loop isn't\n                # specified before assuming it is a notebook\n                # https://github.com/vispy/vispy/issues/1708\n                # https://github.com/ipython/ipython/issues/11920\n                return _get_running_interactive_framework() is None\n            else:\n                # `jupyter console` is used\n                return False\n        except NameError:\n            return False",
  "def run(self, allow_interactive=True):\n        \"\"\"Enter the native GUI event loop.\n\n        Parameters\n        ----------\n        allow_interactive : bool\n            Is the application allowed to handle interactive mode for console\n            terminals?  By default, typing ``python -i main.py`` results in\n            an interactive shell that also regularly calls the VisPy event\n            loop.  In this specific case, the run() function will terminate\n            immediately and rely on the interpreter's input loop to be run\n            after script execution.\n        \"\"\"\n        if os.getenv(\"_VISPY_RUNNING_GALLERY_EXAMPLES\"):\n            # Custom sphinx-gallery scraper in doc/conf.py will handle\n            # rendering/running the application. To make example scripts look\n            # like what a user actually has to run to view the window, we let\n            # them run \"app.run()\" but immediately return here.\n            # Without this the application would block until someone closed the\n            # window that opens.\n            return 0\n        elif not allow_interactive or not self.is_interactive():\n            return self._backend._vispy_run()",
  "def reuse(self):\n        \"\"\"Called when the application is reused in an interactive session.\n        This allow the backend to do stuff in the client when `use_app()` is\n        called multiple times by the user. For example, the notebook backends\n        need to inject JavaScript code as soon as `use_app()` is called.\n        \"\"\"\n        return self._backend._vispy_reuse()",
  "def quit(self):\n        \"\"\"Quit the native GUI event loop.\"\"\"\n        return self._backend._vispy_quit()",
  "def native(self):\n        \"\"\"The native GUI application instance.\"\"\"\n        return self._backend._vispy_get_native_app()",
  "def _use(self, backend_name=None):\n        \"\"\"Select a backend by name. See class docstring for details.\"\"\"\n        # See if we're in a specific testing mode, if so DONT check to see\n        # if it's a valid backend. If it isn't, it's a good thing we\n        # get an error later because we should have decorated our test\n        # with requires_application()\n        test_name = os.getenv('_VISPY_TESTING_APP', None)\n\n        # Check whether the given name is valid\n        if backend_name is not None:\n            if backend_name.lower() == 'default':\n                backend_name = None  # Explicitly use default, avoid using test\n            elif backend_name.lower() not in BACKENDMAP:\n                raise ValueError('backend_name must be one of %s or None, not '\n                                 '%r' % (BACKEND_NAMES, backend_name))\n        elif test_name is not None:\n            backend_name = test_name.lower()\n            assert backend_name in BACKENDMAP\n        elif self.is_notebook():\n            backend_name = 'jupyter_rfb'\n\n        # Should we try and load any backend, or just this specific one?\n        try_others = backend_name is None\n\n        # Get backends to try ...\n        imported_toolkits = []  # Backends for which the native lib is imported\n        backends_to_try = []\n        if not try_others:\n            # We should never hit this, since we check above\n            assert backend_name.lower() in BACKENDMAP.keys()\n            # Add it\n            backends_to_try.append(backend_name.lower())\n        else:\n            # See if a backend is loaded\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                if native_module_name and native_module_name in sys.modules:\n                    imported_toolkits.append(name.lower())\n                    backends_to_try.append(name.lower())\n            # See if a default is given\n            default_backend = config['default_backend'].lower()\n            if default_backend.lower() in BACKENDMAP.keys():\n                if default_backend not in backends_to_try:\n                    backends_to_try.append(default_backend)\n            # After this, try each one\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                name = name.lower()\n                if name not in backends_to_try:\n                    backends_to_try.append(name)\n\n        # Now try each one\n        for key in backends_to_try:\n            name, module_name, native_module_name = BACKENDMAP[key]\n            TRIED_BACKENDS.append(name)\n            mod_name = 'backends.' + module_name\n            __import__(mod_name, globals(), level=1)\n            mod = getattr(backends, module_name)\n            if not mod.available:\n                msg = ('Could not import backend \"%s\":\\n%s'\n                       % (name, str(mod.why_not)))\n                if not try_others:\n                    # Fail if user wanted to use a specific backend\n                    raise RuntimeError(msg)\n                elif key in imported_toolkits:\n                    # Warn if were unable to use an already imported toolkit\n                    msg = ('Although %s is already imported, the %s backend '\n                           'could not\\nbe used (\"%s\"). \\nNote that running '\n                           'multiple GUI toolkits simultaneously can cause '\n                           'side effects.' %\n                           (native_module_name, name, str(mod.why_not)))\n                    logger.warning(msg)\n                elif backend_name is not None:\n                    # Inform only if one isn't available\n                    logger.warning(msg)\n            else:\n                # Success!\n                self._backend_module = mod\n                logger.info('Selected backend %s' % module_name)\n                break\n        else:\n            raise RuntimeError('Could not import any of the backends. '\n                               'You need to install any of %s. We recommend '\n                               'PyQt' % [b[0] for b in CORE_BACKENDS])\n\n        # Store classes for app backend and canvas backend\n        self._backend = self.backend_module.ApplicationBackend()",
  "class Timer(object):\n    \"\"\"Timer used to schedule events in the future or on a repeating schedule.\n\n    Parameters\n    ----------\n    interval : float | 'auto'\n        Time between events in seconds. The default is 'auto', which\n        attempts to find the interval that matches the refresh rate of\n        the current monitor. Currently this is simply 1/60.\n    connect : function | None\n        The function to call.\n    iterations : int\n        Number of iterations. Can be -1 for infinite.\n    start : bool\n        Whether to start the timer.\n    app : instance of vispy.app.Application\n        The application to attach the timer to.\n    \"\"\"\n\n    def __init__(self, interval='auto', connect=None, iterations=-1,\n                 start=False, app=None):\n        \"\"\"Initiallize timer method.\"\"\"\n        self.events = EmitterGroup(source=self,\n                                   start=Event,\n                                   stop=Event,\n                                   timeout=Event)\n        # self.connect = self.events.timeout.connect\n        # self.disconnect = self.events.timeout.disconnect\n\n        # Get app instance\n        if app is None:\n            self._app = use_app(call_reuse=False)\n        elif isinstance(app, Application):\n            self._app = app\n        elif isinstance(app, str):\n            self._app = Application(app)\n        else:\n            raise ValueError('Invalid value for app %r' % app)\n\n        # Ensure app has backend app object\n        self._app.native\n\n        # Instantiate the backed with the right class\n        self._backend = self._app.backend_module.TimerBackend(self)\n\n        if interval == 'auto':\n            interval = 1.0 / 60\n        self._interval = float(interval)\n        self._running = False\n        self._first_emit_time = None\n        self._last_emit_time = None\n        self.iter_count = 0\n        self.max_iterations = iterations\n        if connect is not None:\n            self.connect(connect)\n        if start:\n            self.start()\n\n    @property\n    def app(self):\n        \"\"\"Timer is based on this vispy Application instance.\"\"\"\n        return self._app\n\n    @property\n    def interval(self):\n        return self._interval\n\n    @interval.setter\n    def interval(self, val):\n        self._interval = val\n        if self.running:\n            self.stop()\n            self.start()\n\n    @property\n    def elapsed(self):\n        return precision_time() - self._first_emit_time\n\n    @property\n    def running(self):\n        return self._running\n\n    def start(self, interval=None, iterations=None):\n        \"\"\"Start the timer.\n\n        A timeout event will be generated every *interval* seconds.\n        If *interval* is None, then self.interval will be used.\n\n        If *iterations* is specified, the timer will stop after\n        emitting that number of events. If unspecified, then\n        the previous value of self.iterations will be used. If the value is\n        negative, then the timer will continue running until stop() is called.\n\n        If the timer is already running when this function is called, nothing\n        happens (timer continues running as it did previously, without\n        changing the interval, number of iterations, or emitting a timer\n        start event).\n        \"\"\"\n        if self.running:\n            return  # don't do anything if already running\n        self.iter_count = 0\n        if interval is not None:\n            self.interval = interval\n        if iterations is not None:\n            self.max_iterations = iterations\n        self._backend._vispy_start(self.interval)\n        self._running = True\n        self._first_emit_time = precision_time()\n        self._last_emit_time = precision_time()\n        self.events.start(type='timer_start')\n\n    def stop(self):\n        \"\"\"Stop the timer.\"\"\"\n        self._backend._vispy_stop()\n        self._running = False\n        self.events.stop(type='timer_stop')\n\n    # use timer.app.run() and .quit() instead.\n    # def run_event_loop(self):\n        # \"\"\"Execute the event loop for this Timer's backend.\n        # \"\"\"\n        # return self._backend._vispy_run()\n\n    # def quit_event_loop(self):\n        # \"\"\"Exit the event loop for this Timer's backend.\n        # \"\"\"\n        # return self._backend._vispy_quit()\n\n    @property\n    def native(self):\n        \"\"\"Timer is based on this native timer\"\"\"\n        return self._backend._vispy_get_native_timer()\n\n    def _timeout(self, *args):\n        # called when the backend timer has triggered.\n        if not self.running:\n            return\n        if self.max_iterations >= 0 and self.iter_count >= self.max_iterations:\n            self.stop()\n            return\n\n        # compute dt since last event\n        now = precision_time()\n        dt = now - self._last_emit_time\n        elapsed = now - self._first_emit_time\n        self._last_emit_time = now\n\n        self.events.timeout(\n            type='timer_timeout',\n            iteration=self.iter_count,\n            elapsed=elapsed,\n            dt=dt,\n            count=self.iter_count)\n        self.iter_count += 1\n\n    def connect(self, callback):\n        \"\"\"Alias for self.events.timeout.connect().\"\"\"\n        return self.events.timeout.connect(callback)\n\n    def disconnect(self, callback=None):\n        \"\"\"Alias for self.events.timeout.disconnect().\"\"\"\n        return self.events.timeout.disconnect(callback)",
  "def __init__(self, interval='auto', connect=None, iterations=-1,\n                 start=False, app=None):\n        \"\"\"Initiallize timer method.\"\"\"\n        self.events = EmitterGroup(source=self,\n                                   start=Event,\n                                   stop=Event,\n                                   timeout=Event)\n        # self.connect = self.events.timeout.connect\n        # self.disconnect = self.events.timeout.disconnect\n\n        # Get app instance\n        if app is None:\n            self._app = use_app(call_reuse=False)\n        elif isinstance(app, Application):\n            self._app = app\n        elif isinstance(app, str):\n            self._app = Application(app)\n        else:\n            raise ValueError('Invalid value for app %r' % app)\n\n        # Ensure app has backend app object\n        self._app.native\n\n        # Instantiate the backed with the right class\n        self._backend = self._app.backend_module.TimerBackend(self)\n\n        if interval == 'auto':\n            interval = 1.0 / 60\n        self._interval = float(interval)\n        self._running = False\n        self._first_emit_time = None\n        self._last_emit_time = None\n        self.iter_count = 0\n        self.max_iterations = iterations\n        if connect is not None:\n            self.connect(connect)\n        if start:\n            self.start()",
  "def app(self):\n        \"\"\"Timer is based on this vispy Application instance.\"\"\"\n        return self._app",
  "def interval(self):\n        return self._interval",
  "def interval(self, val):\n        self._interval = val\n        if self.running:\n            self.stop()\n            self.start()",
  "def elapsed(self):\n        return precision_time() - self._first_emit_time",
  "def running(self):\n        return self._running",
  "def start(self, interval=None, iterations=None):\n        \"\"\"Start the timer.\n\n        A timeout event will be generated every *interval* seconds.\n        If *interval* is None, then self.interval will be used.\n\n        If *iterations* is specified, the timer will stop after\n        emitting that number of events. If unspecified, then\n        the previous value of self.iterations will be used. If the value is\n        negative, then the timer will continue running until stop() is called.\n\n        If the timer is already running when this function is called, nothing\n        happens (timer continues running as it did previously, without\n        changing the interval, number of iterations, or emitting a timer\n        start event).\n        \"\"\"\n        if self.running:\n            return  # don't do anything if already running\n        self.iter_count = 0\n        if interval is not None:\n            self.interval = interval\n        if iterations is not None:\n            self.max_iterations = iterations\n        self._backend._vispy_start(self.interval)\n        self._running = True\n        self._first_emit_time = precision_time()\n        self._last_emit_time = precision_time()\n        self.events.start(type='timer_start')",
  "def stop(self):\n        \"\"\"Stop the timer.\"\"\"\n        self._backend._vispy_stop()\n        self._running = False\n        self.events.stop(type='timer_stop')",
  "def native(self):\n        \"\"\"Timer is based on this native timer\"\"\"\n        return self._backend._vispy_get_native_timer()",
  "def _timeout(self, *args):\n        # called when the backend timer has triggered.\n        if not self.running:\n            return\n        if self.max_iterations >= 0 and self.iter_count >= self.max_iterations:\n            self.stop()\n            return\n\n        # compute dt since last event\n        now = precision_time()\n        dt = now - self._last_emit_time\n        elapsed = now - self._first_emit_time\n        self._last_emit_time = now\n\n        self.events.timeout(\n            type='timer_timeout',\n            iteration=self.iter_count,\n            elapsed=elapsed,\n            dt=dt,\n            count=self.iter_count)\n        self.iter_count += 1",
  "def connect(self, callback):\n        \"\"\"Alias for self.events.timeout.connect().\"\"\"\n        return self.events.timeout.connect(callback)",
  "def disconnect(self, callback=None):\n        \"\"\"Alias for self.events.timeout.disconnect().\"\"\"\n        return self.events.timeout.disconnect(callback)",
  "def _set_config(c):\n    \"\"\"Set gl configuration\"\"\"\n    gl_attribs = [glcanvas.WX_GL_RGBA,\n                  glcanvas.WX_GL_DEPTH_SIZE, c['depth_size'],\n                  glcanvas.WX_GL_STENCIL_SIZE, c['stencil_size'],\n                  glcanvas.WX_GL_MIN_RED, c['red_size'],\n                  glcanvas.WX_GL_MIN_GREEN, c['green_size'],\n                  glcanvas.WX_GL_MIN_BLUE, c['blue_size'],\n                  glcanvas.WX_GL_MIN_ALPHA, c['alpha_size']]\n    gl_attribs += [glcanvas.WX_GL_DOUBLEBUFFER] if c['double_buffer'] else []\n    gl_attribs += [glcanvas.WX_GL_STEREO] if c['stereo'] else []\n    return gl_attribs",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._event_loop = wx.GUIEventLoop()\n        wx.EventLoop.SetActive(self._event_loop)\n\n    def _vispy_get_backend_name(self):\n        return 'wx'\n\n    def _vispy_process_events(self):\n        # inpsired by https://github.com/wxWidgets/wxPython/blob/master/\n        #             samples/mainloop/mainloop.py\n        for _ in range(3):  # trial-and-error found this to work (!)\n            while self._event_loop.Pending():\n                self._event_loop.Dispatch()\n            if hasattr(_wx_app, 'ProcessIdle'):\n                _wx_app.ProcessIdle()\n            else:\n                self._event_loop.ProcessIdle()\n            sleep(0.01)\n\n    def _vispy_run(self):\n        return _wx_app.MainLoop()\n\n    def _vispy_quit(self):\n        global _wx_app\n        _wx_app.ExitMainLoop()\n\n    def _vispy_get_native_app(self):\n        # Get native app in save way. Taken from guisupport.py\n        global _wx_app\n        _wx_app = wx.GetApp()  # in case the user already has one\n        if _wx_app is None:\n            if hasattr(wx, 'App'):\n                _wx_app = wx.App()\n            else:\n                # legacy wx\n                _wx_app = wx.PySimpleApp()\n        _wx_app.SetExitOnFrameDelete(True)\n        return _wx_app",
  "def _get_mods(evt):\n    \"\"\"Helper to extract list of mods from event\"\"\"\n    mods = []\n    mods += [keys.CONTROL] if evt.ControlDown() else []\n    mods += [keys.ALT] if evt.AltDown() else []\n    mods += [keys.SHIFT] if evt.ShiftDown() else []\n    mods += [keys.META] if evt.MetaDown() else []\n    return mods",
  "def _process_key(evt):\n    \"\"\"Helper to convert from wx keycode to vispy keycode\"\"\"\n    key = evt.GetKeyCode()\n    if key in KEYMAP:\n        return KEYMAP[key], ''\n    if 97 <= key <= 122:\n        key -= 32\n    if key >= 32 and key <= 127:\n        return keys.Key(chr(key)), chr(key)\n    else:\n        return None, None",
  "class DummySize(object):\n    def __init__(self, size):\n        self.size = size\n\n    def GetSize(self):\n        return self.size\n\n    def Skip(self):\n        pass",
  "class CanvasBackend(GLCanvas, BaseCanvasBackend):\n    \"\"\"wxPython backend for Canvas abstract class.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        # WX supports OS double-click events, so we set this here to\n        # avoid double events\n        self._double_click_supported = True\n\n        # Set config\n        self._gl_attribs = _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('wx', self)\n        if p.context.shared.ref is self:\n            self._gl_context = None  # set for real once we init the GLCanvas\n        else:\n            self._gl_context = p.context.shared.ref._gl_context\n\n        if p.position is None:\n            pos = wx.DefaultPosition\n        else:\n            pos = p.position\n\n        if p.parent is None:\n            style = (wx.MINIMIZE_BOX | wx.MAXIMIZE_BOX | wx.CLOSE_BOX |\n                     wx.SYSTEM_MENU | wx.CAPTION | wx.CLIP_CHILDREN)\n            style |= wx.NO_BORDER if not p.decorate else wx.RESIZE_BORDER\n            style |= wx.STAY_ON_TOP if p.always_on_top else 0\n            self._frame = wx.Frame(None, wx.ID_ANY, p.title, pos, p.size,\n                                   style)\n\n            if not p.resizable:\n                self._frame.SetSizeHints(p.size[0], p.size[1],\n                                         p.size[0], p.size[1])\n            if p.fullscreen is not False:\n                if p.fullscreen is not True:\n                    logger.warning('Cannot specify monitor number for wx '\n                                   'fullscreen, using default')\n                self._fullscreen = True\n            else:\n                self._fullscreen = False\n            _wx_app.SetTopWindow(self._frame)\n            parent = self._frame\n            self._frame.Show()\n            self._frame.Raise()\n            self._frame.Bind(wx.EVT_CLOSE, self.on_close)\n        else:\n            parent = p.parent\n            self._frame = None\n            self._fullscreen = False\n        self._init = False\n        GLCanvas.__init__(self, parent, wx.ID_ANY, pos=pos,\n                          size=p.size, style=0, name='GLCanvas',\n                          attribList=self._gl_attribs)\n\n        if self._gl_context is None:\n            self._gl_context = glcanvas.GLContext(self)\n\n        self.SetFocus()\n        self._vispy_set_title(p.title)\n        self._size = None\n        self.Bind(wx.EVT_SIZE, self.on_resize)\n        self.Bind(wx.EVT_PAINT, self.on_draw)\n        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)\n        self.Bind(wx.EVT_KEY_UP, self.on_key_up)\n        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)\n        self._size_init = p.size\n        self._vispy_set_visible(p.show)\n\n    def on_resize(self, event):\n        if self._vispy_canvas is None or not self._init:\n            event.Skip()\n            return\n        size = event.GetSize()\n        self._vispy_canvas.events.resize(size=size)\n        self.Refresh()\n        event.Skip()\n\n    def on_draw(self, event):\n        if self._vispy_canvas is None:\n            return\n        dc = wx.PaintDC(self)  # needed for wx\n        if not self._init:\n            self._initialize()\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n        del dc\n        event.Skip()\n\n    def _initialize(self):\n        if self._vispy_canvas is None:\n            return\n        self._init = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self.on_resize(DummySize(self._size_init))\n\n    def _vispy_set_current(self):\n        if self.IsShown():\n            self.SetCurrent(self._gl_context)\n\n    def _vispy_warmup(self):\n        etime = time() + 0.3\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        self._vispy_canvas.set_current()\n        self.SwapBuffers()\n\n    def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        if self._frame is not None:\n            self._frame.SetLabel(title)\n\n    def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        if not self._init:\n            self._size_init = (w, h)\n        if hasattr(self, 'SetSize'):\n            # phoenix\n            self.SetSize(w, h)\n        else:\n            # legacy\n            self.SetSizeWH(w, h)\n\n    def _vispy_set_position(self, x, y):\n        # Set positionof the widget or window. May have no effect for widgets\n        if self._frame is not None:\n            self._frame.SetPosition((x, y))\n\n    def _vispy_get_fullscreen(self):\n        return self._fullscreen\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        if self._frame is not None:\n            self._fullscreen = bool(fullscreen)\n            self._vispy_set_visible(True)\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        self.Show(visible)\n        if visible:\n            if self._frame is not None:\n                self._frame.ShowFullScreen(self._fullscreen)\n\n    def _vispy_update(self):\n        # Invoke a redraw\n        self.Refresh()\n\n    def _vispy_close(self):\n        if self._vispy_canvas is None:\n            return\n        # Force the window or widget to shut down\n        canvas = self\n        frame = self._frame\n        self._gl_context = None  # let RC destroy this in case it's shared\n        canvas.Close()\n        canvas.Destroy()\n        if frame:\n            frame.Close()\n            frame.Destroy()\n        gc.collect()  # ensure context gets destroyed if it should be\n\n    def _vispy_get_size(self):\n        if self._vispy_canvas is None:\n            return\n        w, h = self.GetClientSize()\n        return w, h\n\n    def _vispy_get_physical_size(self):\n        w, h = self.GetClientSize()\n        ratio = self.GetContentScaleFactor()\n        return int(w * ratio), int(h * ratio)\n\n    def _vispy_get_position(self):\n        if self._vispy_canvas is None:\n            return\n        x, y = self.GetPosition()\n        return x, y\n\n    def on_close(self, evt):\n        if not self:  # wx control evaluates to false if C++ part deleted\n            return\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()\n\n    def on_mouse_event(self, evt):\n        if self._vispy_canvas is None:\n            return\n        pos = (evt.GetX(), evt.GetY())\n        mods = _get_mods(evt)\n        if evt.GetWheelRotation() != 0:\n            delta = (0., float(evt.GetWheelRotation())/120.0)\n            self._vispy_canvas.events.mouse_wheel(delta=delta, pos=pos,\n                                                  modifiers=mods)\n        elif evt.Moving() or evt.Dragging():  # mouse move event\n            self._vispy_mouse_move(pos=pos, modifiers=mods)\n        elif evt.ButtonDown():\n            if evt.LeftDown():\n                button = 1\n            elif evt.MiddleDown():\n                button = 3\n            elif evt.RightDown():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_press(pos=pos, button=button, modifiers=mods)\n        elif evt.ButtonUp():\n            if evt.LeftUp():\n                button = 1\n            elif evt.MiddleUp():\n                button = 3\n            elif evt.RightUp():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_release(pos=pos, button=button, modifiers=mods)\n        elif evt.ButtonDClick():\n            if evt.LeftDClick():\n                button = 1\n            elif evt.MiddleDClick():\n                button = 3\n            elif evt.RightDClick():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_press(pos=pos, button=button, modifiers=mods)\n            self._vispy_mouse_double_click(pos=pos, button=button,\n                                           modifiers=mods)\n        evt.Skip()\n\n    def on_key_down(self, evt):\n        if self._vispy_canvas is None:\n            return\n        key, text = _process_key(evt)\n        self._vispy_canvas.events.key_press(key=key, text=text,\n                                            modifiers=_get_mods(evt))\n\n    def on_key_up(self, evt):\n        if self._vispy_canvas is None:\n            return\n        key, text = _process_key(evt)\n        self._vispy_canvas.events.key_release(key=key, text=text,\n                                              modifiers=_get_mods(evt))",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        assert _wx_app is not None\n        parent = _wx_app.GetTopWindow()  # assume it's the parent window\n        self._timer = wx.Timer(parent, -1)\n        parent.Bind(wx.EVT_TIMER, self._vispy_timeout, self._timer)\n\n    def _vispy_start(self, interval):\n        self._timer.Start(interval * 1000., False)\n\n    def _vispy_stop(self):\n        self._timer.Stop()\n\n    def _vispy_timeout(self, evt):\n        self._vispy_timer._timeout()\n        evt.Skip()",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._event_loop = wx.GUIEventLoop()\n        wx.EventLoop.SetActive(self._event_loop)",
  "def _vispy_get_backend_name(self):\n        return 'wx'",
  "def _vispy_process_events(self):\n        # inpsired by https://github.com/wxWidgets/wxPython/blob/master/\n        #             samples/mainloop/mainloop.py\n        for _ in range(3):  # trial-and-error found this to work (!)\n            while self._event_loop.Pending():\n                self._event_loop.Dispatch()\n            if hasattr(_wx_app, 'ProcessIdle'):\n                _wx_app.ProcessIdle()\n            else:\n                self._event_loop.ProcessIdle()\n            sleep(0.01)",
  "def _vispy_run(self):\n        return _wx_app.MainLoop()",
  "def _vispy_quit(self):\n        global _wx_app\n        _wx_app.ExitMainLoop()",
  "def _vispy_get_native_app(self):\n        # Get native app in save way. Taken from guisupport.py\n        global _wx_app\n        _wx_app = wx.GetApp()  # in case the user already has one\n        if _wx_app is None:\n            if hasattr(wx, 'App'):\n                _wx_app = wx.App()\n            else:\n                # legacy wx\n                _wx_app = wx.PySimpleApp()\n        _wx_app.SetExitOnFrameDelete(True)\n        return _wx_app",
  "def __init__(self, size):\n        self.size = size",
  "def GetSize(self):\n        return self.size",
  "def Skip(self):\n        pass",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        # WX supports OS double-click events, so we set this here to\n        # avoid double events\n        self._double_click_supported = True\n\n        # Set config\n        self._gl_attribs = _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('wx', self)\n        if p.context.shared.ref is self:\n            self._gl_context = None  # set for real once we init the GLCanvas\n        else:\n            self._gl_context = p.context.shared.ref._gl_context\n\n        if p.position is None:\n            pos = wx.DefaultPosition\n        else:\n            pos = p.position\n\n        if p.parent is None:\n            style = (wx.MINIMIZE_BOX | wx.MAXIMIZE_BOX | wx.CLOSE_BOX |\n                     wx.SYSTEM_MENU | wx.CAPTION | wx.CLIP_CHILDREN)\n            style |= wx.NO_BORDER if not p.decorate else wx.RESIZE_BORDER\n            style |= wx.STAY_ON_TOP if p.always_on_top else 0\n            self._frame = wx.Frame(None, wx.ID_ANY, p.title, pos, p.size,\n                                   style)\n\n            if not p.resizable:\n                self._frame.SetSizeHints(p.size[0], p.size[1],\n                                         p.size[0], p.size[1])\n            if p.fullscreen is not False:\n                if p.fullscreen is not True:\n                    logger.warning('Cannot specify monitor number for wx '\n                                   'fullscreen, using default')\n                self._fullscreen = True\n            else:\n                self._fullscreen = False\n            _wx_app.SetTopWindow(self._frame)\n            parent = self._frame\n            self._frame.Show()\n            self._frame.Raise()\n            self._frame.Bind(wx.EVT_CLOSE, self.on_close)\n        else:\n            parent = p.parent\n            self._frame = None\n            self._fullscreen = False\n        self._init = False\n        GLCanvas.__init__(self, parent, wx.ID_ANY, pos=pos,\n                          size=p.size, style=0, name='GLCanvas',\n                          attribList=self._gl_attribs)\n\n        if self._gl_context is None:\n            self._gl_context = glcanvas.GLContext(self)\n\n        self.SetFocus()\n        self._vispy_set_title(p.title)\n        self._size = None\n        self.Bind(wx.EVT_SIZE, self.on_resize)\n        self.Bind(wx.EVT_PAINT, self.on_draw)\n        self.Bind(wx.EVT_KEY_DOWN, self.on_key_down)\n        self.Bind(wx.EVT_KEY_UP, self.on_key_up)\n        self.Bind(wx.EVT_MOUSE_EVENTS, self.on_mouse_event)\n        self._size_init = p.size\n        self._vispy_set_visible(p.show)",
  "def on_resize(self, event):\n        if self._vispy_canvas is None or not self._init:\n            event.Skip()\n            return\n        size = event.GetSize()\n        self._vispy_canvas.events.resize(size=size)\n        self.Refresh()\n        event.Skip()",
  "def on_draw(self, event):\n        if self._vispy_canvas is None:\n            return\n        dc = wx.PaintDC(self)  # needed for wx\n        if not self._init:\n            self._initialize()\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n        del dc\n        event.Skip()",
  "def _initialize(self):\n        if self._vispy_canvas is None:\n            return\n        self._init = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self.on_resize(DummySize(self._size_init))",
  "def _vispy_set_current(self):\n        if self.IsShown():\n            self.SetCurrent(self._gl_context)",
  "def _vispy_warmup(self):\n        etime = time() + 0.3\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        self._vispy_canvas.set_current()\n        self.SwapBuffers()",
  "def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        if self._frame is not None:\n            self._frame.SetLabel(title)",
  "def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        if not self._init:\n            self._size_init = (w, h)\n        if hasattr(self, 'SetSize'):\n            # phoenix\n            self.SetSize(w, h)\n        else:\n            # legacy\n            self.SetSizeWH(w, h)",
  "def _vispy_set_position(self, x, y):\n        # Set positionof the widget or window. May have no effect for widgets\n        if self._frame is not None:\n            self._frame.SetPosition((x, y))",
  "def _vispy_get_fullscreen(self):\n        return self._fullscreen",
  "def _vispy_set_fullscreen(self, fullscreen):\n        if self._frame is not None:\n            self._fullscreen = bool(fullscreen)\n            self._vispy_set_visible(True)",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        self.Show(visible)\n        if visible:\n            if self._frame is not None:\n                self._frame.ShowFullScreen(self._fullscreen)",
  "def _vispy_update(self):\n        # Invoke a redraw\n        self.Refresh()",
  "def _vispy_close(self):\n        if self._vispy_canvas is None:\n            return\n        # Force the window or widget to shut down\n        canvas = self\n        frame = self._frame\n        self._gl_context = None  # let RC destroy this in case it's shared\n        canvas.Close()\n        canvas.Destroy()\n        if frame:\n            frame.Close()\n            frame.Destroy()\n        gc.collect()",
  "def _vispy_get_size(self):\n        if self._vispy_canvas is None:\n            return\n        w, h = self.GetClientSize()\n        return w, h",
  "def _vispy_get_physical_size(self):\n        w, h = self.GetClientSize()\n        ratio = self.GetContentScaleFactor()\n        return int(w * ratio), int(h * ratio)",
  "def _vispy_get_position(self):\n        if self._vispy_canvas is None:\n            return\n        x, y = self.GetPosition()\n        return x, y",
  "def on_close(self, evt):\n        if not self:  # wx control evaluates to false if C++ part deleted\n            return\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()",
  "def on_mouse_event(self, evt):\n        if self._vispy_canvas is None:\n            return\n        pos = (evt.GetX(), evt.GetY())\n        mods = _get_mods(evt)\n        if evt.GetWheelRotation() != 0:\n            delta = (0., float(evt.GetWheelRotation())/120.0)\n            self._vispy_canvas.events.mouse_wheel(delta=delta, pos=pos,\n                                                  modifiers=mods)\n        elif evt.Moving() or evt.Dragging():  # mouse move event\n            self._vispy_mouse_move(pos=pos, modifiers=mods)\n        elif evt.ButtonDown():\n            if evt.LeftDown():\n                button = 1\n            elif evt.MiddleDown():\n                button = 3\n            elif evt.RightDown():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_press(pos=pos, button=button, modifiers=mods)\n        elif evt.ButtonUp():\n            if evt.LeftUp():\n                button = 1\n            elif evt.MiddleUp():\n                button = 3\n            elif evt.RightUp():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_release(pos=pos, button=button, modifiers=mods)\n        elif evt.ButtonDClick():\n            if evt.LeftDClick():\n                button = 1\n            elif evt.MiddleDClick():\n                button = 3\n            elif evt.RightDClick():\n                button = 2\n            else:\n                evt.Skip()\n            self._vispy_mouse_press(pos=pos, button=button, modifiers=mods)\n            self._vispy_mouse_double_click(pos=pos, button=button,\n                                           modifiers=mods)\n        evt.Skip()",
  "def on_key_down(self, evt):\n        if self._vispy_canvas is None:\n            return\n        key, text = _process_key(evt)\n        self._vispy_canvas.events.key_press(key=key, text=text,\n                                            modifiers=_get_mods(evt))",
  "def on_key_up(self, evt):\n        if self._vispy_canvas is None:\n            return\n        key, text = _process_key(evt)\n        self._vispy_canvas.events.key_release(key=key, text=text,\n                                              modifiers=_get_mods(evt))",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        assert _wx_app is not None\n        parent = _wx_app.GetTopWindow()  # assume it's the parent window\n        self._timer = wx.Timer(parent, -1)\n        parent.Bind(wx.EVT_TIMER, self._vispy_timeout, self._timer)",
  "def _vispy_start(self, interval):\n        self._timer.Start(interval * 1000., False)",
  "def _vispy_stop(self):\n        self._timer.Stop()",
  "def _vispy_timeout(self, evt):\n        self._vispy_timer._timeout()\n        evt.Skip()",
  "class GLCanvas(object):\n        pass",
  "def _set_config(c):\n    \"\"\"Set gl configuration for template\"\"\"\n    raise NotImplementedError",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n\n    def _vispy_get_backend_name(self):\n        return 'ThisBackendsName'\n\n    def _vispy_process_events(self):\n        raise NotImplementedError()\n\n    def _vispy_run(self):\n        raise NotImplementedError()\n\n    def _vispy_quit(self):\n        raise NotImplementedError()\n\n    def _vispy_get_native_app(self):\n        raise NotImplementedError()",
  "class CanvasBackend(BaseCanvasBackend):\n    \"\"\"Template backend\n\n    Events to emit are shown below. Most backends will probably\n    have one method for each event:\n\n        self._vispy_canvas.events.initialize()\n        self._vispy_canvas.events.resize(size=(w, h))\n        self._vispy_canvas.events.draw(region=None)\n        self._vispy_canvas.close()\n        self._vispy_canvas.events.mouse_press(pos=(x, y), button=1,\n                                              modifiers=())\n        self._vispy_canvas.events.mouse_release(pos=(x, y), button=1,\n                                                modifiers=())\n        self._vispy_canvas.events.mouse_double_click(pos=(x, y), button=1,\n                                                     modifiers=())\n        self._vispy_canvas.events.mouse_move(pos=(x, y), modifiers=())\n        self._vispy_canvas.events.mouse_wheel(pos=(x, y), delta=(0, 0),\n                                              modifiers=())\n        self._vispy_canvas.events.key_press(key=key, text=text, modifiers=())\n        self._vispy_canvas.events.key_release(key=key, text=text, modifiers=())\n\n    In most cases, if the window-cross is clicked, a native close-event is\n    generated, which should then call canvas.close(). The Canvas class is\n    responsible for firing the close event and calling\n    backend_canvas._vispy_close, which closes the native widget.\n    If this happens to result in a second close event, canvas.close() gets\n    called again, but Canvas knows it is closing so it stops there.\n\n    If canvas.close() is called (by the user), it calls\n    backend_canvas._vispy_close, which closes the native widget,\n    and we get the same stream of actions as above. This deviation from\n    having events come from the CanvasBackend is necessitated by how\n    different backends handle close events, and the various ways such\n    events can be triggered.\n    \"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # We use _process_backend_kwargs() to \"serialize\" the kwargs\n        # and to check whether they match this backend's capability\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('backend-name', self)\n        if p.context.shared.ref is self:\n            self._native_context = None  # ...\n        else:\n            self._native_context = p.context.shared.ref._native_context\n\n        # NativeWidgetClass.__init__(self, foo, bar)\n\n    def _vispy_set_current(self):\n        # Make this the current context\n        raise NotImplementedError()\n\n    def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        raise NotImplementedError()\n\n    def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        raise NotImplementedError()\n\n    def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        raise NotImplementedError()\n\n    def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        raise NotImplementedError()\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        raise NotImplementedError()\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        # Set the current fullscreen state\n        raise NotImplementedError()\n\n    def _vispy_update(self):\n        # Invoke a redraw\n        raise NotImplementedError()\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        raise NotImplementedError()\n\n    def _vispy_get_size(self):\n        # Should return widget size\n        raise NotImplementedError()\n\n    def _vispy_get_position(self):\n        # Should return widget position\n        raise NotImplementedError()\n\n    def _vispy_get_fullscreen(self):\n        # Should return the current fullscreen state\n        raise NotImplementedError()\n\n    def _vispy_get_native_canvas(self):\n        # Should return the native widget object.\n        # If this is self, this method can be omitted.\n        return self",
  "class TimerBackend(BaseTimerBackend):  # Can be mixed with native timer class\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n\n    def _vispy_start(self, interval):\n        raise NotImplementedError()\n\n    def _vispy_stop(self):\n        raise NotImplementedError()\n\n    def _vispy_timeout(self):\n        raise NotImplementedError()\n\n    def _vispy_get_native_timer(self):\n        # Should return the native widget object.\n        # If this is self, this method can be omitted.\n        return self",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)",
  "def _vispy_get_backend_name(self):\n        return 'ThisBackendsName'",
  "def _vispy_process_events(self):\n        raise NotImplementedError()",
  "def _vispy_run(self):\n        raise NotImplementedError()",
  "def _vispy_quit(self):\n        raise NotImplementedError()",
  "def _vispy_get_native_app(self):\n        raise NotImplementedError()",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # We use _process_backend_kwargs() to \"serialize\" the kwargs\n        # and to check whether they match this backend's capability\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('backend-name', self)\n        if p.context.shared.ref is self:\n            self._native_context = None  # ...\n        else:\n            self._native_context = p.context.shared.ref._native_context",
  "def _vispy_set_current(self):\n        # Make this the current context\n        raise NotImplementedError()",
  "def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        raise NotImplementedError()",
  "def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        raise NotImplementedError()",
  "def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        raise NotImplementedError()",
  "def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        raise NotImplementedError()",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        raise NotImplementedError()",
  "def _vispy_set_fullscreen(self, fullscreen):\n        # Set the current fullscreen state\n        raise NotImplementedError()",
  "def _vispy_update(self):\n        # Invoke a redraw\n        raise NotImplementedError()",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        raise NotImplementedError()",
  "def _vispy_get_size(self):\n        # Should return widget size\n        raise NotImplementedError()",
  "def _vispy_get_position(self):\n        # Should return widget position\n        raise NotImplementedError()",
  "def _vispy_get_fullscreen(self):\n        # Should return the current fullscreen state\n        raise NotImplementedError()",
  "def _vispy_get_native_canvas(self):\n        # Should return the native widget object.\n        # If this is self, this method can be omitted.\n        return self",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)",
  "def _vispy_start(self, interval):\n        raise NotImplementedError()",
  "def _vispy_stop(self):\n        raise NotImplementedError()",
  "def _vispy_timeout(self):\n        raise NotImplementedError()",
  "def _vispy_get_native_timer(self):\n        # Should return the native widget object.\n        # If this is self, this method can be omitted.\n        return self",
  "def qWait(msec):\n            import time\n            start = time.time()\n            PySide2.QtWidgets.QApplication.processEvents()\n            while time.time() < start + msec * 0.001:\n                PySide2.QtWidgets.QApplication.processEvents()",
  "def qWait(msec):\n        import time\n        start = time.time()\n        PySide6.QtWidgets.QApplication.processEvents()\n        while time.time() < start + msec * 0.001:\n            PySide6.QtWidgets.QApplication.processEvents()",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        super().__init__()\n\n    def _vispy_get_backend_name(self):\n        return 'jupyter_rfb'\n\n    def _vispy_process_events(self):\n        raise RuntimeError(\"Cannot process events while asyncio event-loop is running.\")\n\n    def _vispy_run(self):\n        pass  # We're in IPython; don't enter a mainloop or we'll block!\n\n    def _vispy_quit(self):\n        pass\n\n    def _vispy_get_native_app(self):\n        return asyncio",
  "class CanvasBackend(BaseCanvasBackend, RemoteFrameBuffer):\n\n    _double_click_supported = True\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        RemoteFrameBuffer.__init__(self)\n        # Use a context per canvas, because we seem to make assumptions\n        # about OpenGL state being local to the canvas.\n        self._context = OffscreenContext()  # OffscreenContext.get_global_instance()\n        self._helper = FrameBufferHelper()\n        self._loop = asyncio.get_event_loop()\n        self._logical_size = 1, 1\n        self._physical_size = 1, 1\n        self._lifecycle = 0  # 0: not initialized, 1: initialized, 2: closed\n        # Init more based on kwargs (could maybe handle, title, show, context)\n        self._vispy_set_size(*kwargs[\"size\"])\n        self.resizable = kwargs[\"resizable\"]\n        # Need a first update\n        self._vispy_update()\n\n    def handle_event(self, ev):\n        type = ev[\"event_type\"]\n        if type == \"resize\":\n            # Note that jupyter_rfb already throttles this event\n            w, h, r = ev[\"width\"], ev[\"height\"], ev[\"pixel_ratio\"]\n            self._logical_size = w, h\n            self._physical_size = int(w * r), int(h * r)\n            self._helper.set_physical_size(*self._physical_size)\n            self._loop.call_soon(self._emit_resize_event)\n            self._vispy_update()  # make sure to schedule a new draw\n        elif type == \"pointer_down\":\n            self._vispy_mouse_press(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"pointer_up\":\n            self._vispy_mouse_release(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"pointer_move\":\n            self._vispy_mouse_move(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"double_click\":\n            self._vispy_mouse_double_click(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"wheel\":\n            self._vispy_canvas.events.mouse_wheel(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                delta=(ev[\"dx\"] / 100, - ev[\"dy\"] / 100),\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"key_down\":\n            # The special key names are all (most?) the same\n            # But the key is actually more like tex, e.g. shift + 3 becomes \"#\"\n            self._vispy_canvas.events.key_press(\n                native=ev,\n                key=keys.Key(ev[\"key\"]),\n                modifiers=self._modifiers(ev),\n                text=ev[\"key\"],\n            )\n        elif type == \"key_up\":\n            self._vispy_canvas.events.key_release(\n                native=ev,\n                key=keys.Key(ev[\"key\"]),\n                modifiers=self._modifiers(ev),\n                text=ev[\"key\"],\n            )\n        elif type == \"close\":\n            self._lifecycle = 2\n            self._context.close()\n            _stop_timers(self._vispy_canvas)\n        else:\n            pass  # event ignored / unknown\n\n    def _modifiers(self, ev):\n        return tuple(getattr(keys, m.upper()) for m in ev[\"modifiers\"])\n\n    def _emit_resize_event(self):\n        self._vispy_canvas.events.resize(\n            size=self._logical_size,\n            physical_size=self._physical_size,\n        )\n\n    def get_frame(self):\n        # This gets automatically called by the RFB widget\n\n        # Only draw if the draw region is not null\n        if self._physical_size[0] <= 1 or self._physical_size[1] <= 1:\n            return None\n\n        # Handle initialization\n        if not self._lifecycle:\n            self._lifecycle = 1\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.events.initialize()\n            self._emit_resize_event()\n\n        # Draw and obtain result\n        self._vispy_canvas.set_current()\n        with self._helper:\n            self._vispy_canvas.events.draw(region=None)\n            array = self._helper.get_frame()\n\n        # Flush commands here to clean up - otherwise we get errors related to\n        # framebuffers not existin.\n        self._vispy_canvas.context.flush_commands()\n\n        return array\n\n    def _vispy_warmup(self):\n        self._vispy_canvas.set_current()\n\n    def _vispy_set_current(self):\n        self._context.make_current()\n\n    def _vispy_swap_buffers(self):\n        pass\n\n    def _vispy_set_title(self, title):\n        pass\n\n    def _vispy_set_size(self, w, h):\n        self.css_width = f\"{w}px\"\n        self.css_height = f\"{h}px\"\n\n    def _vispy_set_position(self, x, y):\n        pass\n\n    def _vispy_set_visible(self, visible):\n        if not visible:\n            raise NotImplementedError(\"Cannot hide the RFB widget\")\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        raise NotImplementedError()\n\n    def _vispy_update(self):\n        self.request_draw()\n\n    def _vispy_close(self):\n        # ipywidget.Widget.close()  ->  closes the comm and removes all views\n        self.close()\n\n    def _vispy_get_size(self):\n        return self._logical_size\n\n    def _vispy_get_physical_size(self):\n        return self._physical_size\n\n    def _vispy_get_position(self):\n        return 0, 0\n\n    def _vispy_get_fullscreen(self):\n        return False",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        super().__init__(vispy_timer)\n        self._loop = asyncio.get_event_loop()\n        self._task = None\n\n    async def _timer_coro(self, interval):\n        while True:\n            await asyncio.sleep(interval)\n            self._vispy_timeout()\n\n    def _vispy_start(self, interval):\n        if self._task is not None:\n            self._task.cancel()\n        self._task = asyncio.create_task(self._timer_coro(interval))\n\n    def _vispy_stop(self):\n        self._task.cancel()\n        self._task = None\n\n    def _vispy_timeout(self):\n        self._loop.call_soon(self._vispy_timer._timeout)",
  "def _stop_timers(canvas):\n    \"\"\"Stop all timers associated with a canvas.\"\"\"\n    # This is nice and all, but the Canvas object is frozen, so this is never actually used\n    for attr in dir(canvas):\n        try:\n            attr_obj = getattr(canvas, attr)\n        except NotImplementedError:\n            continue  # prevent error due to props that we don't implement\n        else:\n            if isinstance(attr_obj, Timer):\n                attr_obj.stop()",
  "def __init__(self):\n        super().__init__()",
  "def _vispy_get_backend_name(self):\n        return 'jupyter_rfb'",
  "def _vispy_process_events(self):\n        raise RuntimeError(\"Cannot process events while asyncio event-loop is running.\")",
  "def _vispy_run(self):\n        pass",
  "def _vispy_quit(self):\n        pass",
  "def _vispy_get_native_app(self):\n        return asyncio",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        RemoteFrameBuffer.__init__(self)\n        # Use a context per canvas, because we seem to make assumptions\n        # about OpenGL state being local to the canvas.\n        self._context = OffscreenContext()  # OffscreenContext.get_global_instance()\n        self._helper = FrameBufferHelper()\n        self._loop = asyncio.get_event_loop()\n        self._logical_size = 1, 1\n        self._physical_size = 1, 1\n        self._lifecycle = 0  # 0: not initialized, 1: initialized, 2: closed\n        # Init more based on kwargs (could maybe handle, title, show, context)\n        self._vispy_set_size(*kwargs[\"size\"])\n        self.resizable = kwargs[\"resizable\"]\n        # Need a first update\n        self._vispy_update()",
  "def handle_event(self, ev):\n        type = ev[\"event_type\"]\n        if type == \"resize\":\n            # Note that jupyter_rfb already throttles this event\n            w, h, r = ev[\"width\"], ev[\"height\"], ev[\"pixel_ratio\"]\n            self._logical_size = w, h\n            self._physical_size = int(w * r), int(h * r)\n            self._helper.set_physical_size(*self._physical_size)\n            self._loop.call_soon(self._emit_resize_event)\n            self._vispy_update()  # make sure to schedule a new draw\n        elif type == \"pointer_down\":\n            self._vispy_mouse_press(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"pointer_up\":\n            self._vispy_mouse_release(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"pointer_move\":\n            self._vispy_mouse_move(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"double_click\":\n            self._vispy_mouse_double_click(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                button=ev[\"button\"],\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"wheel\":\n            self._vispy_canvas.events.mouse_wheel(\n                native=ev,\n                pos=(ev[\"x\"], ev[\"y\"]),\n                delta=(ev[\"dx\"] / 100, - ev[\"dy\"] / 100),\n                modifiers=self._modifiers(ev),\n            )\n        elif type == \"key_down\":\n            # The special key names are all (most?) the same\n            # But the key is actually more like tex, e.g. shift + 3 becomes \"#\"\n            self._vispy_canvas.events.key_press(\n                native=ev,\n                key=keys.Key(ev[\"key\"]),\n                modifiers=self._modifiers(ev),\n                text=ev[\"key\"],\n            )\n        elif type == \"key_up\":\n            self._vispy_canvas.events.key_release(\n                native=ev,\n                key=keys.Key(ev[\"key\"]),\n                modifiers=self._modifiers(ev),\n                text=ev[\"key\"],\n            )\n        elif type == \"close\":\n            self._lifecycle = 2\n            self._context.close()\n            _stop_timers(self._vispy_canvas)\n        else:\n            pass",
  "def _modifiers(self, ev):\n        return tuple(getattr(keys, m.upper()) for m in ev[\"modifiers\"])",
  "def _emit_resize_event(self):\n        self._vispy_canvas.events.resize(\n            size=self._logical_size,\n            physical_size=self._physical_size,\n        )",
  "def get_frame(self):\n        # This gets automatically called by the RFB widget\n\n        # Only draw if the draw region is not null\n        if self._physical_size[0] <= 1 or self._physical_size[1] <= 1:\n            return None\n\n        # Handle initialization\n        if not self._lifecycle:\n            self._lifecycle = 1\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.events.initialize()\n            self._emit_resize_event()\n\n        # Draw and obtain result\n        self._vispy_canvas.set_current()\n        with self._helper:\n            self._vispy_canvas.events.draw(region=None)\n            array = self._helper.get_frame()\n\n        # Flush commands here to clean up - otherwise we get errors related to\n        # framebuffers not existin.\n        self._vispy_canvas.context.flush_commands()\n\n        return array",
  "def _vispy_warmup(self):\n        self._vispy_canvas.set_current()",
  "def _vispy_set_current(self):\n        self._context.make_current()",
  "def _vispy_swap_buffers(self):\n        pass",
  "def _vispy_set_title(self, title):\n        pass",
  "def _vispy_set_size(self, w, h):\n        self.css_width = f\"{w}px\"\n        self.css_height = f\"{h}px\"",
  "def _vispy_set_position(self, x, y):\n        pass",
  "def _vispy_set_visible(self, visible):\n        if not visible:\n            raise NotImplementedError(\"Cannot hide the RFB widget\")",
  "def _vispy_set_fullscreen(self, fullscreen):\n        raise NotImplementedError()",
  "def _vispy_update(self):\n        self.request_draw()",
  "def _vispy_close(self):\n        # ipywidget.Widget.close()  ->  closes the comm and removes all views\n        self.close()",
  "def _vispy_get_size(self):\n        return self._logical_size",
  "def _vispy_get_physical_size(self):\n        return self._physical_size",
  "def _vispy_get_position(self):\n        return 0, 0",
  "def _vispy_get_fullscreen(self):\n        return False",
  "def __init__(self, vispy_timer):\n        super().__init__(vispy_timer)\n        self._loop = asyncio.get_event_loop()\n        self._task = None",
  "async def _timer_coro(self, interval):\n        while True:\n            await asyncio.sleep(interval)\n            self._vispy_timeout()",
  "def _vispy_start(self, interval):\n        if self._task is not None:\n            self._task.cancel()\n        self._task = asyncio.create_task(self._timer_coro(interval))",
  "def _vispy_stop(self):\n        self._task.cancel()\n        self._task = None",
  "def _vispy_timeout(self):\n        self._loop.call_soon(self._vispy_timer._timeout)",
  "def _get_glfw_windows():\n    wins = list()\n    for win in _VP_GLFW_ALL_WINDOWS:\n        if isinstance(win, CanvasBackend):\n            wins.append(win)\n    return wins",
  "def _set_config(c):\n    \"\"\"Set gl configuration for GLFW.\"\"\"\n    glfw.window_hint(glfw.RED_BITS, c['red_size'])\n    glfw.window_hint(glfw.GREEN_BITS, c['green_size'])\n    glfw.window_hint(glfw.BLUE_BITS, c['blue_size'])\n    glfw.window_hint(glfw.ALPHA_BITS, c['alpha_size'])\n\n    glfw.window_hint(glfw.ACCUM_RED_BITS, 0)\n    glfw.window_hint(glfw.ACCUM_GREEN_BITS, 0)\n    glfw.window_hint(glfw.ACCUM_BLUE_BITS, 0)\n    glfw.window_hint(glfw.ACCUM_ALPHA_BITS, 0)\n\n    glfw.window_hint(glfw.DEPTH_BITS, c['depth_size'])\n    glfw.window_hint(glfw.STENCIL_BITS, c['stencil_size'])\n    # glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, c['major_version'])\n    # glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, c['minor_version'])\n    # glfw.window_hint(glfw.SRGB_CAPABLE, c['srgb'])\n    glfw.window_hint(glfw.SAMPLES, c['samples'])\n    glfw.window_hint(glfw.STEREO, c['stereo'])\n    if not c['double_buffer']:\n        raise RuntimeError('GLFW must double buffer, consider using a '\n                           'different backend, or using double buffering')",
  "def _error_callback(num, descr):\n    _glfw_errors.append('Error %s: %s' % (num, descr))",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()\n\n    def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)\n\n    def _vispy_get_backend_name(self):\n        return 'Glfw'\n\n    def _vispy_process_events(self):\n        glfw.poll_events()\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_glfw_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()\n\n    def _vispy_run(self):\n        wins = _get_glfw_windows()\n        while any(w._id is not None and not glfw.window_should_close(w._id)\n                  for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()  # to clean up\n\n    def _vispy_quit(self):\n        # Close windows\n        wins = _get_glfw_windows()\n        for win in wins:\n            if win._vispy_canvas is not None:\n                win._vispy_canvas.close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []\n\n    def _vispy_get_native_app(self):\n        global _GLFW_INITIALIZED\n        if not _GLFW_INITIALIZED:\n            cwd = os.getcwd()\n            glfw.set_error_callback(_error_callback)\n            try:\n                if not glfw.init():  # only ever call once\n                    raise OSError('Could not init glfw:\\n%r' % _glfw_errors)\n            finally:\n                os.chdir(cwd)\n            glfw.set_error_callback(None)\n            atexit.register(glfw.terminate)\n            _GLFW_INITIALIZED = True\n        return glfw",
  "class CanvasBackend(BaseCanvasBackend):\n    \"\"\"Glfw backend for Canvas abstract class.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with config\n        _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('glfw', self)\n        if p.context.shared.ref is self:\n            share = None\n        else:\n            share = p.context.shared.ref._id\n\n        glfw.window_hint(glfw.REFRESH_RATE, 0)  # highest possible\n        glfw.window_hint(glfw.RESIZABLE, int(p.resizable))\n        glfw.window_hint(glfw.DECORATED, int(p.decorate))\n        glfw.window_hint(glfw.VISIBLE, 0)  # start out hidden\n        glfw.window_hint(glfw.FLOATING, int(p.always_on_top))\n        if p.fullscreen is not False:\n            self._fullscreen = True\n            if p.fullscreen is True:\n                monitor = glfw.get_primary_monitor()\n            else:\n                monitor = glfw.get_monitors()\n                if p.fullscreen >= len(monitor):\n                    raise ValueError('fullscreen must be <= %s'\n                                     % len(monitor))\n                monitor = monitor[p.fullscreen]\n            use_size = glfw.get_video_mode(monitor)[:2]\n            if use_size != tuple(p.size):\n                logger.debug('Requested size %s, will be ignored to '\n                             'use fullscreen mode %s' % (p.size, use_size))\n            size = use_size\n        else:\n            self._fullscreen = False\n            monitor = None\n            size = p.size\n\n        self._id = glfw.create_window(width=size[0], height=size[1],\n                                      title=p.title, monitor=monitor,\n                                      share=share)\n        if not self._id:\n            raise RuntimeError('Could not create window')\n\n        glfw.make_context_current(self._id)\n        glfw.swap_interval(1 if p.vsync else 0)  # needs a valid context\n\n        _VP_GLFW_ALL_WINDOWS.append(self)\n        self._mod = list()\n\n        # Register callbacks\n        glfw.set_window_refresh_callback(self._id, self._on_draw)\n        glfw.set_window_size_callback(self._id, self._on_resize)\n        glfw.set_key_callback(self._id, self._on_key_press)\n        glfw.set_char_callback(self._id, self._on_key_char)\n        glfw.set_mouse_button_callback(self._id, self._on_mouse_button)\n        glfw.set_scroll_callback(self._id, self._on_mouse_scroll)\n        glfw.set_cursor_pos_callback(self._id, self._on_mouse_motion)\n        glfw.set_window_close_callback(self._id, self._on_close)\n        self._vispy_canvas_ = None\n        self._needs_draw = False\n        self._vispy_canvas.set_current()\n        if p.position is not None:\n            self._vispy_set_position(*p.position)\n        if p.show:\n            glfw.show_window(self._id)\n\n        # Init\n        self._initialized = True\n        self._next_key_events = []\n        self._next_key_text = {}\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self._on_resize(self._id, size[0], size[1])\n\n    def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_set_current(self):\n        if self._id is None:\n            return\n        # Make this the current context\n        glfw.make_context_current(self._id)\n\n    def _vispy_swap_buffers(self):\n        if self._id is None:\n            return\n        # Swap front and back buffer\n        glfw.swap_buffers(self._id)\n\n    def _vispy_set_title(self, title):\n        if self._id is None:\n            return\n        # Set the window title. Has no effect for widgets\n        glfw.set_window_title(self._id, title)\n\n    def _vispy_set_size(self, w, h):\n        if self._id is None:\n            return\n        # Set size of the widget or window\n        glfw.set_window_size(self._id, w, h)\n\n    def _vispy_set_position(self, x, y):\n        if self._id is None:\n            return\n        # Set position of the widget or window. May have no effect for widgets\n        glfw.set_window_pos(self._id, x, y)\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if self._id is None:\n            return\n        if visible:\n            glfw.show_window(self._id)\n            # this ensures that the show takes effect\n            self._vispy_update()\n        else:\n            glfw.hide_window(self._id)\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        logger.warn('Cannot change fullscreen mode for GLFW backend')\n\n    def _vispy_update(self):\n        # Invoke a redraw, passing it on to the canvas\n        if self._vispy_canvas is None or self._id is None:\n            return\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        if self._id is not None:\n            self._vispy_canvas = None\n            # glfw.set_window_should_close()  # Does not really cause a close\n            self._vispy_set_visible(False)\n            self._id, id_ = None, self._id\n            glfw.destroy_window(id_)\n            gc.collect()  # help ensure context gets destroyed\n\n    def _vispy_get_size(self):\n        if self._id is None:\n            return\n        w, h = glfw.get_window_size(self._id)\n        return w, h\n\n    def _vispy_get_physical_size(self):\n        if self._id is None:\n            return\n        w, h = glfw.get_framebuffer_size(self._id)\n        return w, h\n\n    def _vispy_get_position(self):\n        if self._id is None:\n            return\n        x, y = glfw.get_window_pos(self._id)\n        return x, y\n\n    def _vispy_get_fullscreen(self):\n        return self._fullscreen\n\n    ##########################################\n    # Notify vispy of events triggered by GLFW\n    def _on_resize(self, _id, w, h):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.resize(\n            size=(w, h), physical_size=self._vispy_get_physical_size())\n\n    def _on_close(self, _id):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()\n\n    def _on_draw(self, _id=None):\n        if self._vispy_canvas is None or self._id is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)  # (0, 0, w, h))\n\n    def _on_mouse_button(self, _id, button, action, mod):\n        if self._vispy_canvas is None and self._id is not None:\n            return\n        pos = glfw.get_cursor_pos(self._id)\n        if button < 3:\n            # Mouse click event\n            button = BUTTONMAP.get(button, 0)\n            if action == glfw.PRESS:\n                fun = self._vispy_mouse_press\n            elif action == glfw.RELEASE:\n                fun = self._vispy_mouse_release\n            else:\n                return\n            fun(pos=pos, button=button, modifiers=self._mod)\n\n    def _on_mouse_scroll(self, _id, x_off, y_off):\n        if self._vispy_canvas is None and self._id is not None:\n            return\n        pos = glfw.get_cursor_pos(self._id)\n        delta = (float(x_off), float(y_off))\n        self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,\n                                              modifiers=self._mod)\n\n    def _on_mouse_motion(self, _id, x, y):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(pos=(x, y), modifiers=self._mod)\n\n    def _on_key_press(self, _id, key, scancode, action, mod):\n        if self._vispy_canvas is None:\n            return\n        key, text = self._process_key(key)\n        if action == glfw.PRESS:\n            fun = self._vispy_canvas.events.key_press\n            down = True\n        elif action == glfw.RELEASE:\n            fun = self._vispy_canvas.events.key_release\n            down = False\n        else:\n            return\n        self._process_mod(key, down=down)\n\n        # NOTE: GLFW only provides localized characters via _on_key_char, so if\n        # this event contains a character we store all other data and dispatch\n        # it once the final unicode character is sent shortly after.\n        if text != '' and action == glfw.PRESS:\n            self._next_key_events.append((fun, key, self._mod))\n        else:\n            if key in self._next_key_text:\n                text = self._next_key_text[key]\n                del self._next_key_text[key]\n            fun(key=key, text=text, modifiers=self._mod)\n\n    def _on_key_char(self, _id, text):\n        # Repeat strokes (frequency configured at OS) are sent here only,\n        # no regular _on_key_press events. Currently ignored!\n        if len(self._next_key_events) == 0:\n            return\n\n        (fun, key, mod) = self._next_key_events.pop(0)\n        fun(key=key, text=chr(text), modifiers=mod)\n        self._next_key_text[key] = text\n\n    def _process_key(self, key):\n        if 32 <= key <= 127:\n            return keys.Key(chr(key)), chr(key)\n        elif key in KEYMAP:\n            return KEYMAP[key], ''\n        else:\n            return None, ''\n\n    def _process_mod(self, key, down):\n        \"\"\"Process (possible) keyboard modifiers\n\n        GLFW provides \"mod\" with many callbacks, but not (critically) the\n        scroll callback, so we keep track on our own here.\n        \"\"\"\n        if key in MOD_KEYS:\n            if down:\n                if key not in self._mod:\n                    self._mod.append(key)\n            elif key in self._mod:\n                self._mod.pop(self._mod.index(key))\n        return self._mod",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()\n\n    def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval\n\n    def _vispy_stop(self):\n        self._next_time = float('inf')\n\n    def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()",
  "def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)",
  "def _vispy_get_backend_name(self):\n        return 'Glfw'",
  "def _vispy_process_events(self):\n        glfw.poll_events()\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_glfw_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()",
  "def _vispy_run(self):\n        wins = _get_glfw_windows()\n        while any(w._id is not None and not glfw.window_should_close(w._id)\n                  for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()",
  "def _vispy_quit(self):\n        # Close windows\n        wins = _get_glfw_windows()\n        for win in wins:\n            if win._vispy_canvas is not None:\n                win._vispy_canvas.close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []",
  "def _vispy_get_native_app(self):\n        global _GLFW_INITIALIZED\n        if not _GLFW_INITIALIZED:\n            cwd = os.getcwd()\n            glfw.set_error_callback(_error_callback)\n            try:\n                if not glfw.init():  # only ever call once\n                    raise OSError('Could not init glfw:\\n%r' % _glfw_errors)\n            finally:\n                os.chdir(cwd)\n            glfw.set_error_callback(None)\n            atexit.register(glfw.terminate)\n            _GLFW_INITIALIZED = True\n        return glfw",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with config\n        _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('glfw', self)\n        if p.context.shared.ref is self:\n            share = None\n        else:\n            share = p.context.shared.ref._id\n\n        glfw.window_hint(glfw.REFRESH_RATE, 0)  # highest possible\n        glfw.window_hint(glfw.RESIZABLE, int(p.resizable))\n        glfw.window_hint(glfw.DECORATED, int(p.decorate))\n        glfw.window_hint(glfw.VISIBLE, 0)  # start out hidden\n        glfw.window_hint(glfw.FLOATING, int(p.always_on_top))\n        if p.fullscreen is not False:\n            self._fullscreen = True\n            if p.fullscreen is True:\n                monitor = glfw.get_primary_monitor()\n            else:\n                monitor = glfw.get_monitors()\n                if p.fullscreen >= len(monitor):\n                    raise ValueError('fullscreen must be <= %s'\n                                     % len(monitor))\n                monitor = monitor[p.fullscreen]\n            use_size = glfw.get_video_mode(monitor)[:2]\n            if use_size != tuple(p.size):\n                logger.debug('Requested size %s, will be ignored to '\n                             'use fullscreen mode %s' % (p.size, use_size))\n            size = use_size\n        else:\n            self._fullscreen = False\n            monitor = None\n            size = p.size\n\n        self._id = glfw.create_window(width=size[0], height=size[1],\n                                      title=p.title, monitor=monitor,\n                                      share=share)\n        if not self._id:\n            raise RuntimeError('Could not create window')\n\n        glfw.make_context_current(self._id)\n        glfw.swap_interval(1 if p.vsync else 0)  # needs a valid context\n\n        _VP_GLFW_ALL_WINDOWS.append(self)\n        self._mod = list()\n\n        # Register callbacks\n        glfw.set_window_refresh_callback(self._id, self._on_draw)\n        glfw.set_window_size_callback(self._id, self._on_resize)\n        glfw.set_key_callback(self._id, self._on_key_press)\n        glfw.set_char_callback(self._id, self._on_key_char)\n        glfw.set_mouse_button_callback(self._id, self._on_mouse_button)\n        glfw.set_scroll_callback(self._id, self._on_mouse_scroll)\n        glfw.set_cursor_pos_callback(self._id, self._on_mouse_motion)\n        glfw.set_window_close_callback(self._id, self._on_close)\n        self._vispy_canvas_ = None\n        self._needs_draw = False\n        self._vispy_canvas.set_current()\n        if p.position is not None:\n            self._vispy_set_position(*p.position)\n        if p.show:\n            glfw.show_window(self._id)\n\n        # Init\n        self._initialized = True\n        self._next_key_events = []\n        self._next_key_text = {}\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self._on_resize(self._id, size[0], size[1])",
  "def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_set_current(self):\n        if self._id is None:\n            return\n        # Make this the current context\n        glfw.make_context_current(self._id)",
  "def _vispy_swap_buffers(self):\n        if self._id is None:\n            return\n        # Swap front and back buffer\n        glfw.swap_buffers(self._id)",
  "def _vispy_set_title(self, title):\n        if self._id is None:\n            return\n        # Set the window title. Has no effect for widgets\n        glfw.set_window_title(self._id, title)",
  "def _vispy_set_size(self, w, h):\n        if self._id is None:\n            return\n        # Set size of the widget or window\n        glfw.set_window_size(self._id, w, h)",
  "def _vispy_set_position(self, x, y):\n        if self._id is None:\n            return\n        # Set position of the widget or window. May have no effect for widgets\n        glfw.set_window_pos(self._id, x, y)",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if self._id is None:\n            return\n        if visible:\n            glfw.show_window(self._id)\n            # this ensures that the show takes effect\n            self._vispy_update()\n        else:\n            glfw.hide_window(self._id)",
  "def _vispy_set_fullscreen(self, fullscreen):\n        logger.warn('Cannot change fullscreen mode for GLFW backend')",
  "def _vispy_update(self):\n        # Invoke a redraw, passing it on to the canvas\n        if self._vispy_canvas is None or self._id is None:\n            return\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        if self._id is not None:\n            self._vispy_canvas = None\n            # glfw.set_window_should_close()  # Does not really cause a close\n            self._vispy_set_visible(False)\n            self._id, id_ = None, self._id\n            glfw.destroy_window(id_)\n            gc.collect()",
  "def _vispy_get_size(self):\n        if self._id is None:\n            return\n        w, h = glfw.get_window_size(self._id)\n        return w, h",
  "def _vispy_get_physical_size(self):\n        if self._id is None:\n            return\n        w, h = glfw.get_framebuffer_size(self._id)\n        return w, h",
  "def _vispy_get_position(self):\n        if self._id is None:\n            return\n        x, y = glfw.get_window_pos(self._id)\n        return x, y",
  "def _vispy_get_fullscreen(self):\n        return self._fullscreen",
  "def _on_resize(self, _id, w, h):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.resize(\n            size=(w, h), physical_size=self._vispy_get_physical_size())",
  "def _on_close(self, _id):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()",
  "def _on_draw(self, _id=None):\n        if self._vispy_canvas is None or self._id is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def _on_mouse_button(self, _id, button, action, mod):\n        if self._vispy_canvas is None and self._id is not None:\n            return\n        pos = glfw.get_cursor_pos(self._id)\n        if button < 3:\n            # Mouse click event\n            button = BUTTONMAP.get(button, 0)\n            if action == glfw.PRESS:\n                fun = self._vispy_mouse_press\n            elif action == glfw.RELEASE:\n                fun = self._vispy_mouse_release\n            else:\n                return\n            fun(pos=pos, button=button, modifiers=self._mod)",
  "def _on_mouse_scroll(self, _id, x_off, y_off):\n        if self._vispy_canvas is None and self._id is not None:\n            return\n        pos = glfw.get_cursor_pos(self._id)\n        delta = (float(x_off), float(y_off))\n        self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,\n                                              modifiers=self._mod)",
  "def _on_mouse_motion(self, _id, x, y):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(pos=(x, y), modifiers=self._mod)",
  "def _on_key_press(self, _id, key, scancode, action, mod):\n        if self._vispy_canvas is None:\n            return\n        key, text = self._process_key(key)\n        if action == glfw.PRESS:\n            fun = self._vispy_canvas.events.key_press\n            down = True\n        elif action == glfw.RELEASE:\n            fun = self._vispy_canvas.events.key_release\n            down = False\n        else:\n            return\n        self._process_mod(key, down=down)\n\n        # NOTE: GLFW only provides localized characters via _on_key_char, so if\n        # this event contains a character we store all other data and dispatch\n        # it once the final unicode character is sent shortly after.\n        if text != '' and action == glfw.PRESS:\n            self._next_key_events.append((fun, key, self._mod))\n        else:\n            if key in self._next_key_text:\n                text = self._next_key_text[key]\n                del self._next_key_text[key]\n            fun(key=key, text=text, modifiers=self._mod)",
  "def _on_key_char(self, _id, text):\n        # Repeat strokes (frequency configured at OS) are sent here only,\n        # no regular _on_key_press events. Currently ignored!\n        if len(self._next_key_events) == 0:\n            return\n\n        (fun, key, mod) = self._next_key_events.pop(0)\n        fun(key=key, text=chr(text), modifiers=mod)\n        self._next_key_text[key] = text",
  "def _process_key(self, key):\n        if 32 <= key <= 127:\n            return keys.Key(chr(key)), chr(key)\n        elif key in KEYMAP:\n            return KEYMAP[key], ''\n        else:\n            return None, ''",
  "def _process_mod(self, key, down):\n        \"\"\"Process (possible) keyboard modifiers\n\n        GLFW provides \"mod\" with many callbacks, but not (critically) the\n        scroll callback, so we keep track on our own here.\n        \"\"\"\n        if key in MOD_KEYS:\n            if down:\n                if key not in self._mod:\n                    self._mod.append(key)\n            elif key in self._mod:\n                self._mod.pop(self._mod.index(key))\n        return self._mod",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()",
  "def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval",
  "def _vispy_stop(self):\n        self._next_time = float('inf')",
  "def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def _get_egl_windows():\n    wins = list()\n    for win in _VP_EGL_ALL_WINDOWS:\n        if isinstance(win, CanvasBackend):\n            wins.append(win)\n    return wins",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()\n\n    def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)\n\n    def _vispy_get_backend_name(self):\n        return 'egl'\n\n    def _vispy_process_events(self):\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_egl_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()\n\n    def _vispy_run(self):\n        wins = _get_egl_windows()\n        while all(w._surface is not None for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()  # to clean up\n\n    def _vispy_quit(self):\n        # Close windows\n        wins = _get_egl_windows()\n        for win in wins:\n            win._vispy_close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []\n\n    def _vispy_get_native_app(self):\n        return egl",
  "class CanvasBackend(BaseCanvasBackend):\n    \"\"\"EGL backend for Canvas abstract class.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with context\n        p.context.shared.add_ref('egl', self)\n        if p.context.shared.ref is self:\n            # Store context information\n            attribs = [egl.EGL_RED_SIZE, 8,\n                       egl.EGL_BLUE_SIZE, 8,\n                       egl.EGL_GREEN_SIZE, 8,\n                       egl.EGL_ALPHA_SIZE, 8,\n                       egl.EGL_COLOR_BUFFER_TYPE, egl.EGL_RGB_BUFFER,\n                       egl.EGL_SURFACE_TYPE, egl.EGL_PBUFFER_BIT]\n            api = None\n            if 'es' in config['gl_backend']:\n                attribs.extend([egl.EGL_RENDERABLE_TYPE,\n                                egl.EGL_OPENGL_ES2_BIT])\n                api = egl.EGL_OPENGL_ES_API\n            else:\n                attribs.extend([egl.EGL_RENDERABLE_TYPE, egl.EGL_OPENGL_BIT])\n                api = egl.EGL_OPENGL_API\n\n            self._native_config = egl.eglChooseConfig(_EGL_DISPLAY, attribs)[0]\n            egl.eglBindAPI(api)\n            self._native_context = egl.eglCreateContext(_EGL_DISPLAY,\n                                                        self._native_config,\n                                                        None)\n        else:\n            # Reuse information from other context\n            self._native_config = p.context.shared.ref._native_config\n            self._native_context = p.context.shared.ref._native_context\n\n        self._surface = None\n        self._vispy_set_size(*p.size)\n        _VP_EGL_ALL_WINDOWS.append(self)\n\n        # Init\n        self._initialized = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n\n    def _destroy_surface(self):\n        if self._surface is not None:\n            egl.eglDestroySurface(_EGL_DISPLAY, self._surface)\n            self._surface = None\n\n    def _vispy_set_size(self, w, h):\n        if self._surface is not None:\n            self._destroy_surface()\n        attrib_list = (egl.EGL_WIDTH, w, egl.EGL_HEIGHT, h)\n        self._surface = egl.eglCreatePbufferSurface(_EGL_DISPLAY,\n                                                    self._native_config,\n                                                    attrib_list)\n        if self._surface == egl.EGL_NO_SURFACE:\n            raise RuntimeError('Could not create rendering surface')\n        self._size = (w, h)\n        self._vispy_update()\n\n    def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_set_current(self):\n        if self._surface is None:\n            return\n        # Make this the current context\n        egl.eglMakeCurrent(_EGL_DISPLAY, self._surface, self._surface,\n                           self._native_context)\n\n    def _vispy_swap_buffers(self):\n        if self._surface is None:\n            return\n        # Swap front and back buffer\n        egl.eglSwapBuffers(_EGL_DISPLAY, self._surface)\n\n    def _vispy_set_title(self, title):\n        pass\n\n    def _vispy_set_position(self, x, y):\n        pass\n\n    def _vispy_set_visible(self, visible):\n        pass\n\n    def _vispy_update(self):\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True\n\n    def _vispy_close(self):\n        self._destroy_surface()\n\n    def _vispy_get_size(self):\n        if self._surface is None:\n            return\n        return self._size\n\n    def _vispy_get_position(self):\n        return 0, 0\n\n    def _on_draw(self, _id=None):\n        # This is called by the processing app\n        if self._vispy_canvas is None or self._surface is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()\n\n    def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval\n\n    def _vispy_stop(self):\n        self._next_time = float('inf')\n\n    def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()",
  "def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)",
  "def _vispy_get_backend_name(self):\n        return 'egl'",
  "def _vispy_process_events(self):\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_egl_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()",
  "def _vispy_run(self):\n        wins = _get_egl_windows()\n        while all(w._surface is not None for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()",
  "def _vispy_quit(self):\n        # Close windows\n        wins = _get_egl_windows()\n        for win in wins:\n            win._vispy_close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []",
  "def _vispy_get_native_app(self):\n        return egl",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with context\n        p.context.shared.add_ref('egl', self)\n        if p.context.shared.ref is self:\n            # Store context information\n            attribs = [egl.EGL_RED_SIZE, 8,\n                       egl.EGL_BLUE_SIZE, 8,\n                       egl.EGL_GREEN_SIZE, 8,\n                       egl.EGL_ALPHA_SIZE, 8,\n                       egl.EGL_COLOR_BUFFER_TYPE, egl.EGL_RGB_BUFFER,\n                       egl.EGL_SURFACE_TYPE, egl.EGL_PBUFFER_BIT]\n            api = None\n            if 'es' in config['gl_backend']:\n                attribs.extend([egl.EGL_RENDERABLE_TYPE,\n                                egl.EGL_OPENGL_ES2_BIT])\n                api = egl.EGL_OPENGL_ES_API\n            else:\n                attribs.extend([egl.EGL_RENDERABLE_TYPE, egl.EGL_OPENGL_BIT])\n                api = egl.EGL_OPENGL_API\n\n            self._native_config = egl.eglChooseConfig(_EGL_DISPLAY, attribs)[0]\n            egl.eglBindAPI(api)\n            self._native_context = egl.eglCreateContext(_EGL_DISPLAY,\n                                                        self._native_config,\n                                                        None)\n        else:\n            # Reuse information from other context\n            self._native_config = p.context.shared.ref._native_config\n            self._native_context = p.context.shared.ref._native_context\n\n        self._surface = None\n        self._vispy_set_size(*p.size)\n        _VP_EGL_ALL_WINDOWS.append(self)\n\n        # Init\n        self._initialized = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()",
  "def _destroy_surface(self):\n        if self._surface is not None:\n            egl.eglDestroySurface(_EGL_DISPLAY, self._surface)\n            self._surface = None",
  "def _vispy_set_size(self, w, h):\n        if self._surface is not None:\n            self._destroy_surface()\n        attrib_list = (egl.EGL_WIDTH, w, egl.EGL_HEIGHT, h)\n        self._surface = egl.eglCreatePbufferSurface(_EGL_DISPLAY,\n                                                    self._native_config,\n                                                    attrib_list)\n        if self._surface == egl.EGL_NO_SURFACE:\n            raise RuntimeError('Could not create rendering surface')\n        self._size = (w, h)\n        self._vispy_update()",
  "def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_set_current(self):\n        if self._surface is None:\n            return\n        # Make this the current context\n        egl.eglMakeCurrent(_EGL_DISPLAY, self._surface, self._surface,\n                           self._native_context)",
  "def _vispy_swap_buffers(self):\n        if self._surface is None:\n            return\n        # Swap front and back buffer\n        egl.eglSwapBuffers(_EGL_DISPLAY, self._surface)",
  "def _vispy_set_title(self, title):\n        pass",
  "def _vispy_set_position(self, x, y):\n        pass",
  "def _vispy_set_visible(self, visible):\n        pass",
  "def _vispy_update(self):\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True",
  "def _vispy_close(self):\n        self._destroy_surface()",
  "def _vispy_get_size(self):\n        if self._surface is None:\n            return\n        return self._size",
  "def _vispy_get_position(self):\n        return 0, 0",
  "def _on_draw(self, _id=None):\n        # This is called by the processing app\n        if self._vispy_canvas is None or self._surface is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()",
  "def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval",
  "def _vispy_stop(self):\n        self._next_time = float('inf')",
  "def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "class OffscreenContext:\n    \"\"\" A helper class to provide an OpenGL context. This context is global\n    to the application.\n    \"\"\"\n\n    _global_instance = None\n    _canvas = None\n\n    @classmethod\n    def get_global_instance(cls):\n        \"\"\" Get a global context. Note that any assumptions about OpenGL state\n        being local will not hold.\n        \"\"\"\n        if cls._global_instance is None:\n            cls._global_instance = cls()\n        return cls._global_instance\n\n    def __init__(self):\n        if self._canvas is not None:\n            return  # already initialized\n\n        self._is_closed = False\n\n        # Glfw is probably the most lightweight approach, so let's try that.\n        # But there are two incompatible packages providing glfw :/\n        self.glfw = None\n        try:\n            import glfw\n        except ImportError:\n            pass\n        else:\n            need_from_glfw = [\"create_window\", \"make_context_current\"]\n            if all(hasattr(glfw, attr) for attr in need_from_glfw):\n                self.glfw = glfw\n\n        if self.glfw:\n            self.glfw.init()\n            self.glfw.window_hint(self.glfw.VISIBLE, 0)\n            self._canvas = self.glfw.create_window(1, 1, \"dummy window\", None, None)\n        else:\n            try:\n                _app = Application('default')\n            except Exception:\n                raise RuntimeError(\n                    \"Cannot find a backend to create an OpenGL context. \"\n                    \"Install e.g. PyQt5, PySide2, or `pip install glfw`.\"\n                )\n            self._canvas = Canvas(app=_app)\n            self._canvas.show(False)\n\n    def make_current(self):\n        \"\"\" Make this the currently active context.\n        \"\"\"\n        # If an application only used off-screen canvases this would technically\n        # have to be called just once. But note that an application/session\n        # could run both real canvases and off-screen ones.\n        if self.glfw:\n            self.glfw.make_context_current(self._canvas)\n        else:\n            self._canvas.set_current()\n\n    def close(self):\n        \"\"\" Close the context. \"\"\"\n        # Cannot close the global instance\n        if self is OffscreenContext._global_instance:\n            return\n        elif not self._is_closed:\n            self._is_closed = True\n            if self.glfw:\n                self.glfw.destroy_window(self._canvas)\n            else:\n                self._canvas.close()\n\n    def __del__(self):\n        self.close()",
  "class FrameBufferHelper:\n    \"\"\" Provides a canvas to render to, using an FBO.\n    \"\"\"\n\n    def __init__(self):\n        self._fbo = None\n        self._physical_size = 1, 1\n        self._fbo_size = -1, -1\n\n    def _ensure_fbo(self):\n        if self._fbo_size != self._physical_size:\n            self._fbo_size = self._physical_size\n            w, h = self._fbo_size\n            if self._fbo is None:\n                color_buffer = gloo.Texture2D((h, w, 4))\n                depth_buffer = gloo.RenderBuffer((h, w))\n                self._fbo = gloo.FrameBuffer(color_buffer, depth_buffer)\n            else:\n                self._fbo.resize((h, w))\n\n    def set_physical_size(self, w, h):\n        \"\"\" Set the physical size of the canvas.\n        \"\"\"\n        self._physical_size = w, h\n\n    def get_frame(self):\n        \"\"\" Call this within the with-context to obtain the frame buffer contents.\n        \"\"\"\n        return self._fbo.read()\n\n    def __enter__(self):\n        self._ensure_fbo()\n        return self._fbo.__enter__()\n\n    def __exit__(self, *args):\n        return self._fbo.__exit__(*args)",
  "def get_global_instance(cls):\n        \"\"\" Get a global context. Note that any assumptions about OpenGL state\n        being local will not hold.\n        \"\"\"\n        if cls._global_instance is None:\n            cls._global_instance = cls()\n        return cls._global_instance",
  "def __init__(self):\n        if self._canvas is not None:\n            return  # already initialized\n\n        self._is_closed = False\n\n        # Glfw is probably the most lightweight approach, so let's try that.\n        # But there are two incompatible packages providing glfw :/\n        self.glfw = None\n        try:\n            import glfw\n        except ImportError:\n            pass\n        else:\n            need_from_glfw = [\"create_window\", \"make_context_current\"]\n            if all(hasattr(glfw, attr) for attr in need_from_glfw):\n                self.glfw = glfw\n\n        if self.glfw:\n            self.glfw.init()\n            self.glfw.window_hint(self.glfw.VISIBLE, 0)\n            self._canvas = self.glfw.create_window(1, 1, \"dummy window\", None, None)\n        else:\n            try:\n                _app = Application('default')\n            except Exception:\n                raise RuntimeError(\n                    \"Cannot find a backend to create an OpenGL context. \"\n                    \"Install e.g. PyQt5, PySide2, or `pip install glfw`.\"\n                )\n            self._canvas = Canvas(app=_app)\n            self._canvas.show(False)",
  "def make_current(self):\n        \"\"\" Make this the currently active context.\n        \"\"\"\n        # If an application only used off-screen canvases this would technically\n        # have to be called just once. But note that an application/session\n        # could run both real canvases and off-screen ones.\n        if self.glfw:\n            self.glfw.make_context_current(self._canvas)\n        else:\n            self._canvas.set_current()",
  "def close(self):\n        \"\"\" Close the context. \"\"\"\n        # Cannot close the global instance\n        if self is OffscreenContext._global_instance:\n            return\n        elif not self._is_closed:\n            self._is_closed = True\n            if self.glfw:\n                self.glfw.destroy_window(self._canvas)\n            else:\n                self._canvas.close()",
  "def __del__(self):\n        self.close()",
  "def __init__(self):\n        self._fbo = None\n        self._physical_size = 1, 1\n        self._fbo_size = -1, -1",
  "def _ensure_fbo(self):\n        if self._fbo_size != self._physical_size:\n            self._fbo_size = self._physical_size\n            w, h = self._fbo_size\n            if self._fbo is None:\n                color_buffer = gloo.Texture2D((h, w, 4))\n                depth_buffer = gloo.RenderBuffer((h, w))\n                self._fbo = gloo.FrameBuffer(color_buffer, depth_buffer)\n            else:\n                self._fbo.resize((h, w))",
  "def set_physical_size(self, w, h):\n        \"\"\" Set the physical size of the canvas.\n        \"\"\"\n        self._physical_size = w, h",
  "def get_frame(self):\n        \"\"\" Call this within the with-context to obtain the frame buffer contents.\n        \"\"\"\n        return self._fbo.read()",
  "def __enter__(self):\n        self._ensure_fbo()\n        return self._fbo.__enter__()",
  "def __exit__(self, *args):\n        return self._fbo.__exit__(*args)",
  "def _set_config(config):\n    \"\"\"Set gl configuration\"\"\"\n    pyglet_config = pyglet.gl.Config()\n\n    pyglet_config.red_size = config['red_size']\n    pyglet_config.green_size = config['green_size']\n    pyglet_config.blue_size = config['blue_size']\n    pyglet_config.alpha_size = config['alpha_size']\n\n    pyglet_config.accum_red_size = 0\n    pyglet_config.accum_green_size = 0\n    pyglet_config.accum_blue_size = 0\n    pyglet_config.accum_alpha_size = 0\n\n    pyglet_config.depth_size = config['depth_size']\n    pyglet_config.stencil_size = config['stencil_size']\n    pyglet_config.double_buffer = config['double_buffer']\n    pyglet_config.stereo = config['stereo']\n    pyglet_config.samples = config['samples']\n    return pyglet_config",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n\n    def _vispy_get_backend_name(self):\n        return 'Pyglet'\n\n    def _vispy_process_events(self):\n        # pyglet.app.platform_event_loop.step(0.0)\n        pyglet.clock.tick()\n        for window in pyglet.app.windows:\n            window.switch_to()\n            window.dispatch_events()\n            window.dispatch_event('on_draw')\n\n    def _vispy_run(self):\n        return pyglet.app.run()\n\n    def _vispy_quit(self):\n        return pyglet.app.exit()\n\n    def _vispy_get_native_app(self):\n        return pyglet.app",
  "class CanvasBackend(BaseCanvasBackend, _Window):\n    \"\"\"Pyglet backend for Canvas abstract class.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        config = _set_config(p.context.config)  # Also used further below\n        # Deal with context\n        p.context.shared.add_ref('pyglet', self)\n        # contexts are shared by default in Pyglet\n\n        style = (pyglet.window.Window.WINDOW_STYLE_DEFAULT if p.decorate else\n                 pyglet.window.Window.WINDOW_STYLE_BORDERLESS)\n        # We keep track of modifier keys so we can pass them to mouse_motion\n        self._current_modifiers = set()\n        # self._buttons_accepted = 0\n        self._draw_ok = False  # whether it is ok to draw yet\n        self._pending_position = None\n        if p.fullscreen is not False:\n            screen = pyglet.window.get_platform().get_default_display()\n            self._vispy_fullscreen = True\n            if p.fullscreen is True:\n                self._vispy_screen = screen.get_default_screen()\n            else:\n                screen = screen.get_screens()\n                if p.fullscreen >= len(screen):\n                    raise RuntimeError('fullscreen must be < %s'\n                                       % len(screen))\n                self._vispy_screen = screen[p.fullscreen]\n        else:\n            self._vispy_fullscreen = False\n            self._vispy_screen = None\n        self._initialize_sent = False\n        pyglet.window.Window.__init__(self, width=p.size[0], height=p.size[1],\n                                      caption=p.title, visible=p.show,\n                                      config=config, vsync=p.vsync,\n                                      resizable=p.resizable, style=style,\n                                      screen=self._vispy_screen)\n        if p.position is not None:\n            self._vispy_set_position(*p.position)\n\n    def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    # Override these ...\n    def flip(self):\n        # Is called by event loop after each draw\n        pass\n\n    def on_draw(self):\n        # Is called by event loop after each event, whatever event ... really\n        if not self._draw_ok:\n            self._draw_ok = True\n            self.our_draw_func()\n\n    def draw_mouse_cursor(self):\n        # Prevent legacy OpenGL\n        pass\n\n    def _vispy_set_current(self):\n        # Make this the current context\n        self.switch_to()\n\n    def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        pyglet.window.Window.flip(self)\n\n    def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        self.set_caption(title)\n\n    def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        self.set_size(w, h)\n\n    def _vispy_set_position(self, x, y):\n        # Set positionof the widget or window. May have no effect for widgets\n        if self._draw_ok:\n            self.set_location(x, y)\n        else:\n            self._pending_position = x, y\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        self.set_visible(visible)\n\n    def _vispy_update(self):\n        # Invoke a redraw\n        pyglet.clock.schedule_once(self.our_draw_func, 0.0)\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        # In Pyglet close is equivalent to destroy (window becomes invalid)\n        self._vispy_canvas = None\n        self.close()\n\n    def _vispy_get_size(self):\n        w, h = self.get_size()\n        return w, h\n\n    def _vispy_get_physical_size(self):\n        if self._vispy_canvas is None:\n            return\n        w, h = self.get_framebuffer_size()\n        return w, h\n\n    def _vispy_get_position(self):\n        x, y = self.get_location()\n        return x, y\n\n    def _vispy_get_fullscreen(self):\n        return self._vispy_fullscreen\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        self._vispy_fullscreen = bool(fullscreen)\n        self.set_fullscreen(self._vispy_fullscreen, self._vispy_screen)\n\n    def on_show(self):\n        if self._vispy_canvas is None:\n            return\n        if not self._initialize_sent:\n            self._initialize_sent = True\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.events.initialize()\n        # Set location now if we must. For some reason we get weird\n        # offsets in viewport if set_location is called before the\n        # widget is shown.\n        if self._pending_position:\n            x, y = self._pending_position\n            self._pending_position = None\n            self.set_location(x, y)\n        # Redraw\n        self._vispy_update()\n\n    def on_close(self):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()\n\n    def on_resize(self, w, h):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.resize(size=(w, h))\n        # self._vispy_update()\n\n    def our_draw_func(self, dummy=None):\n        if not self._draw_ok or self._vispy_canvas is None:\n            return\n        # (0, 0, self.width, self.height))\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n\n    def on_mouse_press(self, x, y, button, modifiers=None):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_press(\n            pos=(x, self.get_size()[1] - y),\n            button=BUTTONMAP.get(button, 0),\n            modifiers=self._modifiers(),\n        )\n#         if ev2.handled:\n#             self._buttons_accepted |= button\n\n    def on_mouse_release(self, x, y, button, modifiers=None):\n        if self._vispy_canvas is None:\n            return\n        if True:  # (button & self._buttons_accepted) > 0:\n            self._vispy_mouse_release(\n                pos=(x, self.get_size()[1] - y),\n                button=BUTTONMAP.get(button, 0),\n                modifiers=self._modifiers(),\n            )\n            # self._buttons_accepted &= ~button\n\n    def on_mouse_motion(self, x, y, dx, dy):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            pos=(x, self.get_size()[1] - y),\n            modifiers=self._modifiers(),\n        )\n\n    def on_mouse_drag(self, x, y, dx, dy, button, modifiers):\n        self.on_mouse_motion(x, y, dx, dy)\n\n    def on_mouse_scroll(self, x, y, scroll_x, scroll_y):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.mouse_wheel(\n            delta=(float(scroll_x), float(scroll_y)),\n            pos=(x, self.get_size()[1] - y),\n            modifiers=self._modifiers(),\n        )\n\n    def on_key_press(self, key, modifiers):\n        # Process modifiers\n        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,\n                   pyglet.window.key.LALT, pyglet.window.key.RALT,\n                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):\n            self._current_modifiers.add(key)\n        # Emit\n        self._vispy_canvas.events.key_press(\n            key=self._processKey(key),\n            text='',  # Handlers that trigger on text wont see this event\n            modifiers=self._modifiers(modifiers))\n\n    def on_text(self, text):\n        # Typically this is called after on_key_press and before\n        # on_key_release\n        self._vispy_canvas.events.key_press(\n            key=None,  # Handlers that trigger on key wont see this event\n            text=text,\n            modifiers=self._modifiers())\n\n    def on_key_release(self, key, modifiers):\n        # Process modifiers\n        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,\n                   pyglet.window.key.LALT, pyglet.window.key.RALT,\n                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):\n            self._current_modifiers.discard(key)\n        # Get txt\n        try:\n            text = chr(key)\n        except Exception:\n            text = ''\n        # Emit\n        self._vispy_canvas.events.key_release(\n            key=self._processKey(key), text=text,\n            modifiers=self._modifiers(modifiers))\n\n    def _processKey(self, key):\n        if 97 <= key <= 122:\n            key -= 32\n        if key in KEYMAP:\n            return KEYMAP[key]\n        elif key >= 32 and key <= 127:\n            return keys.Key(chr(key))\n        else:\n            return None\n\n    def _modifiers(self, pygletmod=None):\n        mod = ()\n        if pygletmod is None:\n            pygletmod = self._current_modifiers\n        if isinstance(pygletmod, set):\n            for key in pygletmod:\n                mod += KEYMAP[key],\n        else:\n            if pygletmod & pyglet.window.key.MOD_SHIFT:\n                mod += keys.SHIFT,\n            if pygletmod & pyglet.window.key.MOD_CTRL:\n                mod += keys.CONTROL,\n            if pygletmod & pyglet.window.key.MOD_ALT:\n                mod += keys.ALT,\n        return mod",
  "class TimerBackend(BaseTimerBackend):\n\n    def _vispy_start(self, interval):\n        interval = self._vispy_timer._interval\n        if self._vispy_timer.max_iterations == 1:\n            pyglet.clock.schedule_once(self._vispy_timer._timeout, interval)\n        else:\n            # seems pyglet does not give the expected behavior when interval==0\n            if interval == 0:\n                interval = 1e-9\n            pyglet.clock.schedule_interval(\n                self._vispy_timer._timeout,\n                interval)\n\n    def _vispy_stop(self):\n        pyglet.clock.unschedule(self._vispy_timer._timeout)\n\n    def _vispy_get_native_timer(self):\n        return pyglet.clock",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)",
  "def _vispy_get_backend_name(self):\n        return 'Pyglet'",
  "def _vispy_process_events(self):\n        # pyglet.app.platform_event_loop.step(0.0)\n        pyglet.clock.tick()\n        for window in pyglet.app.windows:\n            window.switch_to()\n            window.dispatch_events()\n            window.dispatch_event('on_draw')",
  "def _vispy_run(self):\n        return pyglet.app.run()",
  "def _vispy_quit(self):\n        return pyglet.app.exit()",
  "def _vispy_get_native_app(self):\n        return pyglet.app",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        config = _set_config(p.context.config)  # Also used further below\n        # Deal with context\n        p.context.shared.add_ref('pyglet', self)\n        # contexts are shared by default in Pyglet\n\n        style = (pyglet.window.Window.WINDOW_STYLE_DEFAULT if p.decorate else\n                 pyglet.window.Window.WINDOW_STYLE_BORDERLESS)\n        # We keep track of modifier keys so we can pass them to mouse_motion\n        self._current_modifiers = set()\n        # self._buttons_accepted = 0\n        self._draw_ok = False  # whether it is ok to draw yet\n        self._pending_position = None\n        if p.fullscreen is not False:\n            screen = pyglet.window.get_platform().get_default_display()\n            self._vispy_fullscreen = True\n            if p.fullscreen is True:\n                self._vispy_screen = screen.get_default_screen()\n            else:\n                screen = screen.get_screens()\n                if p.fullscreen >= len(screen):\n                    raise RuntimeError('fullscreen must be < %s'\n                                       % len(screen))\n                self._vispy_screen = screen[p.fullscreen]\n        else:\n            self._vispy_fullscreen = False\n            self._vispy_screen = None\n        self._initialize_sent = False\n        pyglet.window.Window.__init__(self, width=p.size[0], height=p.size[1],\n                                      caption=p.title, visible=p.show,\n                                      config=config, vsync=p.vsync,\n                                      resizable=p.resizable, style=style,\n                                      screen=self._vispy_screen)\n        if p.position is not None:\n            self._vispy_set_position(*p.position)",
  "def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def flip(self):\n        # Is called by event loop after each draw\n        pass",
  "def on_draw(self):\n        # Is called by event loop after each event, whatever event ... really\n        if not self._draw_ok:\n            self._draw_ok = True\n            self.our_draw_func()",
  "def draw_mouse_cursor(self):\n        # Prevent legacy OpenGL\n        pass",
  "def _vispy_set_current(self):\n        # Make this the current context\n        self.switch_to()",
  "def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        pyglet.window.Window.flip(self)",
  "def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        self.set_caption(title)",
  "def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        self.set_size(w, h)",
  "def _vispy_set_position(self, x, y):\n        # Set positionof the widget or window. May have no effect for widgets\n        if self._draw_ok:\n            self.set_location(x, y)\n        else:\n            self._pending_position = x, y",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        self.set_visible(visible)",
  "def _vispy_update(self):\n        # Invoke a redraw\n        pyglet.clock.schedule_once(self.our_draw_func, 0.0)",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        # In Pyglet close is equivalent to destroy (window becomes invalid)\n        self._vispy_canvas = None\n        self.close()",
  "def _vispy_get_size(self):\n        w, h = self.get_size()\n        return w, h",
  "def _vispy_get_physical_size(self):\n        if self._vispy_canvas is None:\n            return\n        w, h = self.get_framebuffer_size()\n        return w, h",
  "def _vispy_get_position(self):\n        x, y = self.get_location()\n        return x, y",
  "def _vispy_get_fullscreen(self):\n        return self._vispy_fullscreen",
  "def _vispy_set_fullscreen(self, fullscreen):\n        self._vispy_fullscreen = bool(fullscreen)\n        self.set_fullscreen(self._vispy_fullscreen, self._vispy_screen)",
  "def on_show(self):\n        if self._vispy_canvas is None:\n            return\n        if not self._initialize_sent:\n            self._initialize_sent = True\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.events.initialize()\n        # Set location now if we must. For some reason we get weird\n        # offsets in viewport if set_location is called before the\n        # widget is shown.\n        if self._pending_position:\n            x, y = self._pending_position\n            self._pending_position = None\n            self.set_location(x, y)\n        # Redraw\n        self._vispy_update()",
  "def on_close(self):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.close()",
  "def on_resize(self, w, h):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.resize(size=(w, h))",
  "def our_draw_func(self, dummy=None):\n        if not self._draw_ok or self._vispy_canvas is None:\n            return\n        # (0, 0, self.width, self.height))\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def on_mouse_press(self, x, y, button, modifiers=None):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_press(\n            pos=(x, self.get_size()[1] - y),\n            button=BUTTONMAP.get(button, 0),\n            modifiers=self._modifiers(),\n        )",
  "def on_mouse_release(self, x, y, button, modifiers=None):\n        if self._vispy_canvas is None:\n            return\n        if True:  # (button & self._buttons_accepted) > 0:\n            self._vispy_mouse_release(\n                pos=(x, self.get_size()[1] - y),\n                button=BUTTONMAP.get(button, 0),\n                modifiers=self._modifiers(),\n            )",
  "def on_mouse_motion(self, x, y, dx, dy):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            pos=(x, self.get_size()[1] - y),\n            modifiers=self._modifiers(),\n        )",
  "def on_mouse_drag(self, x, y, dx, dy, button, modifiers):\n        self.on_mouse_motion(x, y, dx, dy)",
  "def on_mouse_scroll(self, x, y, scroll_x, scroll_y):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.mouse_wheel(\n            delta=(float(scroll_x), float(scroll_y)),\n            pos=(x, self.get_size()[1] - y),\n            modifiers=self._modifiers(),\n        )",
  "def on_key_press(self, key, modifiers):\n        # Process modifiers\n        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,\n                   pyglet.window.key.LALT, pyglet.window.key.RALT,\n                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):\n            self._current_modifiers.add(key)\n        # Emit\n        self._vispy_canvas.events.key_press(\n            key=self._processKey(key),\n            text='',  # Handlers that trigger on text wont see this event\n            modifiers=self._modifiers(modifiers))",
  "def on_text(self, text):\n        # Typically this is called after on_key_press and before\n        # on_key_release\n        self._vispy_canvas.events.key_press(\n            key=None,  # Handlers that trigger on key wont see this event\n            text=text,\n            modifiers=self._modifiers())",
  "def on_key_release(self, key, modifiers):\n        # Process modifiers\n        if key in (pyglet.window.key.LCTRL, pyglet.window.key.RCTRL,\n                   pyglet.window.key.LALT, pyglet.window.key.RALT,\n                   pyglet.window.key.LSHIFT, pyglet.window.key.RSHIFT):\n            self._current_modifiers.discard(key)\n        # Get txt\n        try:\n            text = chr(key)\n        except Exception:\n            text = ''\n        # Emit\n        self._vispy_canvas.events.key_release(\n            key=self._processKey(key), text=text,\n            modifiers=self._modifiers(modifiers))",
  "def _processKey(self, key):\n        if 97 <= key <= 122:\n            key -= 32\n        if key in KEYMAP:\n            return KEYMAP[key]\n        elif key >= 32 and key <= 127:\n            return keys.Key(chr(key))\n        else:\n            return None",
  "def _modifiers(self, pygletmod=None):\n        mod = ()\n        if pygletmod is None:\n            pygletmod = self._current_modifiers\n        if isinstance(pygletmod, set):\n            for key in pygletmod:\n                mod += KEYMAP[key],\n        else:\n            if pygletmod & pyglet.window.key.MOD_SHIFT:\n                mod += keys.SHIFT,\n            if pygletmod & pyglet.window.key.MOD_CTRL:\n                mod += keys.CONTROL,\n            if pygletmod & pyglet.window.key.MOD_ALT:\n                mod += keys.ALT,\n        return mod",
  "def _vispy_start(self, interval):\n        interval = self._vispy_timer._interval\n        if self._vispy_timer.max_iterations == 1:\n            pyglet.clock.schedule_once(self._vispy_timer._timeout, interval)\n        else:\n            # seems pyglet does not give the expected behavior when interval==0\n            if interval == 0:\n                interval = 1e-9\n            pyglet.clock.schedule_interval(\n                self._vispy_timer._timeout,\n                interval)",
  "def _vispy_stop(self):\n        pyglet.clock.unschedule(self._vispy_timer._timeout)",
  "def _vispy_get_native_timer(self):\n        return pyglet.clock",
  "class _Window(object):\n        pass",
  "def _set_config(c):\n    \"\"\"Set gl configuration for template.\n    Currently not used for Tkinter backend.\n    \"\"\"\n    return []",
  "class _TkInstanceManager:\n    _tk_inst = None         # Reference to tk.Tk instance\n    _tk_inst_owned = False  # Whether we created the Tk instance or not\n    _canvasses = []         # References to created CanvasBackends\n\n    @classmethod\n    def get_tk_instance(cls):\n        \"\"\"Return the Tk instance.\n\n        Returns\n        -------\n        tk.Tk\n            The tk.Tk instance.\n        \"\"\"\n        if cls._tk_inst is None:\n            if tk._default_root:\n                # There already is a tk.Tk() instance available\n                cls._tk_inst = tk._default_root\n                cls._tk_inst_owned = False\n            else:\n                # Create our own top level Tk instance\n                cls._tk_inst = tk.Tk()\n                cls._tk_inst.withdraw()\n                cls._tk_inst_owned = True\n        return cls._tk_inst\n\n    @classmethod\n    def get_canvasses(cls):\n        \"\"\"Return a list of CanvasBackends.\n\n        Returns\n        -------\n        list\n            A list with CanvasBackends.\n        \"\"\"\n        return cls._canvasses\n\n    @classmethod\n    def new_toplevel(cls, canvas, *args, **kwargs):\n        \"\"\"Create and return a new withdrawn Toplevel.\n        Create a tk.Toplevel with the given args and kwargs,\n        minimize it and add it to the list before returning\n\n        Parameters\n        ----------\n        canvas : CanvasBackend\n            The CanvasBackend instance that wants a new Toplevel.\n        *args\n            Variable length argument list.\n        **kwargs\n            Arbitrary keyword arguments.\n\n        Returns\n        -------\n        tk.Toplevel\n            Return the created tk.Toplevel\n        \"\"\"\n        tl = tk.Toplevel(cls._tk_inst, *args, **kwargs)\n        tl.withdraw()\n        cls._canvasses.append(canvas)\n        return tl\n\n    @classmethod\n    def del_toplevel(cls, canvas=None):\n        \"\"\"\n        Destroy the given Toplevel, and if it was the last one,\n        also destroy the Tk instance if we created it.\n\n        Parameters\n        ----------\n        canvas : CanvasBackend\n            The CanvasBackend to destroy, defaults to None.\n        \"\"\"\n        if canvas:\n            try:\n                canvas.destroy()\n                if canvas.top:\n                    canvas.top.destroy()\n                cls._canvasses.remove(canvas)\n            except Exception:\n                pass\n\n        # If there are no Toplevels left, quit the mainloop.\n        if cls._tk_inst and not cls._canvasses and cls._tk_inst_owned:\n            cls._tk_inst.quit()\n            cls._tk_inst.destroy()\n            cls._tk_inst = None",
  "class ApplicationBackend(BaseApplicationBackend):\n    def _vispy_get_backend_name(self):\n        \"\"\"\n        Returns\n        -------\n        str\n            The name of the backend.\n        \"\"\"\n        return tk.__name__\n\n    def _vispy_process_events(self):\n        \"\"\"Process events related to the spawned Tk application window.\n        First, update the Tk instance, then call `_delayed_update`\n        on every created Toplevel (to force a redraw), and process some Tkinter\n        GUI events by calling the Tk.mainloop and immediately exiting.\n        \"\"\"\n        # Update idle tasks first (probably not required)\n        app = self._vispy_get_native_app()\n        app.update_idletasks()\n\n        # Update every active Canvas window\n        for c in _TkInstanceManager.get_canvasses():\n            c._delayed_update()\n\n        # Process some events in the main Tkinter event loop\n        # And quit so we can continue elsewhere (call blocks normally)\n        app.after(0, lambda: app.quit())\n        app.mainloop()\n\n    def _vispy_run(self):\n        \"\"\"Start the Tk.mainloop. This will block until all Tk windows are destroyed.\"\"\"\n        self._vispy_get_native_app().mainloop()\n\n    def _vispy_quit(self):\n        \"\"\"Destroy each created Toplevel by calling _vispy_close on it.\n        If there are no Toplevels left, also destroy the Tk instance.\n        \"\"\"\n        for c in _TkInstanceManager.get_canvasses():\n            c._vispy_close()\n        _TkInstanceManager.del_toplevel()\n\n    def _vispy_get_native_app(self):\n        \"\"\"Get or create the Tk instance.\n\n        Returns\n        -------\n        tk.Tk\n            The tk.Tk instance.\n        \"\"\"\n        return _TkInstanceManager.get_tk_instance()",
  "class CanvasBackend(BaseCanvasBackend, OpenGLFrame):\n    \"\"\"Tkinter backend for Canvas abstract class.\n    Uses pyopengltk.OpenGLFrame as the internal tk.Frame instance that\n    is able to receive OpenGL draw commands and display the results,\n    while also being placeable in another Toplevel window.\n    \"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        self._double_click_supported = True\n\n        # Deal with config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('tk', self)\n        if p.context.shared.ref is self:\n            self._native_context = None\n        else:\n            self._native_context = p.context.shared.ref._native_context\n\n        # Pop args unrecognised by OpenGLFrame\n        kwargs.pop(\"parent\")\n        kwargs.pop(\"title\")\n        kwargs.pop(\"size\")\n        kwargs.pop(\"position\")\n        kwargs.pop(\"show\")\n        kwargs.pop(\"vsync\")\n        kwargs.pop(\"resizable\")\n        kwargs.pop(\"decorate\")\n        kwargs.pop(\"always_on_top\")\n        kwargs.pop(\"fullscreen\")\n        kwargs.pop(\"context\")\n\n        if p.parent is None:\n            # Create native window and top level\n            self.top = _TkInstanceManager.new_toplevel(self)\n\n            # Check input args and call appropriate set-up functions.\n            if p.title:\n                self._vispy_set_title(p.title)\n            if p.size:\n                self._vispy_set_size(p.size[0], p.size[1])\n            if p.position:\n                self._vispy_set_position(p.position[0], p.position[1])\n\n            self.top.update_idletasks()\n\n            if not p.resizable:\n                self.top.resizable(False, False)\n            if not p.decorate:\n                self.top.overrideredirect(True)\n            if p.always_on_top:\n                self.top.wm_attributes(\"-topmost\", \"True\")\n            self._fullscreen = bool(p.fullscreen)\n\n            self.top.protocol(\"WM_DELETE_WINDOW\", self._vispy_close)\n            parent = self.top\n        else:\n            # Use given parent as top level\n            self.top = None\n            parent = p.parent\n            self._fullscreen = False\n\n        self._init = False\n        self.is_destroyed = False\n        self._dynamic_keymap = {}\n\n        OpenGLFrame.__init__(self, parent, **kwargs)\n\n        if self.top:\n            # Embed canvas in top (new window) if this was created\n            self.top.configure(bg=\"black\")\n            self.pack(fill=tk.BOTH, expand=True)\n\n            # Also bind the key events to the top window instead.\n            self.top.bind(\"<Any-KeyPress>\", self._on_key_down)\n            self.top.bind(\"<Any-KeyRelease>\", self._on_key_up)\n        else:\n            # If no top, bind key events to the canvas itself.\n            self.bind(\"<Any-KeyPress>\", self._on_key_down)\n            self.bind(\"<Any-KeyRelease>\", self._on_key_up)\n\n        # Bind the other events to our internal methods.\n        self.bind(\"<Enter>\", self._on_mouse_enter)  # This also binds MouseWheel\n        self.bind(\"<Leave>\", self._on_mouse_leave)  # This also unbinds MouseWheel\n        self.bind(\"<Motion>\", self._on_mouse_move)\n        self.bind(\"<Any-Button>\", self._on_mouse_button_press)\n        self.bind(\"<Double-Any-Button>\", self._on_mouse_double_button_press)\n        self.bind(\"<Any-ButtonRelease>\", self._on_mouse_button_release)\n        self.bind(\"<Configure>\", self._on_configure, add='+')\n\n        self._vispy_set_visible(p.show)\n        self.focus_force()\n\n    def initgl(self):\n        \"\"\"Overridden from OpenGLFrame\n        Gets called on init or when the frame is remapped into its container.\n        \"\"\"\n        if not hasattr(self, \"_native_context\") or self._native_context is None:\n            # Workaround to get OpenGLFrame.__context for reference here\n            # if access would ever be needed from self._native_context.\n            # FIXME: Context sharing this way seems unsupported\n            self._native_context = vars(self).get(\"_CanvasBackend__context\", None)\n\n        self.update_idletasks()\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glClearColor(0.0, 0.0, 0.0, 0.0)\n\n    def redraw(self, *args):\n        \"\"\"Overridden from OpenGLFrame\n        Gets called when the OpenGLFrame redraws itself.\n        It will set the current buffer, call self.redraw() and\n        swap buffers afterwards.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if not self._init:\n            self._initialize()\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n\n    def _delayed_update(self):\n        \"\"\"\n        Expose a new frame to the canvas. This will call self.redraw() internally.\n\n        The self.animate sets the refresh rate in milliseconds. Using this is not\n        necessary because VisPy will use the TimerBackend to periodically call\n        self._vispy_update, resulting in the exact same behaviour.\n        So we set it to `0` to tell OpenGLFrame not to redraw itself on its own.\n        \"\"\"\n        if self.is_destroyed:\n            return\n        self.animate = 0\n        self.tkExpose(None)\n\n    def _on_configure(self, e):\n        \"\"\"Called when the frame get configured or resized.\"\"\"\n        if self._vispy_canvas is None or not self._init:\n            return\n        size_tup = e if isinstance(e, tuple) else (e.width, e.height)\n        self._vispy_canvas.events.resize(size=size_tup)\n\n    def _initialize(self):\n        \"\"\"Initialise the Canvas for drawing.\"\"\"\n        self.initgl()\n        if self._vispy_canvas is None:\n            return\n        self._init = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self.update_idletasks()\n        self._on_configure(self._vispy_get_size())\n\n    def _vispy_warmup(self):\n        \"\"\"Provided for VisPy tests, so they can 'warm the canvas up'.\n        Mostly taken from the wxWidgets backend.\n        \"\"\"\n        tk_inst = _TkInstanceManager.get_tk_instance()\n\n        etime = time() + 0.3\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n            tk_inst.after(0, lambda: tk_inst.quit())\n            tk_inst.mainloop()\n\n    def _parse_state(self, e):\n        \"\"\"Helper to parse event.state into modifier keys.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n\n        Returns\n        -------\n        list\n            A list of modifier keys that are active (from vispy's keys)\n        \"\"\"\n        return [key for mask, key in KEY_STATE_MAP.items() if e.state & mask]\n\n    def _parse_keys(self, e):\n        \"\"\"Helper to parse key states into Vispy keys.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n\n        Returns\n        -------\n        tuple\n            A tuple (key.Key(), chr(key)), which has the vispy key object and\n            the character representation if available.\n        \"\"\"\n        if e.keysym_num in KEYMAP:\n            return KEYMAP[e.keysym_num], \"\"\n        # e.char, e.keycode, e.keysym, e.keysym_num\n        if e.char:\n            self._dynamic_keymap[e.keycode] = e.char\n            return keys.Key(e.char), e.char\n\n        if e.keycode in self._dynamic_keymap:\n            char = self._dynamic_keymap[e.keycode]\n            return keys.Key(char), char\n\n        warnings.warn(\"The key you typed is not supported by the tkinter backend.\"\n                      \"Please map your functionality to a different key\")\n        return None, None\n\n    def _on_mouse_enter(self, e):\n        \"\"\"Event callback when the mouse enters the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if _tk_on_linux:\n            # On Linux, bind wheel as buttons instead\n            self.bind_all(\"<Button-4>\", self._on_mouse_wheel)\n            self.bind_all(\"<Button-5>\", self._on_mouse_wheel)\n        else:\n            # Other platforms, bind wheel event\n            # FIXME: What to do on Darwin?\n            self.bind_all(\"<MouseWheel>\", self._on_mouse_wheel)\n\n        self._vispy_mouse_move(\n            pos=(e.x, e.y), modifiers=self._parse_state(e))\n\n    def _on_mouse_leave(self, e):\n        \"\"\"Event callback when the mouse leaves the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Unbind mouse wheel events when not over the canvas any more.\n        if _tk_on_linux:\n            self.unbind_all(\"<Button-4>\")\n            self.unbind_all(\"<Button-5>\")\n        else:\n            self.unbind_all(\"<MouseWheel>\")\n\n    def _on_mouse_move(self, e):\n        \"\"\"Event callback when the mouse is moved within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            pos=(e.x, e.y), modifiers=self._parse_state(e))\n\n    def _on_mouse_wheel(self, e):\n        \"\"\"Event callback when the mouse wheel changes within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if _tk_on_linux:\n            # Fix mouse wheel delta\n            e.delta = {4: 120, 5: -120}.get(e.num, 0)\n        self._vispy_canvas.events.mouse_wheel(\n            delta=(0.0, float(e.delta / 120)),\n            pos=(e.x, e.y), modifiers=self._parse_state(e))\n\n    def _on_mouse_button_press(self, e):\n        \"\"\"Event callback when a mouse button is pressed within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_press(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))\n\n    def _vispy_detect_double_click(self, e):\n        \"\"\"Override base class function\n        since double click handling is native in Tk.\n        \"\"\"\n        pass\n\n    def _on_mouse_double_button_press(self, e):\n        \"\"\"Event callback when a mouse button is double clicked within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_double_click(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))\n\n    def _on_mouse_button_release(self, e):\n        \"\"\"Event callback when a mouse button is released within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_release(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))\n\n    def _on_key_down(self, e):\n        \"\"\"Event callback when a key is pressed within the canvas or window.\n\n        Ignore keys.ESCAPE if this is an embedded canvas,\n        as this would make it unresponsive (because it won't close the entire window),\n        while still being updateable.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        key, text = self._parse_keys(e)\n        if not self.top and key == keys.ESCAPE:\n            return\n        self._vispy_canvas.events.key_press(\n            key=key, text=text, modifiers=self._parse_state(e))\n\n    def _on_key_up(self, e):\n        \"\"\"Event callback when a key is released within the canvas or window.\n\n        Ignore keys.ESCAPE if this is an embedded canvas,\n        as this would make it unresponsive (because it won't close the entire window),\n        while still being updateable.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        key, text = self._parse_keys(e)\n        if not self.top and key == keys.ESCAPE:\n            return\n        self._vispy_canvas.events.key_release(\n            key=key, text=text, modifiers=self._parse_state(e))\n\n    def _vispy_set_current(self):\n        \"\"\"Make this the current context.\"\"\"\n        if not self.is_destroyed:\n            self.tkMakeCurrent()\n\n    def _vispy_swap_buffers(self):\n        \"\"\"Swap front and back buffer. This is done internally inside OpenGLFrame.\"\"\"\n        self._vispy_canvas.set_current()\n\n    def _vispy_set_title(self, title):\n        \"\"\"Set the window title. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.title(title)\n\n    def _vispy_set_size(self, w, h):\n        \"\"\"Set size of the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.geometry(f\"{w}x{h}\")\n\n    def _vispy_set_position(self, x, y):\n        \"\"\"Set location of the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.geometry(f\"+{x}+{y}\")\n\n    def _vispy_set_visible(self, visible):\n        \"\"\"Show or hide the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            if visible:\n                self.top.wm_deiconify()\n                self.top.lift()\n                self.top.attributes('-fullscreen', self._fullscreen)\n            else:\n                self.top.withdraw()\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        \"\"\"Set the current fullscreen state.\n\n        Has no effect for widgets. If you want it to become fullscreen,\n        while embedded in another Toplevel window, you should make that\n        window fullscreen instead.\n        \"\"\"\n        self._fullscreen = bool(fullscreen)\n        if self.top:\n            self._vispy_set_visible(True)\n\n    def _vispy_update(self):\n        \"\"\"Invoke a redraw\n\n        Delay this by letting Tk call it later, even a delay of 0 will do.\n        Doing this, prevents EventEmitter loops that are caused\n        by wanting to draw too fast.\n        \"\"\"\n        self.after(0, self._delayed_update)\n\n    def _vispy_close(self):\n        \"\"\"Force the window to close, destroying the canvas in the process.\n\n        When this was the last VisPy window, also quit the Tk instance.\n        This will not interfere if there is already another user window,\n        unrelated top VisPy open.\n        \"\"\"\n        if self.top and not self.is_destroyed:\n            self.is_destroyed = True\n            self._vispy_canvas.close()\n            _TkInstanceManager.del_toplevel(self)\n\n    def destroy(self):\n        \"\"\"Callback when the window gets closed.\n        Destroy the VisPy canvas by calling close on it.\n        \"\"\"\n        self._vispy_canvas.close()\n\n    def _vispy_get_size(self):\n        \"\"\"Return the actual size of the frame.\"\"\"\n        if self.top:\n            self.top.update_idletasks()\n        return self.winfo_width(), self.winfo_height()\n\n    def _vispy_get_position(self):\n        \"\"\"Return the widget or window position.\"\"\"\n        return self.winfo_x(), self.winfo_y()\n\n    def _vispy_get_fullscreen(self):\n        \"\"\"Return the last set full screen state, regardless if it's actually in that state.\n\n        When using the canvas as a widget, it will not go into fullscreen.\n        See _vispy_set_fullscreen\n        \"\"\"\n        return self._fullscreen",
  "class TimerBackend(BaseTimerBackend):\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        self._tk = _TkInstanceManager.get_tk_instance()\n        if self._tk is None:\n            raise Exception(\"TimerBackend: No toplevel?\")\n        self._id = None\n        self.last_interval = 1\n\n    def _vispy_start(self, interval):\n        \"\"\"Start the timer.\n        Use Tk.after to schedule timer events.\n        \"\"\"\n        self._vispy_stop()\n        self.last_interval = max(0, int(round(interval * 1000)))\n        self._id = self._tk.after(self.last_interval, self._vispy_timeout)\n\n    def _vispy_stop(self):\n        \"\"\"Stop the timer.\n        Unschedule the previous callback if it exists.\n        \"\"\"\n        if self._id is not None:\n            self._tk.after_cancel(self._id)\n            self._id = None\n\n    def _vispy_timeout(self):\n        \"\"\"Callback when the timer finishes.\n        Also reschedules the next callback.\n        \"\"\"\n        self._vispy_timer._timeout()\n        self._id = self._tk.after(self.last_interval, self._vispy_timeout)",
  "class OpenGLFrame(object):\n        pass",
  "def get_tk_instance(cls):\n        \"\"\"Return the Tk instance.\n\n        Returns\n        -------\n        tk.Tk\n            The tk.Tk instance.\n        \"\"\"\n        if cls._tk_inst is None:\n            if tk._default_root:\n                # There already is a tk.Tk() instance available\n                cls._tk_inst = tk._default_root\n                cls._tk_inst_owned = False\n            else:\n                # Create our own top level Tk instance\n                cls._tk_inst = tk.Tk()\n                cls._tk_inst.withdraw()\n                cls._tk_inst_owned = True\n        return cls._tk_inst",
  "def get_canvasses(cls):\n        \"\"\"Return a list of CanvasBackends.\n\n        Returns\n        -------\n        list\n            A list with CanvasBackends.\n        \"\"\"\n        return cls._canvasses",
  "def new_toplevel(cls, canvas, *args, **kwargs):\n        \"\"\"Create and return a new withdrawn Toplevel.\n        Create a tk.Toplevel with the given args and kwargs,\n        minimize it and add it to the list before returning\n\n        Parameters\n        ----------\n        canvas : CanvasBackend\n            The CanvasBackend instance that wants a new Toplevel.\n        *args\n            Variable length argument list.\n        **kwargs\n            Arbitrary keyword arguments.\n\n        Returns\n        -------\n        tk.Toplevel\n            Return the created tk.Toplevel\n        \"\"\"\n        tl = tk.Toplevel(cls._tk_inst, *args, **kwargs)\n        tl.withdraw()\n        cls._canvasses.append(canvas)\n        return tl",
  "def del_toplevel(cls, canvas=None):\n        \"\"\"\n        Destroy the given Toplevel, and if it was the last one,\n        also destroy the Tk instance if we created it.\n\n        Parameters\n        ----------\n        canvas : CanvasBackend\n            The CanvasBackend to destroy, defaults to None.\n        \"\"\"\n        if canvas:\n            try:\n                canvas.destroy()\n                if canvas.top:\n                    canvas.top.destroy()\n                cls._canvasses.remove(canvas)\n            except Exception:\n                pass\n\n        # If there are no Toplevels left, quit the mainloop.\n        if cls._tk_inst and not cls._canvasses and cls._tk_inst_owned:\n            cls._tk_inst.quit()\n            cls._tk_inst.destroy()\n            cls._tk_inst = None",
  "def _vispy_get_backend_name(self):\n        \"\"\"\n        Returns\n        -------\n        str\n            The name of the backend.\n        \"\"\"\n        return tk.__name__",
  "def _vispy_process_events(self):\n        \"\"\"Process events related to the spawned Tk application window.\n        First, update the Tk instance, then call `_delayed_update`\n        on every created Toplevel (to force a redraw), and process some Tkinter\n        GUI events by calling the Tk.mainloop and immediately exiting.\n        \"\"\"\n        # Update idle tasks first (probably not required)\n        app = self._vispy_get_native_app()\n        app.update_idletasks()\n\n        # Update every active Canvas window\n        for c in _TkInstanceManager.get_canvasses():\n            c._delayed_update()\n\n        # Process some events in the main Tkinter event loop\n        # And quit so we can continue elsewhere (call blocks normally)\n        app.after(0, lambda: app.quit())\n        app.mainloop()",
  "def _vispy_run(self):\n        \"\"\"Start the Tk.mainloop. This will block until all Tk windows are destroyed.\"\"\"\n        self._vispy_get_native_app().mainloop()",
  "def _vispy_quit(self):\n        \"\"\"Destroy each created Toplevel by calling _vispy_close on it.\n        If there are no Toplevels left, also destroy the Tk instance.\n        \"\"\"\n        for c in _TkInstanceManager.get_canvasses():\n            c._vispy_close()\n        _TkInstanceManager.del_toplevel()",
  "def _vispy_get_native_app(self):\n        \"\"\"Get or create the Tk instance.\n\n        Returns\n        -------\n        tk.Tk\n            The tk.Tk instance.\n        \"\"\"\n        return _TkInstanceManager.get_tk_instance()",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n\n        self._double_click_supported = True\n\n        # Deal with config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('tk', self)\n        if p.context.shared.ref is self:\n            self._native_context = None\n        else:\n            self._native_context = p.context.shared.ref._native_context\n\n        # Pop args unrecognised by OpenGLFrame\n        kwargs.pop(\"parent\")\n        kwargs.pop(\"title\")\n        kwargs.pop(\"size\")\n        kwargs.pop(\"position\")\n        kwargs.pop(\"show\")\n        kwargs.pop(\"vsync\")\n        kwargs.pop(\"resizable\")\n        kwargs.pop(\"decorate\")\n        kwargs.pop(\"always_on_top\")\n        kwargs.pop(\"fullscreen\")\n        kwargs.pop(\"context\")\n\n        if p.parent is None:\n            # Create native window and top level\n            self.top = _TkInstanceManager.new_toplevel(self)\n\n            # Check input args and call appropriate set-up functions.\n            if p.title:\n                self._vispy_set_title(p.title)\n            if p.size:\n                self._vispy_set_size(p.size[0], p.size[1])\n            if p.position:\n                self._vispy_set_position(p.position[0], p.position[1])\n\n            self.top.update_idletasks()\n\n            if not p.resizable:\n                self.top.resizable(False, False)\n            if not p.decorate:\n                self.top.overrideredirect(True)\n            if p.always_on_top:\n                self.top.wm_attributes(\"-topmost\", \"True\")\n            self._fullscreen = bool(p.fullscreen)\n\n            self.top.protocol(\"WM_DELETE_WINDOW\", self._vispy_close)\n            parent = self.top\n        else:\n            # Use given parent as top level\n            self.top = None\n            parent = p.parent\n            self._fullscreen = False\n\n        self._init = False\n        self.is_destroyed = False\n        self._dynamic_keymap = {}\n\n        OpenGLFrame.__init__(self, parent, **kwargs)\n\n        if self.top:\n            # Embed canvas in top (new window) if this was created\n            self.top.configure(bg=\"black\")\n            self.pack(fill=tk.BOTH, expand=True)\n\n            # Also bind the key events to the top window instead.\n            self.top.bind(\"<Any-KeyPress>\", self._on_key_down)\n            self.top.bind(\"<Any-KeyRelease>\", self._on_key_up)\n        else:\n            # If no top, bind key events to the canvas itself.\n            self.bind(\"<Any-KeyPress>\", self._on_key_down)\n            self.bind(\"<Any-KeyRelease>\", self._on_key_up)\n\n        # Bind the other events to our internal methods.\n        self.bind(\"<Enter>\", self._on_mouse_enter)  # This also binds MouseWheel\n        self.bind(\"<Leave>\", self._on_mouse_leave)  # This also unbinds MouseWheel\n        self.bind(\"<Motion>\", self._on_mouse_move)\n        self.bind(\"<Any-Button>\", self._on_mouse_button_press)\n        self.bind(\"<Double-Any-Button>\", self._on_mouse_double_button_press)\n        self.bind(\"<Any-ButtonRelease>\", self._on_mouse_button_release)\n        self.bind(\"<Configure>\", self._on_configure, add='+')\n\n        self._vispy_set_visible(p.show)\n        self.focus_force()",
  "def initgl(self):\n        \"\"\"Overridden from OpenGLFrame\n        Gets called on init or when the frame is remapped into its container.\n        \"\"\"\n        if not hasattr(self, \"_native_context\") or self._native_context is None:\n            # Workaround to get OpenGLFrame.__context for reference here\n            # if access would ever be needed from self._native_context.\n            # FIXME: Context sharing this way seems unsupported\n            self._native_context = vars(self).get(\"_CanvasBackend__context\", None)\n\n        self.update_idletasks()\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glClearColor(0.0, 0.0, 0.0, 0.0)",
  "def redraw(self, *args):\n        \"\"\"Overridden from OpenGLFrame\n        Gets called when the OpenGLFrame redraws itself.\n        It will set the current buffer, call self.redraw() and\n        swap buffers afterwards.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if not self._init:\n            self._initialize()\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def _delayed_update(self):\n        \"\"\"\n        Expose a new frame to the canvas. This will call self.redraw() internally.\n\n        The self.animate sets the refresh rate in milliseconds. Using this is not\n        necessary because VisPy will use the TimerBackend to periodically call\n        self._vispy_update, resulting in the exact same behaviour.\n        So we set it to `0` to tell OpenGLFrame not to redraw itself on its own.\n        \"\"\"\n        if self.is_destroyed:\n            return\n        self.animate = 0\n        self.tkExpose(None)",
  "def _on_configure(self, e):\n        \"\"\"Called when the frame get configured or resized.\"\"\"\n        if self._vispy_canvas is None or not self._init:\n            return\n        size_tup = e if isinstance(e, tuple) else (e.width, e.height)\n        self._vispy_canvas.events.resize(size=size_tup)",
  "def _initialize(self):\n        \"\"\"Initialise the Canvas for drawing.\"\"\"\n        self.initgl()\n        if self._vispy_canvas is None:\n            return\n        self._init = True\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        self.update_idletasks()\n        self._on_configure(self._vispy_get_size())",
  "def _vispy_warmup(self):\n        \"\"\"Provided for VisPy tests, so they can 'warm the canvas up'.\n        Mostly taken from the wxWidgets backend.\n        \"\"\"\n        tk_inst = _TkInstanceManager.get_tk_instance()\n\n        etime = time() + 0.3\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n            tk_inst.after(0, lambda: tk_inst.quit())\n            tk_inst.mainloop()",
  "def _parse_state(self, e):\n        \"\"\"Helper to parse event.state into modifier keys.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n\n        Returns\n        -------\n        list\n            A list of modifier keys that are active (from vispy's keys)\n        \"\"\"\n        return [key for mask, key in KEY_STATE_MAP.items() if e.state & mask]",
  "def _parse_keys(self, e):\n        \"\"\"Helper to parse key states into Vispy keys.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n\n        Returns\n        -------\n        tuple\n            A tuple (key.Key(), chr(key)), which has the vispy key object and\n            the character representation if available.\n        \"\"\"\n        if e.keysym_num in KEYMAP:\n            return KEYMAP[e.keysym_num], \"\"\n        # e.char, e.keycode, e.keysym, e.keysym_num\n        if e.char:\n            self._dynamic_keymap[e.keycode] = e.char\n            return keys.Key(e.char), e.char\n\n        if e.keycode in self._dynamic_keymap:\n            char = self._dynamic_keymap[e.keycode]\n            return keys.Key(char), char\n\n        warnings.warn(\"The key you typed is not supported by the tkinter backend.\"\n                      \"Please map your functionality to a different key\")\n        return None, None",
  "def _on_mouse_enter(self, e):\n        \"\"\"Event callback when the mouse enters the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if _tk_on_linux:\n            # On Linux, bind wheel as buttons instead\n            self.bind_all(\"<Button-4>\", self._on_mouse_wheel)\n            self.bind_all(\"<Button-5>\", self._on_mouse_wheel)\n        else:\n            # Other platforms, bind wheel event\n            # FIXME: What to do on Darwin?\n            self.bind_all(\"<MouseWheel>\", self._on_mouse_wheel)\n\n        self._vispy_mouse_move(\n            pos=(e.x, e.y), modifiers=self._parse_state(e))",
  "def _on_mouse_leave(self, e):\n        \"\"\"Event callback when the mouse leaves the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Unbind mouse wheel events when not over the canvas any more.\n        if _tk_on_linux:\n            self.unbind_all(\"<Button-4>\")\n            self.unbind_all(\"<Button-5>\")\n        else:\n            self.unbind_all(\"<MouseWheel>\")",
  "def _on_mouse_move(self, e):\n        \"\"\"Event callback when the mouse is moved within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            pos=(e.x, e.y), modifiers=self._parse_state(e))",
  "def _on_mouse_wheel(self, e):\n        \"\"\"Event callback when the mouse wheel changes within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        if _tk_on_linux:\n            # Fix mouse wheel delta\n            e.delta = {4: 120, 5: -120}.get(e.num, 0)\n        self._vispy_canvas.events.mouse_wheel(\n            delta=(0.0, float(e.delta / 120)),\n            pos=(e.x, e.y), modifiers=self._parse_state(e))",
  "def _on_mouse_button_press(self, e):\n        \"\"\"Event callback when a mouse button is pressed within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_press(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))",
  "def _vispy_detect_double_click(self, e):\n        \"\"\"Override base class function\n        since double click handling is native in Tk.\n        \"\"\"\n        pass",
  "def _on_mouse_double_button_press(self, e):\n        \"\"\"Event callback when a mouse button is double clicked within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_double_click(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))",
  "def _on_mouse_button_release(self, e):\n        \"\"\"Event callback when a mouse button is released within the canvas.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        # Ignore MouseWheel on linux\n        if _tk_on_linux and e.num in (4, 5):\n            return\n        self._vispy_mouse_release(\n            pos=(e.x, e.y), button=MOUSE_BUTTON_MAP.get(e.num, e.num), modifiers=self._parse_state(e))",
  "def _on_key_down(self, e):\n        \"\"\"Event callback when a key is pressed within the canvas or window.\n\n        Ignore keys.ESCAPE if this is an embedded canvas,\n        as this would make it unresponsive (because it won't close the entire window),\n        while still being updateable.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        key, text = self._parse_keys(e)\n        if not self.top and key == keys.ESCAPE:\n            return\n        self._vispy_canvas.events.key_press(\n            key=key, text=text, modifiers=self._parse_state(e))",
  "def _on_key_up(self, e):\n        \"\"\"Event callback when a key is released within the canvas or window.\n\n        Ignore keys.ESCAPE if this is an embedded canvas,\n        as this would make it unresponsive (because it won't close the entire window),\n        while still being updateable.\n\n        Parameters\n        ----------\n        e : tk.Event\n            The passed in Event.\n        \"\"\"\n        if self._vispy_canvas is None:\n            return\n        key, text = self._parse_keys(e)\n        if not self.top and key == keys.ESCAPE:\n            return\n        self._vispy_canvas.events.key_release(\n            key=key, text=text, modifiers=self._parse_state(e))",
  "def _vispy_set_current(self):\n        \"\"\"Make this the current context.\"\"\"\n        if not self.is_destroyed:\n            self.tkMakeCurrent()",
  "def _vispy_swap_buffers(self):\n        \"\"\"Swap front and back buffer. This is done internally inside OpenGLFrame.\"\"\"\n        self._vispy_canvas.set_current()",
  "def _vispy_set_title(self, title):\n        \"\"\"Set the window title. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.title(title)",
  "def _vispy_set_size(self, w, h):\n        \"\"\"Set size of the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.geometry(f\"{w}x{h}\")",
  "def _vispy_set_position(self, x, y):\n        \"\"\"Set location of the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            self.top.geometry(f\"+{x}+{y}\")",
  "def _vispy_set_visible(self, visible):\n        \"\"\"Show or hide the window. Has no effect for widgets.\"\"\"\n        if self.top:\n            if visible:\n                self.top.wm_deiconify()\n                self.top.lift()\n                self.top.attributes('-fullscreen', self._fullscreen)\n            else:\n                self.top.withdraw()",
  "def _vispy_set_fullscreen(self, fullscreen):\n        \"\"\"Set the current fullscreen state.\n\n        Has no effect for widgets. If you want it to become fullscreen,\n        while embedded in another Toplevel window, you should make that\n        window fullscreen instead.\n        \"\"\"\n        self._fullscreen = bool(fullscreen)\n        if self.top:\n            self._vispy_set_visible(True)",
  "def _vispy_update(self):\n        \"\"\"Invoke a redraw\n\n        Delay this by letting Tk call it later, even a delay of 0 will do.\n        Doing this, prevents EventEmitter loops that are caused\n        by wanting to draw too fast.\n        \"\"\"\n        self.after(0, self._delayed_update)",
  "def _vispy_close(self):\n        \"\"\"Force the window to close, destroying the canvas in the process.\n\n        When this was the last VisPy window, also quit the Tk instance.\n        This will not interfere if there is already another user window,\n        unrelated top VisPy open.\n        \"\"\"\n        if self.top and not self.is_destroyed:\n            self.is_destroyed = True\n            self._vispy_canvas.close()\n            _TkInstanceManager.del_toplevel(self)",
  "def destroy(self):\n        \"\"\"Callback when the window gets closed.\n        Destroy the VisPy canvas by calling close on it.\n        \"\"\"\n        self._vispy_canvas.close()",
  "def _vispy_get_size(self):\n        \"\"\"Return the actual size of the frame.\"\"\"\n        if self.top:\n            self.top.update_idletasks()\n        return self.winfo_width(), self.winfo_height()",
  "def _vispy_get_position(self):\n        \"\"\"Return the widget or window position.\"\"\"\n        return self.winfo_x(), self.winfo_y()",
  "def _vispy_get_fullscreen(self):\n        \"\"\"Return the last set full screen state, regardless if it's actually in that state.\n\n        When using the canvas as a widget, it will not go into fullscreen.\n        See _vispy_set_fullscreen\n        \"\"\"\n        return self._fullscreen",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        self._tk = _TkInstanceManager.get_tk_instance()\n        if self._tk is None:\n            raise Exception(\"TimerBackend: No toplevel?\")\n        self._id = None\n        self.last_interval = 1",
  "def _vispy_start(self, interval):\n        \"\"\"Start the timer.\n        Use Tk.after to schedule timer events.\n        \"\"\"\n        self._vispy_stop()\n        self.last_interval = max(0, int(round(interval * 1000)))\n        self._id = self._tk.after(self.last_interval, self._vispy_timeout)",
  "def _vispy_stop(self):\n        \"\"\"Stop the timer.\n        Unschedule the previous callback if it exists.\n        \"\"\"\n        if self._id is not None:\n            self._tk.after_cancel(self._id)\n            self._id = None",
  "def _vispy_timeout(self):\n        \"\"\"Callback when the timer finishes.\n        Also reschedules the next callback.\n        \"\"\"\n        self._vispy_timer._timeout()\n        self._id = self._tk.after(self.last_interval, self._vispy_timeout)",
  "def _get_sdl2_windows():\n    return list(_VP_SDL2_ALL_WINDOWS.values())",
  "def _set_config(c):\n    \"\"\"Set gl configuration for SDL2\"\"\"\n    func = sdl2.SDL_GL_SetAttribute\n    func(sdl2.SDL_GL_RED_SIZE, c['red_size'])\n    func(sdl2.SDL_GL_GREEN_SIZE, c['green_size'])\n    func(sdl2.SDL_GL_BLUE_SIZE, c['blue_size'])\n    func(sdl2.SDL_GL_ALPHA_SIZE, c['alpha_size'])\n    func(sdl2.SDL_GL_DEPTH_SIZE, c['depth_size'])\n    func(sdl2.SDL_GL_STENCIL_SIZE, c['stencil_size'])\n    func(sdl2.SDL_GL_DOUBLEBUFFER, 1 if c['double_buffer'] else 0)\n    samps = c['samples']\n    func(sdl2.SDL_GL_MULTISAMPLEBUFFERS, 1 if samps > 0 else 0)\n    func(sdl2.SDL_GL_MULTISAMPLESAMPLES, samps if samps > 0 else 0)\n    func(sdl2.SDL_GL_STEREO, c['stereo'])",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()\n\n    def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)\n\n    def _vispy_get_backend_name(self):\n        return 'SDL2'\n\n    def _vispy_process_events(self):\n        events = sdl2.ext.get_events()\n        while len(events) > 0:\n            for event in events:\n                _id = event.window.windowID\n                if _id in _VP_SDL2_ALL_WINDOWS:\n                    win = _VP_SDL2_ALL_WINDOWS[_id]\n                    win._on_event(event)\n            events = sdl2.ext.get_events()\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_sdl2_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()\n\n    def _vispy_run(self):\n        wins = _get_sdl2_windows()\n        while any(w._id is not None for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()  # to clean up\n\n    def _vispy_quit(self):\n        # Close windows\n        wins = _get_sdl2_windows()\n        for win in wins:\n            win._vispy_close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []\n\n    def _vispy_get_native_app(self):\n        global _SDL2_INITIALIZED\n        if not _SDL2_INITIALIZED:\n            sdl2.ext.init()\n            atexit.register(sdl2.ext.quit)\n            _SDL2_INITIALIZED = True\n        return sdl2",
  "class CanvasBackend(BaseCanvasBackend):\n    \"\"\"SDL2 backend for Canvas abstract class.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with config\n        _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('sdl2', self)\n        if p.context.shared.ref is self:\n            share = None\n        else:\n            other = p.context.shared.ref\n            share = other._id.window, other._native_context\n            sdl2.SDL_GL_MakeCurrent(*share)\n            sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1)\n\n        sdl2.SDL_GL_SetSwapInterval(1 if p.vsync else 0)\n        flags = sdl2.SDL_WINDOW_OPENGL\n        flags |= sdl2.SDL_WINDOW_SHOWN  # start out shown\n        flags |= sdl2.SDL_WINDOW_ALLOW_HIGHDPI\n        flags |= sdl2.SDL_WINDOW_RESIZABLE if p.resizable else 0\n        flags |= sdl2.SDL_WINDOW_BORDERLESS if not p.decorate else 0\n        if p.fullscreen is not False:\n            self._fullscreen = True\n            if p.fullscreen is not True:\n                logger.warning('Cannot specify monitor number for SDL2 '\n                               'fullscreen, using default')\n            flags |= sdl2.SDL_WINDOW_FULLSCREEN_DESKTOP\n        else:\n            self._fullscreen = False\n        self._mods = list()\n        if p.position is None:\n            position = [sdl2.SDL_WINDOWPOS_UNDEFINED] * 2\n        else:\n            position = None\n        self._id = sdl2.ext.Window(p.title, p.size, position, flags)\n        if not self._id.window:\n            raise RuntimeError('Could not create window')\n        if share is None:\n            self._native_context = sdl2.SDL_GL_CreateContext(self._id.window)\n        else:\n            self._native_context = sdl2.SDL_GL_CreateContext(share[0])\n        self._sdl_id = sdl2.SDL_GetWindowID(self._id.window)\n        _VP_SDL2_ALL_WINDOWS[self._sdl_id] = self\n\n        # Init\n        self._initialized = True\n        self._needs_draw = False\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        if not p.show:\n            self._vispy_set_visible(False)\n\n    def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_set_current(self):\n        if self._id is None:\n            return\n        # Make this the current context\n        sdl2.SDL_GL_MakeCurrent(self._id.window, self._native_context)\n\n    def _vispy_swap_buffers(self):\n        if self._id is None:\n            return\n        # Swap front and back buffer\n        sdl2.SDL_GL_SwapWindow(self._id.window)\n\n    def _vispy_set_title(self, title):\n        if self._id is None:\n            return\n        # Set the window title. Has no effect for widgets\n        sdl2.SDL_SetWindowTitle(self._id.window, title.encode('UTF-8'))\n\n    def _vispy_set_size(self, w, h):\n        if self._id is None:\n            return\n        # Set size of the widget or window\n        sdl2.SDL_SetWindowSize(self._id.window, w, h)\n\n    def _vispy_set_position(self, x, y):\n        if self._id is None:\n            return\n        # Set position of the widget or window. May have no effect for widgets\n        sdl2.SDL_SetWindowPosition(self._id.window, x, y)\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if self._id is None:\n            return\n        if visible:\n            self._id.show()\n            # this ensures that the show takes effect\n            self._vispy_update()\n        else:\n            self._id.hide()\n\n    def _vispy_update(self):\n        # Invoke a redraw, passing it on to the canvas\n        if self._vispy_canvas is None or self._id is None:\n            return\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        if self._id is not None:\n            _id = self._id.window\n            self._vispy_canvas = None\n            self._id = None\n            sdl2.SDL_DestroyWindow(_id)\n            del _VP_SDL2_ALL_WINDOWS[self._sdl_id]\n            self._sdl_id = None\n            gc.collect()  # enforce gc to help context get destroyed\n\n    def _vispy_get_size(self):\n        if self._id is None:\n            return\n        w, h = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetWindowSize(self._id.window,\n                               ctypes.byref(w), ctypes.byref(h))\n        w, h = w.value, h.value\n        return w, h\n\n    def _vispy_get_fullscreen(self):\n        return self._fullscreen\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        self._fullscreen = bool(fullscreen)\n        flags = sdl2.SDL_WINDOW_FULLSCREEN_DESKTOP if self._fullscreen else 0\n        sdl2.SDL_SetWindowFullscreen(self._id.window, flags)\n\n    def _vispy_get_position(self):\n        if self._id is None:\n            return\n        x, y = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetWindowPosition(self._id.window,\n                                   ctypes.byref(x), ctypes.byref(y))\n        x, y = x.value, y.value\n        return x, y\n\n    ##########################################\n    # Notify vispy of events triggered by SDL2\n    def _get_mouse_position(self):\n        if self._id is None:\n            return (0, 0)\n        x, y = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetMouseState(ctypes.byref(x), ctypes.byref(y))\n        return x.value, y.value\n\n    def _on_draw(self):\n        if self._vispy_canvas is None or self._id is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)  # (0, 0, w, h))\n\n    def _on_event(self, event):\n        if self._vispy_canvas is None:\n            return\n        # triage event to proper handler\n        if event.type == sdl2.SDL_QUIT:\n            self._vispy_canvas.close()\n        elif event.type == sdl2.SDL_WINDOWEVENT:\n            if event.window.event == sdl2.SDL_WINDOWEVENT_RESIZED:\n                w, h = event.window.data1, event.window.data2\n                self._vispy_canvas.events.resize(size=(w, h))\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_CLOSE:\n                self._vispy_canvas.close()\n        elif event.type == sdl2.SDL_MOUSEMOTION:\n            x, y = event.motion.x, event.motion.y\n            self._vispy_mouse_move(pos=(x, y), modifiers=self._mods)\n        elif event.type in (sdl2.SDL_MOUSEBUTTONDOWN,\n                            sdl2.SDL_MOUSEBUTTONUP):\n            x, y = event.button.x, event.button.y\n            button = event.button.button\n            if button in BUTTONMAP:\n                button = BUTTONMAP.get(button, 0)\n                if event.type == sdl2.SDL_MOUSEBUTTONDOWN:\n                    func = self._vispy_mouse_press\n                else:\n                    func = self._vispy_mouse_release\n                func(pos=(x, y), button=button, modifiers=self._mods)\n        elif event.type == sdl2.SDL_MOUSEWHEEL:\n            pos = self._get_mouse_position()\n            delta = float(event.wheel.x), float(event.wheel.y)\n            self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,\n                                                  modifiers=self._mods)\n        elif event.type in (sdl2.SDL_KEYDOWN, sdl2.SDL_KEYUP):\n            down = (event.type == sdl2.SDL_KEYDOWN)\n            keysym = event.key.keysym\n            mods = keysym.mod\n            key = keysym.sym\n            self._process_mod(mods, down)\n            if key in KEYMAP:\n                key, text = KEYMAP[key], ''\n            elif key >= 32 and key <= 127:\n                key, text = keys.Key(chr(key)), chr(key)\n            else:\n                key, text = None, ''\n            if down:\n                fun = self._vispy_canvas.events.key_press\n            else:\n                fun = self._vispy_canvas.events.key_release\n            fun(key=key, text=text, modifiers=self._mods)\n\n    def _process_mod(self, key, down):\n        _modifiers = list()\n        if key & (sdl2.SDLK_LSHIFT | sdl2.SDLK_RSHIFT):\n            _modifiers.append(keys.SHIFT)\n        if key & (sdl2.SDLK_LCTRL | sdl2.SDLK_RCTRL):\n            _modifiers.append(keys.CONTROL)\n        if key & (sdl2.SDLK_LALT | sdl2.SDLK_RALT):\n            _modifiers.append(keys.ALT)\n        if key & (sdl2.SDLK_LGUI | sdl2.SDLK_RGUI):\n            _modifiers.append(keys.META)\n        for mod in _modifiers:\n            if mod not in self._mods:\n                if down:\n                    self._mods.append(mod)\n            elif not down:\n                self._mods.pop(self._mods.index(mod))",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()\n\n    def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval\n\n    def _vispy_stop(self):\n        self._next_time = float('inf')\n\n    def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()",
  "def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)",
  "def _vispy_get_backend_name(self):\n        return 'SDL2'",
  "def _vispy_process_events(self):\n        events = sdl2.ext.get_events()\n        while len(events) > 0:\n            for event in events:\n                _id = event.window.windowID\n                if _id in _VP_SDL2_ALL_WINDOWS:\n                    win = _VP_SDL2_ALL_WINDOWS[_id]\n                    win._on_event(event)\n            events = sdl2.ext.get_events()\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_sdl2_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()",
  "def _vispy_run(self):\n        wins = _get_sdl2_windows()\n        while any(w._id is not None for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()",
  "def _vispy_quit(self):\n        # Close windows\n        wins = _get_sdl2_windows()\n        for win in wins:\n            win._vispy_close()\n        # tear down timers\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []",
  "def _vispy_get_native_app(self):\n        global _SDL2_INITIALIZED\n        if not _SDL2_INITIALIZED:\n            sdl2.ext.init()\n            atexit.register(sdl2.ext.quit)\n            _SDL2_INITIALIZED = True\n        return sdl2",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Deal with config\n        _set_config(p.context.config)\n        # Deal with context\n        p.context.shared.add_ref('sdl2', self)\n        if p.context.shared.ref is self:\n            share = None\n        else:\n            other = p.context.shared.ref\n            share = other._id.window, other._native_context\n            sdl2.SDL_GL_MakeCurrent(*share)\n            sdl2.SDL_GL_SetAttribute(sdl2.SDL_GL_SHARE_WITH_CURRENT_CONTEXT, 1)\n\n        sdl2.SDL_GL_SetSwapInterval(1 if p.vsync else 0)\n        flags = sdl2.SDL_WINDOW_OPENGL\n        flags |= sdl2.SDL_WINDOW_SHOWN  # start out shown\n        flags |= sdl2.SDL_WINDOW_ALLOW_HIGHDPI\n        flags |= sdl2.SDL_WINDOW_RESIZABLE if p.resizable else 0\n        flags |= sdl2.SDL_WINDOW_BORDERLESS if not p.decorate else 0\n        if p.fullscreen is not False:\n            self._fullscreen = True\n            if p.fullscreen is not True:\n                logger.warning('Cannot specify monitor number for SDL2 '\n                               'fullscreen, using default')\n            flags |= sdl2.SDL_WINDOW_FULLSCREEN_DESKTOP\n        else:\n            self._fullscreen = False\n        self._mods = list()\n        if p.position is None:\n            position = [sdl2.SDL_WINDOWPOS_UNDEFINED] * 2\n        else:\n            position = None\n        self._id = sdl2.ext.Window(p.title, p.size, position, flags)\n        if not self._id.window:\n            raise RuntimeError('Could not create window')\n        if share is None:\n            self._native_context = sdl2.SDL_GL_CreateContext(self._id.window)\n        else:\n            self._native_context = sdl2.SDL_GL_CreateContext(share[0])\n        self._sdl_id = sdl2.SDL_GetWindowID(self._id.window)\n        _VP_SDL2_ALL_WINDOWS[self._sdl_id] = self\n\n        # Init\n        self._initialized = True\n        self._needs_draw = False\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n        if not p.show:\n            self._vispy_set_visible(False)",
  "def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_set_current(self):\n        if self._id is None:\n            return\n        # Make this the current context\n        sdl2.SDL_GL_MakeCurrent(self._id.window, self._native_context)",
  "def _vispy_swap_buffers(self):\n        if self._id is None:\n            return\n        # Swap front and back buffer\n        sdl2.SDL_GL_SwapWindow(self._id.window)",
  "def _vispy_set_title(self, title):\n        if self._id is None:\n            return\n        # Set the window title. Has no effect for widgets\n        sdl2.SDL_SetWindowTitle(self._id.window, title.encode('UTF-8'))",
  "def _vispy_set_size(self, w, h):\n        if self._id is None:\n            return\n        # Set size of the widget or window\n        sdl2.SDL_SetWindowSize(self._id.window, w, h)",
  "def _vispy_set_position(self, x, y):\n        if self._id is None:\n            return\n        # Set position of the widget or window. May have no effect for widgets\n        sdl2.SDL_SetWindowPosition(self._id.window, x, y)",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if self._id is None:\n            return\n        if visible:\n            self._id.show()\n            # this ensures that the show takes effect\n            self._vispy_update()\n        else:\n            self._id.hide()",
  "def _vispy_update(self):\n        # Invoke a redraw, passing it on to the canvas\n        if self._vispy_canvas is None or self._id is None:\n            return\n        # Mark that this window wants to be drawn on the next loop iter\n        self._needs_draw = True",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        if self._id is not None:\n            _id = self._id.window\n            self._vispy_canvas = None\n            self._id = None\n            sdl2.SDL_DestroyWindow(_id)\n            del _VP_SDL2_ALL_WINDOWS[self._sdl_id]\n            self._sdl_id = None\n            gc.collect()",
  "def _vispy_get_size(self):\n        if self._id is None:\n            return\n        w, h = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetWindowSize(self._id.window,\n                               ctypes.byref(w), ctypes.byref(h))\n        w, h = w.value, h.value\n        return w, h",
  "def _vispy_get_fullscreen(self):\n        return self._fullscreen",
  "def _vispy_set_fullscreen(self, fullscreen):\n        self._fullscreen = bool(fullscreen)\n        flags = sdl2.SDL_WINDOW_FULLSCREEN_DESKTOP if self._fullscreen else 0\n        sdl2.SDL_SetWindowFullscreen(self._id.window, flags)",
  "def _vispy_get_position(self):\n        if self._id is None:\n            return\n        x, y = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetWindowPosition(self._id.window,\n                                   ctypes.byref(x), ctypes.byref(y))\n        x, y = x.value, y.value\n        return x, y",
  "def _get_mouse_position(self):\n        if self._id is None:\n            return (0, 0)\n        x, y = ctypes.c_int(), ctypes.c_int()\n        sdl2.SDL_GetMouseState(ctypes.byref(x), ctypes.byref(y))\n        return x.value, y.value",
  "def _on_draw(self):\n        if self._vispy_canvas is None or self._id is None:\n            return\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def _on_event(self, event):\n        if self._vispy_canvas is None:\n            return\n        # triage event to proper handler\n        if event.type == sdl2.SDL_QUIT:\n            self._vispy_canvas.close()\n        elif event.type == sdl2.SDL_WINDOWEVENT:\n            if event.window.event == sdl2.SDL_WINDOWEVENT_RESIZED:\n                w, h = event.window.data1, event.window.data2\n                self._vispy_canvas.events.resize(size=(w, h))\n            elif event.window.event == sdl2.SDL_WINDOWEVENT_CLOSE:\n                self._vispy_canvas.close()\n        elif event.type == sdl2.SDL_MOUSEMOTION:\n            x, y = event.motion.x, event.motion.y\n            self._vispy_mouse_move(pos=(x, y), modifiers=self._mods)\n        elif event.type in (sdl2.SDL_MOUSEBUTTONDOWN,\n                            sdl2.SDL_MOUSEBUTTONUP):\n            x, y = event.button.x, event.button.y\n            button = event.button.button\n            if button in BUTTONMAP:\n                button = BUTTONMAP.get(button, 0)\n                if event.type == sdl2.SDL_MOUSEBUTTONDOWN:\n                    func = self._vispy_mouse_press\n                else:\n                    func = self._vispy_mouse_release\n                func(pos=(x, y), button=button, modifiers=self._mods)\n        elif event.type == sdl2.SDL_MOUSEWHEEL:\n            pos = self._get_mouse_position()\n            delta = float(event.wheel.x), float(event.wheel.y)\n            self._vispy_canvas.events.mouse_wheel(pos=pos, delta=delta,\n                                                  modifiers=self._mods)\n        elif event.type in (sdl2.SDL_KEYDOWN, sdl2.SDL_KEYUP):\n            down = (event.type == sdl2.SDL_KEYDOWN)\n            keysym = event.key.keysym\n            mods = keysym.mod\n            key = keysym.sym\n            self._process_mod(mods, down)\n            if key in KEYMAP:\n                key, text = KEYMAP[key], ''\n            elif key >= 32 and key <= 127:\n                key, text = keys.Key(chr(key)), chr(key)\n            else:\n                key, text = None, ''\n            if down:\n                fun = self._vispy_canvas.events.key_press\n            else:\n                fun = self._vispy_canvas.events.key_release\n            fun(key=key, text=text, modifiers=self._mods)",
  "def _process_mod(self, key, down):\n        _modifiers = list()\n        if key & (sdl2.SDLK_LSHIFT | sdl2.SDLK_RSHIFT):\n            _modifiers.append(keys.SHIFT)\n        if key & (sdl2.SDLK_LCTRL | sdl2.SDLK_RCTRL):\n            _modifiers.append(keys.CONTROL)\n        if key & (sdl2.SDLK_LALT | sdl2.SDLK_RALT):\n            _modifiers.append(keys.ALT)\n        if key & (sdl2.SDLK_LGUI | sdl2.SDLK_RGUI):\n            _modifiers.append(keys.META)\n        for mod in _modifiers:\n            if mod not in self._mods:\n                if down:\n                    self._mods.append(mod)\n            elif not down:\n                self._mods.pop(self._mods.index(mod))",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()",
  "def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval",
  "def _vispy_stop(self):\n        self._next_time = float('inf')",
  "def _tick(self):\n        if time() >= self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def _check_imports(lib):\n    # Make sure no conflicting libraries have been imported.\n    libs = ['PyQt4', 'PyQt5', 'PyQt6', 'PySide', 'PySide2', 'PySide6']\n    libs.remove(lib)\n    for lib2 in libs:\n        lib2 += '.QtCore'\n        if lib2 in sys.modules:\n            raise RuntimeError(\"Refusing to import %s because %s is already \"\n                               \"imported.\" % (lib, lib2))",
  "def _get_event_xy(ev):\n    # QT6 (and the Python bindings like PyQt6, PySide6) report position differently from previous versions\n    if hasattr(ev, 'pos'):\n        posx, posy = ev.pos().x(), ev.pos().y()\n    else:\n        # Compatibility for PySide6 / PyQt6\n        posx, posy = ev.position().x(), ev.position().y()\n\n    return posx, posy",
  "def message_handler(*args):\n\n    if qt_lib in (\"pyqt4\", \"pyside\"):\n        msg_type, msg = args\n    elif qt_lib in (\"pyqt5\", \"pyqt6\", \"pyside2\", \"pyside6\"):  # Is this correct for pyside2?\n        msg_type, context, msg = args\n    elif qt_lib:\n        raise RuntimeError(\"Invalid value for qt_lib %r.\" % qt_lib)\n    else:\n        raise RuntimeError(\"Module backends._qt \",\n                           \"should not be imported directly.\")\n\n    BLACKLIST = [\n        # Ignore spam about tablet input\n        'QCocoaView handleTabletEvent: This tablet device is unknown',\n        # Not too sure why this warning is emitted when using\n        #   Spyder + PyQt5 + Vispy\n        #   https://github.com/vispy/vispy/issues/1787\n        # In either case, it is really annoying. We should filter it away\n        'QSocketNotifier: Multiple socket notifiers for same',\n    ]\n    for item in BLACKLIST:\n        if msg.startswith(item):\n            return\n\n    msg = msg.decode() if not isinstance(msg, str) else msg\n    logger.warning(msg)",
  "def use_shared_contexts():\n    \"\"\"Enable context sharing for PyQt5 5.4+ API applications.\n\n    This is disabled by default for PyQt5 5.4+ due to occasional segmentation\n    faults and other issues when contexts are shared.\n\n    \"\"\"\n    forced_env_var = os.getenv('VISPY_PYQT5_SHARE_CONTEXT', 'false').lower() == 'true'\n    return not (QT5_NEW_API or PYSIDE6_API or PYQT6_API) or forced_env_var",
  "def _set_config(c):\n    \"\"\"Set the OpenGL configuration\"\"\"\n    glformat = QGLFormat()\n    glformat.setRedBufferSize(c['red_size'])\n    glformat.setGreenBufferSize(c['green_size'])\n    glformat.setBlueBufferSize(c['blue_size'])\n    glformat.setAlphaBufferSize(c['alpha_size'])\n    if QT5_NEW_API or PYSIDE6_API:\n        # Qt5 >= 5.4.0 - below options automatically enabled if nonzero.\n        glformat.setSwapBehavior(glformat.DoubleBuffer if c['double_buffer']\n                                 else glformat.SingleBuffer)\n    elif PYQT6_API:\n        glformat.setSwapBehavior(glformat.SwapBehavior.DoubleBuffer if c['double_buffer']\n                                 else glformat.SwapBehavior.SingleBuffer)\n    else:\n        # Qt4 and Qt5 < 5.4.0 - buffers must be explicitly requested.\n        glformat.setAccum(False)\n        glformat.setRgba(True)\n        glformat.setDoubleBuffer(True if c['double_buffer'] else False)\n        glformat.setDepth(True if c['depth_size'] else False)\n        glformat.setStencil(True if c['stencil_size'] else False)\n        glformat.setSampleBuffers(True if c['samples'] else False)\n    glformat.setDepthBufferSize(c['depth_size'] if c['depth_size'] else 0)\n    glformat.setStencilBufferSize(c['stencil_size'] if c['stencil_size']\n                                  else 0)\n    glformat.setSamples(c['samples'] if c['samples'] else 0)\n    glformat.setStereo(c['stereo'])\n    return glformat",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        # sharing is currently buggy and causes segmentation faults for tests with PyQt 5.6\n        if (QT5_NEW_API or PYSIDE6_API) and use_shared_contexts():\n            # For Qt5 >= 5.4.0 - Enable sharing of context between windows.\n            QApplication.setAttribute(QtCore.Qt.AA_ShareOpenGLContexts, True)\n        elif PYQT6_API and use_shared_contexts():\n            QApplication.setAttribute(QtCore.Qt.ApplicationAttribute.AA_ShareOpenGLContexts, True)\n\n    def _vispy_get_backend_name(self):\n        name = QtCore.__name__.split('.')[0]\n        return name\n\n    def _vispy_process_events(self):\n        app = self._vispy_get_native_app()\n        # sendPostedEvents replaces flush which has been removed from Qt6.0+\n        # This should be compatible with Qt4.x and Qt5.x\n        app.sendPostedEvents()\n        app.processEvents()\n\n    def _vispy_run(self):\n        app = self._vispy_get_native_app()\n        if hasattr(app, '_in_event_loop') and app._in_event_loop:\n            pass  # Already in event loop\n        else:\n            # app.exec_() for PyQt <=5 and app.exec() for PyQt >=5\n            exec_func = app.exec if hasattr(app, \"exec\") else app.exec_\n            return exec_func()\n\n    def _vispy_quit(self):\n        return self._vispy_get_native_app().quit()\n\n    def _vispy_get_native_app(self):\n        # Get native app in save way. Taken from guisupport.py\n        app = QApplication.instance()\n        if app is None:\n            app = QApplication([''])\n        # Store so it won't be deleted, but not on a vispy object,\n        # or an application may produce error when closed.\n        QtGui._qApp = app\n        # Return\n        return app\n\n    def _vispy_sleep(self, duration_sec):\n        QtTest.QTest.qWait(duration_sec * 1000)",
  "def _get_qpoint_pos(pos):\n    \"\"\"Return the coordinates of a QPointF object.\"\"\"\n    return pos.x(), pos.y()",
  "class QtBaseCanvasBackend(BaseCanvasBackend):\n    \"\"\"Base functionality of Qt backend. No OpenGL Stuff.\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # Maybe to ensure that exactly all arguments are passed?\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Init in desktop GL or EGL way\n        self._init_specific(p, kwargs)\n        assert self._initialized\n\n        self.setMouseTracking(True)\n        self._vispy_set_title(p.title)\n        self._vispy_set_size(*p.size)\n        if p.fullscreen is not False:\n            if p.fullscreen is not True:\n                logger.warning('Cannot specify monitor number for Qt '\n                               'fullscreen, using default')\n            self._fullscreen = True\n        else:\n            self._fullscreen = False\n\n        # must set physical size before setting visible or fullscreen\n        # operations may make the size invalid\n        if hasattr(self, 'devicePixelRatio'):\n            # handle high DPI displays in PyQt5\n            ratio = self.devicePixelRatio()\n        else:\n            ratio = 1\n        self._physical_size = (p.size[0] * ratio, p.size[1] * ratio)\n\n        if not p.resizable:\n            self.setFixedSize(self.size())\n        if p.position is not None:\n            self._vispy_set_position(*p.position)\n        if p.show:\n            self._vispy_set_visible(True)\n\n        # Qt supports OS double-click events, so we set this here to\n        # avoid double events\n        self._double_click_supported = True\n\n        try:\n            # see screen_changed docstring for more details\n            self.window().windowHandle().screenChanged.connect(self.screen_changed)\n        except AttributeError:\n            # either not PyQt5 backend or no parent window available\n            pass\n\n        # Activate touch and gesture.\n        # NOTE: we only activate touch on OS X because there seems to be\n        # problems on Ubuntu computers with touchscreen.\n        # See https://github.com/vispy/vispy/pull/1143\n        if sys.platform == 'darwin':\n            if PYQT6_API:\n                self.setAttribute(QtCore.Qt.WidgetAttribute.WA_AcceptTouchEvents)\n                self.grabGesture(QtCore.Qt.GestureType.PinchGesture)\n            else:\n                self.setAttribute(QtCore.Qt.WA_AcceptTouchEvents)\n                self.grabGesture(QtCore.Qt.PinchGesture)\n\n    def screen_changed(self, new_screen):\n        \"\"\"Window moved from one display to another, resize canvas.\n\n        If display resolutions are the same this is essentially a no-op except for the redraw.\n        If the display resolutions differ (HiDPI versus regular displays) the canvas needs to\n        be redrawn to reset the physical size based on the current `devicePixelRatio()` and\n        redrawn with that new size.\n\n        \"\"\"\n        self.resizeGL(*self._vispy_get_size())\n\n    def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        if self._vispy_canvas is None:\n            return\n        self.setWindowTitle(title)\n\n    def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        self.resize(w, h)\n\n    def _vispy_set_physical_size(self, w, h):\n        self._physical_size = (w, h)\n\n    def _vispy_get_physical_size(self):\n        if self._vispy_canvas is None:\n            return\n        return self._physical_size\n\n    def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        self.move(x, y)\n\n    def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if visible:\n            if self._fullscreen:\n                self.showFullScreen()\n            else:\n                self.showNormal()\n        else:\n            self.hide()\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        self._fullscreen = bool(fullscreen)\n        self._vispy_set_visible(True)\n\n    def _vispy_get_fullscreen(self):\n        return self._fullscreen\n\n    def _vispy_update(self):\n        if self._vispy_canvas is None:\n            return\n        # Invoke a redraw\n        self.update()\n\n    def _vispy_get_position(self):\n        g = self.geometry()\n        return g.x(), g.y()\n\n    def _vispy_get_size(self):\n        g = self.geometry()\n        return g.width(), g.height()\n\n    def sizeHint(self):\n        return self.size()\n\n    def mousePressEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_press(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP.get(ev.button(), 0),\n            modifiers=self._modifiers(ev),\n        )\n\n    def mouseReleaseEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_release(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP[ev.button()],\n            modifiers=self._modifiers(ev),\n        )\n\n    def mouseDoubleClickEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_double_click(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP.get(ev.button(), 0),\n            modifiers=self._modifiers(ev),\n        )\n\n    def mouseMoveEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            native=ev,\n            pos=_get_event_xy(ev),\n            modifiers=self._modifiers(ev),\n        )\n\n    def wheelEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        # Get scrolling\n        deltax, deltay = 0.0, 0.0\n        if hasattr(ev, 'orientation'):\n            if ev.orientation == QtCore.Qt.Horizontal:\n                deltax = ev.delta() / 120.0\n            else:\n                deltay = ev.delta() / 120.0\n        else:\n            # PyQt5 / PyQt6\n            delta = ev.angleDelta()\n            deltax, deltay = delta.x() / 120.0, delta.y() / 120.0\n        # Emit event\n        self._vispy_canvas.events.mouse_wheel(\n            native=ev,\n            delta=(deltax, deltay),\n            pos=_get_event_xy(ev),\n            modifiers=self._modifiers(ev),\n        )\n\n    def keyPressEvent(self, ev):\n        self._keyEvent(self._vispy_canvas.events.key_press, ev)\n\n    def keyReleaseEvent(self, ev):\n        self._keyEvent(self._vispy_canvas.events.key_release, ev)\n\n    def event(self, ev):\n        out = super(QtBaseCanvasBackend, self).event(ev)\n        t = ev.type()\n\n        qt_event_types = QtCore.QEvent.Type if PYQT6_API else QtCore.QEvent\n        # Two-finger pinch.\n        if t == qt_event_types.TouchBegin:\n            self._vispy_canvas.events.touch(type='begin')\n        if t == qt_event_types.TouchEnd:\n            self._vispy_canvas.events.touch(type='end')\n        if t == qt_event_types.Gesture:\n            pinch_gesture = QtCore.Qt.GestureType.PinchGesture if PYQT6_API else QtCore.Qt.PinchGesture\n            gesture = ev.gesture(pinch_gesture)\n            if gesture:\n                (x, y) = _get_qpoint_pos(gesture.centerPoint())\n                scale = gesture.scaleFactor()\n                last_scale = gesture.lastScaleFactor()\n                rotation = gesture.rotationAngle()\n                self._vispy_canvas.events.touch(\n                    type=\"pinch\",\n                    pos=(x, y),\n                    last_pos=None,\n                    scale=scale,\n                    last_scale=last_scale,\n                    rotation=rotation,\n                    total_rotation_angle=gesture.totalRotationAngle(),\n                    total_scale_factor=gesture.totalScaleFactor(),\n                )\n        # General touch event.\n        elif t == qt_event_types.TouchUpdate:\n            if qt_lib == 'pyqt6' or qt_lib == 'pyside6':\n                points = ev.points()\n                # These variables are lists of (x, y) coordinates.\n                pos = [_get_qpoint_pos(p.position()) for p in points]\n                lpos = [_get_qpoint_pos(p.lastPosition()) for p in points]\n            else:\n                points = ev.touchPoints()\n                # These variables are lists of (x, y) coordinates.\n                pos = [_get_qpoint_pos(p.pos()) for p in points]\n                lpos = [_get_qpoint_pos(p.lastPos()) for p in points]\n            self._vispy_canvas.events.touch(type='touch',\n                                            pos=pos,\n                                            last_pos=lpos,\n                                            )\n        return out\n\n    def _keyEvent(self, func, ev):\n        # evaluates the keycode of qt, and transform to vispy key.\n        key = int(ev.key())\n        if key in KEYMAP:\n            key = KEYMAP[key]\n        elif 32 <= key <= 127:\n            key = keys.Key(chr(key))\n        else:\n            key = None\n        mod = self._modifiers(ev)\n        func(native=ev, key=key, text=str(ev.text()), modifiers=mod)\n\n    def _modifiers(self, event):\n        # Convert the QT modifier state into a tuple of active modifier keys.\n        mod = ()\n        qtmod = event.modifiers()\n        qt_keyboard_modifiers = QtCore.Qt.KeyboardModifier if PYQT6_API else QtCore.Qt\n        for q, v in ([qt_keyboard_modifiers.ShiftModifier, keys.SHIFT],\n                     [qt_keyboard_modifiers.ControlModifier, keys.CONTROL],\n                     [qt_keyboard_modifiers.AltModifier, keys.ALT],\n                     [qt_keyboard_modifiers.MetaModifier, keys.META]):\n            if qtmod & q:\n                mod += (v,)\n        return mod",
  "class CanvasBackendEgl(QtBaseCanvasBackend, QWidget):\n\n    def _init_specific(self, p, kwargs):\n\n        # Initialize egl. Note that we only import egl if needed.\n        global _EGL_DISPLAY\n        global egl\n        if egl is None:\n            from ...ext import egl as _egl\n            egl = _egl\n            # Use MESA driver on Linux\n            if IS_LINUX and not IS_RPI:\n                os.environ['EGL_SOFTWARE'] = 'true'\n            # Create and init display\n            _EGL_DISPLAY = egl.eglGetDisplay()\n            CanvasBackendEgl._EGL_VERSION = egl.eglInitialize(_EGL_DISPLAY)\n            atexit.register(egl.eglTerminate, _EGL_DISPLAY)\n\n        # Deal with context\n        p.context.shared.add_ref('qt-egl', self)\n        if p.context.shared.ref is self:\n            self._native_config = c = egl.eglChooseConfig(_EGL_DISPLAY)[0]\n            self._native_context = egl.eglCreateContext(_EGL_DISPLAY, c, None)\n        else:\n            self._native_config = p.context.shared.ref._native_config\n            self._native_context = p.context.shared.ref._native_context\n\n        # Init widget\n        qt_window_types = QtCore.Qt.WindowType if PYQT6_API else QtCore.Qt\n        if p.always_on_top or not p.decorate:\n            hint = 0\n            hint |= 0 if p.decorate else qt_window_types.FramelessWindowHint\n            hint |= qt_window_types.WindowStaysOnTopHint if p.always_on_top else 0\n        else:\n            hint = qt_window_types.Widget  # can also be a window type\n\n        QWidget.__init__(self, p.parent, hint)\n\n        qt_window_attributes = QtCore.Qt.WidgetAttribute if PYQT6_API else QtCore.Qt\n        if 0:  # IS_LINUX or IS_RPI:\n            self.setAutoFillBackground(False)\n            self.setAttribute(qt_window_attributes.WA_NoSystemBackground, True)\n            self.setAttribute(qt_window_attributes.WA_OpaquePaintEvent, True)\n        elif IS_WIN:\n            self.setAttribute(qt_window_attributes.WA_PaintOnScreen, True)\n            self.setAutoFillBackground(False)\n\n        # Init surface\n        w = self.get_window_id()\n        self._surface = egl.eglCreateWindowSurface(_EGL_DISPLAY, c, w)\n        self.initializeGL()\n        self._initialized = True\n\n    def get_window_id(self):\n        \"\"\"Get the window id of a PySide Widget. Might also work for PyQt4.\"\"\"\n        # Get Qt win id\n        winid = self.winId()\n\n        # On Linux this is it\n        if IS_RPI:\n            nw = (ctypes.c_int * 3)(winid, self.width(), self.height())\n            return ctypes.pointer(nw)\n        elif IS_LINUX:\n            return int(winid)  # Is int on PySide, but sip.voidptr on PyQt\n\n        # Get window id from stupid capsule thingy\n        # http://translate.google.com/translate?hl=en&sl=zh-CN&u=http://www.cnb\n        # logs.com/Shiren-Y/archive/2011/04/06/2007288.html&prev=/search%3Fq%3Dp\n        # yside%2Bdirectx%26client%3Dfirefox-a%26hs%3DIsJ%26rls%3Dorg.mozilla:n\n        # l:official%26channel%3Dfflb%26biw%3D1366%26bih%3D614\n        # Prepare\n        ctypes.pythonapi.PyCapsule_GetName.restype = ctypes.c_char_p\n        ctypes.pythonapi.PyCapsule_GetName.argtypes = [ctypes.py_object]\n        ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p\n        ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.py_object,\n                                                          ctypes.c_char_p]\n        # Extract handle from capsule thingy\n        name = ctypes.pythonapi.PyCapsule_GetName(winid)\n        handle = ctypes.pythonapi.PyCapsule_GetPointer(winid, name)\n        return handle\n\n    def _vispy_close(self):\n        # Destroy EGL surface\n        if self._surface is not None:\n            egl.eglDestroySurface(_EGL_DISPLAY, self._surface)\n            self._surface = None\n        # Force the window or widget to shut down\n        self.close()\n\n    def _vispy_set_current(self):\n        egl.eglMakeCurrent(_EGL_DISPLAY, self._surface,\n                           self._surface, self._native_context)\n\n    def _vispy_swap_buffers(self):\n        egl.eglSwapBuffers(_EGL_DISPLAY, self._surface)\n\n    def initializeGL(self):\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n\n    def resizeEvent(self, event):\n        w, h = event.size().width(), event.size().height()\n        self._vispy_canvas.events.resize(size=(w, h))\n\n    def paintEvent(self, event):\n        self._vispy_canvas.events.draw(region=None)\n\n        if IS_LINUX or IS_RPI:\n            # Arg, cannot get GL to draw to the widget, so we take a\n            # screenshot and draw that for now ...\n            # Further, QImage keeps a ref to the data that we pass, so\n            # we need to use a static buffer to prevent memory leakage\n            from ... import gloo\n            import numpy as np\n            if not hasattr(self, '_gl_buffer'):\n                self._gl_buffer = np.ones((3000 * 3000 * 4), np.uint8) * 255\n            # Take screenshot and turn into RGB QImage\n            im = gloo.read_pixels()\n            sze = im.shape[0] * im.shape[1]\n            self._gl_buffer[0:0+sze*4:4] = im[:, :, 2].ravel()\n            self._gl_buffer[1:0+sze*4:4] = im[:, :, 1].ravel()\n            self._gl_buffer[2:2+sze*4:4] = im[:, :, 0].ravel()\n            img = QtGui.QImage(self._gl_buffer, im.shape[1], im.shape[0],\n                               QtGui.QImage.Format_RGB32)\n            # Paint the image\n            painter = QtGui.QPainter()\n            painter.begin(self)\n            rect = QtCore.QRect(0, 0, self.width(), self.height())\n            painter.drawImage(rect, img)\n            painter.end()\n\n    def paintEngine(self):\n        if IS_LINUX and not IS_RPI:\n            # For now we are drawing a screenshot\n            return QWidget.paintEngine(self)\n        else:\n            return None",
  "class CanvasBackendDesktop(QtBaseCanvasBackend, QGLWidget):\n\n    def _init_specific(self, p, kwargs):\n\n        # Deal with config\n        glformat = _set_config(p.context.config)\n        glformat.setSwapInterval(1 if p.vsync else 0)\n        # Deal with context\n        widget = kwargs.pop('shareWidget', None) or self\n        p.context.shared.add_ref('qt', widget)\n        if p.context.shared.ref is widget:\n            if widget is self:\n                widget = None  # QGLWidget does not accept self ;)\n        else:\n            widget = p.context.shared.ref\n            if 'shareWidget' in kwargs:\n                raise RuntimeError('Cannot use vispy to share context and '\n                                   'use built-in shareWidget.')\n\n        qt_window_types = QtCore.Qt.WindowType if PYQT6_API else QtCore.Qt\n        if p.always_on_top or not p.decorate:\n            hint = 0\n            hint |= 0 if p.decorate else qt_window_types.FramelessWindowHint\n            hint |= qt_window_types.WindowStaysOnTopHint if p.always_on_top else 0\n        else:\n            hint = qt_window_types.Widget  # can also be a window type\n\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            # Qt5 >= 5.4.0 - sharing is automatic\n            QGLWidget.__init__(self, p.parent, hint)\n\n            # Need to create an offscreen surface so we can get GL parameters\n            # without opening/showing the Widget. PyQt5 >= 5.4 will create the\n            # valid context later when the widget is shown.\n            self._secondary_context = QtGui.QOpenGLContext()\n            self._secondary_context.setShareContext(self.context())\n            self._secondary_context.setFormat(glformat)\n            self._secondary_context.create()\n\n            self._surface = QtGui.QOffscreenSurface()\n            self._surface.setFormat(glformat)\n            self._surface.create()\n            self._secondary_context.makeCurrent(self._surface)\n        else:\n            # Qt4 and Qt5 < 5.4.0 - sharing is explicitly requested\n            QGLWidget.__init__(self, p.parent, widget, hint)\n            # unused with this API\n            self._secondary_context = None\n            self._surface = None\n\n        self.setFormat(glformat)\n        self._initialized = True\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API and not self.isValid():\n            # On Qt5 >= 5.4.0, isValid is only true once the widget is shown\n            raise RuntimeError('context could not be created')\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API:\n            # to make consistent with other backends\n            self.setAutoBufferSwap(False)\n        qt_focus_policies = QtCore.Qt.FocusPolicy if PYQT6_API else QtCore.Qt\n        self.setFocusPolicy(qt_focus_policies.WheelFocus)\n\n    def _vispy_close(self):\n        # Force the window or widget to shut down\n        self.close()\n        self.doneCurrent()\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API:\n            self.context().reset()\n        if self._vispy_canvas is not None:\n            self._vispy_canvas.app.process_events()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_set_current(self):\n        if self._vispy_canvas is None:\n            return  # todo: can we get rid of this now?\n        if self.isValid():\n            self.makeCurrent()\n\n    def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        if self._vispy_canvas is None:\n            return\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            ctx = self.context()\n            ctx.swapBuffers(ctx.surface())\n        else:\n            self.swapBuffers()\n\n    def _vispy_get_fb_bind_location(self):\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            return self.defaultFramebufferObject()\n        else:\n            return QtBaseCanvasBackend._vispy_get_fb_bind_location(self)\n\n    def initializeGL(self):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.initialize()\n\n    def resizeGL(self, w, h):\n        if self._vispy_canvas is None:\n            return\n        if hasattr(self, 'devicePixelRatio'):\n            # We take into account devicePixelRatio, which is non-unity on\n            # e.g HiDPI displays.\n            # self.devicePixelRatio() is a float and should have been in Qt5 according to the documentation\n            ratio = self.devicePixelRatio()\n            w = int(w * ratio)\n            h = int(h * ratio)\n        self._vispy_set_physical_size(w, h)\n        self._vispy_canvas.events.resize(size=(self.width(), self.height()),\n                                         physical_size=(w, h))\n\n    def paintGL(self):\n        if self._vispy_canvas is None:\n            return\n        # (0, 0, self.width(), self.height()))\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n\n        # Clear the alpha channel with QOpenGLWidget (Qt >= 5.4), otherwise the\n        # window is translucent behind non-opaque objects.\n        # Reference:  MRtrix3/mrtrix3#266\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            context = self._vispy_canvas.context\n            context.set_color_mask(False, False, False, True)\n            context.clear(color=True, depth=False, stencil=False)\n            context.set_color_mask(True, True, True, True)\n            context.flush()",
  "class TimerBackend(BaseTimerBackend, QtCore.QTimer):\n\n    def __init__(self, vispy_timer):\n        # Make sure there is an app\n        app = ApplicationBackend()\n        app._vispy_get_native_app()\n        # Init\n        BaseTimerBackend.__init__(self, vispy_timer)\n        QtCore.QTimer.__init__(self)\n        self.timeout.connect(self._vispy_timeout)\n\n    def _vispy_start(self, interval):\n        self.start(int(interval * 1000))\n\n    def _vispy_stop(self):\n        self.stop()\n\n    def _vispy_timeout(self):\n        self._vispy_timer._timeout()",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        # sharing is currently buggy and causes segmentation faults for tests with PyQt 5.6\n        if (QT5_NEW_API or PYSIDE6_API) and use_shared_contexts():\n            # For Qt5 >= 5.4.0 - Enable sharing of context between windows.\n            QApplication.setAttribute(QtCore.Qt.AA_ShareOpenGLContexts, True)\n        elif PYQT6_API and use_shared_contexts():\n            QApplication.setAttribute(QtCore.Qt.ApplicationAttribute.AA_ShareOpenGLContexts, True)",
  "def _vispy_get_backend_name(self):\n        name = QtCore.__name__.split('.')[0]\n        return name",
  "def _vispy_process_events(self):\n        app = self._vispy_get_native_app()\n        # sendPostedEvents replaces flush which has been removed from Qt6.0+\n        # This should be compatible with Qt4.x and Qt5.x\n        app.sendPostedEvents()\n        app.processEvents()",
  "def _vispy_run(self):\n        app = self._vispy_get_native_app()\n        if hasattr(app, '_in_event_loop') and app._in_event_loop:\n            pass  # Already in event loop\n        else:\n            # app.exec_() for PyQt <=5 and app.exec() for PyQt >=5\n            exec_func = app.exec if hasattr(app, \"exec\") else app.exec_\n            return exec_func()",
  "def _vispy_quit(self):\n        return self._vispy_get_native_app().quit()",
  "def _vispy_get_native_app(self):\n        # Get native app in save way. Taken from guisupport.py\n        app = QApplication.instance()\n        if app is None:\n            app = QApplication([''])\n        # Store so it won't be deleted, but not on a vispy object,\n        # or an application may produce error when closed.\n        QtGui._qApp = app\n        # Return\n        return app",
  "def _vispy_sleep(self, duration_sec):\n        QtTest.QTest.qWait(duration_sec * 1000)",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # Maybe to ensure that exactly all arguments are passed?\n        p = self._process_backend_kwargs(kwargs)\n        self._initialized = False\n\n        # Init in desktop GL or EGL way\n        self._init_specific(p, kwargs)\n        assert self._initialized\n\n        self.setMouseTracking(True)\n        self._vispy_set_title(p.title)\n        self._vispy_set_size(*p.size)\n        if p.fullscreen is not False:\n            if p.fullscreen is not True:\n                logger.warning('Cannot specify monitor number for Qt '\n                               'fullscreen, using default')\n            self._fullscreen = True\n        else:\n            self._fullscreen = False\n\n        # must set physical size before setting visible or fullscreen\n        # operations may make the size invalid\n        if hasattr(self, 'devicePixelRatio'):\n            # handle high DPI displays in PyQt5\n            ratio = self.devicePixelRatio()\n        else:\n            ratio = 1\n        self._physical_size = (p.size[0] * ratio, p.size[1] * ratio)\n\n        if not p.resizable:\n            self.setFixedSize(self.size())\n        if p.position is not None:\n            self._vispy_set_position(*p.position)\n        if p.show:\n            self._vispy_set_visible(True)\n\n        # Qt supports OS double-click events, so we set this here to\n        # avoid double events\n        self._double_click_supported = True\n\n        try:\n            # see screen_changed docstring for more details\n            self.window().windowHandle().screenChanged.connect(self.screen_changed)\n        except AttributeError:\n            # either not PyQt5 backend or no parent window available\n            pass\n\n        # Activate touch and gesture.\n        # NOTE: we only activate touch on OS X because there seems to be\n        # problems on Ubuntu computers with touchscreen.\n        # See https://github.com/vispy/vispy/pull/1143\n        if sys.platform == 'darwin':\n            if PYQT6_API:\n                self.setAttribute(QtCore.Qt.WidgetAttribute.WA_AcceptTouchEvents)\n                self.grabGesture(QtCore.Qt.GestureType.PinchGesture)\n            else:\n                self.setAttribute(QtCore.Qt.WA_AcceptTouchEvents)\n                self.grabGesture(QtCore.Qt.PinchGesture)",
  "def screen_changed(self, new_screen):\n        \"\"\"Window moved from one display to another, resize canvas.\n\n        If display resolutions are the same this is essentially a no-op except for the redraw.\n        If the display resolutions differ (HiDPI versus regular displays) the canvas needs to\n        be redrawn to reset the physical size based on the current `devicePixelRatio()` and\n        redrawn with that new size.\n\n        \"\"\"\n        self.resizeGL(*self._vispy_get_size())",
  "def _vispy_warmup(self):\n        etime = time() + 0.25\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_set_title(self, title):\n        # Set the window title. Has no effect for widgets\n        if self._vispy_canvas is None:\n            return\n        self.setWindowTitle(title)",
  "def _vispy_set_size(self, w, h):\n        # Set size of the widget or window\n        self.resize(w, h)",
  "def _vispy_set_physical_size(self, w, h):\n        self._physical_size = (w, h)",
  "def _vispy_get_physical_size(self):\n        if self._vispy_canvas is None:\n            return\n        return self._physical_size",
  "def _vispy_set_position(self, x, y):\n        # Set location of the widget or window. May have no effect for widgets\n        self.move(x, y)",
  "def _vispy_set_visible(self, visible):\n        # Show or hide the window or widget\n        if visible:\n            if self._fullscreen:\n                self.showFullScreen()\n            else:\n                self.showNormal()\n        else:\n            self.hide()",
  "def _vispy_set_fullscreen(self, fullscreen):\n        self._fullscreen = bool(fullscreen)\n        self._vispy_set_visible(True)",
  "def _vispy_get_fullscreen(self):\n        return self._fullscreen",
  "def _vispy_update(self):\n        if self._vispy_canvas is None:\n            return\n        # Invoke a redraw\n        self.update()",
  "def _vispy_get_position(self):\n        g = self.geometry()\n        return g.x(), g.y()",
  "def _vispy_get_size(self):\n        g = self.geometry()\n        return g.width(), g.height()",
  "def sizeHint(self):\n        return self.size()",
  "def mousePressEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_press(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP.get(ev.button(), 0),\n            modifiers=self._modifiers(ev),\n        )",
  "def mouseReleaseEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_release(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP[ev.button()],\n            modifiers=self._modifiers(ev),\n        )",
  "def mouseDoubleClickEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_double_click(\n            native=ev,\n            pos=_get_event_xy(ev),\n            button=BUTTONMAP.get(ev.button(), 0),\n            modifiers=self._modifiers(ev),\n        )",
  "def mouseMoveEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_mouse_move(\n            native=ev,\n            pos=_get_event_xy(ev),\n            modifiers=self._modifiers(ev),\n        )",
  "def wheelEvent(self, ev):\n        if self._vispy_canvas is None:\n            return\n        # Get scrolling\n        deltax, deltay = 0.0, 0.0\n        if hasattr(ev, 'orientation'):\n            if ev.orientation == QtCore.Qt.Horizontal:\n                deltax = ev.delta() / 120.0\n            else:\n                deltay = ev.delta() / 120.0\n        else:\n            # PyQt5 / PyQt6\n            delta = ev.angleDelta()\n            deltax, deltay = delta.x() / 120.0, delta.y() / 120.0\n        # Emit event\n        self._vispy_canvas.events.mouse_wheel(\n            native=ev,\n            delta=(deltax, deltay),\n            pos=_get_event_xy(ev),\n            modifiers=self._modifiers(ev),\n        )",
  "def keyPressEvent(self, ev):\n        self._keyEvent(self._vispy_canvas.events.key_press, ev)",
  "def keyReleaseEvent(self, ev):\n        self._keyEvent(self._vispy_canvas.events.key_release, ev)",
  "def event(self, ev):\n        out = super(QtBaseCanvasBackend, self).event(ev)\n        t = ev.type()\n\n        qt_event_types = QtCore.QEvent.Type if PYQT6_API else QtCore.QEvent\n        # Two-finger pinch.\n        if t == qt_event_types.TouchBegin:\n            self._vispy_canvas.events.touch(type='begin')\n        if t == qt_event_types.TouchEnd:\n            self._vispy_canvas.events.touch(type='end')\n        if t == qt_event_types.Gesture:\n            pinch_gesture = QtCore.Qt.GestureType.PinchGesture if PYQT6_API else QtCore.Qt.PinchGesture\n            gesture = ev.gesture(pinch_gesture)\n            if gesture:\n                (x, y) = _get_qpoint_pos(gesture.centerPoint())\n                scale = gesture.scaleFactor()\n                last_scale = gesture.lastScaleFactor()\n                rotation = gesture.rotationAngle()\n                self._vispy_canvas.events.touch(\n                    type=\"pinch\",\n                    pos=(x, y),\n                    last_pos=None,\n                    scale=scale,\n                    last_scale=last_scale,\n                    rotation=rotation,\n                    total_rotation_angle=gesture.totalRotationAngle(),\n                    total_scale_factor=gesture.totalScaleFactor(),\n                )\n        # General touch event.\n        elif t == qt_event_types.TouchUpdate:\n            if qt_lib == 'pyqt6' or qt_lib == 'pyside6':\n                points = ev.points()\n                # These variables are lists of (x, y) coordinates.\n                pos = [_get_qpoint_pos(p.position()) for p in points]\n                lpos = [_get_qpoint_pos(p.lastPosition()) for p in points]\n            else:\n                points = ev.touchPoints()\n                # These variables are lists of (x, y) coordinates.\n                pos = [_get_qpoint_pos(p.pos()) for p in points]\n                lpos = [_get_qpoint_pos(p.lastPos()) for p in points]\n            self._vispy_canvas.events.touch(type='touch',\n                                            pos=pos,\n                                            last_pos=lpos,\n                                            )\n        return out",
  "def _keyEvent(self, func, ev):\n        # evaluates the keycode of qt, and transform to vispy key.\n        key = int(ev.key())\n        if key in KEYMAP:\n            key = KEYMAP[key]\n        elif 32 <= key <= 127:\n            key = keys.Key(chr(key))\n        else:\n            key = None\n        mod = self._modifiers(ev)\n        func(native=ev, key=key, text=str(ev.text()), modifiers=mod)",
  "def _modifiers(self, event):\n        # Convert the QT modifier state into a tuple of active modifier keys.\n        mod = ()\n        qtmod = event.modifiers()\n        qt_keyboard_modifiers = QtCore.Qt.KeyboardModifier if PYQT6_API else QtCore.Qt\n        for q, v in ([qt_keyboard_modifiers.ShiftModifier, keys.SHIFT],\n                     [qt_keyboard_modifiers.ControlModifier, keys.CONTROL],\n                     [qt_keyboard_modifiers.AltModifier, keys.ALT],\n                     [qt_keyboard_modifiers.MetaModifier, keys.META]):\n            if qtmod & q:\n                mod += (v,)\n        return mod",
  "def _init_specific(self, p, kwargs):\n\n        # Initialize egl. Note that we only import egl if needed.\n        global _EGL_DISPLAY\n        global egl\n        if egl is None:\n            from ...ext import egl as _egl\n            egl = _egl\n            # Use MESA driver on Linux\n            if IS_LINUX and not IS_RPI:\n                os.environ['EGL_SOFTWARE'] = 'true'\n            # Create and init display\n            _EGL_DISPLAY = egl.eglGetDisplay()\n            CanvasBackendEgl._EGL_VERSION = egl.eglInitialize(_EGL_DISPLAY)\n            atexit.register(egl.eglTerminate, _EGL_DISPLAY)\n\n        # Deal with context\n        p.context.shared.add_ref('qt-egl', self)\n        if p.context.shared.ref is self:\n            self._native_config = c = egl.eglChooseConfig(_EGL_DISPLAY)[0]\n            self._native_context = egl.eglCreateContext(_EGL_DISPLAY, c, None)\n        else:\n            self._native_config = p.context.shared.ref._native_config\n            self._native_context = p.context.shared.ref._native_context\n\n        # Init widget\n        qt_window_types = QtCore.Qt.WindowType if PYQT6_API else QtCore.Qt\n        if p.always_on_top or not p.decorate:\n            hint = 0\n            hint |= 0 if p.decorate else qt_window_types.FramelessWindowHint\n            hint |= qt_window_types.WindowStaysOnTopHint if p.always_on_top else 0\n        else:\n            hint = qt_window_types.Widget  # can also be a window type\n\n        QWidget.__init__(self, p.parent, hint)\n\n        qt_window_attributes = QtCore.Qt.WidgetAttribute if PYQT6_API else QtCore.Qt\n        if 0:  # IS_LINUX or IS_RPI:\n            self.setAutoFillBackground(False)\n            self.setAttribute(qt_window_attributes.WA_NoSystemBackground, True)\n            self.setAttribute(qt_window_attributes.WA_OpaquePaintEvent, True)\n        elif IS_WIN:\n            self.setAttribute(qt_window_attributes.WA_PaintOnScreen, True)\n            self.setAutoFillBackground(False)\n\n        # Init surface\n        w = self.get_window_id()\n        self._surface = egl.eglCreateWindowSurface(_EGL_DISPLAY, c, w)\n        self.initializeGL()\n        self._initialized = True",
  "def get_window_id(self):\n        \"\"\"Get the window id of a PySide Widget. Might also work for PyQt4.\"\"\"\n        # Get Qt win id\n        winid = self.winId()\n\n        # On Linux this is it\n        if IS_RPI:\n            nw = (ctypes.c_int * 3)(winid, self.width(), self.height())\n            return ctypes.pointer(nw)\n        elif IS_LINUX:\n            return int(winid)  # Is int on PySide, but sip.voidptr on PyQt\n\n        # Get window id from stupid capsule thingy\n        # http://translate.google.com/translate?hl=en&sl=zh-CN&u=http://www.cnb\n        # logs.com/Shiren-Y/archive/2011/04/06/2007288.html&prev=/search%3Fq%3Dp\n        # yside%2Bdirectx%26client%3Dfirefox-a%26hs%3DIsJ%26rls%3Dorg.mozilla:n\n        # l:official%26channel%3Dfflb%26biw%3D1366%26bih%3D614\n        # Prepare\n        ctypes.pythonapi.PyCapsule_GetName.restype = ctypes.c_char_p\n        ctypes.pythonapi.PyCapsule_GetName.argtypes = [ctypes.py_object]\n        ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p\n        ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.py_object,\n                                                          ctypes.c_char_p]\n        # Extract handle from capsule thingy\n        name = ctypes.pythonapi.PyCapsule_GetName(winid)\n        handle = ctypes.pythonapi.PyCapsule_GetPointer(winid, name)\n        return handle",
  "def _vispy_close(self):\n        # Destroy EGL surface\n        if self._surface is not None:\n            egl.eglDestroySurface(_EGL_DISPLAY, self._surface)\n            self._surface = None\n        # Force the window or widget to shut down\n        self.close()",
  "def _vispy_set_current(self):\n        egl.eglMakeCurrent(_EGL_DISPLAY, self._surface,\n                           self._surface, self._native_context)",
  "def _vispy_swap_buffers(self):\n        egl.eglSwapBuffers(_EGL_DISPLAY, self._surface)",
  "def initializeGL(self):\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()",
  "def resizeEvent(self, event):\n        w, h = event.size().width(), event.size().height()\n        self._vispy_canvas.events.resize(size=(w, h))",
  "def paintEvent(self, event):\n        self._vispy_canvas.events.draw(region=None)\n\n        if IS_LINUX or IS_RPI:\n            # Arg, cannot get GL to draw to the widget, so we take a\n            # screenshot and draw that for now ...\n            # Further, QImage keeps a ref to the data that we pass, so\n            # we need to use a static buffer to prevent memory leakage\n            from ... import gloo\n            import numpy as np\n            if not hasattr(self, '_gl_buffer'):\n                self._gl_buffer = np.ones((3000 * 3000 * 4), np.uint8) * 255\n            # Take screenshot and turn into RGB QImage\n            im = gloo.read_pixels()\n            sze = im.shape[0] * im.shape[1]\n            self._gl_buffer[0:0+sze*4:4] = im[:, :, 2].ravel()\n            self._gl_buffer[1:0+sze*4:4] = im[:, :, 1].ravel()\n            self._gl_buffer[2:2+sze*4:4] = im[:, :, 0].ravel()\n            img = QtGui.QImage(self._gl_buffer, im.shape[1], im.shape[0],\n                               QtGui.QImage.Format_RGB32)\n            # Paint the image\n            painter = QtGui.QPainter()\n            painter.begin(self)\n            rect = QtCore.QRect(0, 0, self.width(), self.height())\n            painter.drawImage(rect, img)\n            painter.end()",
  "def paintEngine(self):\n        if IS_LINUX and not IS_RPI:\n            # For now we are drawing a screenshot\n            return QWidget.paintEngine(self)\n        else:\n            return None",
  "def _init_specific(self, p, kwargs):\n\n        # Deal with config\n        glformat = _set_config(p.context.config)\n        glformat.setSwapInterval(1 if p.vsync else 0)\n        # Deal with context\n        widget = kwargs.pop('shareWidget', None) or self\n        p.context.shared.add_ref('qt', widget)\n        if p.context.shared.ref is widget:\n            if widget is self:\n                widget = None  # QGLWidget does not accept self ;)\n        else:\n            widget = p.context.shared.ref\n            if 'shareWidget' in kwargs:\n                raise RuntimeError('Cannot use vispy to share context and '\n                                   'use built-in shareWidget.')\n\n        qt_window_types = QtCore.Qt.WindowType if PYQT6_API else QtCore.Qt\n        if p.always_on_top or not p.decorate:\n            hint = 0\n            hint |= 0 if p.decorate else qt_window_types.FramelessWindowHint\n            hint |= qt_window_types.WindowStaysOnTopHint if p.always_on_top else 0\n        else:\n            hint = qt_window_types.Widget  # can also be a window type\n\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            # Qt5 >= 5.4.0 - sharing is automatic\n            QGLWidget.__init__(self, p.parent, hint)\n\n            # Need to create an offscreen surface so we can get GL parameters\n            # without opening/showing the Widget. PyQt5 >= 5.4 will create the\n            # valid context later when the widget is shown.\n            self._secondary_context = QtGui.QOpenGLContext()\n            self._secondary_context.setShareContext(self.context())\n            self._secondary_context.setFormat(glformat)\n            self._secondary_context.create()\n\n            self._surface = QtGui.QOffscreenSurface()\n            self._surface.setFormat(glformat)\n            self._surface.create()\n            self._secondary_context.makeCurrent(self._surface)\n        else:\n            # Qt4 and Qt5 < 5.4.0 - sharing is explicitly requested\n            QGLWidget.__init__(self, p.parent, widget, hint)\n            # unused with this API\n            self._secondary_context = None\n            self._surface = None\n\n        self.setFormat(glformat)\n        self._initialized = True\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API and not self.isValid():\n            # On Qt5 >= 5.4.0, isValid is only true once the widget is shown\n            raise RuntimeError('context could not be created')\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API:\n            # to make consistent with other backends\n            self.setAutoBufferSwap(False)\n        qt_focus_policies = QtCore.Qt.FocusPolicy if PYQT6_API else QtCore.Qt\n        self.setFocusPolicy(qt_focus_policies.WheelFocus)",
  "def _vispy_close(self):\n        # Force the window or widget to shut down\n        self.close()\n        self.doneCurrent()\n        if not QT5_NEW_API and not PYSIDE6_API and not PYQT6_API:\n            self.context().reset()\n        if self._vispy_canvas is not None:\n            self._vispy_canvas.app.process_events()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_set_current(self):\n        if self._vispy_canvas is None:\n            return  # todo: can we get rid of this now?\n        if self.isValid():\n            self.makeCurrent()",
  "def _vispy_swap_buffers(self):\n        # Swap front and back buffer\n        if self._vispy_canvas is None:\n            return\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            ctx = self.context()\n            ctx.swapBuffers(ctx.surface())\n        else:\n            self.swapBuffers()",
  "def _vispy_get_fb_bind_location(self):\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            return self.defaultFramebufferObject()\n        else:\n            return QtBaseCanvasBackend._vispy_get_fb_bind_location(self)",
  "def initializeGL(self):\n        if self._vispy_canvas is None:\n            return\n        self._vispy_canvas.events.initialize()",
  "def resizeGL(self, w, h):\n        if self._vispy_canvas is None:\n            return\n        if hasattr(self, 'devicePixelRatio'):\n            # We take into account devicePixelRatio, which is non-unity on\n            # e.g HiDPI displays.\n            # self.devicePixelRatio() is a float and should have been in Qt5 according to the documentation\n            ratio = self.devicePixelRatio()\n            w = int(w * ratio)\n            h = int(h * ratio)\n        self._vispy_set_physical_size(w, h)\n        self._vispy_canvas.events.resize(size=(self.width(), self.height()),\n                                         physical_size=(w, h))",
  "def paintGL(self):\n        if self._vispy_canvas is None:\n            return\n        # (0, 0, self.width(), self.height()))\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.draw(region=None)\n\n        # Clear the alpha channel with QOpenGLWidget (Qt >= 5.4), otherwise the\n        # window is translucent behind non-opaque objects.\n        # Reference:  MRtrix3/mrtrix3#266\n        if QT5_NEW_API or PYSIDE6_API or PYQT6_API:\n            context = self._vispy_canvas.context\n            context.set_color_mask(False, False, False, True)\n            context.clear(color=True, depth=False, stencil=False)\n            context.set_color_mask(True, True, True, True)\n            context.flush()",
  "def __init__(self, vispy_timer):\n        # Make sure there is an app\n        app = ApplicationBackend()\n        app._vispy_get_native_app()\n        # Init\n        BaseTimerBackend.__init__(self, vispy_timer)\n        QtCore.QTimer.__init__(self)\n        self.timeout.connect(self._vispy_timeout)",
  "def _vispy_start(self, interval):\n        self.start(int(interval * 1000))",
  "def _vispy_stop(self):\n        self.stop()",
  "def _vispy_timeout(self):\n        self._vispy_timer._timeout()",
  "def _get_osmesa_windows():\n    return [win for win in _VP_OSMESA_ALL_WINDOWS\n            if isinstance(win, CanvasBackend)]",
  "class ApplicationBackend(BaseApplicationBackend):\n\n    def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()\n\n    def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)\n\n    def _vispy_get_backend_name(self):\n        return 'osmesa'\n\n    def _vispy_process_events(self):\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_osmesa_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()\n\n    def _vispy_run(self):\n        wins = _get_osmesa_windows()\n        while not all(w.closed for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()\n\n    def _vispy_quit(self):\n        wins = _get_osmesa_windows()\n        for win in wins:\n            win._vispy_close()\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []\n\n    def _vispy_get_native_app(self):\n        return osmesa",
  "class OSMesaContext(object):\n    \"\"\"\n    A wrapper around an OSMesa context that destroy the context when\n    garbage collected\n    \"\"\"\n\n    def __init__(self):\n        self.context = osmesa.OSMesaCreateContext()\n\n    def make_current(self, pixels, width, height):\n        return osmesa.OSMesaMakeCurrent(self.context, pixels, width, height)\n\n    def __del__(self):\n        osmesa.OSMesaDestroyContext(self.context)",
  "class CanvasBackend(BaseCanvasBackend):\n    \"\"\"OSMesa backend for Canvas\"\"\"\n\n    def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # We use _process_backend_kwargs() to \"serialize\" the kwargs\n        # and to check whether they match this backend's capability\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        # TODO: We do not support setting config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('osmesa', self)\n        if p.context.shared.ref is self:\n            self._native_context = OSMesaContext()\n        else:\n            self._native_context = p.context.shared.ref._native_context\n\n        self._closed = False\n        self._pixels = None\n        self._vispy_set_size(*p.size)\n        _VP_OSMESA_ALL_WINDOWS.append(self)\n\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()\n\n    def _vispy_set_current(self):\n        if self._native_context is None:\n            raise RuntimeError('Native context is None')\n        if self._pixels is None:\n            raise RuntimeError('Pixel buffer has already been deleted')\n\n        ok = self._native_context.make_current(self._pixels, self._size[0],\n                                               self._size[1])\n        if not ok:\n            raise RuntimeError('Failed attaching OSMesa rendering buffer')\n\n    def _vispy_swap_buffers(self):\n        if self._pixels is None:\n            raise RuntimeError('No pixel buffer')\n        gl.glFinish()\n\n    def _vispy_set_title(self, title):\n        pass\n\n    def _vispy_set_size(self, w, h):\n        self._pixels = osmesa.allocate_pixels_buffer(w, h)\n        self._size = (w, h)\n        self._vispy_canvas.events.resize(size=(w, h))\n        self._vispy_set_current()\n        self._vispy_update()\n\n    def _vispy_set_position(self, x, y):\n        pass\n\n    def _vispy_set_visible(self, visible):\n        if visible:\n            self._vispy_set_current()\n            self._vispy_update()\n\n    def _vispy_set_fullscreen(self, fullscreen):\n        pass\n\n    def _vispy_update(self):\n        # This is checked by osmesa ApplicationBackend in process_events\n        self._needs_draw = True\n\n    def _vispy_close(self):\n        if self.closed:\n            return\n        # We do not set self._native_context = None here because this causes\n        # trouble in case a canvas is closed multiple times (as in\n        # app.test_run()). The problem occurs in gloo's glir._gl_initialize\n        # when it tries to call glGetString(GL_VERSION).\n        # But OSMesa requires a context to be attached when calling\n        # glGetString otherwise it returns an empty string, which gloo doesn't\n        # like\n        self._closed = True\n        return\n\n    def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()\n\n    def _vispy_get_size(self):\n        if self._pixels is None:\n            return\n        return self._size\n\n    @property\n    def closed(self):\n        return self._closed\n\n    def _vispy_get_position(self):\n        return 0, 0\n\n    def _vispy_get_fullscreen(self):\n        return False\n\n    def _on_draw(self):\n        # This is called by the osmesa ApplicationBackend\n        if self._vispy_canvas is None or self._pixels is None:\n            raise RuntimeError('draw with no canvas or pixels attached')\n            return\n        self._vispy_set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "class TimerBackend(BaseTimerBackend):\n\n    def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()\n\n    def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval\n\n    def _vispy_stop(self):\n        self._next_time = float('inf')\n\n    def _tick(self):\n        if time() > self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "def __init__(self):\n        BaseApplicationBackend.__init__(self)\n        self._timers = list()",
  "def _add_timer(self, timer):\n        if timer not in self._timers:\n            self._timers.append(timer)",
  "def _vispy_get_backend_name(self):\n        return 'osmesa'",
  "def _vispy_process_events(self):\n        for timer in self._timers:\n            timer._tick()\n        wins = _get_osmesa_windows()\n        for win in wins:\n            if win._needs_draw:\n                win._needs_draw = False\n                win._on_draw()",
  "def _vispy_run(self):\n        wins = _get_osmesa_windows()\n        while not all(w.closed for w in wins):\n            self._vispy_process_events()\n        self._vispy_quit()",
  "def _vispy_quit(self):\n        wins = _get_osmesa_windows()\n        for win in wins:\n            win._vispy_close()\n        for timer in self._timers:\n            timer._vispy_stop()\n        self._timers = []",
  "def _vispy_get_native_app(self):\n        return osmesa",
  "def __init__(self):\n        self.context = osmesa.OSMesaCreateContext()",
  "def make_current(self, pixels, width, height):\n        return osmesa.OSMesaMakeCurrent(self.context, pixels, width, height)",
  "def __del__(self):\n        osmesa.OSMesaDestroyContext(self.context)",
  "def __init__(self, vispy_canvas, **kwargs):\n        BaseCanvasBackend.__init__(self, vispy_canvas)\n        # We use _process_backend_kwargs() to \"serialize\" the kwargs\n        # and to check whether they match this backend's capability\n        p = self._process_backend_kwargs(kwargs)\n\n        # Deal with config\n        # TODO: We do not support setting config\n        # ... use context.config\n        # Deal with context\n        p.context.shared.add_ref('osmesa', self)\n        if p.context.shared.ref is self:\n            self._native_context = OSMesaContext()\n        else:\n            self._native_context = p.context.shared.ref._native_context\n\n        self._closed = False\n        self._pixels = None\n        self._vispy_set_size(*p.size)\n        _VP_OSMESA_ALL_WINDOWS.append(self)\n\n        self._vispy_canvas.set_current()\n        self._vispy_canvas.events.initialize()",
  "def _vispy_set_current(self):\n        if self._native_context is None:\n            raise RuntimeError('Native context is None')\n        if self._pixels is None:\n            raise RuntimeError('Pixel buffer has already been deleted')\n\n        ok = self._native_context.make_current(self._pixels, self._size[0],\n                                               self._size[1])\n        if not ok:\n            raise RuntimeError('Failed attaching OSMesa rendering buffer')",
  "def _vispy_swap_buffers(self):\n        if self._pixels is None:\n            raise RuntimeError('No pixel buffer')\n        gl.glFinish()",
  "def _vispy_set_title(self, title):\n        pass",
  "def _vispy_set_size(self, w, h):\n        self._pixels = osmesa.allocate_pixels_buffer(w, h)\n        self._size = (w, h)\n        self._vispy_canvas.events.resize(size=(w, h))\n        self._vispy_set_current()\n        self._vispy_update()",
  "def _vispy_set_position(self, x, y):\n        pass",
  "def _vispy_set_visible(self, visible):\n        if visible:\n            self._vispy_set_current()\n            self._vispy_update()",
  "def _vispy_set_fullscreen(self, fullscreen):\n        pass",
  "def _vispy_update(self):\n        # This is checked by osmesa ApplicationBackend in process_events\n        self._needs_draw = True",
  "def _vispy_close(self):\n        if self.closed:\n            return\n        # We do not set self._native_context = None here because this causes\n        # trouble in case a canvas is closed multiple times (as in\n        # app.test_run()). The problem occurs in gloo's glir._gl_initialize\n        # when it tries to call glGetString(GL_VERSION).\n        # But OSMesa requires a context to be attached when calling\n        # glGetString otherwise it returns an empty string, which gloo doesn't\n        # like\n        self._closed = True\n        return",
  "def _vispy_warmup(self):\n        etime = time() + 0.1\n        while time() < etime:\n            sleep(0.01)\n            self._vispy_canvas.set_current()\n            self._vispy_canvas.app.process_events()",
  "def _vispy_get_size(self):\n        if self._pixels is None:\n            return\n        return self._size",
  "def closed(self):\n        return self._closed",
  "def _vispy_get_position(self):\n        return 0, 0",
  "def _vispy_get_fullscreen(self):\n        return False",
  "def _on_draw(self):\n        # This is called by the osmesa ApplicationBackend\n        if self._vispy_canvas is None or self._pixels is None:\n            raise RuntimeError('draw with no canvas or pixels attached')\n            return\n        self._vispy_set_current()\n        self._vispy_canvas.events.draw(region=None)",
  "def __init__(self, vispy_timer):\n        BaseTimerBackend.__init__(self, vispy_timer)\n        vispy_timer._app._backend._add_timer(self)\n        self._vispy_stop()",
  "def _vispy_start(self, interval):\n        self._interval = interval\n        self._next_time = time() + self._interval",
  "def _vispy_stop(self):\n        self._next_time = float('inf')",
  "def _tick(self):\n        if time() > self._next_time:\n            self._vispy_timer._timeout()\n            self._next_time = time() + self._interval",
  "class SurfacePlotVisual(MeshVisual):\n    \"\"\"Displays a surface plot on a regular x,y grid\n\n    Parameters\n    ----------\n    x : ndarray | None\n        1D/2D array of values specifying the x positions of vertices in the\n        grid. In case 1D array given as input, the values will be replicated\n        to fill the 2D array of size(z). If None, values will be assumed to\n        be integers.\n    y : ndarray | None\n        1D/2D array of values specifying the y positions of vertices in the\n        grid. In case 1D array given as input, the values will be replicated\n        to fill the 2D array of size(z). If None, values will be assumed to\n        be integers.\n    z : ndarray\n        2D array of height values for each grid vertex.\n    colors : ndarray\n        (width, height, 4) array of vertex colors.\n\n    Notes\n    -----\n    All arguments are optional.\n\n    Note that if vertex positions are updated, the normal vectors for each\n    triangle must be recomputed. This is somewhat expensive if the surface\n    was initialized with smooth=False and very expensive if smooth=True.\n    For faster performance, initialize with compute_normals=False and use\n    per-vertex colors or a material that does not require normals.\n    \"\"\"\n\n    def __init__(self, x=None, y=None, z=None, colors=None, **kwargs):\n        # The x, y, z, and colors arguments are passed to set_data().\n        # All other keyword arguments are passed to MeshVisual.__init__().\n        self._x = None\n        self._y = None\n        self._z = None\n        self.__vertices = None\n        self.__faces = None\n        self.__meshdata = MeshData()\n        kwargs.setdefault('shading', 'smooth')\n        MeshVisual.__init__(self, **kwargs)\n        self.set_data(x, y, z, colors)\n\n    def _update_x_data(self, x):\n        if x is not None:\n            if self._x is None or len(x) != len(self._x):\n                self.__vertices = None\n            self._x = x\n\n    def _update_y_data(self, y):\n        if y is not None:\n            if self._y is None or len(y) != len(self._y):\n                self.__vertices = None\n            self._y = y\n\n    def _update_z_data(self, z):\n        if z is not None:\n            if self._x is not None and z.shape[0] != len(self._x):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            if self._y is not None and z.shape[1] != len(self._y):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            self._z = z\n            if (self.__vertices is not None and\n                    self._z.shape != self.__vertices.shape[:2]):\n                self.__vertices = None\n\n    def _update_mesh_vertices(self, x_is_new, y_is_new, z_is_new):\n        new_vertices = False\n        update_vertices = False\n        update_faces = False\n\n        # Generate vertex and face array\n        if self.__vertices is None:\n            self.__vertices = np.empty((self._z.shape[0], self._z.shape[1], 3),\n                                       dtype=np.float32)\n            self.__faces = self._generate_faces()\n            new_vertices = True\n            update_faces = True\n\n        # Copy x, y, z data into vertex array\n        if new_vertices or x_is_new:\n            if not x_is_new and self._x is None:\n                x = np.arange(self._z.shape[0])\n            else:\n                x = self._x\n            if x.ndim == 1:\n                x = x.reshape(len(x), 1)\n            # Copy the 2D data into the appropriate slice\n            self.__vertices[:, :, 0] = x\n            update_vertices = True\n\n        if new_vertices or y_is_new:\n            if not y_is_new and self._y is None:\n                y = np.arange(self._z.shape[1])\n            else:\n                y = self._y\n            if y.ndim == 1:\n                y = y.reshape(1, len(y))\n            # Copy the 2D data into the appropriate slice\n            self.__vertices[:, :, 1] = y\n            update_vertices = True\n\n        if new_vertices or z_is_new:\n            self.__vertices[..., 2] = self._z\n            update_vertices = True\n        return update_faces, update_vertices\n\n    def _prepare_mesh_colors(self, colors):\n        if colors is None:\n            return\n        colors = np.asarray(colors)\n        if colors.ndim == 3:\n            # convert (width, height, 4) to (num_verts, 4)\n            vert_shape = self.__vertices.shape\n            num_vertices = vert_shape[0] * vert_shape[1]\n            colors = colors.reshape(num_vertices, 3)\n        return colors\n\n    def set_data(self, x=None, y=None, z=None, colors=None):\n        \"\"\"Update the data in this surface plot.\n\n        Parameters\n        ----------\n        x : ndarray | None\n            1D/2D array of values specifying the x positions of vertices in\n            the grid. In case 1D array given as input, the values will be\n            replicated to fill the 2D array of size(z). If None, values will be\n            assumed to be integers.\n        y : ndarray | None\n            1D/2D array of values specifying the x positions of vertices in\n            the grid. In case 1D array given as input, the values will be\n            replicated to fill the 2D array of size(z). If None, values will be\n            assumed to be integers.\n        z : ndarray\n            2D array of height values for each grid vertex.\n        colors : ndarray\n            (width, height, 4) array of vertex colors.\n        \"\"\"\n        self._update_x_data(x)\n        self._update_y_data(y)\n        self._update_z_data(z)\n\n        if self._z is None:\n            # no mesh data to plot so no need to update\n            return\n\n        update_faces, update_vertices = self._update_mesh_vertices(\n            x is not None,\n            y is not None,\n            z is not None\n        )\n\n        colors = self._prepare_mesh_colors(colors)\n        update_colors = colors is not None\n        if update_colors:\n            self.__meshdata.set_vertex_colors(colors)\n        if update_faces:\n            self.__meshdata.set_faces(self.__faces)\n        if update_vertices:\n            self.__meshdata.set_vertices(\n                self.__vertices.reshape(self.__vertices.shape[0] *\n                                        self.__vertices.shape[1], 3))\n        if update_faces or update_vertices or update_colors:\n            MeshVisual.set_data(self, meshdata=self.__meshdata)\n\n    def _generate_faces(self):\n        cols = self._z.shape[1] - 1\n        rows = self._z.shape[0] - 1\n        faces = np.empty((cols * rows * 2, 3), dtype=np.uint)\n        rowtemplate1 = (np.arange(cols).reshape(cols, 1) +\n                        np.array([[0, 1, cols + 1]]))\n        rowtemplate2 = (np.arange(cols).reshape(cols, 1) +\n                        np.array([[cols + 1, 1, cols + 2]]))\n        for row in range(rows):\n            start = row * cols * 2\n            faces[start:start + cols] = rowtemplate1 + row * (cols + 1)\n            faces[start + cols:start + (cols * 2)] =\\\n                rowtemplate2 + row * (cols + 1)\n        return faces",
  "def __init__(self, x=None, y=None, z=None, colors=None, **kwargs):\n        # The x, y, z, and colors arguments are passed to set_data().\n        # All other keyword arguments are passed to MeshVisual.__init__().\n        self._x = None\n        self._y = None\n        self._z = None\n        self.__vertices = None\n        self.__faces = None\n        self.__meshdata = MeshData()\n        kwargs.setdefault('shading', 'smooth')\n        MeshVisual.__init__(self, **kwargs)\n        self.set_data(x, y, z, colors)",
  "def _update_x_data(self, x):\n        if x is not None:\n            if self._x is None or len(x) != len(self._x):\n                self.__vertices = None\n            self._x = x",
  "def _update_y_data(self, y):\n        if y is not None:\n            if self._y is None or len(y) != len(self._y):\n                self.__vertices = None\n            self._y = y",
  "def _update_z_data(self, z):\n        if z is not None:\n            if self._x is not None and z.shape[0] != len(self._x):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            if self._y is not None and z.shape[1] != len(self._y):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            self._z = z\n            if (self.__vertices is not None and\n                    self._z.shape != self.__vertices.shape[:2]):\n                self.__vertices = None",
  "def _update_mesh_vertices(self, x_is_new, y_is_new, z_is_new):\n        new_vertices = False\n        update_vertices = False\n        update_faces = False\n\n        # Generate vertex and face array\n        if self.__vertices is None:\n            self.__vertices = np.empty((self._z.shape[0], self._z.shape[1], 3),\n                                       dtype=np.float32)\n            self.__faces = self._generate_faces()\n            new_vertices = True\n            update_faces = True\n\n        # Copy x, y, z data into vertex array\n        if new_vertices or x_is_new:\n            if not x_is_new and self._x is None:\n                x = np.arange(self._z.shape[0])\n            else:\n                x = self._x\n            if x.ndim == 1:\n                x = x.reshape(len(x), 1)\n            # Copy the 2D data into the appropriate slice\n            self.__vertices[:, :, 0] = x\n            update_vertices = True\n\n        if new_vertices or y_is_new:\n            if not y_is_new and self._y is None:\n                y = np.arange(self._z.shape[1])\n            else:\n                y = self._y\n            if y.ndim == 1:\n                y = y.reshape(1, len(y))\n            # Copy the 2D data into the appropriate slice\n            self.__vertices[:, :, 1] = y\n            update_vertices = True\n\n        if new_vertices or z_is_new:\n            self.__vertices[..., 2] = self._z\n            update_vertices = True\n        return update_faces, update_vertices",
  "def _prepare_mesh_colors(self, colors):\n        if colors is None:\n            return\n        colors = np.asarray(colors)\n        if colors.ndim == 3:\n            # convert (width, height, 4) to (num_verts, 4)\n            vert_shape = self.__vertices.shape\n            num_vertices = vert_shape[0] * vert_shape[1]\n            colors = colors.reshape(num_vertices, 3)\n        return colors",
  "def set_data(self, x=None, y=None, z=None, colors=None):\n        \"\"\"Update the data in this surface plot.\n\n        Parameters\n        ----------\n        x : ndarray | None\n            1D/2D array of values specifying the x positions of vertices in\n            the grid. In case 1D array given as input, the values will be\n            replicated to fill the 2D array of size(z). If None, values will be\n            assumed to be integers.\n        y : ndarray | None\n            1D/2D array of values specifying the x positions of vertices in\n            the grid. In case 1D array given as input, the values will be\n            replicated to fill the 2D array of size(z). If None, values will be\n            assumed to be integers.\n        z : ndarray\n            2D array of height values for each grid vertex.\n        colors : ndarray\n            (width, height, 4) array of vertex colors.\n        \"\"\"\n        self._update_x_data(x)\n        self._update_y_data(y)\n        self._update_z_data(z)\n\n        if self._z is None:\n            # no mesh data to plot so no need to update\n            return\n\n        update_faces, update_vertices = self._update_mesh_vertices(\n            x is not None,\n            y is not None,\n            z is not None\n        )\n\n        colors = self._prepare_mesh_colors(colors)\n        update_colors = colors is not None\n        if update_colors:\n            self.__meshdata.set_vertex_colors(colors)\n        if update_faces:\n            self.__meshdata.set_faces(self.__faces)\n        if update_vertices:\n            self.__meshdata.set_vertices(\n                self.__vertices.reshape(self.__vertices.shape[0] *\n                                        self.__vertices.shape[1], 3))\n        if update_faces or update_vertices or update_colors:\n            MeshVisual.set_data(self, meshdata=self.__meshdata)",
  "def _generate_faces(self):\n        cols = self._z.shape[1] - 1\n        rows = self._z.shape[0] - 1\n        faces = np.empty((cols * rows * 2, 3), dtype=np.uint)\n        rowtemplate1 = (np.arange(cols).reshape(cols, 1) +\n                        np.array([[0, 1, cols + 1]]))\n        rowtemplate2 = (np.arange(cols).reshape(cols, 1) +\n                        np.array([[cols + 1, 1, cols + 2]]))\n        for row in range(rows):\n            start = row * cols * 2\n            faces[start:start + cols] = rowtemplate1 + row * (cols + 1)\n            faces[start + cols:start + (cols * 2)] =\\\n                rowtemplate2 + row * (cols + 1)\n        return faces",
  "class ImageVisual(Visual):\n    \"\"\"Visual subclass displaying an image.\n\n    Parameters\n    ----------\n    data : ndarray\n        ImageVisual data. Can be shape (M, N), (M, N, 3), or (M, N, 4).\n        If floating point data is provided and contains NaNs, they will\n        be made transparent (discarded) for the single band data case when\n        scaling is done on the GPU (see ``texture_format``). On the CPU,\n        single band NaNs are mapped to 0 as they are sent to the GPU which\n        result in them using the lowest ``clim`` value in the GPU.\n        For RGB data, NaNs will be mapped to the lowest ``clim`` value.\n        If the Alpha band is NaN it will be mapped to 0 (transparent).\n        Note that NaN handling is not required by some OpenGL implementations\n        and NaNs may be treated differently on some systems (ex. as 0s).\n    method : str\n        Selects method of rendering image in case of non-linear transforms.\n        Each method produces similar results, but may trade efficiency\n        and accuracy. If the transform is linear, this parameter is ignored\n        and a single quad is drawn around the area of the image.\n\n            * 'auto': Automatically select 'impostor' if the image is drawn\n              with a nonlinear transform; otherwise select 'subdivide'.\n            * 'subdivide': ImageVisual is represented as a grid of triangles\n              with texture coordinates linearly mapped.\n            * 'impostor': ImageVisual is represented as a quad covering the\n              entire view, with texture coordinates determined by the\n              transform. This produces the best transformation results, but may\n              be slow.\n\n    grid: tuple (rows, cols)\n        If method='subdivide', this tuple determines the number of rows and\n        columns in the image grid.\n    cmap : str | ColorMap\n        Colormap to use for luminance images.\n    clim : str | tuple\n        Limits to use for the colormap. I.e. the values that map to black and white\n        in a gray colormap. Can be 'auto' to auto-set bounds to\n        the min and max of the data. If not given or None, 'auto' is used.\n    gamma : float\n        Gamma to use during colormap lookup.  Final color will be cmap(val**gamma).\n        by default: 1.\n    interpolation : str\n        Selects method of texture interpolation. Makes use of the two hardware\n        interpolation methods and the available interpolation methods defined\n        in vispy/gloo/glsl/misc/spatial_filters.frag\n\n            * 'nearest': Default, uses 'nearest' with Texture interpolation.\n            * 'linear': uses 'linear' with Texture interpolation.\n            * 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'cubic',\n                'catrom', 'mitchell', 'spline16', 'spline36', 'gaussian',\n                'bessel', 'sinc', 'lanczos', 'blackman'\n            * 'custom': uses the sampling kernel provided through 'custom_kernel'.\n    texture_format: numpy.dtype | str | None\n        How to store data on the GPU. OpenGL allows for many different storage\n        formats and schemes for the low-level texture data stored in the GPU.\n        Most common is unsigned integers or floating point numbers.\n        Unsigned integers are the most widely supported while other formats\n        may not be supported on older versions of OpenGL or with older GPUs.\n        Default value is ``None`` which means data will be scaled on the\n        CPU and the result stored in the GPU as an unsigned integer. If a\n        numpy dtype object, an internal texture format will be chosen to\n        support that dtype and data will *not* be scaled on the CPU. Not all\n        dtypes are supported. If a string, then\n        it must be one of the OpenGL internalformat strings described in the\n        table on this page: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml\n        The name should have `GL_` removed and be lowercase (ex.\n        `GL_R32F` becomes ``'r32f'``). Lastly, this can also be the string\n        ``'auto'`` which will use the data type of the provided image data\n        to determine the internalformat of the texture.\n        When this is specified (not ``None``) data is scaled on the\n        GPU which allows for faster color limit changes. Additionally, when\n        32-bit float data is provided it won't be copied before being\n        transferred to the GPU.\n    custom_kernel: numpy.ndarray\n        Kernel used for texture sampling when interpolation is set to 'custom'.\n    **kwargs : dict\n        Keyword arguments to pass to `Visual`.\n\n    Notes\n    -----\n    The colormap functionality through ``cmap`` and ``clim`` are only used\n    if the data are 2D.\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    _func_templates = {\n        'texture_lookup_interpolated': _INTERPOLATION_TEMPLATE,\n        'texture_lookup_custom': _CUSTOM_FILTER,\n        'texture_lookup': _TEXTURE_LOOKUP,\n        'clim_float': _APPLY_CLIM_FLOAT,\n        'clim': _APPLY_CLIM,\n        'gamma_float': _APPLY_GAMMA_FLOAT,\n        'gamma': _APPLY_GAMMA,\n        'null_color_transform': _NULL_COLOR_TRANSFORM,\n        'red_to_luminance': _C2L_RED,\n    }\n\n    def __init__(self, data=None, method='auto', grid=(1, 1),\n                 cmap='viridis', clim='auto', gamma=1.0,\n                 interpolation='nearest', texture_format=None,\n                 custom_kernel=np.ones((1, 1)), **kwargs):\n        \"\"\"Initialize image properties, texture storage, and interpolation methods.\"\"\"\n        self._data = None\n\n        # load 'float packed rgba8' interpolation kernel\n        # to load float interpolation kernel use\n        # `load_spatial_filters(packed=False)`\n        kernel, interpolation_names = load_spatial_filters()\n\n        self._kerneltex = Texture2D(kernel, interpolation='nearest')\n        # The unpacking can be debugged by changing \"spatial-filters.frag\"\n        # to have the \"unpack\" function just return the .r component. That\n        # combined with using the below as the _kerneltex allows debugging\n        # of the pipeline\n        # self._kerneltex = Texture2D(kernel, interpolation='linear',\n        #                             internalformat='r32f')\n\n        interpolation_names, interpolation_fun = self._init_interpolation(\n            interpolation_names)\n        self._interpolation_names = interpolation_names\n        self._interpolation_fun = interpolation_fun\n        self._interpolation = interpolation\n        if self._interpolation not in self._interpolation_names:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_names))\n\n        self._method = method\n        self._grid = grid\n        self._need_texture_upload = True\n        self._need_vertex_update = True\n        self._need_colortransform_update = True\n        self._need_interpolation_update = True\n        self._texture = self._init_texture(data, texture_format)\n        self._subdiv_position = VertexBuffer()\n        self._subdiv_texcoord = VertexBuffer()\n\n        # impostor quad covers entire viewport\n        vertices = np.array([[-1, -1], [1, -1], [1, 1],\n                             [-1, -1], [1, 1], [-1, 1]],\n                            dtype=np.float32)\n        self._impostor_coords = VertexBuffer(vertices)\n        self._null_tr = NullTransform()\n\n        self._init_view(self)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.set_gl_state('translucent', cull_face=False)\n        self._draw_mode = 'triangles'\n\n        # define _data_lookup_fn as None, will be setup in\n        # self._build_interpolation()\n        self._data_lookup_fn = None\n\n        self.clim = clim or \"auto\"  # None -> \"auto\"\n        self.cmap = cmap\n        self.gamma = gamma\n        self.custom_kernel = custom_kernel\n\n        if data is not None:\n            self.set_data(data)\n        self.freeze()\n\n    def _init_interpolation(self, interpolation_names):\n        # create interpolation shader functions for available interpolations\n        fun = [Function(self._func_templates['texture_lookup_interpolated'] % (n + '2D'))\n               for n in interpolation_names]\n        interpolation_names = [n.lower() for n in interpolation_names]\n\n        # add custom filter\n        fun.append(Function(self._func_templates['texture_lookup_custom']))\n        interpolation_names.append('custom')\n\n        interpolation_fun = dict(zip(interpolation_names, fun))\n        interpolation_names = tuple(sorted(interpolation_names))\n\n        # overwrite \"nearest\" and \"linear\" spatial-filters\n        # with  \"hardware\" interpolation _data_lookup_fn\n        hardware_lookup = Function(self._func_templates['texture_lookup'])\n        interpolation_fun['nearest'] = hardware_lookup\n        interpolation_fun['linear'] = hardware_lookup\n        # alias bilinear to linear and bicubic to cubic (but deprecate)\n        interpolation_names = interpolation_names + ('bilinear', 'bicubic')\n        return interpolation_names, interpolation_fun\n\n    def _init_texture(self, data, texture_format, **texture_kwargs):\n        if self._interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        if texture_format is None:\n            tex = CPUScaledTexture2D(\n                data, interpolation=texture_interpolation,\n                **texture_kwargs\n            )\n        else:\n            tex = GPUScaledTexture2D(\n                data, internalformat=texture_format,\n                interpolation=texture_interpolation,\n                **texture_kwargs\n            )\n        return tex\n\n    def set_data(self, image):\n        \"\"\"Set the image data.\n\n        Parameters\n        ----------\n        image : array-like\n            The image data.\n        texture_format : str or None\n\n        \"\"\"\n        data = np.asarray(image)\n        if np.iscomplexobj(data):\n            raise TypeError(\n                \"Complex data types not supported. Please use 'ComplexImage' instead\"\n            )\n        if should_cast_to_f32(data.dtype):\n            data = data.astype(np.float32)\n        # can the texture handle this data?\n        self._texture.check_data_format(data)\n        if self._data is None or self._data.shape[:2] != data.shape[:2]:\n            # Only rebuild if the size of the image changed\n            self._need_vertex_update = True\n        self._data = data\n        self._need_texture_upload = True\n\n    def view(self):\n        \"\"\"Get the :class:`vispy.visuals.visual.VisualView` for this visual.\"\"\"\n        v = Visual.view(self)\n        self._init_view(v)\n        return v\n\n    def _init_view(self, view):\n        # Store some extra variables per-view\n        view._need_method_update = True\n        view._method_used = None\n\n    @property\n    def clim(self):\n        \"\"\"Get color limits used when rendering the image (cmin, cmax).\"\"\"\n        return self._texture.clim\n\n    @clim.setter\n    def clim(self, clim):\n        if self._texture.set_clim(clim):\n            self._need_texture_upload = True\n        self._update_colortransform_clim()\n        self.update()\n\n    def _update_colortransform_clim(self):\n        if self._need_colortransform_update:\n            # we are going to rebuild anyway so just do it later\n            return\n        try:\n            norm_clims = self._texture.clim_normalized\n        except RuntimeError:\n            return\n        else:\n            # shortcut so we don't have to rebuild the whole color transform\n            self.shared_program.frag['color_transform'][1]['clim'] = norm_clims\n\n    @property\n    def cmap(self):\n        \"\"\"Get the colormap object applied to luminance (single band) data.\"\"\"\n        return self._cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self._need_colortransform_update = True\n        self.update()\n\n    @property\n    def gamma(self):\n        \"\"\"Get the gamma used when rendering the image.\"\"\"\n        return self._gamma\n\n    @gamma.setter\n    def gamma(self, value):\n        \"\"\"Set gamma used when rendering the image.\"\"\"\n        if value <= 0:\n            raise ValueError(\"gamma must be > 0\")\n        self._gamma = float(value)\n        # shortcut so we don't have to rebuild the color transform\n        if not self._need_colortransform_update:\n            self.shared_program.frag['color_transform'][2]['gamma'] = self._gamma\n        self.update()\n\n    @property\n    def method(self):\n        \"\"\"Get rendering method name.\"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, m):\n        if self._method != m:\n            self._method = m\n            self._need_vertex_update = True\n            self.update()\n\n    @property\n    def size(self):\n        \"\"\"Get size of the image (width, height).\"\"\"\n        return self._data.shape[:2][::-1]\n\n    @property\n    def interpolation(self):\n        \"\"\"Get interpolation algorithm name.\"\"\"\n        return self._interpolation\n\n    @interpolation.setter\n    def interpolation(self, i):\n        if i not in self._interpolation_names:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_names))\n        if self._interpolation != i:\n            self._interpolation = i\n            self._need_interpolation_update = True\n            self.update()\n\n    @property\n    def interpolation_functions(self):\n        \"\"\"Get names of possible interpolation methods.\"\"\"\n        return self._interpolation_names\n\n    @property\n    def custom_kernel(self):\n        \"\"\"Kernel used by 'custom' interpolation for texture sampling\"\"\"\n        return self._custom_kernel\n\n    @custom_kernel.setter\n    def custom_kernel(self, value):\n        value = np.asarray(value, dtype=np.float32)\n        if value.ndim != 2:\n            raise ValueError(f'kernel must have 2 dimensions; got {value.ndim}')\n        self._custom_kernel = value\n        self._custom_kerneltex = Texture2D(value, interpolation='nearest')\n        if self._data_lookup_fn is not None and 'kernel' in self._data_lookup_fn:\n            self._data_lookup_fn['kernel'] = self._custom_kerneltex\n            self._data_lookup_fn['kernel_shape'] = value.shape[::-1]\n        self.update()\n\n    # The interpolation code could be transferred to a dedicated filter\n    # function in visuals/filters as discussed in #1051\n    def _build_interpolation(self):\n        \"\"\"Rebuild the _data_lookup_fn for different interpolations.\"\"\"\n        interpolation = self._interpolation\n        # alias bilinear to linear\n        if interpolation == 'bilinear':\n            warnings.warn(\n                \"'bilinear' interpolation is Deprecated. Use 'linear' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'linear'\n        # alias bicubic to cubic\n        if interpolation == 'bicubic':\n            warnings.warn(\n                \"'bicubic' interpolation is Deprecated. Use 'cubic' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'cubic'\n        self._data_lookup_fn = self._interpolation_fun[interpolation]\n        self.shared_program.frag['get_data'] = self._data_lookup_fn\n\n        # only 'linear' and 'custom' use 'linear' texture interpolation\n        if interpolation in ('linear', 'custom'):\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        # 'nearest' (and also 'linear') doesn't use spatial_filters.frag\n        # so u_kernel and shape setting is skipped\n        if interpolation not in ('nearest', 'linear'):\n            self._data_lookup_fn['shape'] = self._data.shape[:2][::-1]\n            if interpolation == 'custom':\n                self._data_lookup_fn['kernel'] = self._custom_kerneltex\n                self._data_lookup_fn['kernel_shape'] = self._custom_kernel.shape[::-1]\n            else:\n                self.shared_program['u_kernel'] = self._kerneltex\n\n        if self._texture.interpolation != texture_interpolation:\n            self._texture.interpolation = texture_interpolation\n\n        self._data_lookup_fn['texture'] = self._texture\n\n        self._need_interpolation_update = False\n\n    def _build_vertex_data(self):\n        \"\"\"Rebuild the vertex buffers for the subdivide method.\"\"\"\n        grid = self._grid\n        w = 1.0 / grid[1]\n        h = 1.0 / grid[0]\n\n        quad = np.array([[0, 0, 0], [w, 0, 0], [w, h, 0],\n                         [0, 0, 0], [w, h, 0], [0, h, 0]],\n                        dtype=np.float32)\n        quads = np.empty((grid[1], grid[0], 6, 3), dtype=np.float32)\n        quads[:] = quad\n\n        mgrid = np.mgrid[0.:grid[1], 0.:grid[0]].transpose(1, 2, 0)\n        mgrid = mgrid[:, :, np.newaxis, :]\n        mgrid[..., 0] *= w\n        mgrid[..., 1] *= h\n\n        quads[..., :2] += mgrid\n        tex_coords = quads.reshape(grid[1]*grid[0]*6, 3)\n        tex_coords = np.ascontiguousarray(tex_coords[:, :2])\n        vertices = tex_coords * self.size\n\n        self._subdiv_position.set_data(vertices.astype('float32'))\n        self._subdiv_texcoord.set_data(tex_coords.astype('float32'))\n        self._need_vertex_update = False\n\n    def _update_method(self, view):\n        \"\"\"Decide which method to use for *view* and configure it accordingly.\"\"\"\n        method = self._method\n        if method == 'auto':\n            if view.transforms.get_transform().Linear:\n                method = 'subdivide'\n            else:\n                method = 'impostor'\n        view._method_used = method\n\n        if method == 'subdivide':\n            view.view_program['method'] = 0\n            view.view_program['a_position'] = self._subdiv_position\n            view.view_program['a_texcoord'] = self._subdiv_texcoord\n        elif method == 'impostor':\n            view.view_program['method'] = 1\n            view.view_program['a_position'] = self._impostor_coords\n            view.view_program['a_texcoord'] = self._impostor_coords\n        else:\n            raise ValueError(\"Unknown image draw method '%s'\" % method)\n\n        self.shared_program['image_size'] = self.size\n        view._need_method_update = False\n        self._prepare_transforms(view)\n\n    def _build_texture(self):\n        try:\n            pre_clims = self._texture.clim_normalized\n        except RuntimeError:\n            pre_clims = \"auto\"\n        pre_internalformat = self._texture.internalformat\n        self._texture.scale_and_set_data(self._data)\n        post_clims = self._texture.clim_normalized\n        post_internalformat = self._texture.internalformat\n        # color transform needs rebuilding if the internalformat was changed\n        # new color limits need to be assigned if the normalized clims changed\n        # otherwise, the original color transform should be fine\n        new_if = post_internalformat != pre_internalformat\n        new_cl = post_clims != pre_clims\n        if new_if:\n            self._need_colortransform_update = True\n        elif new_cl and not self._need_colortransform_update:\n            # shortcut so we don't have to rebuild the whole color transform\n            self.shared_program.frag['color_transform'][1]['clim'] = self._texture.clim_normalized\n        self._need_texture_upload = False\n\n    def _compute_bounds(self, axis, view):\n        if axis > 1:\n            return 0, 0\n        else:\n            return 0, self.size[axis]\n\n    def _build_color_transform(self):\n        if self._data.ndim == 2 or self._data.shape[2] == 1:\n            # luminance data\n            fclim = Function(self._func_templates['clim_float'])\n            fgamma = Function(self._func_templates['gamma_float'])\n            # NOTE: red_to_luminance only uses the red component, fancy internalformats\n            #   may need to use the other components or a different function chain\n            fun = FunctionChain(\n                None, [Function(self._func_templates['red_to_luminance']), fclim, fgamma, Function(self.cmap.glsl_map)]\n            )\n        else:\n            # RGB/A image data (no colormap)\n            fclim = Function(self._func_templates['clim'])\n            fgamma = Function(self._func_templates['gamma'])\n            fun = FunctionChain(None, [Function(self._func_templates['null_color_transform']), fclim, fgamma])\n        fclim['clim'] = self._texture.clim_normalized\n        fgamma['gamma'] = self.gamma\n        return fun\n\n    def _prepare_transforms(self, view):\n        trs = view.transforms\n        prg = view.view_program\n        method = view._method_used\n        if method == 'subdivide':\n            prg.vert['transform'] = trs.get_transform()\n            prg.frag['transform'] = self._null_tr\n        else:\n            prg.vert['transform'] = self._null_tr\n            prg.frag['transform'] = trs.get_transform().inverse\n\n    def _prepare_draw(self, view):\n        if self._data is None:\n            return False\n\n        if self._need_interpolation_update:\n            self._build_interpolation()\n\n        if self._need_texture_upload:\n            self._build_texture()\n\n        if self._need_colortransform_update:\n            prg = view.view_program\n            self.shared_program.frag['color_transform'] = self._build_color_transform()\n            self._need_colortransform_update = False\n            prg['texture2D_LUT'] = self.cmap.texture_lut()\n\n        if self._need_vertex_update:\n            self._build_vertex_data()\n\n        if view._need_method_update:\n            self._update_method(view)",
  "def __init__(self, data=None, method='auto', grid=(1, 1),\n                 cmap='viridis', clim='auto', gamma=1.0,\n                 interpolation='nearest', texture_format=None,\n                 custom_kernel=np.ones((1, 1)), **kwargs):\n        \"\"\"Initialize image properties, texture storage, and interpolation methods.\"\"\"\n        self._data = None\n\n        # load 'float packed rgba8' interpolation kernel\n        # to load float interpolation kernel use\n        # `load_spatial_filters(packed=False)`\n        kernel, interpolation_names = load_spatial_filters()\n\n        self._kerneltex = Texture2D(kernel, interpolation='nearest')\n        # The unpacking can be debugged by changing \"spatial-filters.frag\"\n        # to have the \"unpack\" function just return the .r component. That\n        # combined with using the below as the _kerneltex allows debugging\n        # of the pipeline\n        # self._kerneltex = Texture2D(kernel, interpolation='linear',\n        #                             internalformat='r32f')\n\n        interpolation_names, interpolation_fun = self._init_interpolation(\n            interpolation_names)\n        self._interpolation_names = interpolation_names\n        self._interpolation_fun = interpolation_fun\n        self._interpolation = interpolation\n        if self._interpolation not in self._interpolation_names:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_names))\n\n        self._method = method\n        self._grid = grid\n        self._need_texture_upload = True\n        self._need_vertex_update = True\n        self._need_colortransform_update = True\n        self._need_interpolation_update = True\n        self._texture = self._init_texture(data, texture_format)\n        self._subdiv_position = VertexBuffer()\n        self._subdiv_texcoord = VertexBuffer()\n\n        # impostor quad covers entire viewport\n        vertices = np.array([[-1, -1], [1, -1], [1, 1],\n                             [-1, -1], [1, 1], [-1, 1]],\n                            dtype=np.float32)\n        self._impostor_coords = VertexBuffer(vertices)\n        self._null_tr = NullTransform()\n\n        self._init_view(self)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.set_gl_state('translucent', cull_face=False)\n        self._draw_mode = 'triangles'\n\n        # define _data_lookup_fn as None, will be setup in\n        # self._build_interpolation()\n        self._data_lookup_fn = None\n\n        self.clim = clim or \"auto\"  # None -> \"auto\"\n        self.cmap = cmap\n        self.gamma = gamma\n        self.custom_kernel = custom_kernel\n\n        if data is not None:\n            self.set_data(data)\n        self.freeze()",
  "def _init_interpolation(self, interpolation_names):\n        # create interpolation shader functions for available interpolations\n        fun = [Function(self._func_templates['texture_lookup_interpolated'] % (n + '2D'))\n               for n in interpolation_names]\n        interpolation_names = [n.lower() for n in interpolation_names]\n\n        # add custom filter\n        fun.append(Function(self._func_templates['texture_lookup_custom']))\n        interpolation_names.append('custom')\n\n        interpolation_fun = dict(zip(interpolation_names, fun))\n        interpolation_names = tuple(sorted(interpolation_names))\n\n        # overwrite \"nearest\" and \"linear\" spatial-filters\n        # with  \"hardware\" interpolation _data_lookup_fn\n        hardware_lookup = Function(self._func_templates['texture_lookup'])\n        interpolation_fun['nearest'] = hardware_lookup\n        interpolation_fun['linear'] = hardware_lookup\n        # alias bilinear to linear and bicubic to cubic (but deprecate)\n        interpolation_names = interpolation_names + ('bilinear', 'bicubic')\n        return interpolation_names, interpolation_fun",
  "def _init_texture(self, data, texture_format, **texture_kwargs):\n        if self._interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        if texture_format is None:\n            tex = CPUScaledTexture2D(\n                data, interpolation=texture_interpolation,\n                **texture_kwargs\n            )\n        else:\n            tex = GPUScaledTexture2D(\n                data, internalformat=texture_format,\n                interpolation=texture_interpolation,\n                **texture_kwargs\n            )\n        return tex",
  "def set_data(self, image):\n        \"\"\"Set the image data.\n\n        Parameters\n        ----------\n        image : array-like\n            The image data.\n        texture_format : str or None\n\n        \"\"\"\n        data = np.asarray(image)\n        if np.iscomplexobj(data):\n            raise TypeError(\n                \"Complex data types not supported. Please use 'ComplexImage' instead\"\n            )\n        if should_cast_to_f32(data.dtype):\n            data = data.astype(np.float32)\n        # can the texture handle this data?\n        self._texture.check_data_format(data)\n        if self._data is None or self._data.shape[:2] != data.shape[:2]:\n            # Only rebuild if the size of the image changed\n            self._need_vertex_update = True\n        self._data = data\n        self._need_texture_upload = True",
  "def view(self):\n        \"\"\"Get the :class:`vispy.visuals.visual.VisualView` for this visual.\"\"\"\n        v = Visual.view(self)\n        self._init_view(v)\n        return v",
  "def _init_view(self, view):\n        # Store some extra variables per-view\n        view._need_method_update = True\n        view._method_used = None",
  "def clim(self):\n        \"\"\"Get color limits used when rendering the image (cmin, cmax).\"\"\"\n        return self._texture.clim",
  "def clim(self, clim):\n        if self._texture.set_clim(clim):\n            self._need_texture_upload = True\n        self._update_colortransform_clim()\n        self.update()",
  "def _update_colortransform_clim(self):\n        if self._need_colortransform_update:\n            # we are going to rebuild anyway so just do it later\n            return\n        try:\n            norm_clims = self._texture.clim_normalized\n        except RuntimeError:\n            return\n        else:\n            # shortcut so we don't have to rebuild the whole color transform\n            self.shared_program.frag['color_transform'][1]['clim'] = norm_clims",
  "def cmap(self):\n        \"\"\"Get the colormap object applied to luminance (single band) data.\"\"\"\n        return self._cmap",
  "def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self._need_colortransform_update = True\n        self.update()",
  "def gamma(self):\n        \"\"\"Get the gamma used when rendering the image.\"\"\"\n        return self._gamma",
  "def gamma(self, value):\n        \"\"\"Set gamma used when rendering the image.\"\"\"\n        if value <= 0:\n            raise ValueError(\"gamma must be > 0\")\n        self._gamma = float(value)\n        # shortcut so we don't have to rebuild the color transform\n        if not self._need_colortransform_update:\n            self.shared_program.frag['color_transform'][2]['gamma'] = self._gamma\n        self.update()",
  "def method(self):\n        \"\"\"Get rendering method name.\"\"\"\n        return self._method",
  "def method(self, m):\n        if self._method != m:\n            self._method = m\n            self._need_vertex_update = True\n            self.update()",
  "def size(self):\n        \"\"\"Get size of the image (width, height).\"\"\"\n        return self._data.shape[:2][::-1]",
  "def interpolation(self):\n        \"\"\"Get interpolation algorithm name.\"\"\"\n        return self._interpolation",
  "def interpolation(self, i):\n        if i not in self._interpolation_names:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_names))\n        if self._interpolation != i:\n            self._interpolation = i\n            self._need_interpolation_update = True\n            self.update()",
  "def interpolation_functions(self):\n        \"\"\"Get names of possible interpolation methods.\"\"\"\n        return self._interpolation_names",
  "def custom_kernel(self):\n        \"\"\"Kernel used by 'custom' interpolation for texture sampling\"\"\"\n        return self._custom_kernel",
  "def custom_kernel(self, value):\n        value = np.asarray(value, dtype=np.float32)\n        if value.ndim != 2:\n            raise ValueError(f'kernel must have 2 dimensions; got {value.ndim}')\n        self._custom_kernel = value\n        self._custom_kerneltex = Texture2D(value, interpolation='nearest')\n        if self._data_lookup_fn is not None and 'kernel' in self._data_lookup_fn:\n            self._data_lookup_fn['kernel'] = self._custom_kerneltex\n            self._data_lookup_fn['kernel_shape'] = value.shape[::-1]\n        self.update()",
  "def _build_interpolation(self):\n        \"\"\"Rebuild the _data_lookup_fn for different interpolations.\"\"\"\n        interpolation = self._interpolation\n        # alias bilinear to linear\n        if interpolation == 'bilinear':\n            warnings.warn(\n                \"'bilinear' interpolation is Deprecated. Use 'linear' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'linear'\n        # alias bicubic to cubic\n        if interpolation == 'bicubic':\n            warnings.warn(\n                \"'bicubic' interpolation is Deprecated. Use 'cubic' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'cubic'\n        self._data_lookup_fn = self._interpolation_fun[interpolation]\n        self.shared_program.frag['get_data'] = self._data_lookup_fn\n\n        # only 'linear' and 'custom' use 'linear' texture interpolation\n        if interpolation in ('linear', 'custom'):\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        # 'nearest' (and also 'linear') doesn't use spatial_filters.frag\n        # so u_kernel and shape setting is skipped\n        if interpolation not in ('nearest', 'linear'):\n            self._data_lookup_fn['shape'] = self._data.shape[:2][::-1]\n            if interpolation == 'custom':\n                self._data_lookup_fn['kernel'] = self._custom_kerneltex\n                self._data_lookup_fn['kernel_shape'] = self._custom_kernel.shape[::-1]\n            else:\n                self.shared_program['u_kernel'] = self._kerneltex\n\n        if self._texture.interpolation != texture_interpolation:\n            self._texture.interpolation = texture_interpolation\n\n        self._data_lookup_fn['texture'] = self._texture\n\n        self._need_interpolation_update = False",
  "def _build_vertex_data(self):\n        \"\"\"Rebuild the vertex buffers for the subdivide method.\"\"\"\n        grid = self._grid\n        w = 1.0 / grid[1]\n        h = 1.0 / grid[0]\n\n        quad = np.array([[0, 0, 0], [w, 0, 0], [w, h, 0],\n                         [0, 0, 0], [w, h, 0], [0, h, 0]],\n                        dtype=np.float32)\n        quads = np.empty((grid[1], grid[0], 6, 3), dtype=np.float32)\n        quads[:] = quad\n\n        mgrid = np.mgrid[0.:grid[1], 0.:grid[0]].transpose(1, 2, 0)\n        mgrid = mgrid[:, :, np.newaxis, :]\n        mgrid[..., 0] *= w\n        mgrid[..., 1] *= h\n\n        quads[..., :2] += mgrid\n        tex_coords = quads.reshape(grid[1]*grid[0]*6, 3)\n        tex_coords = np.ascontiguousarray(tex_coords[:, :2])\n        vertices = tex_coords * self.size\n\n        self._subdiv_position.set_data(vertices.astype('float32'))\n        self._subdiv_texcoord.set_data(tex_coords.astype('float32'))\n        self._need_vertex_update = False",
  "def _update_method(self, view):\n        \"\"\"Decide which method to use for *view* and configure it accordingly.\"\"\"\n        method = self._method\n        if method == 'auto':\n            if view.transforms.get_transform().Linear:\n                method = 'subdivide'\n            else:\n                method = 'impostor'\n        view._method_used = method\n\n        if method == 'subdivide':\n            view.view_program['method'] = 0\n            view.view_program['a_position'] = self._subdiv_position\n            view.view_program['a_texcoord'] = self._subdiv_texcoord\n        elif method == 'impostor':\n            view.view_program['method'] = 1\n            view.view_program['a_position'] = self._impostor_coords\n            view.view_program['a_texcoord'] = self._impostor_coords\n        else:\n            raise ValueError(\"Unknown image draw method '%s'\" % method)\n\n        self.shared_program['image_size'] = self.size\n        view._need_method_update = False\n        self._prepare_transforms(view)",
  "def _build_texture(self):\n        try:\n            pre_clims = self._texture.clim_normalized\n        except RuntimeError:\n            pre_clims = \"auto\"\n        pre_internalformat = self._texture.internalformat\n        self._texture.scale_and_set_data(self._data)\n        post_clims = self._texture.clim_normalized\n        post_internalformat = self._texture.internalformat\n        # color transform needs rebuilding if the internalformat was changed\n        # new color limits need to be assigned if the normalized clims changed\n        # otherwise, the original color transform should be fine\n        new_if = post_internalformat != pre_internalformat\n        new_cl = post_clims != pre_clims\n        if new_if:\n            self._need_colortransform_update = True\n        elif new_cl and not self._need_colortransform_update:\n            # shortcut so we don't have to rebuild the whole color transform\n            self.shared_program.frag['color_transform'][1]['clim'] = self._texture.clim_normalized\n        self._need_texture_upload = False",
  "def _compute_bounds(self, axis, view):\n        if axis > 1:\n            return 0, 0\n        else:\n            return 0, self.size[axis]",
  "def _build_color_transform(self):\n        if self._data.ndim == 2 or self._data.shape[2] == 1:\n            # luminance data\n            fclim = Function(self._func_templates['clim_float'])\n            fgamma = Function(self._func_templates['gamma_float'])\n            # NOTE: red_to_luminance only uses the red component, fancy internalformats\n            #   may need to use the other components or a different function chain\n            fun = FunctionChain(\n                None, [Function(self._func_templates['red_to_luminance']), fclim, fgamma, Function(self.cmap.glsl_map)]\n            )\n        else:\n            # RGB/A image data (no colormap)\n            fclim = Function(self._func_templates['clim'])\n            fgamma = Function(self._func_templates['gamma'])\n            fun = FunctionChain(None, [Function(self._func_templates['null_color_transform']), fclim, fgamma])\n        fclim['clim'] = self._texture.clim_normalized\n        fgamma['gamma'] = self.gamma\n        return fun",
  "def _prepare_transforms(self, view):\n        trs = view.transforms\n        prg = view.view_program\n        method = view._method_used\n        if method == 'subdivide':\n            prg.vert['transform'] = trs.get_transform()\n            prg.frag['transform'] = self._null_tr\n        else:\n            prg.vert['transform'] = self._null_tr\n            prg.frag['transform'] = trs.get_transform().inverse",
  "def _prepare_draw(self, view):\n        if self._data is None:\n            return False\n\n        if self._need_interpolation_update:\n            self._build_interpolation()\n\n        if self._need_texture_upload:\n            self._build_texture()\n\n        if self._need_colortransform_update:\n            prg = view.view_program\n            self.shared_program.frag['color_transform'] = self._build_color_transform()\n            self._need_colortransform_update = False\n            prg['texture2D_LUT'] = self.cmap.texture_lut()\n\n        if self._need_vertex_update:\n            self._build_vertex_data()\n\n        if view._need_method_update:\n            self._update_method(view)",
  "class MeshNormalsVisual(LineVisual):\n    \"\"\"Display mesh normals as lines.\n\n    Parameters\n    ----------\n    meshdata : instance of :class:`~vispy.geometry.meshdata.MeshData`\n        The mesh data.\n    primitive : {'face', 'vertex'}\n        The primitive type on which to compute and display the normals.\n    length : None or float or array-like, optional\n        The length(s) of the normals. If None, the length is computed with\n        `length_method`.\n    length_method : {'median_edge', 'max_extent'}, default='median_edge'\n        The method to compute the length of the normals (when `length=None`).\n        Methods: 'median_edge', the median edge length; 'max_extent', the\n        maximum side length of the bounding box of the mesh.\n    length_scale : float, default=1.0\n        A scale factor applied to the length computed with `length_method`.\n    **kwargs : dict, optional\n        Extra arguments to define the appearance of lines. Refer to\n        :class:`~vispy.visuals.line.line.LineVisual`.\n\n    Examples\n    --------\n    Create a :class:`~vispy.visuals.mesh.MeshVisual` on which to display\n    the normals and get the :class:`~vispy.geometry.meshdata.MeshData`:\n\n    >>> mesh = MeshVisual(vertices=vertices, faces=faces, ...)\n    >>> meshdata = mesh.mesh_data\n\n    Create a visual for the mesh normals:\n\n    >>> normals = MeshNormalsVisual(meshdata)\n\n    Display the face normals:\n\n    >>> MeshNormalsVisual(..., primitive='face')\n    >>> MeshNormalsVisual(...)  # equivalent (default values)\n\n    Display the vertex normals:\n\n    >>> MeshNormalsVisual(..., primitive='vertex')\n\n    Fixed length for all normals:\n\n    >>> MeshNormalsVisual(..., length=0.25)\n\n    Individual length per normal:\n\n    >>> lengths = np.array([0.5, 0.2, 0.7, ..., 0.7], dtype=float)\n    >>> MeshNormalsVisual(..., length=lengths)\n    >>> assert len(lengths) == len(faces)  # for face normals\n    >>> assert len(lengths) == len(vertices)  # for vertex normals\n\n    Normals at about the length of a triangle:\n\n    >>> MeshNormalsVisual(..., length_method='median_edge', length_scale=1.0)\n    >>> MeshNormalsVisual(...)  # equivalent (default values)\n\n    Normals at about 10% the size of the mesh:\n\n    >>> MeshNormalsVisual(..., length_method='max_extent', length_scale=0.1)\n    \"\"\"\n\n    def __init__(self, meshdata=None, primitive='face', length=None,\n                 length_method='median_edge', length_scale=1.0, **kwargs):\n        self._previous_meshdata = None\n        super().__init__(connect='segments')\n        self.set_data(meshdata, primitive, length, length_method, length_scale, **kwargs)\n\n    def set_data(self, meshdata=None, primitive='face', length=None,\n                 length_method='median_edge', length_scale=1.0, **kwargs):\n        \"\"\"Set the data used to draw this visual\n\n        Parameters\n        ----------\n        meshdata : instance of :class:`~vispy.geometry.meshdata.MeshData`\n            The mesh data.\n        primitive : {'face', 'vertex'}\n            The primitive type on which to compute and display the normals.\n        length : None or float or array-like, optional\n            The length(s) of the normals. If None, the length is computed with\n            `length_method`.\n        length_method : {'median_edge', 'max_extent'}, default='median_edge'\n            The method to compute the length of the normals (when `length=None`).\n            Methods: 'median_edge', the median edge length; 'max_extent', the\n            maximum side length of the bounding box of the mesh.\n        length_scale : float, default=1.0\n            A scale factor applied to the length computed with `length_method`.\n        **kwargs : dict, optional\n            Extra arguments to define the appearance of lines. Refer to\n            :class:`~vispy.visuals.line.line.LineVisual`.\n        \"\"\"\n        if meshdata is None:\n            meshdata = self._previous_meshdata\n\n        if meshdata is None or meshdata.is_empty():\n            normals = None\n        elif primitive == 'face':\n            normals = meshdata.get_face_normals()\n        elif primitive == 'vertex':\n            normals = meshdata.get_vertex_normals()\n        else:\n            raise ValueError('primitive must be \"face\" or \"vertex\", got %s'\n                             % primitive)\n\n        # remove connect from kwargs to make sure we don't change it\n        kwargs.pop('connect', None)\n\n        if normals is None:\n            super().set_data(pos=np.empty((0, 3), dtype=np.float32), connect='segments', **kwargs)\n            return\n\n        self._previous_meshdata = meshdata\n\n        norms = np.sqrt((normals ** 2).sum(axis=-1, keepdims=True))\n        unit_normals = normals / norms\n\n        if length is None and length_method == 'median_edge':\n            face_corners = meshdata.get_vertices(indexed='faces')\n            edges = np.stack((\n                face_corners[:, 1, :] - face_corners[:, 0, :],\n                face_corners[:, 2, :] - face_corners[:, 1, :],\n                face_corners[:, 0, :] - face_corners[:, 2, :],\n            ))\n            edge_lengths = np.sqrt((edges ** 2).sum(axis=-1))\n            length = np.median(edge_lengths)\n        elif length is None and length_method == 'max_extent':\n            vertices = meshdata.get_vertices()\n            max_extent = np.max(vertices.max(axis=0) - vertices.min(axis=0))\n            length = max_extent\n        length *= length_scale\n\n        if primitive == 'face':\n            origins = meshdata.get_vertices(indexed='faces')\n            origins = origins.mean(axis=1)\n        elif primitive == 'vertex':\n            origins = meshdata.get_vertices()\n\n        # Ensure the broadcasting if the input is an `(n,)` array.\n        length = np.atleast_1d(length)\n        length = length[:, None]\n\n        ends = origins + length * unit_normals\n        segments = np.hstack((origins, ends)).reshape(-1, 3)\n\n        super().set_data(pos=segments, connect='segments', **kwargs)",
  "def __init__(self, meshdata=None, primitive='face', length=None,\n                 length_method='median_edge', length_scale=1.0, **kwargs):\n        self._previous_meshdata = None\n        super().__init__(connect='segments')\n        self.set_data(meshdata, primitive, length, length_method, length_scale, **kwargs)",
  "def set_data(self, meshdata=None, primitive='face', length=None,\n                 length_method='median_edge', length_scale=1.0, **kwargs):\n        \"\"\"Set the data used to draw this visual\n\n        Parameters\n        ----------\n        meshdata : instance of :class:`~vispy.geometry.meshdata.MeshData`\n            The mesh data.\n        primitive : {'face', 'vertex'}\n            The primitive type on which to compute and display the normals.\n        length : None or float or array-like, optional\n            The length(s) of the normals. If None, the length is computed with\n            `length_method`.\n        length_method : {'median_edge', 'max_extent'}, default='median_edge'\n            The method to compute the length of the normals (when `length=None`).\n            Methods: 'median_edge', the median edge length; 'max_extent', the\n            maximum side length of the bounding box of the mesh.\n        length_scale : float, default=1.0\n            A scale factor applied to the length computed with `length_method`.\n        **kwargs : dict, optional\n            Extra arguments to define the appearance of lines. Refer to\n            :class:`~vispy.visuals.line.line.LineVisual`.\n        \"\"\"\n        if meshdata is None:\n            meshdata = self._previous_meshdata\n\n        if meshdata is None or meshdata.is_empty():\n            normals = None\n        elif primitive == 'face':\n            normals = meshdata.get_face_normals()\n        elif primitive == 'vertex':\n            normals = meshdata.get_vertex_normals()\n        else:\n            raise ValueError('primitive must be \"face\" or \"vertex\", got %s'\n                             % primitive)\n\n        # remove connect from kwargs to make sure we don't change it\n        kwargs.pop('connect', None)\n\n        if normals is None:\n            super().set_data(pos=np.empty((0, 3), dtype=np.float32), connect='segments', **kwargs)\n            return\n\n        self._previous_meshdata = meshdata\n\n        norms = np.sqrt((normals ** 2).sum(axis=-1, keepdims=True))\n        unit_normals = normals / norms\n\n        if length is None and length_method == 'median_edge':\n            face_corners = meshdata.get_vertices(indexed='faces')\n            edges = np.stack((\n                face_corners[:, 1, :] - face_corners[:, 0, :],\n                face_corners[:, 2, :] - face_corners[:, 1, :],\n                face_corners[:, 0, :] - face_corners[:, 2, :],\n            ))\n            edge_lengths = np.sqrt((edges ** 2).sum(axis=-1))\n            length = np.median(edge_lengths)\n        elif length is None and length_method == 'max_extent':\n            vertices = meshdata.get_vertices()\n            max_extent = np.max(vertices.max(axis=0) - vertices.min(axis=0))\n            length = max_extent\n        length *= length_scale\n\n        if primitive == 'face':\n            origins = meshdata.get_vertices(indexed='faces')\n            origins = origins.mean(axis=1)\n        elif primitive == 'vertex':\n            origins = meshdata.get_vertices()\n\n        # Ensure the broadcasting if the input is an `(n,)` array.\n        length = np.atleast_1d(length)\n        length = length[:, None]\n\n        ends = origins + length * unit_normals\n        segments = np.hstack((origins, ends)).reshape(-1, 3)\n\n        super().set_data(pos=segments, connect='segments', **kwargs)",
  "class HistogramVisual(MeshVisual):\n    \"\"\"Visual that calculates and displays a histogram of data\n\n    Parameters\n    ----------\n    data : array-like\n        Data to histogram. Currently only 1D data is supported.\n    bins : int | array-like\n        Number of bins, or bin edges.\n    color : instance of Color\n        Color of the histogram.\n    orientation : {'h', 'v'}\n        Orientation of the histogram.\n    \"\"\"\n\n    def __init__(self, data, bins=10, color='w', orientation='h'):\n        #   4-5\n        #   | |\n        # 1-2/7-8\n        # |/| | |\n        # 0-3-6-9\n        data = np.asarray(data)\n        if data.ndim != 1:\n            raise ValueError('Only 1D data currently supported')\n        if not isinstance(orientation, str) or \\\n                orientation not in ('h', 'v'):\n            raise ValueError('orientation must be \"h\" or \"v\", not %s'\n                             % (orientation,))\n        X, Y = (0, 1) if orientation == 'h' else (1, 0)\n\n        # do the histogramming\n        data, bin_edges = np.histogram(data, bins)\n        # construct our vertices\n        rr = np.zeros((3 * len(bin_edges) - 2, 3), np.float32)\n        rr[:, X] = np.repeat(bin_edges, 3)[1:-1]\n        rr[1::3, Y] = data\n        rr[2::3, Y] = data\n        bin_edges.astype(np.float32)\n        # and now our tris\n        tris = np.zeros((2 * len(bin_edges) - 2, 3), np.uint32)\n        offsets = 3 * np.arange(len(bin_edges) - 1,\n                                dtype=np.uint32)[:, np.newaxis]\n        tri_1 = np.array([0, 2, 1])\n        tri_2 = np.array([2, 0, 3])\n        tris[::2] = tri_1 + offsets\n        tris[1::2] = tri_2 + offsets\n        MeshVisual.__init__(self, rr, tris, color=color)",
  "def __init__(self, data, bins=10, color='w', orientation='h'):\n        #   4-5\n        #   | |\n        # 1-2/7-8\n        # |/| | |\n        # 0-3-6-9\n        data = np.asarray(data)\n        if data.ndim != 1:\n            raise ValueError('Only 1D data currently supported')\n        if not isinstance(orientation, str) or \\\n                orientation not in ('h', 'v'):\n            raise ValueError('orientation must be \"h\" or \"v\", not %s'\n                             % (orientation,))\n        X, Y = (0, 1) if orientation == 'h' else (1, 0)\n\n        # do the histogramming\n        data, bin_edges = np.histogram(data, bins)\n        # construct our vertices\n        rr = np.zeros((3 * len(bin_edges) - 2, 3), np.float32)\n        rr[:, X] = np.repeat(bin_edges, 3)[1:-1]\n        rr[1::3, Y] = data\n        rr[2::3, Y] = data\n        bin_edges.astype(np.float32)\n        # and now our tris\n        tris = np.zeros((2 * len(bin_edges) - 2, 3), np.uint32)\n        offsets = 3 * np.arange(len(bin_edges) - 1,\n                                dtype=np.uint32)[:, np.newaxis]\n        tri_1 = np.array([0, 2, 1])\n        tri_2 = np.array([2, 0, 3])\n        tris[::2] = tri_1 + offsets\n        tris[1::2] = tri_2 + offsets\n        MeshVisual.__init__(self, rr, tris, color=color)",
  "class WindbarbVisual(Visual):\n    \"\"\"Visual displaying windbarbs.\"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, **kwargs):\n        self._vbo = VertexBuffer()\n        self._v_size_var = Variable('varying float v_size')\n        self._marker_fun = None\n        self._data = None\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.shared_program.vert['v_size'] = self._v_size_var\n        self.shared_program.frag['v_size'] = self._v_size_var\n        self.set_gl_state(depth_test=True, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n        if len(kwargs) > 0:\n            self.set_data(**kwargs)\n        self.freeze()\n\n    def set_data(self, pos=None, wind=None, trig=True, size=50.,\n                 antialias=1., edge_width=1., edge_color='black',\n                 face_color='white'):\n        \"\"\"Set the data used to display this visual.\n\n        Parameters\n        ----------\n        pos : array\n            The array of locations to display each windbarb.\n        wind : array\n            The array of wind vector components to display each windbarb.\n            in m/s. For knots divide by two.\n        trig : bool\n            True - wind contains (mag, ang)\n            False - wind contains (u, v)\n            defaults to True\n        size : float or array\n            The windbarb size in px.\n        antialias : float\n            The antialiased area (in pixels).\n        edge_width : float | None\n            The width of the windbarb outline in pixels.\n        edge_color : Color | ColorArray\n            The color used to draw each symbol outline.\n        face_color : Color | ColorArray\n            The color used to draw each symbol interior.\n        \"\"\"\n        assert (isinstance(pos, np.ndarray) and\n                pos.ndim == 2 and pos.shape[1] in (2, 3))\n        assert (isinstance(wind, np.ndarray) and\n                pos.ndim == 2 and pos.shape[1] == 2)\n        if edge_width < 0:\n            raise ValueError('edge_width cannot be negative')\n\n        # since the windbarb starts in the fragment center,\n        # we need to multiply by 2 for correct length\n        size *= 2\n\n        edge_color = ColorArray(edge_color).rgba\n        if len(edge_color) == 1:\n            edge_color = edge_color[0]\n\n        face_color = ColorArray(face_color).rgba\n        if len(face_color) == 1:\n            face_color = face_color[0]\n\n        n = len(pos)\n        data = np.zeros(n, dtype=[('a_position', np.float32, 3),\n                                  ('a_wind', np.float32, 2),\n                                  ('a_trig', np.float32, 0),\n                                  ('a_fg_color', np.float32, 4),\n                                  ('a_bg_color', np.float32, 4),\n                                  ('a_size', np.float32),\n                                  ('a_edgewidth', np.float32)])\n        data['a_fg_color'] = edge_color\n        data['a_bg_color'] = face_color\n        data['a_edgewidth'] = edge_width\n        data['a_position'][:, :pos.shape[1]] = pos\n        data['a_wind'][:, :wind.shape[1]] = wind\n        if trig:\n            data['a_trig'] = 1.\n        else:\n            data['a_trig'] = 0.\n        data['a_size'] = size\n        self.shared_program['u_antialias'] = antialias\n        self._data = data\n        self._vbo.set_data(data)\n        self.shared_program.bind(self._vbo)\n        self.update()\n\n    def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform\n\n    def _prepare_draw(self, view):\n        view.view_program['u_px_scale'] = view.transforms.pixel_scale\n        view.view_program['u_scale'] = 1\n\n    def _compute_bounds(self, axis, view):\n        pos = self._data['a_position']\n        if pos is None:\n            return None\n        if pos.shape[1] > axis:\n            return (pos[:, axis].min(), pos[:, axis].max())\n        else:\n            return (0, 0)",
  "def __init__(self, **kwargs):\n        self._vbo = VertexBuffer()\n        self._v_size_var = Variable('varying float v_size')\n        self._marker_fun = None\n        self._data = None\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.shared_program.vert['v_size'] = self._v_size_var\n        self.shared_program.frag['v_size'] = self._v_size_var\n        self.set_gl_state(depth_test=True, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n        if len(kwargs) > 0:\n            self.set_data(**kwargs)\n        self.freeze()",
  "def set_data(self, pos=None, wind=None, trig=True, size=50.,\n                 antialias=1., edge_width=1., edge_color='black',\n                 face_color='white'):\n        \"\"\"Set the data used to display this visual.\n\n        Parameters\n        ----------\n        pos : array\n            The array of locations to display each windbarb.\n        wind : array\n            The array of wind vector components to display each windbarb.\n            in m/s. For knots divide by two.\n        trig : bool\n            True - wind contains (mag, ang)\n            False - wind contains (u, v)\n            defaults to True\n        size : float or array\n            The windbarb size in px.\n        antialias : float\n            The antialiased area (in pixels).\n        edge_width : float | None\n            The width of the windbarb outline in pixels.\n        edge_color : Color | ColorArray\n            The color used to draw each symbol outline.\n        face_color : Color | ColorArray\n            The color used to draw each symbol interior.\n        \"\"\"\n        assert (isinstance(pos, np.ndarray) and\n                pos.ndim == 2 and pos.shape[1] in (2, 3))\n        assert (isinstance(wind, np.ndarray) and\n                pos.ndim == 2 and pos.shape[1] == 2)\n        if edge_width < 0:\n            raise ValueError('edge_width cannot be negative')\n\n        # since the windbarb starts in the fragment center,\n        # we need to multiply by 2 for correct length\n        size *= 2\n\n        edge_color = ColorArray(edge_color).rgba\n        if len(edge_color) == 1:\n            edge_color = edge_color[0]\n\n        face_color = ColorArray(face_color).rgba\n        if len(face_color) == 1:\n            face_color = face_color[0]\n\n        n = len(pos)\n        data = np.zeros(n, dtype=[('a_position', np.float32, 3),\n                                  ('a_wind', np.float32, 2),\n                                  ('a_trig', np.float32, 0),\n                                  ('a_fg_color', np.float32, 4),\n                                  ('a_bg_color', np.float32, 4),\n                                  ('a_size', np.float32),\n                                  ('a_edgewidth', np.float32)])\n        data['a_fg_color'] = edge_color\n        data['a_bg_color'] = face_color\n        data['a_edgewidth'] = edge_width\n        data['a_position'][:, :pos.shape[1]] = pos\n        data['a_wind'][:, :wind.shape[1]] = wind\n        if trig:\n            data['a_trig'] = 1.\n        else:\n            data['a_trig'] = 0.\n        data['a_size'] = size\n        self.shared_program['u_antialias'] = antialias\n        self._data = data\n        self._vbo.set_data(data)\n        self.shared_program.bind(self._vbo)\n        self.update()",
  "def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform",
  "def _prepare_draw(self, view):\n        view.view_program['u_px_scale'] = view.transforms.pixel_scale\n        view.view_program['u_scale'] = 1",
  "def _compute_bounds(self, axis, view):\n        pos = self._data['a_position']\n        if pos is None:\n            return None\n        if pos.shape[1] > axis:\n            return (pos[:, axis].min(), pos[:, axis].max())\n        else:\n            return (0, 0)",
  "class XYZAxisVisual(LineVisual):\n    \"\"\"\n    Simple 3D axis for indicating coordinate system orientation. Axes are\n    x=red, y=green, z=blue.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        pos = np.array([[0, 0, 0],\n                        [1, 0, 0],\n                        [0, 0, 0],\n                        [0, 1, 0],\n                        [0, 0, 0],\n                        [0, 0, 1]])\n        color = np.array([[1, 0, 0, 1],\n                          [1, 0, 0, 1],\n                          [0, 1, 0, 1],\n                          [0, 1, 0, 1],\n                          [0, 0, 1, 1],\n                          [0, 0, 1, 1]])\n        connect = 'segments'\n        method = 'gl'\n\n        kwargs.setdefault('pos', pos)\n        kwargs.setdefault('color', color)\n        kwargs.setdefault('connect', connect)\n        kwargs.setdefault('method', method)\n\n        LineVisual.__init__(self, **kwargs)",
  "def __init__(self, **kwargs):\n        pos = np.array([[0, 0, 0],\n                        [1, 0, 0],\n                        [0, 0, 0],\n                        [0, 1, 0],\n                        [0, 0, 0],\n                        [0, 0, 1]])\n        color = np.array([[1, 0, 0, 1],\n                          [1, 0, 0, 1],\n                          [0, 1, 0, 1],\n                          [0, 1, 0, 1],\n                          [0, 0, 1, 1],\n                          [0, 0, 1, 1]])\n        connect = 'segments'\n        method = 'gl'\n\n        kwargs.setdefault('pos', pos)\n        kwargs.setdefault('color', color)\n        kwargs.setdefault('connect', connect)\n        kwargs.setdefault('method', method)\n\n        LineVisual.__init__(self, **kwargs)",
  "class MeshVisual(Visual):\n    \"\"\"Mesh visual\n\n    Parameters\n    ----------\n    vertices : array-like | None\n        The vertices.\n    faces : array-like | None\n        The faces.\n    vertex_colors : array-like | None\n        Colors to use for each vertex.\n    face_colors : array-like | None\n        Colors to use for each face.\n    color : instance of Color\n        The color to use.\n    vertex_values : array-like | None\n        The values to use for each vertex (for colormapping).\n    meshdata : instance of MeshData | None\n        The meshdata.\n    shading : str | None\n        Shading to use. This uses the\n        :class:`~vispy.visuals.filters.mesh.ShadingFilter`\n        filter introduced in VisPy 0.7. This class provides additional\n        features that are available when the filter is attached manually.\n        See 'examples/basics/scene/mesh_shading.py' for an example.\n    mode : str\n        The drawing mode.\n    **kwargs : dict\n        Keyword arguments to pass to `Visual`.\n\n    Notes\n    -----\n    Additional functionality is available through filters. Mesh-specific\n    filters can be found in the :mod:`vispy.visuals.filters.mesh` module.\n\n    This class emits a `data_updated` event when the mesh data is updated. This\n    is used for example by filters for synchronization.\n\n    Examples\n    --------\n    Create a primitive shape from a helper function:\n\n    >>> from vispy.geometry import create_sphere\n    >>> meshdata = create_sphere()\n    >>> mesh = MeshVisual(meshdata=meshdata)\n\n    Create a custom shape:\n\n    >>> # A rectangle made out of two triangles.\n    >>> vertices = [(0, 0, 0), (1, 0, 1), (1, 1, 1), (0, 1, 0)]\n    >>> faces = [(0, 1, 2), (0, 2, 3)]\n    >>> mesh = MeshVisual(vertices=vertices, faces=faces)\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, vertices=None, faces=None, vertex_colors=None,\n                 face_colors=None, color=(0.5, 0.5, 1, 1), vertex_values=None,\n                 meshdata=None, shading=None, mode='triangles', **kwargs):\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'],\n                        **kwargs)\n        self.set_gl_state('translucent', depth_test=True, cull_face=False)\n\n        self.events.add(data_updated=Event)\n\n        self._meshdata = None\n\n        # Define buffers\n        self._vertices = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        self._cmap = CubeHelixColormap()\n        self._clim = 'auto'\n\n        # Uniform color\n        self._color = Color(color)\n\n        # add filters for various modifiers\n        self.shading_filter = None\n        self.shading = shading\n\n        # Init\n        self._bounds = None\n        # Note we do not call subclass set_data -- often the signatures\n        # do no match.\n        MeshVisual.set_data(\n            self, vertices=vertices, faces=faces, vertex_colors=vertex_colors,\n            face_colors=face_colors, vertex_values=vertex_values,\n            meshdata=meshdata, color=color)\n\n        # primitive mode\n        self._draw_mode = mode\n\n        self.freeze()\n\n    @property\n    def shading(self):\n        \"\"\"The shading method.\"\"\"\n        return self._shading\n\n    @shading.setter\n    def shading(self, shading):\n        assert shading in (None, 'flat', 'smooth')\n        self._shading = shading\n        if shading is None and self.shading_filter is None:\n            # Delay creation of filter until necessary.\n            return\n        if self.shading_filter is None:\n            from vispy.visuals.filters import ShadingFilter\n            self.shading_filter = ShadingFilter(shading=shading)\n            self.attach(self.shading_filter)\n        else:\n            self.shading_filter.shading = shading\n\n    def set_data(self, vertices=None, faces=None, vertex_colors=None,\n                 face_colors=None, color=None, vertex_values=None,\n                 meshdata=None):\n        \"\"\"Set the mesh data\n\n        Parameters\n        ----------\n        vertices : array-like | None\n            The vertices.\n        faces : array-like | None\n            The faces.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        vertex_values : array-like | None\n            Values for each vertex.\n        meshdata : instance of MeshData | None\n            The meshdata.\n        \"\"\"\n        if meshdata is not None:\n            self._meshdata = meshdata\n        else:\n            self._meshdata = MeshData(vertices=vertices, faces=faces,\n                                      vertex_colors=vertex_colors,\n                                      face_colors=face_colors,\n                                      vertex_values=vertex_values)\n        self._bounds = self._meshdata.get_bounds()\n        if color is not None:\n            self._color = Color(color)\n        self.mesh_data_changed()\n\n    @property\n    def clim(self):\n        return (self._clim if isinstance(self._clim, str) else\n                tuple(self._clim))\n\n    @clim.setter\n    def clim(self, clim):\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n        else:\n            clim = np.array(clim, float)\n            if clim.shape != (2,):\n                raise ValueError('clim must have two elements')\n        self._clim = clim\n        self.mesh_data_changed()\n\n    @property\n    def _clim_values(self):\n        if isinstance(self._clim, str):  # == 'auto'\n            if self._meshdata.has_vertex_value():\n                clim = self._meshdata.get_vertex_values()\n                clim = (np.min(clim), np.max(clim))\n            else:\n                clim = (0, 1)\n        else:\n            clim = self._clim\n        return clim\n\n    @property\n    def cmap(self):\n        return self._cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self.mesh_data_changed()\n\n    @property\n    def mode(self):\n        \"\"\"The triangle mode used to draw this mesh.\n\n        Options are:\n\n            * 'triangles': Draw one triangle for every three vertices\n              (eg, [1,2,3], [4,5,6], [7,8,9)\n            * 'triangle_strip': Draw one strip for every vertex excluding the\n              first two (eg, [1,2,3], [2,3,4], [3,4,5])\n            * 'triangle_fan': Draw each triangle from the first vertex and the\n              last two vertices (eg, [1,2,3], [1,3,4], [1,4,5])\n        \"\"\"\n        return self._draw_mode\n\n    @mode.setter\n    def mode(self, m):\n        modes = ['triangles', 'triangle_strip', 'triangle_fan']\n        if m not in modes:\n            raise ValueError(\"Mesh mode must be one of %s\" % ', '.join(modes))\n        self._draw_mode = m\n\n    @property\n    def mesh_data(self):\n        \"\"\"The mesh data\"\"\"\n        return self._meshdata\n\n    @property\n    def color(self):\n        \"\"\"The uniform color for this mesh\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, c):\n        \"\"\"Set the uniform color of the mesh\n\n        This value is only used if per-vertex or per-face colors are not\n        specified.\n\n        Parameters\n        ----------\n        c : instance of Color\n            The color to use.\n        \"\"\"\n        if c is not None:\n            self._color = Color(c)\n        self.mesh_data_changed()\n\n    def mesh_data_changed(self):\n        self._data_changed = True\n        self.update()\n\n    def _build_color_transform(self, colors):\n        # Eventually this could be de-duplicated with visuals/image.py, which does\n        # something similar (but takes a ``color`` instead of ``float``)\n        null_color_transform = 'vec4 pass(vec4 color) { return color; }'\n        clim_func = 'float cmap(float val) { return (val - $cmin) / ($cmax - $cmin); }'\n        if colors.ndim == 2 and colors.shape[1] == 1:\n            fun = Function(clim_func)\n            fun['cmin'] = self.clim[0]\n            fun['cmax'] = self.clim[1]\n            fun = FunctionChain(None, [fun, Function(self.cmap.glsl_map)])\n        else:\n            fun = Function(null_color_transform)\n        return fun\n\n    @staticmethod\n    @lru_cache(maxsize=2)\n    def _ensure_vec4_func(dims):\n        if dims == 2:\n            func = Function(\"\"\"\n                vec4 vec2to4(vec2 xyz) {\n                    return vec4(xyz, 0.0, 1.0);\n                }\n            \"\"\")\n        elif dims == 3:\n            func = Function(\"\"\"\n                vec4 vec3to4(vec3 xyz) {\n                    return vec4(xyz, 1.0);\n                }\n            \"\"\")\n        else:\n            raise TypeError(\"Vertex data must have shape (...,2) or (...,3).\")\n        return func\n\n    def _update_data(self):\n        md = self.mesh_data\n\n        v = md.get_vertices(indexed='faces')\n        if v is None:\n            return False\n        if v.shape[-1] == 2:\n            v = np.concatenate((v, np.zeros((v.shape[:-1] + (1,)))), -1)\n        self._vertices.set_data(v, convert=True)\n        if md.has_vertex_color():\n            colors = md.get_vertex_colors(indexed='faces')\n            colors = colors.astype(np.float32)\n        elif md.has_face_color():\n            colors = md.get_face_colors(indexed='faces')\n            colors = colors.astype(np.float32)\n        elif md.has_vertex_value():\n            colors = md.get_vertex_values(indexed='faces')\n            colors = colors.ravel()[:, np.newaxis]\n            colors = colors.astype(np.float32)\n        else:\n            colors = self._color.rgba\n\n        self.shared_program.vert['position'] = self._vertices\n\n        self.shared_program['texture2D_LUT'] = self._cmap.texture_lut()\n\n        # Position input handling\n        ensure_vec4 = self._ensure_vec4_func(v.shape[-1])\n        self.shared_program.vert['to_vec4'] = ensure_vec4\n\n        # Set the base color.\n        #\n        # The base color is mixed further by the material filters for texture\n        # or shading effects.\n        self.shared_program.vert['color_transform'] = self._build_color_transform(colors)\n        if colors.ndim == 1:\n            self.shared_program.vert['base_color'] = colors\n        else:\n            self.shared_program.vert['base_color'] = VertexBuffer(colors)\n\n        self._data_changed = False\n\n        self.events.data_updated()\n\n    def _prepare_draw(self, view):\n        if self._data_changed:\n            if self._update_data() is False:\n                return False\n            self._data_changed = False\n\n    @staticmethod\n    def _prepare_transforms(view):\n        tr = view.transforms.get_transform()\n        view.view_program.vert['transform'] = tr\n\n    def _compute_bounds(self, axis, view):\n        if self._bounds is None:\n            return None\n        if axis >= len(self._bounds):\n            return (0, 0)\n        else:\n            return self._bounds[axis]",
  "def __init__(self, vertices=None, faces=None, vertex_colors=None,\n                 face_colors=None, color=(0.5, 0.5, 1, 1), vertex_values=None,\n                 meshdata=None, shading=None, mode='triangles', **kwargs):\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'],\n                        **kwargs)\n        self.set_gl_state('translucent', depth_test=True, cull_face=False)\n\n        self.events.add(data_updated=Event)\n\n        self._meshdata = None\n\n        # Define buffers\n        self._vertices = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        self._cmap = CubeHelixColormap()\n        self._clim = 'auto'\n\n        # Uniform color\n        self._color = Color(color)\n\n        # add filters for various modifiers\n        self.shading_filter = None\n        self.shading = shading\n\n        # Init\n        self._bounds = None\n        # Note we do not call subclass set_data -- often the signatures\n        # do no match.\n        MeshVisual.set_data(\n            self, vertices=vertices, faces=faces, vertex_colors=vertex_colors,\n            face_colors=face_colors, vertex_values=vertex_values,\n            meshdata=meshdata, color=color)\n\n        # primitive mode\n        self._draw_mode = mode\n\n        self.freeze()",
  "def shading(self):\n        \"\"\"The shading method.\"\"\"\n        return self._shading",
  "def shading(self, shading):\n        assert shading in (None, 'flat', 'smooth')\n        self._shading = shading\n        if shading is None and self.shading_filter is None:\n            # Delay creation of filter until necessary.\n            return\n        if self.shading_filter is None:\n            from vispy.visuals.filters import ShadingFilter\n            self.shading_filter = ShadingFilter(shading=shading)\n            self.attach(self.shading_filter)\n        else:\n            self.shading_filter.shading = shading",
  "def set_data(self, vertices=None, faces=None, vertex_colors=None,\n                 face_colors=None, color=None, vertex_values=None,\n                 meshdata=None):\n        \"\"\"Set the mesh data\n\n        Parameters\n        ----------\n        vertices : array-like | None\n            The vertices.\n        faces : array-like | None\n            The faces.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        vertex_values : array-like | None\n            Values for each vertex.\n        meshdata : instance of MeshData | None\n            The meshdata.\n        \"\"\"\n        if meshdata is not None:\n            self._meshdata = meshdata\n        else:\n            self._meshdata = MeshData(vertices=vertices, faces=faces,\n                                      vertex_colors=vertex_colors,\n                                      face_colors=face_colors,\n                                      vertex_values=vertex_values)\n        self._bounds = self._meshdata.get_bounds()\n        if color is not None:\n            self._color = Color(color)\n        self.mesh_data_changed()",
  "def clim(self):\n        return (self._clim if isinstance(self._clim, str) else\n                tuple(self._clim))",
  "def clim(self, clim):\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n        else:\n            clim = np.array(clim, float)\n            if clim.shape != (2,):\n                raise ValueError('clim must have two elements')\n        self._clim = clim\n        self.mesh_data_changed()",
  "def _clim_values(self):\n        if isinstance(self._clim, str):  # == 'auto'\n            if self._meshdata.has_vertex_value():\n                clim = self._meshdata.get_vertex_values()\n                clim = (np.min(clim), np.max(clim))\n            else:\n                clim = (0, 1)\n        else:\n            clim = self._clim\n        return clim",
  "def cmap(self):\n        return self._cmap",
  "def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self.mesh_data_changed()",
  "def mode(self):\n        \"\"\"The triangle mode used to draw this mesh.\n\n        Options are:\n\n            * 'triangles': Draw one triangle for every three vertices\n              (eg, [1,2,3], [4,5,6], [7,8,9)\n            * 'triangle_strip': Draw one strip for every vertex excluding the\n              first two (eg, [1,2,3], [2,3,4], [3,4,5])\n            * 'triangle_fan': Draw each triangle from the first vertex and the\n              last two vertices (eg, [1,2,3], [1,3,4], [1,4,5])\n        \"\"\"\n        return self._draw_mode",
  "def mode(self, m):\n        modes = ['triangles', 'triangle_strip', 'triangle_fan']\n        if m not in modes:\n            raise ValueError(\"Mesh mode must be one of %s\" % ', '.join(modes))\n        self._draw_mode = m",
  "def mesh_data(self):\n        \"\"\"The mesh data\"\"\"\n        return self._meshdata",
  "def color(self):\n        \"\"\"The uniform color for this mesh\"\"\"\n        return self._color",
  "def color(self, c):\n        \"\"\"Set the uniform color of the mesh\n\n        This value is only used if per-vertex or per-face colors are not\n        specified.\n\n        Parameters\n        ----------\n        c : instance of Color\n            The color to use.\n        \"\"\"\n        if c is not None:\n            self._color = Color(c)\n        self.mesh_data_changed()",
  "def mesh_data_changed(self):\n        self._data_changed = True\n        self.update()",
  "def _build_color_transform(self, colors):\n        # Eventually this could be de-duplicated with visuals/image.py, which does\n        # something similar (but takes a ``color`` instead of ``float``)\n        null_color_transform = 'vec4 pass(vec4 color) { return color; }'\n        clim_func = 'float cmap(float val) { return (val - $cmin) / ($cmax - $cmin); }'\n        if colors.ndim == 2 and colors.shape[1] == 1:\n            fun = Function(clim_func)\n            fun['cmin'] = self.clim[0]\n            fun['cmax'] = self.clim[1]\n            fun = FunctionChain(None, [fun, Function(self.cmap.glsl_map)])\n        else:\n            fun = Function(null_color_transform)\n        return fun",
  "def _ensure_vec4_func(dims):\n        if dims == 2:\n            func = Function(\"\"\"\n                vec4 vec2to4(vec2 xyz) {\n                    return vec4(xyz, 0.0, 1.0);\n                }\n            \"\"\")\n        elif dims == 3:\n            func = Function(\"\"\"\n                vec4 vec3to4(vec3 xyz) {\n                    return vec4(xyz, 1.0);\n                }\n            \"\"\")\n        else:\n            raise TypeError(\"Vertex data must have shape (...,2) or (...,3).\")\n        return func",
  "def _update_data(self):\n        md = self.mesh_data\n\n        v = md.get_vertices(indexed='faces')\n        if v is None:\n            return False\n        if v.shape[-1] == 2:\n            v = np.concatenate((v, np.zeros((v.shape[:-1] + (1,)))), -1)\n        self._vertices.set_data(v, convert=True)\n        if md.has_vertex_color():\n            colors = md.get_vertex_colors(indexed='faces')\n            colors = colors.astype(np.float32)\n        elif md.has_face_color():\n            colors = md.get_face_colors(indexed='faces')\n            colors = colors.astype(np.float32)\n        elif md.has_vertex_value():\n            colors = md.get_vertex_values(indexed='faces')\n            colors = colors.ravel()[:, np.newaxis]\n            colors = colors.astype(np.float32)\n        else:\n            colors = self._color.rgba\n\n        self.shared_program.vert['position'] = self._vertices\n\n        self.shared_program['texture2D_LUT'] = self._cmap.texture_lut()\n\n        # Position input handling\n        ensure_vec4 = self._ensure_vec4_func(v.shape[-1])\n        self.shared_program.vert['to_vec4'] = ensure_vec4\n\n        # Set the base color.\n        #\n        # The base color is mixed further by the material filters for texture\n        # or shading effects.\n        self.shared_program.vert['color_transform'] = self._build_color_transform(colors)\n        if colors.ndim == 1:\n            self.shared_program.vert['base_color'] = colors\n        else:\n            self.shared_program.vert['base_color'] = VertexBuffer(colors)\n\n        self._data_changed = False\n\n        self.events.data_updated()",
  "def _prepare_draw(self, view):\n        if self._data_changed:\n            if self._update_data() is False:\n                return False\n            self._data_changed = False",
  "def _prepare_transforms(view):\n        tr = view.transforms.get_transform()\n        view.view_program.vert['transform'] = tr",
  "def _compute_bounds(self, axis, view):\n        if self._bounds is None:\n            return None\n        if axis >= len(self._bounds):\n            return (0, 0)\n        else:\n            return self._bounds[axis]",
  "class VolumeVisual(Visual):\n    \"\"\"Displays a 3D Volume\n\n    Parameters\n    ----------\n    vol : ndarray\n        The volume to display. Must be ndim==3. Array is assumed to be stored\n        as ``(z, y, x)``.\n    clim : str | tuple\n        Limits to use for the colormap. I.e. the values that map to black and white\n        in a gray colormap. Can be 'auto' to auto-set bounds to\n        the min and max of the data. If not given or None, 'auto' is used.\n    method : {'mip', 'attenuated_mip', 'minip', 'translucent', 'additive',\n        'iso', 'average'}\n        The render method to use. See corresponding docs for details.\n        Default 'mip'.\n    threshold : float\n        The threshold to use for the isosurface render method. By default\n        the mean of the given volume is used.\n    attenuation: float\n        The attenuation rate to apply for the attenuated mip render method.\n        Default: 1.0.\n    relative_step_size : float\n        The relative step size to step through the volume. Default 0.8.\n        Increase to e.g. 1.5 to increase performance, at the cost of\n        quality.\n    cmap : str\n        Colormap to use.\n    gamma : float\n        Gamma to use during colormap lookup.  Final color will be cmap(val**gamma).\n        by default: 1.\n    interpolation : str\n        Selects method of texture interpolation. Makes use of the two hardware\n        interpolation methods and the available interpolation methods defined\n        in vispy/gloo/glsl/misc/spatial_filters.frag\n\n            * 'nearest': Default, uses 'nearest' with Texture interpolation.\n            * 'linear': uses 'linear' with Texture interpolation.\n            * 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'cubic',\n                'catrom', 'mitchell', 'spline16', 'spline36', 'gaussian',\n                'bessel', 'sinc', 'lanczos', 'blackman'\n    texture_format : numpy.dtype | str | None\n        How to store data on the GPU. OpenGL allows for many different storage\n        formats and schemes for the low-level texture data stored in the GPU.\n        Most common is unsigned integers or floating point numbers.\n        Unsigned integers are the most widely supported while other formats\n        may not be supported on older versions of OpenGL or with older GPUs.\n        Default value is ``None`` which means data will be scaled on the\n        CPU and the result stored in the GPU as an unsigned integer. If a\n        numpy dtype object, an internal texture format will be chosen to\n        support that dtype and data will *not* be scaled on the CPU. Not all\n        dtypes are supported. If a string, then\n        it must be one of the OpenGL internalformat strings described in the\n        table on this page: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml\n        The name should have `GL_` removed and be lowercase (ex.\n        `GL_R32F` becomes ``'r32f'``). Lastly, this can also be the string\n        ``'auto'`` which will use the data type of the provided volume data\n        to determine the internalformat of the texture.\n        When this is specified (not ``None``) data is scaled on the\n        GPU which allows for faster color limit changes. Additionally, when\n        32-bit float data is provided it won't be copied before being\n        transferred to the GPU. Note this visual is limited to \"luminance\"\n        formatted data (single band). This is equivalent to `GL_RED` format\n        in OpenGL 4.0.\n    raycasting_mode : {'volume', 'plane'}\n        Whether to cast a ray through the whole volume or perpendicular to a\n        plane through the volume defined.\n    plane_position : ArrayLike\n        A (3,) array containing a position on a plane of interest in the volume.\n        The position is defined in data coordinates. Only relevant in\n        raycasting_mode = 'plane'.\n    plane_normal : ArrayLike\n        A (3,) array containing a vector normal to the plane of interest in the\n        volume. The normal vector is defined in data coordinates. Only relevant\n        in raycasting_mode = 'plane'.\n    plane_thickness : float\n        A value defining the total length of the ray perpendicular to the\n        plane interrogated during rendering. Defined in data coordinates.\n        Only relevant in raycasting_mode = 'plane'.\n\n\n    .. versionchanged: 0.7\n\n        Deprecate 'emulate_texture' keyword argument.\n\n    \"\"\"\n\n    _rendering_methods = {\n        'mip': _MIP_SNIPPETS,\n        'minip': _MINIP_SNIPPETS,\n        'attenuated_mip': _ATTENUATED_MIP_SNIPPETS,\n        'iso': _ISO_SNIPPETS,\n        'translucent': _TRANSLUCENT_SNIPPETS,\n        'additive': _ADDITIVE_SNIPPETS,\n        'average': _AVG_SNIPPETS\n    }\n\n    _raycasting_modes = {\n        'volume': _RAYCASTING_SETUP_VOLUME,\n        'plane': _RAYCASTING_SETUP_PLANE\n    }\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    _func_templates = {\n        'texture_lookup_interpolated': _INTERPOLATION_TEMPLATE,\n        'texture_lookup': _TEXTURE_LOOKUP,\n    }\n\n    def __init__(self, vol, clim=\"auto\", method='mip', threshold=None,\n                 attenuation=1.0, relative_step_size=0.8, cmap='grays',\n                 gamma=1.0, interpolation='linear', texture_format=None,\n                 raycasting_mode='volume', plane_position=None,\n                 plane_normal=None, plane_thickness=1.0, clipping_planes=None,\n                 clipping_planes_coord_system='scene', mip_cutoff=None,\n                 minip_cutoff=None):\n\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        if clipping_planes_coord_system not in tr:\n            raise ValueError(f'Invalid coordinate system {clipping_planes_coord_system}. Must be one of {tr}.')\n        self._clipping_planes_coord_system = clipping_planes_coord_system\n        self._clip_transform = None\n        # Storage of information of volume\n        self._vol_shape = ()\n        self._gamma = gamma\n        self._raycasting_mode = raycasting_mode\n        self._need_vertex_update = True\n        # Set the colormap\n        self._cmap = get_colormap(cmap)\n        self._is_zyx = True\n\n        # Create gloo objects\n        self._vertices = VertexBuffer()\n\n        kernel, interpolation_methods = load_spatial_filters()\n        self._kerneltex = Texture2D(kernel, interpolation='nearest')\n        interpolation_methods, interpolation_fun = self._init_interpolation(\n            interpolation_methods)\n        self._interpolation_methods = interpolation_methods\n        self._interpolation_fun = interpolation_fun\n        self._interpolation = interpolation\n        if self._interpolation not in self._interpolation_methods:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_methods))\n        self._data_lookup_fn = None\n        self._need_interpolation_update = True\n\n        self._texture = self._create_texture(texture_format, vol)\n        # used to store current data for later CPU-side scaling if\n        # texture_format is None\n        self._last_data = None\n\n        # Create program\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.shared_program['u_volumetex'] = self._texture\n        self.shared_program['a_position'] = self._vertices\n        self.shared_program['gamma'] = self._gamma\n        self._draw_mode = 'triangle_strip'\n        self._index_buffer = IndexBuffer()\n\n        # Only show back faces of cuboid. This is required because if we are\n        # inside the volume, then the front faces are outside of the clipping\n        # box and will not be drawn.\n        self.set_gl_state('translucent', cull_face=False)\n\n        # Apply clim and set data at the same time\n        self.set_data(vol, clim or \"auto\")\n\n        # Set params\n        self.raycasting_mode = raycasting_mode\n        self.mip_cutoff = mip_cutoff\n        self.minip_cutoff = minip_cutoff\n        self.method = method\n        self.relative_step_size = relative_step_size\n        self.threshold = threshold if threshold is not None else vol.mean()\n        self.attenuation = attenuation\n\n        # Set plane params\n        if plane_position is None:\n            self.plane_position = [x / 2 for x in vol.shape]\n        else:\n            self.plane_position = plane_position\n        if plane_normal is None:\n            self.plane_normal = [1, 0, 0]\n        else:\n            self.plane_normal = plane_normal\n        self.plane_thickness = plane_thickness\n\n        self.clipping_planes = clipping_planes\n\n        self.freeze()\n\n    def _init_interpolation(self, interpolation_methods):\n        # create interpolation shader functions for available\n        # interpolations\n        fun = [Function(self._func_templates['texture_lookup_interpolated'] % (n + '3D'))\n               for n in interpolation_methods]\n        interpolation_methods = [n.lower() for n in interpolation_methods]\n\n        interpolation_fun = dict(zip(interpolation_methods, fun))\n        interpolation_methods = tuple(sorted(interpolation_methods))\n\n        # overwrite \"nearest\" and \"linear\" spatial-filters\n        # with  \"hardware\" interpolation _data_lookup_fn\n        hardware_lookup = Function(self._func_templates['texture_lookup'])\n        interpolation_fun['nearest'] = hardware_lookup\n        interpolation_fun['linear'] = hardware_lookup\n        # alias bicubic to cubic (but deprecate)\n        interpolation_methods = interpolation_methods + ('bicubic',)\n        return interpolation_methods, interpolation_fun\n\n    def _create_texture(self, texture_format, data):\n        if texture_format is not None:\n            tex_cls = GPUScaledTextured3D\n        else:\n            tex_cls = CPUScaledTexture3D\n\n        if self._interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        # clamp_to_edge means any texture coordinates outside of 0-1 should be\n        # clamped to 0 and 1.\n        # NOTE: This doesn't actually set the data in the texture. Only\n        # creates a placeholder texture that will be resized later on.\n        return tex_cls(data, interpolation=texture_interpolation,\n                       internalformat=texture_format,\n                       format='luminance',\n                       wrapping='clamp_to_edge')\n\n    def set_data(self, vol, clim=None, copy=True):\n        \"\"\"Set the volume data.\n\n        Parameters\n        ----------\n        vol : ndarray\n            The 3D volume.\n        clim : tuple\n            Colormap limits to use (min, max). None will use the min and max\n            values. Defaults to ``None``.\n        copy : bool\n            Whether to copy the input volume prior to applying clim\n            normalization on the CPU. Has no effect if visual was created\n            with 'texture_format' not equal to None as data is not modified\n            on the CPU and data must already be copied to the GPU.\n            Data must be 32-bit floating point data to completely avoid any\n            data copying when scaling on the CPU. Defaults to ``True`` for\n            CPU scaled data. It is forced to ``False`` for GPU scaled data.\n\n        \"\"\"\n        # Check volume\n        if not isinstance(vol, np.ndarray):\n            raise ValueError('Volume visual needs a numpy array.')\n        if not ((vol.ndim == 3) or (vol.ndim == 4 and vol.shape[-1] > 1)):\n            raise ValueError('Volume visual needs a 3D array.')\n        if isinstance(self._texture, GPUScaledTextured3D):\n            copy = False\n\n        if clim is not None and clim != self._texture.clim:\n            self._texture.set_clim(clim)\n\n        # Apply to texture\n        if should_cast_to_f32(vol.dtype):\n            vol = vol.astype(np.float32)\n        self._texture.check_data_format(vol)\n        self._last_data = vol\n        self._texture.scale_and_set_data(vol, copy=copy)  # will be efficient if vol is same shape\n        self.shared_program['clim'] = self._texture.clim_normalized\n        self.shared_program['u_shape'] = (vol.shape[2], vol.shape[1],\n                                          vol.shape[0])\n\n        shape = vol.shape[:3]\n        if self._vol_shape != shape:\n            self._vol_shape = shape\n            self._need_vertex_update = True\n        self._vol_shape = shape\n\n    @property\n    def rendering_methods(self):\n        return list(self._rendering_methods)\n\n    @property\n    def raycasting_modes(self):\n        return list(self._raycasting_modes)\n\n    @property\n    def clim(self):\n        \"\"\"The contrast limits that were applied to the volume data.\n\n        Volume display is mapped from black to white with these values.\n        Settable via set_data() as well as @clim.setter.\n        \"\"\"\n        return self._texture.clim\n\n    @clim.setter\n    def clim(self, value):\n        \"\"\"Set contrast limits used when rendering the image.\n\n        ``value`` should be a 2-tuple of floats (min_clim, max_clim), where each value is\n        within the range set by self.clim. If the new value is outside of the (min, max)\n        range of the clims previously used to normalize the texture data, then data will\n        be renormalized using set_data.\n        \"\"\"\n        if self._texture.set_clim(value):\n            self.set_data(self._last_data, clim=value)\n        self.shared_program['clim'] = self._texture.clim_normalized\n        self.update()\n\n    @property\n    def gamma(self):\n        \"\"\"The gamma used when rendering the image.\"\"\"\n        return self._gamma\n\n    @gamma.setter\n    def gamma(self, value):\n        \"\"\"Set gamma used when rendering the image.\"\"\"\n        if value <= 0:\n            raise ValueError(\"gamma must be > 0\")\n        self._gamma = float(value)\n        self.shared_program['gamma'] = self._gamma\n        self.update()\n\n    @property\n    def cmap(self):\n        return self._cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self.shared_program.frag['cmap'] = Function(self._cmap.glsl_map)\n        self.shared_program['texture2D_LUT'] = self.cmap.texture_lut()\n        self.update()\n\n    @property\n    def interpolation_methods(self):\n        return self._interpolation_methods\n\n    @property\n    def interpolation(self):\n        \"\"\"Get interpolation algorithm name.\"\"\"\n        return self._interpolation\n\n    @interpolation.setter\n    def interpolation(self, i):\n        if i not in self._interpolation_methods:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_methods))\n        if self._interpolation != i:\n            self._interpolation = i\n            self._need_interpolation_update = True\n            self.update()\n\n    # The interpolation code could be transferred to a dedicated filter\n    # function in visuals/filters as discussed in #1051\n    def _build_interpolation(self):\n        \"\"\"Rebuild the _data_lookup_fn for different interpolations.\"\"\"\n        interpolation = self._interpolation\n        # alias bicubic to cubic\n        if interpolation == 'bicubic':\n            warnings.warn(\n                \"'bicubic' interpolation is Deprecated. Use 'cubic' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'cubic'\n        self._data_lookup_fn = self._interpolation_fun[interpolation]\n        try:\n            self.shared_program.frag['get_data'] = self._data_lookup_fn\n        except Exception as e:\n            print(e)\n\n        # only 'linear' uses 'linear' texture interpolation\n        if interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            # 'nearest' (and also 'linear') doesn't use spatial_filters.frag\n            # so u_kernel and shape setting is skipped\n            texture_interpolation = 'nearest'\n            if interpolation != 'nearest':\n                self.shared_program['u_kernel'] = self._kerneltex\n                self._data_lookup_fn['shape'] = self._last_data.shape[:3][::-1]\n\n        if self._texture.interpolation != texture_interpolation:\n            self._texture.interpolation = texture_interpolation\n\n        self._data_lookup_fn['texture'] = self._texture\n\n        self._need_interpolation_update = False\n\n    @staticmethod\n    @lru_cache(maxsize=10)\n    def _build_clipping_planes_glsl(n_planes: int) -> str:\n        \"\"\"Build the code snippet used to clip the volume based on self.clipping_planes.\"\"\"\n        func_template = '''\n            float clip_planes(vec3 loc, vec3 vol_shape) {{\n                vec3 loc_transf = $clip_transform(vec4(loc * vol_shape, 1)).xyz;\n                float distance_from_clip = 3.4e38; // max float\n                {clips};\n                return distance_from_clip;\n            }}\n        '''\n        # the vertex is considered clipped if on the \"negative\" side of the plane\n        clip_template = '''\n            vec3 relative_vec{idx} = loc_transf - $clipping_plane_pos{idx};\n            float distance_from_clip{idx} = dot(relative_vec{idx}, $clipping_plane_norm{idx});\n            distance_from_clip = min(distance_from_clip{idx}, distance_from_clip);\n            '''\n        all_clips = []\n        for idx in range(n_planes):\n            all_clips.append(clip_template.format(idx=idx))\n        formatted_code = func_template.format(clips=''.join(all_clips))\n        return formatted_code\n\n    @property\n    def clipping_planes(self) -> np.ndarray:\n        \"\"\"The set of planes used to clip the volume. Values on the negative side of the normal are discarded.\n\n        Each plane is defined by a position and a normal vector (magnitude is irrelevant). Shape: (n_planes, 2, 3).\n        The order is xyz, as opposed to data's zyx (for consistency with the rest of vispy)\n\n        Example: one plane in position (0, 0, 0) and with normal (0, 0, 1),\n        and a plane in position (1, 1, 1) with normal (0, 1, 0):\n\n        >>> volume.clipping_planes = np.array([\n        >>>     [[0, 0, 0], [0, 0, 1]],\n        >>>     [[1, 1, 1], [0, 1, 0]],\n        >>> ])\n\n        \"\"\"\n        return self._clipping_planes\n\n    @clipping_planes.setter\n    def clipping_planes(self, value: Optional[np.ndarray]):\n        if value is None:\n            value = np.empty([0, 2, 3])\n        self._clipping_planes = value\n\n        self._clip_func = Function(self._build_clipping_planes_glsl(len(value)))\n        self.shared_program.frag['clip_with_planes'] = self._clip_func\n\n        self._clip_func['clip_transform'] = self._clip_transform\n        for idx, plane in enumerate(value):\n            self._clip_func[f'clipping_plane_pos{idx}'] = tuple(plane[0])\n            self._clip_func[f'clipping_plane_norm{idx}'] = tuple(plane[1])\n        self.update()\n\n    @property\n    def clipping_planes_coord_system(self) -> str:\n        \"\"\"\n        Coordinate system used by the clipping planes (see visuals.transforms.transform_system.py)\n        \"\"\"\n        return self._clipping_planes_coord_system\n\n    @property\n    def _before_loop_snippet(self):\n        return self._rendering_methods[self.method]['before_loop']\n\n    @property\n    def _in_loop_snippet(self):\n        return self._rendering_methods[self.method]['in_loop']\n\n    @property\n    def _after_loop_snippet(self):\n        return self._rendering_methods[self.method]['after_loop']\n\n    @property\n    def method(self):\n        \"\"\"The render method to use\n\n        Current options are:\n\n            * translucent: voxel colors are blended along the view ray until\n              the result is opaque.\n            * mip: maxiumum intensity projection. Cast a ray and display the\n              maximum value that was encountered.\n            * minip: minimum intensity projection. Cast a ray and display the\n              minimum value that was encountered.\n            * attenuated_mip: attenuated maximum intensity projection. Cast a\n              ray and display the maximum value encountered. Values are\n              attenuated as the ray moves deeper into the volume.\n            * additive: voxel colors are added along the view ray until\n              the result is saturated.\n            * iso: isosurface. Cast a ray until a certain threshold is\n              encountered. At that location, lighning calculations are\n              performed to give the visual appearance of a surface.\n            * average: average intensity projection. Cast a ray and display the\n              average of values that were encountered.\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, method):\n        # Check and save\n        known_methods = list(self._rendering_methods.keys())\n        if method not in known_methods:\n            raise ValueError('Volume render method should be in %r, not %r' %\n                             (known_methods, method))\n        self._method = method\n\n        # $get_data needs to be unset and re-set, since it's present inside the snippets.\n        #       Program should probably be able to do this automatically\n        self.shared_program.frag['get_data'] = None\n        self.shared_program.frag['raycasting_setup'] = self._raycasting_setup_snippet\n        self.shared_program.frag['before_loop'] = self._before_loop_snippet\n        self.shared_program.frag['in_loop'] = self._in_loop_snippet\n        self.shared_program.frag['after_loop'] = self._after_loop_snippet\n        self.shared_program.frag['sampler_type'] = self._texture.glsl_sampler_type\n        self.shared_program.frag['cmap'] = Function(self._cmap.glsl_map)\n        self.shared_program['texture2D_LUT'] = self.cmap.texture_lut()\n        self.shared_program['u_mip_cutoff'] = self._mip_cutoff\n        self.shared_program['u_minip_cutoff'] = self._minip_cutoff\n        self._need_interpolation_update = True\n        self.update()\n\n    @property\n    def _raycasting_setup_snippet(self):\n        return self._raycasting_modes[self.raycasting_mode]\n\n    @property\n    def raycasting_mode(self):\n        \"\"\"The raycasting mode to use.\n\n        This defines whether to cast a ray through the whole volume or\n        perpendicular to a plane through the volume.\n        must be in {'volume', 'plane'}\n        \"\"\"\n        return self._raycasting_mode\n\n    @raycasting_mode.setter\n    def raycasting_mode(self, value: str):\n        valid_raycasting_modes = self._raycasting_modes.keys()\n        if value not in valid_raycasting_modes:\n            raise ValueError(f\"Raycasting mode should be in {valid_raycasting_modes}, not {value}\")\n        self._raycasting_mode = value\n        self.shared_program.frag['raycasting_setup'] = self._raycasting_setup_snippet\n        self.update()\n\n    @property\n    def threshold(self):\n        \"\"\"The threshold value to apply for the isosurface render method.\"\"\"\n        return self._threshold\n\n    @threshold.setter\n    def threshold(self, value):\n        self._threshold = float(value)\n        self.shared_program['u_threshold'] = self._threshold\n        self.update()\n\n    @property\n    def attenuation(self):\n        \"\"\"The attenuation rate to apply for the attenuated mip render method.\"\"\"\n        return self._attenuation\n\n    @attenuation.setter\n    def attenuation(self, value):\n        self._attenuation = float(value)\n        self.shared_program['u_attenuation'] = self._attenuation\n        self.update()\n\n    @property\n    def relative_step_size(self):\n        \"\"\"The relative step size used during raycasting.\n\n        Larger values yield higher performance at reduced quality. If\n        set > 2.0 the ray skips entire voxels. Recommended values are\n        between 0.5 and 1.5. The amount of quality degredation depends\n        on the render method.\n        \"\"\"\n        return self._relative_step_size\n\n    @relative_step_size.setter\n    def relative_step_size(self, value):\n        value = float(value)\n        if value < 0.1:\n            raise ValueError('relative_step_size cannot be smaller than 0.1')\n        self._relative_step_size = value\n        self.shared_program['u_relative_step_size'] = value\n\n    @property\n    def plane_position(self):\n        \"\"\"Position on a plane through the volume.\n\n        A (3,) array containing a position on a plane of interest in the volume.\n        The position is defined in data coordinates. Only relevant in\n        raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_position\n\n    @plane_position.setter\n    def plane_position(self, value):\n        value = np.array(value, dtype=np.float32).ravel()\n        if value.shape != (3, ):\n            raise ValueError('plane_position must be a 3 element array-like object')\n        self._plane_position = value\n        self.shared_program['u_plane_position'] = value[::-1]\n        self.update()\n\n    @property\n    def plane_normal(self):\n        \"\"\"Direction normal to a plane through the volume.\n\n        A (3,) array containing a vector normal to the plane of interest in the\n        volume. The normal vector is defined in data coordinates. Only relevant\n        in raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_normal\n\n    @plane_normal.setter\n    def plane_normal(self, value):\n        value = np.array(value, dtype=np.float32).ravel()\n        if value.shape != (3, ):\n            raise ValueError('plane_normal must be a 3 element array-like object')\n        self._plane_normal = value\n        self.shared_program['u_plane_normal'] = value[::-1]\n        self.update()\n\n    @property\n    def plane_thickness(self):\n        \"\"\"Thickness of a plane through the volume.\n\n        A value defining the total length of the ray perpendicular to the\n        plane interrogated during rendering. Defined in data coordinates.\n        Only relevant in raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_thickness\n\n    @plane_thickness.setter\n    def plane_thickness(self, value: float):\n        value = float(value)\n        if value < 1:\n            raise ValueError('plane_thickness should be at least 1.0')\n        self._plane_thickness = value\n        self.shared_program['u_plane_thickness'] = value\n        self.update()\n\n    @property\n    def mip_cutoff(self):\n        \"\"\"The lower cutoff value for `mip` and `attenuated_mip`.\n\n        When using the `mip` or `attenuated_mip` rendering methods, fragments\n        with values below the cutoff will be discarded.\n        \"\"\"\n        return self._mip_cutoff\n\n    @mip_cutoff.setter\n    def mip_cutoff(self, value):\n        if value is None:\n            value = np.finfo('float32').min\n        self._mip_cutoff = float(value)\n        self.shared_program['u_mip_cutoff'] = self._mip_cutoff\n        self.update()\n\n    @property\n    def minip_cutoff(self):\n        \"\"\"The upper cutoff value for `minip`.\n\n        When using the `minip` rendering method, fragments\n        with values above the cutoff will be discarded.\n        \"\"\"\n        return self._minip_cutoff\n\n    @minip_cutoff.setter\n    def minip_cutoff(self, value):\n        if value is None:\n            value = np.finfo('float32').max\n        self._minip_cutoff = float(value)\n        self.shared_program['u_minip_cutoff'] = self._minip_cutoff\n        self.update()\n\n    def _create_vertex_data(self):\n        \"\"\"Create and set positions and texture coords from the given shape\n\n        We have six faces with 1 quad (2 triangles) each, resulting in\n        6*2*3 = 36 vertices in total.\n        \"\"\"\n        shape = self._vol_shape\n\n        # Get corner coordinates. The -0.5 offset is to center\n        # pixels/voxels. This works correctly for anisotropic data.\n        x0, x1 = -0.5, shape[2] - 0.5\n        y0, y1 = -0.5, shape[1] - 0.5\n        z0, z1 = -0.5, shape[0] - 0.5\n\n        pos = np.array([\n            [x0, y0, z0],\n            [x1, y0, z0],\n            [x0, y1, z0],\n            [x1, y1, z0],\n            [x0, y0, z1],\n            [x1, y0, z1],\n            [x0, y1, z1],\n            [x1, y1, z1],\n        ], dtype=np.float32)\n\n        \"\"\"\n          6-------7\n         /|      /|\n        4-------5 |\n        | |     | |\n        | 2-----|-3\n        |/      |/\n        0-------1\n        \"\"\"\n\n        # Order is chosen such that normals face outward; front faces will be\n        # culled.\n        indices = np.array([2, 6, 0, 4, 5, 6, 7, 2, 3, 0, 1, 5, 3, 7],\n                           dtype=np.uint32)\n\n        # Apply\n        self._vertices.set_data(pos)\n        self._index_buffer.set_data(indices)\n\n    def _compute_bounds(self, axis, view):\n        if self._is_zyx:\n            # axis=(x, y, z) -> shape(..., z, y, x)\n            ndim = len(self._vol_shape)\n            return 0, self._vol_shape[ndim - 1 - axis]\n        else:\n            # axis=(x, y, z) -> shape(x, y, z)\n            return 0, self._vol_shape[axis]\n\n    def _prepare_transforms(self, view):\n        trs = view.transforms\n        view.view_program.vert['transform'] = trs.get_transform()\n\n        view_tr_f = trs.get_transform('visual', 'document')\n        view_tr_i = view_tr_f.inverse\n        view.view_program.vert['viewtransformf'] = view_tr_f\n        view.view_program.vert['viewtransformi'] = view_tr_i\n        view.view_program.frag['viewtransformf'] = view_tr_f\n\n        self._clip_transform = trs.get_transform('visual', self._clipping_planes_coord_system)\n\n    def _prepare_draw(self, view):\n        if self._need_vertex_update:\n            self._create_vertex_data()\n\n        if self._need_interpolation_update:\n            self._build_interpolation()",
  "def __init__(self, vol, clim=\"auto\", method='mip', threshold=None,\n                 attenuation=1.0, relative_step_size=0.8, cmap='grays',\n                 gamma=1.0, interpolation='linear', texture_format=None,\n                 raycasting_mode='volume', plane_position=None,\n                 plane_normal=None, plane_thickness=1.0, clipping_planes=None,\n                 clipping_planes_coord_system='scene', mip_cutoff=None,\n                 minip_cutoff=None):\n\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        if clipping_planes_coord_system not in tr:\n            raise ValueError(f'Invalid coordinate system {clipping_planes_coord_system}. Must be one of {tr}.')\n        self._clipping_planes_coord_system = clipping_planes_coord_system\n        self._clip_transform = None\n        # Storage of information of volume\n        self._vol_shape = ()\n        self._gamma = gamma\n        self._raycasting_mode = raycasting_mode\n        self._need_vertex_update = True\n        # Set the colormap\n        self._cmap = get_colormap(cmap)\n        self._is_zyx = True\n\n        # Create gloo objects\n        self._vertices = VertexBuffer()\n\n        kernel, interpolation_methods = load_spatial_filters()\n        self._kerneltex = Texture2D(kernel, interpolation='nearest')\n        interpolation_methods, interpolation_fun = self._init_interpolation(\n            interpolation_methods)\n        self._interpolation_methods = interpolation_methods\n        self._interpolation_fun = interpolation_fun\n        self._interpolation = interpolation\n        if self._interpolation not in self._interpolation_methods:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_methods))\n        self._data_lookup_fn = None\n        self._need_interpolation_update = True\n\n        self._texture = self._create_texture(texture_format, vol)\n        # used to store current data for later CPU-side scaling if\n        # texture_format is None\n        self._last_data = None\n\n        # Create program\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.shared_program['u_volumetex'] = self._texture\n        self.shared_program['a_position'] = self._vertices\n        self.shared_program['gamma'] = self._gamma\n        self._draw_mode = 'triangle_strip'\n        self._index_buffer = IndexBuffer()\n\n        # Only show back faces of cuboid. This is required because if we are\n        # inside the volume, then the front faces are outside of the clipping\n        # box and will not be drawn.\n        self.set_gl_state('translucent', cull_face=False)\n\n        # Apply clim and set data at the same time\n        self.set_data(vol, clim or \"auto\")\n\n        # Set params\n        self.raycasting_mode = raycasting_mode\n        self.mip_cutoff = mip_cutoff\n        self.minip_cutoff = minip_cutoff\n        self.method = method\n        self.relative_step_size = relative_step_size\n        self.threshold = threshold if threshold is not None else vol.mean()\n        self.attenuation = attenuation\n\n        # Set plane params\n        if plane_position is None:\n            self.plane_position = [x / 2 for x in vol.shape]\n        else:\n            self.plane_position = plane_position\n        if plane_normal is None:\n            self.plane_normal = [1, 0, 0]\n        else:\n            self.plane_normal = plane_normal\n        self.plane_thickness = plane_thickness\n\n        self.clipping_planes = clipping_planes\n\n        self.freeze()",
  "def _init_interpolation(self, interpolation_methods):\n        # create interpolation shader functions for available\n        # interpolations\n        fun = [Function(self._func_templates['texture_lookup_interpolated'] % (n + '3D'))\n               for n in interpolation_methods]\n        interpolation_methods = [n.lower() for n in interpolation_methods]\n\n        interpolation_fun = dict(zip(interpolation_methods, fun))\n        interpolation_methods = tuple(sorted(interpolation_methods))\n\n        # overwrite \"nearest\" and \"linear\" spatial-filters\n        # with  \"hardware\" interpolation _data_lookup_fn\n        hardware_lookup = Function(self._func_templates['texture_lookup'])\n        interpolation_fun['nearest'] = hardware_lookup\n        interpolation_fun['linear'] = hardware_lookup\n        # alias bicubic to cubic (but deprecate)\n        interpolation_methods = interpolation_methods + ('bicubic',)\n        return interpolation_methods, interpolation_fun",
  "def _create_texture(self, texture_format, data):\n        if texture_format is not None:\n            tex_cls = GPUScaledTextured3D\n        else:\n            tex_cls = CPUScaledTexture3D\n\n        if self._interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            texture_interpolation = 'nearest'\n\n        # clamp_to_edge means any texture coordinates outside of 0-1 should be\n        # clamped to 0 and 1.\n        # NOTE: This doesn't actually set the data in the texture. Only\n        # creates a placeholder texture that will be resized later on.\n        return tex_cls(data, interpolation=texture_interpolation,\n                       internalformat=texture_format,\n                       format='luminance',\n                       wrapping='clamp_to_edge')",
  "def set_data(self, vol, clim=None, copy=True):\n        \"\"\"Set the volume data.\n\n        Parameters\n        ----------\n        vol : ndarray\n            The 3D volume.\n        clim : tuple\n            Colormap limits to use (min, max). None will use the min and max\n            values. Defaults to ``None``.\n        copy : bool\n            Whether to copy the input volume prior to applying clim\n            normalization on the CPU. Has no effect if visual was created\n            with 'texture_format' not equal to None as data is not modified\n            on the CPU and data must already be copied to the GPU.\n            Data must be 32-bit floating point data to completely avoid any\n            data copying when scaling on the CPU. Defaults to ``True`` for\n            CPU scaled data. It is forced to ``False`` for GPU scaled data.\n\n        \"\"\"\n        # Check volume\n        if not isinstance(vol, np.ndarray):\n            raise ValueError('Volume visual needs a numpy array.')\n        if not ((vol.ndim == 3) or (vol.ndim == 4 and vol.shape[-1] > 1)):\n            raise ValueError('Volume visual needs a 3D array.')\n        if isinstance(self._texture, GPUScaledTextured3D):\n            copy = False\n\n        if clim is not None and clim != self._texture.clim:\n            self._texture.set_clim(clim)\n\n        # Apply to texture\n        if should_cast_to_f32(vol.dtype):\n            vol = vol.astype(np.float32)\n        self._texture.check_data_format(vol)\n        self._last_data = vol\n        self._texture.scale_and_set_data(vol, copy=copy)  # will be efficient if vol is same shape\n        self.shared_program['clim'] = self._texture.clim_normalized\n        self.shared_program['u_shape'] = (vol.shape[2], vol.shape[1],\n                                          vol.shape[0])\n\n        shape = vol.shape[:3]\n        if self._vol_shape != shape:\n            self._vol_shape = shape\n            self._need_vertex_update = True\n        self._vol_shape = shape",
  "def rendering_methods(self):\n        return list(self._rendering_methods)",
  "def raycasting_modes(self):\n        return list(self._raycasting_modes)",
  "def clim(self):\n        \"\"\"The contrast limits that were applied to the volume data.\n\n        Volume display is mapped from black to white with these values.\n        Settable via set_data() as well as @clim.setter.\n        \"\"\"\n        return self._texture.clim",
  "def clim(self, value):\n        \"\"\"Set contrast limits used when rendering the image.\n\n        ``value`` should be a 2-tuple of floats (min_clim, max_clim), where each value is\n        within the range set by self.clim. If the new value is outside of the (min, max)\n        range of the clims previously used to normalize the texture data, then data will\n        be renormalized using set_data.\n        \"\"\"\n        if self._texture.set_clim(value):\n            self.set_data(self._last_data, clim=value)\n        self.shared_program['clim'] = self._texture.clim_normalized\n        self.update()",
  "def gamma(self):\n        \"\"\"The gamma used when rendering the image.\"\"\"\n        return self._gamma",
  "def gamma(self, value):\n        \"\"\"Set gamma used when rendering the image.\"\"\"\n        if value <= 0:\n            raise ValueError(\"gamma must be > 0\")\n        self._gamma = float(value)\n        self.shared_program['gamma'] = self._gamma\n        self.update()",
  "def cmap(self):\n        return self._cmap",
  "def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self.shared_program.frag['cmap'] = Function(self._cmap.glsl_map)\n        self.shared_program['texture2D_LUT'] = self.cmap.texture_lut()\n        self.update()",
  "def interpolation_methods(self):\n        return self._interpolation_methods",
  "def interpolation(self):\n        \"\"\"Get interpolation algorithm name.\"\"\"\n        return self._interpolation",
  "def interpolation(self, i):\n        if i not in self._interpolation_methods:\n            raise ValueError(\"interpolation must be one of %s\" %\n                             ', '.join(self._interpolation_methods))\n        if self._interpolation != i:\n            self._interpolation = i\n            self._need_interpolation_update = True\n            self.update()",
  "def _build_interpolation(self):\n        \"\"\"Rebuild the _data_lookup_fn for different interpolations.\"\"\"\n        interpolation = self._interpolation\n        # alias bicubic to cubic\n        if interpolation == 'bicubic':\n            warnings.warn(\n                \"'bicubic' interpolation is Deprecated. Use 'cubic' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            interpolation = 'cubic'\n        self._data_lookup_fn = self._interpolation_fun[interpolation]\n        try:\n            self.shared_program.frag['get_data'] = self._data_lookup_fn\n        except Exception as e:\n            print(e)\n\n        # only 'linear' uses 'linear' texture interpolation\n        if interpolation == 'linear':\n            texture_interpolation = 'linear'\n        else:\n            # 'nearest' (and also 'linear') doesn't use spatial_filters.frag\n            # so u_kernel and shape setting is skipped\n            texture_interpolation = 'nearest'\n            if interpolation != 'nearest':\n                self.shared_program['u_kernel'] = self._kerneltex\n                self._data_lookup_fn['shape'] = self._last_data.shape[:3][::-1]\n\n        if self._texture.interpolation != texture_interpolation:\n            self._texture.interpolation = texture_interpolation\n\n        self._data_lookup_fn['texture'] = self._texture\n\n        self._need_interpolation_update = False",
  "def _build_clipping_planes_glsl(n_planes: int) -> str:\n        \"\"\"Build the code snippet used to clip the volume based on self.clipping_planes.\"\"\"\n        func_template = '''\n            float clip_planes(vec3 loc, vec3 vol_shape) {{\n                vec3 loc_transf = $clip_transform(vec4(loc * vol_shape, 1)).xyz;\n                float distance_from_clip = 3.4e38; // max float\n                {clips};\n                return distance_from_clip;\n            }}\n        '''\n        # the vertex is considered clipped if on the \"negative\" side of the plane\n        clip_template = '''\n            vec3 relative_vec{idx} = loc_transf - $clipping_plane_pos{idx};\n            float distance_from_clip{idx} = dot(relative_vec{idx}, $clipping_plane_norm{idx});\n            distance_from_clip = min(distance_from_clip{idx}, distance_from_clip);\n            '''\n        all_clips = []\n        for idx in range(n_planes):\n            all_clips.append(clip_template.format(idx=idx))\n        formatted_code = func_template.format(clips=''.join(all_clips))\n        return formatted_code",
  "def clipping_planes(self) -> np.ndarray:\n        \"\"\"The set of planes used to clip the volume. Values on the negative side of the normal are discarded.\n\n        Each plane is defined by a position and a normal vector (magnitude is irrelevant). Shape: (n_planes, 2, 3).\n        The order is xyz, as opposed to data's zyx (for consistency with the rest of vispy)\n\n        Example: one plane in position (0, 0, 0) and with normal (0, 0, 1),\n        and a plane in position (1, 1, 1) with normal (0, 1, 0):\n\n        >>> volume.clipping_planes = np.array([\n        >>>     [[0, 0, 0], [0, 0, 1]],\n        >>>     [[1, 1, 1], [0, 1, 0]],\n        >>> ])\n\n        \"\"\"\n        return self._clipping_planes",
  "def clipping_planes(self, value: Optional[np.ndarray]):\n        if value is None:\n            value = np.empty([0, 2, 3])\n        self._clipping_planes = value\n\n        self._clip_func = Function(self._build_clipping_planes_glsl(len(value)))\n        self.shared_program.frag['clip_with_planes'] = self._clip_func\n\n        self._clip_func['clip_transform'] = self._clip_transform\n        for idx, plane in enumerate(value):\n            self._clip_func[f'clipping_plane_pos{idx}'] = tuple(plane[0])\n            self._clip_func[f'clipping_plane_norm{idx}'] = tuple(plane[1])\n        self.update()",
  "def clipping_planes_coord_system(self) -> str:\n        \"\"\"\n        Coordinate system used by the clipping planes (see visuals.transforms.transform_system.py)\n        \"\"\"\n        return self._clipping_planes_coord_system",
  "def _before_loop_snippet(self):\n        return self._rendering_methods[self.method]['before_loop']",
  "def _in_loop_snippet(self):\n        return self._rendering_methods[self.method]['in_loop']",
  "def _after_loop_snippet(self):\n        return self._rendering_methods[self.method]['after_loop']",
  "def method(self):\n        \"\"\"The render method to use\n\n        Current options are:\n\n            * translucent: voxel colors are blended along the view ray until\n              the result is opaque.\n            * mip: maxiumum intensity projection. Cast a ray and display the\n              maximum value that was encountered.\n            * minip: minimum intensity projection. Cast a ray and display the\n              minimum value that was encountered.\n            * attenuated_mip: attenuated maximum intensity projection. Cast a\n              ray and display the maximum value encountered. Values are\n              attenuated as the ray moves deeper into the volume.\n            * additive: voxel colors are added along the view ray until\n              the result is saturated.\n            * iso: isosurface. Cast a ray until a certain threshold is\n              encountered. At that location, lighning calculations are\n              performed to give the visual appearance of a surface.\n            * average: average intensity projection. Cast a ray and display the\n              average of values that were encountered.\n        \"\"\"\n        return self._method",
  "def method(self, method):\n        # Check and save\n        known_methods = list(self._rendering_methods.keys())\n        if method not in known_methods:\n            raise ValueError('Volume render method should be in %r, not %r' %\n                             (known_methods, method))\n        self._method = method\n\n        # $get_data needs to be unset and re-set, since it's present inside the snippets.\n        #       Program should probably be able to do this automatically\n        self.shared_program.frag['get_data'] = None\n        self.shared_program.frag['raycasting_setup'] = self._raycasting_setup_snippet\n        self.shared_program.frag['before_loop'] = self._before_loop_snippet\n        self.shared_program.frag['in_loop'] = self._in_loop_snippet\n        self.shared_program.frag['after_loop'] = self._after_loop_snippet\n        self.shared_program.frag['sampler_type'] = self._texture.glsl_sampler_type\n        self.shared_program.frag['cmap'] = Function(self._cmap.glsl_map)\n        self.shared_program['texture2D_LUT'] = self.cmap.texture_lut()\n        self.shared_program['u_mip_cutoff'] = self._mip_cutoff\n        self.shared_program['u_minip_cutoff'] = self._minip_cutoff\n        self._need_interpolation_update = True\n        self.update()",
  "def _raycasting_setup_snippet(self):\n        return self._raycasting_modes[self.raycasting_mode]",
  "def raycasting_mode(self):\n        \"\"\"The raycasting mode to use.\n\n        This defines whether to cast a ray through the whole volume or\n        perpendicular to a plane through the volume.\n        must be in {'volume', 'plane'}\n        \"\"\"\n        return self._raycasting_mode",
  "def raycasting_mode(self, value: str):\n        valid_raycasting_modes = self._raycasting_modes.keys()\n        if value not in valid_raycasting_modes:\n            raise ValueError(f\"Raycasting mode should be in {valid_raycasting_modes}, not {value}\")\n        self._raycasting_mode = value\n        self.shared_program.frag['raycasting_setup'] = self._raycasting_setup_snippet\n        self.update()",
  "def threshold(self):\n        \"\"\"The threshold value to apply for the isosurface render method.\"\"\"\n        return self._threshold",
  "def threshold(self, value):\n        self._threshold = float(value)\n        self.shared_program['u_threshold'] = self._threshold\n        self.update()",
  "def attenuation(self):\n        \"\"\"The attenuation rate to apply for the attenuated mip render method.\"\"\"\n        return self._attenuation",
  "def attenuation(self, value):\n        self._attenuation = float(value)\n        self.shared_program['u_attenuation'] = self._attenuation\n        self.update()",
  "def relative_step_size(self):\n        \"\"\"The relative step size used during raycasting.\n\n        Larger values yield higher performance at reduced quality. If\n        set > 2.0 the ray skips entire voxels. Recommended values are\n        between 0.5 and 1.5. The amount of quality degredation depends\n        on the render method.\n        \"\"\"\n        return self._relative_step_size",
  "def relative_step_size(self, value):\n        value = float(value)\n        if value < 0.1:\n            raise ValueError('relative_step_size cannot be smaller than 0.1')\n        self._relative_step_size = value\n        self.shared_program['u_relative_step_size'] = value",
  "def plane_position(self):\n        \"\"\"Position on a plane through the volume.\n\n        A (3,) array containing a position on a plane of interest in the volume.\n        The position is defined in data coordinates. Only relevant in\n        raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_position",
  "def plane_position(self, value):\n        value = np.array(value, dtype=np.float32).ravel()\n        if value.shape != (3, ):\n            raise ValueError('plane_position must be a 3 element array-like object')\n        self._plane_position = value\n        self.shared_program['u_plane_position'] = value[::-1]\n        self.update()",
  "def plane_normal(self):\n        \"\"\"Direction normal to a plane through the volume.\n\n        A (3,) array containing a vector normal to the plane of interest in the\n        volume. The normal vector is defined in data coordinates. Only relevant\n        in raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_normal",
  "def plane_normal(self, value):\n        value = np.array(value, dtype=np.float32).ravel()\n        if value.shape != (3, ):\n            raise ValueError('plane_normal must be a 3 element array-like object')\n        self._plane_normal = value\n        self.shared_program['u_plane_normal'] = value[::-1]\n        self.update()",
  "def plane_thickness(self):\n        \"\"\"Thickness of a plane through the volume.\n\n        A value defining the total length of the ray perpendicular to the\n        plane interrogated during rendering. Defined in data coordinates.\n        Only relevant in raycasting_mode = 'plane'.\n        \"\"\"\n        return self._plane_thickness",
  "def plane_thickness(self, value: float):\n        value = float(value)\n        if value < 1:\n            raise ValueError('plane_thickness should be at least 1.0')\n        self._plane_thickness = value\n        self.shared_program['u_plane_thickness'] = value\n        self.update()",
  "def mip_cutoff(self):\n        \"\"\"The lower cutoff value for `mip` and `attenuated_mip`.\n\n        When using the `mip` or `attenuated_mip` rendering methods, fragments\n        with values below the cutoff will be discarded.\n        \"\"\"\n        return self._mip_cutoff",
  "def mip_cutoff(self, value):\n        if value is None:\n            value = np.finfo('float32').min\n        self._mip_cutoff = float(value)\n        self.shared_program['u_mip_cutoff'] = self._mip_cutoff\n        self.update()",
  "def minip_cutoff(self):\n        \"\"\"The upper cutoff value for `minip`.\n\n        When using the `minip` rendering method, fragments\n        with values above the cutoff will be discarded.\n        \"\"\"\n        return self._minip_cutoff",
  "def minip_cutoff(self, value):\n        if value is None:\n            value = np.finfo('float32').max\n        self._minip_cutoff = float(value)\n        self.shared_program['u_minip_cutoff'] = self._minip_cutoff\n        self.update()",
  "def _create_vertex_data(self):\n        \"\"\"Create and set positions and texture coords from the given shape\n\n        We have six faces with 1 quad (2 triangles) each, resulting in\n        6*2*3 = 36 vertices in total.\n        \"\"\"\n        shape = self._vol_shape\n\n        # Get corner coordinates. The -0.5 offset is to center\n        # pixels/voxels. This works correctly for anisotropic data.\n        x0, x1 = -0.5, shape[2] - 0.5\n        y0, y1 = -0.5, shape[1] - 0.5\n        z0, z1 = -0.5, shape[0] - 0.5\n\n        pos = np.array([\n            [x0, y0, z0],\n            [x1, y0, z0],\n            [x0, y1, z0],\n            [x1, y1, z0],\n            [x0, y0, z1],\n            [x1, y0, z1],\n            [x0, y1, z1],\n            [x1, y1, z1],\n        ], dtype=np.float32)\n\n        \"\"\"\n          6-------7\n         /|      /|\n        4-------5 |\n        | |     | |\n        | 2-----|-3\n        |/      |/\n        0-------1\n        \"\"\"\n\n        # Order is chosen such that normals face outward; front faces will be\n        # culled.\n        indices = np.array([2, 6, 0, 4, 5, 6, 7, 2, 3, 0, 1, 5, 3, 7],\n                           dtype=np.uint32)\n\n        # Apply\n        self._vertices.set_data(pos)\n        self._index_buffer.set_data(indices)",
  "def _compute_bounds(self, axis, view):\n        if self._is_zyx:\n            # axis=(x, y, z) -> shape(..., z, y, x)\n            ndim = len(self._vol_shape)\n            return 0, self._vol_shape[ndim - 1 - axis]\n        else:\n            # axis=(x, y, z) -> shape(x, y, z)\n            return 0, self._vol_shape[axis]",
  "def _prepare_transforms(self, view):\n        trs = view.transforms\n        view.view_program.vert['transform'] = trs.get_transform()\n\n        view_tr_f = trs.get_transform('visual', 'document')\n        view_tr_i = view_tr_f.inverse\n        view.view_program.vert['viewtransformf'] = view_tr_f\n        view.view_program.vert['viewtransformi'] = view_tr_i\n        view.view_program.frag['viewtransformf'] = view_tr_f\n\n        self._clip_transform = trs.get_transform('visual', self._clipping_planes_coord_system)",
  "def _prepare_draw(self, view):\n        if self._need_vertex_update:\n            self._create_vertex_data()\n\n        if self._need_interpolation_update:\n            self._build_interpolation()",
  "class TubeVisual(MeshVisual):\n    \"\"\"Displays a tube around a piecewise-linear path.\n\n    The tube mesh is corrected following its Frenet curvature and\n    torsion such that it varies smoothly along the curve, including if\n    the tube is closed.\n\n    Parameters\n    ----------\n    points : ndarray\n        An array of (x, y, z) points describing the path along which the\n        tube will be extruded.\n    radius : float | ndarray\n        The radius of the tube. Use array of floats as input to set radii of\n        points individually. Defaults to 1.0.\n    closed : bool\n        Whether the tube should be closed, joining the last point to the\n        first. Defaults to False.\n    color : Color | ColorArray\n        The color(s) to use when drawing the tube. The same color is\n        applied to each vertex of the mesh surrounding each point of\n        the line. If the input is a ColorArray, the argument will be\n        cycled; for instance if 'red' is passed then the entire tube\n        will be red, or if ['green', 'blue'] is passed then the points\n        will alternate between these colours. Defaults to 'purple'.\n    tube_points : int\n        The number of points in the circle-approximating polygon of the\n        tube's cross section. Defaults to 8.\n    shading : str | None\n        Same as for the `MeshVisual` class. Defaults to 'smooth'.\n    vertex_colors: ndarray | None\n        Same as for the `MeshVisual` class.\n    face_colors: ndarray | None\n        Same as for the `MeshVisual` class.\n    mode : str\n        Same as for the `MeshVisual` class. Defaults to 'triangles'.\n\n    \"\"\"\n\n    def __init__(self, points, radius=1.0,\n                 closed=False,\n                 color='purple',\n                 tube_points=8,\n                 shading='smooth',\n                 vertex_colors=None,\n                 face_colors=None,\n                 mode='triangles'):\n\n        # make sure we are working with floats\n        points = np.array(points).astype(float)\n\n        tangents, normals, binormals = _frenet_frames(points, closed)\n\n        segments = len(points) - 1\n\n        # if single radius, convert to list of radii\n        if not isinstance(radius, collections.Iterable):\n            radius = [radius] * len(points)\n        elif len(radius) != len(points):\n            raise ValueError('Length of radii list must match points.')\n\n        # get the positions of each vertex\n        grid = np.zeros((len(points), tube_points, 3))\n        for i in range(len(points)):\n            pos = points[i]\n            normal = normals[i]\n            binormal = binormals[i]\n            r = radius[i]\n\n            # Add a vertex for each point on the circle\n            v = np.arange(tube_points,\n                          dtype=np.float) / tube_points * 2 * np.pi\n            cx = -1. * r * np.cos(v)\n            cy = r * np.sin(v)\n            grid[i] = (pos + cx[:, np.newaxis]*normal +\n                       cy[:, np.newaxis]*binormal)\n\n        # construct the mesh\n        indices = []\n        for i in range(segments):\n            for j in range(tube_points):\n                ip = (i+1) % segments if closed else i+1\n                jp = (j+1) % tube_points\n\n                index_a = i*tube_points + j\n                index_b = ip*tube_points + j\n                index_c = ip*tube_points + jp\n                index_d = i*tube_points + jp\n\n                indices.append([index_a, index_b, index_d])\n                indices.append([index_b, index_c, index_d])\n\n        vertices = grid.reshape(grid.shape[0]*grid.shape[1], 3)\n\n        color = ColorArray(color)\n        if vertex_colors is None:\n            point_colors = np.resize(color.rgba,\n                                     (len(points), 4))\n            vertex_colors = np.repeat(point_colors, tube_points, axis=0)\n\n        indices = np.array(indices, dtype=np.uint32)\n\n        MeshVisual.__init__(self, vertices, indices,\n                            vertex_colors=vertex_colors,\n                            face_colors=face_colors,\n                            shading=shading,\n                            mode=mode)",
  "def _frenet_frames(points, closed):\n    \"\"\"Calculates and returns the tangents, normals and binormals for\n    the tube.\n    \"\"\"\n    tangents = np.zeros((len(points), 3))\n    normals = np.zeros((len(points), 3))\n\n    epsilon = 0.0001\n\n    # Compute tangent vectors for each segment\n    tangents = np.roll(points, -1, axis=0) - np.roll(points, 1, axis=0)\n    if not closed:\n        tangents[0] = points[1] - points[0]\n        tangents[-1] = points[-1] - points[-2]\n    mags = np.sqrt(np.sum(tangents * tangents, axis=1))\n    tangents /= mags[:, np.newaxis]\n\n    # Get initial normal and binormal\n    t = np.abs(tangents[0])\n\n    smallest = np.argmin(t)\n    normal = np.zeros(3)\n    normal[smallest] = 1.\n\n    vec = np.cross(tangents[0], normal)\n\n    normals[0] = np.cross(tangents[0], vec)\n\n    # Compute normal and binormal vectors along the path\n    for i in range(1, len(points)):\n        normals[i] = normals[i-1]\n\n        vec = np.cross(tangents[i-1], tangents[i])\n        if norm(vec) > epsilon:\n            vec /= norm(vec)\n            theta = np.arccos(np.clip(tangents[i-1].dot(tangents[i]), -1, 1))\n            normals[i] = rotate(-np.degrees(theta),\n                                vec)[:3, :3].dot(normals[i])\n\n    if closed:\n        theta = np.arccos(np.clip(normals[0].dot(normals[-1]), -1, 1))\n        theta /= len(points) - 1\n\n        if tangents[0].dot(np.cross(normals[0], normals[-1])) > 0:\n            theta *= -1.\n\n        for i in range(1, len(points)):\n            normals[i] = rotate(-np.degrees(theta*i),\n                                tangents[i])[:3, :3].dot(normals[i])\n\n    binormals = np.cross(tangents, normals)\n\n    return tangents, normals, binormals",
  "def __init__(self, points, radius=1.0,\n                 closed=False,\n                 color='purple',\n                 tube_points=8,\n                 shading='smooth',\n                 vertex_colors=None,\n                 face_colors=None,\n                 mode='triangles'):\n\n        # make sure we are working with floats\n        points = np.array(points).astype(float)\n\n        tangents, normals, binormals = _frenet_frames(points, closed)\n\n        segments = len(points) - 1\n\n        # if single radius, convert to list of radii\n        if not isinstance(radius, collections.Iterable):\n            radius = [radius] * len(points)\n        elif len(radius) != len(points):\n            raise ValueError('Length of radii list must match points.')\n\n        # get the positions of each vertex\n        grid = np.zeros((len(points), tube_points, 3))\n        for i in range(len(points)):\n            pos = points[i]\n            normal = normals[i]\n            binormal = binormals[i]\n            r = radius[i]\n\n            # Add a vertex for each point on the circle\n            v = np.arange(tube_points,\n                          dtype=np.float) / tube_points * 2 * np.pi\n            cx = -1. * r * np.cos(v)\n            cy = r * np.sin(v)\n            grid[i] = (pos + cx[:, np.newaxis]*normal +\n                       cy[:, np.newaxis]*binormal)\n\n        # construct the mesh\n        indices = []\n        for i in range(segments):\n            for j in range(tube_points):\n                ip = (i+1) % segments if closed else i+1\n                jp = (j+1) % tube_points\n\n                index_a = i*tube_points + j\n                index_b = ip*tube_points + j\n                index_c = ip*tube_points + jp\n                index_d = i*tube_points + jp\n\n                indices.append([index_a, index_b, index_d])\n                indices.append([index_b, index_c, index_d])\n\n        vertices = grid.reshape(grid.shape[0]*grid.shape[1], 3)\n\n        color = ColorArray(color)\n        if vertex_colors is None:\n            point_colors = np.resize(color.rgba,\n                                     (len(points), 4))\n            vertex_colors = np.repeat(point_colors, tube_points, axis=0)\n\n        indices = np.array(indices, dtype=np.uint32)\n\n        MeshVisual.__init__(self, vertices, indices,\n                            vertex_colors=vertex_colors,\n                            face_colors=face_colors,\n                            shading=shading,\n                            mode=mode)",
  "class IsosurfaceVisual(MeshVisual):\n    \"\"\"Displays an isosurface of a 3D scalar array.\n\n    Parameters\n    ----------\n    data : ndarray | None\n        3D scalar array.\n    level: float | None\n        The level at which the isosurface is constructed from *data*.\n    vertex_colors : ndarray | None\n        The vertex colors to use.\n    face_colors : ndarray | None\n        The face colors to use.\n    color : ndarray | None\n        The color to use.\n    **kwargs : dict\n        Keyword arguments to pass to the mesh construction.\n    \"\"\"\n\n    def __init__(self, data=None, level=None, vertex_colors=None,\n                 face_colors=None, color=(0.5, 0.5, 1, 1), **kwargs):\n        self._data = None\n        self._level = level\n        self._vertex_colors = vertex_colors\n        self._face_colors = face_colors\n        self._color = Color(color)\n\n        # We distinguish between recomputing and just changing the visual\n        # properties - in the latter case we don't recompute the faces.\n        self._vertices_cache = None\n        self._faces_cache = None\n        self._recompute = True\n        self._update_meshvisual = True\n\n        MeshVisual.__init__(self, **kwargs)\n        if data is not None:\n            self.set_data(data, vertex_colors=vertex_colors,\n                          face_colors=face_colors, color=color)\n\n    @property\n    def level(self):\n        \"\"\"The threshold at which the isosurface is constructed from the 3D data.\"\"\"\n        return self._level\n\n    @level.setter\n    def level(self, level):\n        self._level = level\n        self._recompute = True\n        self.update()\n\n    def set_data(self, data=None, vertex_colors=None, face_colors=None,\n                 color=None):\n        \"\"\"Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 3D array of scalar values. The isosurface is constructed to show\n            all locations in the scalar field equal to ``self.level``.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        # We only change the internal variables if they are provided\n        if data is not None:\n            self._data = data\n            self._recompute = True\n        if vertex_colors is not None:\n            self._vertex_colors = vertex_colors\n            self._update_meshvisual = True\n        if face_colors is not None:\n            self._face_colors = face_colors\n            self._update_meshvisual = True\n        if color is not None:\n            self._color = Color(color)\n            self._update_meshvisual = True\n        self.update()\n\n    def _prepare_draw(self, view):\n\n        if self._data is None or self._level is None:\n            return False\n\n        if self._recompute:\n            self._vertices_cache, self._faces_cache = isosurface(self._data,\n                                                                 self._level)\n            self._recompute = False\n            self._update_meshvisual = True\n\n        if self._update_meshvisual:\n            MeshVisual.set_data(self,\n                                vertices=self._vertices_cache,\n                                faces=self._faces_cache,\n                                vertex_colors=self._vertex_colors,\n                                face_colors=self._face_colors,\n                                color=self._color)\n            self._update_meshvisual = False\n\n        return MeshVisual._prepare_draw(self, view)",
  "def __init__(self, data=None, level=None, vertex_colors=None,\n                 face_colors=None, color=(0.5, 0.5, 1, 1), **kwargs):\n        self._data = None\n        self._level = level\n        self._vertex_colors = vertex_colors\n        self._face_colors = face_colors\n        self._color = Color(color)\n\n        # We distinguish between recomputing and just changing the visual\n        # properties - in the latter case we don't recompute the faces.\n        self._vertices_cache = None\n        self._faces_cache = None\n        self._recompute = True\n        self._update_meshvisual = True\n\n        MeshVisual.__init__(self, **kwargs)\n        if data is not None:\n            self.set_data(data, vertex_colors=vertex_colors,\n                          face_colors=face_colors, color=color)",
  "def level(self):\n        \"\"\"The threshold at which the isosurface is constructed from the 3D data.\"\"\"\n        return self._level",
  "def level(self, level):\n        self._level = level\n        self._recompute = True\n        self.update()",
  "def set_data(self, data=None, vertex_colors=None, face_colors=None,\n                 color=None):\n        \"\"\"Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 3D array of scalar values. The isosurface is constructed to show\n            all locations in the scalar field equal to ``self.level``.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        # We only change the internal variables if they are provided\n        if data is not None:\n            self._data = data\n            self._recompute = True\n        if vertex_colors is not None:\n            self._vertex_colors = vertex_colors\n            self._update_meshvisual = True\n        if face_colors is not None:\n            self._face_colors = face_colors\n            self._update_meshvisual = True\n        if color is not None:\n            self._color = Color(color)\n            self._update_meshvisual = True\n        self.update()",
  "def _prepare_draw(self, view):\n\n        if self._data is None or self._level is None:\n            return False\n\n        if self._recompute:\n            self._vertices_cache, self._faces_cache = isosurface(self._data,\n                                                                 self._level)\n            self._recompute = False\n            self._update_meshvisual = True\n\n        if self._update_meshvisual:\n            MeshVisual.set_data(self,\n                                vertices=self._vertices_cache,\n                                faces=self._faces_cache,\n                                vertex_colors=self._vertex_colors,\n                                face_colors=self._face_colors,\n                                color=self._color)\n            self._update_meshvisual = False\n\n        return MeshVisual._prepare_draw(self, view)",
  "class PolygonVisual(CompoundVisual):\n    \"\"\"\n    Displays a 2D polygon\n\n    Parameters\n    ----------\n    pos : array\n        Set of vertices defining the polygon.\n    color : str | tuple | list of colors\n        Fill color of the polygon.\n    border_color : str | tuple | list of colors\n        Border color of the polygon.\n    border_width : int\n        Border width in pixels.\n        Line widths > 1px are only\n        guaranteed to work when using `border_method='agg'` method.\n    border_method : str\n        Mode to use for drawing the border line (see `LineVisual`).\n\n            * \"agg\" uses anti-grain geometry to draw nicely antialiased lines\n              with proper joins and endcaps.\n            * \"gl\" uses OpenGL's built-in line rendering. This is much faster,\n              but produces much lower-quality results and is not guaranteed to\n              obey the requested line width or join/endcap styles.\n\n    triangulate : boolean\n        Triangulate the set of vertices\n    **kwargs : dict\n        Keyword arguments to pass to `CompoundVisual`.\n    \"\"\"\n\n    def __init__(self, pos=None, color='black',\n                 border_color=None, border_width=1, border_method='gl',\n                 triangulate=True, **kwargs):\n        self._mesh = MeshVisual()\n        self._border = LineVisual(method=border_method)\n        self._pos = pos\n        self._color = Color(color)\n        self._border_width = border_width\n        self._border_color = Color(border_color)\n        self._triangulate = triangulate\n\n        self._update()\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self._mesh.set_gl_state(polygon_offset_fill=True,\n                                polygon_offset=(1, 1), cull_face=False)\n        self.freeze()\n\n    def _update(self):\n        if self._pos is None:\n            return\n        if not self._color.is_blank and self._triangulate:\n            data = PolygonData(vertices=np.array(self._pos, dtype=np.float32))\n            pts, tris = data.triangulate()\n            set_state(polygon_offset_fill=False)\n            self._mesh.set_data(vertices=pts, faces=tris.astype(np.uint32),\n                                color=self._color.rgba)\n        elif not self._color.is_blank:\n            self.mesh.set_data(vertices=self._pos,\n                               color=self._color.rgba)\n\n        if not self._border_color.is_blank:\n            # Close border if it is not already.\n            border_pos = self._pos\n            if np.any(border_pos[0] != border_pos[-1]):\n                border_pos = np.concatenate([border_pos, border_pos[:1]],\n                                            axis=0)\n            self._border.set_data(pos=border_pos,\n                                  color=self._border_color.rgba,\n                                  width=self._border_width)\n\n            self._border.update()\n\n    @property\n    def pos(self):\n        \"\"\"The vertex position of the polygon.\"\"\"\n        return self._pos\n\n    @pos.setter\n    def pos(self, pos):\n        self._pos = pos\n        self._update()\n\n    @property\n    def color(self):\n        \"\"\"The color of the polygon.\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        self._color = Color(color, clip=True)\n        self._update()\n\n    @property\n    def border_color(self):\n        \"\"\"The border color of the polygon.\"\"\"\n        return self._border_color\n\n    @border_color.setter\n    def border_color(self, border_color):\n        self._border_color = Color(border_color)\n        self._update()\n\n    @property\n    def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that is owned by the PolygonVisual.\n        It is used to fill in the polygon\n        \"\"\"\n        return self._mesh\n\n    @mesh.setter\n    def mesh(self, mesh):\n        self._mesh = mesh\n        self._update()\n\n    @property\n    def border(self):\n        \"\"\"The vispy.visuals.LineVisual that is owned by the PolygonVisual.\n        It is used to draw the border of the polygon\n        \"\"\"\n        return self._border\n\n    @border.setter\n    def border(self, border):\n        self._border = border\n        self._update()",
  "def __init__(self, pos=None, color='black',\n                 border_color=None, border_width=1, border_method='gl',\n                 triangulate=True, **kwargs):\n        self._mesh = MeshVisual()\n        self._border = LineVisual(method=border_method)\n        self._pos = pos\n        self._color = Color(color)\n        self._border_width = border_width\n        self._border_color = Color(border_color)\n        self._triangulate = triangulate\n\n        self._update()\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self._mesh.set_gl_state(polygon_offset_fill=True,\n                                polygon_offset=(1, 1), cull_face=False)\n        self.freeze()",
  "def _update(self):\n        if self._pos is None:\n            return\n        if not self._color.is_blank and self._triangulate:\n            data = PolygonData(vertices=np.array(self._pos, dtype=np.float32))\n            pts, tris = data.triangulate()\n            set_state(polygon_offset_fill=False)\n            self._mesh.set_data(vertices=pts, faces=tris.astype(np.uint32),\n                                color=self._color.rgba)\n        elif not self._color.is_blank:\n            self.mesh.set_data(vertices=self._pos,\n                               color=self._color.rgba)\n\n        if not self._border_color.is_blank:\n            # Close border if it is not already.\n            border_pos = self._pos\n            if np.any(border_pos[0] != border_pos[-1]):\n                border_pos = np.concatenate([border_pos, border_pos[:1]],\n                                            axis=0)\n            self._border.set_data(pos=border_pos,\n                                  color=self._border_color.rgba,\n                                  width=self._border_width)\n\n            self._border.update()",
  "def pos(self):\n        \"\"\"The vertex position of the polygon.\"\"\"\n        return self._pos",
  "def pos(self, pos):\n        self._pos = pos\n        self._update()",
  "def color(self):\n        \"\"\"The color of the polygon.\"\"\"\n        return self._color",
  "def color(self, color):\n        self._color = Color(color, clip=True)\n        self._update()",
  "def border_color(self):\n        \"\"\"The border color of the polygon.\"\"\"\n        return self._border_color",
  "def border_color(self, border_color):\n        self._border_color = Color(border_color)\n        self._update()",
  "def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that is owned by the PolygonVisual.\n        It is used to fill in the polygon\n        \"\"\"\n        return self._mesh",
  "def mesh(self, mesh):\n        self._mesh = mesh\n        self._update()",
  "def border(self):\n        \"\"\"The vispy.visuals.LineVisual that is owned by the PolygonVisual.\n        It is used to draw the border of the polygon\n        \"\"\"\n        return self._border",
  "def border(self, border):\n        self._border = border\n        self._update()",
  "class ComplexImageVisual(ImageVisual):\n    \"\"\":class:`~vispy.visuals.ImageVisual` subclass displaying a complex-valued image.\n\n    This class handles complex values by using an rg32f float texture behind the scenes,\n    storing the real component in the \"r\"  value and the imaginary in the \"g\" value.\n\n    Parameters\n    ----------\n    data : ndarray\n        Complex valued ImageVisual data.  Should be a two dimensional array with a dtype\n        of np.complex64 or np.complex128.\n    complex_mode : str\n        The mode used to convert the complex value in each pixel into a scalar:\n            * 'real': show only the real component.\n            * 'imaginary': show only the imaginary component.\n            * 'magnitude': show the magnitude (`np.abs`) of the complex value.\n            * 'phase': show the phase (`np.angle`) of the complex value.\n    \"\"\"\n    COMPLEX_MODES = set(COMPLEX_TRANSFORMS)\n\n    def __init__(self, data=None, complex_mode=\"magnitude\", **kwargs):\n        if complex_mode not in self.COMPLEX_MODES:\n            raise ValueError(\n                \"complex_mode must be one of %s\" % \", \".join(self.COMPLEX_MODES)\n            )\n        self._data_is_complex = np.iscomplexobj(data)\n        self._complex_mode = complex_mode\n\n        if kwargs.get(\"clim\", \"auto\") == \"auto\" and self._data_is_complex:\n            kwargs[\"clim\"] = self._calc_complex_clim(data)\n\n        kwargs[\"texture_format\"] = \"r32f\" if self._data_is_complex else \"r32f\"\n        if self._data_is_complex:\n            data = self._convert_complex_to_float_view(data)\n        super().__init__(data=data, **kwargs)\n\n    def _init_texture(self, data, texture_format, **texture_kwargs):\n        texture_kwargs = {}\n        if self._data_is_complex:\n            texture_kwargs[\"format\"] = \"rg\"\n        return super()._init_texture(data, texture_format, **texture_kwargs)\n\n    def set_data(self, image):\n        data = np.asarray(image)\n        if np.iscomplexobj(data):\n            #  Turn the texture into an rg32f texture\n            # where r = 'real' and g = 'imag'\n            self._data_is_complex = True\n            # FUTURE: Add formal way of defining texture format from set_data\n            self._texture._format = \"rg\"\n            data = self._convert_complex_to_float_view(data)\n        elif data.ndim == 3 and data.shape[-1] == 2:\n            # data was complex but was already converted to 32-bit float\n            # should really only occur from __init__\n            self._data_is_complex = True\n        else:\n            self._texture._format = None\n        return super().set_data(data)\n\n    @staticmethod\n    def _convert_complex_to_float_view(complex_arr):\n        # turn complex128 into complex64 if needed\n        complex64_arr = complex_arr.astype(np.complex64, copy=False)\n        float_view_arr = complex64_arr.view(dtype=np.float32).reshape((complex64_arr.shape + (2, )))\n        return float_view_arr\n\n    @property\n    def complex_mode(self):\n        return self._data_is_complex and self._complex_mode\n\n    @complex_mode.setter\n    def complex_mode(self, value):\n        if value not in self.COMPLEX_MODES:\n            raise ValueError(\n                \"complex_mode must be one of %s\" % \", \".join(self.COMPLEX_MODES)\n            )\n        if self._complex_mode != value:\n            self._complex_mode = value\n            self._need_colortransform_update = True\n            self.update()\n\n    def _build_color_transform(self):\n        if self.complex_mode:\n            fclim = Function(_APPLY_CLIM_FLOAT)\n            fgamma = Function(_APPLY_GAMMA_FLOAT)\n            chain = [\n                Function(COMPLEX_TRANSFORMS[self.complex_mode]),\n                fclim,\n                fgamma,\n                Function(self.cmap.glsl_map),\n            ]\n            fun = FunctionChain(None, chain)\n            fclim[\"clim\"] = self._texture.clim_normalized\n            fgamma[\"gamma\"] = self.gamma\n            return fun\n        return super()._build_color_transform()\n\n    @ImageVisual.clim.setter\n    def clim(self, clim):\n        if clim == \"auto\" and self.complex_mode:\n            clim = self._calc_complex_clim()\n        super(ComplexImageVisual, type(self)).clim.fset(self, clim)\n\n    def _calc_complex_clim(self, data=None):\n        # it would be nice if this could be done in the scalable texture mixin,\n        # but that would require the mixin knowing about the complex mode.\n        func = CPU_COMPLEX_TRANSFORMS[self.complex_mode]\n        _rendered = func(self._data if data is None else data)\n        return (_rendered.min(), _rendered.max())",
  "def __init__(self, data=None, complex_mode=\"magnitude\", **kwargs):\n        if complex_mode not in self.COMPLEX_MODES:\n            raise ValueError(\n                \"complex_mode must be one of %s\" % \", \".join(self.COMPLEX_MODES)\n            )\n        self._data_is_complex = np.iscomplexobj(data)\n        self._complex_mode = complex_mode\n\n        if kwargs.get(\"clim\", \"auto\") == \"auto\" and self._data_is_complex:\n            kwargs[\"clim\"] = self._calc_complex_clim(data)\n\n        kwargs[\"texture_format\"] = \"r32f\" if self._data_is_complex else \"r32f\"\n        if self._data_is_complex:\n            data = self._convert_complex_to_float_view(data)\n        super().__init__(data=data, **kwargs)",
  "def _init_texture(self, data, texture_format, **texture_kwargs):\n        texture_kwargs = {}\n        if self._data_is_complex:\n            texture_kwargs[\"format\"] = \"rg\"\n        return super()._init_texture(data, texture_format, **texture_kwargs)",
  "def set_data(self, image):\n        data = np.asarray(image)\n        if np.iscomplexobj(data):\n            #  Turn the texture into an rg32f texture\n            # where r = 'real' and g = 'imag'\n            self._data_is_complex = True\n            # FUTURE: Add formal way of defining texture format from set_data\n            self._texture._format = \"rg\"\n            data = self._convert_complex_to_float_view(data)\n        elif data.ndim == 3 and data.shape[-1] == 2:\n            # data was complex but was already converted to 32-bit float\n            # should really only occur from __init__\n            self._data_is_complex = True\n        else:\n            self._texture._format = None\n        return super().set_data(data)",
  "def _convert_complex_to_float_view(complex_arr):\n        # turn complex128 into complex64 if needed\n        complex64_arr = complex_arr.astype(np.complex64, copy=False)\n        float_view_arr = complex64_arr.view(dtype=np.float32).reshape((complex64_arr.shape + (2, )))\n        return float_view_arr",
  "def complex_mode(self):\n        return self._data_is_complex and self._complex_mode",
  "def complex_mode(self, value):\n        if value not in self.COMPLEX_MODES:\n            raise ValueError(\n                \"complex_mode must be one of %s\" % \", \".join(self.COMPLEX_MODES)\n            )\n        if self._complex_mode != value:\n            self._complex_mode = value\n            self._need_colortransform_update = True\n            self.update()",
  "def _build_color_transform(self):\n        if self.complex_mode:\n            fclim = Function(_APPLY_CLIM_FLOAT)\n            fgamma = Function(_APPLY_GAMMA_FLOAT)\n            chain = [\n                Function(COMPLEX_TRANSFORMS[self.complex_mode]),\n                fclim,\n                fgamma,\n                Function(self.cmap.glsl_map),\n            ]\n            fun = FunctionChain(None, chain)\n            fclim[\"clim\"] = self._texture.clim_normalized\n            fgamma[\"gamma\"] = self.gamma\n            return fun\n        return super()._build_color_transform()",
  "def clim(self, clim):\n        if clim == \"auto\" and self.complex_mode:\n            clim = self._calc_complex_clim()\n        super(ComplexImageVisual, type(self)).clim.fset(self, clim)",
  "def _calc_complex_clim(self, data=None):\n        # it would be nice if this could be done in the scalable texture mixin,\n        # but that would require the mixin knowing about the complex mode.\n        func = CPU_COMPLEX_TRANSFORMS[self.complex_mode]\n        _rendered = func(self._data if data is None else data)\n        return (_rendered.min(), _rendered.max())",
  "class VisualShare(object):\n    \"\"\"Contains data that is shared between all views of a visual.\n\n    This includes:\n\n        * GL state variables (blending, depth test, etc.)\n        * A weak dictionary of all views\n        * A list of filters that should be applied to all views\n        * A cache for bounds.\n\n    \"\"\"\n\n    def __init__(self):\n        # Note: in some cases we will need to compute bounds independently for\n        # each view. That will have to be worked out later..\n        self.bounds = {}\n        self.gl_state = {}\n        self.views = weakref.WeakKeyDictionary()\n        self.filters = []\n        self.visible = True",
  "class BaseVisual(Frozen):\n    \"\"\"Superclass for all visuals.\n\n    This class provides:\n\n        * A TransformSystem.\n        * Two events: `update` and `bounds_change`.\n        * Minimal framework for creating views of the visual.\n        * A data structure that is shared between all views of the visual.\n        * Abstract `draw`, `bounds`, `attach`, and `detach` methods.\n\n    Parameters\n    ----------\n    vshare : instance of VisualShare | None\n        The visual share.\n\n    Notes\n    -----\n    When used in the scenegraph, all Visual classes are mixed with\n    `vispy.scene.Node` in order to implement the methods, attributes and\n    capabilities required for their usage within it.\n\n    This subclasses Frozen so that subclasses can easily freeze their\n    properties.\n    \"\"\"\n\n    def __init__(self, vshare=None):\n        self._view_class = getattr(self, '_view_class', VisualView)\n\n        self._vshare = VisualShare() if vshare is None else vshare\n        self._vshare.views[self] = None\n\n        self.events = EmitterGroup(source=self,\n                                   auto_connect=True,\n                                   update=Event,\n                                   bounds_change=Event\n                                   )\n\n        self._transforms = None\n        self.transforms = TransformSystem()\n\n    @property\n    def transform(self):\n        return self.transforms.visual_transform.transforms[0]\n\n    @transform.setter\n    def transform(self, tr):\n        self.transforms.visual_transform = tr\n\n    @property\n    def transforms(self):\n        return self._transforms\n\n    @transforms.setter\n    def transforms(self, trs):\n        if trs is self._transforms:\n            return\n        if self._transforms is not None:\n            self._transforms.changed.disconnect(self._transform_changed)\n        self._transforms = trs\n        trs.changed.connect(self._transform_changed)\n        self._transform_changed()\n\n    def get_transform(self, map_from='visual', map_to='render'):\n        \"\"\"Return a transform mapping between any two coordinate systems.\n\n        Parameters\n        ----------\n        map_from : str\n            The starting coordinate system to map from. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        map_to : str\n            The ending coordinate system to map to. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        \"\"\"\n        return self.transforms.get_transform(map_from, map_to)\n\n    @property\n    def visible(self):\n        return self._vshare.visible\n\n    @visible.setter\n    def visible(self, v):\n        if v != self._vshare.visible:\n            self._vshare.visible = v\n            self.update()\n\n    def view(self):\n        \"\"\"Return a new view of this visual.\"\"\"\n        return self._view_class(self)\n\n    def draw(self):\n        raise NotImplementedError(self)\n\n    def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual.\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        raise NotImplementedError(self)\n\n    def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        raise NotImplementedError(self)\n\n    def bounds(self, axis, view=None):\n        \"\"\"Get the bounds of the Visual\n\n        Parameters\n        ----------\n        axis : int\n            The axis.\n        view : instance of VisualView\n            The view to use.\n        \"\"\"\n        if view is None:\n            view = self\n        if axis not in self._vshare.bounds:\n            self._vshare.bounds[axis] = self._compute_bounds(axis, view)\n        return self._vshare.bounds[axis]\n\n    def _compute_bounds(self, axis, view):\n        raise NotImplementedError(self)\n\n    def _bounds_changed(self):\n        self._vshare.bounds.clear()\n\n    def update(self):\n        \"\"\"Update the Visual\"\"\"\n        self.events.update()\n\n    def _transform_changed(self, event=None):\n        self.update()",
  "class BaseVisualView(object):\n    \"\"\"Base class for a view on a visual.\n\n    This class must be mixed with another Visual class to work properly. It\n    works mainly by forwarding the calls to _prepare_draw, _prepare_transforms,\n    and _compute_bounds to the viewed visual.\n    \"\"\"\n\n    def __init__(self, visual):\n        self._visual = visual\n\n    @property\n    def visual(self):\n        return self._visual\n\n    def _prepare_draw(self, view=None):\n        self._visual._prepare_draw(view=view)\n\n    def _prepare_transforms(self, view):\n        self._visual._prepare_transforms(view)\n\n    def _compute_bounds(self, axis, view):\n        self._visual._compute_bounds(axis, view)\n\n    def __repr__(self):\n        return '<%s on %r>' % (self.__class__.__name__, self._visual)",
  "class Visual(BaseVisual):\n    \"\"\"Base class for all visuals that can be drawn using a single shader\n    program.\n\n    This class creates a MultiProgram, which is an object that\n    behaves like a normal shader program (you can assign shader code, upload\n    values, set template variables, etc.) but internally manages multiple\n    ModularProgram instances, one per view.\n\n    Subclasses generally only need to reimplement _compute_bounds,\n    _prepare_draw, and _prepare_transforms.\n\n    Parameters\n    ----------\n    vcode : str\n        Vertex shader code.\n    fcode : str\n        Fragment shader code.\n    gcode : str or None\n        Optional geometry shader code.\n    program : instance of Program | None\n        The program to use. If None, a program will be constructed using\n        ``vcode`` and ``fcode``.\n    vshare : instance of VisualShare | None\n        The visual share, if necessary.\n    \"\"\"\n\n    def __init__(self, vcode='', fcode='', gcode=None, program=None,\n                 vshare=None):\n        self._view_class = VisualView\n        BaseVisual.__init__(self, vshare)\n        if vshare is None:\n            self._vshare.draw_mode = None\n            self._vshare.index_buffer = None\n            if program is None:\n                self._vshare.program = MultiProgram(vcode, fcode, gcode)\n            else:\n                self._vshare.program = program\n                if len(vcode) > 0 or len(fcode) > 0:\n                    raise ValueError(\"Cannot specify both program and \"\n                                     \"vcode/fcode arguments.\")\n\n        self._program = self._vshare.program.add_program()\n        self._prepare_transforms(self)\n        self._filters = []\n        self._hooks = {}\n\n    def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        self._vshare.gl_state = kwargs\n        self._vshare.gl_state['preset'] = preset\n\n    def update_gl_state(self, *args, **kwargs):\n        \"\"\"Modify the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        if len(args) == 1:\n            self._vshare.gl_state['preset'] = args[0]\n        elif len(args) != 0:\n            raise TypeError(\"Only one positional argument allowed.\")\n        self._vshare.gl_state.update(kwargs)\n\n    def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        return None\n\n    def _prepare_draw(self, view=None):\n        \"\"\"This visual is about to be drawn.\n\n        Visuals should implement this method to ensure that all program\n        and GL state variables are updated immediately before drawing.\n\n        Return False to indicate that the visual should not be drawn.\n        \"\"\"\n        return True\n\n    def _prepare_transforms(self, view):\n        \"\"\"This method is called whenever the TransformSystem instance is\n        changed for a view.\n\n        Assign a view's transforms to the proper shader template variables\n        on the view's shader program.\n\n        Note that each view has its own TransformSystem. In this method we\n        connect the appropriate mapping functions from the view's\n        TransformSystem to the view's program.\n        \"\"\"\n        raise NotImplementedError()\n        # Todo: this method can be removed if we somehow enable the shader\n        # to specify exactly which transform functions it needs by name. For\n        # example:\n        #\n        #     // mapping function is automatically defined from the\n        #     // corresponding transform in the view's TransformSystem\n        #     gl_Position = visual_to_render(a_position);\n        #\n\n    @property\n    def shared_program(self):\n        return self._vshare.program\n\n    @property\n    def view_program(self):\n        return self._program\n\n    @property\n    def _draw_mode(self):\n        return self._vshare.draw_mode\n\n    @_draw_mode.setter\n    def _draw_mode(self, m):\n        self._vshare.draw_mode = m\n\n    @property\n    def _index_buffer(self):\n        return self._vshare.index_buffer\n\n    @_index_buffer.setter\n    def _index_buffer(self, buf):\n        self._vshare.index_buffer = buf\n\n    def draw(self):\n        if not self.visible:\n            return\n        if self._prepare_draw(view=self) is False:\n            return\n\n        if self._vshare.draw_mode is None:\n            raise ValueError(\"_draw_mode has not been set for visual %r\" %\n                             self)\n\n        self._configure_gl_state()\n        try:\n            self._program.draw(self._vshare.draw_mode,\n                               self._vshare.index_buffer)\n        except Exception:\n            logger.warning(\"Error drawing visual %r\" % self)\n            raise\n\n    def _configure_gl_state(self):\n        gloo.set_state(**self._vshare.gl_state)\n\n    def _get_hook(self, shader, name):\n        \"\"\"Return a FunctionChain that Filters may use to modify the program.\n\n        *shader* should be \"vert\", \"geom\", or \"frag\"\n        *name* should be \"pre\" or \"post\"\n        \"\"\"\n        assert name in ('pre', 'post')\n        key = (shader, name)\n        if key in self._hooks:\n            return self._hooks[key]\n        hook = StatementList()\n        if shader == 'vert':\n            self.view_program.vert[name] = hook\n        elif shader == 'frag':\n            self.view_program.frag[name] = hook\n        elif shader == 'geom':\n            self.view_program.geom[name] = hook\n        else:\n            raise ValueError(\"shader must be vert, geom, or frag\")\n        self._hooks[key] = hook\n        return hook\n\n    def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.append(filt)\n            for view in self._vshare.views.keys():\n                filt._attach(view)\n        else:\n            view._filters.append(filt)\n            filt._attach(view)\n\n    def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.remove(filt)\n            for view in self._vshare.views.keys():\n                filt._detach(view)\n        else:\n            view._filters.remove(filt)\n            filt._detach(view)",
  "class VisualView(BaseVisualView, Visual):\n    \"\"\"A view on another Visual instance.\n\n    View instances are created by calling ``visual.view()``.\n\n    Because this is a subclass of `Visual`, all instances of `VisualView`\n    define their own shader program (which is a clone of the viewed visual's\n    program), transforms, and filter attachments.\n    \"\"\"\n\n    def __init__(self, visual):\n        BaseVisualView.__init__(self, visual)\n        Visual.__init__(self, vshare=visual._vshare)\n\n        # Attach any shared filters\n        for filt in self._vshare.filters:\n            filt._attach(self)",
  "class CompoundVisual(BaseVisual):\n    \"\"\"Visual consisting entirely of sub-visuals.\n\n    To the user, a compound visual behaves exactly like a normal visual--it\n    has a transform system, draw() and bounds() methods, etc. Internally, the\n    compound visual automatically manages proxying these transforms and methods\n    to its sub-visuals. \n\n    Parameters\n    ----------\n    subvisuals : list of BaseVisual instances\n        The list of visuals to be combined in this compound visual.\n    \"\"\"\n\n    def __init__(self, subvisuals):\n        self._view_class = CompoundVisualView\n        self._subvisuals = []\n        BaseVisual.__init__(self)\n        for v in subvisuals:\n            self.add_subvisual(v)\n        self.freeze()\n\n    def add_subvisual(self, visual):\n        \"\"\"Add a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to add.\n        \"\"\"\n        visual.transforms = self.transforms\n        visual._prepare_transforms(visual)\n        self._subvisuals.append(visual)\n        visual.events.update.connect(self._subv_update)\n        self.update()\n\n    def remove_subvisual(self, visual):\n        \"\"\"Remove a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to remove.\n        \"\"\"\n        visual.events.update.disconnect(self._subv_update)\n        self._subvisuals.remove(visual)\n        self.update()\n\n    def _subv_update(self, event):\n        self.update()\n\n    def _transform_changed(self, event=None):\n        for v in self._subvisuals:\n            v.transforms = self.transforms\n        BaseVisual._transform_changed(self)\n\n    def draw(self):\n        \"\"\"Draw the visual\"\"\"\n        if not self.visible:\n            return\n        if self._prepare_draw(view=self) is False:\n            return\n\n        for v in self._subvisuals:\n            if v.visible:\n                v.draw()\n\n    def _prepare_draw(self, view):\n        pass\n\n    def _prepare_transforms(self, view):\n        for v in view._subvisuals:\n            v._prepare_transforms(v)\n\n    def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        for v in self._subvisuals:\n            v.set_gl_state(preset=preset, **kwargs)\n\n    def update_gl_state(self, *args, **kwargs):\n        \"\"\"Modify the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        for v in self._subvisuals:\n            v.update_gl_state(*args, **kwargs)\n\n    def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        for v in self._subvisuals:\n            v.attach(filt, v)\n\n    def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        for v in self._subvisuals:\n            v.detach(filt, v)\n\n    def _compute_bounds(self, axis, view):\n        bounds = None\n        for v in view._subvisuals:\n            if v.visible:\n                vb = v.bounds(axis)\n                if bounds is None:\n                    bounds = vb\n                elif vb is not None:\n                    bounds = [min(bounds[0], vb[0]), max(bounds[1], vb[1])]\n        return bounds",
  "class CompoundVisualView(BaseVisualView, CompoundVisual):\n    def __init__(self, visual):\n        BaseVisualView.__init__(self, visual)\n        # Create a view on each sub-visual\n        subv = [v.view() for v in visual._subvisuals]\n        CompoundVisual.__init__(self, subv)\n\n        # Attach any shared filters\n        for filt in self._vshare.filters:\n            for v in self._subvisuals:\n                filt._attach(v)",
  "class updating_property:\n    \"\"\"A property descriptor that autoupdates the Visual during attribute setting.\n\n    Use this as a decorator in place of the @property when you want the attribute to trigger\n    an immediate update to the visual upon change.  You may additionally declare an @setter,\n    and if you do, it will be called in addition to the standard logic:\n    `self._attr_name = value`.\n\n    For example, the following code examples are equivalent::\n\n        class SomeVisual1(Visual):\n            def __init__(self, someprop=None):\n                self._someprop = someprop\n\n            @property\n            def someprop(self):\n                return self._someprop\n\n            @someprop.setter\n            def someprop(self, value):\n                previous = self._someprop\n                if (previous is None) or np.any(value != previous):\n                    self._someprop = value\n                    self._need_update = True\n                    if hasattr(self, 'events'):\n                        self.update()\n\n        class SomeVisual2(Visual):\n            def __init__(self, someprop=None):\n                self._someprop = someprop\n\n            @updating_property\n            def someprop(self):\n                pass\n\n    NOTE: by default the __get__ method here will look for the conventional `_attr_name`\n    property on the object.  The result of this is that you don't actually have to put\n    anything in the body of a method decorated with @updating_property if you don't want to\n    do anything other than retrieve the property.  So you may see this slightly strange\n    pattern being used::\n\n        class SomeVisual2(Visual):\n            def __init__(self, someprop=None):\n                self._someprop = someprop\n\n            @updating_property\n            def someprop(self):\n                '''the docstring (or pass) is all that is needed'''\n\n    \"\"\"\n\n    def __init__(self, fget=None, fset=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        if self.fget is not None:\n            self.attr_name = f'_{self.fget.__name__}'\n            self.__doc__ = doc or self.fget.__doc__\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        # if the @updating_property getter returns a value, use that\n        val = self.fget(obj)\n        if val is not None:\n            return val\n        # otherwise get the private attribute by the same name\n        return getattr(obj, self.attr_name, None)\n\n    def __set__(self, obj, value):\n        previous = getattr(obj, self.attr_name, None)\n        if (previous is None) or np.any(value != previous):\n            setattr(obj, self.attr_name, value)\n            # if a @.setter method has been declared, run that as well\n            # (overriding the standard setter behavior)\n            if self.fset is not None:\n                self.fset(obj, value)\n            obj._need_update = True\n            # prevent update during obj.__init__\n            if hasattr(obj, 'events'):\n                obj.update()\n\n    def __delete__(self, obj):\n        raise AttributeError(\"can't delete attribute\")\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.__doc__)",
  "def __init__(self):\n        # Note: in some cases we will need to compute bounds independently for\n        # each view. That will have to be worked out later..\n        self.bounds = {}\n        self.gl_state = {}\n        self.views = weakref.WeakKeyDictionary()\n        self.filters = []\n        self.visible = True",
  "def __init__(self, vshare=None):\n        self._view_class = getattr(self, '_view_class', VisualView)\n\n        self._vshare = VisualShare() if vshare is None else vshare\n        self._vshare.views[self] = None\n\n        self.events = EmitterGroup(source=self,\n                                   auto_connect=True,\n                                   update=Event,\n                                   bounds_change=Event\n                                   )\n\n        self._transforms = None\n        self.transforms = TransformSystem()",
  "def transform(self):\n        return self.transforms.visual_transform.transforms[0]",
  "def transform(self, tr):\n        self.transforms.visual_transform = tr",
  "def transforms(self):\n        return self._transforms",
  "def transforms(self, trs):\n        if trs is self._transforms:\n            return\n        if self._transforms is not None:\n            self._transforms.changed.disconnect(self._transform_changed)\n        self._transforms = trs\n        trs.changed.connect(self._transform_changed)\n        self._transform_changed()",
  "def get_transform(self, map_from='visual', map_to='render'):\n        \"\"\"Return a transform mapping between any two coordinate systems.\n\n        Parameters\n        ----------\n        map_from : str\n            The starting coordinate system to map from. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        map_to : str\n            The ending coordinate system to map to. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        \"\"\"\n        return self.transforms.get_transform(map_from, map_to)",
  "def visible(self):\n        return self._vshare.visible",
  "def visible(self, v):\n        if v != self._vshare.visible:\n            self._vshare.visible = v\n            self.update()",
  "def view(self):\n        \"\"\"Return a new view of this visual.\"\"\"\n        return self._view_class(self)",
  "def draw(self):\n        raise NotImplementedError(self)",
  "def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual.\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        raise NotImplementedError(self)",
  "def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        raise NotImplementedError(self)",
  "def bounds(self, axis, view=None):\n        \"\"\"Get the bounds of the Visual\n\n        Parameters\n        ----------\n        axis : int\n            The axis.\n        view : instance of VisualView\n            The view to use.\n        \"\"\"\n        if view is None:\n            view = self\n        if axis not in self._vshare.bounds:\n            self._vshare.bounds[axis] = self._compute_bounds(axis, view)\n        return self._vshare.bounds[axis]",
  "def _compute_bounds(self, axis, view):\n        raise NotImplementedError(self)",
  "def _bounds_changed(self):\n        self._vshare.bounds.clear()",
  "def update(self):\n        \"\"\"Update the Visual\"\"\"\n        self.events.update()",
  "def _transform_changed(self, event=None):\n        self.update()",
  "def __init__(self, visual):\n        self._visual = visual",
  "def visual(self):\n        return self._visual",
  "def _prepare_draw(self, view=None):\n        self._visual._prepare_draw(view=view)",
  "def _prepare_transforms(self, view):\n        self._visual._prepare_transforms(view)",
  "def _compute_bounds(self, axis, view):\n        self._visual._compute_bounds(axis, view)",
  "def __repr__(self):\n        return '<%s on %r>' % (self.__class__.__name__, self._visual)",
  "def __init__(self, vcode='', fcode='', gcode=None, program=None,\n                 vshare=None):\n        self._view_class = VisualView\n        BaseVisual.__init__(self, vshare)\n        if vshare is None:\n            self._vshare.draw_mode = None\n            self._vshare.index_buffer = None\n            if program is None:\n                self._vshare.program = MultiProgram(vcode, fcode, gcode)\n            else:\n                self._vshare.program = program\n                if len(vcode) > 0 or len(fcode) > 0:\n                    raise ValueError(\"Cannot specify both program and \"\n                                     \"vcode/fcode arguments.\")\n\n        self._program = self._vshare.program.add_program()\n        self._prepare_transforms(self)\n        self._filters = []\n        self._hooks = {}",
  "def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        self._vshare.gl_state = kwargs\n        self._vshare.gl_state['preset'] = preset",
  "def update_gl_state(self, *args, **kwargs):\n        \"\"\"Modify the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        if len(args) == 1:\n            self._vshare.gl_state['preset'] = args[0]\n        elif len(args) != 0:\n            raise TypeError(\"Only one positional argument allowed.\")\n        self._vshare.gl_state.update(kwargs)",
  "def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        return None",
  "def _prepare_draw(self, view=None):\n        \"\"\"This visual is about to be drawn.\n\n        Visuals should implement this method to ensure that all program\n        and GL state variables are updated immediately before drawing.\n\n        Return False to indicate that the visual should not be drawn.\n        \"\"\"\n        return True",
  "def _prepare_transforms(self, view):\n        \"\"\"This method is called whenever the TransformSystem instance is\n        changed for a view.\n\n        Assign a view's transforms to the proper shader template variables\n        on the view's shader program.\n\n        Note that each view has its own TransformSystem. In this method we\n        connect the appropriate mapping functions from the view's\n        TransformSystem to the view's program.\n        \"\"\"\n        raise NotImplementedError()",
  "def shared_program(self):\n        return self._vshare.program",
  "def view_program(self):\n        return self._program",
  "def _draw_mode(self):\n        return self._vshare.draw_mode",
  "def _draw_mode(self, m):\n        self._vshare.draw_mode = m",
  "def _index_buffer(self):\n        return self._vshare.index_buffer",
  "def _index_buffer(self, buf):\n        self._vshare.index_buffer = buf",
  "def draw(self):\n        if not self.visible:\n            return\n        if self._prepare_draw(view=self) is False:\n            return\n\n        if self._vshare.draw_mode is None:\n            raise ValueError(\"_draw_mode has not been set for visual %r\" %\n                             self)\n\n        self._configure_gl_state()\n        try:\n            self._program.draw(self._vshare.draw_mode,\n                               self._vshare.index_buffer)\n        except Exception:\n            logger.warning(\"Error drawing visual %r\" % self)\n            raise",
  "def _configure_gl_state(self):\n        gloo.set_state(**self._vshare.gl_state)",
  "def _get_hook(self, shader, name):\n        \"\"\"Return a FunctionChain that Filters may use to modify the program.\n\n        *shader* should be \"vert\", \"geom\", or \"frag\"\n        *name* should be \"pre\" or \"post\"\n        \"\"\"\n        assert name in ('pre', 'post')\n        key = (shader, name)\n        if key in self._hooks:\n            return self._hooks[key]\n        hook = StatementList()\n        if shader == 'vert':\n            self.view_program.vert[name] = hook\n        elif shader == 'frag':\n            self.view_program.frag[name] = hook\n        elif shader == 'geom':\n            self.view_program.geom[name] = hook\n        else:\n            raise ValueError(\"shader must be vert, geom, or frag\")\n        self._hooks[key] = hook\n        return hook",
  "def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.append(filt)\n            for view in self._vshare.views.keys():\n                filt._attach(view)\n        else:\n            view._filters.append(filt)\n            filt._attach(view)",
  "def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.remove(filt)\n            for view in self._vshare.views.keys():\n                filt._detach(view)\n        else:\n            view._filters.remove(filt)\n            filt._detach(view)",
  "def __init__(self, visual):\n        BaseVisualView.__init__(self, visual)\n        Visual.__init__(self, vshare=visual._vshare)\n\n        # Attach any shared filters\n        for filt in self._vshare.filters:\n            filt._attach(self)",
  "def __init__(self, subvisuals):\n        self._view_class = CompoundVisualView\n        self._subvisuals = []\n        BaseVisual.__init__(self)\n        for v in subvisuals:\n            self.add_subvisual(v)\n        self.freeze()",
  "def add_subvisual(self, visual):\n        \"\"\"Add a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to add.\n        \"\"\"\n        visual.transforms = self.transforms\n        visual._prepare_transforms(visual)\n        self._subvisuals.append(visual)\n        visual.events.update.connect(self._subv_update)\n        self.update()",
  "def remove_subvisual(self, visual):\n        \"\"\"Remove a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to remove.\n        \"\"\"\n        visual.events.update.disconnect(self._subv_update)\n        self._subvisuals.remove(visual)\n        self.update()",
  "def _subv_update(self, event):\n        self.update()",
  "def _transform_changed(self, event=None):\n        for v in self._subvisuals:\n            v.transforms = self.transforms\n        BaseVisual._transform_changed(self)",
  "def draw(self):\n        \"\"\"Draw the visual\"\"\"\n        if not self.visible:\n            return\n        if self._prepare_draw(view=self) is False:\n            return\n\n        for v in self._subvisuals:\n            if v.visible:\n                v.draw()",
  "def _prepare_draw(self, view):\n        pass",
  "def _prepare_transforms(self, view):\n        for v in view._subvisuals:\n            v._prepare_transforms(v)",
  "def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        for v in self._subvisuals:\n            v.set_gl_state(preset=preset, **kwargs)",
  "def update_gl_state(self, *args, **kwargs):\n        \"\"\"Modify the set of GL state parameters to use when drawing.\n\n        The arguments are forwarded to :func:`vispy.gloo.wrappers.set_state`.\n\n        Parameters\n        ----------\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n        \"\"\"\n        for v in self._subvisuals:\n            v.update_gl_state(*args, **kwargs)",
  "def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        for v in self._subvisuals:\n            v.attach(filt, v)",
  "def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        for v in self._subvisuals:\n            v.detach(filt, v)",
  "def _compute_bounds(self, axis, view):\n        bounds = None\n        for v in view._subvisuals:\n            if v.visible:\n                vb = v.bounds(axis)\n                if bounds is None:\n                    bounds = vb\n                elif vb is not None:\n                    bounds = [min(bounds[0], vb[0]), max(bounds[1], vb[1])]\n        return bounds",
  "def __init__(self, visual):\n        BaseVisualView.__init__(self, visual)\n        # Create a view on each sub-visual\n        subv = [v.view() for v in visual._subvisuals]\n        CompoundVisual.__init__(self, subv)\n\n        # Attach any shared filters\n        for filt in self._vshare.filters:\n            for v in self._subvisuals:\n                filt._attach(v)",
  "def __init__(self, fget=None, fset=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        if self.fget is not None:\n            self.attr_name = f'_{self.fget.__name__}'\n            self.__doc__ = doc or self.fget.__doc__",
  "def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        # if the @updating_property getter returns a value, use that\n        val = self.fget(obj)\n        if val is not None:\n            return val\n        # otherwise get the private attribute by the same name\n        return getattr(obj, self.attr_name, None)",
  "def __set__(self, obj, value):\n        previous = getattr(obj, self.attr_name, None)\n        if (previous is None) or np.any(value != previous):\n            setattr(obj, self.attr_name, value)\n            # if a @.setter method has been declared, run that as well\n            # (overriding the standard setter behavior)\n            if self.fset is not None:\n                self.fset(obj, value)\n            obj._need_update = True\n            # prevent update during obj.__init__\n            if hasattr(obj, 'events'):\n                obj.update()",
  "def __delete__(self, obj):\n        raise AttributeError(\"can't delete attribute\")",
  "def setter(self, fset):\n        return type(self)(self.fget, fset, self.__doc__)",
  "class RectangleVisual(PolygonVisual):\n    \"\"\"\n    Displays a 2D rectangle with optional rounded corners\n\n    Parameters\n    ----------\n    center :  array\n        Center of the rectangle\n    color : instance of Color\n        The fill color to use.\n    border_color : instance of Color\n        The border color to use.\n    border_width : int\n        Border width in pixels.\n        Line widths > 1px are only\n        guaranteed to work when using `border_method='agg'` method.\n    height : float\n        Length of the rectangle along y-axis\n        Defaults to 1.0\n    width : float\n        Length of the rectangle along x-axis\n        Defaults to 1.0\n    radius : float | array\n        Radii of curvatures of corners in clockwise order from top-left\n        Defaults to 0.\n    **kwargs : dict\n        Keyword arguments to pass to `PolygonVisual`.\n    \"\"\"\n\n    def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, height=1.0, width=1.0,\n                 radius=[0., 0., 0., 0.], **kwargs):\n\n        self._height = height\n        self._width = width\n        self._color = Color(color)\n        self._border_color = Color(border_color)\n        self._border_width = border_width\n        self._radius = radius\n        self._center = center\n\n        # triangulation can be very slow\n        kwargs.setdefault('triangulate', False)\n        PolygonVisual.__init__(self, pos=None, color=color,\n                               border_color=border_color,\n                               border_width=border_width, **kwargs)\n\n        self._mesh.mode = 'triangle_fan'\n        self._regen_pos()\n        self._update()\n\n    @staticmethod\n    def _generate_vertices(center, radius, height, width):\n        half_height = height / 2.\n        half_width = width / 2.\n        hw = min(half_height, half_width)\n\n        if isinstance(radius, (list, tuple)):\n            if len(radius) != 4:\n                raise ValueError(\"radius must be float or 4 value tuple/list\"\n                                 \" (got %s of length %d)\" % (type(radius),\n                                                             len(radius)))\n\n            if (radius > np.ones(4) * hw).all():\n                raise ValueError('Radius of curvature cannot be greater than\\\n                                  half of min(width, height)')\n            radius = np.array(radius, dtype=np.float32)\n\n        else:\n            if radius > hw:\n                raise ValueError('Radius of curvature cannot be greater than\\\n                                  half of min(width, height)')\n            radius = np.ones(4) * radius\n\n        num_segments = (radius / hw * 500.).astype(int)\n\n        bias1 = np.ones(4) * half_width - radius\n        bias2 = np.ones(4) * half_height - radius\n\n        corner1 = np.empty([num_segments[0]+1, 3], dtype=np.float32)\n        corner2 = np.empty([num_segments[1]+1, 3], dtype=np.float32)\n        corner3 = np.empty([num_segments[2]+1, 3], dtype=np.float32)\n        corner4 = np.empty([num_segments[3]+1, 3], dtype=np.float32)\n\n        start_angle = 0.\n        end_angle = np.pi / 2.\n\n        theta = np.linspace(end_angle, start_angle, num_segments[0]+1)\n\n        corner1[:, 0] = center[0] - bias1[0] - radius[0] * np.sin(theta)\n        corner1[:, 1] = center[1] - bias2[0] - radius[0] * np.cos(theta)\n        corner1[:, 2] = 0\n\n        theta = np.linspace(start_angle, end_angle, num_segments[1]+1)\n\n        corner2[:, 0] = center[0] + bias1[1] + radius[1] * np.sin(theta)\n        corner2[:, 1] = center[1] - bias2[1] - radius[1] * np.cos(theta)\n        corner2[:, 2] = 0\n\n        theta = np.linspace(end_angle, start_angle, num_segments[2]+1)\n\n        corner3[:, 0] = center[0] + bias1[2] + radius[2] * np.sin(theta)\n        corner3[:, 1] = center[1] + bias2[2] + radius[2] * np.cos(theta)\n        corner3[:, 2] = 0\n\n        theta = np.linspace(start_angle, end_angle, num_segments[3]+1)\n\n        corner4[:, 0] = center[0] - bias1[3] - radius[3] * np.sin(theta)\n        corner4[:, 1] = center[1] + bias2[3] + radius[3] * np.cos(theta)\n        corner4[:, 2] = 0\n\n        output = np.concatenate(([[center[0], center[1], 0.]],\n                                 [[center[0] - half_width, center[1], 0.]],\n                                 corner1,\n                                 [[center[0], center[1] - half_height, 0.]],\n                                 corner2,\n                                 [[center[0] + half_width, center[1], 0.]],\n                                 corner3,\n                                 [[center[0], center[1] + half_height, 0.]],\n                                 corner4,\n                                 [[center[0] - half_width, center[1], 0.]]))\n\n        vertices = np.array(output, dtype=np.float32)\n        return vertices\n\n    @property\n    def center(self):\n        \"\"\"The center of the ellipse\"\"\"\n        return self._center\n\n    @center.setter\n    def center(self, center):\n        \"\"\"The center of the ellipse\"\"\"\n        self._center = center\n        self._regen_pos()\n        self._update()\n\n    @property\n    def height(self):\n        \"\"\"The height of the rectangle.\"\"\"\n        return self._height\n\n    @height.setter\n    def height(self, height):\n        if height <= 0.:\n            raise ValueError('Height must be positive')\n        self._height = height\n        self._regen_pos()\n        self._update()\n\n    @property\n    def width(self):\n        \"\"\"The width of the rectangle.\"\"\"\n        return self._width\n\n    @width.setter\n    def width(self, width):\n        if width <= 0.:\n            raise ValueError('Width must be positive')\n        self._width = width\n        self._regen_pos()\n        self._update()\n\n    @property\n    def radius(self):\n        \"\"\"The radius of curvature of rounded corners.\"\"\"\n        return self._radius\n\n    @radius.setter\n    def radius(self, radius):\n        self._radius = radius\n        self._regen_pos()\n        self._update()\n\n    def _regen_pos(self):\n        vertices = self._generate_vertices(center=self._center,\n                                           radius=self._radius,\n                                           height=self._height,\n                                           width=self._width)\n        # don't use the center point and only use X/Y coordinates\n        vertices = vertices[1:, ..., :2]\n        self._pos = vertices",
  "def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, height=1.0, width=1.0,\n                 radius=[0., 0., 0., 0.], **kwargs):\n\n        self._height = height\n        self._width = width\n        self._color = Color(color)\n        self._border_color = Color(border_color)\n        self._border_width = border_width\n        self._radius = radius\n        self._center = center\n\n        # triangulation can be very slow\n        kwargs.setdefault('triangulate', False)\n        PolygonVisual.__init__(self, pos=None, color=color,\n                               border_color=border_color,\n                               border_width=border_width, **kwargs)\n\n        self._mesh.mode = 'triangle_fan'\n        self._regen_pos()\n        self._update()",
  "def _generate_vertices(center, radius, height, width):\n        half_height = height / 2.\n        half_width = width / 2.\n        hw = min(half_height, half_width)\n\n        if isinstance(radius, (list, tuple)):\n            if len(radius) != 4:\n                raise ValueError(\"radius must be float or 4 value tuple/list\"\n                                 \" (got %s of length %d)\" % (type(radius),\n                                                             len(radius)))\n\n            if (radius > np.ones(4) * hw).all():\n                raise ValueError('Radius of curvature cannot be greater than\\\n                                  half of min(width, height)')\n            radius = np.array(radius, dtype=np.float32)\n\n        else:\n            if radius > hw:\n                raise ValueError('Radius of curvature cannot be greater than\\\n                                  half of min(width, height)')\n            radius = np.ones(4) * radius\n\n        num_segments = (radius / hw * 500.).astype(int)\n\n        bias1 = np.ones(4) * half_width - radius\n        bias2 = np.ones(4) * half_height - radius\n\n        corner1 = np.empty([num_segments[0]+1, 3], dtype=np.float32)\n        corner2 = np.empty([num_segments[1]+1, 3], dtype=np.float32)\n        corner3 = np.empty([num_segments[2]+1, 3], dtype=np.float32)\n        corner4 = np.empty([num_segments[3]+1, 3], dtype=np.float32)\n\n        start_angle = 0.\n        end_angle = np.pi / 2.\n\n        theta = np.linspace(end_angle, start_angle, num_segments[0]+1)\n\n        corner1[:, 0] = center[0] - bias1[0] - radius[0] * np.sin(theta)\n        corner1[:, 1] = center[1] - bias2[0] - radius[0] * np.cos(theta)\n        corner1[:, 2] = 0\n\n        theta = np.linspace(start_angle, end_angle, num_segments[1]+1)\n\n        corner2[:, 0] = center[0] + bias1[1] + radius[1] * np.sin(theta)\n        corner2[:, 1] = center[1] - bias2[1] - radius[1] * np.cos(theta)\n        corner2[:, 2] = 0\n\n        theta = np.linspace(end_angle, start_angle, num_segments[2]+1)\n\n        corner3[:, 0] = center[0] + bias1[2] + radius[2] * np.sin(theta)\n        corner3[:, 1] = center[1] + bias2[2] + radius[2] * np.cos(theta)\n        corner3[:, 2] = 0\n\n        theta = np.linspace(start_angle, end_angle, num_segments[3]+1)\n\n        corner4[:, 0] = center[0] - bias1[3] - radius[3] * np.sin(theta)\n        corner4[:, 1] = center[1] + bias2[3] + radius[3] * np.cos(theta)\n        corner4[:, 2] = 0\n\n        output = np.concatenate(([[center[0], center[1], 0.]],\n                                 [[center[0] - half_width, center[1], 0.]],\n                                 corner1,\n                                 [[center[0], center[1] - half_height, 0.]],\n                                 corner2,\n                                 [[center[0] + half_width, center[1], 0.]],\n                                 corner3,\n                                 [[center[0], center[1] + half_height, 0.]],\n                                 corner4,\n                                 [[center[0] - half_width, center[1], 0.]]))\n\n        vertices = np.array(output, dtype=np.float32)\n        return vertices",
  "def center(self):\n        \"\"\"The center of the ellipse\"\"\"\n        return self._center",
  "def center(self, center):\n        \"\"\"The center of the ellipse\"\"\"\n        self._center = center\n        self._regen_pos()\n        self._update()",
  "def height(self):\n        \"\"\"The height of the rectangle.\"\"\"\n        return self._height",
  "def height(self, height):\n        if height <= 0.:\n            raise ValueError('Height must be positive')\n        self._height = height\n        self._regen_pos()\n        self._update()",
  "def width(self):\n        \"\"\"The width of the rectangle.\"\"\"\n        return self._width",
  "def width(self, width):\n        if width <= 0.:\n            raise ValueError('Width must be positive')\n        self._width = width\n        self._regen_pos()\n        self._update()",
  "def radius(self):\n        \"\"\"The radius of curvature of rounded corners.\"\"\"\n        return self._radius",
  "def radius(self, radius):\n        self._radius = radius\n        self._regen_pos()\n        self._update()",
  "def _regen_pos(self):\n        vertices = self._generate_vertices(center=self._center,\n                                           radius=self._radius,\n                                           height=self._height,\n                                           width=self._width)\n        # don't use the center point and only use X/Y coordinates\n        vertices = vertices[1:, ..., :2]\n        self._pos = vertices",
  "class PlaneVisual(CompoundVisual):\n    \"\"\"Visual that displays a plane.\n\n    Parameters\n    ----------\n    width : float\n        Plane width.\n    height : float\n        Plane height.\n    width_segments : int\n        Plane segments count along the width.\n    height_segments : float\n        Plane segments count along the height.\n    direction: unicode\n        ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Direction the plane will be facing.\n    vertex_colors : ndarray\n        Same as for `MeshVisual` class. See `create_plane` for vertex ordering.\n    face_colors : ndarray\n        Same as for `MeshVisual` class. See `create_plane` for vertex ordering.\n    color : Color\n        The `Color` to use when drawing the cube faces.\n    edge_color : tuple or Color\n        The `Color` to use when drawing the cube edges. If `None`, then no\n        cube edges are drawn.\n    \"\"\"\n\n    def __init__(self, width=1, height=1, width_segments=1, height_segments=1,\n                 direction='+z', vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None):\n        vertices, filled_indices, outline_indices = create_plane(\n            width, height, width_segments, height_segments, direction)\n\n        self._mesh = MeshVisual(vertices['position'], filled_indices,\n                                vertex_colors, face_colors, color)\n        self._mesh.update_gl_state(polygon_offset=(1, 1),\n                                   polygon_offset_fill=True)\n        self._outline = None\n        CompoundVisual.__init__(self, [self._mesh])\n        if edge_color:\n            self._outline = MeshVisual(vertices['position'], outline_indices,\n                                       color=edge_color, mode='lines')\n            self.add_subvisual(self._outline)",
  "def __init__(self, width=1, height=1, width_segments=1, height_segments=1,\n                 direction='+z', vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None):\n        vertices, filled_indices, outline_indices = create_plane(\n            width, height, width_segments, height_segments, direction)\n\n        self._mesh = MeshVisual(vertices['position'], filled_indices,\n                                vertex_colors, face_colors, color)\n        self._mesh.update_gl_state(polygon_offset=(1, 1),\n                                   polygon_offset_fill=True)\n        self._outline = None\n        CompoundVisual.__init__(self, [self._mesh])\n        if edge_color:\n            self._outline = MeshVisual(vertices['position'], outline_indices,\n                                       color=edge_color, mode='lines')\n            self.add_subvisual(self._outline)",
  "class LinePlotVisual(CompoundVisual):\n    \"\"\"Visual displaying a plot line with optional markers.\n\n    Parameters\n    ----------\n    data : array-like\n        Arguments can be passed as ``(Y,)``, ``(X, Y)``, ``(X, Y, Z)`` or\n        ``np.array((X, Y))``, ``np.array((X, Y, Z))``.\n    color : instance of Color\n        Color of the line.\n    symbol : str\n        Marker symbol to use.\n    line_kind : str\n        Kind of line to draw. For now, only solid lines (``'-'``)\n        are supported.\n    width : float\n        Line width.\n    marker_size : float\n        Marker size. If `size == 0` markers will not be shown.\n    edge_color : instance of Color\n        Color of the marker edge.\n    face_color : instance of Color\n        Color of the marker face.\n    edge_width : float\n        Edge width of the marker.\n    connect : str | array\n        See LineVisual.\n    **kwargs : keyword arguments\n        Argements to pass to the super class.\n\n    Examples\n    --------\n    All of these syntaxes will work:\n\n        >>> LinePlotVisual(y_vals)\n        >>> LinePlotVisual(x_vals, y_vals)\n        >>> LinePlotVisual(xy_vals)\n\n    See also\n    --------\n    LineVisual, MarkersVisual\n    \"\"\"\n\n    _line_kwargs = ('color', 'width', 'connect')\n    _marker_kwargs = ('edge_color', 'face_color', 'edge_width',\n                      'marker_size', 'symbol')\n    _valid_kwargs = set(_line_kwargs).union(set(_marker_kwargs))\n    _kw_trans = dict(marker_size='size')\n\n    def __init__(self, data=None, color='k', symbol=None, line_kind='-',\n                 width=1., marker_size=10., edge_color='k', face_color='w',\n                 edge_width=1., connect='strip'):\n        if line_kind != '-':\n            raise ValueError('Only solid lines currently supported')\n        self._line = LineVisual(method='gl', antialias=False)\n        self._markers = MarkersVisual()\n        self._kwargs = {}\n        CompoundVisual.__init__(self, [self._line, self._markers])\n        self.set_data(data, color=color, symbol=symbol,\n                      width=width, marker_size=marker_size,\n                      edge_color=edge_color, face_color=face_color,\n                      edge_width=edge_width, connect=connect)\n\n    def set_data(self, data=None, **kwargs):\n        \"\"\"Set the line data\n\n        Parameters\n        ----------\n        data : array-like\n            The data.\n        **kwargs : dict\n            Keywoard arguments to pass to MarkerVisual and LineVisal.\n        \"\"\"\n        bad_keys = set(kwargs) - self._valid_kwargs\n        if bad_keys:\n            raise TypeError(\"Invalid keyword arguments: {}\".format(\", \".join(bad_keys)))\n\n        # remember these kwargs for future updates\n        self._kwargs.update(kwargs)\n        if data is None:\n            pos = None\n        else:\n            if isinstance(data, tuple):\n                pos = np.array(data).T.astype(np.float32)\n            else:\n                pos = np.atleast_1d(data).astype(np.float32)\n\n            if pos.ndim == 1:\n                pos = pos[:, np.newaxis]\n            elif pos.ndim > 2:\n                raise ValueError('data must have at most two dimensions')\n\n            if pos.size == 0:\n                pos = self._line.pos\n\n                # if both args and keywords are zero, then there is no\n                # point in calling this function.\n                if len(self._kwargs) == 0:\n                    raise TypeError(\"neither line points nor line properties\"\n                                    \"are provided\")\n            elif pos.shape[1] == 1:\n                x = np.arange(pos.shape[0], dtype=np.float32)[:, np.newaxis]\n                pos = np.concatenate((x, pos), axis=1)\n            # if args are empty, don't modify position\n            elif pos.shape[1] > 3:\n                raise TypeError(\"Too many coordinates given (%s; max is 3).\"\n                                % pos.shape[1])\n\n        # todo: have both sub-visuals share the same buffers.\n        line_kwargs = {}\n        for k in self._line_kwargs:\n            if k in self._kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                line_kwargs[k] = self._kwargs.get(k_)\n        if pos is not None or len(line_kwargs) > 0:\n            self._line.set_data(pos=pos, **line_kwargs)\n\n        marker_kwargs = {}\n        for k in self._marker_kwargs:\n            if k in self._kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                marker_kwargs[k_] = self._kwargs.get(k)\n        if pos is not None or len(marker_kwargs) > 0:\n            self._markers.set_data(pos=pos, **marker_kwargs)",
  "def __init__(self, data=None, color='k', symbol=None, line_kind='-',\n                 width=1., marker_size=10., edge_color='k', face_color='w',\n                 edge_width=1., connect='strip'):\n        if line_kind != '-':\n            raise ValueError('Only solid lines currently supported')\n        self._line = LineVisual(method='gl', antialias=False)\n        self._markers = MarkersVisual()\n        self._kwargs = {}\n        CompoundVisual.__init__(self, [self._line, self._markers])\n        self.set_data(data, color=color, symbol=symbol,\n                      width=width, marker_size=marker_size,\n                      edge_color=edge_color, face_color=face_color,\n                      edge_width=edge_width, connect=connect)",
  "def set_data(self, data=None, **kwargs):\n        \"\"\"Set the line data\n\n        Parameters\n        ----------\n        data : array-like\n            The data.\n        **kwargs : dict\n            Keywoard arguments to pass to MarkerVisual and LineVisal.\n        \"\"\"\n        bad_keys = set(kwargs) - self._valid_kwargs\n        if bad_keys:\n            raise TypeError(\"Invalid keyword arguments: {}\".format(\", \".join(bad_keys)))\n\n        # remember these kwargs for future updates\n        self._kwargs.update(kwargs)\n        if data is None:\n            pos = None\n        else:\n            if isinstance(data, tuple):\n                pos = np.array(data).T.astype(np.float32)\n            else:\n                pos = np.atleast_1d(data).astype(np.float32)\n\n            if pos.ndim == 1:\n                pos = pos[:, np.newaxis]\n            elif pos.ndim > 2:\n                raise ValueError('data must have at most two dimensions')\n\n            if pos.size == 0:\n                pos = self._line.pos\n\n                # if both args and keywords are zero, then there is no\n                # point in calling this function.\n                if len(self._kwargs) == 0:\n                    raise TypeError(\"neither line points nor line properties\"\n                                    \"are provided\")\n            elif pos.shape[1] == 1:\n                x = np.arange(pos.shape[0], dtype=np.float32)[:, np.newaxis]\n                pos = np.concatenate((x, pos), axis=1)\n            # if args are empty, don't modify position\n            elif pos.shape[1] > 3:\n                raise TypeError(\"Too many coordinates given (%s; max is 3).\"\n                                % pos.shape[1])\n\n        # todo: have both sub-visuals share the same buffers.\n        line_kwargs = {}\n        for k in self._line_kwargs:\n            if k in self._kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                line_kwargs[k] = self._kwargs.get(k_)\n        if pos is not None or len(line_kwargs) > 0:\n            self._line.set_data(pos=pos, **line_kwargs)\n\n        marker_kwargs = {}\n        for k in self._marker_kwargs:\n            if k in self._kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                marker_kwargs[k_] = self._kwargs.get(k)\n        if pos is not None or len(marker_kwargs) > 0:\n            self._markers.set_data(pos=pos, **marker_kwargs)",
  "class LinearRegionVisual(Visual):\n    \"\"\"Infinite horizontal or vertical region for 2D plots.\n\n    Parameters\n    ----------\n    pos : list, tuple or numpy array\n        Bounds of the region along the axis. len(pos) must be >=2.\n    color : list, tuple, or array\n        The color to use when drawing the line. It must have a shape of\n        (1, 4) for a single color region or (len(pos), 4) for a multicolor\n        region.\n    vertical:\n        True for drawing a vertical region, False for an horizontal region\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, pos=None, color=[1.0, 1.0, 1.0, 1.0],\n                 vertical=True, **kwargs):\n        \"\"\"\n\n        \"\"\"\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        self._changed = {'pos': False, 'color': False}\n\n        self.pos_buf = gloo.VertexBuffer()\n        self.color_buf = gloo.VertexBuffer()\n        # The Visual superclass contains a MultiProgram, which is an object\n        # that behaves like a normal shader program (you can assign shader\n        # code, upload values, set template variables, etc.) but internally\n        # manages multiple ModularProgram instances, one per view.\n\n        # The MultiProgram is accessed via the `shared_program` property, so\n        # the following modifications to the program will be applied to all\n        # views:\n        self.shared_program['a_pos'] = self.pos_buf\n        self._program.vert['is_vertical'] = 1 if vertical else 0\n\n        self._need_upload = False\n        self._is_vertical = bool(vertical)\n        self._pos = np.zeros((4, 2), dtype=np.float32)\n        self._color = np.ones((1, 4), dtype=np.float32)\n\n        # Visual keeps track of draw mode, index buffer, and GL state. These\n        # are shared between all views.\n        self._draw_mode = 'triangle_strip'\n        self.set_gl_state('translucent', depth_test=False)\n\n        self.set_data(pos=pos, color=color)\n\n    def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : list, tuple or numpy array\n            Bounds of the region along the axis. len(pos) must be >=2.\n        color : list, tuple, or array\n            The color to use when drawing the line. It must have a shape of\n            (1, 4) for a single color region or (len(pos), 4) for a multicolor\n            region.\n        \"\"\"\n        new_pos = self._pos\n        new_color = self._color\n\n        if pos is not None:\n            num_elements = len(pos)\n            pos = np.array(pos, dtype=np.float32)\n            if pos.ndim != 1:\n                raise ValueError('Expected 1D array')\n            vertex = np.empty((num_elements * 2, 2), dtype=np.float32)\n            if self._is_vertical:\n                vertex[:, 0] = np.repeat(pos, 2)\n                vertex[:, 1] = np.tile([-1, 1], num_elements)\n            else:\n                vertex[:, 1] = np.repeat(pos, 2)\n                vertex[:, 0] = np.tile([1, -1], num_elements)\n            new_pos = vertex\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            num_elements = new_pos.shape[0] / 2\n            if color.ndim == 2:\n                if color.shape[0] != num_elements:\n                    raise ValueError('Expected a color for each pos')\n                if color.shape[1] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat(color, 2, axis=0).astype(np.float32)\n            elif color.ndim == 1:\n                if color.shape[0] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat([color], new_pos.shape[0], axis=0)\n                color = color.astype(np.float32)\n            else:\n                raise ValueError('Expected a numpy array of shape '\n                                 '(%d, 4) or (1, 4)' % num_elements)\n            new_color = color\n            self._changed['color'] = True\n\n        # Ensure pos and color have the same size\n        if new_pos.shape[0] != new_color.shape[0]:\n            raise ValueError('pos and color does must have the same size')\n\n        self._color = new_color\n        self._pos = new_pos\n\n    @property\n    def color(self):\n        return self._color[::2]\n\n    @property\n    def pos(self):\n        if self._is_vertical:\n            return self._pos[:, 0].ravel()[::2]\n        else:\n            return self._pos[:, 1].ravel()[::2]\n\n    def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        is_vertical = self._is_vertical\n        pos = self._pos\n        if axis == 0 and is_vertical:\n            return (pos[0, 0], pos[-1, 0])\n        elif axis == 1 and not is_vertical:\n            return (pos[0, 1], pos[-1, 1])\n\n        return None\n\n    @property\n    def is_vertical(self):\n        return self._is_vertical\n\n    def _prepare_transforms(self, view=None):\n        program = view.view_program\n        transforms = view.transforms\n        program.vert['render_to_visual'] = transforms.get_transform('render',\n                                                                    'visual')\n        program.vert['transform'] = transforms.get_transform('visual',\n                                                             'render')\n\n    def _prepare_draw(self, view=None):\n        \"\"\"This method is called immediately before each draw.\n\n        The *view* argument indicates which view is about to be drawn.\n        \"\"\"\n        if self._changed['pos']:\n            self.pos_buf.set_data(self._pos)\n            self._changed['pos'] = False\n\n        if self._changed['color']:\n            self.color_buf.set_data(self._color)\n            self._program.vert['color'] = self.color_buf\n            self._changed['color'] = False\n\n        return True",
  "def __init__(self, pos=None, color=[1.0, 1.0, 1.0, 1.0],\n                 vertical=True, **kwargs):\n        \"\"\"\n\n        \"\"\"\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        self._changed = {'pos': False, 'color': False}\n\n        self.pos_buf = gloo.VertexBuffer()\n        self.color_buf = gloo.VertexBuffer()\n        # The Visual superclass contains a MultiProgram, which is an object\n        # that behaves like a normal shader program (you can assign shader\n        # code, upload values, set template variables, etc.) but internally\n        # manages multiple ModularProgram instances, one per view.\n\n        # The MultiProgram is accessed via the `shared_program` property, so\n        # the following modifications to the program will be applied to all\n        # views:\n        self.shared_program['a_pos'] = self.pos_buf\n        self._program.vert['is_vertical'] = 1 if vertical else 0\n\n        self._need_upload = False\n        self._is_vertical = bool(vertical)\n        self._pos = np.zeros((4, 2), dtype=np.float32)\n        self._color = np.ones((1, 4), dtype=np.float32)\n\n        # Visual keeps track of draw mode, index buffer, and GL state. These\n        # are shared between all views.\n        self._draw_mode = 'triangle_strip'\n        self.set_gl_state('translucent', depth_test=False)\n\n        self.set_data(pos=pos, color=color)",
  "def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : list, tuple or numpy array\n            Bounds of the region along the axis. len(pos) must be >=2.\n        color : list, tuple, or array\n            The color to use when drawing the line. It must have a shape of\n            (1, 4) for a single color region or (len(pos), 4) for a multicolor\n            region.\n        \"\"\"\n        new_pos = self._pos\n        new_color = self._color\n\n        if pos is not None:\n            num_elements = len(pos)\n            pos = np.array(pos, dtype=np.float32)\n            if pos.ndim != 1:\n                raise ValueError('Expected 1D array')\n            vertex = np.empty((num_elements * 2, 2), dtype=np.float32)\n            if self._is_vertical:\n                vertex[:, 0] = np.repeat(pos, 2)\n                vertex[:, 1] = np.tile([-1, 1], num_elements)\n            else:\n                vertex[:, 1] = np.repeat(pos, 2)\n                vertex[:, 0] = np.tile([1, -1], num_elements)\n            new_pos = vertex\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            num_elements = new_pos.shape[0] / 2\n            if color.ndim == 2:\n                if color.shape[0] != num_elements:\n                    raise ValueError('Expected a color for each pos')\n                if color.shape[1] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat(color, 2, axis=0).astype(np.float32)\n            elif color.ndim == 1:\n                if color.shape[0] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat([color], new_pos.shape[0], axis=0)\n                color = color.astype(np.float32)\n            else:\n                raise ValueError('Expected a numpy array of shape '\n                                 '(%d, 4) or (1, 4)' % num_elements)\n            new_color = color\n            self._changed['color'] = True\n\n        # Ensure pos and color have the same size\n        if new_pos.shape[0] != new_color.shape[0]:\n            raise ValueError('pos and color does must have the same size')\n\n        self._color = new_color\n        self._pos = new_pos",
  "def color(self):\n        return self._color[::2]",
  "def pos(self):\n        if self._is_vertical:\n            return self._pos[:, 0].ravel()[::2]\n        else:\n            return self._pos[:, 1].ravel()[::2]",
  "def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        is_vertical = self._is_vertical\n        pos = self._pos\n        if axis == 0 and is_vertical:\n            return (pos[0, 0], pos[-1, 0])\n        elif axis == 1 and not is_vertical:\n            return (pos[0, 1], pos[-1, 1])\n\n        return None",
  "def is_vertical(self):\n        return self._is_vertical",
  "def _prepare_transforms(self, view=None):\n        program = view.view_program\n        transforms = view.transforms\n        program.vert['render_to_visual'] = transforms.get_transform('render',\n                                                                    'visual')\n        program.vert['transform'] = transforms.get_transform('visual',\n                                                             'render')",
  "def _prepare_draw(self, view=None):\n        \"\"\"This method is called immediately before each draw.\n\n        The *view* argument indicates which view is about to be drawn.\n        \"\"\"\n        if self._changed['pos']:\n            self.pos_buf.set_data(self._pos)\n            self._changed['pos'] = False\n\n        if self._changed['color']:\n            self.color_buf.set_data(self._color)\n            self._program.vert['color'] = self.color_buf\n            self._changed['color'] = False\n\n        return True",
  "class InfiniteLineVisual(Visual):\n    \"\"\"Infinite horizontal or vertical line for 2D plots.\n\n    Parameters\n    ----------\n    pos : float\n        Position of the line along the axis.\n    color : list, tuple, or array\n        The color to use when drawing the line. If an array is given, it\n        must be of shape (1, 4) and provide one rgba color per vertex.\n    line_width: float\n        The width of the Infinite line, in pixels\n    antialias: bool\n        If the line is drawn with antialiasing\n    vertical:\n        True for drawing a vertical line, False for an horizontal line\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, pos=None, color=(1.0, 1.0, 1.0, 1.0), line_width=1.0, antialias=False,\n                 vertical=True, **kwargs):\n        \"\"\"\n\n        \"\"\"\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        self._changed = {'pos': False, 'color': False}\n\n        self.pos_buf = gloo.VertexBuffer()\n        # The Visual superclass contains a MultiProgram, which is an object\n        # that behaves like a normal shader program (you can assign shader\n        # code, upload values, set template variables, etc.) but internally\n        # manages multiple ModularProgram instances, one per view.\n\n        # The MultiProgram is accessed via the `shared_program` property, so\n        # the following modifications to the program will be applied to all\n        # views:\n        self.shared_program['a_pos'] = self.pos_buf\n        self._program.vert['is_vertical'] = 1 if vertical else 0\n\n        self._need_upload = False\n        self._is_vertical = bool(vertical)\n        self._pos = np.zeros((2, 2), dtype=np.float32)\n        self._color = np.ones(4, dtype=np.float32)\n        self._line_width = line_width\n        self._antialias = antialias\n\n        # Visual keeps track of draw mode, index buffer, and GL state. These\n        # are shared between all views.\n        self._draw_mode = 'line_strip'\n        self.set_gl_state('translucent', depth_test=False)\n\n        self.set_data(pos=pos, color=color)\n\n    def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : float\n            Position of the line along the axis.\n        color : list, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (1, 4) and provide one rgba color per vertex.\n        \"\"\"\n        if pos is not None:\n            pos = float(pos)\n            xy = self._pos\n            if self._is_vertical:\n                xy[0, 0] = pos\n                xy[0, 1] = -1\n                xy[1, 0] = pos\n                xy[1, 1] = 1\n            else:\n                xy[0, 0] = -1\n                xy[0, 1] = pos\n                xy[1, 0] = 1\n                xy[1, 1] = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            if color.ndim != 1 or color.shape[0] != 4:\n                raise ValueError('color must be a 4 element float rgba tuple,'\n                                 ' list or array')\n            self._color = color\n            self._changed['color'] = True\n\n    @property\n    def color(self):\n        return self._color\n\n    @property\n    def pos(self):\n        if self._is_vertical:\n            return self._pos[0, 0]\n        else:\n            return self._pos[0, 1]\n\n    @property\n    def line_width(self):\n        return self._line_width\n\n    @line_width.setter\n    def line_width(self, val: float):\n        self._line_width = val\n\n    @property\n    def antialias(self):\n        return self._antialias\n\n    @antialias.setter\n    def antialias(self, val: float):\n        self._antialias = val\n\n    def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        is_vertical = self._is_vertical\n        pos = self._pos\n        if axis == 0 and is_vertical:\n            return (pos[0, 0], pos[0, 0])\n        elif axis == 1 and not is_vertical:\n            return (self._pos[0, 1], self._pos[0, 1])\n\n        return None\n\n    @property\n    def is_vertical(self):\n        return self._is_vertical\n\n    def _prepare_transforms(self, view=None):\n        program = view.view_program\n        transforms = view.transforms\n        program.vert['render_to_visual'] = transforms.get_transform('render',\n                                                                    'visual')\n        program.vert['transform'] = transforms.get_transform('visual',\n                                                             'render')\n\n    def _prepare_draw(self, view=None):\n        \"\"\"This method is called immediately before each draw.\n\n        The *view* argument indicates which view is about to be drawn.\n        \"\"\"\n\n        self.update_gl_state(line_smooth=self._antialias)\n        px_scale = self.transforms.pixel_scale\n        width = px_scale * self._line_width\n        self.update_gl_state(line_width=max(width, 1.0))\n\n        if self._changed['pos']:\n            self.pos_buf.set_data(self._pos)\n            self._changed['pos'] = False\n\n        if self._changed['color']:\n            self._program.vert['color'] = self._color\n            self._changed['color'] = False",
  "def __init__(self, pos=None, color=(1.0, 1.0, 1.0, 1.0), line_width=1.0, antialias=False,\n                 vertical=True, **kwargs):\n        \"\"\"\n\n        \"\"\"\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        self._changed = {'pos': False, 'color': False}\n\n        self.pos_buf = gloo.VertexBuffer()\n        # The Visual superclass contains a MultiProgram, which is an object\n        # that behaves like a normal shader program (you can assign shader\n        # code, upload values, set template variables, etc.) but internally\n        # manages multiple ModularProgram instances, one per view.\n\n        # The MultiProgram is accessed via the `shared_program` property, so\n        # the following modifications to the program will be applied to all\n        # views:\n        self.shared_program['a_pos'] = self.pos_buf\n        self._program.vert['is_vertical'] = 1 if vertical else 0\n\n        self._need_upload = False\n        self._is_vertical = bool(vertical)\n        self._pos = np.zeros((2, 2), dtype=np.float32)\n        self._color = np.ones(4, dtype=np.float32)\n        self._line_width = line_width\n        self._antialias = antialias\n\n        # Visual keeps track of draw mode, index buffer, and GL state. These\n        # are shared between all views.\n        self._draw_mode = 'line_strip'\n        self.set_gl_state('translucent', depth_test=False)\n\n        self.set_data(pos=pos, color=color)",
  "def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : float\n            Position of the line along the axis.\n        color : list, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (1, 4) and provide one rgba color per vertex.\n        \"\"\"\n        if pos is not None:\n            pos = float(pos)\n            xy = self._pos\n            if self._is_vertical:\n                xy[0, 0] = pos\n                xy[0, 1] = -1\n                xy[1, 0] = pos\n                xy[1, 1] = 1\n            else:\n                xy[0, 0] = -1\n                xy[0, 1] = pos\n                xy[1, 0] = 1\n                xy[1, 1] = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            if color.ndim != 1 or color.shape[0] != 4:\n                raise ValueError('color must be a 4 element float rgba tuple,'\n                                 ' list or array')\n            self._color = color\n            self._changed['color'] = True",
  "def color(self):\n        return self._color",
  "def pos(self):\n        if self._is_vertical:\n            return self._pos[0, 0]\n        else:\n            return self._pos[0, 1]",
  "def line_width(self):\n        return self._line_width",
  "def line_width(self, val: float):\n        self._line_width = val",
  "def antialias(self):\n        return self._antialias",
  "def antialias(self, val: float):\n        self._antialias = val",
  "def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        is_vertical = self._is_vertical\n        pos = self._pos\n        if axis == 0 and is_vertical:\n            return (pos[0, 0], pos[0, 0])\n        elif axis == 1 and not is_vertical:\n            return (self._pos[0, 1], self._pos[0, 1])\n\n        return None",
  "def is_vertical(self):\n        return self._is_vertical",
  "def _prepare_transforms(self, view=None):\n        program = view.view_program\n        transforms = view.transforms\n        program.vert['render_to_visual'] = transforms.get_transform('render',\n                                                                    'visual')\n        program.vert['transform'] = transforms.get_transform('visual',\n                                                             'render')",
  "def _prepare_draw(self, view=None):\n        \"\"\"This method is called immediately before each draw.\n\n        The *view* argument indicates which view is about to be drawn.\n        \"\"\"\n\n        self.update_gl_state(line_smooth=self._antialias)\n        px_scale = self.transforms.pixel_scale\n        width = px_scale * self._line_width\n        self.update_gl_state(line_width=max(width, 1.0))\n\n        if self._changed['pos']:\n            self.pos_buf.set_data(self._pos)\n            self._changed['pos'] = False\n\n        if self._changed['color']:\n            self._program.vert['color'] = self._color\n            self._changed['color'] = False",
  "class GridMeshVisual(MeshVisual):\n    \"\"\"Displays a mesh in a Cartesian grid about x,y,z coordinates.\n\n    This makes it simple to generate a mesh from e.g. the output\n    of numpy.meshgrid.\n\n    All arguments are optional, though they can be changed\n    individually later with the set_data method.\n\n    Parameters\n    ----------\n    xs : ndarray\n        A 2d array of x coordinates for the vertices of the mesh. Must\n        have the same dimensions as ys and zs.\n    ys : ndarray\n        A 2d array of y coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and zs.\n    zs : ndarray\n        A 2d array of z coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and ys.\n    colors : ndarray | None\n        The colors of the points of the mesh. Should be either a\n        (width, height, 4) array of rgba colors at each grid point or\n        a (width, height, 3) array of rgb colors at each grid point.\n        Defaults to None, in which case the default color of a\n        MeshVisual is used.\n    shading : str | None\n        Same as for the `MeshVisual` class. Defaults to 'smooth'.\n    **kwargs :\n        Other arguments are passed directly to MeshVisual.\n    \"\"\"\n\n    def __init__(self, xs, ys, zs, colors=None, shading='smooth',\n                 **kwargs):\n\n        if xs is None or ys is None or zs is None:\n            raise ValueError('All of xs, ys and zs must be initialised '\n                             'with arrays.')\n\n        self._xs = None\n        self._ys = None\n        self._zs = None\n\n        self.__vertices = None\n        self.__meshdata = MeshData()\n\n        MeshVisual.__init__(self, shading=shading, **kwargs)\n        self.set_data(xs, ys, zs, colors)\n\n    def set_data(self, xs=None, ys=None, zs=None, colors=None):\n        \"\"\"Update the mesh data.\n\n        Parameters\n        ----------\n        xs : ndarray | None\n            A 2d array of x coordinates for the vertices of the mesh.\n        ys : ndarray | None\n            A 2d array of y coordinates for the vertices of the mesh.\n        zs : ndarray | None\n            A 2d array of z coordinates for the vertices of the mesh.\n        colors : ndarray | None\n            The color at each point of the mesh. Must have shape\n            (width, height, 4) or (width, height, 3) for rgba or rgb\n            color definitions respectively.\n        \"\"\"\n        if xs is None:\n            xs = self._xs\n            self.__vertices = None\n\n        if ys is None:\n            ys = self._ys\n            self.__vertices = None\n\n        if zs is None:\n            zs = self._zs\n            self.__vertices = None\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(xs, ys, zs)\n            self._xs = xs\n            self._ys = ys\n            self._zs = zs\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(self._xs, self._ys, self._zs)\n            self.__meshdata.set_vertices(vertices)\n            self.__meshdata.set_faces(indices)\n\n        if colors is not None:\n            self.__meshdata.set_vertex_colors(colors.reshape(\n                colors.shape[0] * colors.shape[1], colors.shape[2]))\n\n        MeshVisual.set_data(self, meshdata=self.__meshdata)",
  "def __init__(self, xs, ys, zs, colors=None, shading='smooth',\n                 **kwargs):\n\n        if xs is None or ys is None or zs is None:\n            raise ValueError('All of xs, ys and zs must be initialised '\n                             'with arrays.')\n\n        self._xs = None\n        self._ys = None\n        self._zs = None\n\n        self.__vertices = None\n        self.__meshdata = MeshData()\n\n        MeshVisual.__init__(self, shading=shading, **kwargs)\n        self.set_data(xs, ys, zs, colors)",
  "def set_data(self, xs=None, ys=None, zs=None, colors=None):\n        \"\"\"Update the mesh data.\n\n        Parameters\n        ----------\n        xs : ndarray | None\n            A 2d array of x coordinates for the vertices of the mesh.\n        ys : ndarray | None\n            A 2d array of y coordinates for the vertices of the mesh.\n        zs : ndarray | None\n            A 2d array of z coordinates for the vertices of the mesh.\n        colors : ndarray | None\n            The color at each point of the mesh. Must have shape\n            (width, height, 4) or (width, height, 3) for rgba or rgb\n            color definitions respectively.\n        \"\"\"\n        if xs is None:\n            xs = self._xs\n            self.__vertices = None\n\n        if ys is None:\n            ys = self._ys\n            self.__vertices = None\n\n        if zs is None:\n            zs = self._zs\n            self.__vertices = None\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(xs, ys, zs)\n            self._xs = xs\n            self._ys = ys\n            self._zs = zs\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(self._xs, self._ys, self._zs)\n            self.__meshdata.set_vertices(vertices)\n            self.__meshdata.set_faces(indices)\n\n        if colors is not None:\n            self.__meshdata.set_vertex_colors(colors.reshape(\n                colors.shape[0] * colors.shape[1], colors.shape[2]))\n\n        MeshVisual.set_data(self, meshdata=self.__meshdata)",
  "class _CoreColorBarVisual(Visual):\n    \"\"\"\n    Visual subclass that actually renders the ColorBar.\n\n    Parameters\n    ----------\n     pos : tuple (x, y)\n        Position where the colorbar is to be placed with\n        respect to the center of the colorbar\n    halfdim : tuple (half_width, half_height)\n        Half the dimensions of the colorbar measured\n        from the center. That way, the total dimensions\n        of the colorbar is (x - half_width) to (x + half_width)\n        and (y - half_height) to (y + half_height)\n    cmap : str | vispy.color.ColorMap\n        Either the name of the ColorMap to be used from the standard\n        set of names (refer to `vispy.color.get_colormap`),\n        or a custom ColorMap object.\n        The ColorMap is used to apply a gradient on the colorbar.\n     orientation : {'left', 'right', 'top', 'bottom'}\n        The orientation of the colorbar, used for rendering. The\n        orientation can be thought of as the position of the label\n        relative to the color bar.\n\n    Note\n    ----\n    This is purely internal.\n    Externally, the ColorBarVisual must be used.\n    This class was separated out to encapsulate rendering information\n    That way, ColorBar simply becomes a CompoundVisual\n\n    See Also\n    --------\n    vispy.visuals.ColorBarVisual\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, pos, halfdim,\n                 cmap,\n                 orientation,\n                 **kwargs):\n\n        self._check_orientation(orientation)\n        self._cmap = get_colormap(cmap)\n        self._pos = pos\n        self._halfdim = halfdim\n        self._orientation = orientation\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        texcoord_func = self._get_texcoord_func(orientation)\n        self.shared_program.frag['orient_texcoord'] = texcoord_func\n\n        tex_coords = np.array([[0, 0], [1, 0], [1, 1],\n                               [0, 0], [1, 1], [0, 1]],\n                              dtype=np.float32)\n\n        glsl_map_fn = Function(self._cmap.glsl_map)\n\n        self.shared_program.frag['color_transform'] = glsl_map_fn\n        self.shared_program['a_texcoord'] = tex_coords.astype(np.float32)\n\n        self._update()\n\n    def _update(self):\n        \"\"\"Rebuilds the shaders, and repositions the objects that are used internally by the ColorBarVisual\"\"\"\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        # test that width and height are non-zero\n        if halfw <= 0:\n            raise ValueError(\"half-width must be positive and non-zero\"\n                             \", not %s\" % halfw)\n        if halfh <= 0:\n            raise ValueError(\"half-height must be positive and non-zero\"\n                             \", not %s\" % halfh)\n\n        # test that the given width and height is consistent\n        # with the orientation\n        if (self._orientation == \"bottom\" or self._orientation == \"top\"):\n            if halfw < halfh:\n                raise ValueError(\"half-width(%s) < half-height(%s) for\"\n                                 \"%s orientation,\"\n                                 \" expected half-width >= half-height\" %\n                                 (halfw, halfh, self._orientation, ))\n        else:  # orientation == left or orientation == right\n            if halfw > halfh:\n                raise ValueError(\"half-width(%s) > half-height(%s) for\"\n                                 \"%s orientation,\"\n                                 \" expected half-width <= half-height\" %\n                                 (halfw, halfh, self._orientation, ))\n\n        # Set up the attributes that the shaders require\n        vertices = np.array([[x - halfw, y - halfh],\n                             [x + halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             # tri 2\n                             [x - halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             [x - halfw, y + halfh]],\n                            dtype=np.float32)\n\n        self.shared_program['a_position'] = vertices\n\n        self.shared_program['texture2D_LUT'] = self._cmap.texture_lut()\n\n    @staticmethod\n    @lru_cache(maxsize=4)\n    def _get_texcoord_func(orientation):\n        if orientation == \"top\" or orientation == \"bottom\":\n            func = Function(\"\"\"\n                float orient_texcoord(vec2 texcoord) {\n                    return texcoord.x;\n                }\n            \"\"\")\n        elif orientation == \"left\" or orientation == \"right\":\n            func = Function(\"\"\"\n                float orient_texcoord(vec2 texcoord) {\n                    return 1 - texcoord.y;\n                }\n            \"\"\")\n        return func\n\n    @staticmethod\n    def _check_orientation(orientation):\n        if orientation not in ('top', 'bottom', 'left', 'right'):\n            raise ValueError(\"orientation must\"\n                             \" be one of 'top', 'bottom', \"\n                             \"'left', or 'right', \"\n                             \"not '%s'\" % (orientation, ))\n\n    @property\n    def pos(self):\n        return self._pos\n\n    @pos.setter\n    def pos(self, pos):\n        self._pos = pos\n        self._update()\n\n    @property\n    def halfdim(self):\n        return self._halfdim\n\n    @halfdim.setter\n    def halfdim(self, halfdim):\n        self._halfdim = halfdim\n\n    @property\n    def cmap(self):\n        \"\"\"The colormap of the Colorbar\"\"\"\n        return self._cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self._program.frag['color_transform'] = Function(self._cmap.glsl_map)\n\n    @staticmethod\n    def _prepare_transforms(view):\n        # figure out padding by considering the entire transform\n        # on the width and height\n        program = view.view_program\n        total_transform = view.transforms.get_transform()\n        program.vert['transform'] = total_transform\n\n    def _prepare_draw(self, view):\n        self._draw_mode = \"triangles\"\n        return True",
  "class ColorBarVisual(CompoundVisual):\n    \"\"\"Visual subclass displaying a colorbar\n\n    Parameters\n    ----------\n    cmap : str | vispy.color.ColorMap\n        Either the name of the ColorMap to be used from the standard\n        set of names (refer to `vispy.color.get_colormap`),\n        or a custom ColorMap object.\n        The ColorMap is used to apply a gradient on the colorbar.\n    orientation : {'left', 'right', 'top', 'bottom'}\n        The orientation of the colorbar, used for rendering. The\n        orientation can be thought of as the position of the label\n        relative to the color bar.\n\n        When the orientation is 'left' or 'right', the colorbar is\n        vertically placed. When it is 'top' or 'bottom', the colorbar is\n        horizontally placed.\n\n            * 'top': the colorbar is horizontal.\n              Color is applied from left to right.\n              Minimum corresponds to left and maximum to right.\n              Label is to the top of the colorbar\n\n            * 'bottom': Same as top, except that\n              label is to the bottom of the colorbar\n\n            * 'left': the colorbar is vertical.\n              Color is applied from bottom to top.\n              Minimum corresponds to bottom and maximum to top.\n              Label is to the left of the colorbar\n\n            * 'right': Same as left, except that the\n              label is placed to the right of the colorbar\n\n    size : (major_axis_length, minor_axis_length)\n        lengths with respect to the major and minor axes.\n        The minor axis is the shorter axis, while the major axis is\n        the longer axis with respect to the orientation\n\n        For orientations 'top' and 'bottom', the major axis is\n        along the length.\n\n        For orientations 'left' and 'right', the major axis is\n        along the breadth\n    pos : tuple (x, y)\n        Position where the colorbar is to be placed with\n        respect to the center of the colorbar\n    label : str | vispy.visuals.TextVisual\n        The label that is to be drawn with the colorbar\n        that provides information about the colorbar.\n        If a TextVisual object then 'label_color' is ignored.\n    label_color : str | vispy.color.Color\n        The color of the label and tick labels. This can either be a\n        str as the color's name or an actual instace of a vipy.color.Color\n    clim : tuple (min, max)\n        the minimum and maximum values of the data that\n        is given to the colorbar. This is used to draw the scale\n        on the side of the colorbar.\n    border_width : float (in px)\n        The width of the border the colormap should have. This measurement\n        is given in pixels\n    border_color : str | vispy.color.Color\n        The color of the border of the colormap. This can either be a\n        str as the color's name or an actual instace of a vipy.color.Color\n\n    .. versionchanged:: 0.7\n\n        Keyword argument ``label_str`` renamed to `label`.\n\n    \"\"\"\n\n    # The padding multiplier that's used to place the text\n    # next to the Colorbar. Makes sure the text isn't\n    # visually \"sticking\" to the Colorbar\n    text_padding_factor = 1.05\n\n    def __init__(self, cmap, orientation, size,\n                 pos=[0, 0],\n                 label=\"\",\n                 label_color='black',\n                 clim=(0.0, 1.0),\n                 border_width=1.0,\n                 border_color=\"black\"):\n\n        _CoreColorBarVisual._check_orientation(orientation)\n        self._cmap = get_colormap(cmap)\n        self._clim = clim\n        self._pos = pos\n        self._size = size\n        self._orientation = orientation\n\n        if not isinstance(label, TextVisual):\n            label = TextVisual(label, color=label_color)\n        self._label = label\n\n        self._ticks = []\n        self._ticks.append(TextVisual(str(self._clim[0]),\n                                      color=label_color))\n        self._ticks.append(TextVisual(str(self._clim[1]),\n                                      color=label_color))\n\n        if orientation in [\"top\", \"bottom\"]:\n            (width, height) = size\n        elif orientation in [\"left\", \"right\"]:\n            (height, width) = size\n\n        self._halfdim = (width * 0.5, height * 0.5)\n\n        self._colorbar = _CoreColorBarVisual(pos, self._halfdim,\n                                             cmap, orientation)\n\n        self._border = _BorderVisual(pos, self._halfdim,\n                                     border_width, border_color)\n\n        CompoundVisual.__init__(self, [self._colorbar,\n                                       self._border,\n                                       self._ticks[0],\n                                       self._ticks[1],\n                                       self._label,\n                                       ])\n        self._update()\n\n    def _update(self):\n        \"\"\"Rebuilds the shaders, and repositions the objects that are used internally by the ColorBarVisual\"\"\"\n        self._colorbar.halfdim = self._halfdim\n        self._border.halfdim = self._halfdim\n\n        self._ticks[0].text = str(self._clim[0])\n        self._ticks[1].text = str(self._clim[1])\n\n        self._update_positions()\n\n        self._colorbar._update()\n        self._border._update()\n\n    def _update_positions(self):\n        \"\"\"Updates the positions of the colorbars and labels\"\"\"\n        self._colorbar.pos = self._pos\n        self._border.pos = self._pos\n\n        if self._orientation == \"right\" or self._orientation == \"left\":\n            self._label.rotation = -90\n\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        label_anchors = \\\n            ColorBarVisual._get_label_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n        self._label.anchors = label_anchors\n\n        ticks_anchors = \\\n            ColorBarVisual._get_ticks_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n\n        self._ticks[0].anchors = ticks_anchors\n        self._ticks[1].anchors = ticks_anchors\n\n        (label_pos, ticks_pos) = \\\n            ColorBarVisual._calc_positions(center=self._pos,\n                                           halfdim=self._halfdim,\n                                           border_width=self.border_width,\n                                           orientation=self._orientation,\n                                           transforms=self.transforms)\n\n        self._label.pos = label_pos\n        self._ticks[0].pos = ticks_pos[0]\n        self._ticks[1].pos = ticks_pos[1]\n\n    @staticmethod\n    def _get_label_anchors(center, halfdim, orientation, transforms):\n        visual_to_doc = transforms.get_transform('visual', 'document')\n\n        doc_x = visual_to_doc.map(np.array([1, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, 1, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # NOTE: these are in document coordinates\n        if orientation == \"bottom\":\n            perp_direction = doc_y\n        elif orientation == \"top\":\n            perp_direction = -doc_y\n        elif orientation == \"left\":\n            perp_direction = -doc_x\n        elif orientation == \"right\":\n            perp_direction = doc_x\n\n        perp_direction = np.array(perp_direction, dtype=np.float32)\n        perp_direction /= np.linalg.norm(perp_direction)\n\n        # rotate axes by -90 degrees to mimic label's rotation\n        if orientation in [\"left\", \"right\"]:\n            x = perp_direction[0]\n            y = perp_direction[1]\n\n            perp_direction[0] = -y\n            perp_direction[1] = x\n\n        # use the document (pixel) coord system to set text anchors\n        anchors = []\n        if perp_direction[0] < 0:\n            anchors.append('right')\n        elif perp_direction[0] > 0:\n            anchors.append('left')\n        else:\n            anchors.append('center')\n        if perp_direction[1] < 0:\n            anchors.append('bottom')\n        elif perp_direction[1] > 0:\n            anchors.append('top')\n        else:\n            anchors.append('middle')\n\n        return anchors\n\n    @staticmethod\n    def _get_ticks_anchors(center, halfdim, orientation, transforms):\n        visual_to_doc = transforms.get_transform('visual', 'document')\n\n        doc_x = visual_to_doc.map(np.array([1, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, 1, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # NOTE: these are in document coordinates\n        if orientation == \"bottom\":\n            perp_direction = doc_y\n        elif orientation == \"top\":\n            perp_direction = -doc_y\n        elif orientation == \"left\":\n            perp_direction = -doc_x\n        elif orientation == \"right\":\n            perp_direction = doc_x\n\n        perp_direction = np.array(perp_direction, dtype=np.float32)\n        perp_direction /= np.linalg.norm(perp_direction)\n\n        # use the document (pixel) coord system to set text anchors\n        anchors = []\n        if perp_direction[0] < 0:\n            anchors.append('right')\n        elif perp_direction[0] > 0:\n            anchors.append('left')\n        else:\n            anchors.append('center')\n        if perp_direction[1] < 0:\n            anchors.append('bottom')\n        elif perp_direction[1] > 0:\n            anchors.append('top')\n        else:\n            anchors.append('middle')\n\n        return anchors\n\n    @staticmethod\n    def _calc_positions(center, halfdim, border_width,\n                        orientation, transforms):\n        \"\"\"\n        Calculate the text centeritions given the ColorBar\n        parameters.\n\n        Note\n        ----\n        This is static because in principle, this\n        function does not need access to the state of the ColorBar\n        at all. It's a computation function that computes coordinate\n        transforms\n\n        Parameters\n        ----------\n        center: tuple (x, y)\n            Center of the ColorBar\n        halfdim: tuple (halfw, halfh)\n            Half of the dimensions measured from the center\n        border_width: float\n            Width of the border of the ColorBar\n        orientation: \"top\" | \"bottom\" | \"left\" | \"right\"\n            Position of the label with respect to the ColorBar\n        transforms: TransformSystem\n            the transforms of the ColorBar\n        \"\"\"\n        (x, y) = center\n        (halfw, halfh) = halfdim\n\n        visual_to_doc = transforms.get_transform('visual', 'document')\n        doc_to_visual = transforms.get_transform('document', 'visual')\n\n        # doc_widths = visual_to_doc.map(np.array([halfw, halfh, 0, 0],\n        #                                         dtype=np.float32))\n\n        doc_x = visual_to_doc.map(np.array([halfw, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, halfh, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # doc_halfw = np.abs(doc_widths[0])\n        # doc_halfh = np.abs(doc_widths[1])\n\n        if orientation == \"top\":\n            doc_perp_vector = -doc_y\n        elif orientation == \"bottom\":\n            doc_perp_vector = doc_y\n        elif orientation == \"left\":\n            doc_perp_vector = -doc_x\n        if orientation == \"right\":\n            doc_perp_vector = doc_x\n\n        perp_len = np.linalg.norm(doc_perp_vector)\n        doc_perp_vector /= perp_len\n        perp_len += border_width\n        perp_len += 5  # pixels\n        perp_len *= ColorBarVisual.text_padding_factor\n        doc_perp_vector *= perp_len\n\n        doc_center = visual_to_doc.map(np.array([x, y, 0, 0],\n                                                dtype=np.float32))\n        doc_label_pos = doc_center + doc_perp_vector\n        visual_label_pos = doc_to_visual.map(doc_label_pos)[:3]\n\n        # next, calculate tick positions\n        if orientation in [\"top\", \"bottom\"]:\n            doc_ticks_pos = [doc_label_pos - doc_x,\n                             doc_label_pos + doc_x]\n        else:\n            doc_ticks_pos = [doc_label_pos + doc_y,\n                             doc_label_pos - doc_y]\n\n        visual_ticks_pos = []\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[0])[:3])\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[1])[:3])\n\n        return (visual_label_pos, visual_ticks_pos)\n\n    @property\n    def pos(self):\n        \"\"\"The position of the text anchor in the local coordinate frame\"\"\"\n        return self._pos\n\n    @pos.setter\n    def pos(self, pos):\n        self._pos = pos\n        self._update_positions()\n\n    @property\n    def cmap(self):\n        \"\"\"The colormap of the Colorbar\"\"\"\n        return self._colorbar._cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._colorbar.cmap = cmap\n\n    @property\n    def clim(self):\n        \"\"\"The data limits of the Colorbar\n\n        Returns\n        -------\n        clim: tuple(min, max)\n        \"\"\"\n        return self._clim\n\n    @clim.setter\n    def clim(self, clim):\n        self._clim = clim\n        self._update()\n\n    @property\n    def label(self):\n        \"\"\"The vispy.visuals.TextVisual associated with the label\"\"\"\n        return self._label\n\n    @label.setter\n    def label(self, label):\n        if isinstance(label, TextVisual):\n            self._label = label\n        else:\n            self._label.text = label\n        self._update()\n\n    @property\n    def ticks(self):\n        \"\"\"The vispy.visuals.TextVisual associated with the ticks\n\n        Returns\n        -------\n        ticks: [vispy.visual.TextVisual]\n            The array is of length 2\n        \"\"\"\n        return self._ticks\n\n    @ticks.setter\n    def ticks(self, ticks):\n        self._ticks = ticks\n        self._update()\n\n    @property\n    def border_width(self):\n        \"\"\"The width of the border around the ColorBar in pixels\"\"\"\n        return self._border.border_width\n\n    @border_width.setter\n    def border_width(self, border_width):\n        self._border.border_width = border_width\n        self._update()\n\n    @property\n    def border_color(self):\n        \"\"\"The color of the border around the ColorBar in pixels\"\"\"\n        return self._border.border_color\n\n    @border_color.setter\n    def border_color(self, border_color):\n        self._border.border_color = border_color\n        self._update()\n\n    @property\n    def orientation(self):\n        \"\"\"The orientation of the ColorBar\"\"\"\n        return self._orientation\n\n    @property\n    def size(self):\n        \"\"\"The size of the ColorBar\n\n        Returns\n        -------\n        size: (major_axis_length, minor_axis_length)\n            major and minor axis are defined by the\n            orientation of the ColorBar\n        \"\"\"\n        (halfw, halfh) = self._halfdim\n        if self.orientation in [\"top\", \"bottom\"]:\n            return (halfw * 2., halfh * 2.)\n        else:\n            return (halfh * 2., halfw * 2.)\n\n    @size.setter\n    def size(self, size):\n        if size[0] < size[1]:\n            raise ValueError(\"Major axis must be greater than or equal to \"\n                             \"Minor axis. Given \"\n                             \"Major axis: (%s) < Minor axis (%s)\" % (size[0],\n                                                                     size[1]))\n\n        if self.orientation in [\"top\", \"bottom\"]:\n            (width, height) = size\n        else:\n            (height, width) = size\n\n        if width < 0.:\n            raise ValueError(\"width must be non-negative, not %s \" % (width, ))\n        elif width == 0.:\n            raise ValueError(\"width must be non-zero, not %s\" % (width, ))\n\n        if height < 0.:\n            raise ValueError(\"height must be non-negative, not %s \" %\n                             (height, ))\n        elif height == 0.:\n            raise ValueError(\"height must be non-zero, not %s\" % (height, ))\n\n        self._halfdim = (width / 2., height / 2.)\n        self._update()",
  "def __init__(self, pos, halfdim,\n                 cmap,\n                 orientation,\n                 **kwargs):\n\n        self._check_orientation(orientation)\n        self._cmap = get_colormap(cmap)\n        self._pos = pos\n        self._halfdim = halfdim\n        self._orientation = orientation\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n        texcoord_func = self._get_texcoord_func(orientation)\n        self.shared_program.frag['orient_texcoord'] = texcoord_func\n\n        tex_coords = np.array([[0, 0], [1, 0], [1, 1],\n                               [0, 0], [1, 1], [0, 1]],\n                              dtype=np.float32)\n\n        glsl_map_fn = Function(self._cmap.glsl_map)\n\n        self.shared_program.frag['color_transform'] = glsl_map_fn\n        self.shared_program['a_texcoord'] = tex_coords.astype(np.float32)\n\n        self._update()",
  "def _update(self):\n        \"\"\"Rebuilds the shaders, and repositions the objects that are used internally by the ColorBarVisual\"\"\"\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        # test that width and height are non-zero\n        if halfw <= 0:\n            raise ValueError(\"half-width must be positive and non-zero\"\n                             \", not %s\" % halfw)\n        if halfh <= 0:\n            raise ValueError(\"half-height must be positive and non-zero\"\n                             \", not %s\" % halfh)\n\n        # test that the given width and height is consistent\n        # with the orientation\n        if (self._orientation == \"bottom\" or self._orientation == \"top\"):\n            if halfw < halfh:\n                raise ValueError(\"half-width(%s) < half-height(%s) for\"\n                                 \"%s orientation,\"\n                                 \" expected half-width >= half-height\" %\n                                 (halfw, halfh, self._orientation, ))\n        else:  # orientation == left or orientation == right\n            if halfw > halfh:\n                raise ValueError(\"half-width(%s) > half-height(%s) for\"\n                                 \"%s orientation,\"\n                                 \" expected half-width <= half-height\" %\n                                 (halfw, halfh, self._orientation, ))\n\n        # Set up the attributes that the shaders require\n        vertices = np.array([[x - halfw, y - halfh],\n                             [x + halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             # tri 2\n                             [x - halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             [x - halfw, y + halfh]],\n                            dtype=np.float32)\n\n        self.shared_program['a_position'] = vertices\n\n        self.shared_program['texture2D_LUT'] = self._cmap.texture_lut()",
  "def _get_texcoord_func(orientation):\n        if orientation == \"top\" or orientation == \"bottom\":\n            func = Function(\"\"\"\n                float orient_texcoord(vec2 texcoord) {\n                    return texcoord.x;\n                }\n            \"\"\")\n        elif orientation == \"left\" or orientation == \"right\":\n            func = Function(\"\"\"\n                float orient_texcoord(vec2 texcoord) {\n                    return 1 - texcoord.y;\n                }\n            \"\"\")\n        return func",
  "def _check_orientation(orientation):\n        if orientation not in ('top', 'bottom', 'left', 'right'):\n            raise ValueError(\"orientation must\"\n                             \" be one of 'top', 'bottom', \"\n                             \"'left', or 'right', \"\n                             \"not '%s'\" % (orientation, ))",
  "def pos(self):\n        return self._pos",
  "def pos(self, pos):\n        self._pos = pos\n        self._update()",
  "def halfdim(self):\n        return self._halfdim",
  "def halfdim(self, halfdim):\n        self._halfdim = halfdim",
  "def cmap(self):\n        \"\"\"The colormap of the Colorbar\"\"\"\n        return self._cmap",
  "def cmap(self, cmap):\n        self._cmap = get_colormap(cmap)\n        self._program.frag['color_transform'] = Function(self._cmap.glsl_map)",
  "def _prepare_transforms(view):\n        # figure out padding by considering the entire transform\n        # on the width and height\n        program = view.view_program\n        total_transform = view.transforms.get_transform()\n        program.vert['transform'] = total_transform",
  "def _prepare_draw(self, view):\n        self._draw_mode = \"triangles\"\n        return True",
  "def __init__(self, cmap, orientation, size,\n                 pos=[0, 0],\n                 label=\"\",\n                 label_color='black',\n                 clim=(0.0, 1.0),\n                 border_width=1.0,\n                 border_color=\"black\"):\n\n        _CoreColorBarVisual._check_orientation(orientation)\n        self._cmap = get_colormap(cmap)\n        self._clim = clim\n        self._pos = pos\n        self._size = size\n        self._orientation = orientation\n\n        if not isinstance(label, TextVisual):\n            label = TextVisual(label, color=label_color)\n        self._label = label\n\n        self._ticks = []\n        self._ticks.append(TextVisual(str(self._clim[0]),\n                                      color=label_color))\n        self._ticks.append(TextVisual(str(self._clim[1]),\n                                      color=label_color))\n\n        if orientation in [\"top\", \"bottom\"]:\n            (width, height) = size\n        elif orientation in [\"left\", \"right\"]:\n            (height, width) = size\n\n        self._halfdim = (width * 0.5, height * 0.5)\n\n        self._colorbar = _CoreColorBarVisual(pos, self._halfdim,\n                                             cmap, orientation)\n\n        self._border = _BorderVisual(pos, self._halfdim,\n                                     border_width, border_color)\n\n        CompoundVisual.__init__(self, [self._colorbar,\n                                       self._border,\n                                       self._ticks[0],\n                                       self._ticks[1],\n                                       self._label,\n                                       ])\n        self._update()",
  "def _update(self):\n        \"\"\"Rebuilds the shaders, and repositions the objects that are used internally by the ColorBarVisual\"\"\"\n        self._colorbar.halfdim = self._halfdim\n        self._border.halfdim = self._halfdim\n\n        self._ticks[0].text = str(self._clim[0])\n        self._ticks[1].text = str(self._clim[1])\n\n        self._update_positions()\n\n        self._colorbar._update()\n        self._border._update()",
  "def _update_positions(self):\n        \"\"\"Updates the positions of the colorbars and labels\"\"\"\n        self._colorbar.pos = self._pos\n        self._border.pos = self._pos\n\n        if self._orientation == \"right\" or self._orientation == \"left\":\n            self._label.rotation = -90\n\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        label_anchors = \\\n            ColorBarVisual._get_label_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n        self._label.anchors = label_anchors\n\n        ticks_anchors = \\\n            ColorBarVisual._get_ticks_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n\n        self._ticks[0].anchors = ticks_anchors\n        self._ticks[1].anchors = ticks_anchors\n\n        (label_pos, ticks_pos) = \\\n            ColorBarVisual._calc_positions(center=self._pos,\n                                           halfdim=self._halfdim,\n                                           border_width=self.border_width,\n                                           orientation=self._orientation,\n                                           transforms=self.transforms)\n\n        self._label.pos = label_pos\n        self._ticks[0].pos = ticks_pos[0]\n        self._ticks[1].pos = ticks_pos[1]",
  "def _get_label_anchors(center, halfdim, orientation, transforms):\n        visual_to_doc = transforms.get_transform('visual', 'document')\n\n        doc_x = visual_to_doc.map(np.array([1, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, 1, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # NOTE: these are in document coordinates\n        if orientation == \"bottom\":\n            perp_direction = doc_y\n        elif orientation == \"top\":\n            perp_direction = -doc_y\n        elif orientation == \"left\":\n            perp_direction = -doc_x\n        elif orientation == \"right\":\n            perp_direction = doc_x\n\n        perp_direction = np.array(perp_direction, dtype=np.float32)\n        perp_direction /= np.linalg.norm(perp_direction)\n\n        # rotate axes by -90 degrees to mimic label's rotation\n        if orientation in [\"left\", \"right\"]:\n            x = perp_direction[0]\n            y = perp_direction[1]\n\n            perp_direction[0] = -y\n            perp_direction[1] = x\n\n        # use the document (pixel) coord system to set text anchors\n        anchors = []\n        if perp_direction[0] < 0:\n            anchors.append('right')\n        elif perp_direction[0] > 0:\n            anchors.append('left')\n        else:\n            anchors.append('center')\n        if perp_direction[1] < 0:\n            anchors.append('bottom')\n        elif perp_direction[1] > 0:\n            anchors.append('top')\n        else:\n            anchors.append('middle')\n\n        return anchors",
  "def _get_ticks_anchors(center, halfdim, orientation, transforms):\n        visual_to_doc = transforms.get_transform('visual', 'document')\n\n        doc_x = visual_to_doc.map(np.array([1, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, 1, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # NOTE: these are in document coordinates\n        if orientation == \"bottom\":\n            perp_direction = doc_y\n        elif orientation == \"top\":\n            perp_direction = -doc_y\n        elif orientation == \"left\":\n            perp_direction = -doc_x\n        elif orientation == \"right\":\n            perp_direction = doc_x\n\n        perp_direction = np.array(perp_direction, dtype=np.float32)\n        perp_direction /= np.linalg.norm(perp_direction)\n\n        # use the document (pixel) coord system to set text anchors\n        anchors = []\n        if perp_direction[0] < 0:\n            anchors.append('right')\n        elif perp_direction[0] > 0:\n            anchors.append('left')\n        else:\n            anchors.append('center')\n        if perp_direction[1] < 0:\n            anchors.append('bottom')\n        elif perp_direction[1] > 0:\n            anchors.append('top')\n        else:\n            anchors.append('middle')\n\n        return anchors",
  "def _calc_positions(center, halfdim, border_width,\n                        orientation, transforms):\n        \"\"\"\n        Calculate the text centeritions given the ColorBar\n        parameters.\n\n        Note\n        ----\n        This is static because in principle, this\n        function does not need access to the state of the ColorBar\n        at all. It's a computation function that computes coordinate\n        transforms\n\n        Parameters\n        ----------\n        center: tuple (x, y)\n            Center of the ColorBar\n        halfdim: tuple (halfw, halfh)\n            Half of the dimensions measured from the center\n        border_width: float\n            Width of the border of the ColorBar\n        orientation: \"top\" | \"bottom\" | \"left\" | \"right\"\n            Position of the label with respect to the ColorBar\n        transforms: TransformSystem\n            the transforms of the ColorBar\n        \"\"\"\n        (x, y) = center\n        (halfw, halfh) = halfdim\n\n        visual_to_doc = transforms.get_transform('visual', 'document')\n        doc_to_visual = transforms.get_transform('document', 'visual')\n\n        # doc_widths = visual_to_doc.map(np.array([halfw, halfh, 0, 0],\n        #                                         dtype=np.float32))\n\n        doc_x = visual_to_doc.map(np.array([halfw, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, halfh, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # doc_halfw = np.abs(doc_widths[0])\n        # doc_halfh = np.abs(doc_widths[1])\n\n        if orientation == \"top\":\n            doc_perp_vector = -doc_y\n        elif orientation == \"bottom\":\n            doc_perp_vector = doc_y\n        elif orientation == \"left\":\n            doc_perp_vector = -doc_x\n        if orientation == \"right\":\n            doc_perp_vector = doc_x\n\n        perp_len = np.linalg.norm(doc_perp_vector)\n        doc_perp_vector /= perp_len\n        perp_len += border_width\n        perp_len += 5  # pixels\n        perp_len *= ColorBarVisual.text_padding_factor\n        doc_perp_vector *= perp_len\n\n        doc_center = visual_to_doc.map(np.array([x, y, 0, 0],\n                                                dtype=np.float32))\n        doc_label_pos = doc_center + doc_perp_vector\n        visual_label_pos = doc_to_visual.map(doc_label_pos)[:3]\n\n        # next, calculate tick positions\n        if orientation in [\"top\", \"bottom\"]:\n            doc_ticks_pos = [doc_label_pos - doc_x,\n                             doc_label_pos + doc_x]\n        else:\n            doc_ticks_pos = [doc_label_pos + doc_y,\n                             doc_label_pos - doc_y]\n\n        visual_ticks_pos = []\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[0])[:3])\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[1])[:3])\n\n        return (visual_label_pos, visual_ticks_pos)",
  "def pos(self):\n        \"\"\"The position of the text anchor in the local coordinate frame\"\"\"\n        return self._pos",
  "def pos(self, pos):\n        self._pos = pos\n        self._update_positions()",
  "def cmap(self):\n        \"\"\"The colormap of the Colorbar\"\"\"\n        return self._colorbar._cmap",
  "def cmap(self, cmap):\n        self._colorbar.cmap = cmap",
  "def clim(self):\n        \"\"\"The data limits of the Colorbar\n\n        Returns\n        -------\n        clim: tuple(min, max)\n        \"\"\"\n        return self._clim",
  "def clim(self, clim):\n        self._clim = clim\n        self._update()",
  "def label(self):\n        \"\"\"The vispy.visuals.TextVisual associated with the label\"\"\"\n        return self._label",
  "def label(self, label):\n        if isinstance(label, TextVisual):\n            self._label = label\n        else:\n            self._label.text = label\n        self._update()",
  "def ticks(self):\n        \"\"\"The vispy.visuals.TextVisual associated with the ticks\n\n        Returns\n        -------\n        ticks: [vispy.visual.TextVisual]\n            The array is of length 2\n        \"\"\"\n        return self._ticks",
  "def ticks(self, ticks):\n        self._ticks = ticks\n        self._update()",
  "def border_width(self):\n        \"\"\"The width of the border around the ColorBar in pixels\"\"\"\n        return self._border.border_width",
  "def border_width(self, border_width):\n        self._border.border_width = border_width\n        self._update()",
  "def border_color(self):\n        \"\"\"The color of the border around the ColorBar in pixels\"\"\"\n        return self._border.border_color",
  "def border_color(self, border_color):\n        self._border.border_color = border_color\n        self._update()",
  "def orientation(self):\n        \"\"\"The orientation of the ColorBar\"\"\"\n        return self._orientation",
  "def size(self):\n        \"\"\"The size of the ColorBar\n\n        Returns\n        -------\n        size: (major_axis_length, minor_axis_length)\n            major and minor axis are defined by the\n            orientation of the ColorBar\n        \"\"\"\n        (halfw, halfh) = self._halfdim\n        if self.orientation in [\"top\", \"bottom\"]:\n            return (halfw * 2., halfh * 2.)\n        else:\n            return (halfh * 2., halfw * 2.)",
  "def size(self, size):\n        if size[0] < size[1]:\n            raise ValueError(\"Major axis must be greater than or equal to \"\n                             \"Minor axis. Given \"\n                             \"Major axis: (%s) < Minor axis (%s)\" % (size[0],\n                                                                     size[1]))\n\n        if self.orientation in [\"top\", \"bottom\"]:\n            (width, height) = size\n        else:\n            (height, width) = size\n\n        if width < 0.:\n            raise ValueError(\"width must be non-negative, not %s \" % (width, ))\n        elif width == 0.:\n            raise ValueError(\"width must be non-zero, not %s\" % (width, ))\n\n        if height < 0.:\n            raise ValueError(\"height must be non-negative, not %s \" %\n                             (height, ))\n        elif height == 0.:\n            raise ValueError(\"height must be non-zero, not %s\" % (height, ))\n\n        self._halfdim = (width / 2., height / 2.)\n        self._update()",
  "def iso_mesh_line(vertices, tris, vertex_data, levels):\n    \"\"\"Generate an isocurve from vertex data in a surface mesh.\n\n    Parameters\n    ----------\n    vertices : ndarray, shape (Nv, 3)\n        Vertex coordinates.\n    tris : ndarray, shape (Nf, 3)\n        Indices of triangular element into the vertices array.\n    vertex_data : ndarray, shape (Nv,)\n        data at vertex.\n    levels : ndarray, shape (Nl,)\n        Levels at which to generate an isocurve\n\n    Returns\n    -------\n    lines : ndarray, shape (Nvout, 3)\n        Vertex coordinates for lines points\n    connects : ndarray, shape (Ne, 2)\n        Indices of line element into the vertex array.\n    vertex_level: ndarray, shape (Nvout,)\n        level for vertex in lines\n\n    Notes\n    -----\n    Uses a marching squares algorithm to generate the isolines.\n    \"\"\"\n    lines = None\n    connects = None\n    vertex_level = None\n    level_index = None\n    if not all([isinstance(x, np.ndarray) for x in (vertices, tris,\n                                                    vertex_data, levels)]):\n        raise ValueError('all inputs must be numpy arrays')\n    if vertices.shape[1] <= 3:\n        verts = vertices\n    elif vertices.shape[1] == 4:\n        verts = vertices[:, :-1]\n    else:\n        verts = None\n    if (verts is not None and tris.shape[1] == 3 and\n            vertex_data.shape[0] == verts.shape[0]):\n        edges = np.vstack((tris.reshape((-1)),\n                           np.roll(tris, -1, axis=1).reshape((-1)))).T\n        edge_datas = vertex_data[edges]\n        edge_coors = verts[edges].reshape(tris.shape[0]*3, 2, 3)\n        for lev in levels:\n            # index for select edges with vertices have only False - True\n            # or True - False at extremity\n            index = (edge_datas >= lev)\n            index = index[:, 0] ^ index[:, 1]  # xor calculation\n            # Selectect edge\n            edge_datas_Ok = edge_datas[index, :]\n            xyz = edge_coors[index]\n            # Linear interpolation\n            ratio = np.array([(lev - edge_datas_Ok[:, 0]) /\n                              (edge_datas_Ok[:, 1] - edge_datas_Ok[:, 0])])\n            point = xyz[:, 0, :] + ratio.T * (xyz[:, 1, :] - xyz[:, 0, :])\n            nbr = point.shape[0]//2\n            if connects is not None:\n                connect = np.arange(0, nbr*2).reshape((nbr, 2)) + \\\n                    len(lines)\n                connects = np.append(connects, connect, axis=0)\n                lines = np.append(lines, point, axis=0)\n                vertex_level = np.append(vertex_level,\n                                         np.zeros(len(point)) +\n                                         lev)\n                level_index = np.append(level_index, np.array(len(point)))\n            else:\n                lines = point\n                connects = np.arange(0, nbr*2).reshape((nbr, 2))\n                vertex_level = np.zeros(len(point)) + lev\n                level_index = np.array(len(point))\n\n            vertex_level = vertex_level.reshape((vertex_level.size, 1))\n\n    return lines, connects, vertex_level, level_index",
  "class IsolineVisual(LineVisual):\n    \"\"\"Isocurves of a tri mesh with data at vertices at different levels.\n\n    Parameters\n    ----------\n    vertices : ndarray, shape (Nv, 3) | None\n        Vertex coordinates.\n    tris : ndarray, shape (Nf, 3) | None\n        Indices into the vertex array.\n    data : ndarray, shape (Nv,) | None\n        scalar at vertices\n    levels : ndarray, shape (Nlev,) | None\n        The levels at which the isocurve is constructed from \"data\".\n    color_lev : Color, tuple, colormap name or array\n        The color to use when drawing the line. If an array is given, it\n        must be of shape (Nlev, 4) and provide one rgba color by level.\n    **kwargs : dict\n        Keyword arguments to pass to `LineVisual`.\n    \"\"\"\n\n    def __init__(self, vertices=None, tris=None, data=None,\n                 levels=None, color_lev=None, **kwargs):\n        self._data = None\n        self._vertices = None\n        self._tris = None\n        self._levels = levels\n        self._color_lev = color_lev\n        self._need_color_update = True\n        self._need_recompute = True\n        self._v = None\n        self._c = None\n        self._vl = None\n        self._li = None\n        self._lc = None\n        self._cl = None\n        self._update_color_lev = False\n        kwargs['antialias'] = False\n        LineVisual.__init__(self, method='gl', **kwargs)\n        self.set_data(vertices=vertices, tris=tris, data=data)\n\n    @property\n    def levels(self):\n        \"\"\"The threshold at which the isocurves are constructed from the data.\"\"\"\n        return self._levels\n\n    @levels.setter\n    def levels(self, levels):\n        self._levels = levels\n        self._need_recompute = True\n        self.update()\n\n    @property\n    def data(self):\n        \"\"\"The mesh data\"\"\"\n        return self._vertices, self._tris, self._data\n\n    def set_data(self, vertices=None, tris=None, data=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        vertices : ndarray, shape (Nv, 3) | None\n            Vertex coordinates.\n        tris : ndarray, shape (Nf, 3) | None\n            Indices into the vertex array.\n        data : ndarray, shape (Nv,) | None\n            scalar at vertices\n        \"\"\"\n        # modifier pour tenier compte des None self._recompute = True\n        if data is not None:\n            self._data = data\n            self._need_recompute = True\n        if vertices is not None:\n            self._vertices = vertices\n            self._need_recompute = True\n        if tris is not None:\n            self._tris = tris\n            self._need_recompute = True\n        self.update()\n\n    @property\n    def color(self):\n        return self._color_lev\n\n    def set_color(self, color):\n        \"\"\"Set the color\n\n        Parameters\n        ----------\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        if color is not None:\n            self._color_lev = color\n            self._need_color_update = True\n            self.update()\n\n    def _levels_to_colors(self):\n        # computes ColorArrays for given levels\n        # try _color_lev as colormap, except as everything else\n        try:\n            f_color_levs = get_colormap(self._color_lev)\n        except (KeyError, TypeError):\n            colors = ColorArray(self._color_lev).rgba\n        else:\n            lev = _normalize(self._levels, self._levels.min(),\n                             self._levels.max())\n            # map function expects (Nlev,1)!\n            colors = f_color_levs.map(lev[:, np.newaxis])\n\n        if len(colors) == 1:\n            colors = colors * np.ones((len(self._levels), 1))\n\n        # detect color/level mismatch and raise error\n        if (len(colors) != len(self._levels)):\n            raise TypeError(\"Color/level mismatch. Color must be of shape \"\n                            \"(Nlev, ...) and provide one color per level\")\n\n        self._lc = colors\n\n    def _compute_iso_color(self):\n        \"\"\"Compute LineVisual color from level index and corresponding level color\"\"\"\n        level_color = []\n        colors = self._lc\n        for i, index in enumerate(self._li):\n            level_color.append(np.zeros((index, 4)) + colors[i])\n        self._cl = np.vstack(level_color)\n\n    def _prepare_draw(self, view):\n        if (self._data is None or self._levels is None or self._tris is None or\n                self._vertices is None or self._color_lev is None):\n            return False\n\n        if self._need_recompute:\n            self._v, self._c, self._vl, self._li = iso_mesh_line(\n                self._vertices, self._tris, self._data, self._levels)\n            self._levels_to_colors()\n            self._compute_iso_color()\n            LineVisual.set_data(self, pos=self._v, connect=self._c,\n                                color=self._cl)\n            self._need_recompute = False\n\n        if self._need_color_update:\n            self._levels_to_colors()\n            self._compute_iso_color()\n            LineVisual.set_data(self, color=self._cl)\n            self._update_color_lev = False\n\n        return LineVisual._prepare_draw(self, view)",
  "def __init__(self, vertices=None, tris=None, data=None,\n                 levels=None, color_lev=None, **kwargs):\n        self._data = None\n        self._vertices = None\n        self._tris = None\n        self._levels = levels\n        self._color_lev = color_lev\n        self._need_color_update = True\n        self._need_recompute = True\n        self._v = None\n        self._c = None\n        self._vl = None\n        self._li = None\n        self._lc = None\n        self._cl = None\n        self._update_color_lev = False\n        kwargs['antialias'] = False\n        LineVisual.__init__(self, method='gl', **kwargs)\n        self.set_data(vertices=vertices, tris=tris, data=data)",
  "def levels(self):\n        \"\"\"The threshold at which the isocurves are constructed from the data.\"\"\"\n        return self._levels",
  "def levels(self, levels):\n        self._levels = levels\n        self._need_recompute = True\n        self.update()",
  "def data(self):\n        \"\"\"The mesh data\"\"\"\n        return self._vertices, self._tris, self._data",
  "def set_data(self, vertices=None, tris=None, data=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        vertices : ndarray, shape (Nv, 3) | None\n            Vertex coordinates.\n        tris : ndarray, shape (Nf, 3) | None\n            Indices into the vertex array.\n        data : ndarray, shape (Nv,) | None\n            scalar at vertices\n        \"\"\"\n        # modifier pour tenier compte des None self._recompute = True\n        if data is not None:\n            self._data = data\n            self._need_recompute = True\n        if vertices is not None:\n            self._vertices = vertices\n            self._need_recompute = True\n        if tris is not None:\n            self._tris = tris\n            self._need_recompute = True\n        self.update()",
  "def color(self):\n        return self._color_lev",
  "def set_color(self, color):\n        \"\"\"Set the color\n\n        Parameters\n        ----------\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        if color is not None:\n            self._color_lev = color\n            self._need_color_update = True\n            self.update()",
  "def _levels_to_colors(self):\n        # computes ColorArrays for given levels\n        # try _color_lev as colormap, except as everything else\n        try:\n            f_color_levs = get_colormap(self._color_lev)\n        except (KeyError, TypeError):\n            colors = ColorArray(self._color_lev).rgba\n        else:\n            lev = _normalize(self._levels, self._levels.min(),\n                             self._levels.max())\n            # map function expects (Nlev,1)!\n            colors = f_color_levs.map(lev[:, np.newaxis])\n\n        if len(colors) == 1:\n            colors = colors * np.ones((len(self._levels), 1))\n\n        # detect color/level mismatch and raise error\n        if (len(colors) != len(self._levels)):\n            raise TypeError(\"Color/level mismatch. Color must be of shape \"\n                            \"(Nlev, ...) and provide one color per level\")\n\n        self._lc = colors",
  "def _compute_iso_color(self):\n        \"\"\"Compute LineVisual color from level index and corresponding level color\"\"\"\n        level_color = []\n        colors = self._lc\n        for i, index in enumerate(self._li):\n            level_color.append(np.zeros((index, 4)) + colors[i])\n        self._cl = np.vstack(level_color)",
  "def _prepare_draw(self, view):\n        if (self._data is None or self._levels is None or self._tris is None or\n                self._vertices is None or self._color_lev is None):\n            return False\n\n        if self._need_recompute:\n            self._v, self._c, self._vl, self._li = iso_mesh_line(\n                self._vertices, self._tris, self._data, self._levels)\n            self._levels_to_colors()\n            self._compute_iso_color()\n            LineVisual.set_data(self, pos=self._v, connect=self._c,\n                                color=self._cl)\n            self._need_recompute = False\n\n        if self._need_color_update:\n            self._levels_to_colors()\n            self._compute_iso_color()\n            LineVisual.set_data(self, color=self._cl)\n            self._update_color_lev = False\n\n        return LineVisual._prepare_draw(self, view)",
  "class BoxVisual(CompoundVisual):\n    \"\"\"Visual that displays a box.\n\n    Parameters\n    ----------\n    width : float\n        Box width.\n    height : float\n        Box height.\n    depth : float\n        Box depth.\n    width_segments : int\n        Box segments count along the width.\n    height_segments : float\n        Box segments count along the height.\n    depth_segments : float\n        Box segments count along the depth.\n    planes: array_like\n        Any combination of ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Included planes in the box construction.\n    vertex_colors : ndarray\n        Same as for `MeshVisual` class. See `create_plane` for vertex ordering.\n    face_colors : ndarray\n        Same as for `MeshVisual` class. See `create_plane` for vertex ordering.\n    color : Color\n        The `Color` to use when drawing the cube faces.\n    edge_color : tuple or Color\n        The `Color` to use when drawing the cube edges. If `None`, then no\n        cube edges are drawn.\n    \"\"\"\n\n    def __init__(self, width=1, height=1, depth=1, width_segments=1,\n                 height_segments=1, depth_segments=1, planes=None,\n                 vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, **kwargs):\n        vertices, filled_indices, outline_indices = create_box(\n            width, height, depth, width_segments, height_segments,\n            depth_segments, planes)\n\n        self._mesh = MeshVisual(vertices['position'], filled_indices,\n                                vertex_colors, face_colors, color)\n        if edge_color:\n            self._border = MeshVisual(vertices['position'], outline_indices,\n                                      color=edge_color, mode='lines')\n        else:\n            self._border = MeshVisual()\n\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self.mesh.set_gl_state(polygon_offset_fill=True,\n                               polygon_offset=(1, 1), depth_test=True)\n\n    @property\n    def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to fill in.\"\"\"\n        return self._mesh\n\n    @mesh.setter\n    def mesh(self, mesh):\n        self._mesh = mesh\n\n    @property\n    def border(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to draw the border.\"\"\"\n        return self._border\n\n    @border.setter\n    def border(self, border):\n        self._border = border",
  "def __init__(self, width=1, height=1, depth=1, width_segments=1,\n                 height_segments=1, depth_segments=1, planes=None,\n                 vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, **kwargs):\n        vertices, filled_indices, outline_indices = create_box(\n            width, height, depth, width_segments, height_segments,\n            depth_segments, planes)\n\n        self._mesh = MeshVisual(vertices['position'], filled_indices,\n                                vertex_colors, face_colors, color)\n        if edge_color:\n            self._border = MeshVisual(vertices['position'], outline_indices,\n                                      color=edge_color, mode='lines')\n        else:\n            self._border = MeshVisual()\n\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self.mesh.set_gl_state(polygon_offset_fill=True,\n                               polygon_offset=(1, 1), depth_test=True)",
  "def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to fill in.\"\"\"\n        return self._mesh",
  "def mesh(self, mesh):\n        self._mesh = mesh",
  "def border(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to draw the border.\"\"\"\n        return self._border",
  "def border(self, border):\n        self._border = border",
  "class AxisVisual(CompoundVisual):\n    \"\"\"Axis visual\n\n    Parameters\n    ----------\n    pos : array\n        Co-ordinates of start and end of the axis.\n    domain : tuple\n        The data values at the beginning and end of the axis, used for tick\n        labels. i.e. (5, 10) means the axis starts at 5 and ends at 10. Default\n        is (0, 1).\n    tick_direction : array\n        The tick direction to use (in document coordinates).\n    scale_type : str\n        The type of scale. For now only 'linear' is supported.\n    axis_color : tuple\n        RGBA values for the axis colour. Default is black.\n    tick_color : tuple\n        RGBA values for the tick colours. The colour for the major and minor\n        ticks is currently fixed to be the same. Default is a dark grey.\n    text_color : Color\n        The color to use for drawing tick and axis labels\n    minor_tick_length : float\n        The length of minor ticks, in pixels\n    major_tick_length : float\n        The length of major ticks, in pixels\n    tick_width : float\n        Line width for the ticks\n    tick_label_margin : float\n        Margin between ticks and tick labels\n    tick_font_size : float\n        The font size to use for rendering tick labels.\n    axis_width : float\n        Line width for the axis\n    axis_label : str\n        Text to use for the axis label\n    axis_label_margin : float\n        Margin between ticks and axis labels\n    axis_font_size : float\n        The font size to use for rendering axis labels.\n    font_size : float\n        Font size for both the tick and axis labels. If this is set,\n        tick_font_size and axis_font_size are ignored.\n    anchors : iterable\n        A 2-element iterable (tuple, list, etc.) giving the horizontal and\n        vertical alignment of the tick labels. The first element should be one\n        of 'left', 'center', or 'right', and the second element should be one\n        of 'bottom', 'middle', or 'top'. If this is not specified, it is\n        determined automatically.\n    \"\"\"\n\n    def __init__(self, pos=None, domain=(0., 1.), \n                 tick_direction=(-1., 0.), \n                 scale_type=\"linear\", \n                 axis_color=(1, 1, 1), \n                 tick_color=(0.7, 0.7, 0.7), \n                 text_color='w', \n                 minor_tick_length=5, \n                 major_tick_length=10, \n                 tick_width=2, \n                 tick_label_margin=12, \n                 tick_font_size=8, \n                 axis_width=3, \n                 axis_label=None, \n                 axis_label_margin=35, \n                 axis_font_size=10, \n                 font_size=None, \n                 anchors=None):\n\n        if scale_type != 'linear':\n            raise NotImplementedError('only linear scaling is currently '\n                                      'supported')\n\n        if font_size is not None:\n            tick_font_size = font_size\n            axis_font_size = font_size\n\n        self._pos = None\n        self._domain = None\n\n        # If True, then axis stops at the first / last major tick.\n        # If False, then axis extends to edge of *pos*\n        # (private until we come up with a better name for this)\n        self._stop_at_major = (False, False)\n\n        self.ticker = Ticker(self, anchors=anchors)\n        self.tick_direction = np.array(tick_direction, float)\n        self.scale_type = scale_type\n\n        self._minor_tick_length = minor_tick_length  # px\n        self._major_tick_length = major_tick_length  # px\n        self._tick_label_margin = tick_label_margin  # px\n        self._axis_label_margin = axis_label_margin  # px\n\n        self._axis_label = axis_label\n\n        self._need_update = True\n\n        self._line = LineVisual(method='gl', width=axis_width, antialias=True,\n                                color=axis_color)\n        self._ticks = LineVisual(method='gl', width=tick_width,\n                                 connect='segments', antialias=True,\n                                 color=tick_color)\n\n        self._text = TextVisual(font_size=tick_font_size, color=text_color)\n        self._axis_label_vis = TextVisual(font_size=axis_font_size,\n                                          color=text_color)\n        CompoundVisual.__init__(self, [self._line, self._text, self._ticks,\n                                       self._axis_label_vis])\n        if pos is not None:\n            self.pos = pos\n        self.domain = domain\n\n    @property\n    def text_color(self):\n        return self._text.color\n\n    @text_color.setter\n    def text_color(self, value):\n        self._text.color = value\n        self._axis_label_vis.color = value\n\n    @property\n    def axis_color(self):\n        return self._line.color\n\n    @axis_color.setter\n    def axis_color(self, value):\n        self._line.set_data(color=value)\n\n    @property\n    def axis_width(self):\n        return self._line.width\n\n    @axis_width.setter\n    def axis_width(self, value):\n        self._line.set_data(width=value)\n\n    @property\n    def tick_color(self):\n        return self._ticks.color\n\n    @tick_color.setter\n    def tick_color(self, value):\n        self._ticks.set_data(color=value)\n\n    @property\n    def tick_width(self):\n        return self._ticks.width\n\n    @tick_width.setter\n    def tick_width(self, value):\n        self._ticks.set_data(width=value)\n\n    @property\n    def tick_font_size(self):\n        return self._text.font_size\n\n    @tick_font_size.setter\n    def tick_font_size(self, value):\n        self._text.font_size = value\n\n    @updating_property\n    def tick_direction(self):\n        \"\"\"The tick direction to use (in document coordinates).\"\"\"\n\n    @tick_direction.setter\n    def tick_direction(self, tick_direction):\n        self._tick_direction = np.array(tick_direction, float)\n\n    @property\n    def axis_font_size(self):\n        return self._axis_label_vis.font_size\n\n    @axis_font_size.setter\n    def axis_font_size(self, value):\n        self._axis_label_vis.font_size = value\n\n    @updating_property\n    def domain(self):\n        \"\"\"The data values at the beginning and end of the axis, used for tick labels.\"\"\"\n\n    @updating_property\n    def axis_label(self):\n        \"\"\"Text to use for the axis label.\"\"\"\n\n    @updating_property\n    def pos(self):\n        \"\"\"Co-ordinates of start and end of the axis.\"\"\"\n\n    @pos.setter\n    def pos(self, pos):\n        self._pos = np.array(pos, float)\n\n    @updating_property\n    def minor_tick_length(self):\n        \"\"\"The length of minor ticks, in pixels\"\"\"\n\n    @updating_property\n    def major_tick_length(self):\n        \"\"\"The length of major ticks, in pixels\"\"\"\n\n    @updating_property\n    def tick_label_margin(self):\n        \"\"\"Margin between ticks and tick labels\"\"\"\n\n    @updating_property\n    def axis_label_margin(self):\n        \"\"\"Margin between ticks and axis labels\"\"\"\n\n    @property\n    def _vec(self):\n        \"\"\"Vector in the direction of the axis line\"\"\"\n        return self.pos[1] - self.pos[0]\n\n    def _update_subvisuals(self):\n        tick_pos, labels, tick_label_pos, anchors, axis_label_pos = \\\n            self.ticker.get_update()\n\n        self._line.set_data(pos=self.pos, color=self.axis_color)\n        self._ticks.set_data(pos=tick_pos, color=self.tick_color)\n        self._text.text = list(labels)\n        self._text.pos = tick_label_pos\n        self._text.anchors = anchors\n        if self.axis_label is not None:\n            self._axis_label_vis.text = self.axis_label\n            self._axis_label_vis.pos = axis_label_pos\n        self._need_update = False\n\n    def _prepare_draw(self, view):\n        if self._pos is None:\n            return False\n        if self.axis_label is not None:\n            self._axis_label_vis.rotation = self._rotation_angle\n        if self._need_update:\n            self._update_subvisuals()\n\n    @property\n    def _rotation_angle(self):\n        \"\"\"Determine the rotation angle of the axis as projected onto the canvas.\"\"\"\n        # TODO: make sure we only call get_transform if the transform for\n        # the line is updated\n        tr = self._line.get_transform(map_from='visual', map_to='canvas')\n        trpos = tr.map(self.pos)\n        # Normalize homogeneous coordinates\n        # trpos /= trpos[:, 3:]\n        x1, y1, x2, y2 = trpos[:, :2].ravel()\n        if x1 > x2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        return math.degrees(math.atan2(y2-y1, x2-x1))\n\n    def _compute_bounds(self, axis, view):\n        if axis == 2:\n            return (0., 0.)\n        # now axis in (0, 1)\n        return self.pos[:, axis].min(), self.pos[:, axis].max()",
  "class Ticker(object):\n    \"\"\"Class to determine tick marks\n\n    Parameters\n    ----------\n    axis : instance of AxisVisual\n        The AxisVisual to generate ticks for.\n    \"\"\"\n\n    def __init__(self, axis, anchors=None):\n        self.axis = axis\n        self._anchors = anchors\n\n    def get_update(self):\n        major_tick_fractions, minor_tick_fractions, tick_labels = \\\n            self._get_tick_frac_labels()\n        tick_pos, tick_label_pos, axis_label_pos, anchors = \\\n            self._get_tick_positions(major_tick_fractions,\n                                     minor_tick_fractions)\n        return tick_pos, tick_labels, tick_label_pos, anchors, axis_label_pos\n\n    def _get_tick_positions(self, major_tick_fractions, minor_tick_fractions):\n        # tick direction is defined in visual coords, but use document\n        # coords to determine the tick length\n        trs = self.axis.transforms\n        visual_to_document = trs.get_transform('visual', 'document')\n        direction = np.array(self.axis.tick_direction)\n        direction /= np.linalg.norm(direction)\n\n        if self._anchors is None:\n            # use the document (pixel) coord system to set text anchors\n            anchors = []\n            if direction[0] < 0:\n                anchors.append('right')\n            elif direction[0] > 0:\n                anchors.append('left')\n            else:\n                anchors.append('center')\n            if direction[1] < 0:\n                anchors.append('bottom')\n            elif direction[1] > 0:\n                anchors.append('top')\n            else:\n                anchors.append('middle')\n        else:\n            anchors = self._anchors\n\n        # now figure out the tick positions in visual (data) coords\n        doc_unit = visual_to_document.map([[0, 0], direction[:2]])\n        doc_unit = doc_unit[1] - doc_unit[0]\n        doc_len = np.linalg.norm(doc_unit)\n\n        vectors = np.array([[0., 0.],\n                            direction * self.axis.minor_tick_length / doc_len,\n                            direction * self.axis.major_tick_length / doc_len,\n                            direction * (self.axis.major_tick_length +\n                                         self.axis.tick_label_margin) / doc_len\n                            ],\n                           dtype=float)\n        minor_vector = vectors[1] - vectors[0]\n        major_vector = vectors[2] - vectors[0]\n        label_vector = vectors[3] - vectors[0]\n\n        axislabel_vector = direction * (self.axis.major_tick_length +\n                                        self.axis.axis_label_margin) / doc_len\n\n        major_origins, major_endpoints = self._tile_ticks(\n            major_tick_fractions, major_vector)\n\n        minor_origins, minor_endpoints = self._tile_ticks(\n            minor_tick_fractions, minor_vector)\n\n        tick_label_pos = major_origins + label_vector\n\n        axis_label_pos = 0.5 * (self.axis.pos[0] +\n                                self.axis.pos[1]) + axislabel_vector\n\n        num_major = len(major_tick_fractions)\n        num_minor = len(minor_tick_fractions)\n\n        c = np.empty([(num_major + num_minor) * 2, 2])\n\n        c[0:(num_major-1)*2+1:2] = major_origins\n        c[1:(num_major-1)*2+2:2] = major_endpoints\n        c[(num_major-1)*2+2::2] = minor_origins\n        c[(num_major-1)*2+3::2] = minor_endpoints\n\n        return c, tick_label_pos, axis_label_pos, anchors\n\n    def _tile_ticks(self, frac, tickvec):\n        \"\"\"Tiles tick marks along the axis.\"\"\"\n        origins = np.tile(self.axis._vec, (len(frac), 1))\n        origins = self.axis.pos[0].T + (origins.T*frac).T\n        endpoints = tickvec + origins\n        return origins, endpoints\n\n    def _get_tick_frac_labels(self):\n        \"\"\"Get the major ticks, minor ticks, and major labels\"\"\"\n        minor_num = 4  # number of minor ticks per major division\n        if (self.axis.scale_type == 'linear'):\n            domain = self.axis.domain\n            if domain[1] < domain[0]:\n                flip = True\n                domain = domain[::-1]\n            else:\n                flip = False\n            offset = domain[0]\n            scale = domain[1] - domain[0]\n\n            transforms = self.axis.transforms\n            length = self.axis.pos[1] - self.axis.pos[0]  # in logical coords\n            n_inches = np.sqrt(np.sum(length ** 2)) / transforms.dpi\n\n            major = _get_ticks_talbot(domain[0], domain[1], n_inches, 2)\n\n            labels = ['%g' % x for x in major]\n            majstep = major[1] - major[0]\n            minor = []\n            minstep = majstep / (minor_num + 1)\n            minstart = 0 if self.axis._stop_at_major[0] else -1\n            minstop = -1 if self.axis._stop_at_major[1] else 0\n            for i in range(minstart, len(major) + minstop):\n                maj = major[0] + i * majstep\n                minor.extend(np.linspace(maj + minstep,\n                                         maj + majstep - minstep,\n                                         minor_num))\n            major_frac = major - offset\n            minor_frac = np.array(minor) - offset\n            if scale != 0:  # maybe something better to do here?\n                major_frac /= scale\n                minor_frac /= scale\n            use_mask = (major_frac > -0.0001) & (major_frac < 1.0001)\n            major_frac = major_frac[use_mask]\n            labels = [l for li, l in enumerate(labels) if use_mask[li]]\n            minor_frac = minor_frac[(minor_frac > -0.0001) &\n                                    (minor_frac < 1.0001)]\n            # Flip ticks coordinates if necessary :\n            if flip:\n                major_frac = 1 - major_frac\n                minor_frac = 1 - minor_frac\n        elif self.axis.scale_type == 'logarithmic':\n            return NotImplementedError\n        elif self.axis.scale_type == 'power':\n            return NotImplementedError\n        return major_frac, minor_frac, labels",
  "class MaxNLocator(object):\n    \"\"\"Select no more than N intervals at nice locations.\"\"\"\n\n    def __init__(self, nbins=10, steps=None, trim=True, integer=False,\n                 symmetric=False, prune=None):\n        \"\"\"\n        Keyword args:\n        *nbins*\n            Maximum number of intervals; one less than max number of ticks.\n        *steps*\n            Sequence of nice numbers starting with 1 and ending with 10;\n            e.g., [1, 2, 4, 5, 10]\n        *integer*\n            If True, ticks will take only integer values.\n        *symmetric*\n            If True, autoscaling will result in a range symmetric\n            about zero.\n        *prune*\n            ['lower' | 'upper' | 'both' | None]\n            Remove edge ticks -- useful for stacked or ganged plots\n            where the upper tick of one axes overlaps with the lower\n            tick of the axes above it.\n            If prune=='lower', the smallest tick will\n            be removed.  If prune=='upper', the largest tick will be\n            removed.  If prune=='both', the largest and smallest ticks\n            will be removed.  If prune==None, no ticks will be removed.\n        \"\"\"\n        self._nbins = int(nbins)\n        self._trim = trim\n        self._integer = integer\n        self._symmetric = symmetric\n        if prune is not None and prune not in ['upper', 'lower', 'both']:\n            raise ValueError(\n                \"prune must be 'upper', 'lower', 'both', or None\")\n        self._prune = prune\n        if steps is None:\n            steps = [1, 2, 2.5, 3, 4, 5, 6, 8, 10]\n        else:\n            if int(steps[-1]) != 10:\n                steps = list(steps)\n                steps.append(10)\n        self._steps = steps\n        self._integer = integer\n        if self._integer:\n            self._steps = [n for n in self._steps\n                           if divmod(n, 1)[1] < 0.001]\n\n    def bin_boundaries(self, vmin, vmax):\n        nbins = self._nbins\n        scale, offset = scale_range(vmin, vmax, nbins)\n        if self._integer:\n            scale = max(1, scale)\n        vmin = vmin - offset\n        vmax = vmax - offset\n        raw_step = (vmax - vmin) / nbins\n        scaled_raw_step = raw_step / scale\n        best_vmax = vmax\n        best_vmin = vmin\n\n        for step in self._steps:\n            if step < scaled_raw_step:\n                continue\n            step *= scale\n            best_vmin = step * divmod(vmin, step)[0]\n            best_vmax = best_vmin + step * nbins\n            if (best_vmax >= vmax):\n                break\n        if self._trim:\n            extra_bins = int(divmod((best_vmax - vmax), step)[0])\n            nbins -= extra_bins\n        return (np.arange(nbins + 1) * step + best_vmin + offset)\n\n    def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)\n\n    def tick_values(self, vmin, vmax):\n        locs = self.bin_boundaries(vmin, vmax)\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return locs\n\n    def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            maxabs = max(abs(dmin), abs(dmax))\n            dmin = -maxabs\n            dmax = maxabs\n        return np.take(self.bin_boundaries(dmin, dmax), [0, -1])",
  "def scale_range(vmin, vmax, n=1, threshold=100):\n    dv = abs(vmax - vmin)\n    if dv == 0:     # maxabsv == 0 is a special case of this.\n        return 1.0, 0.0\n        # Note: this should never occur because\n        # vmin, vmax should have been checked by nonsingular(),\n        # and spread apart if necessary.\n    meanv = 0.5 * (vmax + vmin)\n    if abs(meanv) / dv < threshold:\n        offset = 0\n    elif meanv > 0:\n        ex = divmod(np.log10(meanv), 1)[0]\n        offset = 10 ** ex\n    else:\n        ex = divmod(np.log10(-meanv), 1)[0]\n        offset = -10 ** ex\n    ex = divmod(np.log10(dv / n), 1)[0]\n    scale = 10 ** ex\n    return scale, offset",
  "def _coverage(dmin, dmax, lmin, lmax):\n    return 1 - 0.5 * ((dmax - lmax) ** 2 +\n                      (dmin - lmin) ** 2) / (0.1 * (dmax - dmin)) ** 2",
  "def _coverage_max(dmin, dmax, span):\n    range_ = dmax - dmin\n    if span <= range_:\n        return 1.\n    else:\n        half = (span - range_) / 2.0\n        return 1 - half ** 2 / (0.1 * range_) ** 2",
  "def _density(k, m, dmin, dmax, lmin, lmax):\n    r = (k-1.0) / (lmax-lmin)\n    rt = (m-1.0) / (max(lmax, dmax) - min(lmin, dmin))\n    return 2 - max(r / rt, rt / r)",
  "def _density_max(k, m):\n    return 2 - (k-1.0) / (m-1.0) if k >= m else 1.",
  "def _simplicity(q, Q, j, lmin, lmax, lstep):\n    eps = 1e-10\n    n = len(Q)\n    i = Q.index(q) + 1\n    if ((lmin % lstep) < eps or\n            (lstep - lmin % lstep) < eps) and lmin <= 0 and lmax >= 0:\n        v = 1\n    else:\n        v = 0\n    return (n - i) / (n - 1.0) + v - j",
  "def _simplicity_max(q, Q, j):\n    n = len(Q)\n    i = Q.index(q) + 1\n    return (n - i)/(n - 1.0) + 1. - j",
  "def _get_ticks_talbot(dmin, dmax, n_inches, density=1.):\n    # density * size gives target number of intervals,\n    # density * size + 1 gives target number of tick marks,\n    # the density function converts this back to a density in data units\n    # (not inches)\n    n_inches = max(n_inches, 2.0)  # Set minimum otherwise code can crash :(\n\n    if dmin == dmax:\n        return np.array([dmin, dmax])\n\n    m = density * n_inches + 1.0\n    only_inside = False  # we cull values outside ourselves\n    Q = [1, 5, 2, 2.5, 4, 3]\n    w = [0.25, 0.2, 0.5, 0.05]\n    best_score = -2.0\n    best = None\n\n    j = 1.0\n    n_max = 1000\n    while j < n_max:\n        for q in Q:\n            sm = _simplicity_max(q, Q, j)\n\n            if w[0] * sm + w[1] + w[2] + w[3] < best_score:\n                j = n_max\n                break\n\n            k = 2.0\n            while k < n_max:\n                dm = _density_max(k, n_inches)\n\n                if w[0] * sm + w[1] + w[2] * dm + w[3] < best_score:\n                    break\n\n                delta = (dmax-dmin)/(k+1.0)/j/q\n                z = np.ceil(np.log10(delta))\n\n                while z < float('infinity'):\n                    step = j * q * 10 ** z\n                    cm = _coverage_max(dmin, dmax, step*(k-1.0))\n\n                    if (w[0] * sm +\n                            w[1] * cm +\n                            w[2] * dm +\n                            w[3] < best_score):\n                        break\n\n                    min_start = np.floor(dmax/step)*j - (k-1.0)*j\n                    max_start = np.ceil(dmin/step)*j\n\n                    if min_start > max_start:\n                        z = z+1\n                        break\n\n                    for start in range(int(min_start), int(max_start)+1):\n                        lmin = start * (step/j)\n                        lmax = lmin + step*(k-1.0)\n                        lstep = step\n\n                        s = _simplicity(q, Q, j, lmin, lmax, lstep)\n                        c = _coverage(dmin, dmax, lmin, lmax)\n                        d = _density(k, m, dmin, dmax, lmin, lmax)\n                        leg = 1.  # _legibility(lmin, lmax, lstep)\n\n                        score = w[0] * s + w[1] * c + w[2] * d + w[3] * leg\n\n                        if (score > best_score and\n                                (not only_inside or (lmin >= dmin and\n                                                     lmax <= dmax))):\n                            best_score = score\n                            best = (lmin, lmax, lstep, q, k)\n                    z += 1\n                k += 1\n            if k == n_max:\n                raise RuntimeError('could not converge on ticks')\n        j += 1\n    if j == n_max:\n        raise RuntimeError('could not converge on ticks')\n\n    if best is None:\n        raise RuntimeError('could not converge on ticks')\n    return np.arange(best[4]) * best[2] + best[0]",
  "def __init__(self, pos=None, domain=(0., 1.), \n                 tick_direction=(-1., 0.), \n                 scale_type=\"linear\", \n                 axis_color=(1, 1, 1), \n                 tick_color=(0.7, 0.7, 0.7), \n                 text_color='w', \n                 minor_tick_length=5, \n                 major_tick_length=10, \n                 tick_width=2, \n                 tick_label_margin=12, \n                 tick_font_size=8, \n                 axis_width=3, \n                 axis_label=None, \n                 axis_label_margin=35, \n                 axis_font_size=10, \n                 font_size=None, \n                 anchors=None):\n\n        if scale_type != 'linear':\n            raise NotImplementedError('only linear scaling is currently '\n                                      'supported')\n\n        if font_size is not None:\n            tick_font_size = font_size\n            axis_font_size = font_size\n\n        self._pos = None\n        self._domain = None\n\n        # If True, then axis stops at the first / last major tick.\n        # If False, then axis extends to edge of *pos*\n        # (private until we come up with a better name for this)\n        self._stop_at_major = (False, False)\n\n        self.ticker = Ticker(self, anchors=anchors)\n        self.tick_direction = np.array(tick_direction, float)\n        self.scale_type = scale_type\n\n        self._minor_tick_length = minor_tick_length  # px\n        self._major_tick_length = major_tick_length  # px\n        self._tick_label_margin = tick_label_margin  # px\n        self._axis_label_margin = axis_label_margin  # px\n\n        self._axis_label = axis_label\n\n        self._need_update = True\n\n        self._line = LineVisual(method='gl', width=axis_width, antialias=True,\n                                color=axis_color)\n        self._ticks = LineVisual(method='gl', width=tick_width,\n                                 connect='segments', antialias=True,\n                                 color=tick_color)\n\n        self._text = TextVisual(font_size=tick_font_size, color=text_color)\n        self._axis_label_vis = TextVisual(font_size=axis_font_size,\n                                          color=text_color)\n        CompoundVisual.__init__(self, [self._line, self._text, self._ticks,\n                                       self._axis_label_vis])\n        if pos is not None:\n            self.pos = pos\n        self.domain = domain",
  "def text_color(self):\n        return self._text.color",
  "def text_color(self, value):\n        self._text.color = value\n        self._axis_label_vis.color = value",
  "def axis_color(self):\n        return self._line.color",
  "def axis_color(self, value):\n        self._line.set_data(color=value)",
  "def axis_width(self):\n        return self._line.width",
  "def axis_width(self, value):\n        self._line.set_data(width=value)",
  "def tick_color(self):\n        return self._ticks.color",
  "def tick_color(self, value):\n        self._ticks.set_data(color=value)",
  "def tick_width(self):\n        return self._ticks.width",
  "def tick_width(self, value):\n        self._ticks.set_data(width=value)",
  "def tick_font_size(self):\n        return self._text.font_size",
  "def tick_font_size(self, value):\n        self._text.font_size = value",
  "def tick_direction(self):\n        \"\"\"The tick direction to use (in document coordinates).\"\"\"",
  "def tick_direction(self, tick_direction):\n        self._tick_direction = np.array(tick_direction, float)",
  "def axis_font_size(self):\n        return self._axis_label_vis.font_size",
  "def axis_font_size(self, value):\n        self._axis_label_vis.font_size = value",
  "def domain(self):\n        \"\"\"The data values at the beginning and end of the axis, used for tick labels.\"\"\"",
  "def axis_label(self):\n        \"\"\"Text to use for the axis label.\"\"\"",
  "def pos(self):\n        \"\"\"Co-ordinates of start and end of the axis.\"\"\"",
  "def pos(self, pos):\n        self._pos = np.array(pos, float)",
  "def minor_tick_length(self):\n        \"\"\"The length of minor ticks, in pixels\"\"\"",
  "def major_tick_length(self):\n        \"\"\"The length of major ticks, in pixels\"\"\"",
  "def tick_label_margin(self):\n        \"\"\"Margin between ticks and tick labels\"\"\"",
  "def axis_label_margin(self):\n        \"\"\"Margin between ticks and axis labels\"\"\"",
  "def _vec(self):\n        \"\"\"Vector in the direction of the axis line\"\"\"\n        return self.pos[1] - self.pos[0]",
  "def _update_subvisuals(self):\n        tick_pos, labels, tick_label_pos, anchors, axis_label_pos = \\\n            self.ticker.get_update()\n\n        self._line.set_data(pos=self.pos, color=self.axis_color)\n        self._ticks.set_data(pos=tick_pos, color=self.tick_color)\n        self._text.text = list(labels)\n        self._text.pos = tick_label_pos\n        self._text.anchors = anchors\n        if self.axis_label is not None:\n            self._axis_label_vis.text = self.axis_label\n            self._axis_label_vis.pos = axis_label_pos\n        self._need_update = False",
  "def _prepare_draw(self, view):\n        if self._pos is None:\n            return False\n        if self.axis_label is not None:\n            self._axis_label_vis.rotation = self._rotation_angle\n        if self._need_update:\n            self._update_subvisuals()",
  "def _rotation_angle(self):\n        \"\"\"Determine the rotation angle of the axis as projected onto the canvas.\"\"\"\n        # TODO: make sure we only call get_transform if the transform for\n        # the line is updated\n        tr = self._line.get_transform(map_from='visual', map_to='canvas')\n        trpos = tr.map(self.pos)\n        # Normalize homogeneous coordinates\n        # trpos /= trpos[:, 3:]\n        x1, y1, x2, y2 = trpos[:, :2].ravel()\n        if x1 > x2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        return math.degrees(math.atan2(y2-y1, x2-x1))",
  "def _compute_bounds(self, axis, view):\n        if axis == 2:\n            return (0., 0.)\n        # now axis in (0, 1)\n        return self.pos[:, axis].min(), self.pos[:, axis].max()",
  "def __init__(self, axis, anchors=None):\n        self.axis = axis\n        self._anchors = anchors",
  "def get_update(self):\n        major_tick_fractions, minor_tick_fractions, tick_labels = \\\n            self._get_tick_frac_labels()\n        tick_pos, tick_label_pos, axis_label_pos, anchors = \\\n            self._get_tick_positions(major_tick_fractions,\n                                     minor_tick_fractions)\n        return tick_pos, tick_labels, tick_label_pos, anchors, axis_label_pos",
  "def _get_tick_positions(self, major_tick_fractions, minor_tick_fractions):\n        # tick direction is defined in visual coords, but use document\n        # coords to determine the tick length\n        trs = self.axis.transforms\n        visual_to_document = trs.get_transform('visual', 'document')\n        direction = np.array(self.axis.tick_direction)\n        direction /= np.linalg.norm(direction)\n\n        if self._anchors is None:\n            # use the document (pixel) coord system to set text anchors\n            anchors = []\n            if direction[0] < 0:\n                anchors.append('right')\n            elif direction[0] > 0:\n                anchors.append('left')\n            else:\n                anchors.append('center')\n            if direction[1] < 0:\n                anchors.append('bottom')\n            elif direction[1] > 0:\n                anchors.append('top')\n            else:\n                anchors.append('middle')\n        else:\n            anchors = self._anchors\n\n        # now figure out the tick positions in visual (data) coords\n        doc_unit = visual_to_document.map([[0, 0], direction[:2]])\n        doc_unit = doc_unit[1] - doc_unit[0]\n        doc_len = np.linalg.norm(doc_unit)\n\n        vectors = np.array([[0., 0.],\n                            direction * self.axis.minor_tick_length / doc_len,\n                            direction * self.axis.major_tick_length / doc_len,\n                            direction * (self.axis.major_tick_length +\n                                         self.axis.tick_label_margin) / doc_len\n                            ],\n                           dtype=float)\n        minor_vector = vectors[1] - vectors[0]\n        major_vector = vectors[2] - vectors[0]\n        label_vector = vectors[3] - vectors[0]\n\n        axislabel_vector = direction * (self.axis.major_tick_length +\n                                        self.axis.axis_label_margin) / doc_len\n\n        major_origins, major_endpoints = self._tile_ticks(\n            major_tick_fractions, major_vector)\n\n        minor_origins, minor_endpoints = self._tile_ticks(\n            minor_tick_fractions, minor_vector)\n\n        tick_label_pos = major_origins + label_vector\n\n        axis_label_pos = 0.5 * (self.axis.pos[0] +\n                                self.axis.pos[1]) + axislabel_vector\n\n        num_major = len(major_tick_fractions)\n        num_minor = len(minor_tick_fractions)\n\n        c = np.empty([(num_major + num_minor) * 2, 2])\n\n        c[0:(num_major-1)*2+1:2] = major_origins\n        c[1:(num_major-1)*2+2:2] = major_endpoints\n        c[(num_major-1)*2+2::2] = minor_origins\n        c[(num_major-1)*2+3::2] = minor_endpoints\n\n        return c, tick_label_pos, axis_label_pos, anchors",
  "def _tile_ticks(self, frac, tickvec):\n        \"\"\"Tiles tick marks along the axis.\"\"\"\n        origins = np.tile(self.axis._vec, (len(frac), 1))\n        origins = self.axis.pos[0].T + (origins.T*frac).T\n        endpoints = tickvec + origins\n        return origins, endpoints",
  "def _get_tick_frac_labels(self):\n        \"\"\"Get the major ticks, minor ticks, and major labels\"\"\"\n        minor_num = 4  # number of minor ticks per major division\n        if (self.axis.scale_type == 'linear'):\n            domain = self.axis.domain\n            if domain[1] < domain[0]:\n                flip = True\n                domain = domain[::-1]\n            else:\n                flip = False\n            offset = domain[0]\n            scale = domain[1] - domain[0]\n\n            transforms = self.axis.transforms\n            length = self.axis.pos[1] - self.axis.pos[0]  # in logical coords\n            n_inches = np.sqrt(np.sum(length ** 2)) / transforms.dpi\n\n            major = _get_ticks_talbot(domain[0], domain[1], n_inches, 2)\n\n            labels = ['%g' % x for x in major]\n            majstep = major[1] - major[0]\n            minor = []\n            minstep = majstep / (minor_num + 1)\n            minstart = 0 if self.axis._stop_at_major[0] else -1\n            minstop = -1 if self.axis._stop_at_major[1] else 0\n            for i in range(minstart, len(major) + minstop):\n                maj = major[0] + i * majstep\n                minor.extend(np.linspace(maj + minstep,\n                                         maj + majstep - minstep,\n                                         minor_num))\n            major_frac = major - offset\n            minor_frac = np.array(minor) - offset\n            if scale != 0:  # maybe something better to do here?\n                major_frac /= scale\n                minor_frac /= scale\n            use_mask = (major_frac > -0.0001) & (major_frac < 1.0001)\n            major_frac = major_frac[use_mask]\n            labels = [l for li, l in enumerate(labels) if use_mask[li]]\n            minor_frac = minor_frac[(minor_frac > -0.0001) &\n                                    (minor_frac < 1.0001)]\n            # Flip ticks coordinates if necessary :\n            if flip:\n                major_frac = 1 - major_frac\n                minor_frac = 1 - minor_frac\n        elif self.axis.scale_type == 'logarithmic':\n            return NotImplementedError\n        elif self.axis.scale_type == 'power':\n            return NotImplementedError\n        return major_frac, minor_frac, labels",
  "def __init__(self, nbins=10, steps=None, trim=True, integer=False,\n                 symmetric=False, prune=None):\n        \"\"\"\n        Keyword args:\n        *nbins*\n            Maximum number of intervals; one less than max number of ticks.\n        *steps*\n            Sequence of nice numbers starting with 1 and ending with 10;\n            e.g., [1, 2, 4, 5, 10]\n        *integer*\n            If True, ticks will take only integer values.\n        *symmetric*\n            If True, autoscaling will result in a range symmetric\n            about zero.\n        *prune*\n            ['lower' | 'upper' | 'both' | None]\n            Remove edge ticks -- useful for stacked or ganged plots\n            where the upper tick of one axes overlaps with the lower\n            tick of the axes above it.\n            If prune=='lower', the smallest tick will\n            be removed.  If prune=='upper', the largest tick will be\n            removed.  If prune=='both', the largest and smallest ticks\n            will be removed.  If prune==None, no ticks will be removed.\n        \"\"\"\n        self._nbins = int(nbins)\n        self._trim = trim\n        self._integer = integer\n        self._symmetric = symmetric\n        if prune is not None and prune not in ['upper', 'lower', 'both']:\n            raise ValueError(\n                \"prune must be 'upper', 'lower', 'both', or None\")\n        self._prune = prune\n        if steps is None:\n            steps = [1, 2, 2.5, 3, 4, 5, 6, 8, 10]\n        else:\n            if int(steps[-1]) != 10:\n                steps = list(steps)\n                steps.append(10)\n        self._steps = steps\n        self._integer = integer\n        if self._integer:\n            self._steps = [n for n in self._steps\n                           if divmod(n, 1)[1] < 0.001]",
  "def bin_boundaries(self, vmin, vmax):\n        nbins = self._nbins\n        scale, offset = scale_range(vmin, vmax, nbins)\n        if self._integer:\n            scale = max(1, scale)\n        vmin = vmin - offset\n        vmax = vmax - offset\n        raw_step = (vmax - vmin) / nbins\n        scaled_raw_step = raw_step / scale\n        best_vmax = vmax\n        best_vmin = vmin\n\n        for step in self._steps:\n            if step < scaled_raw_step:\n                continue\n            step *= scale\n            best_vmin = step * divmod(vmin, step)[0]\n            best_vmax = best_vmin + step * nbins\n            if (best_vmax >= vmax):\n                break\n        if self._trim:\n            extra_bins = int(divmod((best_vmax - vmax), step)[0])\n            nbins -= extra_bins\n        return (np.arange(nbins + 1) * step + best_vmin + offset)",
  "def __call__(self):\n        vmin, vmax = self.axis.get_view_interval()\n        return self.tick_values(vmin, vmax)",
  "def tick_values(self, vmin, vmax):\n        locs = self.bin_boundaries(vmin, vmax)\n        prune = self._prune\n        if prune == 'lower':\n            locs = locs[1:]\n        elif prune == 'upper':\n            locs = locs[:-1]\n        elif prune == 'both':\n            locs = locs[1:-1]\n        return locs",
  "def view_limits(self, dmin, dmax):\n        if self._symmetric:\n            maxabs = max(abs(dmin), abs(dmax))\n            dmin = -maxabs\n            dmax = maxabs\n        return np.take(self.bin_boundaries(dmin, dmax), [0, -1])",
  "class ScrollingLinesVisual(Visual):\n    \"\"\"Displays many line strips of equal length, with the option to add new\n    vertex data to one end of the lines.\n\n    Parameters\n    ----------\n    n_lines : int\n        The number of independent line strips to draw.\n    line_size : int\n        The number of samples in each line strip.\n    dx : float\n        The x distance between samples\n    color : array-like\n        An array of colors to assign to each line strip.\n    pos_offset : array-like\n        An array of x, y position offsets to apply to each line strip.\n    columns : int\n        Arrange line strips into a grid with this number of columns. This\n        option is not compatible with *pos_offset*.\n    cell_size : tuple\n        The x, y distance between cells in the grid.\n    \"\"\"\n\n    vertex_code = \"\"\"\n    attribute vec2 index;  // .x=line_n, .y=vertex_n\n    uniform sampler2D position;\n    uniform sampler1D pos_offset;\n    uniform sampler1D color_tex;\n    \n    uniform vec2 pos_size;  // x=n_lines, y=n_verts_per_line\n    uniform float offset;  // rolling pointer into vertexes\n    uniform float dx;  // x step per sample\n    \n    varying vec2 v_index;\n    varying vec4 v_color;\n    \n    \n    void main() {\n        v_index = vec2(mod(index.y + offset, pos_size.y), index.x);\n        vec2 uv = (v_index + 0.5) / (pos_size.yx);\n        vec4 pos = vec4(index.y * dx, texture2D(position, uv).r, 0, 1);\n        \n        // fetch starting position from texture lookup:\n        pos += vec4(texture1D(pos_offset, (index.x + 0.5) / pos_size.x).rg,\n                              0, 0); \n        \n        gl_Position = $transform(pos);\n        \n        v_color = texture1D(color_tex, (index.x + 0.5) / pos_size.x);\n    }\n    \"\"\"\n\n    fragment_code = \"\"\"\n    varying vec2 v_index;\n    varying vec4 v_color;\n    \n    void main() {\n        if (v_index.y - floor(v_index.y) > 0) {\n            discard;\n        }\n        gl_FragColor = $color;\n    }\n    \"\"\"\n\n    def __init__(self, n_lines, line_size, dx, color=None, pos_offset=None,\n                 columns=None, cell_size=None):\n        self._pos_data = None\n        self._offset = 0\n        self._dx = dx\n\n        data = np.zeros((n_lines, line_size), dtype='float32')\n        self._pos_tex = gloo.Texture2D(data, format='luminance',\n                                       internalformat='r32f')\n        self._index_buf = gloo.VertexBuffer()\n        self._data_shape = data.shape\n\n        Visual.__init__(self, vcode=self.vertex_code, fcode=self.fragment_code)\n\n        self.shared_program['position'] = self._pos_tex\n        self.shared_program['index'] = self._index_buf\n        self.shared_program['dx'] = dx\n        self.shared_program['pos_size'] = data.shape\n        self.shared_program['offset'] = self._offset\n\n        # set an array giving the x/y origin for each plot\n        if pos_offset is None:\n            # construct positions as a grid \n            rows = int(np.ceil(n_lines / columns))\n            pos_offset = np.empty((rows, columns, 3), dtype='float32')\n            pos_offset[..., 0] = (np.arange(columns)[np.newaxis, :] * \n                                  cell_size[0])\n            pos_offset[..., 1] = np.arange(rows)[:, np.newaxis] * cell_size[1]\n            # limit position texture to the number of lines in case there are\n            # more row/column cells than lines\n            pos_offset = pos_offset.reshape((rows*columns), 3)[:n_lines, :]\n        self._pos_offset = gloo.Texture1D(pos_offset, internalformat='rgb32f',\n                                          interpolation='nearest')\n        self.shared_program['pos_offset'] = self._pos_offset\n\n        if color is None:\n            # default to white (1, 1, 1, 1)\n            self._color_tex = gloo.Texture1D(\n                np.ones((n_lines, 4), dtype=np.float32))\n            self.shared_program['color_tex'] = self._color_tex\n            self.shared_program.frag['color'] = 'v_color'\n        else:\n            self._color_tex = gloo.Texture1D(color)\n            self.shared_program['color_tex'] = self._color_tex\n            self.shared_program.frag['color'] = 'v_color'\n\n        # construct a vertex buffer index containing (plot_n, vertex_n) for\n        # each vertex\n        index = np.empty((data.shape[0], data.shape[1], 2), dtype='float32')\n        index[..., 0] = np.arange(data.shape[0])[:, np.newaxis]\n        index[..., 1] = np.arange(data.shape[1])[np.newaxis, :]\n        index = index.reshape((index.shape[0]*index.shape[1], index.shape[2]))\n        self._index_buf.set_data(index)\n\n        self._draw_mode = 'line_strip'\n        self.set_gl_state('translucent', line_width=1)\n        self.freeze()\n\n    def set_pos_offset(self, po):\n        \"\"\"Set the array of position offsets for each line strip.\n\n        Parameters\n        ----------\n        po : array-like\n            An array of xy offset values.\n        \"\"\"\n        self._pos_offset.set_data(po)\n\n    def set_color(self, color):\n        \"\"\"Set the array of colors for each line strip.\n\n        Parameters\n        ----------\n        color : array-like\n            An array of rgba values.\n        \"\"\"\n        self._color_tex.set_data(color)\n\n    def _prepare_transforms(self, view):\n        view.view_program.vert['transform'] = view.get_transform().simplified\n\n    def _prepare_draw(self, view):\n        pass\n\n    def _compute_bounds(self, axis, view):\n        if self._pos_data is None:\n            return None\n        return self._pos_data[..., axis].min(), self.pos_data[..., axis].max()\n\n    def roll_data(self, data):\n        \"\"\"Append new data to the right side of every line strip and remove\n        as much data from the left.\n\n        Parameters\n        ----------\n        data : array-like\n            A data array to append.\n        \"\"\"\n        data = data.astype('float32')[..., np.newaxis]\n        s1 = self._data_shape[1] - self._offset\n        if data.shape[1] > s1:\n            self._pos_tex[:, self._offset:] = data[:, :s1]\n            self._pos_tex[:, :data.shape[1] - s1] = data[:, s1:]\n            self._offset = (self._offset + data.shape[1]) % self._data_shape[1]\n        else:\n            self._pos_tex[:, self._offset:self._offset+data.shape[1]] = data\n            self._offset += data.shape[1]\n        self.shared_program['offset'] = self._offset\n        self.update()\n\n    def set_data(self, index, data):\n        \"\"\"Set the complete data for a single line strip.\n\n        Parameters\n        ----------\n        index : int\n            The index of the line strip to be replaced.\n        data : array-like\n            The data to assign to the selected line strip.\n        \"\"\"\n        self._pos_tex[index, :] = data\n        self.update()",
  "def __init__(self, n_lines, line_size, dx, color=None, pos_offset=None,\n                 columns=None, cell_size=None):\n        self._pos_data = None\n        self._offset = 0\n        self._dx = dx\n\n        data = np.zeros((n_lines, line_size), dtype='float32')\n        self._pos_tex = gloo.Texture2D(data, format='luminance',\n                                       internalformat='r32f')\n        self._index_buf = gloo.VertexBuffer()\n        self._data_shape = data.shape\n\n        Visual.__init__(self, vcode=self.vertex_code, fcode=self.fragment_code)\n\n        self.shared_program['position'] = self._pos_tex\n        self.shared_program['index'] = self._index_buf\n        self.shared_program['dx'] = dx\n        self.shared_program['pos_size'] = data.shape\n        self.shared_program['offset'] = self._offset\n\n        # set an array giving the x/y origin for each plot\n        if pos_offset is None:\n            # construct positions as a grid \n            rows = int(np.ceil(n_lines / columns))\n            pos_offset = np.empty((rows, columns, 3), dtype='float32')\n            pos_offset[..., 0] = (np.arange(columns)[np.newaxis, :] * \n                                  cell_size[0])\n            pos_offset[..., 1] = np.arange(rows)[:, np.newaxis] * cell_size[1]\n            # limit position texture to the number of lines in case there are\n            # more row/column cells than lines\n            pos_offset = pos_offset.reshape((rows*columns), 3)[:n_lines, :]\n        self._pos_offset = gloo.Texture1D(pos_offset, internalformat='rgb32f',\n                                          interpolation='nearest')\n        self.shared_program['pos_offset'] = self._pos_offset\n\n        if color is None:\n            # default to white (1, 1, 1, 1)\n            self._color_tex = gloo.Texture1D(\n                np.ones((n_lines, 4), dtype=np.float32))\n            self.shared_program['color_tex'] = self._color_tex\n            self.shared_program.frag['color'] = 'v_color'\n        else:\n            self._color_tex = gloo.Texture1D(color)\n            self.shared_program['color_tex'] = self._color_tex\n            self.shared_program.frag['color'] = 'v_color'\n\n        # construct a vertex buffer index containing (plot_n, vertex_n) for\n        # each vertex\n        index = np.empty((data.shape[0], data.shape[1], 2), dtype='float32')\n        index[..., 0] = np.arange(data.shape[0])[:, np.newaxis]\n        index[..., 1] = np.arange(data.shape[1])[np.newaxis, :]\n        index = index.reshape((index.shape[0]*index.shape[1], index.shape[2]))\n        self._index_buf.set_data(index)\n\n        self._draw_mode = 'line_strip'\n        self.set_gl_state('translucent', line_width=1)\n        self.freeze()",
  "def set_pos_offset(self, po):\n        \"\"\"Set the array of position offsets for each line strip.\n\n        Parameters\n        ----------\n        po : array-like\n            An array of xy offset values.\n        \"\"\"\n        self._pos_offset.set_data(po)",
  "def set_color(self, color):\n        \"\"\"Set the array of colors for each line strip.\n\n        Parameters\n        ----------\n        color : array-like\n            An array of rgba values.\n        \"\"\"\n        self._color_tex.set_data(color)",
  "def _prepare_transforms(self, view):\n        view.view_program.vert['transform'] = view.get_transform().simplified",
  "def _prepare_draw(self, view):\n        pass",
  "def _compute_bounds(self, axis, view):\n        if self._pos_data is None:\n            return None\n        return self._pos_data[..., axis].min(), self.pos_data[..., axis].max()",
  "def roll_data(self, data):\n        \"\"\"Append new data to the right side of every line strip and remove\n        as much data from the left.\n\n        Parameters\n        ----------\n        data : array-like\n            A data array to append.\n        \"\"\"\n        data = data.astype('float32')[..., np.newaxis]\n        s1 = self._data_shape[1] - self._offset\n        if data.shape[1] > s1:\n            self._pos_tex[:, self._offset:] = data[:, :s1]\n            self._pos_tex[:, :data.shape[1] - s1] = data[:, s1:]\n            self._offset = (self._offset + data.shape[1]) % self._data_shape[1]\n        else:\n            self._pos_tex[:, self._offset:self._offset+data.shape[1]] = data\n            self._offset += data.shape[1]\n        self.shared_program['offset'] = self._offset\n        self.update()",
  "def set_data(self, index, data):\n        \"\"\"Set the complete data for a single line strip.\n\n        Parameters\n        ----------\n        index : int\n            The index of the line strip to be replaced.\n        data : array-like\n            The data to assign to the selected line strip.\n        \"\"\"\n        self._pos_tex[index, :] = data\n        self.update()",
  "class SpectrogramVisual(ImageVisual):\n    \"\"\"Calculate and show a spectrogram\n\n    Parameters\n    ----------\n    x : array-like\n        1D signal to operate on. ``If len(x) < n_fft``, x will be\n        zero-padded to length ``n_fft``.\n    n_fft : int\n        Number of FFT points. Much faster for powers of two.\n    step : int | None\n        Step size between calculations. If None, ``n_fft // 2``\n        will be used.\n    fs : float\n        The sample rate of the data.\n    window : str | None\n        Window function to use. Can be ``'hann'`` for Hann window, or None\n        for no windowing.\n    normalize : bool\n        Normalization of spectrogram values across frequencies.\n    color_scale : {'linear', 'log'}\n        Scale to apply to the result of the STFT.\n        ``'log'`` will use ``10 * log10(power)``.\n    cmap : str\n        Colormap name.\n    clim : str | tuple\n        Colormap limits. Should be ``'auto'`` or a two-element tuple of\n        min and max values.\n    \"\"\"\n\n    def __init__(self, x=None, n_fft=256, step=None, fs=1., window='hann',\n                 normalize=False, color_scale='log', cmap='cubehelix',\n                 clim='auto'):\n        self._x = np.asarray(x)\n        self._n_fft = int(n_fft)\n        self._step = step\n        self._fs = float(fs)\n        self._window = window\n        self._normalize = normalize\n        self._color_scale = color_scale\n\n        if clim == 'auto':\n            self._clim_auto = True\n        else:\n            self._clim_auto = False\n\n        if not isinstance(self._color_scale, str) or \\\n                self._color_scale not in ('log', 'linear'):\n            raise ValueError('color_scale must be \"linear\" or \"log\"')\n\n        data = self._calculate_spectrogram()\n        super(SpectrogramVisual, self).__init__(data, clim=clim, cmap=cmap)\n\n    @property\n    def freqs(self):\n        \"\"\"The spectrogram frequencies\"\"\"\n        return fft_freqs(self._n_fft, self._fs)\n\n    @property\n    def x(self):\n        \"\"\"The original signal\"\"\"\n        return self._x\n\n    @x.setter\n    def x(self, x):\n        self._x = np.asarray(x)\n        self._update_image()\n\n    @property\n    def n_fft(self):\n        \"\"\"The length of fft window\"\"\"\n        return self._n_fft\n\n    @n_fft.setter\n    def n_fft(self, n_fft):\n        self._n_fft = int(n_fft)\n        self._update_image()\n\n    @property\n    def step(self):\n        \"\"\"The step of fft window\"\"\"\n        if self._step is None:\n            return self._n_fft // 2\n        else:\n            return self._step\n\n    @step.setter\n    def step(self, step):\n        self._step = step\n        self._update_image()\n\n    @property\n    def fs(self):\n        \"\"\"The sampling frequency\"\"\"\n        return self._fs\n\n    @fs.setter\n    def fs(self, fs):\n        self._fs = fs\n        self._update_image()\n\n    @property\n    def window(self):\n        \"\"\"The used window function\"\"\"\n        return self._window\n\n    @window.setter\n    def window(self, window):\n        self._window = window\n        self._update_image()\n\n    @property\n    def color_scale(self):\n        \"\"\"The color scale\"\"\"\n        return self._color_scale\n\n    @color_scale.setter\n    def color_scale(self, color_scale):\n        if not isinstance(color_scale, str) or \\\n                color_scale not in ('log', 'linear'):\n            raise ValueError('color_scale must be \"linear\" or \"log\"')\n        self._color_scale = color_scale\n        self._update_image()\n\n    @property\n    def normalize(self):\n        \"\"\"The normalization setting\"\"\"\n        return self._normalize\n\n    @normalize.setter\n    def normalize(self, normalize):\n        self._normalize = normalize\n        self._update_image()\n\n    def _calculate_spectrogram(self):\n        if self._x is not None:\n            x = self._x\n            nan_mean = np.nanmean(x)\n            idx = np.isnan(x)\n            x[idx] = nan_mean\n            data = stft(x, self._n_fft, self._step, self._fs, self._window)\n            data = np.abs(data)\n            data = 20 * np.log10(data) if self._color_scale == 'log' else data\n            if self._normalize:\n                for i in range(data.shape[0]):\n                    data[i, :] -= np.mean(data[i, :])\n                    data[i, :] /= np.std(data[i, :])\n            return data.astype(np.float32)  # ImageVisual will warn if 64-bit\n        else:\n            return None\n\n    def _update_image(self):\n        data = self._calculate_spectrogram()\n        self.set_data(data)\n        self.update()\n        if self._clim_auto:\n            self.clim = 'auto'",
  "def __init__(self, x=None, n_fft=256, step=None, fs=1., window='hann',\n                 normalize=False, color_scale='log', cmap='cubehelix',\n                 clim='auto'):\n        self._x = np.asarray(x)\n        self._n_fft = int(n_fft)\n        self._step = step\n        self._fs = float(fs)\n        self._window = window\n        self._normalize = normalize\n        self._color_scale = color_scale\n\n        if clim == 'auto':\n            self._clim_auto = True\n        else:\n            self._clim_auto = False\n\n        if not isinstance(self._color_scale, str) or \\\n                self._color_scale not in ('log', 'linear'):\n            raise ValueError('color_scale must be \"linear\" or \"log\"')\n\n        data = self._calculate_spectrogram()\n        super(SpectrogramVisual, self).__init__(data, clim=clim, cmap=cmap)",
  "def freqs(self):\n        \"\"\"The spectrogram frequencies\"\"\"\n        return fft_freqs(self._n_fft, self._fs)",
  "def x(self):\n        \"\"\"The original signal\"\"\"\n        return self._x",
  "def x(self, x):\n        self._x = np.asarray(x)\n        self._update_image()",
  "def n_fft(self):\n        \"\"\"The length of fft window\"\"\"\n        return self._n_fft",
  "def n_fft(self, n_fft):\n        self._n_fft = int(n_fft)\n        self._update_image()",
  "def step(self):\n        \"\"\"The step of fft window\"\"\"\n        if self._step is None:\n            return self._n_fft // 2\n        else:\n            return self._step",
  "def step(self, step):\n        self._step = step\n        self._update_image()",
  "def fs(self):\n        \"\"\"The sampling frequency\"\"\"\n        return self._fs",
  "def fs(self, fs):\n        self._fs = fs\n        self._update_image()",
  "def window(self):\n        \"\"\"The used window function\"\"\"\n        return self._window",
  "def window(self, window):\n        self._window = window\n        self._update_image()",
  "def color_scale(self):\n        \"\"\"The color scale\"\"\"\n        return self._color_scale",
  "def color_scale(self, color_scale):\n        if not isinstance(color_scale, str) or \\\n                color_scale not in ('log', 'linear'):\n            raise ValueError('color_scale must be \"linear\" or \"log\"')\n        self._color_scale = color_scale\n        self._update_image()",
  "def normalize(self):\n        \"\"\"The normalization setting\"\"\"\n        return self._normalize",
  "def normalize(self, normalize):\n        self._normalize = normalize\n        self._update_image()",
  "def _calculate_spectrogram(self):\n        if self._x is not None:\n            x = self._x\n            nan_mean = np.nanmean(x)\n            idx = np.isnan(x)\n            x[idx] = nan_mean\n            data = stft(x, self._n_fft, self._step, self._fs, self._window)\n            data = np.abs(data)\n            data = 20 * np.log10(data) if self._color_scale == 'log' else data\n            if self._normalize:\n                for i in range(data.shape[0]):\n                    data[i, :] -= np.mean(data[i, :])\n                    data[i, :] /= np.std(data[i, :])\n            return data.astype(np.float32)  # ImageVisual will warn if 64-bit\n        else:\n            return None",
  "def _update_image(self):\n        data = self._calculate_spectrogram()\n        self.set_data(data)\n        self.update()\n        if self._clim_auto:\n            self.clim = 'auto'",
  "class GridLinesVisual(ImageVisual):\n    \"\"\"Displays regularly spaced grid lines in any coordinate system and at\n    any scale.\n\n    Parameters\n    ----------\n    scale : tuple\n        The scale factors to apply when determining the spacing of grid lines.\n    color : Color\n        The base color for grid lines. The final color may have its alpha\n        channel modified.\n    \"\"\"\n\n    def __init__(self, scale=(1, 1), color='w'):\n        # todo: PlaneVisual should support subdivide/impostor methods from\n        # image and gridlines should inherit from plane instead.\n        self._grid_color_fn = Function(_GRID_COLOR)\n        self._grid_color_fn['color'] = Color(color).rgba\n        self._grid_color_fn['scale'] = scale\n        ImageVisual.__init__(self, method='impostor')\n        self.set_gl_state('additive', cull_face=False)\n        self.shared_program.frag['get_data'] = self._grid_color_fn\n        cfun = Function('vec4 null(vec4 x) { return x; }')\n        self.shared_program.frag['color_transform'] = cfun\n\n    @property\n    def size(self):\n        return (1, 1)\n\n    def _prepare_transforms(self, view):\n        fn = self._grid_color_fn\n        fn['map_to_doc'] = self.get_transform('visual', 'document')\n        fn['map_doc_to_local'] = self.get_transform('document', 'visual')\n        ImageVisual._prepare_transforms(self, view)\n\n    def _prepare_draw(self, view):\n        if self._need_vertex_update:\n            self._build_vertex_data()\n\n        if view._need_method_update:\n            self._update_method(view)",
  "def __init__(self, scale=(1, 1), color='w'):\n        # todo: PlaneVisual should support subdivide/impostor methods from\n        # image and gridlines should inherit from plane instead.\n        self._grid_color_fn = Function(_GRID_COLOR)\n        self._grid_color_fn['color'] = Color(color).rgba\n        self._grid_color_fn['scale'] = scale\n        ImageVisual.__init__(self, method='impostor')\n        self.set_gl_state('additive', cull_face=False)\n        self.shared_program.frag['get_data'] = self._grid_color_fn\n        cfun = Function('vec4 null(vec4 x) { return x; }')\n        self.shared_program.frag['color_transform'] = cfun",
  "def size(self):\n        return (1, 1)",
  "def _prepare_transforms(self, view):\n        fn = self._grid_color_fn\n        fn['map_to_doc'] = self.get_transform('visual', 'document')\n        fn['map_doc_to_local'] = self.get_transform('document', 'visual')\n        ImageVisual._prepare_transforms(self, view)",
  "def _prepare_draw(self, view):\n        if self._need_vertex_update:\n            self._build_vertex_data()\n\n        if view._need_method_update:\n            self._update_method(view)",
  "class IsocurveVisual(LineVisual):\n    \"\"\"Displays an isocurve of a 2D scalar array.\n\n    Parameters\n    ----------\n    data : ndarray | None\n        2D scalar array.\n    levels : ndarray, shape (Nlev,) | None\n        The levels at which the isocurve is constructed from \"*data*\".\n    color_lev : Color, colormap name, tuple, list or array\n        The color to use when drawing the line. If a list is given, it\n        must be of shape (Nlev), if an array is given, it must be of\n        shape (Nlev, ...). and provide one color per level (rgba, colorname).\n    clim : tuple\n        (min, max) limits to apply when mapping level values through a\n        colormap.\n    **kwargs : dict\n        Keyword arguments to pass to `LineVisual`.\n    \"\"\"\n\n    def __init__(self, data=None, levels=None, color_lev=None, clim=None,\n                 **kwargs):\n        self._data = None\n        self._levels = levels\n        self._color_lev = color_lev\n        self._clim = clim\n        self._need_color_update = True\n        self._need_level_update = True\n        self._need_recompute = True\n        self._level_min = None\n        self._data_is_uniform = False\n        self._lc = None\n        self._cl = None\n        self._li = None\n        self._connect = None\n        self._verts = None\n        kwargs['method'] = 'gl'\n        kwargs['antialias'] = False\n        LineVisual.__init__(self, **kwargs)\n        if data is not None:\n            self.set_data(data)\n\n    @property\n    def levels(self):\n        \"\"\"The threshold at which the isocurve is constructed from the\n        2D data.\n        \"\"\"\n        return self._levels\n\n    @levels.setter\n    def levels(self, levels):\n        self._levels = levels\n        self._need_level_update = True\n        self._need_recompute = True\n        self.update()\n\n    @property\n    def color(self):\n        return self._color_lev\n\n    @color.setter\n    def color(self, color):\n        self._color_lev = color\n        self._need_level_update = True\n        self._need_color_update = True\n        self.update()\n\n    def set_data(self, data):\n        \"\"\"Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 2D array of scalar values. The isocurve is constructed to show\n            all locations in the scalar field equal to ``self.levels``.\n        \"\"\"\n        self._data = data\n\n        if self._clim is None:\n            self._clim = (data.min(), data.max())\n\n        # sanity check,\n        # should we raise an error here, since no isolines can be drawn?\n        # for now, _prepare_draw returns False if no isoline can be drawn\n        if self._data.min() != self._data.max():\n            self._data_is_uniform = False\n        else:\n            self._data_is_uniform = True\n\n        self._need_recompute = True\n        self.update()\n\n    def _get_verts_and_connect(self, paths):\n        \"\"\"Retrieve vertices and connects from given paths-list\"\"\"\n        verts = np.vstack(paths)\n        gaps = np.add.accumulate(np.array([len(x) for x in paths])) - 1\n        connect = np.ones(gaps[-1], dtype=bool)\n        connect[gaps[:-1]] = False\n        return verts, connect\n\n    def _compute_iso_line(self):\n        \"\"\"Compute LineVisual vertices, connects and color-index\"\"\"\n        level_index = []\n        connects = []\n        verts = []\n\n        # calculate which level are within data range\n        # this works for now and the existing examples, but should be tested\n        # thoroughly also with the data-sanity check in set_data-function\n        choice = np.nonzero((self.levels > self._data.min()) &\n                            (self._levels < self._data.max()))\n        levels_to_calc = np.array(self.levels)[choice]\n\n        # save minimum level index\n        self._level_min = choice[0][0]\n\n        try:\n            from skimage.measure import find_contours\n        except ImportError:\n            find_contours = None\n\n        for level in levels_to_calc:\n            # if we use skimage isoline algorithm we need to add half a\n            # pixel in both (x,y) dimensions because isolines are aligned to\n            # pixel centers\n            if find_contours is not None:\n                contours = find_contours(self._data, level,\n                                         positive_orientation='high')\n                v, c = self._get_verts_and_connect(contours)\n                # swap row, column to column, row (x, y)\n                v[:, [0, 1]] = v[:, [1, 0]]\n                v += np.array([0.5, 0.5])\n            else:\n                paths = isocurve(self._data.astype(float).T, level,\n                                 extend_to_edge=True, connected=True)\n                v, c = self._get_verts_and_connect(paths)\n\n            level_index.append(v.shape[0])\n            connects.append(np.hstack((c, [False])))\n            verts.append(v)\n\n        self._li = np.hstack(level_index)\n        self._connect = np.hstack(connects)\n        self._verts = np.vstack(verts)\n\n    def _compute_iso_color(self):\n        \"\"\"Compute LineVisual color from level index and corresponding color\"\"\"\n        level_color = []\n        colors = self._lc\n        for i, index in enumerate(self._li):\n            level_color.append(np.zeros((index, 4)) +\n                               colors[i+self._level_min])\n        self._cl = np.vstack(level_color)\n\n    def _levels_to_colors(self):\n        # computes ColorArrays for given levels\n        # try _color_lev as colormap, except as everything else\n        try:\n            f_color_levs = get_colormap(self._color_lev)\n        except (KeyError, TypeError):\n            colors = ColorArray(self._color_lev).rgba\n        else:\n            lev = _normalize(self._levels, self._clim[0], self._clim[1])\n            # map function expects (Nlev,1)!\n            colors = f_color_levs.map(lev[:, np.newaxis])\n\n        # broadcast to (nlev, 4) array\n        if len(colors) == 1:\n            colors = colors * np.ones((len(self._levels), 1))\n\n        # detect color_lev/levels mismatch and raise error\n        if (len(colors) != len(self._levels)):\n            raise TypeError(\"Color/level mismatch. Color must be of shape \"\n                            \"(Nlev, ...) and provide one color per level\")\n\n        self._lc = colors\n\n    def _prepare_draw(self, view):\n        if (self._data is None or self._levels is None or\n                self._color_lev is None or self._data_is_uniform):\n            return False\n\n        if self._need_level_update:\n            self._levels_to_colors()\n            self._need_level_update = False\n\n        if self._need_recompute:\n            self._compute_iso_line()\n            self._compute_iso_color()\n            LineVisual.set_data(self, pos=self._verts, connect=self._connect,\n                                color=self._cl)\n            self._need_recompute = False\n\n        if self._need_color_update:\n            self._compute_iso_color()\n            LineVisual.set_data(self, color=self._cl)\n            self._need_color_update = False\n\n        return LineVisual._prepare_draw(self, view)",
  "def __init__(self, data=None, levels=None, color_lev=None, clim=None,\n                 **kwargs):\n        self._data = None\n        self._levels = levels\n        self._color_lev = color_lev\n        self._clim = clim\n        self._need_color_update = True\n        self._need_level_update = True\n        self._need_recompute = True\n        self._level_min = None\n        self._data_is_uniform = False\n        self._lc = None\n        self._cl = None\n        self._li = None\n        self._connect = None\n        self._verts = None\n        kwargs['method'] = 'gl'\n        kwargs['antialias'] = False\n        LineVisual.__init__(self, **kwargs)\n        if data is not None:\n            self.set_data(data)",
  "def levels(self):\n        \"\"\"The threshold at which the isocurve is constructed from the\n        2D data.\n        \"\"\"\n        return self._levels",
  "def levels(self, levels):\n        self._levels = levels\n        self._need_level_update = True\n        self._need_recompute = True\n        self.update()",
  "def color(self):\n        return self._color_lev",
  "def color(self, color):\n        self._color_lev = color\n        self._need_level_update = True\n        self._need_color_update = True\n        self.update()",
  "def set_data(self, data):\n        \"\"\"Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 2D array of scalar values. The isocurve is constructed to show\n            all locations in the scalar field equal to ``self.levels``.\n        \"\"\"\n        self._data = data\n\n        if self._clim is None:\n            self._clim = (data.min(), data.max())\n\n        # sanity check,\n        # should we raise an error here, since no isolines can be drawn?\n        # for now, _prepare_draw returns False if no isoline can be drawn\n        if self._data.min() != self._data.max():\n            self._data_is_uniform = False\n        else:\n            self._data_is_uniform = True\n\n        self._need_recompute = True\n        self.update()",
  "def _get_verts_and_connect(self, paths):\n        \"\"\"Retrieve vertices and connects from given paths-list\"\"\"\n        verts = np.vstack(paths)\n        gaps = np.add.accumulate(np.array([len(x) for x in paths])) - 1\n        connect = np.ones(gaps[-1], dtype=bool)\n        connect[gaps[:-1]] = False\n        return verts, connect",
  "def _compute_iso_line(self):\n        \"\"\"Compute LineVisual vertices, connects and color-index\"\"\"\n        level_index = []\n        connects = []\n        verts = []\n\n        # calculate which level are within data range\n        # this works for now and the existing examples, but should be tested\n        # thoroughly also with the data-sanity check in set_data-function\n        choice = np.nonzero((self.levels > self._data.min()) &\n                            (self._levels < self._data.max()))\n        levels_to_calc = np.array(self.levels)[choice]\n\n        # save minimum level index\n        self._level_min = choice[0][0]\n\n        try:\n            from skimage.measure import find_contours\n        except ImportError:\n            find_contours = None\n\n        for level in levels_to_calc:\n            # if we use skimage isoline algorithm we need to add half a\n            # pixel in both (x,y) dimensions because isolines are aligned to\n            # pixel centers\n            if find_contours is not None:\n                contours = find_contours(self._data, level,\n                                         positive_orientation='high')\n                v, c = self._get_verts_and_connect(contours)\n                # swap row, column to column, row (x, y)\n                v[:, [0, 1]] = v[:, [1, 0]]\n                v += np.array([0.5, 0.5])\n            else:\n                paths = isocurve(self._data.astype(float).T, level,\n                                 extend_to_edge=True, connected=True)\n                v, c = self._get_verts_and_connect(paths)\n\n            level_index.append(v.shape[0])\n            connects.append(np.hstack((c, [False])))\n            verts.append(v)\n\n        self._li = np.hstack(level_index)\n        self._connect = np.hstack(connects)\n        self._verts = np.vstack(verts)",
  "def _compute_iso_color(self):\n        \"\"\"Compute LineVisual color from level index and corresponding color\"\"\"\n        level_color = []\n        colors = self._lc\n        for i, index in enumerate(self._li):\n            level_color.append(np.zeros((index, 4)) +\n                               colors[i+self._level_min])\n        self._cl = np.vstack(level_color)",
  "def _levels_to_colors(self):\n        # computes ColorArrays for given levels\n        # try _color_lev as colormap, except as everything else\n        try:\n            f_color_levs = get_colormap(self._color_lev)\n        except (KeyError, TypeError):\n            colors = ColorArray(self._color_lev).rgba\n        else:\n            lev = _normalize(self._levels, self._clim[0], self._clim[1])\n            # map function expects (Nlev,1)!\n            colors = f_color_levs.map(lev[:, np.newaxis])\n\n        # broadcast to (nlev, 4) array\n        if len(colors) == 1:\n            colors = colors * np.ones((len(self._levels), 1))\n\n        # detect color_lev/levels mismatch and raise error\n        if (len(colors) != len(self._levels)):\n            raise TypeError(\"Color/level mismatch. Color must be of shape \"\n                            \"(Nlev, ...) and provide one color per level\")\n\n        self._lc = colors",
  "def _prepare_draw(self, view):\n        if (self._data is None or self._levels is None or\n                self._color_lev is None or self._data_is_uniform):\n            return False\n\n        if self._need_level_update:\n            self._levels_to_colors()\n            self._need_level_update = False\n\n        if self._need_recompute:\n            self._compute_iso_line()\n            self._compute_iso_color()\n            LineVisual.set_data(self, pos=self._verts, connect=self._connect,\n                                color=self._cl)\n            self._need_recompute = False\n\n        if self._need_color_update:\n            self._compute_iso_color()\n            LineVisual.set_data(self, color=self._cl)\n            self._need_color_update = False\n\n        return LineVisual._prepare_draw(self, view)",
  "class _BorderVisual(Visual):\n    \"\"\"\n    Visual subclass to display 2D pixel-width borders.\n\n    Parameters\n    ----------\n    pos : tuple (x, y)\n        Position where the colorbar is to be placed with\n        respect to the center of the colorbar\n    halfdim : tuple (half_width, half_height)\n        Half the dimensions of the colorbar measured\n        from the center. That way, the total dimensions\n        of the colorbar is (x - half_width) to (x + half_width)\n        and (y - half_height) to (y + half_height)\n    border_width : float (in px)\n        The width of the border the colormap should have. This measurement\n        is given in pixels\n    border_color : str | vispy.color.Color\n        The color of the border of the colormap. This can either be a\n        str as the color's name or an actual instace of a vipy.color.Color\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, pos, halfdim,\n                 border_width=1.0,\n                 border_color=None,\n                 **kwargs):\n\n        self._pos = pos\n        self._halfdim = halfdim\n        self._border_width = border_width\n        self._border_color = Color(border_color)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n\n    @staticmethod\n    def _prepare_transforms(view):\n\n        program = view.shared_program\n        program.vert['visual_to_doc'] = \\\n            view.transforms.get_transform('visual', 'document')\n        program.vert['doc_to_render'] = \\\n            view.transforms.get_transform('document', 'render')\n\n    @property\n    def visual_border_width(self):\n        \"\"\"The border width in visual coordinates\"\"\"\n        render_to_doc =  \\\n            self.transforms.get_transform('document', 'visual')\n\n        vec = render_to_doc.map([self.border_width, self.border_width, 0])\n        origin = render_to_doc.map([0, 0, 0])\n\n        visual_border_width = [vec[0] - origin[0], vec[1] - origin[1]]\n\n        # we need to flip the y axis because coordinate systems are inverted\n        visual_border_width[1] *= -1\n\n        return visual_border_width\n\n    def _update(self):\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        border_vertices = np.array([\n            [x - halfw, y - halfh],\n            [x - halfw, y - halfh],\n\n            [x + halfw, y - halfh],\n            [x + halfw, y - halfh],\n\n            [x + halfw, y + halfh],\n            [x + halfw, y + halfh],\n\n            [x - halfw, y + halfh],\n            [x - halfw, y + halfh],\n\n            [x - halfw, y - halfh],\n            [x - halfw, y - halfh],\n        ], dtype=np.float32)\n\n        # Direction each vertex should move to correct for line width\n        adjust_dir = np.array([\n            [0, 0], [-1, -1],\n            [0, 0], [1, -1],\n            [0, 0], [1, 1],\n            [0, 0], [-1, 1],\n            [0, 0], [-1, -1],\n        ], dtype=np.float32)\n\n        self.shared_program['a_position'] = border_vertices\n        self.shared_program['a_adjust_dir'] = adjust_dir\n        self.shared_program.vert['border_width'] = float(self._border_width)\n        self.shared_program.frag['border_color'] = self._border_color.rgba\n\n    def _prepare_draw(self, view=None):\n        self._update()\n        self._draw_mode = \"triangle_strip\"\n        return True\n\n    @property\n    def border_width(self):\n        \"\"\"The width of the border\"\"\"\n        return self._border_width\n\n    @border_width.setter\n    def border_width(self, border_width):\n        self._border_width = border_width\n        # positions of text need to be changed accordingly\n        self._update()\n\n    @property\n    def border_color(self):\n        \"\"\"The color of the border in pixels\"\"\"\n        return self._border_color\n\n    @border_color.setter\n    def border_color(self, border_color):\n        self._border_color = Color(border_color)\n        self.shared_program.frag['border_color'] = self._border_color.rgba\n\n    @property\n    def pos(self):\n        \"\"\"The center of the BorderVisual\"\"\"\n        return self._pos\n\n    @pos.setter\n    def pos(self, pos):\n        self._pos = pos\n        self._update()\n\n    @property\n    def halfdim(self):\n        \"\"\"The half-dimensions measured from the center of the BorderVisual\"\"\"\n        return self._halfdim\n\n    @halfdim.setter\n    def halfdim(self, halfdim):\n        self._halfdim = halfdim\n        self._update()",
  "def __init__(self, pos, halfdim,\n                 border_width=1.0,\n                 border_color=None,\n                 **kwargs):\n\n        self._pos = pos\n        self._halfdim = halfdim\n        self._border_width = border_width\n        self._border_color = Color(border_color)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])",
  "def _prepare_transforms(view):\n\n        program = view.shared_program\n        program.vert['visual_to_doc'] = \\\n            view.transforms.get_transform('visual', 'document')\n        program.vert['doc_to_render'] = \\\n            view.transforms.get_transform('document', 'render')",
  "def visual_border_width(self):\n        \"\"\"The border width in visual coordinates\"\"\"\n        render_to_doc =  \\\n            self.transforms.get_transform('document', 'visual')\n\n        vec = render_to_doc.map([self.border_width, self.border_width, 0])\n        origin = render_to_doc.map([0, 0, 0])\n\n        visual_border_width = [vec[0] - origin[0], vec[1] - origin[1]]\n\n        # we need to flip the y axis because coordinate systems are inverted\n        visual_border_width[1] *= -1\n\n        return visual_border_width",
  "def _update(self):\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        border_vertices = np.array([\n            [x - halfw, y - halfh],\n            [x - halfw, y - halfh],\n\n            [x + halfw, y - halfh],\n            [x + halfw, y - halfh],\n\n            [x + halfw, y + halfh],\n            [x + halfw, y + halfh],\n\n            [x - halfw, y + halfh],\n            [x - halfw, y + halfh],\n\n            [x - halfw, y - halfh],\n            [x - halfw, y - halfh],\n        ], dtype=np.float32)\n\n        # Direction each vertex should move to correct for line width\n        adjust_dir = np.array([\n            [0, 0], [-1, -1],\n            [0, 0], [1, -1],\n            [0, 0], [1, 1],\n            [0, 0], [-1, 1],\n            [0, 0], [-1, -1],\n        ], dtype=np.float32)\n\n        self.shared_program['a_position'] = border_vertices\n        self.shared_program['a_adjust_dir'] = adjust_dir\n        self.shared_program.vert['border_width'] = float(self._border_width)\n        self.shared_program.frag['border_color'] = self._border_color.rgba",
  "def _prepare_draw(self, view=None):\n        self._update()\n        self._draw_mode = \"triangle_strip\"\n        return True",
  "def border_width(self):\n        \"\"\"The width of the border\"\"\"\n        return self._border_width",
  "def border_width(self, border_width):\n        self._border_width = border_width\n        # positions of text need to be changed accordingly\n        self._update()",
  "def border_color(self):\n        \"\"\"The color of the border in pixels\"\"\"\n        return self._border_color",
  "def border_color(self, border_color):\n        self._border_color = Color(border_color)\n        self.shared_program.frag['border_color'] = self._border_color.rgba",
  "def pos(self):\n        \"\"\"The center of the BorderVisual\"\"\"\n        return self._pos",
  "def pos(self, pos):\n        self._pos = pos\n        self._update()",
  "def halfdim(self):\n        \"\"\"The half-dimensions measured from the center of the BorderVisual\"\"\"\n        return self._halfdim",
  "def halfdim(self, halfdim):\n        self._halfdim = halfdim\n        self._update()",
  "def get_default_clim_from_dtype(dtype):\n    \"\"\"Get min and max color limits based on the range of the dtype.\"\"\"\n    # assume floating point data is pre-normalized to 0 and 1\n    if np.issubdtype(dtype, np.floating):\n        return 0, 1\n    # assume integer RGBs fill the whole data space\n    dtype_info = np.iinfo(dtype)\n    dmin = dtype_info.min\n    dmax = dtype_info.max\n    return dmin, dmax",
  "def get_default_clim_from_data(data):\n    \"\"\"Compute a reasonable clim from the min and max, taking nans into account.\n\n    If there are no non-finite values (nan, inf, -inf) this is as fast as it can be.\n    Otherwise, this functions is about 3x slower.\n    \"\"\"\n    # Fast\n    min_value = data.min()\n    max_value = data.max()\n\n    # Need more work? The nan-functions are slower\n    min_finite = np.isfinite(min_value)\n    max_finite = np.isfinite(max_value)\n    if not (min_finite and max_finite):\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size:\n            min_value = finite_data.min()\n            max_value = finite_data.max()\n        else:\n            min_value = max_value = 0  # no finite values in the data\n\n    return min_value, max_value",
  "class _ScaledTextureMixin:\n    \"\"\"Mixin class to make a texture aware of color limits.\n\n    This class contains the shared functionality for the CPU and GPU mixin\n    classes below. In some cases this class provides a \"generic\"\n    implementation of a specific method and is then overridden by one of the\n    subclasses.\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array. A tuple of the shape of the\n        texture can also be given. However, some subclasses may benefit from\n        or even require a numpy array to make decisions based on shape **and**\n        dtype.\n    **texture_kwargs\n        Any other keyword arguments to pass to the parent TextureXD class.\n\n    \"\"\"\n\n    def __init__(self, data=None, **texture_kwargs):\n        self._clim = None\n        self._data_dtype = None\n        data, texture_kwargs = self.init_scaling_texture(data, **texture_kwargs)\n        # Call the __init__ of the TextureXD class\n        super().__init__(data, **texture_kwargs)\n\n    def init_scaling_texture(self, data=None, internalformat=None, **texture_kwargs):\n        \"\"\"Initialize scaling properties and create a representative array.\"\"\"\n        self._data_dtype = getattr(data, 'dtype', None)\n        data = self._create_rep_array(data)\n        internalformat = self._get_texture_format_for_data(\n            data,\n            internalformat)\n        texture_kwargs['internalformat'] = internalformat\n        return data, texture_kwargs\n\n    def _get_texture_format_for_data(self, data, internalformat):\n        return internalformat\n\n    @property\n    def clim(self):\n        \"\"\"Color limits of the texture's data.\"\"\"\n        return self._clim\n\n    def set_clim(self, clim):\n        \"\"\"Set clim and return if a texture update is needed.\n\n        In this default implementation, it is assumed changing the color limit\n        never requires re-uploading the data to the texture (always return\n        ``False``).\n\n        \"\"\"\n        need_texture_upload = False\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n            self._clim = clim\n        else:\n            try:\n                cmin, cmax = clim\n            except (ValueError, TypeError):\n                raise ValueError('clim must have two elements')\n            self._clim = (cmin, cmax)\n        return need_texture_upload\n\n    @property\n    def clim_normalized(self):\n        \"\"\"Normalize current clims to match texture data inside the shader.\n\n        If data is scaled on the CPU then the texture data will be in the range\n        0-1 in the _build_texture() method. Inside the fragment shader the\n        final contrast adjustment will be applied based on this normalized\n        ``clim``.\n\n        \"\"\"\n        if isinstance(self.clim, str) and self.clim == \"auto\":\n            raise RuntimeError(\"Can't return 'auto' normalized color limits \"\n                               \"until data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self._data_dtype is None:\n            raise RuntimeError(\"Can't return normalized color limits until \"\n                               \"data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self.clim[0] == self.clim[1]:\n            return self.clim[0], np.inf\n        # if the internalformat of the texture is normalized we need to\n        # also normalize the clims so they match in-shader\n        clim_min = self.normalize_value(self.clim[0], self._data_dtype)\n        clim_max = self.normalize_value(self.clim[1], self._data_dtype)\n        return clim_min, clim_max\n\n    @property\n    def is_normalized(self):\n        \"\"\"Whether the in-shader representation of this texture is normalized or not.\n\n        Formats ending in 'f' (float), 'ui' (unsigned integer), or 'i'\n        (signed integer) are not normalized in the GPU. Formats ending in \"_snorm\"\n        are normalized on the range [-1, 1] based on the data type of the\n        input data (ex. 0-255 for uint8). Formats with no data type suffix are\n        normalized on the range [0, 1]. See\n        https://www.khronos.org/opengl/wiki/Image_Format for more information.\n\n        This property can be used to determine if input shader variables\n        (uniforms, template variables) need to also be normalized. See\n        :meth:`~BaseTexture.normalize_value` below.\n\n        \"\"\"\n        if self.internalformat is None:\n            return True\n        return self.internalformat[-1] not in ('f', 'i')\n\n    def normalize_value(self, val, input_data_dtype):\n        \"\"\"Normalize values to match in-shader representation of this shader.\n\n        Parameters\n        ----------\n        val : int | float | ndarray\n            Value(s) to normalize.\n        input_data_dtype : numpy.dtype\n            Data type of input data. The assumption is that the provided\n            values to be normalized are in the same range as the input\n            texture data and must be normalized in the same way.\n\n        \"\"\"\n        if not self.is_normalized:\n            return val\n        dtype_info = np.iinfo(input_data_dtype)\n        dmin = dtype_info.min\n        dmax = dtype_info.max\n        val = (val - dmin) / (dmax - dmin)\n        # XXX: Do we need to handle _snorm differently?\n        #  Not currently supported in vispy.\n        return val\n\n    def _data_num_channels(self, data):\n        # if format == 'luminance':\n        #     num_channels = 1\n        if data is not None:\n            # array or shape tuple\n            ndim = getattr(data, 'ndim', len(data))\n            # Ex. (M, N, 3) in Texture2D (ndim=2) -> 3 channels\n            num_channels = data.shape[-1] if ndim == self._ndim + 1 else 1\n        else:\n            num_channels = 4\n        return num_channels\n\n    def _create_rep_array(self, data):\n        \"\"\"Get a representative array with an initial shape.\n\n        Data will be filled in and the texture resized later.\n\n        \"\"\"\n        dtype = getattr(data, 'dtype', np.float32)\n        num_channels = self._data_num_channels(data)\n        init_shape = (10,) * self._ndim + (num_channels,)\n        return np.zeros(init_shape).astype(dtype)\n\n    def check_data_format(self, data):\n        \"\"\"Check if provided data will cause issues if set later.\"\"\"\n        # this texture type has no limitations\n        return\n\n    def scale_and_set_data(self, data, offset=None, copy=False):\n        \"\"\"Upload new data to the GPU.\"\"\"\n        return self.set_data(data, offset=offset, copy=copy)",
  "class CPUScaledTextureMixin(_ScaledTextureMixin):\n    \"\"\"Texture mixin class for smarter scaling decisions.\n\n    This class wraps the logic to normalize data on the CPU before sending\n    it to the GPU (the texture). Pre-scaling on the CPU can be helpful in\n    cases where OpenGL 2/ES requirements limit the texture storage to an\n    8-bit normalized integer internally.\n\n    This class includes optimizations where image data is not re-normalized\n    if the previous normalization can still be used to visualize the data\n    with the new color limits.\n\n    This class should only be used internally. For similar features where\n    scaling occurs on the GPU see\n    :class:`vispy.visuals._scalable_textures.GPUScaledTextureMixin`.\n\n    To use this mixin, a subclass should be created to combine this mixin with\n    the texture class being used. Existing subclasses already exist in this\n    module. Note that this class **must** appear first in the subclass's parent\n    classes so that its ``__init__`` method is called instead of the parent\n    Texture class.\n\n    \"\"\"\n\n    def __init__(self, data=None, **texture_kwargs):\n        self._data_limits = None\n        # Call the __init__ of the mixin base class\n        super().__init__(data, **texture_kwargs)\n\n    def _clim_outside_data_limits(self, cmin, cmax):\n        if self._data_limits is None:\n            return False\n        return cmin < self._data_limits[0] or cmax > self._data_limits[1]\n\n    def set_clim(self, clim):\n        \"\"\"Set clim and return if a texture update is needed.\"\"\"\n        need_texture_upload = False\n        # NOTE: Color limits are not checked against data type limits\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n            need_texture_upload = True\n            self._clim = clim\n        else:\n            try:\n                cmin, cmax = clim\n            except (ValueError, TypeError):\n                raise ValueError('clim must have two elements')\n            if self._clim_outside_data_limits(cmin, cmax):\n                need_texture_upload = True\n            self._clim = (cmin, cmax)\n        return need_texture_upload\n\n    @property\n    def clim_normalized(self):\n        \"\"\"Normalize current clims to match texture data inside the shader.\n\n        If data is scaled on the CPU then the texture data will be in the range\n        0-1 in the _build_texture() method. Inside the fragment shader the\n        final contrast adjustment will be applied based on this normalized\n        ``clim``.\n\n        \"\"\"\n        if isinstance(self.clim, str) and self.clim == \"auto\":\n            raise RuntimeError(\"Can't return 'auto' normalized color limits \"\n                               \"until data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self._data_limits is None:\n            raise RuntimeError(\"Can't return normalized color limits until \"\n                               \"data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n\n        range_min, range_max = self._data_limits\n        clim_min, clim_max = self.clim\n        if clim_min == clim_max:\n            return 0, np.inf\n        clim_min = (clim_min - range_min) / (range_max - range_min)\n        clim_max = (clim_max - range_min) / (range_max - range_min)\n        return clim_min, clim_max\n\n    @staticmethod\n    def _scale_data_on_cpu(data, clim, copy=True):\n        if copy:\n            should_cast_to_f32(data.dtype)\n            data = np.array(data, dtype=np.float32, copy=copy)\n        elif not copy and not np.issubdtype(data.dtype, np.floating):\n            raise ValueError(\"Data must be of floating type for no copying to occur.\")\n\n        if clim[0] != clim[1]:\n            data -= clim[0]\n            data *= 1.0 / (clim[1] - clim[0])\n        if should_cast_to_f32(data.dtype):\n            data = data.astype(np.float32)\n        return data\n\n    def scale_and_set_data(self, data, offset=None, copy=True):\n        \"\"\"Upload new data to the GPU, scaling if necessary.\"\"\"\n        self._data_dtype = data.dtype\n\n        clim = self._clim\n        is_auto = isinstance(clim, str) and clim == 'auto'\n        if data.ndim == self._ndim or data.shape[self._ndim] == 1:\n            if is_auto:\n                clim = get_default_clim_from_data(data)\n            data = self._scale_data_on_cpu(data, clim, copy=copy)\n            data_limits = clim\n        else:\n            data_limits = get_default_clim_from_dtype(data.dtype)\n            if is_auto:\n                clim = data_limits\n\n        self._clim = float(clim[0]), float(clim[1])\n        self._data_limits = data_limits\n        return super().scale_and_set_data(data, offset=offset, copy=copy)",
  "class GPUScaledTextureMixin(_ScaledTextureMixin):\n    \"\"\"Texture class for smarter scaling and internalformat decisions.\n\n    This texture class uses internal formats that are not supported by\n    strict OpenGL 2/ES drivers without additional extensions. By using\n    this texture we upload data to the GPU in a format as close to\n    the original data type as possible (32-bit floats on the CPU are 32-bit\n    floats on the GPU). No normalization/scaling happens on the CPU and\n    all of it happens on the GPU. This should avoid unnecessary data copies\n    as well as provide the highest precision for the final visualization.\n\n    The texture format may either be a GL enum string (ex. 'r32f'), a numpy\n    dtype object (ex. np.float32), or 'auto' which means the texture will\n    try to pick the best format for the provided data. By using 'auto' you\n    also give the texture permission to change formats in the future if\n    new data is provided with a different data type.\n\n    This class should only be used internally. For similar features where\n    scaling occurs on the CPU see\n    :class:`vispy.visuals._scalable_textures.CPUScaledTextureMixin`.\n\n    To use this mixin, a subclass should be created to combine this mixin with\n    the texture class being used. Existing subclasses already exist in this\n    module. Note that this class **must** appear first in the subclass's parent\n    classes so that its ``__init__`` method is called instead of the parent\n    Texture class.\n\n    \"\"\"\n\n    # dtype -> internalformat\n    # 'r' will be replaced (if needed) with rgb or rgba depending on number of bands\n    _texture_dtype_format = {\n        np.float32: 'r32f',\n        np.float64: 'r32f',\n        np.uint8: 'r8',  # uint8 normalized\n        np.uint16: 'r16',  # uint16 normalized\n        # np.int8: 'r8',  # not supported, there are no signed-integer norm formats\n        # np.int16: 'r16',\n        # np.uint32: 'r32ui',  # not supported, no normal formats for 32bit ints\n        # np.int32: 'r32i',\n    }\n    # instance variable that will be used later on\n    _auto_texture_format = False\n\n    def _handle_auto_texture_format(self, texture_format, data):\n        if isinstance(texture_format, str) and texture_format == 'auto':\n            if data is None:\n                warnings.warn(\"'texture_format' set to 'auto' but no data \"\n                              \"provided. Falling back to CPU scaling.\")\n                texture_format = None\n            else:\n                texture_format = data.dtype.type\n                self._auto_texture_format = True\n        return texture_format\n\n    def _get_gl_tex_format(self, texture_format, num_channels):\n        if texture_format and not isinstance(texture_format, str):\n            texture_format = np.dtype(texture_format).type\n            if texture_format not in self._texture_dtype_format:\n                raise ValueError(\"Can't determine internal texture format for '{}'\".format(texture_format))\n            should_cast_to_f32(texture_format)\n            texture_format = self._texture_dtype_format[texture_format]\n        # adjust internalformat for format of data (RGBA vs L)\n        texture_format = texture_format.replace('r', 'rgba'[:num_channels])\n        return texture_format\n\n    def _get_texture_format_for_data(self, data, internalformat):\n        if internalformat is None:\n            raise ValueError(\"'internalformat' must be provided for GPU scaled textures.\")\n        num_channels = self._data_num_channels(data)\n        texture_format = self._handle_auto_texture_format(internalformat, data)\n        texture_format = self._get_gl_tex_format(texture_format, num_channels)\n        return texture_format\n\n    def _compute_clim(self, data):\n        clim = self._clim\n        is_auto = isinstance(clim, str) and clim == 'auto'\n        if data.ndim == self._ndim or data.shape[2] == 1:\n            if is_auto:\n                clim = get_default_clim_from_data(data)\n        elif is_auto:\n            # assume that RGB data is already scaled (0, 1)\n            clim = get_default_clim_from_dtype(data.dtype)\n        return float(clim[0]), float(clim[1])\n\n    def _internalformat_will_change(self, data):\n        shape_repr = self._create_rep_array(data)\n        new_if = self._get_gl_tex_format(data.dtype, shape_repr.shape[-1])\n        return new_if != self.internalformat\n\n    def check_data_format(self, data):\n        \"\"\"Check if provided data will cause issues if set later.\"\"\"\n        if self._internalformat_will_change(data) and not self._auto_texture_format:\n            raise ValueError(\"Data being set would cause a format change \"\n                             \"in the texture. This is only allowed when \"\n                             \"'texture_format' is set to 'auto'.\")\n\n    def _reformat_if_necessary(self, data):\n        if not self._internalformat_will_change(data):\n            return\n        if self._auto_texture_format:\n            shape_repr = self._create_rep_array(data)\n            internalformat = self._get_gl_tex_format(data.dtype, shape_repr.shape[-1])\n            self._resize(data.shape, internalformat=internalformat)\n        else:\n            raise RuntimeError(\"'internalformat' needs to change but \"\n                               \"'texture_format' was not 'auto'.\")\n\n    def scale_and_set_data(self, data, offset=None, copy=False):\n        \"\"\"Upload new data to the GPU, scaling if necessary.\"\"\"\n        self._reformat_if_necessary(data)\n        self._data_dtype = np.dtype(data.dtype)\n        self._clim = self._compute_clim(data)\n        return super().scale_and_set_data(data, offset=offset, copy=copy)",
  "class CPUScaledTexture2D(CPUScaledTextureMixin, Texture2D):\n    \"\"\"Texture class with clim scaling handling builtin.\n\n    See :class:`vispy.visuals._scalable_textures.CPUScaledTextureMixin` for\n    more information.\n\n    \"\"\"",
  "class GPUScaledTexture2D(GPUScaledTextureMixin, Texture2D):\n    \"\"\"Texture class with clim scaling handling builtin.\n\n    See :class:`vispy.visuals._scalable_textures.GPUScaledTextureMixin` for\n    more information.\n\n    \"\"\"",
  "class CPUScaledTexture3D(CPUScaledTextureMixin, Texture3D):\n    \"\"\"Texture class with clim scaling handling builtin.\n\n    See :class:`vispy.visuals._scalable_textures.CPUScaledTextureMixin` for\n    more information.\n\n    \"\"\"",
  "class GPUScaledTextured3D(GPUScaledTextureMixin, Texture3D):\n    \"\"\"Texture class with clim scaling handling builtin.\n\n    See :class:`vispy.visuals._scalable_textures.GPUScaledTextureMixin` for\n    more information.\n\n    \"\"\"",
  "def __init__(self, data=None, **texture_kwargs):\n        self._clim = None\n        self._data_dtype = None\n        data, texture_kwargs = self.init_scaling_texture(data, **texture_kwargs)\n        # Call the __init__ of the TextureXD class\n        super().__init__(data, **texture_kwargs)",
  "def init_scaling_texture(self, data=None, internalformat=None, **texture_kwargs):\n        \"\"\"Initialize scaling properties and create a representative array.\"\"\"\n        self._data_dtype = getattr(data, 'dtype', None)\n        data = self._create_rep_array(data)\n        internalformat = self._get_texture_format_for_data(\n            data,\n            internalformat)\n        texture_kwargs['internalformat'] = internalformat\n        return data, texture_kwargs",
  "def _get_texture_format_for_data(self, data, internalformat):\n        return internalformat",
  "def clim(self):\n        \"\"\"Color limits of the texture's data.\"\"\"\n        return self._clim",
  "def set_clim(self, clim):\n        \"\"\"Set clim and return if a texture update is needed.\n\n        In this default implementation, it is assumed changing the color limit\n        never requires re-uploading the data to the texture (always return\n        ``False``).\n\n        \"\"\"\n        need_texture_upload = False\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n            self._clim = clim\n        else:\n            try:\n                cmin, cmax = clim\n            except (ValueError, TypeError):\n                raise ValueError('clim must have two elements')\n            self._clim = (cmin, cmax)\n        return need_texture_upload",
  "def clim_normalized(self):\n        \"\"\"Normalize current clims to match texture data inside the shader.\n\n        If data is scaled on the CPU then the texture data will be in the range\n        0-1 in the _build_texture() method. Inside the fragment shader the\n        final contrast adjustment will be applied based on this normalized\n        ``clim``.\n\n        \"\"\"\n        if isinstance(self.clim, str) and self.clim == \"auto\":\n            raise RuntimeError(\"Can't return 'auto' normalized color limits \"\n                               \"until data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self._data_dtype is None:\n            raise RuntimeError(\"Can't return normalized color limits until \"\n                               \"data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self.clim[0] == self.clim[1]:\n            return self.clim[0], np.inf\n        # if the internalformat of the texture is normalized we need to\n        # also normalize the clims so they match in-shader\n        clim_min = self.normalize_value(self.clim[0], self._data_dtype)\n        clim_max = self.normalize_value(self.clim[1], self._data_dtype)\n        return clim_min, clim_max",
  "def is_normalized(self):\n        \"\"\"Whether the in-shader representation of this texture is normalized or not.\n\n        Formats ending in 'f' (float), 'ui' (unsigned integer), or 'i'\n        (signed integer) are not normalized in the GPU. Formats ending in \"_snorm\"\n        are normalized on the range [-1, 1] based on the data type of the\n        input data (ex. 0-255 for uint8). Formats with no data type suffix are\n        normalized on the range [0, 1]. See\n        https://www.khronos.org/opengl/wiki/Image_Format for more information.\n\n        This property can be used to determine if input shader variables\n        (uniforms, template variables) need to also be normalized. See\n        :meth:`~BaseTexture.normalize_value` below.\n\n        \"\"\"\n        if self.internalformat is None:\n            return True\n        return self.internalformat[-1] not in ('f', 'i')",
  "def normalize_value(self, val, input_data_dtype):\n        \"\"\"Normalize values to match in-shader representation of this shader.\n\n        Parameters\n        ----------\n        val : int | float | ndarray\n            Value(s) to normalize.\n        input_data_dtype : numpy.dtype\n            Data type of input data. The assumption is that the provided\n            values to be normalized are in the same range as the input\n            texture data and must be normalized in the same way.\n\n        \"\"\"\n        if not self.is_normalized:\n            return val\n        dtype_info = np.iinfo(input_data_dtype)\n        dmin = dtype_info.min\n        dmax = dtype_info.max\n        val = (val - dmin) / (dmax - dmin)\n        # XXX: Do we need to handle _snorm differently?\n        #  Not currently supported in vispy.\n        return val",
  "def _data_num_channels(self, data):\n        # if format == 'luminance':\n        #     num_channels = 1\n        if data is not None:\n            # array or shape tuple\n            ndim = getattr(data, 'ndim', len(data))\n            # Ex. (M, N, 3) in Texture2D (ndim=2) -> 3 channels\n            num_channels = data.shape[-1] if ndim == self._ndim + 1 else 1\n        else:\n            num_channels = 4\n        return num_channels",
  "def _create_rep_array(self, data):\n        \"\"\"Get a representative array with an initial shape.\n\n        Data will be filled in and the texture resized later.\n\n        \"\"\"\n        dtype = getattr(data, 'dtype', np.float32)\n        num_channels = self._data_num_channels(data)\n        init_shape = (10,) * self._ndim + (num_channels,)\n        return np.zeros(init_shape).astype(dtype)",
  "def check_data_format(self, data):\n        \"\"\"Check if provided data will cause issues if set later.\"\"\"\n        # this texture type has no limitations\n        return",
  "def scale_and_set_data(self, data, offset=None, copy=False):\n        \"\"\"Upload new data to the GPU.\"\"\"\n        return self.set_data(data, offset=offset, copy=copy)",
  "def __init__(self, data=None, **texture_kwargs):\n        self._data_limits = None\n        # Call the __init__ of the mixin base class\n        super().__init__(data, **texture_kwargs)",
  "def _clim_outside_data_limits(self, cmin, cmax):\n        if self._data_limits is None:\n            return False\n        return cmin < self._data_limits[0] or cmax > self._data_limits[1]",
  "def set_clim(self, clim):\n        \"\"\"Set clim and return if a texture update is needed.\"\"\"\n        need_texture_upload = False\n        # NOTE: Color limits are not checked against data type limits\n        if isinstance(clim, str):\n            if clim != 'auto':\n                raise ValueError('clim must be \"auto\" if a string')\n            need_texture_upload = True\n            self._clim = clim\n        else:\n            try:\n                cmin, cmax = clim\n            except (ValueError, TypeError):\n                raise ValueError('clim must have two elements')\n            if self._clim_outside_data_limits(cmin, cmax):\n                need_texture_upload = True\n            self._clim = (cmin, cmax)\n        return need_texture_upload",
  "def clim_normalized(self):\n        \"\"\"Normalize current clims to match texture data inside the shader.\n\n        If data is scaled on the CPU then the texture data will be in the range\n        0-1 in the _build_texture() method. Inside the fragment shader the\n        final contrast adjustment will be applied based on this normalized\n        ``clim``.\n\n        \"\"\"\n        if isinstance(self.clim, str) and self.clim == \"auto\":\n            raise RuntimeError(\"Can't return 'auto' normalized color limits \"\n                               \"until data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n        if self._data_limits is None:\n            raise RuntimeError(\"Can't return normalized color limits until \"\n                               \"data has been set. Call \"\n                               \"'scale_and_set_data' first.\")\n\n        range_min, range_max = self._data_limits\n        clim_min, clim_max = self.clim\n        if clim_min == clim_max:\n            return 0, np.inf\n        clim_min = (clim_min - range_min) / (range_max - range_min)\n        clim_max = (clim_max - range_min) / (range_max - range_min)\n        return clim_min, clim_max",
  "def _scale_data_on_cpu(data, clim, copy=True):\n        if copy:\n            should_cast_to_f32(data.dtype)\n            data = np.array(data, dtype=np.float32, copy=copy)\n        elif not copy and not np.issubdtype(data.dtype, np.floating):\n            raise ValueError(\"Data must be of floating type for no copying to occur.\")\n\n        if clim[0] != clim[1]:\n            data -= clim[0]\n            data *= 1.0 / (clim[1] - clim[0])\n        if should_cast_to_f32(data.dtype):\n            data = data.astype(np.float32)\n        return data",
  "def scale_and_set_data(self, data, offset=None, copy=True):\n        \"\"\"Upload new data to the GPU, scaling if necessary.\"\"\"\n        self._data_dtype = data.dtype\n\n        clim = self._clim\n        is_auto = isinstance(clim, str) and clim == 'auto'\n        if data.ndim == self._ndim or data.shape[self._ndim] == 1:\n            if is_auto:\n                clim = get_default_clim_from_data(data)\n            data = self._scale_data_on_cpu(data, clim, copy=copy)\n            data_limits = clim\n        else:\n            data_limits = get_default_clim_from_dtype(data.dtype)\n            if is_auto:\n                clim = data_limits\n\n        self._clim = float(clim[0]), float(clim[1])\n        self._data_limits = data_limits\n        return super().scale_and_set_data(data, offset=offset, copy=copy)",
  "def _handle_auto_texture_format(self, texture_format, data):\n        if isinstance(texture_format, str) and texture_format == 'auto':\n            if data is None:\n                warnings.warn(\"'texture_format' set to 'auto' but no data \"\n                              \"provided. Falling back to CPU scaling.\")\n                texture_format = None\n            else:\n                texture_format = data.dtype.type\n                self._auto_texture_format = True\n        return texture_format",
  "def _get_gl_tex_format(self, texture_format, num_channels):\n        if texture_format and not isinstance(texture_format, str):\n            texture_format = np.dtype(texture_format).type\n            if texture_format not in self._texture_dtype_format:\n                raise ValueError(\"Can't determine internal texture format for '{}'\".format(texture_format))\n            should_cast_to_f32(texture_format)\n            texture_format = self._texture_dtype_format[texture_format]\n        # adjust internalformat for format of data (RGBA vs L)\n        texture_format = texture_format.replace('r', 'rgba'[:num_channels])\n        return texture_format",
  "def _get_texture_format_for_data(self, data, internalformat):\n        if internalformat is None:\n            raise ValueError(\"'internalformat' must be provided for GPU scaled textures.\")\n        num_channels = self._data_num_channels(data)\n        texture_format = self._handle_auto_texture_format(internalformat, data)\n        texture_format = self._get_gl_tex_format(texture_format, num_channels)\n        return texture_format",
  "def _compute_clim(self, data):\n        clim = self._clim\n        is_auto = isinstance(clim, str) and clim == 'auto'\n        if data.ndim == self._ndim or data.shape[2] == 1:\n            if is_auto:\n                clim = get_default_clim_from_data(data)\n        elif is_auto:\n            # assume that RGB data is already scaled (0, 1)\n            clim = get_default_clim_from_dtype(data.dtype)\n        return float(clim[0]), float(clim[1])",
  "def _internalformat_will_change(self, data):\n        shape_repr = self._create_rep_array(data)\n        new_if = self._get_gl_tex_format(data.dtype, shape_repr.shape[-1])\n        return new_if != self.internalformat",
  "def check_data_format(self, data):\n        \"\"\"Check if provided data will cause issues if set later.\"\"\"\n        if self._internalformat_will_change(data) and not self._auto_texture_format:\n            raise ValueError(\"Data being set would cause a format change \"\n                             \"in the texture. This is only allowed when \"\n                             \"'texture_format' is set to 'auto'.\")",
  "def _reformat_if_necessary(self, data):\n        if not self._internalformat_will_change(data):\n            return\n        if self._auto_texture_format:\n            shape_repr = self._create_rep_array(data)\n            internalformat = self._get_gl_tex_format(data.dtype, shape_repr.shape[-1])\n            self._resize(data.shape, internalformat=internalformat)\n        else:\n            raise RuntimeError(\"'internalformat' needs to change but \"\n                               \"'texture_format' was not 'auto'.\")",
  "def scale_and_set_data(self, data, offset=None, copy=False):\n        \"\"\"Upload new data to the GPU, scaling if necessary.\"\"\"\n        self._reformat_if_necessary(data)\n        self._data_dtype = np.dtype(data.dtype)\n        self._clim = self._compute_clim(data)\n        return super().scale_and_set_data(data, offset=offset, copy=copy)",
  "class EllipseVisual(PolygonVisual):\n    \"\"\"\n    Displays a 2D ellipse\n\n    Parameters\n    ----------\n    center : array\n        Center of the ellipse\n    color : instance of Color\n        The face color to use.\n    border_color : instance of Color\n        The border color to use.\n    border_width: float\n        The width of the border in pixels\n        Line widths > 1px are only\n        guaranteed to work when using `border_method='agg'` method.\n    radius : float | tuple\n        Radius or radii of the ellipse\n        Defaults to  (0.1, 0.1)\n    start_angle : float\n        Start angle of the ellipse in degrees\n        Defaults to 0.\n    span_angle : float\n        Span angle of the ellipse in degrees\n        Defaults to 360.\n    num_segments : int\n        Number of segments to be used to draw the ellipse\n        Defaults to 100\n    **kwargs : dict\n        Keyword arguments to pass to `PolygonVisual`.\n    \"\"\"\n\n    def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, radius=(0.1, 0.1), start_angle=0.,\n                 span_angle=360., num_segments=100, **kwargs):\n        self._center = center\n        self._radius = radius\n        self._start_angle = start_angle\n        self._span_angle = span_angle\n        self._num_segments = num_segments\n\n        # triangulation can be very slow\n        kwargs.setdefault('triangulate', False)\n        PolygonVisual.__init__(self, pos=None, color=color,\n                               border_color=border_color,\n                               border_width=border_width, **kwargs)\n\n        self._mesh.mode = \"triangle_fan\"\n        self._regen_pos()\n        self._update()\n\n    @staticmethod\n    def _generate_vertices(center, radius, start_angle, span_angle,\n                           num_segments):\n        if isinstance(radius, (list, tuple)):\n            if len(radius) == 2:\n                xr, yr = radius\n            else:\n                raise ValueError(\"radius must be float or 2 value tuple/list\"\n                                 \" (got %s of length %d)\" % (type(radius),\n                                                             len(radius)))\n        else:\n            xr = yr = radius\n\n        start_angle = np.deg2rad(start_angle)\n\n        vertices = np.empty([num_segments + 2, 2], dtype=np.float32)\n\n        # split the total angle into num_segments intances\n        theta = np.linspace(start_angle,\n                            start_angle + np.deg2rad(span_angle),\n                            num_segments + 1)\n\n        # PolarProjection\n        vertices[1:, 0] = center[0] + xr * np.cos(theta)\n        vertices[1:, 1] = center[1] + yr * np.sin(theta)\n\n        # specify center point (not used in border)\n        vertices[0] = np.float32([center[0], center[1]])\n\n        return vertices\n\n    @property\n    def center(self):\n        \"\"\"The center of the ellipse\"\"\"\n        return self._center\n\n    @center.setter\n    def center(self, center):\n        \"\"\"The center of the ellipse\"\"\"\n        self._center = center\n        self._regen_pos()\n        self._update()\n\n    @property\n    def radius(self):\n        \"\"\"The start radii of the ellipse.\"\"\"\n        return self._radius\n\n    @radius.setter\n    def radius(self, radius):\n        self._radius = radius\n        self._regen_pos()\n        self._update()\n\n    @property\n    def start_angle(self):\n        \"\"\"The start start_angle of the ellipse.\"\"\"\n        return self._start_angle\n\n    @start_angle.setter\n    def start_angle(self, start_angle):\n        self._start_angle = start_angle\n        self._regen_pos()\n        self._update()\n\n    @property\n    def span_angle(self):\n        \"\"\"The angular span of the ellipse.\"\"\"\n        return self._span_angle\n\n    @span_angle.setter\n    def span_angle(self, span_angle):\n        self._span_angle = span_angle\n        self._regen_pos()\n        self._update()\n\n    @property\n    def num_segments(self):\n        \"\"\"The number of segments in the ellipse.\"\"\"\n        return self._num_segments\n\n    @num_segments.setter\n    def num_segments(self, num_segments):\n        num_segments = int(num_segments)\n        if num_segments < 1:\n            raise ValueError('EllipseVisual must consist of more than 1 '\n                             'segment')\n        self._num_segments = num_segments\n        self._regen_pos()\n        self._update()\n\n    def _regen_pos(self):\n        vertices = self._generate_vertices(center=self._center,\n                                           radius=self._radius,\n                                           start_angle=self._start_angle,\n                                           span_angle=self._span_angle,\n                                           num_segments=self._num_segments)\n        # don't use the center point\n        self._pos = vertices[1:]",
  "def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, radius=(0.1, 0.1), start_angle=0.,\n                 span_angle=360., num_segments=100, **kwargs):\n        self._center = center\n        self._radius = radius\n        self._start_angle = start_angle\n        self._span_angle = span_angle\n        self._num_segments = num_segments\n\n        # triangulation can be very slow\n        kwargs.setdefault('triangulate', False)\n        PolygonVisual.__init__(self, pos=None, color=color,\n                               border_color=border_color,\n                               border_width=border_width, **kwargs)\n\n        self._mesh.mode = \"triangle_fan\"\n        self._regen_pos()\n        self._update()",
  "def _generate_vertices(center, radius, start_angle, span_angle,\n                           num_segments):\n        if isinstance(radius, (list, tuple)):\n            if len(radius) == 2:\n                xr, yr = radius\n            else:\n                raise ValueError(\"radius must be float or 2 value tuple/list\"\n                                 \" (got %s of length %d)\" % (type(radius),\n                                                             len(radius)))\n        else:\n            xr = yr = radius\n\n        start_angle = np.deg2rad(start_angle)\n\n        vertices = np.empty([num_segments + 2, 2], dtype=np.float32)\n\n        # split the total angle into num_segments intances\n        theta = np.linspace(start_angle,\n                            start_angle + np.deg2rad(span_angle),\n                            num_segments + 1)\n\n        # PolarProjection\n        vertices[1:, 0] = center[0] + xr * np.cos(theta)\n        vertices[1:, 1] = center[1] + yr * np.sin(theta)\n\n        # specify center point (not used in border)\n        vertices[0] = np.float32([center[0], center[1]])\n\n        return vertices",
  "def center(self):\n        \"\"\"The center of the ellipse\"\"\"\n        return self._center",
  "def center(self, center):\n        \"\"\"The center of the ellipse\"\"\"\n        self._center = center\n        self._regen_pos()\n        self._update()",
  "def radius(self):\n        \"\"\"The start radii of the ellipse.\"\"\"\n        return self._radius",
  "def radius(self, radius):\n        self._radius = radius\n        self._regen_pos()\n        self._update()",
  "def start_angle(self):\n        \"\"\"The start start_angle of the ellipse.\"\"\"\n        return self._start_angle",
  "def start_angle(self, start_angle):\n        self._start_angle = start_angle\n        self._regen_pos()\n        self._update()",
  "def span_angle(self):\n        \"\"\"The angular span of the ellipse.\"\"\"\n        return self._span_angle",
  "def span_angle(self, span_angle):\n        self._span_angle = span_angle\n        self._regen_pos()\n        self._update()",
  "def num_segments(self):\n        \"\"\"The number of segments in the ellipse.\"\"\"\n        return self._num_segments",
  "def num_segments(self, num_segments):\n        num_segments = int(num_segments)\n        if num_segments < 1:\n            raise ValueError('EllipseVisual must consist of more than 1 '\n                             'segment')\n        self._num_segments = num_segments\n        self._regen_pos()\n        self._update()",
  "def _regen_pos(self):\n        vertices = self._generate_vertices(center=self._center,\n                                           radius=self._radius,\n                                           start_angle=self._start_angle,\n                                           span_angle=self._span_angle,\n                                           num_segments=self._num_segments)\n        # don't use the center point\n        self._pos = vertices[1:]",
  "class MarkersVisual(Visual):\n    \"\"\"Visual displaying marker symbols.\n\n    Parameters\n    ----------\n    pos : array\n        The array of locations to display each symbol.\n    size : float or array\n        The symbol size in screen (or data, if scaling is on) px.\n    edge_width : float or array or None\n        The width of the symbol outline in screen (or data, if scaling is on) px.\n    edge_width_rel : float or array or None\n        The width as a fraction of marker size. Exactly one of\n        `edge_width` and `edge_width_rel` must be supplied.\n    edge_color : Color | ColorArray\n        The color used to draw each symbol outline.\n    face_color : Color | ColorArray\n        The color used to draw each symbol interior.\n    symbol : str or array\n        The style of symbol used to draw each marker (see Notes).\n    scaling : bool\n        If set to True, marker scales when rezooming.\n    alpha : float\n        The opacity level of the visual.\n    antialias : float\n        Antialiasing amount (in px).\n    spherical : bool\n        Whether to add a spherical effect on the marker using lighting.\n    light_color : Color | ColorArray\n        The color of the light used to create the spherical effect.\n    light_position : array\n        The coordinates of the light used to create the spherical effect.\n    light_ambient : float\n        The amount of ambient light used to create the spherical effect.\n\n    Notes\n    -----\n    Allowed style strings are: disc, arrow, ring, clobber, square, diamond,\n    vbar, hbar, cross, tailed_arrow, x, triangle_up, triangle_down,\n    and star.\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n    _symbol_shader_values = symbol_shader_values\n    _symbol_shader = symbol_func\n\n    def __init__(self, scaling=False, alpha=1, antialias=1, spherical=False,\n                 light_color='white', light_position=(1, -1, 1), light_ambient=0.3, **kwargs):\n        self._vbo = VertexBuffer()\n        self._data = None\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self._symbol_func = Function(self._symbol_shader)\n        self.shared_program.frag['marker'] = self._symbol_func\n        self._v_size_var = Variable('varying float v_size')\n        self.shared_program.vert['v_size'] = self._v_size_var\n        self.shared_program.frag['v_size'] = self._v_size_var\n        self._symbol_func['v_size'] = self._v_size_var\n\n        self.set_gl_state(depth_test=True, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n\n        if len(kwargs) > 0:\n            self.set_data(**kwargs)\n\n        self.scaling = scaling\n        self.antialias = antialias\n        self.light_color = light_color\n        self.light_position = light_position\n        self.light_ambient = light_ambient\n        self.alpha = alpha\n        self.spherical = spherical\n\n        self.freeze()\n\n    def set_data(self, pos=None, size=10., edge_width=1., edge_width_rel=None,\n                 edge_color='black', face_color='white',\n                 symbol='o'):\n        \"\"\"Set the data used to display this visual.\n\n        Parameters\n        ----------\n        pos : array\n            The array of locations to display each symbol.\n        size : float or array\n            The symbol size in screen (or data, if scaling is on) px.\n        edge_width : float or array or None\n            The width of the symbol outline in screen (or data, if scaling is on) px.\n        edge_width_rel : float or array or None\n            The width as a fraction of marker size. Exactly one of\n            `edge_width` and `edge_width_rel` must be supplied.\n        edge_color : Color | ColorArray\n            The color used to draw each symbol outline.\n        face_color : Color | ColorArray\n            The color used to draw each symbol interior.\n        symbol : str or array\n            The style of symbol used to draw each marker (see Notes).\n        \"\"\"\n        if (edge_width is not None) + (edge_width_rel is not None) != 1:\n            raise ValueError('exactly one of edge_width and edge_width_rel '\n                             'must be non-None')\n\n        if edge_width is not None:\n            edge_width = np.asarray(edge_width)\n            if np.any(edge_width < 0):\n                raise ValueError('edge_width cannot be negative')\n        else:\n            edge_width_rel = np.asarray(edge_width_rel)\n            if np.any(edge_width_rel < 0):\n                raise ValueError('edge_width_rel cannot be negative')\n\n        if symbol is not None:\n            if not np.all(np.isin(np.asarray(symbol), self.symbols)):\n                raise ValueError(f'symbols must one of {self.symbols}')\n\n        edge_color = ColorArray(edge_color).rgba\n        if len(edge_color) == 1:\n            edge_color = edge_color[0]\n\n        face_color = ColorArray(face_color).rgba\n        if len(face_color) == 1:\n            face_color = face_color[0]\n\n        if pos is not None:\n            assert (isinstance(pos, np.ndarray) and\n                    pos.ndim == 2 and pos.shape[1] in (2, 3))\n\n            n = len(pos)\n            data = np.zeros(n, dtype=[('a_position', np.float32, 3),\n                                      ('a_fg_color', np.float32, 4),\n                                      ('a_bg_color', np.float32, 4),\n                                      ('a_size', np.float32),\n                                      ('a_edgewidth', np.float32),\n                                      ('a_symbol', np.float32)])\n            data['a_fg_color'] = edge_color\n            data['a_bg_color'] = face_color\n            if edge_width is not None:\n                data['a_edgewidth'] = edge_width\n            else:\n                data['a_edgewidth'] = size * edge_width_rel\n            data['a_position'][:, :pos.shape[1]] = pos\n            data['a_size'] = size\n\n            data['a_symbol'] = np.vectorize(self._symbol_shader_values.get)(symbol)\n\n            self._data = data\n            self._vbo.set_data(data)\n            self.shared_program.bind(self._vbo)\n\n        self.update()\n\n    @property\n    def symbols(self):\n        return list(self._symbol_shader_values)\n\n    @property\n    def symbol(self):\n        value_to_symbol = {v: k for k, v in self._symbol_shader_values.items()}\n        return np.vectorize(value_to_symbol.get)(self._data['a_symbol'])\n\n    @symbol.setter\n    def symbol(self, value):\n        rec_to_kw = {\n            'a_position': 'pos',\n            'a_fg_color': 'edge_color',\n            'a_bg_color': 'face_color',\n            'a_size': 'size',\n            'a_edgewidth': 'edge_width',\n            'a_symbol': 'symbol',\n        }\n        kwargs = {kw: self._data[rec] for rec, kw in rec_to_kw.items()}\n        kwargs['symbol'] = value\n        self.set_data(**kwargs)\n\n    @property\n    def scaling(self):\n        \"\"\"\n        If set to True, marker scales when rezooming.\n        \"\"\"\n        return self._scaling\n\n    @scaling.setter\n    def scaling(self, value):\n        value = bool(value)\n        self.shared_program['u_scaling'] = value\n        self._scaling = value\n        self.update()\n\n    @property\n    def antialias(self):\n        \"\"\"\n        Antialiasing amount (in px).\n        \"\"\"\n        return self._antialias\n\n    @antialias.setter\n    def antialias(self, value):\n        value = float(value)\n        self.shared_program['u_antialias'] = value\n        self._antialias = value\n        self.update()\n\n    @property\n    def light_position(self):\n        \"\"\"\n        The coordinates of the light used to create the spherical effect.\n        \"\"\"\n        return self._light_position\n\n    @light_position.setter\n    def light_position(self, value):\n        value = np.array(value)\n        self.shared_program['u_light_position'] = value / np.linalg.norm(value)\n        self._light_position = value\n        self.update()\n\n    @property\n    def light_ambient(self):\n        \"\"\"\n        The amount of ambient light used to create the spherical effect.\n        \"\"\"\n        return self._light_ambient\n\n    @light_ambient.setter\n    def light_ambient(self, value):\n        self.shared_program['u_light_ambient'] = value\n        self._light_ambient = value\n        self.update()\n\n    @property\n    def light_color(self):\n        \"\"\"\n        The color of the light used to create the spherical effect.\n        \"\"\"\n        return self._light_color\n\n    @light_color.setter\n    def light_color(self, value):\n        self.shared_program['u_light_color'] = ColorArray(value).rgb\n        self._light_color = value\n        self.update()\n\n    @property\n    def alpha(self):\n        \"\"\"\n        The opacity level of the visual.\n        \"\"\"\n        return self._alpha\n\n    @alpha.setter\n    def alpha(self, value):\n        self.shared_program['u_alpha'] = value\n        self._alpha = value\n        self.update()\n\n    @property\n    def spherical(self):\n        \"\"\"\n        Whether to add a spherical effect on the marker using lighting.\n        \"\"\"\n        return self._spherical\n\n    @spherical.setter\n    def spherical(self, value):\n        self.shared_program['u_spherical'] = value\n        self._spherical = value\n        self.update()\n\n    def _prepare_transforms(self, view):\n        view.view_program.vert['visual_to_framebuffer'] = view.get_transform('visual', 'framebuffer')\n        view.view_program.vert['framebuffer_to_visual'] = view.get_transform('framebuffer', 'visual')\n        view.view_program.vert['framebuffer_to_render'] = view.get_transform('framebuffer', 'render')\n        view.view_program.vert['framebuffer_to_scene'] = view.get_transform('framebuffer', 'scene')\n        view.view_program.vert['scene_to_framebuffer'] = view.get_transform('scene', 'framebuffer')\n\n    def _prepare_draw(self, view):\n        if self._data is None:\n            return False\n        view.view_program['u_px_scale'] = view.transforms.pixel_scale\n        view.view_program['u_scaling'] = self.scaling\n\n    def _compute_bounds(self, axis, view):\n        pos = self._data['a_position']\n        if pos is None:\n            return None\n        if pos.shape[1] > axis:\n            return (pos[:, axis].min(), pos[:, axis].max())\n        else:\n            return (0, 0)",
  "def __init__(self, scaling=False, alpha=1, antialias=1, spherical=False,\n                 light_color='white', light_position=(1, -1, 1), light_ambient=0.3, **kwargs):\n        self._vbo = VertexBuffer()\n        self._data = None\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self._symbol_func = Function(self._symbol_shader)\n        self.shared_program.frag['marker'] = self._symbol_func\n        self._v_size_var = Variable('varying float v_size')\n        self.shared_program.vert['v_size'] = self._v_size_var\n        self.shared_program.frag['v_size'] = self._v_size_var\n        self._symbol_func['v_size'] = self._v_size_var\n\n        self.set_gl_state(depth_test=True, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n\n        if len(kwargs) > 0:\n            self.set_data(**kwargs)\n\n        self.scaling = scaling\n        self.antialias = antialias\n        self.light_color = light_color\n        self.light_position = light_position\n        self.light_ambient = light_ambient\n        self.alpha = alpha\n        self.spherical = spherical\n\n        self.freeze()",
  "def set_data(self, pos=None, size=10., edge_width=1., edge_width_rel=None,\n                 edge_color='black', face_color='white',\n                 symbol='o'):\n        \"\"\"Set the data used to display this visual.\n\n        Parameters\n        ----------\n        pos : array\n            The array of locations to display each symbol.\n        size : float or array\n            The symbol size in screen (or data, if scaling is on) px.\n        edge_width : float or array or None\n            The width of the symbol outline in screen (or data, if scaling is on) px.\n        edge_width_rel : float or array or None\n            The width as a fraction of marker size. Exactly one of\n            `edge_width` and `edge_width_rel` must be supplied.\n        edge_color : Color | ColorArray\n            The color used to draw each symbol outline.\n        face_color : Color | ColorArray\n            The color used to draw each symbol interior.\n        symbol : str or array\n            The style of symbol used to draw each marker (see Notes).\n        \"\"\"\n        if (edge_width is not None) + (edge_width_rel is not None) != 1:\n            raise ValueError('exactly one of edge_width and edge_width_rel '\n                             'must be non-None')\n\n        if edge_width is not None:\n            edge_width = np.asarray(edge_width)\n            if np.any(edge_width < 0):\n                raise ValueError('edge_width cannot be negative')\n        else:\n            edge_width_rel = np.asarray(edge_width_rel)\n            if np.any(edge_width_rel < 0):\n                raise ValueError('edge_width_rel cannot be negative')\n\n        if symbol is not None:\n            if not np.all(np.isin(np.asarray(symbol), self.symbols)):\n                raise ValueError(f'symbols must one of {self.symbols}')\n\n        edge_color = ColorArray(edge_color).rgba\n        if len(edge_color) == 1:\n            edge_color = edge_color[0]\n\n        face_color = ColorArray(face_color).rgba\n        if len(face_color) == 1:\n            face_color = face_color[0]\n\n        if pos is not None:\n            assert (isinstance(pos, np.ndarray) and\n                    pos.ndim == 2 and pos.shape[1] in (2, 3))\n\n            n = len(pos)\n            data = np.zeros(n, dtype=[('a_position', np.float32, 3),\n                                      ('a_fg_color', np.float32, 4),\n                                      ('a_bg_color', np.float32, 4),\n                                      ('a_size', np.float32),\n                                      ('a_edgewidth', np.float32),\n                                      ('a_symbol', np.float32)])\n            data['a_fg_color'] = edge_color\n            data['a_bg_color'] = face_color\n            if edge_width is not None:\n                data['a_edgewidth'] = edge_width\n            else:\n                data['a_edgewidth'] = size * edge_width_rel\n            data['a_position'][:, :pos.shape[1]] = pos\n            data['a_size'] = size\n\n            data['a_symbol'] = np.vectorize(self._symbol_shader_values.get)(symbol)\n\n            self._data = data\n            self._vbo.set_data(data)\n            self.shared_program.bind(self._vbo)\n\n        self.update()",
  "def symbols(self):\n        return list(self._symbol_shader_values)",
  "def symbol(self):\n        value_to_symbol = {v: k for k, v in self._symbol_shader_values.items()}\n        return np.vectorize(value_to_symbol.get)(self._data['a_symbol'])",
  "def symbol(self, value):\n        rec_to_kw = {\n            'a_position': 'pos',\n            'a_fg_color': 'edge_color',\n            'a_bg_color': 'face_color',\n            'a_size': 'size',\n            'a_edgewidth': 'edge_width',\n            'a_symbol': 'symbol',\n        }\n        kwargs = {kw: self._data[rec] for rec, kw in rec_to_kw.items()}\n        kwargs['symbol'] = value\n        self.set_data(**kwargs)",
  "def scaling(self):\n        \"\"\"\n        If set to True, marker scales when rezooming.\n        \"\"\"\n        return self._scaling",
  "def scaling(self, value):\n        value = bool(value)\n        self.shared_program['u_scaling'] = value\n        self._scaling = value\n        self.update()",
  "def antialias(self):\n        \"\"\"\n        Antialiasing amount (in px).\n        \"\"\"\n        return self._antialias",
  "def antialias(self, value):\n        value = float(value)\n        self.shared_program['u_antialias'] = value\n        self._antialias = value\n        self.update()",
  "def light_position(self):\n        \"\"\"\n        The coordinates of the light used to create the spherical effect.\n        \"\"\"\n        return self._light_position",
  "def light_position(self, value):\n        value = np.array(value)\n        self.shared_program['u_light_position'] = value / np.linalg.norm(value)\n        self._light_position = value\n        self.update()",
  "def light_ambient(self):\n        \"\"\"\n        The amount of ambient light used to create the spherical effect.\n        \"\"\"\n        return self._light_ambient",
  "def light_ambient(self, value):\n        self.shared_program['u_light_ambient'] = value\n        self._light_ambient = value\n        self.update()",
  "def light_color(self):\n        \"\"\"\n        The color of the light used to create the spherical effect.\n        \"\"\"\n        return self._light_color",
  "def light_color(self, value):\n        self.shared_program['u_light_color'] = ColorArray(value).rgb\n        self._light_color = value\n        self.update()",
  "def alpha(self):\n        \"\"\"\n        The opacity level of the visual.\n        \"\"\"\n        return self._alpha",
  "def alpha(self, value):\n        self.shared_program['u_alpha'] = value\n        self._alpha = value\n        self.update()",
  "def spherical(self):\n        \"\"\"\n        Whether to add a spherical effect on the marker using lighting.\n        \"\"\"\n        return self._spherical",
  "def spherical(self, value):\n        self.shared_program['u_spherical'] = value\n        self._spherical = value\n        self.update()",
  "def _prepare_transforms(self, view):\n        view.view_program.vert['visual_to_framebuffer'] = view.get_transform('visual', 'framebuffer')\n        view.view_program.vert['framebuffer_to_visual'] = view.get_transform('framebuffer', 'visual')\n        view.view_program.vert['framebuffer_to_render'] = view.get_transform('framebuffer', 'render')\n        view.view_program.vert['framebuffer_to_scene'] = view.get_transform('framebuffer', 'scene')\n        view.view_program.vert['scene_to_framebuffer'] = view.get_transform('scene', 'framebuffer')",
  "def _prepare_draw(self, view):\n        if self._data is None:\n            return False\n        view.view_program['u_px_scale'] = view.transforms.pixel_scale\n        view.view_program['u_scaling'] = self.scaling",
  "def _compute_bounds(self, axis, view):\n        pos = self._data['a_position']\n        if pos is None:\n            return None\n        if pos.shape[1] > axis:\n            return (pos[:, axis].min(), pos[:, axis].max())\n        else:\n            return (0, 0)",
  "class RegularPolygonVisual(EllipseVisual):\n    \"\"\"\n    Displays a regular polygon\n\n    Parameters\n    ----------\n    center : array-like (x, y)\n        Center of the regular polygon\n    color : str | tuple | list of colors\n        Fill color of the polygon\n    border_color : str | tuple | list of colors\n        Border color of the polygon\n    border_width: float\n        The width of the border in pixels\n    radius : float\n        Radius of the regular polygon\n        Defaults to  0.1\n    sides : int\n        Number of sides of the regular polygon\n    \"\"\"\n\n    def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, radius=0.1, sides=4, **kwargs):\n        EllipseVisual.__init__(self, center=center,\n                               radius=radius,\n                               color=color,\n                               border_color=border_color,\n                               border_width=border_width,\n                               num_segments=sides, **kwargs)\n\n    @property\n    def sides(self):\n        \"\"\"The number of sides in the regular polygon.\"\"\"\n        # return using the property accessor for num_segments\n        return self.num_segments\n\n    @sides.setter\n    def sides(self, sides):\n        if sides < 3:\n            raise ValueError('PolygonVisual must have at least 3 sides, not %s'\n                             % sides)\n        # edit using the property accessor of num_segments so this\n        # internally calls the update()\n        self.num_segments = sides",
  "def __init__(self, center=None, color='black', border_color=None,\n                 border_width=1, radius=0.1, sides=4, **kwargs):\n        EllipseVisual.__init__(self, center=center,\n                               radius=radius,\n                               color=color,\n                               border_color=border_color,\n                               border_width=border_width,\n                               num_segments=sides, **kwargs)",
  "def sides(self):\n        \"\"\"The number of sides in the regular polygon.\"\"\"\n        # return using the property accessor for num_segments\n        return self.num_segments",
  "def sides(self, sides):\n        if sides < 3:\n            raise ValueError('PolygonVisual must have at least 3 sides, not %s'\n                             % sides)\n        # edit using the property accessor of num_segments so this\n        # internally calls the update()\n        self.num_segments = sides",
  "class SphereVisual(CompoundVisual):\n    \"\"\"Visual that displays a sphere\n\n    Parameters\n    ----------\n    radius : float\n        The size of the sphere.\n    cols : int\n        Number of cols that make up the sphere mesh\n        (for method='latitude' and 'cube').\n    rows : int\n        Number of rows that make up the sphere mesh\n        (for method='latitude' and 'cube').\n    depth : int\n        Number of depth segments that make up the sphere mesh\n        (for method='cube').\n    subdivisions : int\n        Number of subdivisions to perform (for method='ico').\n    method : str\n        Method for generating sphere. Accepts 'latitude' for\n        latitude-longitude, 'ico' for icosahedron, and 'cube'\n        for cube based tessellation.\n    vertex_colors : ndarray\n        Same as for `MeshVisual` class.\n        See `create_sphere` for vertex ordering.\n    face_colors : ndarray\n        Same as for `MeshVisual` class.\n        See `create_sphere` for vertex ordering.\n    color : Color\n        The `Color` to use when drawing the sphere faces.\n    edge_color : tuple or Color\n        The `Color` to use when drawing the sphere edges. If `None`, then no\n        sphere edges are drawn.\n    shading : str | None\n        Shading to use.\n    \"\"\"\n\n    def __init__(self, radius=1.0, cols=30, rows=30, depth=30, subdivisions=3,\n                 method='latitude', vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, shading=None, **kwargs):\n\n        mesh = create_sphere(rows, cols, depth, radius=radius,\n                             subdivisions=subdivisions, method=method)\n\n        self._mesh = MeshVisual(vertices=mesh.get_vertices(),\n                                faces=mesh.get_faces(),\n                                vertex_colors=vertex_colors,\n                                face_colors=face_colors, color=color,\n                                shading=shading)\n        if edge_color:\n            self._border = MeshVisual(vertices=mesh.get_vertices(),\n                                      faces=mesh.get_edges(),\n                                      color=edge_color, mode='lines')\n        else:\n            self._border = MeshVisual()\n\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self.mesh.set_gl_state(polygon_offset_fill=True,\n                               polygon_offset=(1, 1), depth_test=True)\n\n    @property\n    def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to fil in.\"\"\"\n        return self._mesh\n\n    @property\n    def border(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to draw the border.\"\"\"\n        return self._border",
  "def __init__(self, radius=1.0, cols=30, rows=30, depth=30, subdivisions=3,\n                 method='latitude', vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, shading=None, **kwargs):\n\n        mesh = create_sphere(rows, cols, depth, radius=radius,\n                             subdivisions=subdivisions, method=method)\n\n        self._mesh = MeshVisual(vertices=mesh.get_vertices(),\n                                faces=mesh.get_faces(),\n                                vertex_colors=vertex_colors,\n                                face_colors=face_colors, color=color,\n                                shading=shading)\n        if edge_color:\n            self._border = MeshVisual(vertices=mesh.get_vertices(),\n                                      faces=mesh.get_edges(),\n                                      color=edge_color, mode='lines')\n        else:\n            self._border = MeshVisual()\n\n        CompoundVisual.__init__(self, [self._mesh, self._border], **kwargs)\n        self.mesh.set_gl_state(polygon_offset_fill=True,\n                               polygon_offset=(1, 1), depth_test=True)",
  "def mesh(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to fil in.\"\"\"\n        return self._mesh",
  "def border(self):\n        \"\"\"The vispy.visuals.MeshVisual that used to draw the border.\"\"\"\n        return self._border",
  "class CubeVisual(BoxVisual):\n    \"\"\"Visual that displays a cube or cuboid\n\n    Parameters\n    ----------\n    size : float or tuple\n        The size of the cuboid. A float gives a cube, whereas tuples may\n        specify the size of each axis (x, y, z) independently.\n    vertex_colors : ndarray\n        Same as for `MeshVisual` class. See `create_cube` for vertex ordering.\n    face_colors : ndarray\n        Same as for `MeshVisual` class. See `create_cube` for vertex ordering.\n    color : Color\n        The `Color` to use when drawing the cube faces.\n    edge_color : tuple or Color\n        The `Color` to use when drawing the cube edges. If `None`, then no\n        cube edges are drawn.\n    \"\"\"\n\n    def __init__(self, size=1.0, vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, **kwargs):\n        warnings.warn(\"The CubeVisual is deprecated in favor of BoxVisual\",\n                      DeprecationWarning, stacklevel=2)\n        if isinstance(size, tuple):\n            width, height, depth = size\n        else:\n            width = height = depth = size\n        BoxVisual.__init__(self, width=width, height=height, depth=depth,\n                           vertex_colors=vertex_colors,\n                           face_colors=face_colors, color=color,\n                           edge_color=edge_color, **kwargs)",
  "def __init__(self, size=1.0, vertex_colors=None, face_colors=None,\n                 color=(0.5, 0.5, 1, 1), edge_color=None, **kwargs):\n        warnings.warn(\"The CubeVisual is deprecated in favor of BoxVisual\",\n                      DeprecationWarning, stacklevel=2)\n        if isinstance(size, tuple):\n            width, height, depth = size\n        else:\n            width = height = depth = size\n        BoxVisual.__init__(self, width=width, height=height, depth=depth,\n                           vertex_colors=vertex_colors,\n                           face_colors=face_colors, color=color,\n                           edge_color=edge_color, **kwargs)",
  "class Clipper(Filter):\n    \"\"\"Clips visual output to a rectangular region.\"\"\"\n\n    FRAG_SHADER = \"\"\"\n        void clip() {\n            vec4 pos = $fb_to_clip(gl_FragCoord);\n            if( pos.x < $view.x || pos.x > $view.y ||\n                pos.y < $view.z || pos.y > $view.w ) {\n                discard;\n            }\n        }\n    \"\"\"\n\n    def __init__(self, bounds=(0, 0, 1, 1), transform=None):\n        super(Clipper, self).__init__(fcode=self.FRAG_SHADER,\n                                      fhook='pre', fpos=1)\n\n        self.bounds = bounds  # (x, y, w, h)\n        if transform is None:\n            transform = NullTransform()\n        self._transform = None\n        self.transform = transform\n\n    @property\n    def bounds(self):\n        \"\"\"The clipping boundaries.\n\n        This must be a tuple (x, y, w, h) in a clipping coordinate system\n        that is defined by the `transform` property.\n        \"\"\"\n        return self._bounds\n\n    @bounds.setter\n    def bounds(self, b):\n        self._bounds = Rect(b).normalized()\n        b = self._bounds\n        self.fshader['view'] = (b.left, b.right, b.bottom, b.top)\n\n    @property\n    def transform(self):\n        \"\"\"The transform that maps from framebuffer coordinates to clipping\n        coordinates.\n        \"\"\"\n        return self._transform\n\n    @transform.setter\n    def transform(self, tr):\n        if tr is self._transform:\n            return\n        self._transform = tr\n        self.fshader['fb_to_clip'] = tr",
  "def __init__(self, bounds=(0, 0, 1, 1), transform=None):\n        super(Clipper, self).__init__(fcode=self.FRAG_SHADER,\n                                      fhook='pre', fpos=1)\n\n        self.bounds = bounds  # (x, y, w, h)\n        if transform is None:\n            transform = NullTransform()\n        self._transform = None\n        self.transform = transform",
  "def bounds(self):\n        \"\"\"The clipping boundaries.\n\n        This must be a tuple (x, y, w, h) in a clipping coordinate system\n        that is defined by the `transform` property.\n        \"\"\"\n        return self._bounds",
  "def bounds(self, b):\n        self._bounds = Rect(b).normalized()\n        b = self._bounds\n        self.fshader['view'] = (b.left, b.right, b.bottom, b.top)",
  "def transform(self):\n        \"\"\"The transform that maps from framebuffer coordinates to clipping\n        coordinates.\n        \"\"\"\n        return self._transform",
  "def transform(self, tr):\n        if tr is self._transform:\n            return\n        self._transform = tr\n        self.fshader['fb_to_clip'] = tr",
  "class BaseFilter(object):\n    \"\"\"Superclass for all filters.\"\"\"\n\n    def _attach(self, visual):\n        \"\"\"Called when a filter should be attached to a visual.\n\n        Parameters\n        ----------\n        visual : instance of BaseVisual\n            The visual that called this.\n        \"\"\"\n        raise NotImplementedError(self)\n\n    def _detach(self, visual):\n        \"\"\"Called when a filter should be detached from a visual.\n\n        Parameters\n        ----------\n        visual : instance of BaseVisual\n            The visual that called this.\n        \"\"\"\n        raise NotImplementedError(self)",
  "class Filter(BaseFilter):\n    \"\"\"Base class for all filters that use fragment and/or vertex shaders.\n\n    Parameters\n    ----------\n    vcode : str | Function | None\n        Vertex shader code. If None, ``vhook`` and ``vpos`` will\n        be ignored.\n    vhook : {'pre', 'post'}\n        Hook name to attach the vertex shader to.\n    vpos : int\n        Position in the hook to attach the vertex shader.\n    fcode : str | Function | None\n        Fragment shader code. If None, ``fhook`` and ``fpos`` will\n        be ignored.\n    fhook : {'pre', 'post'}\n        Hook name to attach the fragment shader to.\n    fpos : int\n        Position in the hook to attach the fragment shader.\n\n    Attributes\n    ----------\n    vshader : Function | None\n        Vertex shader.\n    fshader : Function | None\n        Fragment shader.\n    \"\"\"\n\n    def __init__(self, vcode=None, vhook='post', vpos=5,\n                 fcode=None, fhook='post', fpos=5):\n        super(Filter, self).__init__()\n\n        if vcode is not None:\n            self.vshader = Function(vcode) if isinstance(vcode, str) else vcode\n            self._vexpr = self.vshader()\n            self._vhook = vhook\n            self._vpos = vpos\n        else:\n            self.vshader = None\n\n        if fcode is not None:\n            self.fshader = Function(fcode) if isinstance(fcode, str) else fcode\n            self._fexpr = self.fshader()\n            self._fhook = fhook\n            self._fpos = fpos\n        else:\n            self.fshader = None\n\n        self._attached = False\n\n    @property\n    def attached(self):\n        return self._attached\n\n    def _attach(self, visual):\n        \"\"\"Called when a filter should be attached to a visual.\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual that called this.\n        \"\"\"\n        if self.vshader:\n            hook = visual._get_hook('vert', self._vhook)\n            hook.add(self._vexpr, position=self._vpos)\n\n        if self.fshader:\n            hook = visual._get_hook('frag', self._fhook)\n            hook.add(self._fexpr, position=self._fpos)\n\n        self._attached = True\n        self._visual = visual\n\n    def _detach(self, visual):\n        \"\"\"Called when a filter should be detached from a visual.\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual that called this.\n        \"\"\"\n        if self.vshader:\n            hook = visual._get_hook('vert', self._vhook)\n            hook.remove(self._vexpr)\n\n        if self.fshader:\n            hook = visual._get_hook('frag', self._fhook)\n            hook.remove(self._fexpr)\n\n        self._attached = False\n        self._visual = None",
  "def _attach(self, visual):\n        \"\"\"Called when a filter should be attached to a visual.\n\n        Parameters\n        ----------\n        visual : instance of BaseVisual\n            The visual that called this.\n        \"\"\"\n        raise NotImplementedError(self)",
  "def _detach(self, visual):\n        \"\"\"Called when a filter should be detached from a visual.\n\n        Parameters\n        ----------\n        visual : instance of BaseVisual\n            The visual that called this.\n        \"\"\"\n        raise NotImplementedError(self)",
  "def __init__(self, vcode=None, vhook='post', vpos=5,\n                 fcode=None, fhook='post', fpos=5):\n        super(Filter, self).__init__()\n\n        if vcode is not None:\n            self.vshader = Function(vcode) if isinstance(vcode, str) else vcode\n            self._vexpr = self.vshader()\n            self._vhook = vhook\n            self._vpos = vpos\n        else:\n            self.vshader = None\n\n        if fcode is not None:\n            self.fshader = Function(fcode) if isinstance(fcode, str) else fcode\n            self._fexpr = self.fshader()\n            self._fhook = fhook\n            self._fpos = fpos\n        else:\n            self.fshader = None\n\n        self._attached = False",
  "def attached(self):\n        return self._attached",
  "def _attach(self, visual):\n        \"\"\"Called when a filter should be attached to a visual.\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual that called this.\n        \"\"\"\n        if self.vshader:\n            hook = visual._get_hook('vert', self._vhook)\n            hook.add(self._vexpr, position=self._vpos)\n\n        if self.fshader:\n            hook = visual._get_hook('frag', self._fhook)\n            hook.add(self._fexpr, position=self._fpos)\n\n        self._attached = True\n        self._visual = visual",
  "def _detach(self, visual):\n        \"\"\"Called when a filter should be detached from a visual.\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual that called this.\n        \"\"\"\n        if self.vshader:\n            hook = visual._get_hook('vert', self._vhook)\n            hook.remove(self._vexpr)\n\n        if self.fshader:\n            hook = visual._get_hook('frag', self._fhook)\n            hook.remove(self._fexpr)\n\n        self._attached = False\n        self._visual = None",
  "class PlanesClipper(Filter):\n    \"\"\"Clips visual output based on arbitrary clipping planes.\n\n    Parameters\n    ----------\n    cliping_planes : ArrayLike\n        Each plane is defined by a position and a normal vector (magnitude is irrelevant). Shape: (n_planes, 2, 3)\n    coord_system : str\n        Coordinate system used by the clipping planes (see visuals.transforms.transform_system.py)\n\n    \"\"\"\n\n    VERT_CODE = \"\"\"\n    void clip() {\n        // pass position as varying for interpolation\n        $v_position = gl_Position;\n    }\n    \"\"\"\n\n    FRAG_CODE = \"\"\"\n    void clip() {\n        float distance_from_clip = $clip_with_planes($itransform($v_position).xyz);\n        if (distance_from_clip < 0.)\n            discard;\n    }\n    \"\"\"\n\n    def __init__(self, clipping_planes: Optional[np.ndarray] = None, coord_system: str = 'scene'):\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        if coord_system not in tr:\n            raise ValueError(f'Invalid coordinate system {coord_system}. Must be one of {tr}.')\n        self._coord_system = coord_system\n\n        super().__init__(\n            vcode=Function(self.VERT_CODE), vhook='post', vpos=1,\n            fcode=Function(self.FRAG_CODE), fhook='pre', fpos=1,\n        )\n\n        v_position = Varying('v_position', 'vec4')\n        self.vshader['v_position'] = v_position\n        self.fshader['v_position'] = v_position\n\n        self.clipping_planes = clipping_planes\n\n    @property\n    def coord_system(self) -> str:\n        \"\"\"\n        Coordinate system used by the clipping planes (see visuals.transforms.transform_system.py)\n        \"\"\"\n        # unsettable cause we can't update the transform after being attached\n        return self._coord_system\n\n    def _attach(self, visual):\n        super()._attach(visual)\n        self.fshader['itransform'] = visual.get_transform('render', self._coord_system)\n\n    @staticmethod\n    @lru_cache(maxsize=10)\n    def _build_clipping_planes_glsl(n_planes: int) -> str:\n        \"\"\"Build the code snippet used to clip the volume based on self.clipping_planes.\"\"\"\n        func_template = '''\n            float clip_planes(vec3 loc) {{\n                float distance_from_clip = 3.4e38; // max float\n                {clips};\n                return distance_from_clip;\n            }}\n        '''\n        # the vertex is considered clipped if on the \"negative\" side of the plane\n        clip_template = '''\n            vec3 relative_vec{idx} = loc - $clipping_plane_pos{idx};\n            float distance_from_clip{idx} = dot(relative_vec{idx}, $clipping_plane_norm{idx});\n            distance_from_clip = min(distance_from_clip{idx}, distance_from_clip);\n            '''\n        all_clips = []\n        for idx in range(n_planes):\n            all_clips.append(clip_template.format(idx=idx))\n        formatted_code = func_template.format(clips=''.join(all_clips))\n        return formatted_code\n\n    @property\n    def clipping_planes(self) -> np.ndarray:\n        \"\"\"Get the set of planes used to clip the mesh.\n        Each plane is defined by a position and a normal vector (magnitude is irrelevant). Shape: (n_planes, 2, 3)\n        \"\"\"\n        return self._clipping_planes\n\n    @clipping_planes.setter\n    def clipping_planes(self, value: Optional[np.ndarray]):\n        if value is None:\n            value = np.empty([0, 2, 3])\n        self._clipping_planes = value\n\n        clip_func = Function(self._build_clipping_planes_glsl(len(value)))\n        self.fshader['clip_with_planes'] = clip_func\n\n        for idx, plane in enumerate(value):\n            clip_func[f'clipping_plane_pos{idx}'] = tuple(plane[0])\n            clip_func[f'clipping_plane_norm{idx}'] = tuple(plane[1])",
  "def __init__(self, clipping_planes: Optional[np.ndarray] = None, coord_system: str = 'scene'):\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        if coord_system not in tr:\n            raise ValueError(f'Invalid coordinate system {coord_system}. Must be one of {tr}.')\n        self._coord_system = coord_system\n\n        super().__init__(\n            vcode=Function(self.VERT_CODE), vhook='post', vpos=1,\n            fcode=Function(self.FRAG_CODE), fhook='pre', fpos=1,\n        )\n\n        v_position = Varying('v_position', 'vec4')\n        self.vshader['v_position'] = v_position\n        self.fshader['v_position'] = v_position\n\n        self.clipping_planes = clipping_planes",
  "def coord_system(self) -> str:\n        \"\"\"\n        Coordinate system used by the clipping planes (see visuals.transforms.transform_system.py)\n        \"\"\"\n        # unsettable cause we can't update the transform after being attached\n        return self._coord_system",
  "def _attach(self, visual):\n        super()._attach(visual)\n        self.fshader['itransform'] = visual.get_transform('render', self._coord_system)",
  "def _build_clipping_planes_glsl(n_planes: int) -> str:\n        \"\"\"Build the code snippet used to clip the volume based on self.clipping_planes.\"\"\"\n        func_template = '''\n            float clip_planes(vec3 loc) {{\n                float distance_from_clip = 3.4e38; // max float\n                {clips};\n                return distance_from_clip;\n            }}\n        '''\n        # the vertex is considered clipped if on the \"negative\" side of the plane\n        clip_template = '''\n            vec3 relative_vec{idx} = loc - $clipping_plane_pos{idx};\n            float distance_from_clip{idx} = dot(relative_vec{idx}, $clipping_plane_norm{idx});\n            distance_from_clip = min(distance_from_clip{idx}, distance_from_clip);\n            '''\n        all_clips = []\n        for idx in range(n_planes):\n            all_clips.append(clip_template.format(idx=idx))\n        formatted_code = func_template.format(clips=''.join(all_clips))\n        return formatted_code",
  "def clipping_planes(self) -> np.ndarray:\n        \"\"\"Get the set of planes used to clip the mesh.\n        Each plane is defined by a position and a normal vector (magnitude is irrelevant). Shape: (n_planes, 2, 3)\n        \"\"\"\n        return self._clipping_planes",
  "def clipping_planes(self, value: Optional[np.ndarray]):\n        if value is None:\n            value = np.empty([0, 2, 3])\n        self._clipping_planes = value\n\n        clip_func = Function(self._build_clipping_planes_glsl(len(value)))\n        self.fshader['clip_with_planes'] = clip_func\n\n        for idx, plane in enumerate(value):\n            clip_func[f'clipping_plane_pos{idx}'] = tuple(plane[0])\n            clip_func[f'clipping_plane_norm{idx}'] = tuple(plane[1])",
  "class TextureFilter(Filter):\n    \"\"\"Filter to apply a texture to a mesh.\n\n    Note the texture is applied by multiplying the texture color by the\n    Visual's produced color. By specifying `color=\"white\"` when creating\n    a `MeshVisual` the result will be the unaltered texture value. Any\n    other color, including the default, will result in a blending of that\n    color and the color of the texture.\n\n    Parameters\n    ----------\n    texture : (M, N) or (M, N, C) array\n        The 2D texture image.\n    texcoords : (N, 2) array\n        The texture coordinates.\n    enabled : bool\n        Whether the display of the texture is enabled.\n\n    Examples\n    --------\n    See\n    `examples/basics/scene/mesh_texture.py\n    <https://github.com/vispy/vispy/blob/main/examples/basics/scene/mesh_texture.py>`_\n    example script.\n\n    \"\"\"\n\n    def __init__(self, texture, texcoords, enabled=True):\n        \"\"\"Apply a texture on a mesh.\"\"\"\n        vfunc = Function(\"\"\"\n            void pass_coords() {\n                $v_texcoords = $texcoords;\n            }\n        \"\"\")\n        ffunc = Function(\"\"\"\n            void apply_texture() {\n                if ($enabled == 1) {\n                    gl_FragColor *= texture2D($u_texture, $texcoords);\n                }\n            }\n        \"\"\")\n        self._texcoord_varying = Varying('v_texcoord', 'vec2')\n        vfunc['v_texcoords'] = self._texcoord_varying\n        ffunc['texcoords'] = self._texcoord_varying\n        self._texcoords_buffer = VertexBuffer(\n            np.zeros((0, 2), dtype=np.float32)\n        )\n        vfunc['texcoords'] = self._texcoords_buffer\n        super().__init__(vcode=vfunc, vhook='pre', fcode=ffunc)\n\n        self.enabled = enabled\n        self.texture = texture\n        self.texcoords = texcoords\n\n    @property\n    def enabled(self):\n        \"\"\"True to display the texture, False to disable.\"\"\"\n        return self._enabled\n\n    @enabled.setter\n    def enabled(self, enabled):\n        self._enabled = enabled\n        self.fshader['enabled'] = 1 if enabled else 0\n\n    @property\n    def texture(self):\n        \"\"\"The texture image.\"\"\"\n        return self._texture\n\n    @texture.setter\n    def texture(self, texture):\n        self._texture = texture\n        self.fshader['u_texture'] = Texture2D(texture)\n\n    @property\n    def texcoords(self):\n        \"\"\"The texture coordinates as an (N, 2) array of floats.\"\"\"\n        return self._texcoords\n\n    @texcoords.setter\n    def texcoords(self, texcoords):\n        self._texcoords = texcoords\n        self._update_texcoords_buffer(texcoords)\n\n    def _update_texcoords_buffer(self, texcoords):\n        if not self._attached or self._visual is None:\n            return\n\n        # FIXME: Indices for texture coordinates might be different than face\n        # indices, although in some cases they are the same. Currently,\n        # vispy.io.read_mesh assumes face indices and texture coordinates are\n        # the same.\n        # TODO:\n        # 1. Add reading and returning of texture coordinate indices in\n        #    read_mesh.\n        # 2. Add texture coordinate indices in MeshData from\n        #    vispy.geometry.meshdata\n        # 3. Use mesh_data.get_texcoords_indices() here below.\n        tc = texcoords[self._visual.mesh_data.get_faces()]\n        self._texcoords_buffer.set_data(tc, convert=True)\n\n    def _attach(self, visual):\n        super()._attach(visual)\n        self._update_texcoords_buffer(self._texcoords)",
  "def _as_rgba(intensity_or_color, default_rgb=(1.0, 1.0, 1.0)):\n    \"\"\"Create an RGBA color from a color or a scalar intensity.\n\n    Examples\n    --------\n    >>> # Specify the full RGBA color.\n    >>> _as_rgba((0.2, 0.3, 0.4, 0.25))\n    ... <Color: (0.2, 0.3, 0.4, 0.25)>\n    >>> # Specify an RGB color. (Default intensity `1.0` is used.)\n    >>> _as_rgba((0.2, 0.3, 0.4))\n    ... <Color: (0.2, 0.3, 0.4, 1.0)>\n    >>> # Specify an intensity only. (Default color `(1.0, 1.0, 1.0)` is used.)\n    >>> _as_rgba(0.25)\n    ... <Color: (1.0, 1.0, 1.0, 0.25)>\n    \"\"\"\n    if isinstance(intensity_or_color, numbers.Number):\n        intensity = intensity_or_color\n        return Color(default_rgb, alpha=intensity)\n    color = intensity_or_color\n    return Color(color)",
  "class ShadingFilter(Filter):\n    \"\"\"Apply shading to a :class:`~vispy.visuals.mesh.MeshVisual` using the Phong reflection model.\n\n    For convenience, a :class:`~vispy.visuals.mesh.MeshVisual` creates and\n    embeds a shading filter when constructed with an explicit `shading`\n    parameter, e.g. `mesh = MeshVisual(..., shading='smooth')`. The filter is\n    then accessible as `mesh.shading_filter`.\n\n    When attached manually to a :class:`~vispy.visuals.mesh.MeshVisual`, the\n    shading filter should come after any other filter that modifies the base\n    color to be shaded. See the examples below.\n\n    Parameters\n    ----------\n    shading : str\n        Shading mode: None, 'flat' or 'smooth'. If None, the shading is\n        disabled.\n    ambient_coefficient : str or tuple or Color\n        Color and intensity of the ambient reflection coefficient (Ka).\n    diffuse_coefficient : str or tuple or Color\n        Color and intensity of the diffuse reflection coefficient (Kd).\n    specular_coefficient : str or tuple or Color\n        Color and intensity of the specular reflection coefficient (Ks).\n    shininess : float\n        The shininess controls the size of specular highlight. The higher, the\n        more localized.  Must be greater than or equal to zero.\n    light_dir : array_like\n        Direction of the light. Assuming a directional light.\n    ambient_light : str or tuple or Color\n        Color and intensity of the ambient light.\n    diffuse_light : str or tuple or Color\n        Color and intensity of the diffuse light.\n    specular_light : str or tuple or Color\n        Color and intensity of the specular light.\n    enabled : bool, default=True\n        Whether the filter is enabled at creation time. This can be changed at\n        run time with :obj:`~enabled`.\n\n    Notes\n    -----\n    Under the Phong reflection model, the illumination `I` is computed as::\n\n        I = I_ambient + mesh_color * I_diffuse + I_specular\n\n    for each color channel independently.\n    `mesh_color` is the color of the :class:`~vispy.visuals.mesh.MeshVisual`,\n    possibly modified by the filters applied before this one.\n    The ambient, diffuse and specular terms are defined as::\n\n        I_ambient = Ka * Ia\n        I_diffuse = Kd * Id * dot(L, N)\n        I_specular = Ks * Is * dot(R, V) ** s\n\n    with\n\n    `L`\n        the light direction, assuming a directional light,\n    `N`\n        the normal to the surface at the reflection point,\n    `R`\n        the direction of the reflection,\n    `V`\n        the direction to the viewer,\n    `s`\n        the shininess factor.\n\n    The `Ka`, `Kd` and `Ks` coefficients are defined as an RGBA color. The RGB\n    components define the color that the surface reflects, and the alpha\n    component (A) defines the intensity/attenuation of the reflection. When\n    applied in the per-channel illumation formulas above, the color component\n    is multiplied by the intensity to obtain the final coefficient, e.g.\n    `Kd = R * A` for the red channel.\n\n    Similarly, the light intensities, `Ia`, `Id` and `Is`, are defined by RGBA\n    colors, corresponding to the color of the light and its intensity.\n\n    Examples\n    --------\n    Define the mesh data for a :class:`vispy.visuals.mesh.MeshVisual`:\n\n    >>> # A triangle.\n    >>> vertices = np.array([(0, 0, 0), (1, 1, 1), (0, 1, 0)], dtype=float)\n    >>> faces = np.array([(0, 1, 2)], dtype=int)\n\n    Let the :class:`vispy.visuals.mesh.MeshVisual` create and embed a shading\n    filter:\n\n    >>> mesh = MeshVisual(vertices, faces, shading='smooth')\n    >>> # Configure the filter afterwards.\n    >>> mesh.shading_filter.shininess = 64\n    >>> mesh.shading_filter.specular_coefficient = 0.3\n\n    Create the shading filter manually and attach it to a\n    :class:`vispy.visuals.mesh.MeshVisual`:\n\n    >>> # With the default shading parameters.\n    >>> shading_filter = ShadingFilter()\n    >>> mesh = MeshVisual(vertices, faces)\n    >>> mesh.attach(shading_filter)\n\n    The filter can be configured at creation time and at run time:\n\n    >>> # Configure at creation time.\n    >>> shading_filter = ShadingFilter(\n    ...     # A shiny surface (small specular highlight).\n    ...     shininess=250,\n    ...     # A blue higlight, at half intensity.\n    ...     specular_coefficient=(0, 0, 1, 0.5),\n    ...     # Equivalent to `(0.7, 0.7, 0.7, 1.0)`.\n    ...     diffuse_coefficient=0.7,\n    ...     # Same as `(0.2, 0.3, 0.3, 1.0)`.\n    ...     ambient_coefficient=(0.2, 0.3, 0.3),\n    ... )\n    >>> # Change the configuration at run time.\n    >>> shading_filter.shininess = 64\n    >>> shading_filter.specular_coefficient = 0.3\n\n    Disable the filter temporarily:\n\n    >>> # Turn off the shading.\n    >>> shading_filter.enabled = False\n    ... # Some time passes...\n    >>> # Turn on the shading again.\n    >>> shading_filter.enabled = True\n\n    When using the :class:`WireframeFilter`, the wireframe is shaded only if\n    the wireframe filter is attached before the shading filter:\n\n    >>> shading_filter = ShadingFilter()\n    >>> wireframe_filter = WireframeFilter()\n    >>> # Option 1: Shade the wireframe.\n    >>> mesh1 = MeshVisual(vertices, faces)\n    >>> mesh1.attached(wireframe_filter)\n    >>> mesh1.attached(shading_filter)\n    >>> # Option 2: Do not shade the wireframe.\n    >>> mesh2 = MeshVisual(vertices, faces)\n    >>> mesh2.attached(shading_filter)\n    >>> mesh2.attached(wireframe_filter)\n\n    See also\n    `examples/basics/scene/mesh_shading.py\n    <https://github.com/vispy/vispy/blob/main/examples/basics/scene/mesh_shading.py>`_\n    example script.\n    \"\"\"\n\n    def __init__(self, shading='flat',\n                 ambient_coefficient=(1, 1, 1, 1),\n                 diffuse_coefficient=(1, 1, 1, 1),\n                 specular_coefficient=(1, 1, 1, 1),\n                 shininess=100,\n                 light_dir=(10, 5, -5),\n                 ambient_light=(1, 1, 1, .25),\n                 diffuse_light=(1, 1, 1, 0.7),\n                 specular_light=(1, 1, 1, .25),\n                 enabled=True):\n        self._shading = shading\n\n        self._ambient_coefficient = _as_rgba(ambient_coefficient)\n        self._diffuse_coefficient = _as_rgba(diffuse_coefficient)\n        self._specular_coefficient = _as_rgba(specular_coefficient)\n        self._shininess = shininess\n\n        self._light_dir = light_dir\n        self._ambient_light = _as_rgba(ambient_light)\n        self._diffuse_light = _as_rgba(diffuse_light)\n        self._specular_light = _as_rgba(specular_light)\n\n        self._enabled = enabled\n\n        vfunc = Function(shading_vertex_template)\n        ffunc = Function(shading_fragment_template)\n\n        self._normals = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        vfunc['normal'] = self._normals\n\n        super().__init__(vcode=vfunc, fcode=ffunc)\n\n    @property\n    def enabled(self):\n        \"\"\"True to enable the filter, False to disable.\"\"\"\n        return self._enabled\n\n    @enabled.setter\n    def enabled(self, enabled):\n        self._enabled = enabled\n        self._update_data()\n\n    @property\n    def shading(self):\n        \"\"\"The shading method.\"\"\"\n        return self._shading\n\n    @shading.setter\n    def shading(self, shading):\n        assert shading in (None, 'flat', 'smooth')\n        self._shading = shading\n        self._update_data()\n\n    @property\n    def light_dir(self):\n        \"\"\"The light direction.\"\"\"\n        return self._light_dir\n\n    @light_dir.setter\n    def light_dir(self, direction):\n        direction = np.array(direction, float).ravel()\n        if direction.size != 3 or not np.isfinite(direction).all():\n            raise ValueError('Invalid direction %s' % direction)\n        self._light_dir = tuple(direction)\n        self._update_data()\n\n    @property\n    def ambient_light(self):\n        \"\"\"The color and intensity of the ambient light.\"\"\"\n        return self._ambient_light\n\n    @ambient_light.setter\n    def ambient_light(self, light_color):\n        self._ambient_light = _as_rgba(light_color)\n        self._update_data()\n\n    @property\n    def diffuse_light(self):\n        \"\"\"The color and intensity of the diffuse light.\"\"\"\n        return self._diffuse_light\n\n    @diffuse_light.setter\n    def diffuse_light(self, light_color):\n        self._diffuse_light = _as_rgba(light_color)\n        self._update_data()\n\n    @property\n    def specular_light(self):\n        \"\"\"The color and intensity of the specular light.\"\"\"\n        return self._specular_light\n\n    @specular_light.setter\n    def specular_light(self, light_color):\n        self._specular_light = _as_rgba(light_color)\n        self._update_data()\n\n    @property\n    def ambient_coefficient(self):\n        \"\"\"The ambient reflection coefficient.\"\"\"\n        return self._ambient_coefficient\n\n    @ambient_coefficient.setter\n    def ambient_coefficient(self, color):\n        self._ambient_coefficient = _as_rgba(color)\n        self._update_data()\n\n    @property\n    def diffuse_coefficient(self):\n        \"\"\"The diffuse reflection coefficient.\"\"\"\n        return self._diffuse_coefficient\n\n    @diffuse_coefficient.setter\n    def diffuse_coefficient(self, diffuse_coefficient):\n        self._diffuse_coefficient = _as_rgba(diffuse_coefficient)\n        self._update_data()\n\n    @property\n    def specular_coefficient(self):\n        \"\"\"The specular reflection coefficient.\"\"\"\n        return self._specular_coefficient\n\n    @specular_coefficient.setter\n    def specular_coefficient(self, specular_coefficient):\n        self._specular_coefficient = _as_rgba(specular_coefficient)\n        self._update_data()\n\n    @property\n    def shininess(self):\n        \"\"\"The shininess controlling the spread of the specular highlight.\"\"\"\n        return self._shininess\n\n    @shininess.setter\n    def shininess(self, shininess):\n        self._shininess = float(shininess)\n        self._update_data()\n\n    def _update_data(self):\n        if not self._attached:\n            return\n\n        self.vshader['light_dir'] = self._light_dir\n\n        self.fshader['ambient_light'] = self._ambient_light.rgba\n        self.fshader['diffuse_light'] = self._diffuse_light.rgba\n        self.fshader['specular_light'] = self._specular_light.rgba\n\n        self.fshader['ambient_coefficient'] = self._ambient_coefficient.rgba\n        self.fshader['diffuse_coefficient'] = self._diffuse_coefficient.rgba\n        self.fshader['specular_coefficient'] = self._specular_coefficient.rgba\n        self.fshader['shininess'] = self._shininess\n\n        self.fshader['flat_shading'] = 1 if self._shading == 'flat' else 0\n        self.fshader['shading_enabled'] = (\n            1 if self._enabled and self._shading is not None else 0\n        )\n\n        normals = self._visual.mesh_data.get_vertex_normals(indexed='faces')\n        self._normals.set_data(normals, convert=True)\n\n    def on_mesh_data_updated(self, event):\n        self._update_data()\n\n    def _attach(self, visual):\n        super()._attach(visual)\n\n        render2scene = visual.transforms.get_transform('render', 'scene')\n        visual2scene = visual.transforms.get_transform('visual', 'scene')\n        scene2doc = visual.transforms.get_transform('scene', 'document')\n        doc2scene = visual.transforms.get_transform('document', 'scene')\n        self.vshader['render2scene'] = render2scene\n        self.vshader['visual2scene'] = visual2scene\n        self.vshader['scene2doc'] = scene2doc\n        self.vshader['doc2scene'] = doc2scene\n\n        if self._visual.mesh_data is not None:\n            self._update_data()\n\n        visual.events.data_updated.connect(self.on_mesh_data_updated)\n\n    def _detach(self, visual):\n        visual.events.data_updated.disconnect(self.on_mesh_data_updated)\n        super()._detach(visual)",
  "class WireframeFilter(Filter):\n    \"\"\"Add wireframe to a mesh.\n\n    The wireframe filter should be attached before the shading filter for the\n    wireframe to be shaded.\n\n    Parameters\n    ----------\n    color : str or tuple or Color\n        Line color of the wireframe\n    width : float\n        Line width of the wireframe\n    enabled : bool\n        Whether the wireframe is drawn or not\n\n    Examples\n    --------\n    See\n    `examples/basics/scene/mesh_shading.py\n    <https://github.com/vispy/vispy/blob/main/examples/basics/scene/mesh_shading.py>`_\n    example script.\n\n    \"\"\"\n\n    def __init__(self, enabled=True, color='black', width=1.0,\n                 wireframe_only=False, faces_only=False):\n        self._attached = False\n        self._color = Color(color)\n        self._width = width\n        self._enabled = enabled\n        self._wireframe_only = wireframe_only\n        self._faces_only = faces_only\n\n        vfunc = Function(wireframe_vertex_template)\n        ffunc = Function(wireframe_fragment_template)\n\n        self._bc = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        vfunc['bc'] = self._bc\n\n        super().__init__(vcode=vfunc, fcode=ffunc)\n        self.enabled = enabled\n\n    @property\n    def enabled(self):\n        \"\"\"True to enable the display of the wireframe, False to disable.\"\"\"\n        return self._enabled\n\n    @enabled.setter\n    def enabled(self, enabled):\n        self._enabled = enabled\n        self.fshader['enabled'] = 1 if enabled else 0\n        self._update_data()\n\n    @property\n    def color(self):\n        \"\"\"The wireframe color.\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        self._color = Color(color)\n        self._update_data()\n\n    @property\n    def width(self):\n        \"\"\"The wireframe width.\"\"\"\n        return self._width\n\n    @width.setter\n    def width(self, width):\n        if width < 0:\n            raise ValueError(\"width must be greater than zero\")\n        self._width = width\n        self._update_data()\n\n    @property\n    def wireframe_only(self):\n        \"\"\"Draw only the wireframe and discard the interior of the faces.\"\"\"\n        return self._wireframe_only\n\n    @wireframe_only.setter\n    def wireframe_only(self, wireframe_only):\n        self._wireframe_only = wireframe_only\n        self._update_data()\n\n    @property\n    def faces_only(self):\n        \"\"\"Make the wireframe transparent.\n\n        Draw only the interior of the faces.\n        \"\"\"\n        return self._faces_only\n\n    @faces_only.setter\n    def faces_only(self, faces_only):\n        self._faces_only = faces_only\n        self._update_data()\n\n    def _update_data(self):\n        if not self.attached:\n            return\n        self.fshader['color'] = self._color.rgba\n        self.fshader['width'] = self._width\n        self.fshader['wireframe_only'] = 1 if self._wireframe_only else 0\n        self.fshader['faces_only'] = 1 if self._faces_only else 0\n        if self._visual.mesh_data.is_empty():\n            n_faces = 0\n        else:\n            n_faces = len(self._visual.mesh_data.get_faces())\n        bc = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype='float')\n        bc = np.tile(bc[None, ...], (n_faces, 1, 1))\n        self._bc.set_data(bc, convert=True)\n\n    def on_mesh_data_updated(self, event):\n        self._update_data()\n\n    def _attach(self, visual):\n        super()._attach(visual)\n        visual.events.data_updated.connect(self.on_mesh_data_updated)\n\n    def _detach(self, visual):\n        visual.events.data_updated.disconnect(self.on_mesh_data_updated)\n        super()._detach(visual)",
  "def __init__(self, texture, texcoords, enabled=True):\n        \"\"\"Apply a texture on a mesh.\"\"\"\n        vfunc = Function(\"\"\"\n            void pass_coords() {\n                $v_texcoords = $texcoords;\n            }\n        \"\"\")\n        ffunc = Function(\"\"\"\n            void apply_texture() {\n                if ($enabled == 1) {\n                    gl_FragColor *= texture2D($u_texture, $texcoords);\n                }\n            }\n        \"\"\")\n        self._texcoord_varying = Varying('v_texcoord', 'vec2')\n        vfunc['v_texcoords'] = self._texcoord_varying\n        ffunc['texcoords'] = self._texcoord_varying\n        self._texcoords_buffer = VertexBuffer(\n            np.zeros((0, 2), dtype=np.float32)\n        )\n        vfunc['texcoords'] = self._texcoords_buffer\n        super().__init__(vcode=vfunc, vhook='pre', fcode=ffunc)\n\n        self.enabled = enabled\n        self.texture = texture\n        self.texcoords = texcoords",
  "def enabled(self):\n        \"\"\"True to display the texture, False to disable.\"\"\"\n        return self._enabled",
  "def enabled(self, enabled):\n        self._enabled = enabled\n        self.fshader['enabled'] = 1 if enabled else 0",
  "def texture(self):\n        \"\"\"The texture image.\"\"\"\n        return self._texture",
  "def texture(self, texture):\n        self._texture = texture\n        self.fshader['u_texture'] = Texture2D(texture)",
  "def texcoords(self):\n        \"\"\"The texture coordinates as an (N, 2) array of floats.\"\"\"\n        return self._texcoords",
  "def texcoords(self, texcoords):\n        self._texcoords = texcoords\n        self._update_texcoords_buffer(texcoords)",
  "def _update_texcoords_buffer(self, texcoords):\n        if not self._attached or self._visual is None:\n            return\n\n        # FIXME: Indices for texture coordinates might be different than face\n        # indices, although in some cases they are the same. Currently,\n        # vispy.io.read_mesh assumes face indices and texture coordinates are\n        # the same.\n        # TODO:\n        # 1. Add reading and returning of texture coordinate indices in\n        #    read_mesh.\n        # 2. Add texture coordinate indices in MeshData from\n        #    vispy.geometry.meshdata\n        # 3. Use mesh_data.get_texcoords_indices() here below.\n        tc = texcoords[self._visual.mesh_data.get_faces()]\n        self._texcoords_buffer.set_data(tc, convert=True)",
  "def _attach(self, visual):\n        super()._attach(visual)\n        self._update_texcoords_buffer(self._texcoords)",
  "def __init__(self, shading='flat',\n                 ambient_coefficient=(1, 1, 1, 1),\n                 diffuse_coefficient=(1, 1, 1, 1),\n                 specular_coefficient=(1, 1, 1, 1),\n                 shininess=100,\n                 light_dir=(10, 5, -5),\n                 ambient_light=(1, 1, 1, .25),\n                 diffuse_light=(1, 1, 1, 0.7),\n                 specular_light=(1, 1, 1, .25),\n                 enabled=True):\n        self._shading = shading\n\n        self._ambient_coefficient = _as_rgba(ambient_coefficient)\n        self._diffuse_coefficient = _as_rgba(diffuse_coefficient)\n        self._specular_coefficient = _as_rgba(specular_coefficient)\n        self._shininess = shininess\n\n        self._light_dir = light_dir\n        self._ambient_light = _as_rgba(ambient_light)\n        self._diffuse_light = _as_rgba(diffuse_light)\n        self._specular_light = _as_rgba(specular_light)\n\n        self._enabled = enabled\n\n        vfunc = Function(shading_vertex_template)\n        ffunc = Function(shading_fragment_template)\n\n        self._normals = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        vfunc['normal'] = self._normals\n\n        super().__init__(vcode=vfunc, fcode=ffunc)",
  "def enabled(self):\n        \"\"\"True to enable the filter, False to disable.\"\"\"\n        return self._enabled",
  "def enabled(self, enabled):\n        self._enabled = enabled\n        self._update_data()",
  "def shading(self):\n        \"\"\"The shading method.\"\"\"\n        return self._shading",
  "def shading(self, shading):\n        assert shading in (None, 'flat', 'smooth')\n        self._shading = shading\n        self._update_data()",
  "def light_dir(self):\n        \"\"\"The light direction.\"\"\"\n        return self._light_dir",
  "def light_dir(self, direction):\n        direction = np.array(direction, float).ravel()\n        if direction.size != 3 or not np.isfinite(direction).all():\n            raise ValueError('Invalid direction %s' % direction)\n        self._light_dir = tuple(direction)\n        self._update_data()",
  "def ambient_light(self):\n        \"\"\"The color and intensity of the ambient light.\"\"\"\n        return self._ambient_light",
  "def ambient_light(self, light_color):\n        self._ambient_light = _as_rgba(light_color)\n        self._update_data()",
  "def diffuse_light(self):\n        \"\"\"The color and intensity of the diffuse light.\"\"\"\n        return self._diffuse_light",
  "def diffuse_light(self, light_color):\n        self._diffuse_light = _as_rgba(light_color)\n        self._update_data()",
  "def specular_light(self):\n        \"\"\"The color and intensity of the specular light.\"\"\"\n        return self._specular_light",
  "def specular_light(self, light_color):\n        self._specular_light = _as_rgba(light_color)\n        self._update_data()",
  "def ambient_coefficient(self):\n        \"\"\"The ambient reflection coefficient.\"\"\"\n        return self._ambient_coefficient",
  "def ambient_coefficient(self, color):\n        self._ambient_coefficient = _as_rgba(color)\n        self._update_data()",
  "def diffuse_coefficient(self):\n        \"\"\"The diffuse reflection coefficient.\"\"\"\n        return self._diffuse_coefficient",
  "def diffuse_coefficient(self, diffuse_coefficient):\n        self._diffuse_coefficient = _as_rgba(diffuse_coefficient)\n        self._update_data()",
  "def specular_coefficient(self):\n        \"\"\"The specular reflection coefficient.\"\"\"\n        return self._specular_coefficient",
  "def specular_coefficient(self, specular_coefficient):\n        self._specular_coefficient = _as_rgba(specular_coefficient)\n        self._update_data()",
  "def shininess(self):\n        \"\"\"The shininess controlling the spread of the specular highlight.\"\"\"\n        return self._shininess",
  "def shininess(self, shininess):\n        self._shininess = float(shininess)\n        self._update_data()",
  "def _update_data(self):\n        if not self._attached:\n            return\n\n        self.vshader['light_dir'] = self._light_dir\n\n        self.fshader['ambient_light'] = self._ambient_light.rgba\n        self.fshader['diffuse_light'] = self._diffuse_light.rgba\n        self.fshader['specular_light'] = self._specular_light.rgba\n\n        self.fshader['ambient_coefficient'] = self._ambient_coefficient.rgba\n        self.fshader['diffuse_coefficient'] = self._diffuse_coefficient.rgba\n        self.fshader['specular_coefficient'] = self._specular_coefficient.rgba\n        self.fshader['shininess'] = self._shininess\n\n        self.fshader['flat_shading'] = 1 if self._shading == 'flat' else 0\n        self.fshader['shading_enabled'] = (\n            1 if self._enabled and self._shading is not None else 0\n        )\n\n        normals = self._visual.mesh_data.get_vertex_normals(indexed='faces')\n        self._normals.set_data(normals, convert=True)",
  "def on_mesh_data_updated(self, event):\n        self._update_data()",
  "def _attach(self, visual):\n        super()._attach(visual)\n\n        render2scene = visual.transforms.get_transform('render', 'scene')\n        visual2scene = visual.transforms.get_transform('visual', 'scene')\n        scene2doc = visual.transforms.get_transform('scene', 'document')\n        doc2scene = visual.transforms.get_transform('document', 'scene')\n        self.vshader['render2scene'] = render2scene\n        self.vshader['visual2scene'] = visual2scene\n        self.vshader['scene2doc'] = scene2doc\n        self.vshader['doc2scene'] = doc2scene\n\n        if self._visual.mesh_data is not None:\n            self._update_data()\n\n        visual.events.data_updated.connect(self.on_mesh_data_updated)",
  "def _detach(self, visual):\n        visual.events.data_updated.disconnect(self.on_mesh_data_updated)\n        super()._detach(visual)",
  "def __init__(self, enabled=True, color='black', width=1.0,\n                 wireframe_only=False, faces_only=False):\n        self._attached = False\n        self._color = Color(color)\n        self._width = width\n        self._enabled = enabled\n        self._wireframe_only = wireframe_only\n        self._faces_only = faces_only\n\n        vfunc = Function(wireframe_vertex_template)\n        ffunc = Function(wireframe_fragment_template)\n\n        self._bc = VertexBuffer(np.zeros((0, 3), dtype=np.float32))\n        vfunc['bc'] = self._bc\n\n        super().__init__(vcode=vfunc, fcode=ffunc)\n        self.enabled = enabled",
  "def enabled(self):\n        \"\"\"True to enable the display of the wireframe, False to disable.\"\"\"\n        return self._enabled",
  "def enabled(self, enabled):\n        self._enabled = enabled\n        self.fshader['enabled'] = 1 if enabled else 0\n        self._update_data()",
  "def color(self):\n        \"\"\"The wireframe color.\"\"\"\n        return self._color",
  "def color(self, color):\n        self._color = Color(color)\n        self._update_data()",
  "def width(self):\n        \"\"\"The wireframe width.\"\"\"\n        return self._width",
  "def width(self, width):\n        if width < 0:\n            raise ValueError(\"width must be greater than zero\")\n        self._width = width\n        self._update_data()",
  "def wireframe_only(self):\n        \"\"\"Draw only the wireframe and discard the interior of the faces.\"\"\"\n        return self._wireframe_only",
  "def wireframe_only(self, wireframe_only):\n        self._wireframe_only = wireframe_only\n        self._update_data()",
  "def faces_only(self):\n        \"\"\"Make the wireframe transparent.\n\n        Draw only the interior of the faces.\n        \"\"\"\n        return self._faces_only",
  "def faces_only(self, faces_only):\n        self._faces_only = faces_only\n        self._update_data()",
  "def _update_data(self):\n        if not self.attached:\n            return\n        self.fshader['color'] = self._color.rgba\n        self.fshader['width'] = self._width\n        self.fshader['wireframe_only'] = 1 if self._wireframe_only else 0\n        self.fshader['faces_only'] = 1 if self._faces_only else 0\n        if self._visual.mesh_data.is_empty():\n            n_faces = 0\n        else:\n            n_faces = len(self._visual.mesh_data.get_faces())\n        bc = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype='float')\n        bc = np.tile(bc[None, ...], (n_faces, 1, 1))\n        self._bc.set_data(bc, convert=True)",
  "def on_mesh_data_updated(self, event):\n        self._update_data()",
  "def _attach(self, visual):\n        super()._attach(visual)\n        visual.events.data_updated.connect(self.on_mesh_data_updated)",
  "def _detach(self, visual):\n        visual.events.data_updated.disconnect(self.on_mesh_data_updated)\n        super()._detach(visual)",
  "class PickingFilter(Filter):\n    \"\"\"Filter used to color visuals by a picking ID.\n\n    Note that the ID color uses the alpha channel, so this may not be used\n    with blending enabled.\n    \"\"\"\n\n    FRAG_SHADER = \"\"\"\n        void picking_filter() {\n            if( $enabled == 0 )\n                return;\n            if( gl_FragColor.a == 0.0 )\n                discard;\n            gl_FragColor = $id_color;\n        }\n    \"\"\"\n\n    def __init__(self, id_=None):\n        super(PickingFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=10)\n\n        self.id = id_\n        self.enabled = False\n\n    @property\n    def id(self):\n        return self._id\n\n    @id.setter\n    def id(self, id):\n        if id < 1:\n            raise ValueError('Picking ID must be integer > 0.')\n        id_color = struct.unpack('<4B', struct.pack('<I', id))\n        self.fshader['id_color'] = [x/255. for x in id_color]\n        self._id = id\n        self._id_color = id_color\n\n    @property\n    def enabled(self):\n        return self._enabled\n\n    @enabled.setter\n    def enabled(self, e):\n        self._enabled = e\n        self.fshader['enabled'] = 1 if e is True else 0\n\n    @property\n    def color(self):\n        \"\"\"The RGBA color that will be drawn to the framebuffer for visuals\n        that use this filter.\n        \"\"\"\n        return self._id_color",
  "def __init__(self, id_=None):\n        super(PickingFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=10)\n\n        self.id = id_\n        self.enabled = False",
  "def id(self):\n        return self._id",
  "def id(self, id):\n        if id < 1:\n            raise ValueError('Picking ID must be integer > 0.')\n        id_color = struct.unpack('<4B', struct.pack('<I', id))\n        self.fshader['id_color'] = [x/255. for x in id_color]\n        self._id = id\n        self._id_color = id_color",
  "def enabled(self):\n        return self._enabled",
  "def enabled(self, e):\n        self._enabled = e\n        self.fshader['enabled'] = 1 if e is True else 0",
  "def color(self):\n        \"\"\"The RGBA color that will be drawn to the framebuffer for visuals\n        that use this filter.\n        \"\"\"\n        return self._id_color",
  "class IsolineFilter(Filter):\n    FRAG_SHADER = \"\"\"\n        void isoline() {\n            if ($isolevel <= 0. || $isowidth <= 0.) {\n                return;\n            }\n\n            // function taken from glumpy/examples/isocurves.py\n            // and extended to have level, width, color and antialiasing\n            // as parameters\n\n            // Extract data value\n            // this accounts for perception,\n            // have to decide, which one to use or make this a uniform\n            const vec3 w = vec3(0.299, 0.587, 0.114);\n            //const vec3 w = vec3(0.2126, 0.7152, 0.0722);\n            float value = dot(gl_FragColor.rgb, w);\n\n            // setup lw, aa\n            float linewidth = $isowidth + $antialias;\n\n            // \"middle\" contour(s) dividing upper and lower half\n            // but only if isolevel is even\n            if( mod($isolevel,2.0) == 0.0 ) {\n                if( length(value - 0.5) < 0.5 / $isolevel)\n                    linewidth = linewidth * 2;\n            }\n\n            // Trace contour isoline\n            float v  = $isolevel * value - 0.5;\n            float dv = linewidth/2.0 * fwidth(v);\n            float f = abs(fract(v) - 0.5);\n            float d = smoothstep(-dv, +dv, f);\n            float t = linewidth/2.0 - $antialias;\n            d = abs(d)*linewidth/2.0 - t;\n\n            if( d < - linewidth ) {\n                d = 1.0;\n            } else  {\n                 d /= $antialias;\n            }\n\n            // setup foreground\n            vec4 fc = $isocolor;\n\n            // mix with background\n            if (d < 1.) {\n                gl_FragColor = mix(gl_FragColor, fc, 1-d);\n            }\n\n        }\n    \"\"\"\n\n    def __init__(self, level=2., width=2.0, antialias=1.0, color='black', **kwargs):\n        super(IsolineFilter, self).__init__(fcode=self.FRAG_SHADER, **kwargs)\n\n        self.level = level\n        self.width = width\n        self.color = color\n        self.antialias = antialias\n\n    @property\n    def level(self):\n        return self._level\n\n    @level.setter\n    def level(self, lev):\n        if lev <= 0:\n            lev = 0\n        self._level = lev\n        self.fshader['isolevel'] = float(lev)\n\n    @property\n    def width(self):\n        return self._width\n\n    @width.setter\n    def width(self, w):\n        self._width = w\n        self.fshader['isowidth'] = float(w)\n\n    @property\n    def color(self):\n        return self._color\n\n    @color.setter\n    def color(self, c):\n        self._color = c\n        self.fshader['isocolor'] = Color(c).rgba\n\n    @property\n    def antialias(self):\n        return self._antialias\n\n    @antialias.setter\n    def antialias(self, a):\n        self._antialias = a\n        self.fshader['antialias'] = float(a)",
  "class Alpha(Filter):\n    FRAG_SHADER = \"\"\"\n        void apply_alpha() {\n            gl_FragColor.a = gl_FragColor.a * $alpha;\n        }\n    \"\"\"\n\n    def __init__(self, alpha=1.0, **kwargs):\n        super(Alpha, self).__init__(fcode=self.FRAG_SHADER, **kwargs)\n\n        self.alpha = alpha\n\n    @property\n    def alpha(self):\n        return self._alpha\n\n    @alpha.setter\n    def alpha(self, a):\n        self._alpha = a\n        self.fshader['alpha'] = float(a)",
  "class ColorFilter(Filter):\n    FRAG_SHADER = \"\"\"\n        void apply_color_filter() {\n            gl_FragColor = gl_FragColor * $filter;\n        }\n    \"\"\"\n\n    def __init__(self, filter=(1., 1., 1., 1.), fpos=8, **kwargs):\n        super(ColorFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=fpos, **kwargs)\n\n        self.filter = filter\n\n    @property\n    def filter(self):\n        return self._filter\n\n    @filter.setter\n    def filter(self, f):\n        self._filter = tuple(f)\n        self.fshader['filter'] = self._filter",
  "class ZColormapFilter(Filter):\n    FRAG_SHADER = \"\"\"\n        void z_colormap_support() {\n            $zval = $position.z;\n        }\n    \"\"\"\n    VERT_SHADER = \"\"\"\n        void apply_z_colormap() {\n            gl_FragColor = $cmap(($zval - $zrange.x) /\n                                 ($zrange.y - $zrange.x));\n        }\n    \"\"\"\n\n    def __init__(self, cmap, zrange=(0., 1.), fpos=3, vpos=9, **kwargs):\n        super(ZColormapFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=fpos,\n                                              vcode=self.VERT_SHADER, vpos=vpos, **kwargs)\n\n        if isinstance(cmap, str):\n            cmap = colormap.get_colormap(cmap)\n        self.cmap = Function(cmap.glsl_map)\n        self.fshader['cmap'] = self.cmap\n        self.fshader['zrange'] = zrange\n        self.vshader['zval'] = Varying('v_zval', dtype='float')\n        self.fshader['zval'] = self.vshader['zval']\n\n    def _attach(self, visual):\n        super(ZColormapFilter, self)._attach(visual)\n        self.vshader['position'] = visual.shared_program.vert['position']",
  "def __init__(self, level=2., width=2.0, antialias=1.0, color='black', **kwargs):\n        super(IsolineFilter, self).__init__(fcode=self.FRAG_SHADER, **kwargs)\n\n        self.level = level\n        self.width = width\n        self.color = color\n        self.antialias = antialias",
  "def level(self):\n        return self._level",
  "def level(self, lev):\n        if lev <= 0:\n            lev = 0\n        self._level = lev\n        self.fshader['isolevel'] = float(lev)",
  "def width(self):\n        return self._width",
  "def width(self, w):\n        self._width = w\n        self.fshader['isowidth'] = float(w)",
  "def color(self):\n        return self._color",
  "def color(self, c):\n        self._color = c\n        self.fshader['isocolor'] = Color(c).rgba",
  "def antialias(self):\n        return self._antialias",
  "def antialias(self, a):\n        self._antialias = a\n        self.fshader['antialias'] = float(a)",
  "def __init__(self, alpha=1.0, **kwargs):\n        super(Alpha, self).__init__(fcode=self.FRAG_SHADER, **kwargs)\n\n        self.alpha = alpha",
  "def alpha(self):\n        return self._alpha",
  "def alpha(self, a):\n        self._alpha = a\n        self.fshader['alpha'] = float(a)",
  "def __init__(self, filter=(1., 1., 1., 1.), fpos=8, **kwargs):\n        super(ColorFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=fpos, **kwargs)\n\n        self.filter = filter",
  "def filter(self):\n        return self._filter",
  "def filter(self, f):\n        self._filter = tuple(f)\n        self.fshader['filter'] = self._filter",
  "def __init__(self, cmap, zrange=(0., 1.), fpos=3, vpos=9, **kwargs):\n        super(ZColormapFilter, self).__init__(fcode=self.FRAG_SHADER, fpos=fpos,\n                                              vcode=self.VERT_SHADER, vpos=vpos, **kwargs)\n\n        if isinstance(cmap, str):\n            cmap = colormap.get_colormap(cmap)\n        self.cmap = Function(cmap.glsl_map)\n        self.fshader['cmap'] = self.cmap\n        self.fshader['zrange'] = zrange\n        self.vshader['zval'] = Varying('v_zval', dtype='float')\n        self.fshader['zval'] = self.vshader['zval']",
  "def _attach(self, visual):\n        super(ZColormapFilter, self)._attach(visual)\n        self.vshader['position'] = visual.shared_program.vert['position']",
  "def dtype_reduce(dtype, level=0, depth=0):\n    \"\"\"Try to reduce dtype up to a given level when it is possible.\n\n    Examples\n    --------\n    >>> dtype =  [ ('vertex',  [('x', 'f4'), ('y', 'f4'), ('z', 'f4')]),\n    ...            ('normal',  [('x', 'f4'), ('y', 'f4'), ('z', 'f4')]),\n    ...            ('color',   [('r', 'f4'), ('g', 'f4'), ('b', 'f4'),\n    ...                         ('a', 'f4')])]\n\n    level 0 result::\n\n        ['color,vertex,normal,', 10, 'float32']\n\n    level 1 result::\n\n        [['color', 4, 'float32']\n         ['normal', 3, 'float32']\n         ['vertex', 3, 'float32']]\n\n    \"\"\"\n    dtype = np.dtype(dtype)\n    fields = dtype.fields\n\n    # No fields\n    if fields is None:\n        if len(dtype.shape):\n            count = reduce(mul, dtype.shape)\n        else:\n            count = 1\n        # size = dtype.itemsize / count\n        if dtype.subdtype:\n            name = str(dtype.subdtype[0])\n        else:\n            name = str(dtype)\n        return ['', count, name]\n    else:\n        items = []\n        name = ''\n        # Get reduced fields\n        for key, value in fields.items():\n            dtype_list = dtype_reduce(value[0], level, depth + 1)\n            if isinstance(dtype_list[0], str):\n                items.append([key, dtype_list[1], dtype_list[2]])\n            else:\n                items.append(dtype_list)\n            name += key + ','\n\n        # Check if we can reduce item list\n        ctype = None\n        count = 0\n        for i, item in enumerate(items):\n            # One item is a list, we cannot reduce\n            if not isinstance(item[0], str):\n                return items\n            else:\n                if i == 0:\n                    ctype = item[2]\n                    count += item[1]\n                else:\n                    if item[2] != ctype:\n                        return items\n                    count += item[1]\n        if depth >= level:\n            return [name, count, ctype]\n        else:\n            return items",
  "def fetchcode(utype, prefix=\"\"):\n    \"\"\"Generate the GLSL code needed to retrieve fake uniform values from a texture.\n\n    Parameters\n    ----------\n    uniforms : sampler2D\n        Texture to fetch uniforms from\n    uniforms_shape: vec3\n        Size of texture (width,height,count) where count is the number of float\n        to be fetched.\n    collection_index: float\n        Attribute giving the index of the uniforms to be fetched. This index\n        relates to the index in the uniform array from python side.\n\n    \"\"\"\n    utype = np.dtype(utype)\n    _utype = dtype_reduce(utype, level=1)\n\n    header = \"\"\"\nuniform   sampler2D uniforms;\nuniform   vec3      uniforms_shape;\nattribute float     collection_index;\n\n\"\"\"\n\n    # Header generation (easy)\n    types = {1: 'float', 2: 'vec2 ', 3: 'vec3 ',\n             4: 'vec4 ', 9: 'mat3 ', 16: 'mat4 '}\n    for name, count, _ in _utype:\n        if name != '__unused__':\n            header += \"varying %s %s%s;\\n\" % (types[count], prefix, name)\n\n    # Body generation (not so easy)\n    body = \"\"\"\\nvoid fetch_uniforms() {\n    float rows   = uniforms_shape.x;\n    float cols   = uniforms_shape.y;\n    float count  = uniforms_shape.z;\n    float index  = collection_index;\n    int index_x  = int(mod(index, (floor(cols/(count/4.0))))) * int(count/4.0);\n    int index_y  = int(floor(index / (floor(cols/(count/4.0)))));\n    float size_x = cols - 1.0;\n    float size_y = rows - 1.0;\n    float ty     = 0.0;\n    if (size_y > 0.0)\n        ty = float(index_y)/size_y;\n    int i = index_x;\n    vec4 _uniform;\\n\"\"\"\n\n    _utype = dict([(name, count) for name, count, _ in _utype])\n    store = 0\n    # Be very careful with utype name order (_utype.keys is wrong)\n    for name in utype.names:\n        if name == '__unused__':\n            continue\n        count, shift = _utype[name], 0\n        size = count\n        while count:\n            if store == 0:\n                body += \"\\n    _uniform = texture2D(uniforms, vec2(float(i++)/size_x,ty));\\n\"  # noqa\n                store = 4\n            if store == 4:\n                a = \"xyzw\"\n            elif store == 3:\n                a = \"yzw\"\n            elif store == 2:\n                a = \"zw\"\n            elif store == 1:\n                a = \"w\"\n            if shift == 0:\n                b = \"xyzw\"\n            elif shift == 1:\n                b = \"yzw\"\n            elif shift == 2:\n                b = \"zw\"\n            elif shift == 3:\n                b = \"w\"\n            i = min(min(len(b), count), len(a))\n            if size > 1:\n                body += \"    %s%s.%s = _uniform.%s;\\n\" % (prefix, name, b[:i], a[:i])  # noqa\n            else:\n                body += \"    %s%s = _uniform.%s;\\n\" % (prefix, name, a[:i])\n            count -= i\n            shift += i\n            store -= i\n\n    body += \"\"\"}\\n\\n\"\"\"\n    return header + body",
  "class RawTriangleCollection(Collection):\n\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-triangle.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-triangle.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform\n\n    def append(self, points, indices, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        points : np.array\n            Vertices composing the triangles\n\n        indices : np.array\n            Indices describing triangles\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = len(points)\n        itemcount = 1\n\n        V = np.empty(itemcount * itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'position']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = points\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=np.array(indices).ravel(),\n                          itemsize=itemsize)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-triangle.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-triangle.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform",
  "def append(self, points, indices, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        points : np.array\n            Vertices composing the triangles\n\n        indices : np.array\n            Indices describing triangles\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = len(points)\n        itemcount = 1\n\n        V = np.empty(itemcount * itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'position']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = points\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=np.array(indices).ravel(),\n                          itemsize=itemsize)",
  "def PolygonCollection(mode=\"raw\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\"   (speed: fastest, size: small, output: ugly, no dash, no\n                 thickness)\n      - \"agg\"   (speed: medium,  size: medium output: nice, some flaws, no\n                 dash)\n      - \"agg+\"  (speed: slow, size: big, output: perfect, no dash)\n    \"\"\"\n    # if mode == \"raw\":\n    return RawPolygonCollection(*args, **kwargs)",
  "class ArrayList(object):\n    \"\"\"\n    An ArrayList is a strongly typed list whose type can be anything that can\n    be interpreted as a numpy data type.\n    \"\"\"\n\n    def __init__(self, data=None, itemsize=None, dtype=float,\n                 sizeable=True, writeable=True):\n        \"\"\"Create a new buffer using given data and sizes or dtype\n\n        Parameters\n        ----------\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n\n        dtype: np.dtype\n            Any object that can be interpreted as a numpy data type.\n\n        sizeable : boolean\n            Indicate whether item can be appended/inserted/deleted\n\n        writeable : boolean\n            Indicate whether content can be changed\n        \"\"\"\n        self._sizeable = sizeable\n        self._writeable = writeable\n\n        if data is not None:\n            if isinstance(data, (list, tuple)):\n                if isinstance(data[0], (list, tuple)):\n                    itemsize = [len(sublist) for sublist in data]\n                    data = [item for sublist in data for item in sublist]\n            self._data = np.array(data, copy=False)\n            self._size = self._data.size\n\n            # Default is one group with all data inside\n            _itemsize = np.ones(1) * self._data.size\n\n            # Check item sizes and get items count\n            if itemsize is not None:\n                if isinstance(itemsize, int):\n                    if (self._size % itemsize) != 0:\n                        raise ValueError(\"Cannot partition data as requested\")\n                    self._count = self._size // itemsize\n                    _itemsize = np.ones(\n                        self._count, dtype=int) * (self._size // self._count)\n                else:\n                    _itemsize = np.array(itemsize, copy=False)\n                    self._count = len(itemsize)\n                    if _itemsize.sum() != self._size:\n                        raise ValueError(\"Cannot partition data as requested\")\n            else:\n                self._count = 1\n\n            # Store items\n            self._items = np.zeros((self._count, 2), int)\n            C = _itemsize.cumsum()\n            self._items[1:, 0] += C[:-1]\n            self._items[0:, 1] += C\n\n        else:\n            self._data = np.zeros(1, dtype=dtype)\n            self._items = np.zeros((1, 2), dtype=int)\n            self._size = 0\n            self._count = 0\n\n    @property\n    def data(self):\n        \"\"\"The array's elements, in memory.\"\"\"\n        return self._data[:self._size]\n\n    @property\n    def size(self):\n        \"\"\"Number of base elements, in memory.\"\"\"\n        return self._size\n\n    @property\n    def itemsize(self):\n        \"\"\"Individual item sizes\"\"\"\n        return self._items[:self._count, 1] - self._items[:self._count, 0]\n\n    @property\n    def dtype(self):\n        \"\"\"Describes the format of the elements in the buffer.\"\"\"\n        return self._data.dtype\n\n    def reserve(self, capacity):\n        \"\"\"Set current capacity of the underlying array\"\"\"\n        if capacity >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(capacity)))\n            self._data = np.resize(self._data, capacity)\n\n    def __len__(self):\n        \"\"\"x.__len__() <==> len(x)\"\"\"\n        return self._count\n\n    def __str__(self):\n        s = '[ '\n        for item in self:\n            s += str(item) + ' '\n        s += ']'\n        return s\n\n    def __getitem__(self, key):\n        \"\"\"x.__getitem__(y) <==> x[y]\"\"\"\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key >= len(self):\n                raise IndexError(\"Tuple index out of range\")\n            dstart = self._items[key][0]\n            dstop = self._items[key][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            dstart = self._items[istart][0]\n            if istart == istop:\n                dstop = dstart\n            else:\n                dstop = self._items[istop - 1][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, str):\n            return self._data[key][:self._size]\n\n        elif key is Ellipsis:\n            return self.data\n\n        else:\n            raise TypeError(\"List indices must be integers\")\n\n    def __setitem__(self, key, data):\n        \"\"\"x.__setitem__(i, y) <==> x[i]=y\"\"\"\n        if not self._writeable:\n            raise AttributeError(\"List is not writeable\")\n\n        if isinstance(key, (int, slice)):\n            if isinstance(key, int):\n                if key < 0:\n                    key += len(self)\n                if key < 0 or key > len(self):\n                    raise IndexError(\"List assignment index out of range\")\n                dstart = self._items[key][0]\n                dstop = self._items[key][1]\n                istart = key\n            elif isinstance(key, slice):\n                istart, istop, step = key.indices(len(self))\n                if istart == istop:\n                    return\n                if istart > istop:\n                    istart, istop = istop, istart\n                if istart > len(self) or istop > len(self):\n                    raise IndexError(\"Can only assign iterable\")\n                dstart = self._items[istart][0]\n                if istart == istop:\n                    dstop = dstart\n                else:\n                    dstop = self._items[istop - 1][1]\n\n            if hasattr(data, \"__len__\"):\n                if len(data) == dstop - dstart:  # or len(data) == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart, data)\n            else:  # we assume len(data) = 1\n                if dstop - dstart == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart, data)\n\n        elif key is Ellipsis:\n            self.data[...] = data\n\n        elif isinstance(key, str):\n            self._data[key][:self._size] = data\n\n        else:\n            raise TypeError(\"List assignment indices must be integers\")\n\n    def __delitem__(self, key):\n        \"\"\"x.__delitem__(y) <==> del x[y]\"\"\"\n        if not self._sizeable:\n            raise AttributeError(\"List is not sizeable\")\n\n        # Deleting a single item\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key > len(self):\n                raise IndexError(\"List deletion index out of range\")\n            istart, istop = key, key + 1\n            dstart, dstop = self._items[key]\n\n        # Deleting several items\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n            dstart = self._items[istart][0]\n            dstop = self._items[istop - 1][1]\n\n        elif key is Ellipsis:\n            istart = 0\n            istop = len(self)\n            dstart = 0\n            dstop = self.size\n        # Error\n        else:\n            raise TypeError(\"List deletion indices must be integers\")\n\n        # Remove data\n        size = self._size - (dstop - dstart)\n        self._data[\n            dstart:dstart + self._size - dstop] = self._data[dstop:self._size]\n        self._size -= dstop - dstart\n\n        # Remove corresponding items\n        size = self._count - istop\n        self._items[istart:istart + size] = self._items[istop:istop + size]\n\n        # Update other items\n        size = dstop - dstart\n        self._items[istart:istop + size + 1] -= size, size\n        self._count -= istop - istart\n\n    def insert(self, index, data, itemsize=None):\n        \"\"\"Insert data before index\n\n        Parameters\n        ----------\n        index : int\n            Index before which data will be inserted.\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        if not self._sizeable:\n            raise AttributeError(\"List is not sizeable\")\n\n        if isinstance(data, (list, tuple)) and isinstance(data[0], (list, tuple)):  # noqa\n            itemsize = [len(sublist) for sublist in data]\n            data = [item for sublist in data for item in sublist]\n\n        data = np.array(data, copy=False).ravel()\n        size = data.size\n\n        # Check item size and get item number\n        if itemsize is not None:\n            if isinstance(itemsize, int):\n                if (size % itemsize) != 0:\n                    raise ValueError(\"Cannot partition data as requested\")\n                _count = size // itemsize\n                _itemsize = np.ones(_count, dtype=int) * (size // _count)\n            else:\n                _itemsize = np.array(itemsize, copy=False)\n                _count = len(itemsize)\n                if _itemsize.sum() != size:\n                    raise ValueError(\"Cannot partition data as requested\")\n        else:\n            _count = 1\n\n        # Check if data array is big enough and resize it if necessary\n        if self._size + size >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(self._size + size)))\n            self._data = np.resize(self._data, capacity)\n\n        # Check if item array is big enough and resize it if necessary\n        if self._count + _count >= len(self._items):\n            capacity = int(2 ** np.ceil(np.log2(self._count + _count)))\n            self._items = np.resize(self._items, (capacity, 2))\n\n        # Check index\n        if index < 0:\n            index += len(self)\n        if index < 0 or index > len(self):\n            raise IndexError(\"List insertion index out of range\")\n\n        # Inserting\n        if index < self._count:\n            istart = index\n            dstart = self._items[istart][0]\n            dstop = self._items[istart][1]\n            # Move data\n            Z = self._data[dstart:self._size]\n            self._data[dstart + size:self._size + size] = Z\n            # Update moved items\n            items = self._items[istart:self._count] + size\n            self._items[istart + _count:self._count + _count] = items\n\n        # Appending\n        else:\n            dstart = self._size\n            istart = self._count\n\n        # Only one item (faster)\n        if _count == 1:\n            # Store data\n            self._data[dstart:dstart + size] = data\n            self._size += size\n            # Store data location (= item)\n            self._items[istart][0] = dstart\n            self._items[istart][1] = dstart + size\n            self._count += 1\n\n        # Several items\n        else:\n            # Store data\n            dstop = dstart + size\n            self._data[dstart:dstop] = data\n            self._size += size\n\n            # Store items\n            items = np.ones((_count, 2), int) * dstart\n            C = _itemsize.cumsum()\n            items[1:, 0] += C[:-1]\n            items[0:, 1] += C\n            istop = istart + _count\n            self._items[istart:istop] = items\n            self._count += _count\n\n    def append(self, data, itemsize=None):\n        \"\"\"Append data to the end.\n\n        Parameters\n        ----------\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        self.insert(len(self), data, itemsize)",
  "def __init__(self, data=None, itemsize=None, dtype=float,\n                 sizeable=True, writeable=True):\n        \"\"\"Create a new buffer using given data and sizes or dtype\n\n        Parameters\n        ----------\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n\n        dtype: np.dtype\n            Any object that can be interpreted as a numpy data type.\n\n        sizeable : boolean\n            Indicate whether item can be appended/inserted/deleted\n\n        writeable : boolean\n            Indicate whether content can be changed\n        \"\"\"\n        self._sizeable = sizeable\n        self._writeable = writeable\n\n        if data is not None:\n            if isinstance(data, (list, tuple)):\n                if isinstance(data[0], (list, tuple)):\n                    itemsize = [len(sublist) for sublist in data]\n                    data = [item for sublist in data for item in sublist]\n            self._data = np.array(data, copy=False)\n            self._size = self._data.size\n\n            # Default is one group with all data inside\n            _itemsize = np.ones(1) * self._data.size\n\n            # Check item sizes and get items count\n            if itemsize is not None:\n                if isinstance(itemsize, int):\n                    if (self._size % itemsize) != 0:\n                        raise ValueError(\"Cannot partition data as requested\")\n                    self._count = self._size // itemsize\n                    _itemsize = np.ones(\n                        self._count, dtype=int) * (self._size // self._count)\n                else:\n                    _itemsize = np.array(itemsize, copy=False)\n                    self._count = len(itemsize)\n                    if _itemsize.sum() != self._size:\n                        raise ValueError(\"Cannot partition data as requested\")\n            else:\n                self._count = 1\n\n            # Store items\n            self._items = np.zeros((self._count, 2), int)\n            C = _itemsize.cumsum()\n            self._items[1:, 0] += C[:-1]\n            self._items[0:, 1] += C\n\n        else:\n            self._data = np.zeros(1, dtype=dtype)\n            self._items = np.zeros((1, 2), dtype=int)\n            self._size = 0\n            self._count = 0",
  "def data(self):\n        \"\"\"The array's elements, in memory.\"\"\"\n        return self._data[:self._size]",
  "def size(self):\n        \"\"\"Number of base elements, in memory.\"\"\"\n        return self._size",
  "def itemsize(self):\n        \"\"\"Individual item sizes\"\"\"\n        return self._items[:self._count, 1] - self._items[:self._count, 0]",
  "def dtype(self):\n        \"\"\"Describes the format of the elements in the buffer.\"\"\"\n        return self._data.dtype",
  "def reserve(self, capacity):\n        \"\"\"Set current capacity of the underlying array\"\"\"\n        if capacity >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(capacity)))\n            self._data = np.resize(self._data, capacity)",
  "def __len__(self):\n        \"\"\"x.__len__() <==> len(x)\"\"\"\n        return self._count",
  "def __str__(self):\n        s = '[ '\n        for item in self:\n            s += str(item) + ' '\n        s += ']'\n        return s",
  "def __getitem__(self, key):\n        \"\"\"x.__getitem__(y) <==> x[y]\"\"\"\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key >= len(self):\n                raise IndexError(\"Tuple index out of range\")\n            dstart = self._items[key][0]\n            dstop = self._items[key][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            dstart = self._items[istart][0]\n            if istart == istop:\n                dstop = dstart\n            else:\n                dstop = self._items[istop - 1][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key, str):\n            return self._data[key][:self._size]\n\n        elif key is Ellipsis:\n            return self.data\n\n        else:\n            raise TypeError(\"List indices must be integers\")",
  "def __setitem__(self, key, data):\n        \"\"\"x.__setitem__(i, y) <==> x[i]=y\"\"\"\n        if not self._writeable:\n            raise AttributeError(\"List is not writeable\")\n\n        if isinstance(key, (int, slice)):\n            if isinstance(key, int):\n                if key < 0:\n                    key += len(self)\n                if key < 0 or key > len(self):\n                    raise IndexError(\"List assignment index out of range\")\n                dstart = self._items[key][0]\n                dstop = self._items[key][1]\n                istart = key\n            elif isinstance(key, slice):\n                istart, istop, step = key.indices(len(self))\n                if istart == istop:\n                    return\n                if istart > istop:\n                    istart, istop = istop, istart\n                if istart > len(self) or istop > len(self):\n                    raise IndexError(\"Can only assign iterable\")\n                dstart = self._items[istart][0]\n                if istart == istop:\n                    dstop = dstart\n                else:\n                    dstop = self._items[istop - 1][1]\n\n            if hasattr(data, \"__len__\"):\n                if len(data) == dstop - dstart:  # or len(data) == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart, data)\n            else:  # we assume len(data) = 1\n                if dstop - dstart == 1:\n                    self._data[dstart:dstop] = data\n                else:\n                    self.__delitem__(key)\n                    self.insert(istart, data)\n\n        elif key is Ellipsis:\n            self.data[...] = data\n\n        elif isinstance(key, str):\n            self._data[key][:self._size] = data\n\n        else:\n            raise TypeError(\"List assignment indices must be integers\")",
  "def __delitem__(self, key):\n        \"\"\"x.__delitem__(y) <==> del x[y]\"\"\"\n        if not self._sizeable:\n            raise AttributeError(\"List is not sizeable\")\n\n        # Deleting a single item\n        if isinstance(key, int):\n            if key < 0:\n                key += len(self)\n            if key < 0 or key > len(self):\n                raise IndexError(\"List deletion index out of range\")\n            istart, istop = key, key + 1\n            dstart, dstop = self._items[key]\n\n        # Deleting several items\n        elif isinstance(key, slice):\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n            dstart = self._items[istart][0]\n            dstop = self._items[istop - 1][1]\n\n        elif key is Ellipsis:\n            istart = 0\n            istop = len(self)\n            dstart = 0\n            dstop = self.size\n        # Error\n        else:\n            raise TypeError(\"List deletion indices must be integers\")\n\n        # Remove data\n        size = self._size - (dstop - dstart)\n        self._data[\n            dstart:dstart + self._size - dstop] = self._data[dstop:self._size]\n        self._size -= dstop - dstart\n\n        # Remove corresponding items\n        size = self._count - istop\n        self._items[istart:istart + size] = self._items[istop:istop + size]\n\n        # Update other items\n        size = dstop - dstart\n        self._items[istart:istop + size + 1] -= size, size\n        self._count -= istop - istart",
  "def insert(self, index, data, itemsize=None):\n        \"\"\"Insert data before index\n\n        Parameters\n        ----------\n        index : int\n            Index before which data will be inserted.\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        if not self._sizeable:\n            raise AttributeError(\"List is not sizeable\")\n\n        if isinstance(data, (list, tuple)) and isinstance(data[0], (list, tuple)):  # noqa\n            itemsize = [len(sublist) for sublist in data]\n            data = [item for sublist in data for item in sublist]\n\n        data = np.array(data, copy=False).ravel()\n        size = data.size\n\n        # Check item size and get item number\n        if itemsize is not None:\n            if isinstance(itemsize, int):\n                if (size % itemsize) != 0:\n                    raise ValueError(\"Cannot partition data as requested\")\n                _count = size // itemsize\n                _itemsize = np.ones(_count, dtype=int) * (size // _count)\n            else:\n                _itemsize = np.array(itemsize, copy=False)\n                _count = len(itemsize)\n                if _itemsize.sum() != size:\n                    raise ValueError(\"Cannot partition data as requested\")\n        else:\n            _count = 1\n\n        # Check if data array is big enough and resize it if necessary\n        if self._size + size >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(self._size + size)))\n            self._data = np.resize(self._data, capacity)\n\n        # Check if item array is big enough and resize it if necessary\n        if self._count + _count >= len(self._items):\n            capacity = int(2 ** np.ceil(np.log2(self._count + _count)))\n            self._items = np.resize(self._items, (capacity, 2))\n\n        # Check index\n        if index < 0:\n            index += len(self)\n        if index < 0 or index > len(self):\n            raise IndexError(\"List insertion index out of range\")\n\n        # Inserting\n        if index < self._count:\n            istart = index\n            dstart = self._items[istart][0]\n            dstop = self._items[istart][1]\n            # Move data\n            Z = self._data[dstart:self._size]\n            self._data[dstart + size:self._size + size] = Z\n            # Update moved items\n            items = self._items[istart:self._count] + size\n            self._items[istart + _count:self._count + _count] = items\n\n        # Appending\n        else:\n            dstart = self._size\n            istart = self._count\n\n        # Only one item (faster)\n        if _count == 1:\n            # Store data\n            self._data[dstart:dstart + size] = data\n            self._size += size\n            # Store data location (= item)\n            self._items[istart][0] = dstart\n            self._items[istart][1] = dstart + size\n            self._count += 1\n\n        # Several items\n        else:\n            # Store data\n            dstop = dstart + size\n            self._data[dstart:dstop] = data\n            self._size += size\n\n            # Store items\n            items = np.ones((_count, 2), int) * dstart\n            C = _itemsize.cumsum()\n            items[1:, 0] += C[:-1]\n            items[0:, 1] += C\n            istop = istart + _count\n            self._items[istart:istop] = items\n            self._count += _count",
  "def append(self, data, itemsize=None):\n        \"\"\"Append data to the end.\n\n        Parameters\n        ----------\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        self.insert(len(self), data, itemsize)",
  "class AggPointCollection(RawPointCollection):\n    \"\"\"\n    Antigrain Geometry Point Collection\n\n    This collection provides fast points. Output quality is perfect.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        transform : Transform instance\n            Used to define the GLSL transform(vec4) function\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        if vertex is None:\n            vertex = glsl.get(\"collections/agg-point.vert\")\n        if fragment is None:\n            fragment = glsl.get(\"collections/agg-point.frag\")\n\n        RawPointCollection.__init__(self, user_dtype=user_dtype,\n                                    transform=transform,\n                                    vertex=vertex, fragment=fragment, **kwargs)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        transform : Transform instance\n            Used to define the GLSL transform(vec4) function\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        if vertex is None:\n            vertex = glsl.get(\"collections/agg-point.vert\")\n        if fragment is None:\n            fragment = glsl.get(\"collections/agg-point.frag\")\n\n        RawPointCollection.__init__(self, user_dtype=user_dtype,\n                                    transform=transform,\n                                    vertex=vertex, fragment=fragment, **kwargs)",
  "def SegmentCollection(mode=\"agg-fast\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\" (speed: fastest, size: small, output: ugly, no dash,\n               no thickness)\n      - \"agg\" (speed: slower, size: medium, output: perfect, no dash)\n    \"\"\"\n    if mode == \"raw\":\n        return RawSegmentCollection(*args, **kwargs)\n    return AggSegmentCollection(*args, **kwargs)",
  "class Collection(BaseCollection):\n    \"\"\"\n    A collection is a container for several items having the same data\n    structure (dtype). Each data type can be declared as local (it is specific\n    to a vertex), shared (it is shared among item vertices) or global (it is\n    shared by all items). It is based on the BaseCollection but offers a more\n    intuitive interface.\n\n    Parameters\n    ----------\n    dtype: list\n        Data individual types as (name, dtype, scope, default)\n\n    itype: np.dtype or None\n        Indices data type\n\n    mode : GL_ENUM\n        GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP,\n        GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN\n\n    vertex: str or tuple of str\n       Vertex shader to use to draw this collection\n\n    fragment:  str or tuple of str\n       Fragment shader to use to draw this collection\n\n    kwargs: str\n        Scope can also be specified using keyword argument,\n        where parameter name must be one of the dtype.\n    \"\"\"\n\n    _gtypes = {('float32', 1): \"float\",\n               ('float32', 2): \"vec2\",\n               ('float32', 3): \"vec3\",\n               ('float32', 4): \"vec4\",\n               ('int32', 1): \"int\",\n               ('int32', 2): \"ivec2\",\n               ('int32', 3): \"ivec3\",\n               ('int32', 4): \"ivec4\"}\n\n    def __init__(self, dtype, itype, mode, vertex, fragment, program=None, \n                 **kwargs):\n        \"\"\"\n        \"\"\"\n\n        self._uniforms = {}\n        self._attributes = {}\n        self._varyings = {}\n        self._mode = mode\n        vtype = []\n        utype = []\n\n        self.update = EventEmitter(source=self, type='collection_update')\n\n        # Build vtype and utype according to parameters\n        declarations = {\"uniforms\": \"\",\n                        \"attributes\": \"\",\n                        \"varyings\": \"\"}\n        defaults = {}\n        for item in dtype:\n            name, (basetype, count), scope, default = item\n            basetype = np.dtype(basetype).name\n            if scope[0] == \"!\":\n                scope = scope[1:]\n            else:\n                scope = kwargs.pop(name, scope)\n            defaults[name] = default\n            gtype = Collection._gtypes[(basetype, count)]\n            if scope == \"local\":\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                vtype.append((name, basetype, count) if count != 1 else (name, basetype))\n                declarations[\n                    \"attributes\"] += \"attribute %s %s;\\n\" % (gtype, name)\n            elif scope == \"shared\":\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                utype.append((name, basetype, count) if count != 1 else (name, basetype))\n                declarations[\"varyings\"] += \"varying %s %s;\\n\" % (gtype, name)\n            else:\n                declarations[\"uniforms\"] += \"uniform %s %s;\\n\" % (gtype, name)\n                self._uniforms[name] = None\n\n        if len(kwargs) > 0:\n            raise NameError(\"Invalid keyword argument(s): %s\" % \n                            list(kwargs.keys()))\n\n        vtype = np.dtype(vtype)\n        itype = np.dtype(itype) if itype else None\n        utype = np.dtype(utype) if utype else None\n\n        BaseCollection.__init__(self, vtype=vtype, utype=utype, itype=itype)\n        self._declarations = declarations\n        self._defaults = defaults\n\n        # Build program (once base collection is built)\n        saved = vertex\n        vertex = \"\"\n\n        if self.utype is not None:\n            vertex += fetchcode(self.utype) + vertex\n        else:\n            vertex += \"void fetch_uniforms(void) { }\\n\" + vertex\n        vertex += self._declarations[\"uniforms\"]\n        vertex += self._declarations[\"attributes\"]\n        vertex += saved\n\n        self._vertex = vertex\n        self._fragment = fragment\n\n        if program is None:\n            program = ModularProgram(vertex, fragment)\n        else:\n            program.vert = vertex\n            program.frag = fragment\n        if hasattr(program, 'changed'):\n            program.changed.connect(self.update)\n        self._programs.append(program)\n\n        # Initialize uniforms\n        for name in self._uniforms.keys():\n            self._uniforms[name] = self._defaults.get(name)\n            program[name] = self._uniforms[name]\n\n    def view(self, transform, viewport=None):\n        \"\"\"Return a view on the collection using provided transform\"\"\"\n        return CollectionView(self, transform, viewport)\n\n        # program = gloo.Program(self._vertex, self._fragment)\n        # if \"transform\" in program.hooks:\n        #     program[\"transform\"] = transform\n        # if \"viewport\" in program.hooks:\n        #     if viewport is not None:\n        #         program[\"viewport\"] = viewport\n        #     else:\n        #         program[\"viewport\"] = Viewport()\n        # self._programs.append(program)\n        # program.bind(self._vertices_buffer)\n        # for name in self._uniforms.keys():\n        #     program[name] = self._uniforms[name]\n        # #if self._uniforms_list is not None:\n        # #    program[\"uniforms\"] = self._uniforms_texture\n        # #    program[\"uniforms_shape\"] = self._ushape\n\n        # # Piggy backing\n        # def draw():\n        #     if self._need_update:\n        #         self._update()\n        #         program.bind(self._vertices_buffer)\n        #         if self._uniforms_list is not None:\n        #             program[\"uniforms\"] = self._uniforms_texture\n        #             program[\"uniforms_shape\"] = self._ushape\n\n        #     if self._indices_list is not None:\n        #         Program.draw(program, self._mode, self._indices_buffer)\n        #     else:\n        #         Program.draw(program, self._mode)\n\n        # program.draw = draw\n        # return program\n\n    def __getitem__(self, key):\n\n        program = self._programs[0]\n        for name, (storage, _, _) in program._code_variables.items():\n            if name == key and storage == 'uniform':\n                return program[key]\n        return BaseCollection.__getitem__(self, key)\n\n    def __setitem__(self, key, value):\n        try:\n            BaseCollection.__setitem__(self, key, value)\n        except IndexError:\n            for program in self._programs:\n                program[key] = value\n\n    def draw(self, mode=None):\n        \"\"\"Draw collection\"\"\"\n        if self._need_update:\n            self._update()\n\n        program = self._programs[0]\n\n        mode = mode or self._mode\n        if self._indices_list is not None:\n            program.draw(mode, self._indices_buffer)\n        else:\n            program.draw(mode)",
  "class CollectionView(object):\n\n    def __init__(self, collection, transform=None, viewport=None):\n\n        vertex = collection._vertex\n        fragment = collection._fragment\n        program = gloo.Program(vertex, fragment)\n\n#        if \"transform\" in program.hooks and transform is not None:\n#            program[\"transform\"] = transform\n#        if \"viewport\" in program.hooks and viewport is not None:\n#            program[\"viewport\"] = viewport\n\n        program.bind(collection._vertices_buffer)\n        for name in collection._uniforms.keys():\n            program[name] = collection._uniforms[name]\n\n        collection._programs.append(program)\n        self._program = program\n        self._collection = collection\n\n    def __getitem__(self, key):\n        return self._program[key]\n\n    def __setitem__(self, key, value):\n        self._program[key] = value\n\n    def draw(self):\n\n        program = self._program\n        collection = self._collection\n        mode = collection._mode\n\n        if collection._need_update:\n            collection._update()\n            # self._program.bind(self._vertices_buffer)\n            if collection._uniforms_list is not None:\n                program[\"uniforms\"] = collection._uniforms_texture\n                program[\"uniforms_shape\"] = collection._ushape\n\n        if collection._indices_list is not None:\n            program.draw(mode, collection._indices_buffer)\n        else:\n            program.draw(mode)",
  "def __init__(self, dtype, itype, mode, vertex, fragment, program=None, \n                 **kwargs):\n        \"\"\"\n        \"\"\"\n\n        self._uniforms = {}\n        self._attributes = {}\n        self._varyings = {}\n        self._mode = mode\n        vtype = []\n        utype = []\n\n        self.update = EventEmitter(source=self, type='collection_update')\n\n        # Build vtype and utype according to parameters\n        declarations = {\"uniforms\": \"\",\n                        \"attributes\": \"\",\n                        \"varyings\": \"\"}\n        defaults = {}\n        for item in dtype:\n            name, (basetype, count), scope, default = item\n            basetype = np.dtype(basetype).name\n            if scope[0] == \"!\":\n                scope = scope[1:]\n            else:\n                scope = kwargs.pop(name, scope)\n            defaults[name] = default\n            gtype = Collection._gtypes[(basetype, count)]\n            if scope == \"local\":\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                vtype.append((name, basetype, count) if count != 1 else (name, basetype))\n                declarations[\n                    \"attributes\"] += \"attribute %s %s;\\n\" % (gtype, name)\n            elif scope == \"shared\":\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                utype.append((name, basetype, count) if count != 1 else (name, basetype))\n                declarations[\"varyings\"] += \"varying %s %s;\\n\" % (gtype, name)\n            else:\n                declarations[\"uniforms\"] += \"uniform %s %s;\\n\" % (gtype, name)\n                self._uniforms[name] = None\n\n        if len(kwargs) > 0:\n            raise NameError(\"Invalid keyword argument(s): %s\" % \n                            list(kwargs.keys()))\n\n        vtype = np.dtype(vtype)\n        itype = np.dtype(itype) if itype else None\n        utype = np.dtype(utype) if utype else None\n\n        BaseCollection.__init__(self, vtype=vtype, utype=utype, itype=itype)\n        self._declarations = declarations\n        self._defaults = defaults\n\n        # Build program (once base collection is built)\n        saved = vertex\n        vertex = \"\"\n\n        if self.utype is not None:\n            vertex += fetchcode(self.utype) + vertex\n        else:\n            vertex += \"void fetch_uniforms(void) { }\\n\" + vertex\n        vertex += self._declarations[\"uniforms\"]\n        vertex += self._declarations[\"attributes\"]\n        vertex += saved\n\n        self._vertex = vertex\n        self._fragment = fragment\n\n        if program is None:\n            program = ModularProgram(vertex, fragment)\n        else:\n            program.vert = vertex\n            program.frag = fragment\n        if hasattr(program, 'changed'):\n            program.changed.connect(self.update)\n        self._programs.append(program)\n\n        # Initialize uniforms\n        for name in self._uniforms.keys():\n            self._uniforms[name] = self._defaults.get(name)\n            program[name] = self._uniforms[name]",
  "def view(self, transform, viewport=None):\n        \"\"\"Return a view on the collection using provided transform\"\"\"\n        return CollectionView(self, transform, viewport)",
  "def __getitem__(self, key):\n\n        program = self._programs[0]\n        for name, (storage, _, _) in program._code_variables.items():\n            if name == key and storage == 'uniform':\n                return program[key]\n        return BaseCollection.__getitem__(self, key)",
  "def __setitem__(self, key, value):\n        try:\n            BaseCollection.__setitem__(self, key, value)\n        except IndexError:\n            for program in self._programs:\n                program[key] = value",
  "def draw(self, mode=None):\n        \"\"\"Draw collection\"\"\"\n        if self._need_update:\n            self._update()\n\n        program = self._programs[0]\n\n        mode = mode or self._mode\n        if self._indices_list is not None:\n            program.draw(mode, self._indices_buffer)\n        else:\n            program.draw(mode)",
  "def __init__(self, collection, transform=None, viewport=None):\n\n        vertex = collection._vertex\n        fragment = collection._fragment\n        program = gloo.Program(vertex, fragment)\n\n#        if \"transform\" in program.hooks and transform is not None:\n#            program[\"transform\"] = transform\n#        if \"viewport\" in program.hooks and viewport is not None:\n#            program[\"viewport\"] = viewport\n\n        program.bind(collection._vertices_buffer)\n        for name in collection._uniforms.keys():\n            program[name] = collection._uniforms[name]\n\n        collection._programs.append(program)\n        self._program = program\n        self._collection = collection",
  "def __getitem__(self, key):\n        return self._program[key]",
  "def __setitem__(self, key, value):\n        self._program[key] = value",
  "def draw(self):\n\n        program = self._program\n        collection = self._collection\n        mode = collection._mode\n\n        if collection._need_update:\n            collection._update()\n            # self._program.bind(self._vertices_buffer)\n            if collection._uniforms_list is not None:\n                program[\"uniforms\"] = collection._uniforms_texture\n                program[\"uniforms_shape\"] = collection._ushape\n\n        if collection._indices_list is not None:\n            program.draw(mode, collection._indices_buffer)\n        else:\n            program.draw(mode)",
  "class RawPointCollection(Collection):\n    \"\"\"\n    Raw Point Collection\n\n    This collection provides very fast points. Output quality is ugly so it\n    must be used at small size only (2/3 pixels). You've been warned.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('position', (np.float32, 3), \"!local\", (0, 0, 0)),\n                      ('size', (np.float32, 1), \"global\", 3.0),\n                      ('color', (np.float32, 4), \"global\", (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get(\"collections/raw-point.vert\")\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get(\"collections/raw-point.frag\")\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=\"points\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        program.vert['transform'] = self.transform\n\n    def append(self, P, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the points(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P) // itemsize\n\n        V = np.empty(len(P), dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['position', \"collection_index\"]:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = P\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('position', (np.float32, 3), \"!local\", (0, 0, 0)),\n                      ('size', (np.float32, 1), \"global\", 3.0),\n                      ('color', (np.float32, 4), \"global\", (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get(\"collections/raw-point.vert\")\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get(\"collections/raw-point.frag\")\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode=\"points\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        program.vert['transform'] = self.transform",
  "def append(self, P, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the points(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P) // itemsize\n\n        V = np.empty(len(P), dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['position', \"collection_index\"]:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = P\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)",
  "class RawPathCollection(Collection):\n\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('id', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1)),\n                      (\"linewidth\", (np.float32, 1), 'global', 1),\n                      (\"viewport\", (np.float32, 4), 'global', (0, 0, 512, 512))\n                      ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-path.frag')\n\n        vertex = transform + vertex\n        Collection.__init__(self, dtype=dtype, itype=None, mode='line_strip',\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize\n        P = P.reshape(itemcount, itemsize, 3)\n        if closed:\n            V = np.empty((itemcount, itemsize + 3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'position']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V[\"position\"][:, 1:-2] = P\n            V[\"position\"][:, -2] = V[\"position\"][:, 1]\n        else:\n            V = np.empty((itemcount, itemsize + 2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'position']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V[\"position\"][:, 1:-1] = P\n        V[\"id\"] = 1\n        V[:, 0] = V[:, 1]\n        V[:, -1] = V[:, -2]\n        V[\"id\"][:, 0] = 0\n        V[\"id\"][:, -1] = 0\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=itemsize + 2 + closed)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('id', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1)),\n                      (\"linewidth\", (np.float32, 1), 'global', 1),\n                      (\"viewport\", (np.float32, 4), 'global', (0, 0, 512, 512))\n                      ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-path.frag')\n\n        vertex = transform + vertex\n        Collection.__init__(self, dtype=dtype, itype=None, mode='line_strip',\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform",
  "def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize\n        P = P.reshape(itemcount, itemsize, 3)\n        if closed:\n            V = np.empty((itemcount, itemsize + 3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'position']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V[\"position\"][:, 1:-2] = P\n            V[\"position\"][:, -2] = V[\"position\"][:, 1]\n        else:\n            V = np.empty((itemcount, itemsize + 2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'position']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V[\"position\"][:, 1:-1] = P\n        V[\"id\"] = 1\n        V[:, 0] = V[:, 1]\n        V[:, -1] = V[:, -2]\n        V[\"id\"][:, 0] = 0\n        V[\"id\"][:, -1] = 0\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=itemsize + 2 + closed)",
  "class AggFastPathCollection(Collection):\n    \"\"\"\n    Antigrain Geometry Fast Path Collection\n\n    This collection provides antialiased and accurate paths with caps and miter\n    joins. It consume x4 more memory than regular lines and is a bit slower,\n    but the quality of the output is worth the cost. Note that no control can\n    be made on miter joins which may result in some glitches on screen.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('prev', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('curr', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('next', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('id', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'global', (0, 0, 0, 1)),\n                      ('linewidth', (np.float32, 1), 'global', 1),\n                      ('antialias', (np.float32, 1), 'global', 1),\n                      (\"viewport\", (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-fast-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform\n        if fragment is None:\n            fragment = glsl.get('collections/agg-fast-path.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=None,\n                            mode=\"triangle_strip\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        program = self._programs[0]\n        program.vert['transform'] = self.transform\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = int(itemsize or len(P))\n        itemcount = len(P) // itemsize\n\n        P = P.reshape(itemcount, itemsize, 3)\n        if closed:\n            V = np.empty((itemcount, itemsize + 3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:-1] = P\n            V['prev'][:, 1] = V['prev'][:, -2]\n            V['curr'][:, 1:-2] = P\n            V['curr'][:, -2] = V['curr'][:, 1]\n            V['next'][:, 0:-3] = P\n            V['next'][:, -3] = V['next'][:, 0]\n            V['next'][:, -2] = V['next'][:, 1]\n        else:\n            V = np.empty((itemcount, itemsize + 2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:] = P\n            V['prev'][:, 1] = V['prev'][:, 2]\n            V['curr'][:, 1:-1] = P\n            V['next'][:, :-2] = P\n            V['next'][:, -2] = V['next'][:, -3]\n\n        V[:, 0] = V[:, 1]\n        V[:, -1] = V[:, -2]\n        V = V.ravel()\n        V = np.repeat(V, 2, axis=0)\n        V['id'] = np.tile([1, -1], len(V) // 2)\n        if closed:\n            V = V.reshape(itemcount, 2 * (itemsize + 3))\n        else:\n            V = V.reshape(itemcount, 2 * (itemsize + 2))\n        V[\"id\"][:, :2] = 2, -2\n        V[\"id\"][:, -2:] = 2, -2\n        V = V.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=2 * (itemsize + 2 + closed))\n\n    def bake(self, P, key='curr', closed=False, itemsize=None):\n        \"\"\"\n        Given a path P, return the baked vertices as they should be copied in\n        the collection if the path has already been appended.\n\n        Examples\n        --------\n        >>> paths.append(P)\n        >>> P *= 2\n        >>> paths['prev'][0] = bake(P,'prev')\n        >>> paths['curr'][0] = bake(P,'curr')\n        >>> paths['next'][0] = bake(P,'next')\n\n        \"\"\"\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize  # noqa\n        n = itemsize\n\n        if closed:\n            idxs = np.arange(n + 3)\n            if key == 'prev':\n                idxs -= 2\n                idxs[0], idxs[1], idxs[-1] = n - 1, n - 1, n - 1\n            elif key == 'next':\n                idxs[0], idxs[-3], idxs[-2], idxs[-1] = 1, 0, 1, 1\n            else:\n                idxs -= 1\n                idxs[0], idxs[-1], idxs[n + 1] = 0, 0, 0\n        else:\n            idxs = np.arange(n + 2)\n            if key == 'prev':\n                idxs -= 2\n                idxs[0], idxs[1], idxs[-1] = 0, 0, n - 2\n            elif key == 'next':\n                idxs[0], idxs[-1], idxs[-2] = 1, n - 1, n - 1\n            else:\n                idxs -= 1\n                idxs[0], idxs[-1] = 0, n - 1\n        idxs = np.repeat(idxs, 2)\n        return P[idxs]\n\n    def draw(self, mode=\"triangle_strip\"):\n        \"\"\"Draw collection\"\"\"\n        gloo.set_depth_mask(0)\n        Collection.draw(self, mode)\n        gloo.set_depth_mask(1)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('prev', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('curr', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('next', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('id', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'global', (0, 0, 0, 1)),\n                      ('linewidth', (np.float32, 1), 'global', 1),\n                      ('antialias', (np.float32, 1), 'global', 1),\n                      (\"viewport\", (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-fast-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform\n        if fragment is None:\n            fragment = glsl.get('collections/agg-fast-path.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=None,\n                            mode=\"triangle_strip\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        program = self._programs[0]\n        program.vert['transform'] = self.transform",
  "def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = int(itemsize or len(P))\n        itemcount = len(P) // itemsize\n\n        P = P.reshape(itemcount, itemsize, 3)\n        if closed:\n            V = np.empty((itemcount, itemsize + 3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:-1] = P\n            V['prev'][:, 1] = V['prev'][:, -2]\n            V['curr'][:, 1:-2] = P\n            V['curr'][:, -2] = V['curr'][:, 1]\n            V['next'][:, 0:-3] = P\n            V['next'][:, -3] = V['next'][:, 0]\n            V['next'][:, -2] = V['next'][:, 1]\n        else:\n            V = np.empty((itemcount, itemsize + 2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:] = P\n            V['prev'][:, 1] = V['prev'][:, 2]\n            V['curr'][:, 1:-1] = P\n            V['next'][:, :-2] = P\n            V['next'][:, -2] = V['next'][:, -3]\n\n        V[:, 0] = V[:, 1]\n        V[:, -1] = V[:, -2]\n        V = V.ravel()\n        V = np.repeat(V, 2, axis=0)\n        V['id'] = np.tile([1, -1], len(V) // 2)\n        if closed:\n            V = V.reshape(itemcount, 2 * (itemsize + 3))\n        else:\n            V = V.reshape(itemcount, 2 * (itemsize + 2))\n        V[\"id\"][:, :2] = 2, -2\n        V[\"id\"][:, -2:] = 2, -2\n        V = V.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=2 * (itemsize + 2 + closed))",
  "def bake(self, P, key='curr', closed=False, itemsize=None):\n        \"\"\"\n        Given a path P, return the baked vertices as they should be copied in\n        the collection if the path has already been appended.\n\n        Examples\n        --------\n        >>> paths.append(P)\n        >>> P *= 2\n        >>> paths['prev'][0] = bake(P,'prev')\n        >>> paths['curr'][0] = bake(P,'curr')\n        >>> paths['next'][0] = bake(P,'next')\n\n        \"\"\"\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize  # noqa\n        n = itemsize\n\n        if closed:\n            idxs = np.arange(n + 3)\n            if key == 'prev':\n                idxs -= 2\n                idxs[0], idxs[1], idxs[-1] = n - 1, n - 1, n - 1\n            elif key == 'next':\n                idxs[0], idxs[-3], idxs[-2], idxs[-1] = 1, 0, 1, 1\n            else:\n                idxs -= 1\n                idxs[0], idxs[-1], idxs[n + 1] = 0, 0, 0\n        else:\n            idxs = np.arange(n + 2)\n            if key == 'prev':\n                idxs -= 2\n                idxs[0], idxs[1], idxs[-1] = 0, 0, n - 2\n            elif key == 'next':\n                idxs[0], idxs[-1], idxs[-2] = 1, n - 1, n - 1\n            else:\n                idxs -= 1\n                idxs[0], idxs[-1] = 0, n - 1\n        idxs = np.repeat(idxs, 2)\n        return P[idxs]",
  "def draw(self, mode=\"triangle_strip\"):\n        \"\"\"Draw collection\"\"\"\n        gloo.set_depth_mask(0)\n        Collection.draw(self, mode)\n        gloo.set_depth_mask(1)",
  "class RawPolygonCollection(Collection):\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-triangle.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-triangle.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,  # 16 for WebGL\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        program.vert['transform'] = self.transform\n\n    def append(self, points, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        points : np.array\n            Vertices composing the triangles\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        vertices, indices = triangulate(points)\n        itemsize = len(vertices)\n        itemcount = 1\n\n        V = np.empty(itemcount * itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'position']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = vertices\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=np.array(indices).ravel(),\n                          itemsize=itemsize)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n\n        base_dtype = [('position', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('color', (np.float32, 4), 'local', (0, 0, 0, 1))]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-triangle.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-triangle.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,  # 16 for WebGL\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n\n        # Set hooks if necessary\n        program = self._programs[0]\n        program.vert['transform'] = self.transform",
  "def append(self, points, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        points : np.array\n            Vertices composing the triangles\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        vertices, indices = triangulate(points)\n        itemsize = len(vertices)\n        itemcount = 1\n\n        V = np.empty(itemcount * itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'position']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = vertices\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=np.array(indices).ravel(),\n                          itemsize=itemsize)",
  "def PathCollection(mode=\"agg\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\"   (speed: fastest, size: small, output: ugly, no dash,\n                 no thickness)\n      - \"agg\"   (speed: medium, size: medium output: nice, some flaws, no dash)\n      - \"agg+\"  (speed: slow, size: big, output: perfect, no dash)\n    \"\"\"\n    if mode == \"raw\":\n        return RawPathCollection(*args, **kwargs)\n    elif mode == \"agg+\":\n        return AggPathCollection(*args, **kwargs)\n    return AggFastPathCollection(*args, **kwargs)",
  "def next_power_of_2(n):\n    \"\"\"Return next power of 2 greater than or equal to n\"\"\"\n    n -= 1  # greater than OR EQUAL TO n\n    shift = 1\n    while (n + 1) & n:  # n+1 is not a power of 2 yet\n        n |= n >> shift\n        shift *= 2\n    return max(4, n + 1)",
  "class Item(object):\n    \"\"\"\n    An item represent an object within a collection and is created on demand\n    when accessing a specific object of the collection.\n    \"\"\"\n\n    def __init__(self, parent, key, vertices, indices, uniforms):\n        \"\"\"\n        Create an item from an existing collection.\n\n        Parameters\n        ----------\n        parent : Collection\n            Collection this item belongs to\n\n        key : int\n            Collection index of this item\n\n        vertices: array-like\n            Vertices of the item\n\n        indices: array-like\n            Indices of the item\n\n        uniforms: array-like\n            Uniform parameters of the item\n        \"\"\"\n        self._parent = parent\n        self._key = key\n        self._vertices = vertices\n        self._indices = indices\n        self._uniforms = uniforms\n\n    @property\n    def vertices(self):\n        return self._vertices\n\n    @vertices.setter\n    def vertices(self, data):\n        self._vertices[...] = np.array(data)\n\n    @property\n    def indices(self):\n        return self._indices\n\n    @indices.setter\n    def indices(self, data):\n        if self._indices is None:\n            raise ValueError(\"Item has no indices\")\n        start = self._parent.vertices._items[self._key][0]\n        self._indices[...] = np.array(data) + start\n\n    @property\n    def uniforms(self):\n        return self._uniforms\n\n    @uniforms.setter\n    def uniforms(self, data):\n        if self._uniforms is None:\n            raise ValueError(\"Item has no associated uniform\")\n        self._uniforms[...] = data\n\n    def __getitem__(self, key):\n        \"\"\"Get a specific uniforms value\"\"\"\n        if key in self._vertices.dtype.names:\n            return self._vertices[key]\n        elif key in self._uniforms.dtype.names:\n            return self._uniforms[key]\n        else:\n            raise IndexError(\"Unknown key ('%s')\" % key)\n\n    def __setitem__(self, key, value):\n        \"\"\"Set a specific uniforms value\"\"\"\n        if key in self._vertices.dtype.names:\n            self._vertices[key] = value\n        elif key in self._uniforms.dtype.names:\n            self._uniforms[key] = value\n        else:\n            raise IndexError(\"Unknown key\")\n\n    def __str__(self):\n        return \"Item (%s, %s, %s)\" % (self._vertices,\n                                      self._indices,\n                                      self._uniforms)",
  "class BaseCollection(object):\n\n    def __init__(self, vtype, utype=None, itype=None):\n\n        # Vertices and type (mandatory)\n        self._vertices_list = None\n        self._vertices_buffer = None\n\n        # Vertex indices and type (optional)\n        self._indices_list = None\n        self._indices_buffer = None\n\n        # Uniforms and type (optional)\n        self._uniforms_list = None\n        self._uniforms_texture = None\n\n        # Make sure types are np.dtype (or None)\n        vtype = np.dtype(vtype) if vtype is not None else None\n        itype = np.dtype(itype) if itype is not None else None\n        utype = np.dtype(utype) if utype is not None else None\n\n        # Vertices type (mandatory)\n        # -------------------------\n        if vtype.names is None:\n            raise ValueError(\"vtype must be a structured dtype\")\n\n        # Indices type (optional)\n        # -----------------------\n        if itype is not None:\n            if itype not in [np.uint8, np.uint16, np.uint32]:\n                raise ValueError(\"itype must be unsigned integer or None\")\n            self._indices_list = ArrayList(dtype=itype)\n\n        # No program yet\n        self._programs = []\n\n        # Need to update buffers & texture\n        self._need_update = True\n\n        # Uniforms type (optional)\n        # -------------------------\n        if utype is not None:\n\n            if utype.names is None:\n                raise ValueError(\"utype must be a structured dtype\")\n\n            # Convert types to lists (in case they were already dtypes) such\n            # that we can append new fields\n            vtype = eval(str(np.dtype(vtype)))\n            # We add a uniform index to access uniform data\n            vtype.append(('collection_index', np.float32))\n            vtype = np.dtype(vtype)\n\n            # Check utype is made of float32 only\n            utype = eval(str(np.dtype(utype)))\n            r_utype = dtype_reduce(utype)\n            if not isinstance(r_utype[0], str) or r_utype[2] != 'float32':\n                raise RuntimeError(\"utype cannot be reduced to float32 only\")\n\n            # Make utype divisible by 4\n            # count = ((r_utype[1]-1)//4+1)*4\n\n            # Make utype a power of two\n            count = next_power_of_2(r_utype[1])\n            if (count - r_utype[1]) > 0:\n                utype.append(('__unused__', np.float32, count - r_utype[1]))\n\n            self._uniforms_list = ArrayList(dtype=utype)\n            self._uniforms_float_count = count\n\n            # Reserve some space in texture such that we have\n            # at least one full line\n            shape = self._compute_texture_shape(1)\n            self._uniforms_list.reserve(shape[1] / (count / 4))\n\n        # Last since utype may add a new field in vtype (collecion_index)\n        self._vertices_list = ArrayList(dtype=vtype)\n\n        # Record all types\n        self._vtype = np.dtype(vtype)\n        self._itype = np.dtype(itype) if itype is not None else None\n        self._utype = np.dtype(utype) if utype is not None else None\n\n    def __len__(self):\n        \"\"\"x.__len__() <==> len(x)\"\"\"\n        return len(self._vertices_list)\n\n    @property\n    def vtype(self):\n        \"\"\"Vertices dtype\"\"\"\n        return self._vtype\n\n    @property\n    def itype(self):\n        \"\"\"Indices dtype\"\"\"\n        return self._itype\n\n    @property\n    def utype(self):\n        \"\"\"Uniforms dtype\"\"\"\n        return self._utype\n\n    def append(self, vertices, uniforms=None, indices=None, itemsize=None):\n        \"\"\"\n        Parameters\n        ----------\n        vertices : numpy array\n            An array whose dtype is compatible with self.vdtype\n\n        uniforms: numpy array\n            An array whose dtype is compatible with self.utype\n\n        indices : numpy array\n            An array whose dtype is compatible with self.idtype\n            All index values must be between 0 and len(vertices)\n\n        itemsize: int, tuple or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        # Vertices\n        # -----------------------------\n        vertices = np.array(vertices).astype(self.vtype).ravel()\n        vsize = self._vertices_list.size\n\n        # No itemsize given\n        # -----------------\n        if itemsize is None:\n            index = 0\n            count = 1\n\n        # Uniform itemsize (int)\n        # ----------------------\n        elif isinstance(itemsize, int):\n            count = len(vertices) / itemsize\n            index = np.repeat(np.arange(count), itemsize)\n\n        # Individual itemsize (array)\n        # ---------------------------\n        elif isinstance(itemsize, (np.ndarray, list)):\n            count = len(itemsize)\n            index = np.repeat(np.arange(count), itemsize)\n        else:\n            raise ValueError(\"Itemsize not understood\")\n\n        if self.utype:\n            vertices[\"collection_index\"] = index + len(self)\n        self._vertices_list.append(vertices, itemsize)\n\n        # Indices\n        # -----------------------------\n        if self.itype is not None:\n            # No indices given (-> automatic generation)\n            if indices is None:\n                indices = vsize + np.arange(len(vertices))\n                self._indices_list.append(indices, itemsize)\n\n            # Indices given\n            # FIXME: variables indices (list of list or ArrayList)\n            else:\n                if itemsize is None:\n                    idxs = np.array(indices) + vsize\n                elif isinstance(itemsize, int):\n                    idxs = vsize + (np.tile(indices, count) +\n                                    itemsize * np.repeat(np.arange(count), len(indices)))  # noqa\n                else:\n                    raise ValueError(\"Indices not compatible with items\")\n                self._indices_list.append(idxs, len(indices))\n\n        # Uniforms\n        # -----------------------------\n        if self.utype:\n            if uniforms is None:\n                uniforms = np.zeros(count, dtype=self.utype)\n            else:\n                uniforms = np.array(uniforms).astype(self.utype).ravel()\n            self._uniforms_list.append(uniforms, itemsize=1)\n\n        self._need_update = True\n\n    def __delitem__(self, index):\n        \"\"\"x.__delitem__(y) <==> del x[y]\"\"\"\n        # Deleting one item\n        if isinstance(index, int):\n            if index < 0:\n                index += len(self)\n            if index < 0 or index > len(self):\n                raise IndexError(\"Collection deletion index out of range\")\n            istart, istop = index, index + 1\n        # Deleting several items\n        elif isinstance(index, slice):\n            istart, istop, _ = index.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n        # Deleting everything\n        elif index is Ellipsis:\n            istart, istop = 0, len(self)\n        # Error\n        else:\n            raise TypeError(\"Collection deletion indices must be integers\")\n\n        vsize = len(self._vertices_list[index])\n        if self.itype is not None:\n            del self._indices_list[index]\n            self._indices_list[index:] -= vsize\n\n        if self.utype:\n            self._vertices_list[index:][\"collection_index\"] -= istop - istart\n        del self._vertices_list[index]\n\n        if self.utype is not None:\n            del self._uniforms_list[index]\n\n        self._need_update = True\n\n    def __getitem__(self, key):\n        \"\"\" \"\"\"\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        idxs = None\n        U = None\n        if self._indices_list is not None:\n            idxs = self._indices_buffer\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.data.ravel().view(self.utype)\n\n        # Getting a whole field\n        if isinstance(key, str):\n            # Getting a named field from vertices\n            if key in V.dtype.names:\n                return V[key]\n            # Getting a named field from uniforms\n            elif U is not None and key in U.dtype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # return U[key]\n                return U[key][:len(self._uniforms_list)]\n            else:\n                raise IndexError(\"Unknown field name ('%s')\" % key)\n\n        # Getting individual item\n        elif isinstance(key, int):\n            vstart, vend = self._vertices_list._items[key]\n            vertices = V[vstart:vend]\n            indices = None\n            uniforms = None\n            if idxs is not None:\n                istart, iend = self._indices_list._items[key]\n                indices = idxs[istart:iend]\n\n            if U is not None:\n                ustart, uend = self._uniforms_list._items[key]\n                uniforms = U[ustart:uend]\n\n            return Item(self, key, vertices, indices, uniforms)\n\n        # Error\n        else:\n            raise IndexError(\"Cannot get more than one item at once\")\n\n    def __setitem__(self, key, data):\n        \"\"\"x.__setitem__(i, y) <==> x[i]=y\"\"\"\n        # if len(self._programs):\n        # found = False\n        # for program in self._programs:\n        #     if key in program.hooks:\n        #         program[key] = data\n        #         found = True\n        # if found: return\n\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        # I = None\n        U = None\n        # if self._indices_list is not None:\n        #     I = self._indices_buffer  # noqa\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.data.ravel().view(self.utype)\n\n        # Setting a whole field\n        if isinstance(key, str):\n            # Setting a named field in vertices\n            if key in self.vtype.names:\n                V[key] = data\n            # Setting a named field in uniforms\n            elif self.utype and key in self.utype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # U[key] = data\n                U[key][:len(self._uniforms_list)] = data\n            else:\n                raise IndexError(\"Unknown field name ('%s')\" % key)\n\n        # # Setting individual item\n        # elif isinstance(key, int):\n        #     #vstart, vend = self._vertices_list._items[key]\n        #     #istart, iend = self._indices_list._items[key]\n        #     #ustart, uend = self._uniforms_list._items[key]\n        #     vertices, indices, uniforms = data\n        #     del self[key]\n        #     self.insert(key, vertices, indices, uniforms)\n\n        else:\n            raise IndexError(\"Cannot set more than one item\")\n\n    def _compute_texture_shape(self, size=1):\n        \"\"\"Compute uniform texture shape\"\"\"\n        # We should use this line but we may not have a GL context yet\n        # linesize = gl.glGetInteger(gl.GL_MAX_TEXTURE_SIZE)\n        linesize = 1024\n        count = self._uniforms_float_count\n        cols = 4 * linesize // int(count)\n        rows = max(1, int(math.ceil(size / float(cols))))\n        shape = rows, cols * (count // 4), count\n        self._ushape = shape\n        return shape\n\n    def _update(self):\n        \"\"\"Update vertex buffers & texture\"\"\"\n        if self._vertices_buffer is not None:\n            self._vertices_buffer.delete()\n        self._vertices_buffer = VertexBuffer(self._vertices_list.data)\n\n        if self.itype is not None:\n            if self._indices_buffer is not None:\n                self._indices_buffer.delete()\n            self._indices_buffer = IndexBuffer(self._indices_list.data)\n\n        if self.utype is not None:\n            if self._uniforms_texture is not None:\n                self._uniforms_texture.delete()\n\n            # We take the whole array (_data), not the data one\n            texture = self._uniforms_list._data.view(np.float32)\n            size = len(texture) / self._uniforms_float_count\n            shape = self._compute_texture_shape(size)\n\n            # shape[2] = float count is only used in vertex shader code\n            texture = texture.reshape(shape[0], shape[1], 4)\n            self._uniforms_texture = Texture2D(texture)\n            self._uniforms_texture.data = texture\n            self._uniforms_texture.interpolation = 'nearest'\n\n        if len(self._programs):\n            for program in self._programs:\n                program.bind(self._vertices_buffer)\n                if self._uniforms_list is not None:\n                    program[\"uniforms\"] = self._uniforms_texture\n                    program[\"uniforms_shape\"] = self._ushape",
  "def __init__(self, parent, key, vertices, indices, uniforms):\n        \"\"\"\n        Create an item from an existing collection.\n\n        Parameters\n        ----------\n        parent : Collection\n            Collection this item belongs to\n\n        key : int\n            Collection index of this item\n\n        vertices: array-like\n            Vertices of the item\n\n        indices: array-like\n            Indices of the item\n\n        uniforms: array-like\n            Uniform parameters of the item\n        \"\"\"\n        self._parent = parent\n        self._key = key\n        self._vertices = vertices\n        self._indices = indices\n        self._uniforms = uniforms",
  "def vertices(self):\n        return self._vertices",
  "def vertices(self, data):\n        self._vertices[...] = np.array(data)",
  "def indices(self):\n        return self._indices",
  "def indices(self, data):\n        if self._indices is None:\n            raise ValueError(\"Item has no indices\")\n        start = self._parent.vertices._items[self._key][0]\n        self._indices[...] = np.array(data) + start",
  "def uniforms(self):\n        return self._uniforms",
  "def uniforms(self, data):\n        if self._uniforms is None:\n            raise ValueError(\"Item has no associated uniform\")\n        self._uniforms[...] = data",
  "def __getitem__(self, key):\n        \"\"\"Get a specific uniforms value\"\"\"\n        if key in self._vertices.dtype.names:\n            return self._vertices[key]\n        elif key in self._uniforms.dtype.names:\n            return self._uniforms[key]\n        else:\n            raise IndexError(\"Unknown key ('%s')\" % key)",
  "def __setitem__(self, key, value):\n        \"\"\"Set a specific uniforms value\"\"\"\n        if key in self._vertices.dtype.names:\n            self._vertices[key] = value\n        elif key in self._uniforms.dtype.names:\n            self._uniforms[key] = value\n        else:\n            raise IndexError(\"Unknown key\")",
  "def __str__(self):\n        return \"Item (%s, %s, %s)\" % (self._vertices,\n                                      self._indices,\n                                      self._uniforms)",
  "def __init__(self, vtype, utype=None, itype=None):\n\n        # Vertices and type (mandatory)\n        self._vertices_list = None\n        self._vertices_buffer = None\n\n        # Vertex indices and type (optional)\n        self._indices_list = None\n        self._indices_buffer = None\n\n        # Uniforms and type (optional)\n        self._uniforms_list = None\n        self._uniforms_texture = None\n\n        # Make sure types are np.dtype (or None)\n        vtype = np.dtype(vtype) if vtype is not None else None\n        itype = np.dtype(itype) if itype is not None else None\n        utype = np.dtype(utype) if utype is not None else None\n\n        # Vertices type (mandatory)\n        # -------------------------\n        if vtype.names is None:\n            raise ValueError(\"vtype must be a structured dtype\")\n\n        # Indices type (optional)\n        # -----------------------\n        if itype is not None:\n            if itype not in [np.uint8, np.uint16, np.uint32]:\n                raise ValueError(\"itype must be unsigned integer or None\")\n            self._indices_list = ArrayList(dtype=itype)\n\n        # No program yet\n        self._programs = []\n\n        # Need to update buffers & texture\n        self._need_update = True\n\n        # Uniforms type (optional)\n        # -------------------------\n        if utype is not None:\n\n            if utype.names is None:\n                raise ValueError(\"utype must be a structured dtype\")\n\n            # Convert types to lists (in case they were already dtypes) such\n            # that we can append new fields\n            vtype = eval(str(np.dtype(vtype)))\n            # We add a uniform index to access uniform data\n            vtype.append(('collection_index', np.float32))\n            vtype = np.dtype(vtype)\n\n            # Check utype is made of float32 only\n            utype = eval(str(np.dtype(utype)))\n            r_utype = dtype_reduce(utype)\n            if not isinstance(r_utype[0], str) or r_utype[2] != 'float32':\n                raise RuntimeError(\"utype cannot be reduced to float32 only\")\n\n            # Make utype divisible by 4\n            # count = ((r_utype[1]-1)//4+1)*4\n\n            # Make utype a power of two\n            count = next_power_of_2(r_utype[1])\n            if (count - r_utype[1]) > 0:\n                utype.append(('__unused__', np.float32, count - r_utype[1]))\n\n            self._uniforms_list = ArrayList(dtype=utype)\n            self._uniforms_float_count = count\n\n            # Reserve some space in texture such that we have\n            # at least one full line\n            shape = self._compute_texture_shape(1)\n            self._uniforms_list.reserve(shape[1] / (count / 4))\n\n        # Last since utype may add a new field in vtype (collecion_index)\n        self._vertices_list = ArrayList(dtype=vtype)\n\n        # Record all types\n        self._vtype = np.dtype(vtype)\n        self._itype = np.dtype(itype) if itype is not None else None\n        self._utype = np.dtype(utype) if utype is not None else None",
  "def __len__(self):\n        \"\"\"x.__len__() <==> len(x)\"\"\"\n        return len(self._vertices_list)",
  "def vtype(self):\n        \"\"\"Vertices dtype\"\"\"\n        return self._vtype",
  "def itype(self):\n        \"\"\"Indices dtype\"\"\"\n        return self._itype",
  "def utype(self):\n        \"\"\"Uniforms dtype\"\"\"\n        return self._utype",
  "def append(self, vertices, uniforms=None, indices=None, itemsize=None):\n        \"\"\"\n        Parameters\n        ----------\n        vertices : numpy array\n            An array whose dtype is compatible with self.vdtype\n\n        uniforms: numpy array\n            An array whose dtype is compatible with self.utype\n\n        indices : numpy array\n            An array whose dtype is compatible with self.idtype\n            All index values must be between 0 and len(vertices)\n\n        itemsize: int, tuple or 1-D array\n            If `itemsize` is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n        # Vertices\n        # -----------------------------\n        vertices = np.array(vertices).astype(self.vtype).ravel()\n        vsize = self._vertices_list.size\n\n        # No itemsize given\n        # -----------------\n        if itemsize is None:\n            index = 0\n            count = 1\n\n        # Uniform itemsize (int)\n        # ----------------------\n        elif isinstance(itemsize, int):\n            count = len(vertices) / itemsize\n            index = np.repeat(np.arange(count), itemsize)\n\n        # Individual itemsize (array)\n        # ---------------------------\n        elif isinstance(itemsize, (np.ndarray, list)):\n            count = len(itemsize)\n            index = np.repeat(np.arange(count), itemsize)\n        else:\n            raise ValueError(\"Itemsize not understood\")\n\n        if self.utype:\n            vertices[\"collection_index\"] = index + len(self)\n        self._vertices_list.append(vertices, itemsize)\n\n        # Indices\n        # -----------------------------\n        if self.itype is not None:\n            # No indices given (-> automatic generation)\n            if indices is None:\n                indices = vsize + np.arange(len(vertices))\n                self._indices_list.append(indices, itemsize)\n\n            # Indices given\n            # FIXME: variables indices (list of list or ArrayList)\n            else:\n                if itemsize is None:\n                    idxs = np.array(indices) + vsize\n                elif isinstance(itemsize, int):\n                    idxs = vsize + (np.tile(indices, count) +\n                                    itemsize * np.repeat(np.arange(count), len(indices)))  # noqa\n                else:\n                    raise ValueError(\"Indices not compatible with items\")\n                self._indices_list.append(idxs, len(indices))\n\n        # Uniforms\n        # -----------------------------\n        if self.utype:\n            if uniforms is None:\n                uniforms = np.zeros(count, dtype=self.utype)\n            else:\n                uniforms = np.array(uniforms).astype(self.utype).ravel()\n            self._uniforms_list.append(uniforms, itemsize=1)\n\n        self._need_update = True",
  "def __delitem__(self, index):\n        \"\"\"x.__delitem__(y) <==> del x[y]\"\"\"\n        # Deleting one item\n        if isinstance(index, int):\n            if index < 0:\n                index += len(self)\n            if index < 0 or index > len(self):\n                raise IndexError(\"Collection deletion index out of range\")\n            istart, istop = index, index + 1\n        # Deleting several items\n        elif isinstance(index, slice):\n            istart, istop, _ = index.indices(len(self))\n            if istart > istop:\n                istart, istop = istop, istart\n            if istart == istop:\n                return\n        # Deleting everything\n        elif index is Ellipsis:\n            istart, istop = 0, len(self)\n        # Error\n        else:\n            raise TypeError(\"Collection deletion indices must be integers\")\n\n        vsize = len(self._vertices_list[index])\n        if self.itype is not None:\n            del self._indices_list[index]\n            self._indices_list[index:] -= vsize\n\n        if self.utype:\n            self._vertices_list[index:][\"collection_index\"] -= istop - istart\n        del self._vertices_list[index]\n\n        if self.utype is not None:\n            del self._uniforms_list[index]\n\n        self._need_update = True",
  "def __getitem__(self, key):\n        \"\"\" \"\"\"\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        idxs = None\n        U = None\n        if self._indices_list is not None:\n            idxs = self._indices_buffer\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.data.ravel().view(self.utype)\n\n        # Getting a whole field\n        if isinstance(key, str):\n            # Getting a named field from vertices\n            if key in V.dtype.names:\n                return V[key]\n            # Getting a named field from uniforms\n            elif U is not None and key in U.dtype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # return U[key]\n                return U[key][:len(self._uniforms_list)]\n            else:\n                raise IndexError(\"Unknown field name ('%s')\" % key)\n\n        # Getting individual item\n        elif isinstance(key, int):\n            vstart, vend = self._vertices_list._items[key]\n            vertices = V[vstart:vend]\n            indices = None\n            uniforms = None\n            if idxs is not None:\n                istart, iend = self._indices_list._items[key]\n                indices = idxs[istart:iend]\n\n            if U is not None:\n                ustart, uend = self._uniforms_list._items[key]\n                uniforms = U[ustart:uend]\n\n            return Item(self, key, vertices, indices, uniforms)\n\n        # Error\n        else:\n            raise IndexError(\"Cannot get more than one item at once\")",
  "def __setitem__(self, key, data):\n        \"\"\"x.__setitem__(i, y) <==> x[i]=y\"\"\"\n        # if len(self._programs):\n        # found = False\n        # for program in self._programs:\n        #     if key in program.hooks:\n        #         program[key] = data\n        #         found = True\n        # if found: return\n\n        # WARNING\n        # Here we want to make sure to use buffers and texture (instead of\n        # lists) since only them are aware of any external modification.\n        if self._need_update:\n            self._update()\n\n        V = self._vertices_buffer\n        # I = None\n        U = None\n        # if self._indices_list is not None:\n        #     I = self._indices_buffer  # noqa\n        if self._uniforms_list is not None:\n            U = self._uniforms_texture.data.ravel().view(self.utype)\n\n        # Setting a whole field\n        if isinstance(key, str):\n            # Setting a named field in vertices\n            if key in self.vtype.names:\n                V[key] = data\n            # Setting a named field in uniforms\n            elif self.utype and key in self.utype.names:\n                # Careful, U is the whole texture that can be bigger than list\n                # U[key] = data\n                U[key][:len(self._uniforms_list)] = data\n            else:\n                raise IndexError(\"Unknown field name ('%s')\" % key)\n\n        # # Setting individual item\n        # elif isinstance(key, int):\n        #     #vstart, vend = self._vertices_list._items[key]\n        #     #istart, iend = self._indices_list._items[key]\n        #     #ustart, uend = self._uniforms_list._items[key]\n        #     vertices, indices, uniforms = data\n        #     del self[key]\n        #     self.insert(key, vertices, indices, uniforms)\n\n        else:\n            raise IndexError(\"Cannot set more than one item\")",
  "def _compute_texture_shape(self, size=1):\n        \"\"\"Compute uniform texture shape\"\"\"\n        # We should use this line but we may not have a GL context yet\n        # linesize = gl.glGetInteger(gl.GL_MAX_TEXTURE_SIZE)\n        linesize = 1024\n        count = self._uniforms_float_count\n        cols = 4 * linesize // int(count)\n        rows = max(1, int(math.ceil(size / float(cols))))\n        shape = rows, cols * (count // 4), count\n        self._ushape = shape\n        return shape",
  "def _update(self):\n        \"\"\"Update vertex buffers & texture\"\"\"\n        if self._vertices_buffer is not None:\n            self._vertices_buffer.delete()\n        self._vertices_buffer = VertexBuffer(self._vertices_list.data)\n\n        if self.itype is not None:\n            if self._indices_buffer is not None:\n                self._indices_buffer.delete()\n            self._indices_buffer = IndexBuffer(self._indices_list.data)\n\n        if self.utype is not None:\n            if self._uniforms_texture is not None:\n                self._uniforms_texture.delete()\n\n            # We take the whole array (_data), not the data one\n            texture = self._uniforms_list._data.view(np.float32)\n            size = len(texture) / self._uniforms_float_count\n            shape = self._compute_texture_shape(size)\n\n            # shape[2] = float count is only used in vertex shader code\n            texture = texture.reshape(shape[0], shape[1], 4)\n            self._uniforms_texture = Texture2D(texture)\n            self._uniforms_texture.data = texture\n            self._uniforms_texture.interpolation = 'nearest'\n\n        if len(self._programs):\n            for program in self._programs:\n                program.bind(self._vertices_buffer)\n                if self._uniforms_list is not None:\n                    program[\"uniforms\"] = self._uniforms_texture\n                    program[\"uniforms_shape\"] = self._ushape",
  "class RawSegmentCollection(Collection):\n    \"\"\"\n    Raw Segment Collection\n\n    This collection provides fast raw (& ugly) line segments.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [(\"position\", (np.float32, 3), \"!local\", (0, 0, 0)),\n                      (\"color\", (np.float32, 4), \"global\", (0, 0, 0, 1)),\n                      (\"viewport\", (np.float32, 4), \"global\", (0, 0, 512, 512))\n                      ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-segment.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-segment.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode='lines',\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform\n\n    def append(self, P0, P1, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P0) / itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V = np.repeat(V, 2, axis=0)\n        V['P'][0::2] = P0\n        V['P'][1::2] = P1\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        color : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [(\"position\", (np.float32, 3), \"!local\", (0, 0, 0)),\n                      (\"color\", (np.float32, 4), \"global\", (0, 0, 0, 1)),\n                      (\"viewport\", (np.float32, 4), \"global\", (0, 0, 512, 512))\n                      ]\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/raw-segment.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/raw-segment.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=None, mode='lines',\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform",
  "def append(self, P0, P1, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P0) / itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V = np.repeat(V, 2, axis=0)\n        V['P'][0::2] = P0\n        V['P'][1::2] = P1\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)",
  "class AggPathCollection(Collection):\n    \"\"\"\n    Antigrain Geometry Path Collection\n\n    This collection provides antialiased and accurate paths with caps and\n    joins. It is memory hungry (x8) and slow (x.25) so it is to be used\n    sparingly, mainly for thick paths where quality is critical.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        join : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        miter_limit : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('p0', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p1', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p2', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p3', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('uv', (np.float32, 2), '!local', (0, 0)),\n\n                      ('caps', (np.float32, 2), 'global', (0, 0)),\n                      ('join', (np.float32, 1), 'global', 0),\n                      ('color', (np.float32, 4), 'global', (0, 0, 0, 1)),\n                      ('miter_limit', (np.float32, 1), 'global', 4),\n                      ('linewidth', (np.float32, 1), 'global', 1),\n                      ('antialias', (np.float32, 1), 'global', 1),\n                      ('viewport', (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform\n        if fragment is None:\n            fragment = glsl.get('collections/agg-path.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,  # 16 for WebGL\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform\n\n    def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        join : list, array or float\n           path segment join\n\n        color : list, array or 4-tuple\n           Path color\n\n        miter_limit : list, array or float\n           Miter limit for join\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = int(itemsize or len(P))\n        itemcount = len(P) // itemsize\n\n        # Computes the adjacency information\n        n, p = len(P), P.shape[-1]\n        Z = np.tile(P, 2).reshape(2 * len(P), p)\n        V = np.empty(n, dtype=self.vtype)\n\n        V['p0'][1:-1] = Z[0::2][:-2]\n        V['p1'][:-1] = Z[1::2][:-1]\n        V['p2'][:-1] = Z[1::2][+1:]\n        V['p3'][:-2] = Z[0::2][+2:]\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'p0', 'p1', 'p2', 'p3']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        # Extract relevant segments only\n        V = (V.reshape(n // itemsize, itemsize)[:, :-1])\n        if closed:\n            V['p0'][:, 0] = V['p2'][:, -1]\n            V['p3'][:, -1] = V['p1'][:, 0]\n        else:\n            V['p0'][:, 0] = V['p1'][:, 0]\n            V['p3'][:, -1] = V['p2'][:, -1]\n        V = V.ravel()\n\n        # Quadruple each point (we're using 2 triangles / segment)\n        # No shared vertices between segment because of joins\n        V = np.repeat(V, 4, axis=0).reshape((len(V), 4))\n        V['uv'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)\n        V = V.ravel()\n\n        n = itemsize\n        if closed:\n            # uint16 for WebGL\n            idxs = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), n * 2 * 3)\n            idxs += np.repeat(4 * np.arange(n, dtype=np.uint32), 6)\n            idxs[-6:] = 4 * n - 6, 4 * n - 5, 0, 4 * n - 5, 0, 1\n        else:\n            idxs = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), (n - 1) * 2 * 3)\n            idxs += np.repeat(4 * np.arange(n - 1, dtype=np.uint32), 6)\n        idxs = idxs.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=idxs, itemsize=itemsize * 4 - 4)\n\n    def draw(self, mode=\"triangles\"):\n        \"\"\"Draw collection\"\"\"\n        gloo.set_depth_mask(0)\n        Collection.draw(self, mode)\n        gloo.set_depth_mask(1)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : Transform instance\n            Used to define the transform(vec4) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        join : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        miter_limit : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('p0', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p1', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p2', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('p3', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('uv', (np.float32, 2), '!local', (0, 0)),\n\n                      ('caps', (np.float32, 2), 'global', (0, 0)),\n                      ('join', (np.float32, 1), 'global', 0),\n                      ('color', (np.float32, 4), 'global', (0, 0, 0, 1)),\n                      ('miter_limit', (np.float32, 1), 'global', 4),\n                      ('linewidth', (np.float32, 1), 'global', 1),\n                      ('antialias', (np.float32, 1), 'global', 1),\n                      ('viewport', (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-path.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform\n        if fragment is None:\n            fragment = glsl.get('collections/agg-path.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,  # 16 for WebGL\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform",
  "def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        join : list, array or float\n           path segment join\n\n        color : list, array or 4-tuple\n           Path color\n\n        miter_limit : list, array or float\n           Miter limit for join\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = int(itemsize or len(P))\n        itemcount = len(P) // itemsize\n\n        # Computes the adjacency information\n        n, p = len(P), P.shape[-1]\n        Z = np.tile(P, 2).reshape(2 * len(P), p)\n        V = np.empty(n, dtype=self.vtype)\n\n        V['p0'][1:-1] = Z[0::2][:-2]\n        V['p1'][:-1] = Z[1::2][:-1]\n        V['p2'][:-1] = Z[1::2][+1:]\n        V['p3'][:-2] = Z[0::2][+2:]\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'p0', 'p1', 'p2', 'p3']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        # Extract relevant segments only\n        V = (V.reshape(n // itemsize, itemsize)[:, :-1])\n        if closed:\n            V['p0'][:, 0] = V['p2'][:, -1]\n            V['p3'][:, -1] = V['p1'][:, 0]\n        else:\n            V['p0'][:, 0] = V['p1'][:, 0]\n            V['p3'][:, -1] = V['p2'][:, -1]\n        V = V.ravel()\n\n        # Quadruple each point (we're using 2 triangles / segment)\n        # No shared vertices between segment because of joins\n        V = np.repeat(V, 4, axis=0).reshape((len(V), 4))\n        V['uv'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)\n        V = V.ravel()\n\n        n = itemsize\n        if closed:\n            # uint16 for WebGL\n            idxs = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), n * 2 * 3)\n            idxs += np.repeat(4 * np.arange(n, dtype=np.uint32), 6)\n            idxs[-6:] = 4 * n - 6, 4 * n - 5, 0, 4 * n - 5, 0, 1\n        else:\n            idxs = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), (n - 1) * 2 * 3)\n            idxs += np.repeat(4 * np.arange(n - 1, dtype=np.uint32), 6)\n        idxs = idxs.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=idxs, itemsize=itemsize * 4 - 4)",
  "def draw(self, mode=\"triangles\"):\n        \"\"\"Draw collection\"\"\"\n        gloo.set_depth_mask(0)\n        Collection.draw(self, mode)\n        gloo.set_depth_mask(1)",
  "def TriangleCollection(mode=\"raw\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\"  (speed: fastest, size: small,   output: ugly)\n      - \"agg\"  (speed: fast,    size: small,   output: beautiful)\n    \"\"\"\n    return RawTriangleCollection(*args, **kwargs)",
  "def PointCollection(mode=\"raw\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\"  (speed: fastest, size: small,   output: ugly)\n      - \"agg\"  (speed: fast,    size: small,   output: beautiful)\n    \"\"\"\n    if mode == \"raw\":\n        return RawPointCollection(*args, **kwargs)\n    return AggPointCollection(*args, **kwargs)",
  "class AggSegmentCollection(Collection):\n    \"\"\"\n    Antigrain Geometry Segment Collection\n\n    This collection provides antialiased and accurate segments with caps. It\n    consume x2 more memory than regular lines and is a bit slower, but the\n    quality of the output is worth the cost.\n    \"\"\"\n\n    def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('P0', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('P1', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('index', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'shared', (0, 0, 0, 1)),\n                      ('linewidth', (np.float32, 1), 'shared', 1),\n                      ('antialias', (np.float32, 1), 'shared', 1),\n                      ('viewport', (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-segment.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/agg-segment.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform\n\n    def append(self, P0, P1, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P0) // itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P0', 'P1', 'index']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V['P0'] = P0\n        V['P1'] = P1\n        V = V.repeat(4, axis=0)\n        V['index'] = np.resize([0, 1, 2, 3], 4 * itemcount * itemsize)\n\n        idxs = np.ones((itemcount, 6), dtype=int)\n        idxs[:] = 0, 1, 2, 0, 2, 3\n        idxs[:] += 4 * np.arange(itemcount)[:, np.newaxis]\n        idxs = idxs.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(\n            self, vertices=V, uniforms=U, indices=idxs, itemsize=4 * itemcount)",
  "def __init__(self, user_dtype=None, transform=None,\n                 vertex=None, fragment=None, **kwargs):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters\n        ----------\n        user_dtype: list\n            The base dtype can be completed (appended) by the used_dtype. It\n            only make sense if user also provide vertex and/or fragment shaders\n\n        transform : string\n            GLSL Transform code defining the vec4 transform(vec3) function\n\n        vertex: string\n            Vertex shader code\n\n        fragment: string\n            Fragment  shader code\n\n        caps : string\n            'local', 'shared' or 'global'\n\n        color : string\n            'local', 'shared' or 'global'\n\n        linewidth : string\n            'local', 'shared' or 'global'\n\n        antialias : string\n            'local', 'shared' or 'global'\n        \"\"\"\n        base_dtype = [('P0', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('P1', (np.float32, 3), '!local', (0, 0, 0)),\n                      ('index', (np.float32, 1), '!local', 0),\n                      ('color', (np.float32, 4), 'shared', (0, 0, 0, 1)),\n                      ('linewidth', (np.float32, 1), 'shared', 1),\n                      ('antialias', (np.float32, 1), 'shared', 1),\n                      ('viewport', (np.float32, 4), 'global', (0, 0, 512, 512))]  # noqa\n\n        dtype = base_dtype\n        if user_dtype:\n            dtype.extend(user_dtype)\n\n        if vertex is None:\n            vertex = glsl.get('collections/agg-segment.vert')\n        if transform is None:\n            transform = NullTransform()\n        self.transform = transform        \n        if fragment is None:\n            fragment = glsl.get('collections/agg-segment.frag')\n\n        Collection.__init__(self, dtype=dtype, itype=np.uint32,\n                            mode=\"triangles\",\n                            vertex=vertex, fragment=fragment, **kwargs)\n        self._programs[0].vert['transform'] = self.transform",
  "def append(self, P0, P1, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        color : list, array or 4-tuple\n           Path color\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n        itemsize = itemsize or 1\n        itemcount = len(P0) // itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P0', 'P1', 'index']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V['P0'] = P0\n        V['P1'] = P1\n        V = V.repeat(4, axis=0)\n        V['index'] = np.resize([0, 1, 2, 3], 4 * itemcount * itemsize)\n\n        idxs = np.ones((itemcount, 6), dtype=int)\n        idxs[:] = 0, 1, 2, 0, 2, 3\n        idxs[:] += 4 * np.arange(itemcount)[:, np.newaxis]\n        idxs = idxs.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(\n            self, vertices=V, uniforms=U, indices=idxs, itemsize=4 * itemcount)",
  "class SDFRendererGPU(object):\n    def __init__(self):\n        self.program_seed = Program(vert_seed, frag_seed)\n        self.program_flood = Program(vert, frag_flood)\n        self.program_insert = Program(vert, frag_insert)\n        self.programs = [self.program_seed, self.program_flood,\n                         self.program_insert]\n\n        # Initialize variables\n        self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n        vtype = np.dtype([('a_position', np.float32, 2),\n                          ('a_texcoord', np.float32, 2)])\n        vertices = np.zeros(4, dtype=vtype)\n        vertices['a_position'] = [[-1., -1.], [-1., 1.], [1., -1.], [1., 1.]]\n        vertices['a_texcoord'] = [[0., 0.], [0., 1.], [1., 0.], [1., 1.]]\n        vertices = VertexBuffer(vertices)\n        self.program_insert['u_step'] = 1.\n        for program in self.programs:\n            program.bind(vertices)\n\n    def render_to_texture(self, data, texture, offset, size):\n        \"\"\"Render a SDF to a texture at a given offset and size\n\n        Parameters\n        ----------\n        data : array\n            Must be 2D with type np.ubyte.\n        texture : instance of Texture2D\n            The texture to render to.\n        offset : tuple of int\n            Offset (x, y) to render to inside the texture.\n        size : tuple of int\n            Size (w, h) to render inside the texture.\n        \"\"\"\n        assert isinstance(texture, Texture2D)\n        set_state(blend=False, depth_test=False)\n\n        # calculate the negative half (within object)\n        orig_tex = Texture2D(255 - data, format='luminance',\n                             wrapping='clamp_to_edge', interpolation='nearest')\n        edf_neg_tex = self._render_edf(orig_tex)\n\n        # calculate positive half (outside object)\n        orig_tex[:, :, 0] = data\n\n        edf_pos_tex = self._render_edf(orig_tex)\n\n        # render final product to output texture\n        self.program_insert['u_texture'] = orig_tex\n        self.program_insert['u_pos_texture'] = edf_pos_tex\n        self.program_insert['u_neg_texture'] = edf_neg_tex\n        self.fbo_to[-1].color_buffer = texture\n        with self.fbo_to[-1]:\n            set_viewport(tuple(offset) + tuple(size))\n            self.program_insert.draw('triangle_strip')\n\n    def _render_edf(self, orig_tex):\n        \"\"\"Render an EDF to a texture\"\"\"\n        # Set up the necessary textures\n        sdf_size = orig_tex.shape[:2]\n\n        comp_texs = []\n        for _ in range(2):\n            tex = Texture2D(sdf_size + (4,), format='rgba',\n                            interpolation='nearest', wrapping='clamp_to_edge')\n            comp_texs.append(tex)\n        self.fbo_to[0].color_buffer = comp_texs[0]\n        self.fbo_to[1].color_buffer = comp_texs[1]\n        for program in self.programs[1:]:  # program_seed does not need this\n            program['u_texh'], program['u_texw'] = sdf_size\n\n        # Do the rendering\n        last_rend = 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_seed['u_texture'] = orig_tex\n            self.program_seed.draw('triangle_strip')\n        stepsize = (np.array(sdf_size) // 2).max()\n        while stepsize > 0:\n            self.program_flood['u_step'] = stepsize\n            self.program_flood['u_texture'] = comp_texs[last_rend]\n            last_rend = 1 if last_rend == 0 else 0\n            with self.fbo_to[last_rend]:\n                set_viewport(0, 0, sdf_size[1], sdf_size[0])\n                self.program_flood.draw('triangle_strip')\n            stepsize //= 2\n        return comp_texs[last_rend]",
  "def __init__(self):\n        self.program_seed = Program(vert_seed, frag_seed)\n        self.program_flood = Program(vert, frag_flood)\n        self.program_insert = Program(vert, frag_insert)\n        self.programs = [self.program_seed, self.program_flood,\n                         self.program_insert]\n\n        # Initialize variables\n        self.fbo_to = [FrameBuffer(), FrameBuffer(), FrameBuffer()]\n        vtype = np.dtype([('a_position', np.float32, 2),\n                          ('a_texcoord', np.float32, 2)])\n        vertices = np.zeros(4, dtype=vtype)\n        vertices['a_position'] = [[-1., -1.], [-1., 1.], [1., -1.], [1., 1.]]\n        vertices['a_texcoord'] = [[0., 0.], [0., 1.], [1., 0.], [1., 1.]]\n        vertices = VertexBuffer(vertices)\n        self.program_insert['u_step'] = 1.\n        for program in self.programs:\n            program.bind(vertices)",
  "def render_to_texture(self, data, texture, offset, size):\n        \"\"\"Render a SDF to a texture at a given offset and size\n\n        Parameters\n        ----------\n        data : array\n            Must be 2D with type np.ubyte.\n        texture : instance of Texture2D\n            The texture to render to.\n        offset : tuple of int\n            Offset (x, y) to render to inside the texture.\n        size : tuple of int\n            Size (w, h) to render inside the texture.\n        \"\"\"\n        assert isinstance(texture, Texture2D)\n        set_state(blend=False, depth_test=False)\n\n        # calculate the negative half (within object)\n        orig_tex = Texture2D(255 - data, format='luminance',\n                             wrapping='clamp_to_edge', interpolation='nearest')\n        edf_neg_tex = self._render_edf(orig_tex)\n\n        # calculate positive half (outside object)\n        orig_tex[:, :, 0] = data\n\n        edf_pos_tex = self._render_edf(orig_tex)\n\n        # render final product to output texture\n        self.program_insert['u_texture'] = orig_tex\n        self.program_insert['u_pos_texture'] = edf_pos_tex\n        self.program_insert['u_neg_texture'] = edf_neg_tex\n        self.fbo_to[-1].color_buffer = texture\n        with self.fbo_to[-1]:\n            set_viewport(tuple(offset) + tuple(size))\n            self.program_insert.draw('triangle_strip')",
  "def _render_edf(self, orig_tex):\n        \"\"\"Render an EDF to a texture\"\"\"\n        # Set up the necessary textures\n        sdf_size = orig_tex.shape[:2]\n\n        comp_texs = []\n        for _ in range(2):\n            tex = Texture2D(sdf_size + (4,), format='rgba',\n                            interpolation='nearest', wrapping='clamp_to_edge')\n            comp_texs.append(tex)\n        self.fbo_to[0].color_buffer = comp_texs[0]\n        self.fbo_to[1].color_buffer = comp_texs[1]\n        for program in self.programs[1:]:  # program_seed does not need this\n            program['u_texh'], program['u_texw'] = sdf_size\n\n        # Do the rendering\n        last_rend = 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_seed['u_texture'] = orig_tex\n            self.program_seed.draw('triangle_strip')\n        stepsize = (np.array(sdf_size) // 2).max()\n        while stepsize > 0:\n            self.program_flood['u_step'] = stepsize\n            self.program_flood['u_texture'] = comp_texs[last_rend]\n            last_rend = 1 if last_rend == 0 else 0\n            with self.fbo_to[last_rend]:\n                set_viewport(0, 0, sdf_size[1], sdf_size[0])\n                self.program_flood.draw('triangle_strip')\n            stepsize //= 2\n        return comp_texs[last_rend]",
  "class TextureFont(object):\n    \"\"\"Gather a set of glyphs relative to a given font name and size\n\n    This currently stores characters in a `TextureAtlas` object which uses\n    a 2D RGB texture to store unsigned 8-bit integer data. In the future this\n    could be changed to a ``GL_R8`` texture instead of RGB when OpenGL ES\n    3.0+ is standard. Since VisPy tries to stay compatible with OpenGL ES 2.0\n    we are using an ``RGB`` texture. Using a single channel texture should\n    improve performance by requiring less data to be sent to the GPU and to\n    remote backends (jupyter notebook).\n\n    Parameters\n    ----------\n    font : dict\n        Dict with entries \"face\", \"size\", \"bold\", \"italic\".\n    renderer : instance of SDFRenderer\n        SDF renderer to use.\n\n    \"\"\"\n\n    def __init__(self, font, renderer):\n        self._atlas = TextureAtlas(dtype=np.uint8)\n        self._atlas.wrapping = 'clamp_to_edge'\n        self._kernel, _ = load_spatial_filters()\n        self._renderer = renderer\n        self._font = deepcopy(font)\n        self._font['size'] = 256  # use high resolution point size for SDF\n        self._lowres_size = 64  # end at this point size for storage\n        assert (self._font['size'] % self._lowres_size) == 0\n        # spread/border at the high-res for SDF calculation; must be chosen\n        # relative to fragment_insert.glsl multiplication factor to ensure we\n        # get to zero at the edges of characters\n        # This is also used in SDFRendererCPU, so changing this needs to\n        # propagate at least 2 other places.\n        self._spread = 32\n        assert self._spread % self.ratio == 0\n        self._glyphs = {}\n\n    @property\n    def ratio(self):\n        \"\"\"Ratio of the initial high-res to final stored low-res glyph\"\"\"\n        return self._font['size'] // self._lowres_size\n\n    @property\n    def slop(self):\n        \"\"\"Extra space along each glyph edge due to SDF borders\"\"\"\n        return self._spread // self.ratio\n\n    def __getitem__(self, char):\n        if not (isinstance(char, str) and len(char) == 1):\n            raise TypeError('index must be a 1-character string')\n        if char not in self._glyphs:\n            self._load_char(char)\n        return self._glyphs[char]\n\n    def _load_char(self, char):\n        \"\"\"Build and store a glyph corresponding to an individual character\n\n        Parameters\n        ----------\n        char : str\n            A single character to be represented.\n        \"\"\"\n        assert isinstance(char, str) and len(char) == 1\n        assert char not in self._glyphs\n        # load new glyph data from font\n        _load_glyph(self._font, char, self._glyphs)\n        # put new glyph into the texture\n        glyph = self._glyphs[char]\n        bitmap = glyph['bitmap']\n\n        # convert to padded array\n        data = np.zeros((bitmap.shape[0] + 2*self._spread,\n                         bitmap.shape[1] + 2*self._spread), np.uint8)\n        data[self._spread:-self._spread, self._spread:-self._spread] = bitmap\n\n        # Store, while scaling down to proper size\n        height = data.shape[0] // self.ratio\n        width = data.shape[1] // self.ratio\n        region = self._atlas.get_free_region(width + 2, height + 2)\n        if region is None:\n            raise RuntimeError('Cannot store glyph')\n        x, y, w, h = region\n        x, y, w, h = x + 1, y + 1, w - 2, h - 2\n\n        self._renderer.render_to_texture(data, self._atlas, (x, y), (w, h))\n        u0 = x / float(self._atlas.shape[1])\n        v0 = y / float(self._atlas.shape[0])\n        u1 = (x+w) / float(self._atlas.shape[1])\n        v1 = (y+h) / float(self._atlas.shape[0])\n        texcoords = (u0, v0, u1, v1)\n        glyph.update(dict(size=(w, h), texcoords=texcoords))",
  "class FontManager(object):\n    \"\"\"Helper to create TextureFont instances and reuse them when possible\"\"\"\n\n    # XXX: should store a font-manager on each context,\n    # or let TextureFont use a TextureAtlas for each context\n    def __init__(self, method='cpu'):\n        self._fonts = {}\n        if not isinstance(method, str) or \\\n                method not in ('cpu', 'gpu'):\n            raise ValueError('method must be \"cpu\" or \"gpu\", got %s (%s)'\n                             % (method, type(method)))\n        if method == 'cpu':\n            self._renderer = SDFRendererCPU()\n        else:  # method == 'gpu':\n            self._renderer = SDFRendererGPU()\n\n    def get_font(self, face, bold=False, italic=False):\n        \"\"\"Get a font described by face and size\"\"\"\n        key = '%s-%s-%s' % (face, bold, italic)\n        if key not in self._fonts:\n            font = dict(face=face, bold=bold, italic=italic)\n            self._fonts[key] = TextureFont(font, self._renderer)\n        return self._fonts[key]",
  "def _text_to_vbo(text, font, anchor_x, anchor_y, lowres_size):\n    \"\"\"Convert text characters to VBO\"\"\"\n    # Necessary to flush commands before requesting current viewport because\n    # There may be a set_viewport command waiting in the queue.\n    # TODO: would be nicer if each canvas just remembers and manages its own\n    # viewport, rather than relying on the context for this.\n    canvas = context.get_current_canvas()\n    canvas.context.flush_commands()\n\n    text_vtype = np.dtype([('a_position', np.float32, 2),\n                           ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(len(text) * 4, dtype=text_vtype)\n    prev = None\n    width = height = ascender = descender = 0\n    ratio, slop = 1. / font.ratio, font.slop\n    x_off = -slop\n    # Need to make sure we have a unicode string here (Py2.7 mis-interprets\n    # characters like \"\u2022\" otherwise)\n    if sys.version[0] == '2' and isinstance(text, str):\n        text = text.decode('utf-8')\n    # Need to store the original viewport, because the font[char] will\n    # trigger SDF rendering, which changes our viewport\n    # todo: get rid of call to glGetParameter!\n\n    # Also analyse chars with large ascender and descender, otherwise the\n    # vertical alignment can be very inconsistent\n    for char in 'hy':\n        glyph = font[char]\n        y0 = glyph['offset'][1] * ratio + slop\n        y1 = y0 - glyph['size'][1]\n        ascender = max(ascender, y0 - slop)\n        descender = min(descender, y1 + slop)\n        height = max(height, glyph['size'][1] - 2*slop)\n\n    # Get/set the fonts whitespace length and line height (size of this ok?)\n    glyph = font[' ']\n    spacewidth = glyph['advance'] * ratio\n    lineheight = height * 1.5\n\n    # Added escape sequences characters: {unicode:offset,...}\n    #   ord('\\a') = 7\n    #   ord('\\b') = 8\n    #   ord('\\f') = 12\n    #   ord('\\n') = 10  => linebreak\n    #   ord('\\r') = 13\n    #   ord('\\t') = 9   => tab, set equal 4 whitespaces?\n    #   ord('\\v') = 11  => vertical tab, set equal 4 linebreaks?\n    # If text coordinate offset > 0 -> it applies to x-direction\n    # If text coordinate offset < 0 -> it applies to y-direction\n    esc_seq = {7: 0, 8: 0, 9: -4, 10: 1, 11: 4, 12: 0, 13: 0}\n\n    # Keep track of y_offset to set lines at right position\n    y_offset = 0\n\n    # When a line break occur, record the vertices index value\n    vi_marker = 0\n    ii_offset = 0  # Offset since certain characters won't be drawn\n\n    # The running tracker of characters vertex index\n    vi = 0\n\n    orig_viewport = canvas.context.get_viewport()\n    for ii, char in enumerate(text):\n        if ord(char) in esc_seq:\n            if esc_seq[ord(char)] < 0:\n                # Add offset in x-direction\n                x_off += abs(esc_seq[ord(char)]) * spacewidth\n                width += abs(esc_seq[ord(char)]) * spacewidth\n            elif esc_seq[ord(char)] > 0:\n                # Add offset in y-direction and reset things in x-direction\n                dx = dy = 0\n                if anchor_x == 'right':\n                    dx = -width\n                elif anchor_x == 'center':\n                    dx = -width / 2.\n                vertices['a_position'][vi_marker:vi+4] += (dx, dy)\n                vi_marker = vi+4\n                ii_offset -= 1\n                # Reset variables that affects x-direction positioning\n                x_off = -slop\n                width = 0\n                # Add offset in y-direction\n                y_offset += esc_seq[ord(char)] * lineheight\n        else:\n            # For ordinary characters, normal procedure\n            glyph = font[char]\n            kerning = glyph['kerning'].get(prev, 0.) * ratio\n            x0 = x_off + glyph['offset'][0] * ratio + kerning\n            y0 = glyph['offset'][1] * ratio + slop - y_offset\n            x1 = x0 + glyph['size'][0]\n            y1 = y0 - glyph['size'][1]\n            u0, v0, u1, v1 = glyph['texcoords']\n            position = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]]\n            texcoords = [[u0, v0], [u0, v1], [u1, v1], [u1, v0]]\n            vi = (ii + ii_offset) * 4\n            vertices['a_position'][vi:vi+4] = position\n            vertices['a_texcoord'][vi:vi+4] = texcoords\n            x_move = glyph['advance'] * ratio + kerning\n            x_off += x_move\n            ascender = max(ascender, y0 - slop)\n            descender = min(descender, y1 + slop)\n            width += x_move\n            height = max(height, glyph['size'][1] - 2*slop)\n            prev = char\n\n    if orig_viewport is not None:\n        canvas.context.set_viewport(*orig_viewport)\n\n    dx = dy = 0\n    if anchor_y == 'top':\n        dy = -descender\n    elif anchor_y in ('center', 'middle'):\n        dy = (-descender - ascender) / 2\n    elif anchor_y == 'bottom':\n        dy = -ascender\n    if anchor_x == 'right':\n        dx = -width\n    elif anchor_x == 'center':\n        dx = -width / 2.\n\n    # If any linebreaks occured in text, we only want to translate characters\n    # in the last line in text (those after the vi_marker)\n    vertices['a_position'][0:vi_marker] += (0, dy)\n    vertices['a_position'][vi_marker:] += (dx, dy)\n    vertices['a_position'] /= lowres_size\n\n    return vertices",
  "class TextVisual(Visual):\n    \"\"\"Visual that displays text\n\n    Parameters\n    ----------\n    text : str | list of str\n        Text to display. Can also be a list of strings.\n        Note: support for list of str might be removed soon\n        in favor of text collections.\n    color : instance of Color\n        Color to use.\n    bold : bool\n        Bold face.\n    italic : bool\n        Italic face.\n    face : str\n        Font face to use.\n    font_size : float\n        Point size to use.\n    pos : tuple | list of tuple\n        Position (x, y) or (x, y, z) of the text.\n        Can also be a list of tuple if `text` is a list.\n    rotation : float\n        Rotation (in degrees) of the text clockwise.\n    anchor_x : str\n        Horizontal text anchor.\n    anchor_y : str\n        Vertical text anchor.\n    method : str\n        Rendering method for text characters. Either 'cpu' (default) or\n        'gpu'. The 'cpu' method should perform better on remote backends.\n        The 'gpu' method should produce higher quality results.\n    font_manager : object | None\n        Font manager to use (can be shared if the GLContext is shared).\n    depth_test : bool\n        Whether to apply depth testing. Default False. If False, the text\n        behaves like an overlay that does not get hidden behind other\n        visuals in the scene.\n    \"\"\"\n\n    _shaders = {\n        'vertex': _VERTEX_SHADER,\n        'fragment': _FRAGMENT_SHADER,\n    }\n\n    def __init__(self, text=None, color='black', bold=False,\n                 italic=False, face='OpenSans', font_size=12, pos=[0, 0, 0],\n                 rotation=0., anchor_x='center', anchor_y='center',\n                 method='cpu', font_manager=None, depth_test=False):\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        # Check input\n        valid_keys = ('top', 'center', 'middle', 'baseline', 'bottom')\n        _check_valid('anchor_y', anchor_y, valid_keys)\n        valid_keys = ('left', 'center', 'right')\n        _check_valid('anchor_x', anchor_x, valid_keys)\n        # Init font handling stuff\n        # _font_manager is a temporary solution to use global mananger\n        self._font_manager = font_manager or FontManager(method=method)\n        self._face = face\n        self._bold = bold\n        self._italic = italic\n        self._update_font()\n        self._vertices = None\n        self._color_vbo = None\n        self._anchors = (anchor_x, anchor_y)\n        # Init text properties\n        self.color = color\n        self.text = text\n        self.font_size = font_size\n        self.pos = pos\n        self.rotation = rotation\n        self._text_scale = STTransform()\n        self._draw_mode = 'triangles'\n        self.set_gl_state(blend=True, depth_test=depth_test, cull_face=False,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self.freeze()\n\n    @property\n    def text(self):\n        \"\"\"The text string\"\"\"\n        return self._text\n\n    @text.setter\n    def text(self, text):\n        if isinstance(text, list):\n            assert all(isinstance(t, str) for t in text)\n        if text is None:\n            text = []\n        self._text = text\n        self._vertices = None\n        self._pos_changed = True  # need to update this as well\n        self._color_changed = True\n        self.update()\n\n    @property\n    def anchors(self):\n        return self._anchors\n\n    @anchors.setter\n    def anchors(self, a):\n        self._anchors = a\n        self._vertices = None\n        self._pos_changed = True\n        self.update()\n\n    @property\n    def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._font_size\n\n    @font_size.setter\n    def font_size(self, size):\n        self._font_size = max(0.0, float(size))\n        self.update()\n\n    @property\n    def color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, color):\n        self._color = ColorArray(color)\n        self._color_changed = True\n        self.update()\n\n    @property\n    def rotation(self):\n        \"\"\"The rotation of the text (clockwise, in degrees)\"\"\"\n        return self._rotation * 180. / np.pi\n\n    @rotation.setter\n    def rotation(self, rotation):\n        self._rotation = np.asarray(rotation) * np.pi / 180.\n        self._pos_changed = True\n        self.update()\n\n    @property\n    def pos(self):\n        \"\"\"The position of the text anchor in the local coordinate frame\"\"\"\n        return self._pos\n\n    @pos.setter\n    def pos(self, pos):\n        pos = np.atleast_2d(pos).astype(np.float32)\n        if pos.shape[1] == 2:\n            pos = np.concatenate((pos, np.zeros((pos.shape[0], 1),\n                                                np.float32)), axis=1)\n        elif pos.shape[1] != 3:\n            raise ValueError('pos must have 2 or 3 elements')\n        elif pos.shape[0] == 0:\n            raise ValueError('at least one position must be given')\n        self._pos = pos\n        self._pos_changed = True\n        self.update()\n\n    def _prepare_draw(self, view):\n        # attributes / uniforms are not available until program is built\n        if len(self.text) == 0:\n            return False\n        if self._vertices is None:\n            text = self.text\n            if isinstance(text, str):\n                text = [text]\n            n_char = sum(len(t) for t in text)\n            # we delay creating vertices because it requires a context,\n            # which may or may not exist when the object is initialized\n            self._vertices = np.concatenate([\n                _text_to_vbo(t, self._font, self._anchors[0], self._anchors[1],\n                             self._font._lowres_size) for t in text])\n            self._vertices = VertexBuffer(self._vertices)\n            idx = (np.array([0, 1, 2, 0, 2, 3], np.uint32) +\n                   np.arange(0, 4*n_char, 4, dtype=np.uint32)[:, np.newaxis])\n            self._index_buffer = IndexBuffer(idx.ravel())\n            self.shared_program.bind(self._vertices)\n            # This is necessary to reset the GL drawing state after generating\n            # SDF textures. A better way would be to enable the state to be\n            # pushed/popped by the context.\n            self._configure_gl_state()\n        if self._pos_changed:\n            # now we promote pos to the proper shape (attribute)\n            text = self.text\n            if not isinstance(text, str):\n                repeats = [4 * len(t) for t in text]\n                text = ''.join(text)\n            else:\n                repeats = [4 * len(text)]\n            n_text = len(repeats)\n            pos = self.pos\n            # Rotation\n            _rot = self._rotation\n            if isinstance(_rot, (int, float)):\n                _rot = np.full((pos.shape[0],), self._rotation)\n            _rot = np.asarray(_rot)\n            if _rot.shape[0] < n_text:\n                _rep = [1] * (len(_rot) - 1) + [n_text - len(_rot) + 1]\n                _rot = np.repeat(_rot, _rep, axis=0)\n            _rot = np.repeat(_rot[:n_text], repeats, axis=0)\n            self.shared_program['a_rotation'] = _rot.astype(np.float32)\n            # Position\n            if pos.shape[0] < n_text:\n                _rep = [1] * (len(pos) - 1) + [n_text - len(pos) + 1]\n                pos = np.repeat(pos, _rep, axis=0)\n            pos = np.repeat(pos[:n_text], repeats, axis=0)\n            assert pos.shape[0] == self._vertices.size == len(_rot)\n            self.shared_program['a_pos'] = pos\n            self._pos_changed = False\n        if self._color_changed:\n            # now we promote color to the proper shape (varying)\n            text = self.text\n            if not isinstance(text, str):\n                repeats = [4 * len(t) for t in text]\n                text = ''.join(text)\n            else:\n                repeats = [4 * len(text)]\n            n_text = len(repeats)\n            color = self.color.rgba\n            if color.shape[0] < n_text:\n                color = np.repeat(color,\n                                  [1]*(len(color)-1) + [n_text-len(color)+1],\n                                  axis=0)\n            color = np.repeat(color[:n_text], repeats, axis=0)\n            assert color.shape[0] == self._vertices.size\n            self._color_vbo = VertexBuffer(color)\n            self.shared_program.vert['color'] = self._color_vbo\n            self._color_changed = False\n\n        transforms = self.transforms\n        n_pix = (self._font_size / 72.) * transforms.dpi  # logical pix\n        tr = transforms.get_transform('document', 'render')\n        px_scale = (tr.map((1, 0)) - tr.map((0, 1)))[:2]\n        self._text_scale.scale = px_scale * n_pix\n        self.shared_program.vert['text_scale'] = self._text_scale\n        self.shared_program['u_npix'] = n_pix\n        self.shared_program['u_kernel'] = self._font._kernel\n        self.shared_program['u_color'] = self._color.rgba\n        self.shared_program['u_font_atlas'] = self._font._atlas\n        self.shared_program['u_font_atlas_shape'] = self._font._atlas.shape[:2]\n\n    def _prepare_transforms(self, view):\n        self._pos_changed = True\n        # Note that we access `view_program` instead of `shared_program`\n        # because we do not want this function assigned to other views.\n        tr = view.transforms.get_transform()\n        view.view_program.vert['transform'] = tr  # .simplified()\n\n    def _compute_bounds(self, axis, view):\n        return self._pos[:, axis].min(), self._pos[:, axis].max()\n\n    @property\n    def face(self):\n        return self._face\n\n    @face.setter\n    def face(self, value):\n        self._face = value\n        self._update_font()\n\n    @property\n    def bold(self):\n        return self._bold\n\n    @bold.setter\n    def bold(self, value):\n        self._bold = value\n        self._update_font()\n\n    @property\n    def italic(self):\n        return self._italic\n\n    @italic.setter\n    def italic(self, value):\n        self._italic = value\n        self._update_font()\n\n    def _update_font(self):\n        self._font = self._font_manager.get_font(self._face, self._bold, self._italic)\n        self.update()",
  "class SDFRendererCPU(object):\n    \"\"\"Render SDFs using the CPU.\"\"\"\n\n    # This should probably live in _sdf_cpu.pyx, but doing so makes\n    # debugging substantially more annoying\n    def render_to_texture(self, data, texture, offset, size):\n        sdf = (data / 255).astype(np.float32)  # from ubyte -> float\n        h, w = sdf.shape\n        tex_w, tex_h = size\n        _calc_distance_field(sdf, w, h, 32)\n        # This tweaking gets us a result more similar to the GPU SDFs,\n        # for which the text rendering code was optimized\n        sdf = 2 * sdf - 1.\n        sdf = np.sign(sdf) * np.abs(sdf) ** 0.75 / 2. + 0.5\n        # Downsample using NumPy (because we can't guarantee SciPy)\n        xp = (np.arange(w) + 0.5) / float(w)\n        x = (np.arange(tex_w) + 0.5) / float(tex_w)\n        bitmap = np.array([np.interp(x, xp, ss) for ss in sdf])\n        xp = (np.arange(h) + 0.5) / float(h)\n        x = (np.arange(tex_h) + 0.5) / float(tex_h)\n        bitmap = np.array([np.interp(x, xp, ss) for ss in bitmap.T]).T\n        assert bitmap.shape[::-1] == size\n        # convert to uint8\n        bitmap = (bitmap * 255).astype(np.uint8)\n        # convert single channel to RGB by repeating\n        bitmap = np.tile(bitmap[..., np.newaxis],\n                         (1, 1, 3))\n        texture[offset[1]:offset[1] + size[1],\n                offset[0]:offset[0] + size[0], :] = bitmap",
  "def __init__(self, font, renderer):\n        self._atlas = TextureAtlas(dtype=np.uint8)\n        self._atlas.wrapping = 'clamp_to_edge'\n        self._kernel, _ = load_spatial_filters()\n        self._renderer = renderer\n        self._font = deepcopy(font)\n        self._font['size'] = 256  # use high resolution point size for SDF\n        self._lowres_size = 64  # end at this point size for storage\n        assert (self._font['size'] % self._lowres_size) == 0\n        # spread/border at the high-res for SDF calculation; must be chosen\n        # relative to fragment_insert.glsl multiplication factor to ensure we\n        # get to zero at the edges of characters\n        # This is also used in SDFRendererCPU, so changing this needs to\n        # propagate at least 2 other places.\n        self._spread = 32\n        assert self._spread % self.ratio == 0\n        self._glyphs = {}",
  "def ratio(self):\n        \"\"\"Ratio of the initial high-res to final stored low-res glyph\"\"\"\n        return self._font['size'] // self._lowres_size",
  "def slop(self):\n        \"\"\"Extra space along each glyph edge due to SDF borders\"\"\"\n        return self._spread // self.ratio",
  "def __getitem__(self, char):\n        if not (isinstance(char, str) and len(char) == 1):\n            raise TypeError('index must be a 1-character string')\n        if char not in self._glyphs:\n            self._load_char(char)\n        return self._glyphs[char]",
  "def _load_char(self, char):\n        \"\"\"Build and store a glyph corresponding to an individual character\n\n        Parameters\n        ----------\n        char : str\n            A single character to be represented.\n        \"\"\"\n        assert isinstance(char, str) and len(char) == 1\n        assert char not in self._glyphs\n        # load new glyph data from font\n        _load_glyph(self._font, char, self._glyphs)\n        # put new glyph into the texture\n        glyph = self._glyphs[char]\n        bitmap = glyph['bitmap']\n\n        # convert to padded array\n        data = np.zeros((bitmap.shape[0] + 2*self._spread,\n                         bitmap.shape[1] + 2*self._spread), np.uint8)\n        data[self._spread:-self._spread, self._spread:-self._spread] = bitmap\n\n        # Store, while scaling down to proper size\n        height = data.shape[0] // self.ratio\n        width = data.shape[1] // self.ratio\n        region = self._atlas.get_free_region(width + 2, height + 2)\n        if region is None:\n            raise RuntimeError('Cannot store glyph')\n        x, y, w, h = region\n        x, y, w, h = x + 1, y + 1, w - 2, h - 2\n\n        self._renderer.render_to_texture(data, self._atlas, (x, y), (w, h))\n        u0 = x / float(self._atlas.shape[1])\n        v0 = y / float(self._atlas.shape[0])\n        u1 = (x+w) / float(self._atlas.shape[1])\n        v1 = (y+h) / float(self._atlas.shape[0])\n        texcoords = (u0, v0, u1, v1)\n        glyph.update(dict(size=(w, h), texcoords=texcoords))",
  "def __init__(self, method='cpu'):\n        self._fonts = {}\n        if not isinstance(method, str) or \\\n                method not in ('cpu', 'gpu'):\n            raise ValueError('method must be \"cpu\" or \"gpu\", got %s (%s)'\n                             % (method, type(method)))\n        if method == 'cpu':\n            self._renderer = SDFRendererCPU()\n        else:  # method == 'gpu':\n            self._renderer = SDFRendererGPU()",
  "def get_font(self, face, bold=False, italic=False):\n        \"\"\"Get a font described by face and size\"\"\"\n        key = '%s-%s-%s' % (face, bold, italic)\n        if key not in self._fonts:\n            font = dict(face=face, bold=bold, italic=italic)\n            self._fonts[key] = TextureFont(font, self._renderer)\n        return self._fonts[key]",
  "def __init__(self, text=None, color='black', bold=False,\n                 italic=False, face='OpenSans', font_size=12, pos=[0, 0, 0],\n                 rotation=0., anchor_x='center', anchor_y='center',\n                 method='cpu', font_manager=None, depth_test=False):\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        # Check input\n        valid_keys = ('top', 'center', 'middle', 'baseline', 'bottom')\n        _check_valid('anchor_y', anchor_y, valid_keys)\n        valid_keys = ('left', 'center', 'right')\n        _check_valid('anchor_x', anchor_x, valid_keys)\n        # Init font handling stuff\n        # _font_manager is a temporary solution to use global mananger\n        self._font_manager = font_manager or FontManager(method=method)\n        self._face = face\n        self._bold = bold\n        self._italic = italic\n        self._update_font()\n        self._vertices = None\n        self._color_vbo = None\n        self._anchors = (anchor_x, anchor_y)\n        # Init text properties\n        self.color = color\n        self.text = text\n        self.font_size = font_size\n        self.pos = pos\n        self.rotation = rotation\n        self._text_scale = STTransform()\n        self._draw_mode = 'triangles'\n        self.set_gl_state(blend=True, depth_test=depth_test, cull_face=False,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self.freeze()",
  "def text(self):\n        \"\"\"The text string\"\"\"\n        return self._text",
  "def text(self, text):\n        if isinstance(text, list):\n            assert all(isinstance(t, str) for t in text)\n        if text is None:\n            text = []\n        self._text = text\n        self._vertices = None\n        self._pos_changed = True  # need to update this as well\n        self._color_changed = True\n        self.update()",
  "def anchors(self):\n        return self._anchors",
  "def anchors(self, a):\n        self._anchors = a\n        self._vertices = None\n        self._pos_changed = True\n        self.update()",
  "def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._font_size",
  "def font_size(self, size):\n        self._font_size = max(0.0, float(size))\n        self.update()",
  "def color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._color",
  "def color(self, color):\n        self._color = ColorArray(color)\n        self._color_changed = True\n        self.update()",
  "def rotation(self):\n        \"\"\"The rotation of the text (clockwise, in degrees)\"\"\"\n        return self._rotation * 180. / np.pi",
  "def rotation(self, rotation):\n        self._rotation = np.asarray(rotation) * np.pi / 180.\n        self._pos_changed = True\n        self.update()",
  "def pos(self):\n        \"\"\"The position of the text anchor in the local coordinate frame\"\"\"\n        return self._pos",
  "def pos(self, pos):\n        pos = np.atleast_2d(pos).astype(np.float32)\n        if pos.shape[1] == 2:\n            pos = np.concatenate((pos, np.zeros((pos.shape[0], 1),\n                                                np.float32)), axis=1)\n        elif pos.shape[1] != 3:\n            raise ValueError('pos must have 2 or 3 elements')\n        elif pos.shape[0] == 0:\n            raise ValueError('at least one position must be given')\n        self._pos = pos\n        self._pos_changed = True\n        self.update()",
  "def _prepare_draw(self, view):\n        # attributes / uniforms are not available until program is built\n        if len(self.text) == 0:\n            return False\n        if self._vertices is None:\n            text = self.text\n            if isinstance(text, str):\n                text = [text]\n            n_char = sum(len(t) for t in text)\n            # we delay creating vertices because it requires a context,\n            # which may or may not exist when the object is initialized\n            self._vertices = np.concatenate([\n                _text_to_vbo(t, self._font, self._anchors[0], self._anchors[1],\n                             self._font._lowres_size) for t in text])\n            self._vertices = VertexBuffer(self._vertices)\n            idx = (np.array([0, 1, 2, 0, 2, 3], np.uint32) +\n                   np.arange(0, 4*n_char, 4, dtype=np.uint32)[:, np.newaxis])\n            self._index_buffer = IndexBuffer(idx.ravel())\n            self.shared_program.bind(self._vertices)\n            # This is necessary to reset the GL drawing state after generating\n            # SDF textures. A better way would be to enable the state to be\n            # pushed/popped by the context.\n            self._configure_gl_state()\n        if self._pos_changed:\n            # now we promote pos to the proper shape (attribute)\n            text = self.text\n            if not isinstance(text, str):\n                repeats = [4 * len(t) for t in text]\n                text = ''.join(text)\n            else:\n                repeats = [4 * len(text)]\n            n_text = len(repeats)\n            pos = self.pos\n            # Rotation\n            _rot = self._rotation\n            if isinstance(_rot, (int, float)):\n                _rot = np.full((pos.shape[0],), self._rotation)\n            _rot = np.asarray(_rot)\n            if _rot.shape[0] < n_text:\n                _rep = [1] * (len(_rot) - 1) + [n_text - len(_rot) + 1]\n                _rot = np.repeat(_rot, _rep, axis=0)\n            _rot = np.repeat(_rot[:n_text], repeats, axis=0)\n            self.shared_program['a_rotation'] = _rot.astype(np.float32)\n            # Position\n            if pos.shape[0] < n_text:\n                _rep = [1] * (len(pos) - 1) + [n_text - len(pos) + 1]\n                pos = np.repeat(pos, _rep, axis=0)\n            pos = np.repeat(pos[:n_text], repeats, axis=0)\n            assert pos.shape[0] == self._vertices.size == len(_rot)\n            self.shared_program['a_pos'] = pos\n            self._pos_changed = False\n        if self._color_changed:\n            # now we promote color to the proper shape (varying)\n            text = self.text\n            if not isinstance(text, str):\n                repeats = [4 * len(t) for t in text]\n                text = ''.join(text)\n            else:\n                repeats = [4 * len(text)]\n            n_text = len(repeats)\n            color = self.color.rgba\n            if color.shape[0] < n_text:\n                color = np.repeat(color,\n                                  [1]*(len(color)-1) + [n_text-len(color)+1],\n                                  axis=0)\n            color = np.repeat(color[:n_text], repeats, axis=0)\n            assert color.shape[0] == self._vertices.size\n            self._color_vbo = VertexBuffer(color)\n            self.shared_program.vert['color'] = self._color_vbo\n            self._color_changed = False\n\n        transforms = self.transforms\n        n_pix = (self._font_size / 72.) * transforms.dpi  # logical pix\n        tr = transforms.get_transform('document', 'render')\n        px_scale = (tr.map((1, 0)) - tr.map((0, 1)))[:2]\n        self._text_scale.scale = px_scale * n_pix\n        self.shared_program.vert['text_scale'] = self._text_scale\n        self.shared_program['u_npix'] = n_pix\n        self.shared_program['u_kernel'] = self._font._kernel\n        self.shared_program['u_color'] = self._color.rgba\n        self.shared_program['u_font_atlas'] = self._font._atlas\n        self.shared_program['u_font_atlas_shape'] = self._font._atlas.shape[:2]",
  "def _prepare_transforms(self, view):\n        self._pos_changed = True\n        # Note that we access `view_program` instead of `shared_program`\n        # because we do not want this function assigned to other views.\n        tr = view.transforms.get_transform()\n        view.view_program.vert['transform'] = tr",
  "def _compute_bounds(self, axis, view):\n        return self._pos[:, axis].min(), self._pos[:, axis].max()",
  "def face(self):\n        return self._face",
  "def face(self, value):\n        self._face = value\n        self._update_font()",
  "def bold(self):\n        return self._bold",
  "def bold(self, value):\n        self._bold = value\n        self._update_font()",
  "def italic(self):\n        return self._italic",
  "def italic(self, value):\n        self._italic = value\n        self._update_font()",
  "def _update_font(self):\n        self._font = self._font_manager.get_font(self._face, self._bold, self._italic)\n        self.update()",
  "def render_to_texture(self, data, texture, offset, size):\n        sdf = (data / 255).astype(np.float32)  # from ubyte -> float\n        h, w = sdf.shape\n        tex_w, tex_h = size\n        _calc_distance_field(sdf, w, h, 32)\n        # This tweaking gets us a result more similar to the GPU SDFs,\n        # for which the text rendering code was optimized\n        sdf = 2 * sdf - 1.\n        sdf = np.sign(sdf) * np.abs(sdf) ** 0.75 / 2. + 0.5\n        # Downsample using NumPy (because we can't guarantee SciPy)\n        xp = (np.arange(w) + 0.5) / float(w)\n        x = (np.arange(tex_w) + 0.5) / float(tex_w)\n        bitmap = np.array([np.interp(x, xp, ss) for ss in sdf])\n        xp = (np.arange(h) + 0.5) / float(h)\n        x = (np.arange(tex_h) + 0.5) / float(tex_h)\n        bitmap = np.array([np.interp(x, xp, ss) for ss in bitmap.T]).T\n        assert bitmap.shape[::-1] == size\n        # convert to uint8\n        bitmap = (bitmap * 255).astype(np.uint8)\n        # convert single channel to RGB by repeating\n        bitmap = np.tile(bitmap[..., np.newaxis],\n                         (1, 1, 3))\n        texture[offset[1]:offset[1] + size[1],\n                offset[0]:offset[0] + size[0], :] = bitmap",
  "class Variable(ShaderObject):\n    \"\"\"Representation of global shader variable\n\n    Parameters\n    ----------\n    name : str\n        the name of the variable. This string can also contain the full\n        definition of the variable, e.g. 'uniform vec2 foo'.\n    value : {float, int, tuple, GLObject}\n        If given, vtype and dtype are determined automatically. If a\n        float/int/tuple is given, the variable is a uniform. If a gloo\n        object is given that has a glsl_type property, the variable is\n        an attribute and\n    vtype : {'const', 'uniform', 'attribute', 'varying', 'inout'}\n        The type of variable.\n    dtype : str\n        The data type of the variable, e.g. 'float', 'vec4', 'mat', etc.\n    \"\"\"\n\n    _vtype_32_conversion = {'in': 'attribute', 'out': 'varying'}\n    _vtype_23_conversion = {'attribute': 'in', 'varying': 'out'}\n\n    def __init__(self, name, value=None, vtype=None, dtype=None):\n        super(Variable, self).__init__()\n\n        # allow full definition in first argument\n        if ' ' in name:\n            fields = name.split(' ')\n            if len(fields) == 3:\n                vtype, dtype, name = fields\n            elif len(fields) == 4 and fields[0] == 'const':\n                vtype, dtype, name, value = fields\n            else:\n                raise ValueError('Variable specifications given by string must'\n                                 ' be of the form \"vtype dtype name\" or '\n                                 '\"const dtype name value\".')\n\n        if not (isinstance(name, str) or name is None):\n            raise TypeError(\"Variable name must be string or None.\")\n\n        self._state_counter = 0\n        self._name = name\n        self._vtype = self._vtype_32_conversion.get(vtype, vtype)\n        self._dtype = dtype\n        self._value = None\n\n        # If vtype/dtype were given at init, then we will never\n        # try to set these values automatically.\n        self._type_locked = self._vtype is not None and self._dtype is not None\n\n        if value is not None:\n            self.value = value\n\n        if self._vtype and self._vtype not in VARIABLE_TYPES:\n            raise ValueError('Not a valid vtype: %r' % self._vtype)\n\n    @property\n    def name(self):\n        \"\"\"The name of this variable.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, n):\n        # Settable mostly to allow automatic setting of varying names\n        # See ShaderObject.create()\n        if self._name != n:\n            self._name = n\n            self.changed(code_changed=True)\n\n    @property\n    def vtype(self):\n        \"\"\"The type of variable (const, uniform, attribute, or varying).\n\n        For in/out variables (GLSL 150+), vtype is 'varying'.\n        \"\"\"\n        return self._vtype\n\n    @property\n    def dtype(self):\n        \"\"\"The type of data (float, int, vec, mat, ...).\"\"\"\n        return self._dtype\n\n    @property\n    def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        if isinstance(value, (tuple, list)) and 1 < len(value) < 5:\n            vtype = 'uniform'\n            dtype = 'vec%d' % len(value)\n        elif isinstance(value, np.ndarray):\n            if value.ndim == 1 and (1 < len(value) < 5):\n                vtype = 'uniform'\n                dtype = 'vec%d' % len(value)\n            elif value.ndim == 2 and value.shape in ((2, 2), (3, 3), (4, 4)):\n                vtype = 'uniform'\n                dtype = 'mat%d' % value.shape[0]\n            else:\n                raise ValueError(\"Cannot make uniform value for %s from array \"\n                                 \"of shape %s.\" % (self.name, value.shape))\n        elif np.isscalar(value):\n            vtype = 'uniform'\n            if isinstance(value, (float, np.floating)):\n                dtype = 'float'\n            elif isinstance(value, (int, np.integer)):\n                dtype = 'int'\n            else:\n                raise TypeError(\"Unknown data type %r for variable %r\" %\n                                (type(value), self))\n        elif getattr(value, 'glsl_type', None) is not None:\n            # Note: hasattr() is broken by design--swallows all exceptions!\n            vtype, dtype = value.glsl_type\n        else:\n            raise TypeError(\"Unknown data type %r for variable %r\" %\n                            (type(value), self))\n\n        self._value = value\n        self._state_counter += 1\n\n        if self._type_locked:\n            if dtype != self._dtype or vtype != self._vtype:\n                raise TypeError('Variable is type \"%s\"; cannot assign value '\n                                '%r.' % (self.dtype, value))\n            return\n\n        # update vtype/dtype and emit changed event if necessary\n        changed = False\n        if self._dtype != dtype:\n            self._dtype = dtype\n            changed = True\n        if self._vtype != vtype:\n            self._vtype = vtype\n            changed = True\n        if changed:\n            self.changed(code_changed=True, value_changed=True)\n\n    @property\n    def state_id(self):\n        \"\"\"Return a unique ID that changes whenever the state of the Variable\n        has changed. This allows ModularProgram to quickly determine whether\n        the value has changed since it was last used.\n        \"\"\"\n        return id(self), self._state_counter\n\n    def __repr__(self):\n        return (\"<%s \\\"%s %s %s\\\" at 0x%x>\" % (self.__class__.__name__,\n                                               self._vtype, self._dtype,\n                                               self.name, id(self)))\n\n    def expression(self, names):\n        return names[self]\n\n    def _vtype_for_version(self, version):\n        \"\"\"Return the vtype for this variable, converted based on the GLSL version.\"\"\"\n        vtype = self.vtype\n        if version is None or version[0] == 120:\n            return self._vtype_32_conversion.get(vtype, vtype)\n        else:\n            return self._vtype_23_conversion.get(vtype, vtype)\n\n    def definition(self, names, version, shader):\n        if self.vtype is None:\n            raise RuntimeError(\"Variable has no vtype: %r\" % self)\n        if self.dtype is None:\n            raise RuntimeError(\"Variable has no dtype: %r\" % self)\n\n        name = names[self]\n        vtype = self._vtype_for_version(version)\n        if vtype == 'const':\n            return '%s %s %s = %s;' % (vtype, self.dtype, name, self.value)\n        else:\n            return '%s %s %s;' % (vtype, self.dtype, name)",
  "class Varying(Variable):\n    \"\"\"Representation of a varying (variables passed from one shader to the\n    next).\n\n    Varyings can inherit their dtype from another Variable, allowing for\n    more flexibility in composing shaders.\n    \"\"\"\n\n    def __init__(self, name, dtype=None):\n        self._link = None\n        self._src_func = None\n        self._dst_func = None\n        Variable.__init__(self, name, vtype='varying', dtype=dtype)\n\n    @property\n    def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        if value is not None:\n            raise TypeError(\"Cannot assign value directly to varying.\")\n\n    @property\n    def dtype(self):\n        if self._dtype is None:\n            if self._link is None:\n                return None\n            else:\n                return self._link.dtype\n        else:\n            return self._dtype\n\n    def link(self, var):\n        \"\"\"Link this Varying to another object from which it will derive its\n        dtype.\n\n        This method is used internally when assigning an attribute to\n        a varying using syntax ``function[varying] = attr``.\n        \"\"\"\n        assert self._dtype is not None or hasattr(var, 'dtype')\n        self._link = var\n        self.changed()\n\n    def invar(self, array=False):\n        \"\"\"Return a varying that defines itself using the same name as this,\n        but as an `in` variable instead of `out`.\n        \"\"\"\n        return InVar(self, array=array)",
  "class InVar(Variable):\n    def __init__(self, var, array=False):\n        self._var = var\n        self._array = array\n        Variable.__init__(self, var.name)\n\n    @property\n    def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._var.value\n\n    @value.setter\n    def value(self, value):\n        if value is not None:\n            raise TypeError(\"Cannot assign value directly to varying.\")\n\n    @property\n    def dtype(self):\n        return self._var.dtype\n\n    def definition(self, names, version, shader):\n        # inherit name from source variable\n        name = names[self._var]\n        dtype = self._var.dtype\n\n        if version[0] <= 120:\n            return \"varying %s %s;\" % (dtype, name)\n        else:\n            if self._array:\n                return \"in %s %s[];\" % (dtype, name)\n            else:\n                return \"in %s %s;\" % (dtype, name)\n\n    def expression(self, names):\n        return names[self._var]",
  "def __init__(self, name, value=None, vtype=None, dtype=None):\n        super(Variable, self).__init__()\n\n        # allow full definition in first argument\n        if ' ' in name:\n            fields = name.split(' ')\n            if len(fields) == 3:\n                vtype, dtype, name = fields\n            elif len(fields) == 4 and fields[0] == 'const':\n                vtype, dtype, name, value = fields\n            else:\n                raise ValueError('Variable specifications given by string must'\n                                 ' be of the form \"vtype dtype name\" or '\n                                 '\"const dtype name value\".')\n\n        if not (isinstance(name, str) or name is None):\n            raise TypeError(\"Variable name must be string or None.\")\n\n        self._state_counter = 0\n        self._name = name\n        self._vtype = self._vtype_32_conversion.get(vtype, vtype)\n        self._dtype = dtype\n        self._value = None\n\n        # If vtype/dtype were given at init, then we will never\n        # try to set these values automatically.\n        self._type_locked = self._vtype is not None and self._dtype is not None\n\n        if value is not None:\n            self.value = value\n\n        if self._vtype and self._vtype not in VARIABLE_TYPES:\n            raise ValueError('Not a valid vtype: %r' % self._vtype)",
  "def name(self):\n        \"\"\"The name of this variable.\"\"\"\n        return self._name",
  "def name(self, n):\n        # Settable mostly to allow automatic setting of varying names\n        # See ShaderObject.create()\n        if self._name != n:\n            self._name = n\n            self.changed(code_changed=True)",
  "def vtype(self):\n        \"\"\"The type of variable (const, uniform, attribute, or varying).\n\n        For in/out variables (GLSL 150+), vtype is 'varying'.\n        \"\"\"\n        return self._vtype",
  "def dtype(self):\n        \"\"\"The type of data (float, int, vec, mat, ...).\"\"\"\n        return self._dtype",
  "def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._value",
  "def value(self, value):\n        if isinstance(value, (tuple, list)) and 1 < len(value) < 5:\n            vtype = 'uniform'\n            dtype = 'vec%d' % len(value)\n        elif isinstance(value, np.ndarray):\n            if value.ndim == 1 and (1 < len(value) < 5):\n                vtype = 'uniform'\n                dtype = 'vec%d' % len(value)\n            elif value.ndim == 2 and value.shape in ((2, 2), (3, 3), (4, 4)):\n                vtype = 'uniform'\n                dtype = 'mat%d' % value.shape[0]\n            else:\n                raise ValueError(\"Cannot make uniform value for %s from array \"\n                                 \"of shape %s.\" % (self.name, value.shape))\n        elif np.isscalar(value):\n            vtype = 'uniform'\n            if isinstance(value, (float, np.floating)):\n                dtype = 'float'\n            elif isinstance(value, (int, np.integer)):\n                dtype = 'int'\n            else:\n                raise TypeError(\"Unknown data type %r for variable %r\" %\n                                (type(value), self))\n        elif getattr(value, 'glsl_type', None) is not None:\n            # Note: hasattr() is broken by design--swallows all exceptions!\n            vtype, dtype = value.glsl_type\n        else:\n            raise TypeError(\"Unknown data type %r for variable %r\" %\n                            (type(value), self))\n\n        self._value = value\n        self._state_counter += 1\n\n        if self._type_locked:\n            if dtype != self._dtype or vtype != self._vtype:\n                raise TypeError('Variable is type \"%s\"; cannot assign value '\n                                '%r.' % (self.dtype, value))\n            return\n\n        # update vtype/dtype and emit changed event if necessary\n        changed = False\n        if self._dtype != dtype:\n            self._dtype = dtype\n            changed = True\n        if self._vtype != vtype:\n            self._vtype = vtype\n            changed = True\n        if changed:\n            self.changed(code_changed=True, value_changed=True)",
  "def state_id(self):\n        \"\"\"Return a unique ID that changes whenever the state of the Variable\n        has changed. This allows ModularProgram to quickly determine whether\n        the value has changed since it was last used.\n        \"\"\"\n        return id(self), self._state_counter",
  "def __repr__(self):\n        return (\"<%s \\\"%s %s %s\\\" at 0x%x>\" % (self.__class__.__name__,\n                                               self._vtype, self._dtype,\n                                               self.name, id(self)))",
  "def expression(self, names):\n        return names[self]",
  "def _vtype_for_version(self, version):\n        \"\"\"Return the vtype for this variable, converted based on the GLSL version.\"\"\"\n        vtype = self.vtype\n        if version is None or version[0] == 120:\n            return self._vtype_32_conversion.get(vtype, vtype)\n        else:\n            return self._vtype_23_conversion.get(vtype, vtype)",
  "def definition(self, names, version, shader):\n        if self.vtype is None:\n            raise RuntimeError(\"Variable has no vtype: %r\" % self)\n        if self.dtype is None:\n            raise RuntimeError(\"Variable has no dtype: %r\" % self)\n\n        name = names[self]\n        vtype = self._vtype_for_version(version)\n        if vtype == 'const':\n            return '%s %s %s = %s;' % (vtype, self.dtype, name, self.value)\n        else:\n            return '%s %s %s;' % (vtype, self.dtype, name)",
  "def __init__(self, name, dtype=None):\n        self._link = None\n        self._src_func = None\n        self._dst_func = None\n        Variable.__init__(self, name, vtype='varying', dtype=dtype)",
  "def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._value",
  "def value(self, value):\n        if value is not None:\n            raise TypeError(\"Cannot assign value directly to varying.\")",
  "def dtype(self):\n        if self._dtype is None:\n            if self._link is None:\n                return None\n            else:\n                return self._link.dtype\n        else:\n            return self._dtype",
  "def link(self, var):\n        \"\"\"Link this Varying to another object from which it will derive its\n        dtype.\n\n        This method is used internally when assigning an attribute to\n        a varying using syntax ``function[varying] = attr``.\n        \"\"\"\n        assert self._dtype is not None or hasattr(var, 'dtype')\n        self._link = var\n        self.changed()",
  "def invar(self, array=False):\n        \"\"\"Return a varying that defines itself using the same name as this,\n        but as an `in` variable instead of `out`.\n        \"\"\"\n        return InVar(self, array=array)",
  "def __init__(self, var, array=False):\n        self._var = var\n        self._array = array\n        Variable.__init__(self, var.name)",
  "def value(self):\n        \"\"\"The value associated with this variable.\"\"\"\n        return self._var.value",
  "def value(self, value):\n        if value is not None:\n            raise TypeError(\"Cannot assign value directly to varying.\")",
  "def dtype(self):\n        return self._var.dtype",
  "def definition(self, names, version, shader):\n        # inherit name from source variable\n        name = names[self._var]\n        dtype = self._var.dtype\n\n        if version[0] <= 120:\n            return \"varying %s %s;\" % (dtype, name)\n        else:\n            if self._array:\n                return \"in %s %s[];\" % (dtype, name)\n            else:\n                return \"in %s %s;\" % (dtype, name)",
  "def expression(self, names):\n        return names[self._var]",
  "class Expression(ShaderObject):\n    \"\"\"Base class for expressions (ShaderObjects that do not have a\n    definition nor dependencies)\n    \"\"\"\n\n    def definition(self, names, version):\n        # expressions are declared inline.\n        return None",
  "class TextExpression(Expression):\n    \"\"\"Plain GLSL text to insert inline\"\"\"\n\n    def __init__(self, text):\n        super(TextExpression, self).__init__()\n        if not isinstance(text, str):\n            raise TypeError(\"Argument must be string.\")\n        self._text = text\n\n    def __repr__(self):\n        return '<TextExpression %r for at 0x%x>' % (self.text, id(self))\n\n    def expression(self, names=None):\n        return self._text\n\n    @property\n    def text(self):\n        return self._text\n\n    @text.setter\n    def text(self, t):\n        self._text = t\n        self.changed()\n\n    def __eq__(self, a):\n        if isinstance(a, TextExpression):\n            return a._text == self._text\n        elif isinstance(a, str):\n            return a == self._text\n        else:\n            return False\n\n    def __hash__(self):\n        return self._text.__hash__()",
  "class FunctionCall(Expression):\n    \"\"\"Representation of a call to a function\n\n    Essentially this is container for a Function along with its signature.\n    \"\"\"\n\n    def __init__(self, function, args):\n        from .function import Function\n        super(FunctionCall, self).__init__()\n\n        if not isinstance(function, Function):\n            raise TypeError('FunctionCall needs a Function')\n\n        sig_len = len(function.args)\n        if len(args) != sig_len:\n            raise TypeError('Function %s requires %d arguments (got %d)' %\n                            (function.name, sig_len, len(args)))\n\n        # Ensure all expressions\n        sig = function.args\n\n        self._function = function\n\n        # Convert all arguments to ShaderObject, using arg name if possible.\n        self._args = [ShaderObject.create(arg, ref=sig[i][1])\n                      for i, arg in enumerate(args)]\n\n        self._add_dep(function)\n        for arg in self._args:\n            self._add_dep(arg)\n\n    def __repr__(self):\n        return '<FunctionCall of %r at 0x%x>' % (self.function.name, id(self))\n\n    @property\n    def function(self):\n        return self._function\n\n    @property\n    def dtype(self):\n        return self._function.rtype\n\n    def expression(self, names):\n        str_args = [arg.expression(names) for arg in self._args]\n        args = ', '.join(str_args)\n        fname = self.function.expression(names)\n        return '%s(%s)' % (fname, args)",
  "def definition(self, names, version):\n        # expressions are declared inline.\n        return None",
  "def __init__(self, text):\n        super(TextExpression, self).__init__()\n        if not isinstance(text, str):\n            raise TypeError(\"Argument must be string.\")\n        self._text = text",
  "def __repr__(self):\n        return '<TextExpression %r for at 0x%x>' % (self.text, id(self))",
  "def expression(self, names=None):\n        return self._text",
  "def text(self):\n        return self._text",
  "def text(self, t):\n        self._text = t\n        self.changed()",
  "def __eq__(self, a):\n        if isinstance(a, TextExpression):\n            return a._text == self._text\n        elif isinstance(a, str):\n            return a == self._text\n        else:\n            return False",
  "def __hash__(self):\n        return self._text.__hash__()",
  "def __init__(self, function, args):\n        from .function import Function\n        super(FunctionCall, self).__init__()\n\n        if not isinstance(function, Function):\n            raise TypeError('FunctionCall needs a Function')\n\n        sig_len = len(function.args)\n        if len(args) != sig_len:\n            raise TypeError('Function %s requires %d arguments (got %d)' %\n                            (function.name, sig_len, len(args)))\n\n        # Ensure all expressions\n        sig = function.args\n\n        self._function = function\n\n        # Convert all arguments to ShaderObject, using arg name if possible.\n        self._args = [ShaderObject.create(arg, ref=sig[i][1])\n                      for i, arg in enumerate(args)]\n\n        self._add_dep(function)\n        for arg in self._args:\n            self._add_dep(arg)",
  "def __repr__(self):\n        return '<FunctionCall of %r at 0x%x>' % (self.function.name, id(self))",
  "def function(self):\n        return self._function",
  "def dtype(self):\n        return self._function.rtype",
  "def expression(self, names):\n        str_args = [arg.expression(names) for arg in self._args]\n        args = ', '.join(str_args)\n        fname = self.function.expression(names)\n        return '%s(%s)' % (fname, args)",
  "class ModularProgram(Program):\n    \"\"\"\n    Shader program using Function instances as basis for its shaders.\n\n    Automatically rebuilds program when functions have changed and uploads\n    program variables.\n    \"\"\"\n\n    def __init__(self, vcode='', fcode='', gcode=None):\n        Program.__init__(self)\n\n        self.changed = EventEmitter(source=self, type='program_change')\n\n        # Cache state of Variables so we know which ones require update\n        self._variable_cache = WeakKeyDictionary()\n\n        # List of settable variables to be checked for value changes\n        self._variables = []\n\n        self._vert = MainFunction('vertex', '')\n        self._frag = MainFunction('fragment', '')\n        self._vert._dependents[self] = None\n        self._frag._dependents[self] = None\n        self._geom = None\n\n        self.vert = vcode\n        self.frag = fcode\n        self.geom = gcode\n\n    @property\n    def vert(self):\n        return self._vert\n\n    @vert.setter\n    def vert(self, vcode):\n        vcode = preprocess(vcode)\n        self._vert.code = vcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)\n\n    @property\n    def frag(self):\n        return self._frag\n\n    @frag.setter\n    def frag(self, fcode):\n        fcode = preprocess(fcode)\n        self._frag.code = fcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)\n\n    @property\n    def geom(self):\n        return self._geom\n\n    @geom.setter\n    def geom(self, gcode):\n        if gcode is None:\n            self._geom = None\n            return\n        gcode = preprocess(gcode)\n        if self._geom is None:\n            self._geom = MainFunction('geometry', '')\n            self._geom._dependents[self] = None\n        self._geom.code = gcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)\n\n    def _dep_changed(self, dep, code_changed=False, value_changed=False):\n        if code_changed and logger.level <= logging.DEBUG:\n            logger.debug(\"ModularProgram changed: %s   source=%s, values=%s\", \n                         self, code_changed, value_changed)\n            import traceback\n            traceback.print_stack()\n\n        if code_changed:\n            self._need_build = True\n        self.changed(code_changed=code_changed, \n                     value_changed=value_changed)\n\n    def draw(self, *args, **kwargs):\n        self.build_if_needed()\n        self.update_variables()\n        Program.draw(self, *args, **kwargs)\n\n    def build_if_needed(self):\n        \"\"\"Reset shader source if necesssary.\"\"\"\n        if self._need_build:\n            self._build()\n\n            # after recompile, we need to upload all variables again\n            # (some variables may have changed name)\n            self._variable_cache.clear()\n\n            # Collect a list of all settable variables\n            settable_vars = 'attribute', 'uniform', 'in'\n            deps = [d for d in self.vert.dependencies() if (\n                isinstance(d, Variable) and d.vtype in settable_vars)]\n            deps += [d for d in self.frag.dependencies() if (\n                isinstance(d, Variable) and d.vtype == 'uniform')]\n            if self.geom is not None:\n                deps += [d for d in self.geom.dependencies() if (\n                    isinstance(d, Variable) and d.vtype == 'uniform')]\n            self._variables = deps\n\n            self._need_build = False\n\n    def _build(self):\n        logger.debug(\"Rebuild ModularProgram: %s\", self)\n        shaders = {'vert': self.vert, 'frag': self.frag}\n        if self.geom is not None:\n            shaders['geom'] = self.geom\n        self.compiler = Compiler(**shaders)\n        code = self.compiler.compile()\n\n        # Update shader code, but don't let the program update variables yet \n        code['update_variables'] = False\n        self.set_shaders(**code)\n\n        logger.debug('==== Vertex Shader ====\\n\\n%s\\n', code['vert'])\n        if 'geom' in code:\n            logger.debug('==== Geometry shader ====\\n\\n%s\\n', code['geom'])\n        logger.debug('==== Fragment shader ====\\n\\n%s\\n', code['frag'])\n\n    def update_variables(self):\n        # Set any variables that have a new value\n        logger.debug(\"Apply variables:\")\n        for dep in sorted(self._variables, key=lambda d: self.compiler[d]):\n            name = self.compiler[dep]\n            state_id = dep.state_id\n            if self._variable_cache.get(dep, None) != state_id:\n                self[name] = dep.value\n                self._variable_cache[dep] = state_id\n                logger.debug(\"    %s = %s **\", name, dep.value)\n            else:\n                logger.debug(\"    %s = %s\", name, dep.value)\n\n        # Process any pending variables and discard anything else that is\n        # not active in the program (otherwise we get lots of warnings).\n        self._process_pending_variables()\n        logger.debug(\"Discarding unused variables before draw: %s\" % \n                     self._pending_variables.keys())\n        self._pending_variables = {}",
  "def __init__(self, vcode='', fcode='', gcode=None):\n        Program.__init__(self)\n\n        self.changed = EventEmitter(source=self, type='program_change')\n\n        # Cache state of Variables so we know which ones require update\n        self._variable_cache = WeakKeyDictionary()\n\n        # List of settable variables to be checked for value changes\n        self._variables = []\n\n        self._vert = MainFunction('vertex', '')\n        self._frag = MainFunction('fragment', '')\n        self._vert._dependents[self] = None\n        self._frag._dependents[self] = None\n        self._geom = None\n\n        self.vert = vcode\n        self.frag = fcode\n        self.geom = gcode",
  "def vert(self):\n        return self._vert",
  "def vert(self, vcode):\n        vcode = preprocess(vcode)\n        self._vert.code = vcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)",
  "def frag(self):\n        return self._frag",
  "def frag(self, fcode):\n        fcode = preprocess(fcode)\n        self._frag.code = fcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)",
  "def geom(self):\n        return self._geom",
  "def geom(self, gcode):\n        if gcode is None:\n            self._geom = None\n            return\n        gcode = preprocess(gcode)\n        if self._geom is None:\n            self._geom = MainFunction('geometry', '')\n            self._geom._dependents[self] = None\n        self._geom.code = gcode\n        self._need_build = True\n        self.changed(code_changed=True, value_changed=False)",
  "def _dep_changed(self, dep, code_changed=False, value_changed=False):\n        if code_changed and logger.level <= logging.DEBUG:\n            logger.debug(\"ModularProgram changed: %s   source=%s, values=%s\", \n                         self, code_changed, value_changed)\n            import traceback\n            traceback.print_stack()\n\n        if code_changed:\n            self._need_build = True\n        self.changed(code_changed=code_changed, \n                     value_changed=value_changed)",
  "def draw(self, *args, **kwargs):\n        self.build_if_needed()\n        self.update_variables()\n        Program.draw(self, *args, **kwargs)",
  "def build_if_needed(self):\n        \"\"\"Reset shader source if necesssary.\"\"\"\n        if self._need_build:\n            self._build()\n\n            # after recompile, we need to upload all variables again\n            # (some variables may have changed name)\n            self._variable_cache.clear()\n\n            # Collect a list of all settable variables\n            settable_vars = 'attribute', 'uniform', 'in'\n            deps = [d for d in self.vert.dependencies() if (\n                isinstance(d, Variable) and d.vtype in settable_vars)]\n            deps += [d for d in self.frag.dependencies() if (\n                isinstance(d, Variable) and d.vtype == 'uniform')]\n            if self.geom is not None:\n                deps += [d for d in self.geom.dependencies() if (\n                    isinstance(d, Variable) and d.vtype == 'uniform')]\n            self._variables = deps\n\n            self._need_build = False",
  "def _build(self):\n        logger.debug(\"Rebuild ModularProgram: %s\", self)\n        shaders = {'vert': self.vert, 'frag': self.frag}\n        if self.geom is not None:\n            shaders['geom'] = self.geom\n        self.compiler = Compiler(**shaders)\n        code = self.compiler.compile()\n\n        # Update shader code, but don't let the program update variables yet \n        code['update_variables'] = False\n        self.set_shaders(**code)\n\n        logger.debug('==== Vertex Shader ====\\n\\n%s\\n', code['vert'])\n        if 'geom' in code:\n            logger.debug('==== Geometry shader ====\\n\\n%s\\n', code['geom'])\n        logger.debug('==== Fragment shader ====\\n\\n%s\\n', code['frag'])",
  "def update_variables(self):\n        # Set any variables that have a new value\n        logger.debug(\"Apply variables:\")\n        for dep in sorted(self._variables, key=lambda d: self.compiler[d]):\n            name = self.compiler[dep]\n            state_id = dep.state_id\n            if self._variable_cache.get(dep, None) != state_id:\n                self[name] = dep.value\n                self._variable_cache[dep] = state_id\n                logger.debug(\"    %s = %s **\", name, dep.value)\n            else:\n                logger.debug(\"    %s = %s\", name, dep.value)\n\n        # Process any pending variables and discard anything else that is\n        # not active in the program (otherwise we get lots of warnings).\n        self._process_pending_variables()\n        logger.debug(\"Discarding unused variables before draw: %s\" % \n                     self._pending_variables.keys())\n        self._pending_variables = {}",
  "class ShaderObject(object):\n    \"\"\"Base class for all objects that may be included in a GLSL program\n    (Functions, Variables, Expressions).\n\n    Shader objects have a *definition* that defines the object in GLSL, an\n    *expression* that is used to reference the object, and a set of\n    *dependencies* that must be declared before the object is used.\n\n    Dependencies are tracked hierarchically such that changes to any object\n    will be propagated up the dependency hierarchy to trigger a recompile.\n    \"\"\"\n\n    @classmethod\n    def create(self, obj, ref=None):\n        \"\"\"Convert *obj* to a new ShaderObject. If the output is a Variable\n        with no name, then set its name using *ref*.\n        \"\"\"\n        if isinstance(ref, Variable):\n            ref = ref.name\n        elif isinstance(ref, str) and ref.startswith('gl_'):\n            # gl_ names not allowed for variables\n            ref = ref[3:].lower()\n\n        # Allow any type of object to be converted to ShaderObject if it\n        # provides a magic method:\n        if hasattr(obj, '_shader_object'):\n            obj = obj._shader_object()\n\n        if isinstance(obj, ShaderObject):\n            if isinstance(obj, Variable) and obj.name is None:\n                obj.name = ref\n        elif isinstance(obj, str):\n            obj = TextExpression(obj)\n        else:\n            obj = Variable(ref, obj)\n            # Try prepending the name to indicate attribute, uniform, varying\n            if obj.vtype and obj.vtype[0] in 'auv':\n                obj.name = obj.vtype[0] + '_' + obj.name\n\n        return obj\n\n    def __init__(self):\n        # objects that must be declared before this object's definition.\n        # {obj: refcount}\n        self._deps = OrderedDict()  # OrderedDict for consistent code output\n\n        # Objects that depend on this one will be informed of changes.\n        self._dependents = WeakKeyDictionary()\n\n    @property\n    def name(self):\n        \"\"\"The name of this shader object.\"\"\"\n        return None\n\n    @property\n    def version_pragma(self):\n        \"\"\"Return version number and extra qualifiers from pragma if present.\"\"\"\n        return None\n\n    def definition(self, obj_names, version, shader):\n        \"\"\"Return the GLSL definition for this object. Use *obj_names* to\n        determine the names of dependencies, and *version* (number, qualifier)\n        to adjust code output.\n        \"\"\"\n        return None\n\n    def expression(self, obj_names):\n        \"\"\"Return the GLSL expression used to reference this object inline.\"\"\"\n        return obj_names[self]\n\n    def dependencies(self, sort=False):\n        \"\"\"Return all dependencies required to use this object. The last item\n        in the list is *self*.\n        \"\"\"\n        alldeps = []\n        if sort:\n            def key(obj):\n                # sort deps such that we get functions, variables, self.\n                if not isinstance(obj, Variable):\n                    return (0, 0)\n                else:\n                    return (1, obj.vtype)\n\n            deps = sorted(self._deps, key=key)\n        else:\n            deps = self._deps\n\n        for dep in deps:\n            alldeps.extend(dep.dependencies(sort=sort))\n        alldeps.append(self)\n        return alldeps\n\n    def static_names(self):\n        \"\"\"Return a list of names that are declared in this object's\n        definition (not including the name of the object itself).\n\n        These names will be reserved by the compiler when automatically\n        determining object names.\n        \"\"\"\n        return []\n\n    def _add_dep(self, dep):\n        \"\"\"Increment the reference count for *dep*. If this is a new\n        dependency, then connect to its *changed* event.\n        \"\"\"\n        if dep in self._deps:\n            self._deps[dep] += 1\n        else:\n            self._deps[dep] = 1\n            dep._dependents[self] = None\n\n    def _remove_dep(self, dep):\n        \"\"\"Decrement the reference count for *dep*. If the reference count\n        reaches 0, then the dependency is removed and its *changed* event is\n        disconnected.\n        \"\"\"\n        refcount = self._deps[dep]\n        if refcount == 1:\n            self._deps.pop(dep)\n            dep._dependents.pop(self)\n        else:\n            self._deps[dep] -= 1\n\n    def _dep_changed(self, dep, code_changed=False, value_changed=False):\n        \"\"\"Called when a dependency's expression has changed.\"\"\"\n        self.changed(code_changed, value_changed)\n\n    def changed(self, code_changed=False, value_changed=False):\n        \"\"\"Inform dependents that this shaderobject has changed.\"\"\"\n        for d in self._dependents:\n            d._dep_changed(self, code_changed=code_changed,\n                           value_changed=value_changed)\n\n    def compile(self):\n        \"\"\"Return a compilation of this object and its dependencies.\n\n        Note: this is mainly for debugging purposes; the names in this code\n        are not guaranteed to match names in any other compilations. Use\n        Compiler directly to ensure consistent naming across multiple objects.\n        \"\"\"\n        compiler = Compiler(obj=self)\n        return compiler.compile()['obj']\n\n    def __repr__(self):\n        if self.name is not None:\n            return '<%s \"%s\" at 0x%x>' % (self.__class__.__name__,\n                                          self.name, id(self))\n        else:\n            return '<%s at 0x%x>' % (self.__class__.__name__, id(self))",
  "def create(self, obj, ref=None):\n        \"\"\"Convert *obj* to a new ShaderObject. If the output is a Variable\n        with no name, then set its name using *ref*.\n        \"\"\"\n        if isinstance(ref, Variable):\n            ref = ref.name\n        elif isinstance(ref, str) and ref.startswith('gl_'):\n            # gl_ names not allowed for variables\n            ref = ref[3:].lower()\n\n        # Allow any type of object to be converted to ShaderObject if it\n        # provides a magic method:\n        if hasattr(obj, '_shader_object'):\n            obj = obj._shader_object()\n\n        if isinstance(obj, ShaderObject):\n            if isinstance(obj, Variable) and obj.name is None:\n                obj.name = ref\n        elif isinstance(obj, str):\n            obj = TextExpression(obj)\n        else:\n            obj = Variable(ref, obj)\n            # Try prepending the name to indicate attribute, uniform, varying\n            if obj.vtype and obj.vtype[0] in 'auv':\n                obj.name = obj.vtype[0] + '_' + obj.name\n\n        return obj",
  "def __init__(self):\n        # objects that must be declared before this object's definition.\n        # {obj: refcount}\n        self._deps = OrderedDict()  # OrderedDict for consistent code output\n\n        # Objects that depend on this one will be informed of changes.\n        self._dependents = WeakKeyDictionary()",
  "def name(self):\n        \"\"\"The name of this shader object.\"\"\"\n        return None",
  "def version_pragma(self):\n        \"\"\"Return version number and extra qualifiers from pragma if present.\"\"\"\n        return None",
  "def definition(self, obj_names, version, shader):\n        \"\"\"Return the GLSL definition for this object. Use *obj_names* to\n        determine the names of dependencies, and *version* (number, qualifier)\n        to adjust code output.\n        \"\"\"\n        return None",
  "def expression(self, obj_names):\n        \"\"\"Return the GLSL expression used to reference this object inline.\"\"\"\n        return obj_names[self]",
  "def dependencies(self, sort=False):\n        \"\"\"Return all dependencies required to use this object. The last item\n        in the list is *self*.\n        \"\"\"\n        alldeps = []\n        if sort:\n            def key(obj):\n                # sort deps such that we get functions, variables, self.\n                if not isinstance(obj, Variable):\n                    return (0, 0)\n                else:\n                    return (1, obj.vtype)\n\n            deps = sorted(self._deps, key=key)\n        else:\n            deps = self._deps\n\n        for dep in deps:\n            alldeps.extend(dep.dependencies(sort=sort))\n        alldeps.append(self)\n        return alldeps",
  "def static_names(self):\n        \"\"\"Return a list of names that are declared in this object's\n        definition (not including the name of the object itself).\n\n        These names will be reserved by the compiler when automatically\n        determining object names.\n        \"\"\"\n        return []",
  "def _add_dep(self, dep):\n        \"\"\"Increment the reference count for *dep*. If this is a new\n        dependency, then connect to its *changed* event.\n        \"\"\"\n        if dep in self._deps:\n            self._deps[dep] += 1\n        else:\n            self._deps[dep] = 1\n            dep._dependents[self] = None",
  "def _remove_dep(self, dep):\n        \"\"\"Decrement the reference count for *dep*. If the reference count\n        reaches 0, then the dependency is removed and its *changed* event is\n        disconnected.\n        \"\"\"\n        refcount = self._deps[dep]\n        if refcount == 1:\n            self._deps.pop(dep)\n            dep._dependents.pop(self)\n        else:\n            self._deps[dep] -= 1",
  "def _dep_changed(self, dep, code_changed=False, value_changed=False):\n        \"\"\"Called when a dependency's expression has changed.\"\"\"\n        self.changed(code_changed, value_changed)",
  "def changed(self, code_changed=False, value_changed=False):\n        \"\"\"Inform dependents that this shaderobject has changed.\"\"\"\n        for d in self._dependents:\n            d._dep_changed(self, code_changed=code_changed,\n                           value_changed=value_changed)",
  "def compile(self):\n        \"\"\"Return a compilation of this object and its dependencies.\n\n        Note: this is mainly for debugging purposes; the names in this code\n        are not guaranteed to match names in any other compilations. Use\n        Compiler directly to ensure consistent naming across multiple objects.\n        \"\"\"\n        compiler = Compiler(obj=self)\n        return compiler.compile()['obj']",
  "def __repr__(self):\n        if self.name is not None:\n            return '<%s \"%s\" at 0x%x>' % (self.__class__.__name__,\n                                          self.name, id(self))\n        else:\n            return '<%s at 0x%x>' % (self.__class__.__name__, id(self))",
  "def key(obj):\n                # sort deps such that we get functions, variables, self.\n                if not isinstance(obj, Variable):\n                    return (0, 0)\n                else:\n                    return (1, obj.vtype)",
  "class Compiler(object):\n    \"\"\"\n    Compiler is used to convert Function and Variable instances into\n    ready-to-use GLSL code. This class handles name mangling to ensure that\n    there are no name collisions amongst global objects. The final name of\n    each object may be retrieved using ``Compiler.__getitem__(obj)``.\n\n    Accepts multiple root Functions as keyword arguments. ``compile()`` then\n    returns a dict of GLSL strings with the same keys.\n\n    Example::\n\n        # initialize with two main functions\n        compiler = Compiler(vert=v_func, frag=f_func)\n\n        # compile and extract shaders\n        code = compiler.compile()\n        v_code = code['vert']\n        f_code = code['frag']\n\n        # look up name of some object\n        name = compiler[obj]\n\n    \"\"\"\n\n    def __init__(self, namespace=None, **shaders):\n        # cache of compilation results for each function and variable\n        if namespace is None:\n            namespace = {}\n        self._object_names = namespace  # {object: name}\n        self.shaders = shaders\n\n    def __getitem__(self, item):\n        \"\"\"Return the name of the specified object, if it has been assigned one.\"\"\"\n        return self._object_names[item]\n\n    def compile(self, pretty=True):\n        \"\"\"Compile all code and return a dict {name: code} where the keys\n        are determined by the keyword arguments passed to __init__().\n\n        Parameters\n        ----------\n        pretty : bool\n            If True, use a slower method to mangle object names. This produces\n            GLSL that is more readable.\n            If False, then the output is mostly unreadable GLSL, but is about\n            10x faster to compile.\n        \"\"\"\n        # Authoritative mapping of {obj: name}\n        self._object_names = {}\n\n        #\n        # 1. collect list of dependencies for each shader\n        #\n\n        # maps {shader_name: [deps]}\n        self._shader_deps = {}\n\n        for shader_name, shader in self.shaders.items():\n            this_shader_deps = []\n            self._shader_deps[shader_name] = this_shader_deps\n            dep_set = set()\n\n            for dep in shader.dependencies(sort=True):\n                # visit each object no more than once per shader\n                if dep.name is None or dep in dep_set:\n                    continue\n                this_shader_deps.append(dep)\n                dep_set.add(dep)\n\n        #\n        # 2. Assign names to all objects.\n        #\n        if pretty:\n            self._rename_objects_pretty()\n        else:\n            self._rename_objects_fast()\n\n        #\n        # 3. Now we have a complete namespace; concatenate all definitions\n        # together in topological order.\n        #\n        compiled = {}\n        obj_names = self._object_names\n\n        for shader_name, shader in self.shaders.items():\n            code = []\n            version = shader.version_pragma\n            for dep in self._shader_deps[shader_name]:\n                dep_code = dep.definition(obj_names, version, shader)\n                if dep_code is not None:\n                    code.append(dep_code)\n\n            if version is not None:\n                code.insert(0, '#version %s %s' % version)\n\n            compiled[shader_name] = '\\n'.join(code)\n\n        self.code = compiled\n        return compiled\n\n    def _rename_objects_fast(self):\n        \"\"\"Rename all objects quickly to guaranteed-unique names using the\n        id() of each object.\n\n        This produces mostly unreadable GLSL, but is about 10x faster to\n        compile.\n        \"\"\"\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                name = dep.name\n                if name != 'main':\n                    ext = '_%x' % id(dep)\n                    name = name[:32-len(ext)] + ext\n                self._object_names[dep] = name\n\n    def _rename_objects_pretty(self):\n        \"\"\"Rename all objects like \"name_1\" to avoid conflicts. Objects are\n        only renamed if necessary.\n\n        This method produces more readable GLSL, but is rather slow.\n        \"\"\"\n        #\n        # 1. For each object, add its static names to the global namespace\n        #    and make a list of the shaders used by the object.\n        #\n\n        # {name: obj} mapping for finding unique names\n        # initialize with reserved keywords.\n        self._global_ns = dict([(kwd, None) for kwd in gloo.util.KEYWORDS])\n        # functions are local per-shader\n        self._shader_ns = dict([(shader, {}) for shader in self.shaders])\n\n        # for each object, keep a list of shaders the object appears in\n        obj_shaders = {}\n\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                # Add static names to namespace\n                for name in dep.static_names():\n                    self._global_ns[name] = None\n\n                obj_shaders.setdefault(dep, []).append(shader_name)\n\n        #\n        # 2. Assign new object names\n        #\n        name_index = {}\n        for obj, shaders in obj_shaders.items():\n            name = obj.name\n            if self._name_available(obj, name, shaders):\n                # hooray, we get to keep this name\n                self._assign_name(obj, name, shaders)\n            else:\n                # boo, find a new name\n                while True:\n                    index = name_index.get(name, 0) + 1\n                    name_index[name] = index\n                    ext = '_%d' % index\n                    new_name = name[:32-len(ext)] + ext\n                    if self._name_available(obj, new_name, shaders):\n                        self._assign_name(obj, new_name, shaders)\n                        break\n\n    def _is_global(self, obj):\n        \"\"\"Return True if *obj* should be declared in the global namespace.\n\n        Some objects need to be declared only in per-shader namespaces:\n        functions, static variables, and const variables may all be given\n        different definitions in each shader.\n        \"\"\"\n        # todo: right now we assume all Variables are global, and all\n        # Functions are local. Is this actually correct? Are there any\n        # global functions? Are there any local variables?\n        from .variable import Variable\n        return isinstance(obj, Variable)\n\n    def _name_available(self, obj, name, shaders):\n        \"\"\"Return True if *name* is available for *obj* in *shaders*.\"\"\"\n        if name in self._global_ns:\n            return False\n        shaders = self.shaders if self._is_global(obj) else shaders\n        for shader in shaders:\n            if name in self._shader_ns[shader]:\n                return False\n        return True\n\n    def _assign_name(self, obj, name, shaders):\n        \"\"\"Assign *name* to *obj* in *shaders*.\"\"\"\n        if self._is_global(obj):\n            assert name not in self._global_ns\n            self._global_ns[name] = obj\n        else:\n            for shader in shaders:\n                ns = self._shader_ns[shader]\n                assert name not in ns\n                ns[name] = obj\n        self._object_names[obj] = name",
  "def __init__(self, namespace=None, **shaders):\n        # cache of compilation results for each function and variable\n        if namespace is None:\n            namespace = {}\n        self._object_names = namespace  # {object: name}\n        self.shaders = shaders",
  "def __getitem__(self, item):\n        \"\"\"Return the name of the specified object, if it has been assigned one.\"\"\"\n        return self._object_names[item]",
  "def compile(self, pretty=True):\n        \"\"\"Compile all code and return a dict {name: code} where the keys\n        are determined by the keyword arguments passed to __init__().\n\n        Parameters\n        ----------\n        pretty : bool\n            If True, use a slower method to mangle object names. This produces\n            GLSL that is more readable.\n            If False, then the output is mostly unreadable GLSL, but is about\n            10x faster to compile.\n        \"\"\"\n        # Authoritative mapping of {obj: name}\n        self._object_names = {}\n\n        #\n        # 1. collect list of dependencies for each shader\n        #\n\n        # maps {shader_name: [deps]}\n        self._shader_deps = {}\n\n        for shader_name, shader in self.shaders.items():\n            this_shader_deps = []\n            self._shader_deps[shader_name] = this_shader_deps\n            dep_set = set()\n\n            for dep in shader.dependencies(sort=True):\n                # visit each object no more than once per shader\n                if dep.name is None or dep in dep_set:\n                    continue\n                this_shader_deps.append(dep)\n                dep_set.add(dep)\n\n        #\n        # 2. Assign names to all objects.\n        #\n        if pretty:\n            self._rename_objects_pretty()\n        else:\n            self._rename_objects_fast()\n\n        #\n        # 3. Now we have a complete namespace; concatenate all definitions\n        # together in topological order.\n        #\n        compiled = {}\n        obj_names = self._object_names\n\n        for shader_name, shader in self.shaders.items():\n            code = []\n            version = shader.version_pragma\n            for dep in self._shader_deps[shader_name]:\n                dep_code = dep.definition(obj_names, version, shader)\n                if dep_code is not None:\n                    code.append(dep_code)\n\n            if version is not None:\n                code.insert(0, '#version %s %s' % version)\n\n            compiled[shader_name] = '\\n'.join(code)\n\n        self.code = compiled\n        return compiled",
  "def _rename_objects_fast(self):\n        \"\"\"Rename all objects quickly to guaranteed-unique names using the\n        id() of each object.\n\n        This produces mostly unreadable GLSL, but is about 10x faster to\n        compile.\n        \"\"\"\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                name = dep.name\n                if name != 'main':\n                    ext = '_%x' % id(dep)\n                    name = name[:32-len(ext)] + ext\n                self._object_names[dep] = name",
  "def _rename_objects_pretty(self):\n        \"\"\"Rename all objects like \"name_1\" to avoid conflicts. Objects are\n        only renamed if necessary.\n\n        This method produces more readable GLSL, but is rather slow.\n        \"\"\"\n        #\n        # 1. For each object, add its static names to the global namespace\n        #    and make a list of the shaders used by the object.\n        #\n\n        # {name: obj} mapping for finding unique names\n        # initialize with reserved keywords.\n        self._global_ns = dict([(kwd, None) for kwd in gloo.util.KEYWORDS])\n        # functions are local per-shader\n        self._shader_ns = dict([(shader, {}) for shader in self.shaders])\n\n        # for each object, keep a list of shaders the object appears in\n        obj_shaders = {}\n\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                # Add static names to namespace\n                for name in dep.static_names():\n                    self._global_ns[name] = None\n\n                obj_shaders.setdefault(dep, []).append(shader_name)\n\n        #\n        # 2. Assign new object names\n        #\n        name_index = {}\n        for obj, shaders in obj_shaders.items():\n            name = obj.name\n            if self._name_available(obj, name, shaders):\n                # hooray, we get to keep this name\n                self._assign_name(obj, name, shaders)\n            else:\n                # boo, find a new name\n                while True:\n                    index = name_index.get(name, 0) + 1\n                    name_index[name] = index\n                    ext = '_%d' % index\n                    new_name = name[:32-len(ext)] + ext\n                    if self._name_available(obj, new_name, shaders):\n                        self._assign_name(obj, new_name, shaders)\n                        break",
  "def _is_global(self, obj):\n        \"\"\"Return True if *obj* should be declared in the global namespace.\n\n        Some objects need to be declared only in per-shader namespaces:\n        functions, static variables, and const variables may all be given\n        different definitions in each shader.\n        \"\"\"\n        # todo: right now we assume all Variables are global, and all\n        # Functions are local. Is this actually correct? Are there any\n        # global functions? Are there any local variables?\n        from .variable import Variable\n        return isinstance(obj, Variable)",
  "def _name_available(self, obj, name, shaders):\n        \"\"\"Return True if *name* is available for *obj* in *shaders*.\"\"\"\n        if name in self._global_ns:\n            return False\n        shaders = self.shaders if self._is_global(obj) else shaders\n        for shader in shaders:\n            if name in self._shader_ns[shader]:\n                return False\n        return True",
  "def _assign_name(self, obj, name, shaders):\n        \"\"\"Assign *name* to *obj* in *shaders*.\"\"\"\n        if self._is_global(obj):\n            assert name not in self._global_ns\n            self._global_ns[name] = obj\n        else:\n            for shader in shaders:\n                ns = self._shader_ns[shader]\n                assert name not in ns\n                ns[name] = obj\n        self._object_names[obj] = name",
  "class MultiProgram(object):\n    \"\"\"A collection of ModularPrograms that emulates the API of a single\n    ModularProgram. \n\n    A single Visual is often drawn in many different ways--viewed under\n    different transforms, with different clipping boundaries, or with different\n    colors as in picking and anaglyph stereo. Each draw may require a different\n    program. To simplify this process, MultiProgram exposes an API that looks\n    very much like a single ModularProgram, but internally manages many\n    programs.\n    \"\"\"\n\n    def __init__(self, vcode='', fcode='', gcode=None):\n        self._vcode = vcode\n        self._fcode = fcode\n        self._gcode = gcode\n        self._programs = weakref.WeakValueDictionary()\n        self._set_items = {}\n        self._next_prog_id = 0\n        self._vert = MultiShader(self, 'vert')\n        self._frag = MultiShader(self, 'frag')\n        self._geom = None if gcode is None else MultiShader(self, 'geom')\n\n    def add_program(self, name=None):\n        \"\"\"Create a program and add it to this MultiProgram.\n\n        It is the caller's responsibility to keep a reference to the returned \n        program.\n\n        The *name* must be unique, but is otherwise arbitrary and used for \n        debugging purposes.\n        \"\"\"\n        if name is None:\n            name = 'program' + str(self._next_prog_id)\n            self._next_prog_id += 1\n\n        if name in self._programs:\n            raise KeyError(\"Program named '%s' already exists.\" % name)\n\n        # create a program and update it to look like the rest\n        prog = ModularProgram(self._vcode, self._fcode, self._gcode)\n        for key, val in self._set_items.items():\n            prog[key] = val\n        self.frag._new_program(prog)\n        self.vert._new_program(prog)\n        if self._geom is not None:\n            self.geom._new_program(prog)\n\n        self._programs[name] = prog\n        return prog\n\n    @property\n    def vert(self):\n        \"\"\"A wrapper around all vertex shaders contained in this MultiProgram.\"\"\"\n        return self._vert\n\n    @vert.setter\n    def vert(self, code):\n        self._vcode = code\n        for p in self._programs.values():\n            p.vert = code\n\n    @property\n    def frag(self):\n        \"\"\"A wrapper around all fragment shaders contained in this MultiProgram.\"\"\"\n        return self._frag\n\n    @frag.setter\n    def frag(self, code):\n        self._fcode = code\n        for p in self._programs.values():\n            p.frag = code\n\n    @property\n    def geom(self):\n        \"\"\"A wrapper around all geometry shaders contained in this MultiProgram.\"\"\"\n        return self._geom\n\n    @geom.setter\n    def geom(self, code):\n        self._gcode = code\n        if self._geom is None:\n            self._geom = MultiShader(self, 'geom')\n        for p in self._programs.values():\n            p.geom = code\n\n    def __contains__(self, key):\n        return any(key in p for p in self._programs.values())\n\n    def __getitem__(self, key):\n        return self._set_items[key]\n\n    def __setitem__(self, key, value):\n        self._set_items[key] = value\n        for program in self._programs.values():\n            program[key] = value\n\n    def __iter__(self):\n        for p in self._programs.values():\n            yield p\n\n    def bind(self, data):\n        for name in data.dtype.names:\n            self[name] = data[name]",
  "class MultiShader(object):\n    \"\"\"Emulates the API of a MainFunction while wrapping all vertex or fragment\n    shaders in a MultiProgram.\n\n    Example::\n\n        mp = MultiProgram(vert, frag)\n        mp.add_program('p1')\n        mp.add_program('p2')\n\n        # applies to all programs\n        mp.vert['u_scale'] = (1, 2)\n\n        # applies to one program\n        mp.get_program('p1').frag['u_color'] = (1, 1, 1, 1)  \n    \"\"\"\n\n    def __init__(self, program, shader):\n        self._program = program\n        self._shader = shader\n        self._set_items = {}\n\n    def __getitem__(self, key):\n        return self._set_items[key]\n\n    def __setitem__(self, key, value):\n        self._set_items[key] = value\n        for p in self._program._programs.values():\n            getattr(p, self._shader)[key] = value\n\n    def _new_program(self, p):\n        \"\"\"New program was added to the multiprogram; update items in the shader.\"\"\"\n        for k, v in self._set_items.items():\n            getattr(p, self._shader)[k] = v",
  "def __init__(self, vcode='', fcode='', gcode=None):\n        self._vcode = vcode\n        self._fcode = fcode\n        self._gcode = gcode\n        self._programs = weakref.WeakValueDictionary()\n        self._set_items = {}\n        self._next_prog_id = 0\n        self._vert = MultiShader(self, 'vert')\n        self._frag = MultiShader(self, 'frag')\n        self._geom = None if gcode is None else MultiShader(self, 'geom')",
  "def add_program(self, name=None):\n        \"\"\"Create a program and add it to this MultiProgram.\n\n        It is the caller's responsibility to keep a reference to the returned \n        program.\n\n        The *name* must be unique, but is otherwise arbitrary and used for \n        debugging purposes.\n        \"\"\"\n        if name is None:\n            name = 'program' + str(self._next_prog_id)\n            self._next_prog_id += 1\n\n        if name in self._programs:\n            raise KeyError(\"Program named '%s' already exists.\" % name)\n\n        # create a program and update it to look like the rest\n        prog = ModularProgram(self._vcode, self._fcode, self._gcode)\n        for key, val in self._set_items.items():\n            prog[key] = val\n        self.frag._new_program(prog)\n        self.vert._new_program(prog)\n        if self._geom is not None:\n            self.geom._new_program(prog)\n\n        self._programs[name] = prog\n        return prog",
  "def vert(self):\n        \"\"\"A wrapper around all vertex shaders contained in this MultiProgram.\"\"\"\n        return self._vert",
  "def vert(self, code):\n        self._vcode = code\n        for p in self._programs.values():\n            p.vert = code",
  "def frag(self):\n        \"\"\"A wrapper around all fragment shaders contained in this MultiProgram.\"\"\"\n        return self._frag",
  "def frag(self, code):\n        self._fcode = code\n        for p in self._programs.values():\n            p.frag = code",
  "def geom(self):\n        \"\"\"A wrapper around all geometry shaders contained in this MultiProgram.\"\"\"\n        return self._geom",
  "def geom(self, code):\n        self._gcode = code\n        if self._geom is None:\n            self._geom = MultiShader(self, 'geom')\n        for p in self._programs.values():\n            p.geom = code",
  "def __contains__(self, key):\n        return any(key in p for p in self._programs.values())",
  "def __getitem__(self, key):\n        return self._set_items[key]",
  "def __setitem__(self, key, value):\n        self._set_items[key] = value\n        for program in self._programs.values():\n            program[key] = value",
  "def __iter__(self):\n        for p in self._programs.values():\n            yield p",
  "def bind(self, data):\n        for name in data.dtype.names:\n            self[name] = data[name]",
  "def __init__(self, program, shader):\n        self._program = program\n        self._shader = shader\n        self._set_items = {}",
  "def __getitem__(self, key):\n        return self._set_items[key]",
  "def __setitem__(self, key, value):\n        self._set_items[key] = value\n        for p in self._program._programs.values():\n            getattr(p, self._shader)[key] = value",
  "def _new_program(self, p):\n        \"\"\"New program was added to the multiprogram; update items in the shader.\"\"\"\n        for k, v in self._set_items.items():\n            getattr(p, self._shader)[k] = v",
  "class Function(ShaderObject):\n    \"\"\"Representation of a GLSL function\n\n    Objects of this class can be used for re-using and composing GLSL\n    snippets. Each Function consists of a GLSL snippet in the form of\n    a function. The code may have template variables that start with\n    the dollar sign. These stubs can be replaced with expressions using\n    the index operation. Expressions can be:\n\n    * plain text that is inserted verbatim in the code\n    * a Function object or a call to a funcion\n    * a Variable (or Varying) object\n    * float, int, tuple are automatically turned into a uniform Variable\n    * a VertexBuffer is automatically turned into an attribute Variable\n\n    All functions have implicit \"$pre\" and \"$post\" placeholders that may be\n    used to insert code at the beginning and end of the function.\n\n    Examples\n    --------\n    This example shows the basic usage of the Function class::\n\n        vert_code_template = Function('''\n            void main() {\n            gl_Position = $pos;\n            gl_Position.x += $xoffset;\n            gl_Position.y += $yoffset;\n        }''')\n\n        scale_transform = Function('''\n        vec4 transform_scale(vec4 pos){\n            return pos * $scale;\n        }''')\n\n        # If you get the function from a snippet collection, always\n        # create new Function objects to ensure they are 'fresh'.\n        vert_code = Function(vert_code_template)\n        trans1 = Function(scale_transform)\n        trans2 = Function(scale_transform)  # trans2 != trans1\n\n        # Three ways to assign to template variables:\n        #\n        # 1) Assign verbatim code\n        vert_code['xoffset'] = '(3.0 / 3.1415)'\n\n        # 2) Assign a value (this creates a new uniform or attribute)\n        vert_code['yoffset'] = 5.0\n\n        # 3) Assign a function call expression\n        pos_var = Variable('attribute vec4 a_position')\n        vert_code['pos'] = trans1(trans2(pos_var))\n\n        # Transforms also need their variables set\n        trans1['scale'] = 0.5\n        trans2['scale'] = (1.0, 0.5, 1.0, 1.0)\n\n        # You can actually change any code you want, but use this with care!\n        vert_code.replace('gl_Position.y', 'gl_Position.z')\n\n        # Finally, you can set special variables explicitly. This generates\n        # a new statement at the end of the vert_code function.\n        vert_code['gl_PointSize'] = '10.'\n\n\n    If we use ``vert_code.compile()`` we get::\n\n        attribute vec4 a_position;\n        uniform float u_yoffset;\n        uniform float u_scale_1;\n        uniform vec4 u_scale_2;\n        uniform float u_pointsize;\n\n        vec4 transform_scale_1(vec4 pos){\n            return pos * u_scale_1;\n        }\n\n        vec4 transform_scale_2(vec4 pos){\n            return pos * u_scale_2;\n        }\n\n        void main() {\n            gl_Position = transform_scale_1(transform_scale_2(a_position));\n            gl_Position.x += (3.0 / 3.1415);\n            gl_Position.z += u_yoffset;\n\n            gl_PointSize = u_pointsize;\n        }\n\n    Note how the two scale function resulted in two different functions\n    and two uniforms for the scale factors.\n\n    Notes\n    -----\n\n    Function calls:\n\n    As can be seen above, the arguments with which a function is to be\n    called must be specified by calling the Function object. The\n    arguments can be any of the expressions mentioned earlier. If the\n    signature is already specified in the template code, that function\n    itself must be given.\n\n    ::\n\n        code = Function('''\n            void main() {\n                vec4 position = $pos;\n                gl_Position = $scale(position)\n            }\n        ''')\n\n        # Example of a function call with all possible three expressions\n        vert_code['pos'] = func1('3.0', 'uniform float u_param', func2())\n\n        # For scale, the sigfnature is already specified\n        code['scale'] = scale_func  # Must not specify args\n\n    Data for uniform and attribute variables:\n\n    To each variable a value can be associated. In fact, in most cases\n    the Function class is smart enough to be able to create a Variable\n    object if only the data is given.\n\n    ::\n\n        code['offset'] = Variable('uniform float offset')  # No data\n        code['offset'] = Variable('uniform float offset', 3.0)  # With data\n        code['offset'] = 3.0  # -> Uniform Variable\n        position['position'] = VertexBuffer()  # -> attribute Variable\n\n        # Updating variables\n        code['offset'].value = 4.0\n        position['position'].value.set_data(...)\n\n    \"\"\"\n\n    def __init__(self, code, dependencies=None):\n        super(Function, self).__init__()\n\n        # Add depencencies is given. This is to allow people to\n        # manually define deps for a function that they use.\n        if dependencies is not None:\n            for dep in dependencies:\n                self._add_dep(dep)\n\n        self.code = code\n\n        # Expressions replace template variables (also our dependencies)\n        self._expressions = OrderedDict()\n\n        # Verbatim string replacements\n        self._replacements = OrderedDict()\n\n        # Stuff to do at the end\n        self._assignments = OrderedDict()\n\n    def __setitem__(self, key, val):\n        \"\"\"Setting of replacements through a dict-like syntax.\n\n        Each replacement can be:\n        * verbatim code: ``fun1['foo'] = '3.14159'``\n        * a FunctionCall: ``fun1['foo'] = fun2()``\n        * a Variable: ``fun1['foo'] = Variable(...)`` (can be auto-generated)\n        \"\"\"\n        # Check the key. Must be Varying, 'gl_X' or a known template variable\n        if isinstance(key, Variable):\n            if key.vtype == 'varying':\n                if self.name != 'main':\n                    raise Exception(\"Varying assignment only alowed in 'main' \"\n                                    \"function.\")\n                storage = self._assignments\n            else:\n                raise TypeError(\"Variable assignment only allowed for \"\n                                \"varyings, not %s (in %s)\"\n                                % (key.vtype, self.name))\n        elif isinstance(key, str):\n            if any(map(key.startswith,\n                       ('gl_PointSize', 'gl_Position', 'gl_FragColor'))):\n                storage = self._assignments\n            elif key in self.template_vars or key in ('pre', 'post'):\n                storage = self._expressions\n            else:\n                raise KeyError('Invalid template variable %r' % key)\n        else:\n            raise TypeError('In `function[key]` key must be a string or '\n                            'varying.')\n\n        # If values already match, bail out now\n        if eq(storage.get(key), val):\n            return\n\n        # If we are only changing the value (and not the dtype) of a uniform,\n        # we can set that value and return immediately to avoid triggering a\n        # recompile.\n        if val is not None and not isinstance(val, Variable):\n            # We are setting a value. If there is already a variable set here,\n            # try just updating its value.\n            variable = storage.get(key, None)\n            if isinstance(variable, Variable):\n                if np.any(variable.value != val):\n                    variable.value = val\n                    self.changed(value_changed=True)\n                return\n\n            # Could not set variable.value directly; instead we will need\n            # to create a new ShaderObject\n            val = ShaderObject.create(val, ref=key)\n            if variable is val:\n                # This can happen if ShaderObject.create returns the same\n                # object (such as when setting a Transform).\n                return\n\n        # Remove old references, if any\n        oldval = storage.pop(key, None)\n        if oldval is not None:\n            for obj in (key, oldval):\n                if isinstance(obj, ShaderObject):\n                    self._remove_dep(obj)\n\n        # Add new references\n        if val is not None:\n            if isinstance(key, Varying):\n                # tell this varying to inherit properties from\n                # its source attribute / expression.\n                key.link(val)\n\n            # Store value and dependencies\n            storage[key] = val\n            for obj in (key, val):\n                if isinstance(obj, ShaderObject):\n                    self._add_dep(obj)\n\n        # In case of verbatim text, we might have added new template vars\n        if isinstance(val, TextExpression):\n            for var in parsing.find_template_variables(val.expression()):\n                if var not in self.template_vars:\n                    self.template_vars.add(var.lstrip('$'))\n\n        self.changed(code_changed=True, value_changed=True)\n        if logger.level <= logging.DEBUG:\n            import traceback\n            last = traceback.format_list(traceback.extract_stack()[-2:-1])\n            logger.debug(\"Assignment would trigger shader recompile:\\n\"\n                         \"Original: %r\\nReplacement: %r\\nSource: %s\",\n                         oldval, val, ''.join(last))\n\n    def __getitem__(self, key):\n        \"\"\"Return a reference to a program variable from this function.\n\n        This allows variables between functions to be linked together::\n\n            func1['var_name'] = func2['other_var_name']\n\n        In the example above, the two local variables would be assigned to the\n        same program variable whenever func1 and func2 are attached to the same\n        program.\n        \"\"\"\n        try:\n            return self._expressions[key]\n        except KeyError:\n            pass\n\n        try:\n            return self._assignments[key]\n        except KeyError:\n            pass\n\n        if key not in self.template_vars:\n            raise KeyError('Invalid template variable %r' % key)\n        else:\n            raise KeyError('No value known for key %r' % key)\n\n    def __call__(self, *args):\n        \"\"\"Set the signature for this function and return an FunctionCall\n        object. Each argument can be verbatim code or a FunctionCall object.\n        \"\"\"\n        return FunctionCall(self, args)\n\n    def __contains__(self, key):\n        return key in self.template_vars\n\n    # Public API methods\n\n    @property\n    def signature(self):\n        if self._signature is None:\n            try:\n                self._signature = parsing.parse_function_signature(self._code)\n            except Exception as err:\n                raise ValueError('Invalid code: ' + str(err))\n        return self._signature\n\n    @property\n    def name(self):\n        \"\"\"The function name. The name may be mangled in the final code\n        to avoid name clashes.\n        \"\"\"\n        return self.signature[0]\n\n    @property\n    def args(self):\n        \"\"\"\n        List of input arguments in the function signature::\n            [(arg_name, arg_type), ...]\n        \"\"\"\n        return self.signature[1]\n\n    @property\n    def rtype(self):\n        \"\"\"The return type of this function.\"\"\"\n        return self.signature[2]\n\n    @property\n    def code(self):\n        \"\"\"The template code used to generate the definition for this function.\"\"\"\n        return self._code\n\n    @code.setter\n    def code(self, code):\n        # Get and strip code\n        if isinstance(code, Function):\n            code = code._code\n        elif not isinstance(code, str):\n            raise ValueError('Function needs a string or Function; got %s.' %\n                             type(code))\n        self._code = self._clean_code(code)\n\n        # (name, args, rval)\n        self._signature = None\n\n        # $placeholders parsed from the code\n        self._template_vars = None\n\n        # Create static Variable instances for any global variables declared\n        # in the code\n        self._static_vars = None\n\n    @property\n    def template_vars(self):\n        if self._template_vars is None:\n            self._template_vars = self._parse_template_vars()\n        return self._template_vars\n\n    def static_names(self):\n        if self._static_vars is None:\n            self._static_vars = parsing.find_program_variables(self._code)\n        return list(self._static_vars.keys()) + [arg[0] for arg in self.args]\n\n    def replace(self, str1, str2):\n        \"\"\"Set verbatim code replacement\n\n        It is strongly recommended to use function['$foo'] = 'bar' where\n        possible because template variables are less likely to changed\n        than the code itself in future versions of vispy.\n\n        Parameters\n        ----------\n        str1 : str\n            String to replace\n        str2 : str\n            String to replace str1 with\n        \"\"\"\n        if str2 != self._replacements.get(str1, None):\n            self._replacements[str1] = str2\n            self.changed(code_changed=True)\n            # self._last_changed = time.time()\n\n    # Private methods\n\n    def _parse_template_vars(self):\n        \"\"\"Find all template variables in self._code, excluding the function name.\"\"\"\n        template_vars = set()\n        for var in parsing.find_template_variables(self._code):\n            var = var.lstrip('$')\n            if var == self.name:\n                continue\n            if var in ('pre', 'post'):\n                raise ValueError('GLSL uses reserved template variable $%s' %\n                                 var)\n            template_vars.add(var)\n        return template_vars\n\n    def _get_replaced_code(self, names, version, shader):\n        \"\"\"Return code, with new name, expressions, and replacements applied.\"\"\"\n        code = self._code\n\n        # Modify name\n        fname = names[self]\n        code = code.replace(\" \" + self.name + \"(\", \" \" + fname + \"(\")\n\n        # Apply string replacements first -- these may contain $placeholders\n        for key, val in self._replacements.items():\n            code = code.replace(key, val)\n\n        # Apply assignments to the end of the function\n\n        # Collect post lines\n        post_lines = []\n        for key, val in self._assignments.items():\n            if isinstance(key, Variable):\n                key = names[key]\n            if isinstance(val, ShaderObject):\n                val = val.expression(names)\n            line = '    %s = %s;' % (key, val)\n            post_lines.append(line)\n\n        # Add a default $post placeholder if needed\n        if 'post' in self._expressions:\n            post_lines.append('    $post')\n\n        # Apply placeholders for hooks\n        post_text = '\\n'.join(post_lines)\n        if post_text:\n            post_text = '\\n' + post_text + '\\n'\n        code = code.rpartition('}')\n        code = code[0] + post_text + code[1] + code[2]\n\n        # Add a default $pre placeholder if needed\n        if 'pre' in self._expressions:\n            m = re.search(fname + r'\\s*\\([^{]*\\)\\s*{', code)\n            if m is None:\n                raise RuntimeError(\"Cound not find beginning of function '%s'\"\n                                   % fname)\n            ind = m.span()[1]\n            code = code[:ind] + \"\\n    $pre\\n\" + code[ind:]\n\n        # Apply template variables\n        for key, val in self._expressions.items():\n            val = val.expression(names)\n            search = r'\\$' + key + r'($|[^a-zA-Z0-9_])'\n            code = re.sub(search, val+r'\\1', code)\n\n        # Done\n        if '$' in code:\n            v = parsing.find_template_variables(code)\n            logger.warning('Unsubstituted placeholders in code: %s\\n'\n                           '  replacements made: %s',\n                           v, list(self._expressions.keys()))\n\n        return code + '\\n'\n\n    def definition(self, names, version, shader):\n        return self._get_replaced_code(names, version, shader)\n\n    def expression(self, names):\n        return names[self]\n\n    def _clean_code(self, code):\n        \"\"\"Return *code* with indentation and leading/trailing blank lines removed.\"\"\"\n        lines = code.split(\"\\n\")\n        min_indent = 100\n        for line in lines:\n            if line.strip() != \"\":\n                indent = len(line) - len(line.lstrip())\n                min_indent = min(indent, min_indent)\n        if min_indent > 0:\n            lines = [line[min_indent:] for line in lines]\n        code = \"\\n\".join(lines)\n        return code\n\n    def __repr__(self):\n        try:\n            args = ', '.join([' '.join(arg) for arg in self.args])\n        except Exception:\n            return ('<%s (error parsing signature) at 0x%x>' %\n                    (self.__class__.__name__, id(self)))\n        return '<%s \"%s %s(%s)\" at 0x%x>' % (self.__class__.__name__,\n                                             self.rtype,\n                                             self.name,\n                                             args,\n                                             id(self))",
  "class MainFunction(Function):\n    \"\"\"Subclass of Function that allows multiple functions and variables to\n    be defined in a single code string. The code must contain a main() function\n    definition.\n    \"\"\"\n\n    def __init__(self, shader_type, *args, **kwargs):\n        self.shader_type = shader_type\n        self._chains = {}\n        Function.__init__(self, *args, **kwargs)\n\n    @property\n    def signature(self):\n        return ('main', [], 'void')\n\n    @property\n    def version_pragma(self):\n        \"\"\"Return version number and extra qualifiers from pragma if present.\"\"\"\n        m = re.search(parsing.re_version_pragma, self.code)\n        if m is None:\n            return None\n        return int(m.group(1)), m.group(2)\n\n    def definition(self, obj_names, version, shader):\n        code = Function.definition(self, obj_names, version, shader)\n        # strip out version pragma before returning code; this will be\n        # added to the final compiled code later.\n        code = re.sub(parsing.re_version_pragma, '', code)\n        return code\n\n    def static_names(self):\n        if self._static_vars is not None:\n            return self._static_vars\n\n        # parse static variables\n        names = Function.static_names(self)\n\n        # parse all function names + argument names\n        funcs = parsing.find_functions(self.code)\n        for f in funcs:\n            if f[0] == 'main':\n                continue\n            names.append(f[0])\n            for arg in f[1]:\n                names.append(arg[1])\n\n        self._static_vars = names\n        return names\n\n    def add_chain(self, var):\n        \"\"\"Create a new ChainFunction and attach to $var.\"\"\"\n        chain = FunctionChain(var, [])\n        self._chains[var] = chain\n        self[var] = chain\n\n    def add_callback(self, hook, func):\n        self._chains[hook].append(func)\n\n    def remove_callback(self, hook, func):\n        self._chains[hook].remove(func)",
  "class FunctionChain(Function):\n    \"\"\"Subclass that generates GLSL code to call Function list in order\n\n    Functions may be called independently, or composed such that the\n    output of each function provides the input to the next.\n\n    Parameters\n    ----------\n    name : str\n        The name of the generated function\n    funcs : list of Functions\n        The list of Functions that will be called by the generated GLSL code.\n\n    Examples\n    --------\n    This creates a function chain::\n\n        >>> func1 = Function('void my_func_1() {}')\n        >>> func2 = Function('void my_func_2() {}')\n        >>> chain = FunctionChain('my_func_chain', [func1, func2])\n\n    If *chain* is included in a ModularProgram, it will generate the following\n    output::\n\n        void my_func_1() {}\n        void my_func_2() {}\n\n        void my_func_chain() {\n            my_func_1();\n            my_func_2();\n        }\n\n    The return type of the generated function is the same as the return type\n    of the last function in the chain. Likewise, the arguments for the\n    generated function are the same as the first function in the chain.\n\n    If the return type is not 'void', then the return value of each function\n    will be used to supply the first input argument of the next function in\n    the chain. For example::\n\n        vec3 my_func_1(vec3 input) {return input + vec3(1, 0, 0);}\n        void my_func_2(vec3 input) {return input + vec3(0, 1, 0);}\n\n        vec3 my_func_chain(vec3 input) {\n            return my_func_2(my_func_1(input));\n        }\n    \"\"\"\n\n    def __init__(self, name=None, funcs=()):\n        # bypass Function.__init__ completely.\n        ShaderObject.__init__(self)\n        if not (name is None or isinstance(name, str)):\n            raise TypeError(\"Name argument must be string or None.\")\n        self._funcs = []\n        self._code = None\n        self._name = name or \"chain\"\n        self._args = []\n        self._rtype = 'void'\n        self.functions = funcs\n\n    @property\n    def functions(self):\n        return self._funcs[:]\n\n    @functions.setter\n    def functions(self, funcs):\n        while self._funcs:\n            self.remove(self._funcs[0], update=False)\n        for f in funcs:\n            self.append(f, update=False)\n        self._update()\n\n    @property\n    def signature(self):\n        return self._name, self._args, self._rtype\n\n    def _update(self):\n        funcs = self._funcs\n        if len(funcs) > 0:\n            self._rtype = funcs[-1].rtype\n            self._args = funcs[0].args[:]\n        else:\n            self._rtype = 'void'\n            self._args = []\n\n        self.changed(code_changed=True)\n\n    @property\n    def code(self):\n        # Code is generated at compile time; hopefully it is not requested\n        # before then..\n        return None\n\n    @code.setter\n    def code(self, c):\n        raise TypeError(\"Cannot set code property on FunctionChain.\")\n\n    @property\n    def template_vars(self):\n        return {}\n\n    def append(self, function, update=True):\n        \"\"\"Append a new function to the end of this chain.\"\"\"\n        self._funcs.append(function)\n        self._add_dep(function)\n        if update:\n            self._update()\n\n    def __setitem__(self, index, func):\n        self._remove_dep(self._funcs[index])\n        self._add_dep(func)\n        self._funcs[index] = func\n\n        self._update()\n\n    def __getitem__(self, k):\n        return self.functions[k]\n\n    def insert(self, index, function, update=True):\n        \"\"\"Insert a new function into the chain at *index*.\"\"\"\n        self._funcs.insert(index, function)\n        self._add_dep(function)\n        if update:\n            self._update()\n\n    def remove(self, function, update=True):\n        \"\"\"Remove a function from the chain.\"\"\"\n        self._funcs.remove(function)\n        self._remove_dep(function)\n        if update:\n            self._update()\n\n    def definition(self, obj_names, version, shader):\n        name = obj_names[self]\n\n        args = \", \".join([\"%s %s\" % arg for arg in self.args])\n        code = \"%s %s(%s) {\\n\" % (self.rtype, name, args)\n\n        result_index = 0\n        if len(self.args) == 0:\n            last_rtype = 'void'\n            last_result = ''\n        else:\n            last_rtype, last_result = self.args[0][:2]\n\n        for fn in self._funcs:\n            # Use previous return value as an argument to the next function\n            if last_rtype == 'void':\n                args = ''\n            else:\n                args = last_result\n                if len(fn.args) != 1 or last_rtype != fn.args[0][0]:\n                    raise Exception(\"Cannot chain output '%s' of function to \"\n                                    \"input of '%s'\" %\n                                    (last_rtype, fn.signature))\n            last_rtype = fn.rtype\n\n            # Store the return value of this function\n            if fn.rtype == 'void':\n                set_str = ''\n            else:\n                result_index += 1\n                result = 'result_%d' % result_index\n                set_str = '%s %s = ' % (fn.rtype, result)\n                last_result = result\n\n            code += \"    %s%s(%s);\\n\" % (set_str, obj_names[fn], args)\n\n        # return the last function's output\n        if self.rtype != 'void':\n            code += \"    return result_%d;\\n\" % result_index\n\n        code += \"}\\n\"\n        return code\n\n    def static_names(self):\n        return []\n\n    def __repr__(self):\n        fn = \",\\n                \".join(map(repr, self.functions))\n        return \"<FunctionChain [%s] at 0x%x>\" % (fn, id(self))",
  "class StatementList(ShaderObject):\n    \"\"\"Represents a list of statements.\"\"\"\n\n    def __init__(self):\n        self.items = {}\n        self.order = []\n        ShaderObject.__init__(self)\n\n    def add(self, item, position=5):\n        \"\"\"Add an item to the list unless it is already present.\n\n        If the item is an expression, then a semicolon will be appended to it\n        in the final compiled code.\n        \"\"\"\n        if item in self.items:\n            return\n        self.items[item] = position\n        self._add_dep(item)\n        self.order = None\n        self.changed(code_changed=True)\n\n    def remove(self, item):\n        \"\"\"Remove an item from the list.\"\"\"\n        self.items.pop(item)\n        self._remove_dep(item)\n        self.order = None\n        self.changed(code_changed=True)\n\n    def expression(self, obj_names):\n        if self.order is None:\n            self.order = list(self.items.items())\n            self.order.sort(key=lambda x: x[1])\n\n        code = \"\"\n        for item, pos in self.order:\n            code += item.expression(obj_names) + ';\\n'\n        return code",
  "def __init__(self, code, dependencies=None):\n        super(Function, self).__init__()\n\n        # Add depencencies is given. This is to allow people to\n        # manually define deps for a function that they use.\n        if dependencies is not None:\n            for dep in dependencies:\n                self._add_dep(dep)\n\n        self.code = code\n\n        # Expressions replace template variables (also our dependencies)\n        self._expressions = OrderedDict()\n\n        # Verbatim string replacements\n        self._replacements = OrderedDict()\n\n        # Stuff to do at the end\n        self._assignments = OrderedDict()",
  "def __setitem__(self, key, val):\n        \"\"\"Setting of replacements through a dict-like syntax.\n\n        Each replacement can be:\n        * verbatim code: ``fun1['foo'] = '3.14159'``\n        * a FunctionCall: ``fun1['foo'] = fun2()``\n        * a Variable: ``fun1['foo'] = Variable(...)`` (can be auto-generated)\n        \"\"\"\n        # Check the key. Must be Varying, 'gl_X' or a known template variable\n        if isinstance(key, Variable):\n            if key.vtype == 'varying':\n                if self.name != 'main':\n                    raise Exception(\"Varying assignment only alowed in 'main' \"\n                                    \"function.\")\n                storage = self._assignments\n            else:\n                raise TypeError(\"Variable assignment only allowed for \"\n                                \"varyings, not %s (in %s)\"\n                                % (key.vtype, self.name))\n        elif isinstance(key, str):\n            if any(map(key.startswith,\n                       ('gl_PointSize', 'gl_Position', 'gl_FragColor'))):\n                storage = self._assignments\n            elif key in self.template_vars or key in ('pre', 'post'):\n                storage = self._expressions\n            else:\n                raise KeyError('Invalid template variable %r' % key)\n        else:\n            raise TypeError('In `function[key]` key must be a string or '\n                            'varying.')\n\n        # If values already match, bail out now\n        if eq(storage.get(key), val):\n            return\n\n        # If we are only changing the value (and not the dtype) of a uniform,\n        # we can set that value and return immediately to avoid triggering a\n        # recompile.\n        if val is not None and not isinstance(val, Variable):\n            # We are setting a value. If there is already a variable set here,\n            # try just updating its value.\n            variable = storage.get(key, None)\n            if isinstance(variable, Variable):\n                if np.any(variable.value != val):\n                    variable.value = val\n                    self.changed(value_changed=True)\n                return\n\n            # Could not set variable.value directly; instead we will need\n            # to create a new ShaderObject\n            val = ShaderObject.create(val, ref=key)\n            if variable is val:\n                # This can happen if ShaderObject.create returns the same\n                # object (such as when setting a Transform).\n                return\n\n        # Remove old references, if any\n        oldval = storage.pop(key, None)\n        if oldval is not None:\n            for obj in (key, oldval):\n                if isinstance(obj, ShaderObject):\n                    self._remove_dep(obj)\n\n        # Add new references\n        if val is not None:\n            if isinstance(key, Varying):\n                # tell this varying to inherit properties from\n                # its source attribute / expression.\n                key.link(val)\n\n            # Store value and dependencies\n            storage[key] = val\n            for obj in (key, val):\n                if isinstance(obj, ShaderObject):\n                    self._add_dep(obj)\n\n        # In case of verbatim text, we might have added new template vars\n        if isinstance(val, TextExpression):\n            for var in parsing.find_template_variables(val.expression()):\n                if var not in self.template_vars:\n                    self.template_vars.add(var.lstrip('$'))\n\n        self.changed(code_changed=True, value_changed=True)\n        if logger.level <= logging.DEBUG:\n            import traceback\n            last = traceback.format_list(traceback.extract_stack()[-2:-1])\n            logger.debug(\"Assignment would trigger shader recompile:\\n\"\n                         \"Original: %r\\nReplacement: %r\\nSource: %s\",\n                         oldval, val, ''.join(last))",
  "def __getitem__(self, key):\n        \"\"\"Return a reference to a program variable from this function.\n\n        This allows variables between functions to be linked together::\n\n            func1['var_name'] = func2['other_var_name']\n\n        In the example above, the two local variables would be assigned to the\n        same program variable whenever func1 and func2 are attached to the same\n        program.\n        \"\"\"\n        try:\n            return self._expressions[key]\n        except KeyError:\n            pass\n\n        try:\n            return self._assignments[key]\n        except KeyError:\n            pass\n\n        if key not in self.template_vars:\n            raise KeyError('Invalid template variable %r' % key)\n        else:\n            raise KeyError('No value known for key %r' % key)",
  "def __call__(self, *args):\n        \"\"\"Set the signature for this function and return an FunctionCall\n        object. Each argument can be verbatim code or a FunctionCall object.\n        \"\"\"\n        return FunctionCall(self, args)",
  "def __contains__(self, key):\n        return key in self.template_vars",
  "def signature(self):\n        if self._signature is None:\n            try:\n                self._signature = parsing.parse_function_signature(self._code)\n            except Exception as err:\n                raise ValueError('Invalid code: ' + str(err))\n        return self._signature",
  "def name(self):\n        \"\"\"The function name. The name may be mangled in the final code\n        to avoid name clashes.\n        \"\"\"\n        return self.signature[0]",
  "def args(self):\n        \"\"\"\n        List of input arguments in the function signature::\n            [(arg_name, arg_type), ...]\n        \"\"\"\n        return self.signature[1]",
  "def rtype(self):\n        \"\"\"The return type of this function.\"\"\"\n        return self.signature[2]",
  "def code(self):\n        \"\"\"The template code used to generate the definition for this function.\"\"\"\n        return self._code",
  "def code(self, code):\n        # Get and strip code\n        if isinstance(code, Function):\n            code = code._code\n        elif not isinstance(code, str):\n            raise ValueError('Function needs a string or Function; got %s.' %\n                             type(code))\n        self._code = self._clean_code(code)\n\n        # (name, args, rval)\n        self._signature = None\n\n        # $placeholders parsed from the code\n        self._template_vars = None\n\n        # Create static Variable instances for any global variables declared\n        # in the code\n        self._static_vars = None",
  "def template_vars(self):\n        if self._template_vars is None:\n            self._template_vars = self._parse_template_vars()\n        return self._template_vars",
  "def static_names(self):\n        if self._static_vars is None:\n            self._static_vars = parsing.find_program_variables(self._code)\n        return list(self._static_vars.keys()) + [arg[0] for arg in self.args]",
  "def replace(self, str1, str2):\n        \"\"\"Set verbatim code replacement\n\n        It is strongly recommended to use function['$foo'] = 'bar' where\n        possible because template variables are less likely to changed\n        than the code itself in future versions of vispy.\n\n        Parameters\n        ----------\n        str1 : str\n            String to replace\n        str2 : str\n            String to replace str1 with\n        \"\"\"\n        if str2 != self._replacements.get(str1, None):\n            self._replacements[str1] = str2\n            self.changed(code_changed=True)",
  "def _parse_template_vars(self):\n        \"\"\"Find all template variables in self._code, excluding the function name.\"\"\"\n        template_vars = set()\n        for var in parsing.find_template_variables(self._code):\n            var = var.lstrip('$')\n            if var == self.name:\n                continue\n            if var in ('pre', 'post'):\n                raise ValueError('GLSL uses reserved template variable $%s' %\n                                 var)\n            template_vars.add(var)\n        return template_vars",
  "def _get_replaced_code(self, names, version, shader):\n        \"\"\"Return code, with new name, expressions, and replacements applied.\"\"\"\n        code = self._code\n\n        # Modify name\n        fname = names[self]\n        code = code.replace(\" \" + self.name + \"(\", \" \" + fname + \"(\")\n\n        # Apply string replacements first -- these may contain $placeholders\n        for key, val in self._replacements.items():\n            code = code.replace(key, val)\n\n        # Apply assignments to the end of the function\n\n        # Collect post lines\n        post_lines = []\n        for key, val in self._assignments.items():\n            if isinstance(key, Variable):\n                key = names[key]\n            if isinstance(val, ShaderObject):\n                val = val.expression(names)\n            line = '    %s = %s;' % (key, val)\n            post_lines.append(line)\n\n        # Add a default $post placeholder if needed\n        if 'post' in self._expressions:\n            post_lines.append('    $post')\n\n        # Apply placeholders for hooks\n        post_text = '\\n'.join(post_lines)\n        if post_text:\n            post_text = '\\n' + post_text + '\\n'\n        code = code.rpartition('}')\n        code = code[0] + post_text + code[1] + code[2]\n\n        # Add a default $pre placeholder if needed\n        if 'pre' in self._expressions:\n            m = re.search(fname + r'\\s*\\([^{]*\\)\\s*{', code)\n            if m is None:\n                raise RuntimeError(\"Cound not find beginning of function '%s'\"\n                                   % fname)\n            ind = m.span()[1]\n            code = code[:ind] + \"\\n    $pre\\n\" + code[ind:]\n\n        # Apply template variables\n        for key, val in self._expressions.items():\n            val = val.expression(names)\n            search = r'\\$' + key + r'($|[^a-zA-Z0-9_])'\n            code = re.sub(search, val+r'\\1', code)\n\n        # Done\n        if '$' in code:\n            v = parsing.find_template_variables(code)\n            logger.warning('Unsubstituted placeholders in code: %s\\n'\n                           '  replacements made: %s',\n                           v, list(self._expressions.keys()))\n\n        return code + '\\n'",
  "def definition(self, names, version, shader):\n        return self._get_replaced_code(names, version, shader)",
  "def expression(self, names):\n        return names[self]",
  "def _clean_code(self, code):\n        \"\"\"Return *code* with indentation and leading/trailing blank lines removed.\"\"\"\n        lines = code.split(\"\\n\")\n        min_indent = 100\n        for line in lines:\n            if line.strip() != \"\":\n                indent = len(line) - len(line.lstrip())\n                min_indent = min(indent, min_indent)\n        if min_indent > 0:\n            lines = [line[min_indent:] for line in lines]\n        code = \"\\n\".join(lines)\n        return code",
  "def __repr__(self):\n        try:\n            args = ', '.join([' '.join(arg) for arg in self.args])\n        except Exception:\n            return ('<%s (error parsing signature) at 0x%x>' %\n                    (self.__class__.__name__, id(self)))\n        return '<%s \"%s %s(%s)\" at 0x%x>' % (self.__class__.__name__,\n                                             self.rtype,\n                                             self.name,\n                                             args,\n                                             id(self))",
  "def __init__(self, shader_type, *args, **kwargs):\n        self.shader_type = shader_type\n        self._chains = {}\n        Function.__init__(self, *args, **kwargs)",
  "def signature(self):\n        return ('main', [], 'void')",
  "def version_pragma(self):\n        \"\"\"Return version number and extra qualifiers from pragma if present.\"\"\"\n        m = re.search(parsing.re_version_pragma, self.code)\n        if m is None:\n            return None\n        return int(m.group(1)), m.group(2)",
  "def definition(self, obj_names, version, shader):\n        code = Function.definition(self, obj_names, version, shader)\n        # strip out version pragma before returning code; this will be\n        # added to the final compiled code later.\n        code = re.sub(parsing.re_version_pragma, '', code)\n        return code",
  "def static_names(self):\n        if self._static_vars is not None:\n            return self._static_vars\n\n        # parse static variables\n        names = Function.static_names(self)\n\n        # parse all function names + argument names\n        funcs = parsing.find_functions(self.code)\n        for f in funcs:\n            if f[0] == 'main':\n                continue\n            names.append(f[0])\n            for arg in f[1]:\n                names.append(arg[1])\n\n        self._static_vars = names\n        return names",
  "def add_chain(self, var):\n        \"\"\"Create a new ChainFunction and attach to $var.\"\"\"\n        chain = FunctionChain(var, [])\n        self._chains[var] = chain\n        self[var] = chain",
  "def add_callback(self, hook, func):\n        self._chains[hook].append(func)",
  "def remove_callback(self, hook, func):\n        self._chains[hook].remove(func)",
  "def __init__(self, name=None, funcs=()):\n        # bypass Function.__init__ completely.\n        ShaderObject.__init__(self)\n        if not (name is None or isinstance(name, str)):\n            raise TypeError(\"Name argument must be string or None.\")\n        self._funcs = []\n        self._code = None\n        self._name = name or \"chain\"\n        self._args = []\n        self._rtype = 'void'\n        self.functions = funcs",
  "def functions(self):\n        return self._funcs[:]",
  "def functions(self, funcs):\n        while self._funcs:\n            self.remove(self._funcs[0], update=False)\n        for f in funcs:\n            self.append(f, update=False)\n        self._update()",
  "def signature(self):\n        return self._name, self._args, self._rtype",
  "def _update(self):\n        funcs = self._funcs\n        if len(funcs) > 0:\n            self._rtype = funcs[-1].rtype\n            self._args = funcs[0].args[:]\n        else:\n            self._rtype = 'void'\n            self._args = []\n\n        self.changed(code_changed=True)",
  "def code(self):\n        # Code is generated at compile time; hopefully it is not requested\n        # before then..\n        return None",
  "def code(self, c):\n        raise TypeError(\"Cannot set code property on FunctionChain.\")",
  "def template_vars(self):\n        return {}",
  "def append(self, function, update=True):\n        \"\"\"Append a new function to the end of this chain.\"\"\"\n        self._funcs.append(function)\n        self._add_dep(function)\n        if update:\n            self._update()",
  "def __setitem__(self, index, func):\n        self._remove_dep(self._funcs[index])\n        self._add_dep(func)\n        self._funcs[index] = func\n\n        self._update()",
  "def __getitem__(self, k):\n        return self.functions[k]",
  "def insert(self, index, function, update=True):\n        \"\"\"Insert a new function into the chain at *index*.\"\"\"\n        self._funcs.insert(index, function)\n        self._add_dep(function)\n        if update:\n            self._update()",
  "def remove(self, function, update=True):\n        \"\"\"Remove a function from the chain.\"\"\"\n        self._funcs.remove(function)\n        self._remove_dep(function)\n        if update:\n            self._update()",
  "def definition(self, obj_names, version, shader):\n        name = obj_names[self]\n\n        args = \", \".join([\"%s %s\" % arg for arg in self.args])\n        code = \"%s %s(%s) {\\n\" % (self.rtype, name, args)\n\n        result_index = 0\n        if len(self.args) == 0:\n            last_rtype = 'void'\n            last_result = ''\n        else:\n            last_rtype, last_result = self.args[0][:2]\n\n        for fn in self._funcs:\n            # Use previous return value as an argument to the next function\n            if last_rtype == 'void':\n                args = ''\n            else:\n                args = last_result\n                if len(fn.args) != 1 or last_rtype != fn.args[0][0]:\n                    raise Exception(\"Cannot chain output '%s' of function to \"\n                                    \"input of '%s'\" %\n                                    (last_rtype, fn.signature))\n            last_rtype = fn.rtype\n\n            # Store the return value of this function\n            if fn.rtype == 'void':\n                set_str = ''\n            else:\n                result_index += 1\n                result = 'result_%d' % result_index\n                set_str = '%s %s = ' % (fn.rtype, result)\n                last_result = result\n\n            code += \"    %s%s(%s);\\n\" % (set_str, obj_names[fn], args)\n\n        # return the last function's output\n        if self.rtype != 'void':\n            code += \"    return result_%d;\\n\" % result_index\n\n        code += \"}\\n\"\n        return code",
  "def static_names(self):\n        return []",
  "def __repr__(self):\n        fn = \",\\n                \".join(map(repr, self.functions))\n        return \"<FunctionChain [%s] at 0x%x>\" % (fn, id(self))",
  "def __init__(self):\n        self.items = {}\n        self.order = []\n        ShaderObject.__init__(self)",
  "def add(self, item, position=5):\n        \"\"\"Add an item to the list unless it is already present.\n\n        If the item is an expression, then a semicolon will be appended to it\n        in the final compiled code.\n        \"\"\"\n        if item in self.items:\n            return\n        self.items[item] = position\n        self._add_dep(item)\n        self.order = None\n        self.changed(code_changed=True)",
  "def remove(self, item):\n        \"\"\"Remove an item from the list.\"\"\"\n        self.items.pop(item)\n        self._remove_dep(item)\n        self.order = None\n        self.changed(code_changed=True)",
  "def expression(self, obj_names):\n        if self.order is None:\n            self.order = list(self.items.items())\n            self.order.sort(key=lambda x: x[1])\n\n        code = \"\"\n        for item, pos in self.order:\n            code += item.expression(obj_names) + ';\\n'\n        return code",
  "def parse_function_signature(code):\n    \"\"\"\n    Return the name, arguments, and return type of the first function\n    definition found in *code*. Arguments are returned as [(type, name), ...].\n    \"\"\"\n    m = re.search(r\"^\\s*\" + re_func_decl + r\"\\s*{\", code, re.M)\n    if m is None:\n        print(code)\n        raise Exception(\"Failed to parse function signature. \"\n                        \"Full code is printed above.\")\n    rtype, name, args = m.groups()[:3]\n    if args == 'void' or args.strip() == '':\n        args = []\n    else:\n        args = [tuple(arg.strip().split(' ')) for arg in args.split(',')]\n    return name, args, rtype",
  "def find_functions(code):\n    \"\"\"\n    Return a list of (name, arguments, return type) for all function\n    definition2 found in *code*. Arguments are returned as [(type, name), ...].\n    \"\"\"\n    regex = r\"^\\s*\" + re_func_decl + r\"\\s*{\"\n\n    funcs = []\n    while True:\n        m = re.search(regex, code, re.M)\n        if m is None:\n            return funcs\n\n        rtype, name, args = m.groups()[:3]\n        if args == 'void' or args.strip() == '':\n            args = []\n        else:\n            args = [tuple(arg.strip().split(' ')) for arg in args.split(',')]\n        funcs.append((name, args, rtype))\n\n        code = code[m.end():]",
  "def find_prototypes(code):\n    \"\"\"\n    Return a list of signatures for each function prototype declared in *code*.\n    Format is [(name, [args], rtype), ...].\n    \"\"\"\n    prots = []\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match(r\"\\s*\" + re_func_prot, line)\n        if m is not None:\n            rtype, name, args = m.groups()[:3]\n            if args == 'void' or args.strip() == '':\n                args = []\n            else:\n                args = [tuple(arg.strip().split(' '))\n                        for arg in args.split(',')]\n            prots.append((name, args, rtype))\n\n    return prots",
  "def find_program_variables(code):\n    \"\"\"\n    Return a dict describing program variables::\n\n        {'var_name': ('uniform|attribute|varying', type), ...}\n\n    \"\"\"\n    vars = {}\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match(r\"\\s*\" + re_prog_var_declaration + r\"\\s*(=|;)\", line)\n        if m is not None:\n            vtype, dtype, names = m.groups()[:3]\n            for name in names.split(','):\n                vars[name.strip()] = (vtype, dtype)\n    return vars",
  "def find_template_variables(code):\n    \"\"\"Return a list of template variables found in *code*.\"\"\"\n    return re.findall(re_template_var, code)",
  "class _ArrowHeadVisual(Visual):\n    \"\"\"Arrow head visual\n\n    Several shapes to put on the end of a line. This visual differs from\n    MarkersVisual in the sense that this visual calculates the orientation of\n    the visual on the GPU, by calculating the tangent of the line between two\n    given vertices.\n\n    This is not really a visual you would use on your own,\n    use :class:`ArrowVisual` instead.\n\n    Parameters\n    ----------\n    parent : ArrowVisual\n        This actual ArrowVisual this arrow head is part of.\n    \"\"\"\n\n    ARROWHEAD_VERTEX_SHADER = glsl.get('arrowheads/arrowheads.vert')\n    ARROWHEAD_FRAGMENT_SHADER = glsl.get('arrowheads/arrowheads.frag')\n\n    _arrow_vtype = np.dtype([\n        ('v1', np.float32, (4,)),\n        ('v2', np.float32, (4,)),\n        ('size', np.float32),\n        ('color', np.float32, (4,)),\n        ('linewidth', np.float32)\n    ])\n\n    def __init__(self, parent):\n        Visual.__init__(self, self.ARROWHEAD_VERTEX_SHADER,\n                        self.ARROWHEAD_FRAGMENT_SHADER)\n        self._parent = parent\n        self.set_gl_state(depth_test=False, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n\n        self._arrow_vbo = gloo.VertexBuffer(\n            np.array([], dtype=self._arrow_vtype))\n\n    def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform\n\n    def _prepare_draw(self, view=None):\n        if self._parent._arrows_changed:\n            self._prepare_vertex_data()\n        self.shared_program.bind(self._arrow_vbo)\n        self.shared_program['antialias'] = 1.0\n        self.shared_program.frag['arrow_type'] = self._parent.arrow_type\n        self.shared_program.frag['fill_type'] = \"filled\"\n\n    def _prepare_vertex_data(self):\n        arrows = self._parent.arrows\n\n        if arrows is None or arrows.size == 0:\n            self._arrow_vbo = gloo.VertexBuffer(\n                np.array([], dtype=self._arrow_vtype))\n            return\n\n        v = np.zeros(len(arrows), dtype=self._arrow_vtype)\n        # 2d // 3d v1 v2.\n        sh = int(arrows.shape[1] / 2)\n        v['v1'] = as_vec4(arrows[:, 0:sh])\n        v['v2'] = as_vec4(arrows[:, sh:int(2 * sh)])\n        v['size'][:] = self._parent.arrow_size\n        color, cmap = self._parent._interpret_color(self._parent.arrow_color)\n        v['color'][:] = color\n        v['linewidth'][:] = self._parent.width\n        self._arrow_vbo = gloo.VertexBuffer(v)",
  "class ArrowVisual(LineVisual):\n    \"\"\"Arrow visual\n\n    A special line visual which can also draw optional arrow heads at the\n    specified vertices.\n\n    You add an arrow head by specifying two vertices `v1` and `v2` which\n    represent the arrow body. This visual will draw an arrow head using `v2`\n    as center point, and the orientation of the arrow head is automatically\n    determined by calculating the direction vector between `v1` and `v2`. \n    The arrow head can be detached from arrow body.\n\n    Parameters\n    ----------\n    pos : array\n        Array of shape (..., 2) or (..., 3) specifying vertex coordinates\n        of arrow body.\n    color : Color, tuple, or array\n        The color to use when drawing the line. If an array is given, it\n        must be of shape (..., 4) and provide one rgba color per vertex.\n        Can also be a colormap name, or appropriate `Function`.\n    width:\n        The width of the line in px. Line widths > 1px are only\n        guaranteed to work when using 'agg' method.\n    connect : str or array\n        Determines which vertices are connected by lines.\n\n            * \"strip\" causes the line to be drawn with each vertex\n              connected to the next.\n            * \"segments\" causes each pair of vertices to draw an\n              independent line segment\n            * numpy arrays specify the exact set of segment pairs to\n              connect.\n    method : str\n        Mode to use for drawing.\n\n            * \"agg\" uses anti-grain geometry to draw nicely antialiased lines\n              with proper joins and endcaps.\n            * \"gl\" uses OpenGL's built-in line rendering. This is much faster,\n              but produces much lower-quality results and is not guaranteed to\n              obey the requested line width or join/endcap styles.\n    antialias : bool\n        Enables or disables antialiasing.\n        For method='gl', this specifies whether to use GL's line smoothing,\n        which may be unavailable or inconsistent on some platforms.\n    arrows : array\n        A (N, 4) or (N, 6) matrix where each row contains the (x, y) or the\n        (x, y, z) coordinates of the first and second vertex of the arrow\n        head. Remember that the second vertex is used as center point for\n        the arrow head, and the first vertex is only used for determining\n        the arrow head orientation.\n    arrow_type : string\n        Specify the arrow head type, the currently available arrow head types\n        are:\n\n            * stealth\n            * curved\n            * triangle_30\n            * triangle_60\n            * triangle_90\n            * angle_30\n            * angle_60\n            * angle_90\n            * inhibitor_round\n    arrow_size : float\n        Specify the arrow size\n    arrow_color : Color, tuple, or array\n        The arrow head color. If an array is given, it must be of shape\n        (..., 4) and provide one rgba color per arrow head. Can also be a\n        colormap name, or appropriate `Function`.\n    \"\"\"\n\n    def __init__(self, pos=None, color=(0.5, 0.5, 0.5, 1), width=1,\n                 connect='strip', method='gl', antialias=False, arrows=None,\n                 arrow_type='stealth', arrow_size=None,\n                 arrow_color=(0.5, 0.5, 0.5, 1)):\n\n        # Do not use the self._changed dictionary as it gets overwritten by\n        # the LineVisual constructor.\n        self._arrows_changed = False\n\n        self._arrow_type = None\n        self._arrow_size = None\n        self._arrows = None\n\n        self.arrow_type = arrow_type\n        self.arrow_size = arrow_size\n        self.arrow_color = arrow_color\n\n        self.arrow_head = _ArrowHeadVisual(self)\n\n        # TODO: `LineVisual.__init__` also calls its own `set_data` method,\n        # which triggers an *update* event. This results in a redraw. After\n        # that we call our own `set_data` method, which triggers another\n        # redraw. This should be fixed.\n        LineVisual.__init__(self, pos, color, width, connect, method,\n                            antialias)\n        ArrowVisual.set_data(self, arrows=arrows)\n\n        # Add marker visual for the arrow head\n        self.add_subvisual(self.arrow_head)\n\n    def set_data(self, pos=None, color=None, width=None, connect=None,\n                 arrows=None):\n        \"\"\"Set the data used for this visual\n\n        Parameters\n        ----------\n        pos : array\n            Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n        color : Color, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (..., 4) and provide one rgba color per vertex.\n            Can also be a colormap name, or appropriate `Function`.\n        width:\n            The width of the line in px. Line widths > 1px are only\n            guaranteed to work when using 'agg' method.\n        connect : str or array\n            Determines which vertices are connected by lines.\n\n                * \"strip\" causes the line to be drawn with each vertex\n                  connected to the next.\n                * \"segments\" causes each pair of vertices to draw an\n                  independent line segment\n                * numpy arrays specify the exact set of segment pairs to\n                  connect.\n        arrows : array\n            A (N, 4) or (N, 6) matrix where each row contains the (x, y) or the\n            (x, y, z) coordinate of the first and second vertex of the arrow\n            body. Remember that the second vertex is used as center point for\n            the arrow head, and the first vertex is only used for determining\n            the arrow head orientation.\n        \"\"\"\n        if arrows is not None:\n            self._arrows = arrows\n            self._arrows_changed = True\n\n        LineVisual.set_data(self, pos, color, width, connect)\n\n    @property\n    def arrow_type(self):\n        return self._arrow_type\n\n    @arrow_type.setter\n    def arrow_type(self, value):\n        if value not in ARROW_TYPES:\n            raise ValueError(\n                \"Invalid arrow type '{}'. Should be one of {}\".format(\n                    value, \", \".join(ARROW_TYPES)\n                )\n            )\n\n        if value == self._arrow_type:\n            return\n\n        self._arrow_type = value\n        self._arrows_changed = True\n\n    @property\n    def arrow_size(self):\n        return self._arrow_size\n\n    @arrow_size.setter\n    def arrow_size(self, value):\n        if value is None:\n            self._arrow_size = 5.0\n        else:\n            if value <= 0.0:\n                raise ValueError(\"Arrow size should be greater than zero.\")\n\n            self._arrow_size = value\n\n        self._arrows_changed = True\n\n    @property\n    def arrow_color(self):\n        return self._arrow_color\n\n    @arrow_color.setter\n    def arrow_color(self, value):\n        if value is not None:\n            self._arrow_color = value\n            self._arrows_changed = True\n\n    @property\n    def arrows(self):\n        return self._arrows",
  "def __init__(self, parent):\n        Visual.__init__(self, self.ARROWHEAD_VERTEX_SHADER,\n                        self.ARROWHEAD_FRAGMENT_SHADER)\n        self._parent = parent\n        self.set_gl_state(depth_test=False, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n        self._draw_mode = 'points'\n\n        self._arrow_vbo = gloo.VertexBuffer(\n            np.array([], dtype=self._arrow_vtype))",
  "def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform",
  "def _prepare_draw(self, view=None):\n        if self._parent._arrows_changed:\n            self._prepare_vertex_data()\n        self.shared_program.bind(self._arrow_vbo)\n        self.shared_program['antialias'] = 1.0\n        self.shared_program.frag['arrow_type'] = self._parent.arrow_type\n        self.shared_program.frag['fill_type'] = \"filled\"",
  "def _prepare_vertex_data(self):\n        arrows = self._parent.arrows\n\n        if arrows is None or arrows.size == 0:\n            self._arrow_vbo = gloo.VertexBuffer(\n                np.array([], dtype=self._arrow_vtype))\n            return\n\n        v = np.zeros(len(arrows), dtype=self._arrow_vtype)\n        # 2d // 3d v1 v2.\n        sh = int(arrows.shape[1] / 2)\n        v['v1'] = as_vec4(arrows[:, 0:sh])\n        v['v2'] = as_vec4(arrows[:, sh:int(2 * sh)])\n        v['size'][:] = self._parent.arrow_size\n        color, cmap = self._parent._interpret_color(self._parent.arrow_color)\n        v['color'][:] = color\n        v['linewidth'][:] = self._parent.width\n        self._arrow_vbo = gloo.VertexBuffer(v)",
  "def __init__(self, pos=None, color=(0.5, 0.5, 0.5, 1), width=1,\n                 connect='strip', method='gl', antialias=False, arrows=None,\n                 arrow_type='stealth', arrow_size=None,\n                 arrow_color=(0.5, 0.5, 0.5, 1)):\n\n        # Do not use the self._changed dictionary as it gets overwritten by\n        # the LineVisual constructor.\n        self._arrows_changed = False\n\n        self._arrow_type = None\n        self._arrow_size = None\n        self._arrows = None\n\n        self.arrow_type = arrow_type\n        self.arrow_size = arrow_size\n        self.arrow_color = arrow_color\n\n        self.arrow_head = _ArrowHeadVisual(self)\n\n        # TODO: `LineVisual.__init__` also calls its own `set_data` method,\n        # which triggers an *update* event. This results in a redraw. After\n        # that we call our own `set_data` method, which triggers another\n        # redraw. This should be fixed.\n        LineVisual.__init__(self, pos, color, width, connect, method,\n                            antialias)\n        ArrowVisual.set_data(self, arrows=arrows)\n\n        # Add marker visual for the arrow head\n        self.add_subvisual(self.arrow_head)",
  "def set_data(self, pos=None, color=None, width=None, connect=None,\n                 arrows=None):\n        \"\"\"Set the data used for this visual\n\n        Parameters\n        ----------\n        pos : array\n            Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n        color : Color, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (..., 4) and provide one rgba color per vertex.\n            Can also be a colormap name, or appropriate `Function`.\n        width:\n            The width of the line in px. Line widths > 1px are only\n            guaranteed to work when using 'agg' method.\n        connect : str or array\n            Determines which vertices are connected by lines.\n\n                * \"strip\" causes the line to be drawn with each vertex\n                  connected to the next.\n                * \"segments\" causes each pair of vertices to draw an\n                  independent line segment\n                * numpy arrays specify the exact set of segment pairs to\n                  connect.\n        arrows : array\n            A (N, 4) or (N, 6) matrix where each row contains the (x, y) or the\n            (x, y, z) coordinate of the first and second vertex of the arrow\n            body. Remember that the second vertex is used as center point for\n            the arrow head, and the first vertex is only used for determining\n            the arrow head orientation.\n        \"\"\"\n        if arrows is not None:\n            self._arrows = arrows\n            self._arrows_changed = True\n\n        LineVisual.set_data(self, pos, color, width, connect)",
  "def arrow_type(self):\n        return self._arrow_type",
  "def arrow_type(self, value):\n        if value not in ARROW_TYPES:\n            raise ValueError(\n                \"Invalid arrow type '{}'. Should be one of {}\".format(\n                    value, \", \".join(ARROW_TYPES)\n                )\n            )\n\n        if value == self._arrow_type:\n            return\n\n        self._arrow_type = value\n        self._arrows_changed = True",
  "def arrow_size(self):\n        return self._arrow_size",
  "def arrow_size(self, value):\n        if value is None:\n            self._arrow_size = 5.0\n        else:\n            if value <= 0.0:\n                raise ValueError(\"Arrow size should be greater than zero.\")\n\n            self._arrow_size = value\n\n        self._arrows_changed = True",
  "def arrow_color(self):\n        return self._arrow_color",
  "def arrow_color(self, value):\n        if value is not None:\n            self._arrow_color = value\n            self._arrows_changed = True",
  "def arrows(self):\n        return self._arrows",
  "class LineVisual(CompoundVisual):\n    \"\"\"Line visual\n\n    Parameters\n    ----------\n    pos : array\n        Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n    color : Color, tuple, or array\n        The color to use when drawing the line. If an array is given, it\n        must be of shape (..., 4) and provide one rgba color per vertex.\n        Can also be a colormap name, or appropriate `Function`.\n    width:\n        The width of the line in px. Line widths > 1px are only\n        guaranteed to work when using 'agg' method.\n    connect : str or array\n        Determines which vertices are connected by lines.\n\n            * \"strip\" causes the line to be drawn with each vertex\n              connected to the next.\n            * \"segments\" causes each pair of vertices to draw an\n              independent line segment\n            * numpy arrays specify the exact set of segment pairs to\n              connect.\n\n    method : str\n        Mode to use for drawing.\n\n            * \"agg\" uses anti-grain geometry to draw nicely antialiased lines\n              with proper joins and endcaps.\n            * \"gl\" uses OpenGL's built-in line rendering. This is much faster,\n              but produces much lower-quality results and is not guaranteed to\n              obey the requested line width or join/endcap styles.\n\n    antialias : bool\n        Enables or disables antialiasing.\n        For method='gl', this specifies whether to use GL's line smoothing,\n        which may be unavailable or inconsistent on some platforms.\n    \"\"\"\n\n    _join_types = joins\n\n    _cap_types = caps\n\n    def __init__(self, pos=None, color=(0.5, 0.5, 0.5, 1), width=1,\n                 connect='strip', method='gl', antialias=False):\n        self._line_visual = None\n\n        self._changed = {'pos': False, 'color': False, 'connect': False}\n\n        self._pos = None\n        self._color = None\n        self._width = None\n        self._connect = None\n        self._bounds = None\n        self._antialias = None\n        self._method = 'none'\n\n        CompoundVisual.__init__(self, [])\n\n        # don't call subclass set_data; these often have different\n        # signatures.\n        LineVisual.set_data(self, pos=pos, color=color, width=width,\n                            connect=connect)\n        self.antialias = antialias\n        self.method = method\n\n    @property\n    def join_types(self):\n        return self._join_types\n\n    @property\n    def cap_types(self):\n        return self._cap_types\n\n    @property\n    def antialias(self):\n        return self._antialias\n\n    @antialias.setter\n    def antialias(self, aa):\n        self._antialias = bool(aa)\n        self.update()\n\n    @property\n    def method(self):\n        \"\"\"The current drawing method\"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, method):\n        if method not in ('agg', 'gl'):\n            raise ValueError('method argument must be \"agg\" or \"gl\".')\n        if method == self._method:\n            return\n\n        self._method = method\n        if self._line_visual is not None:\n            self.remove_subvisual(self._line_visual)\n\n        if method == 'gl':\n            self._line_visual = _GLLineVisual(self)\n        elif method == 'agg':\n            self._line_visual = _AggLineVisual(self)\n        self.add_subvisual(self._line_visual)\n\n        for k in self._changed:\n            self._changed[k] = True\n\n    def set_data(self, pos=None, color=None, width=None, connect=None):\n        \"\"\"Set the data used to draw this visual.\n\n        Parameters\n        ----------\n        pos : array\n            Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n        color : Color, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (..., 4) and provide one rgba color per vertex.\n        width:\n            The width of the line in px. Line widths < 1 px will be rounded up\n            to 1 px when using the 'gl' method.\n        connect : str or array\n            Determines which vertices are connected by lines.\n\n                * \"strip\" causes the line to be drawn with each vertex\n                  connected to the next.\n                * \"segments\" causes each pair of vertices to draw an\n                  independent line segment\n                * int numpy arrays specify the exact set of segment pairs to\n                  connect.\n                * bool numpy arrays specify which _adjacent_ pairs to connect.\n\n        \"\"\"\n        if pos is not None:\n            self._bounds = None\n            self._pos = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            self._color = color\n            self._changed['color'] = True\n\n        if width is not None:\n            # width is always updated\n            self._width = width\n\n        if connect is not None:\n            self._connect = connect\n            self._changed['connect'] = True\n\n        self.update()\n\n    @property\n    def color(self):\n        return self._color\n\n    @property\n    def width(self):\n        return self._width\n\n    @property\n    def connect(self):\n        return self._connect\n\n    @property\n    def pos(self):\n        return self._pos\n\n    def _interpret_connect(self):\n        if isinstance(self._connect, np.ndarray):\n            # Convert a boolean connection array to a vertex index array\n            if self._connect.ndim == 1 and self._connect.dtype == bool:\n                index = np.empty((len(self._connect), 2), dtype=np.uint32)\n                index[:] = np.arange(len(self._connect))[:, np.newaxis]\n                index[:, 1] += 1\n                return index[self._connect]\n            elif self._connect.ndim == 2 and self._connect.shape[1] == 2:\n                return self._connect.astype(np.uint32)\n            else:\n                raise TypeError(\"Got invalid connect array of shape %r and \"\n                                \"dtype %r\" % (self._connect.shape,\n                                              self._connect.dtype))\n        else:\n            return self._connect\n\n    def _interpret_color(self, color_in=None):\n        color_in = self._color if color_in is None else color_in\n        colormap = None\n        if isinstance(color_in, str):\n            try:\n                colormap = get_colormap(color_in)\n                color = Function(colormap.glsl_map)\n            except KeyError:\n                color = Color(color_in).rgba\n        elif isinstance(color_in, Function):\n            color = Function(color_in)\n        else:\n            color = ColorArray(color_in).rgba\n            if len(color) == 1:\n                color = color[0]\n        return color, colormap\n\n    def _compute_bounds(self, axis, view):\n        \"\"\"Get the bounds\n\n        Parameters\n        ----------\n        mode : str\n            Describes the type of boundary requested. Can be \"visual\", \"data\",\n            or \"mouse\".\n        axis : 0, 1, 2\n            The axis along which to measure the bounding values, in\n            x-y-z order.\n        \"\"\"\n        # Can and should we calculate bounds?\n        if (self._bounds is None) and self._pos is not None:\n            pos = self._pos\n            self._bounds = [(pos[:, d].min(), pos[:, d].max())\n                            for d in range(pos.shape[1])]\n        # Return what we can\n        if self._bounds is None:\n            return\n        else:\n            if axis < len(self._bounds):\n                return self._bounds[axis]\n            else:\n                return (0, 0)\n\n    def _prepare_draw(self, view):\n        if self._width == 0:\n            return False\n        CompoundVisual._prepare_draw(self, view)",
  "class _GLLineVisual(Visual):\n    _shaders = {\n        'vertex': \"\"\"\n            varying vec4 v_color;\n\n            void main(void) {\n                gl_Position = $transform($to_vec4($position));\n                v_color = $color;\n            }\n        \"\"\",\n        'fragment': \"\"\"\n            varying vec4 v_color;\n            void main() {\n                gl_FragColor = v_color;\n            }\n        \"\"\"\n    }\n\n    def __init__(self, parent):\n        self._parent = parent\n        self._pos_vbo = gloo.VertexBuffer()\n        self._color_vbo = gloo.VertexBuffer()\n        self._connect_ibo = gloo.IndexBuffer()\n        self._connect = None\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.set_gl_state('translucent')\n\n    @staticmethod\n    @lru_cache(maxsize=2)\n    def _ensure_vec4_func(dims):\n        if dims == 2:\n            func = Function(\"\"\"\n                vec4 vec2to4(vec2 xyz) {\n                    return vec4(xyz, 0.0, 1.0);\n                }\n            \"\"\")\n        elif dims == 3:\n            func = Function(\"\"\"\n                vec4 vec3to4(vec3 xyz) {\n                    return vec4(xyz, 1.0);\n                }\n            \"\"\")\n        else:\n            raise TypeError(\"Vertex data must have shape (...,2) or (...,3).\")\n        return func\n\n    def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform\n\n    def _prepare_draw(self, view):\n        prof = Profiler()\n\n        if self._parent._changed['pos']:\n            if self._parent._pos is None:\n                return False\n            pos = np.ascontiguousarray(self._parent._pos, dtype=np.float32)\n            self._pos_vbo.set_data(pos)\n            self._program.vert['position'] = self._pos_vbo\n            self._program.vert['to_vec4'] = self._ensure_vec4_func(pos.shape[-1])\n            self._parent._changed['pos'] = False\n\n        if self._parent._changed['color']:\n            color, cmap = self._parent._interpret_color()\n            # If color is not visible, just quit now\n            if isinstance(color, Color) and color.is_blank:\n                return False\n            if isinstance(color, Function):\n                # TODO: Change to the parametric coordinate once that is done\n                self._program.vert['color'] = color(\n                    '(gl_Position.x + 1.0) / 2.0')\n            else:\n                if color.ndim == 1:\n                    self._program.vert['color'] = color\n                else:\n                    self._color_vbo.set_data(color)\n                    self._program.vert['color'] = self._color_vbo\n            self._parent._changed['color'] = False\n\n            self.shared_program['texture2D_LUT'] = cmap and cmap.texture_lut()\n\n        self.update_gl_state(line_smooth=bool(self._parent._antialias))\n        px_scale = self.transforms.pixel_scale\n        width = px_scale * self._parent._width\n        self.update_gl_state(line_width=max(width, 1.0))\n\n        if self._parent._changed['connect']:\n            self._connect = self._parent._interpret_connect()\n            if isinstance(self._connect, np.ndarray):\n                self._connect_ibo.set_data(self._connect)\n            self._parent._changed['connect'] = False\n        if self._connect is None:\n            return False\n\n        prof('prepare')\n\n        # Draw\n        if isinstance(self._connect, str) and \\\n                self._connect == 'strip':\n            self._draw_mode = 'line_strip'\n            self._index_buffer = None\n        elif isinstance(self._connect, str) and \\\n                self._connect == 'segments':\n            self._draw_mode = 'lines'\n            self._index_buffer = None\n        elif isinstance(self._connect, np.ndarray):\n            self._draw_mode = 'lines'\n            self._index_buffer = self._connect_ibo\n        else:\n            raise ValueError(\"Invalid line connect mode: %r\" % self._connect)\n\n        prof('draw')",
  "class _AggLineVisual(Visual):\n    _agg_vtype = np.dtype([('a_position', np.float32, (2,)),\n                           ('a_tangents', np.float32, (4,)),\n                           ('a_segment', np.float32, (2,)),\n                           ('a_angles', np.float32, (2,)),\n                           ('a_texcoord', np.float32, (2,)),\n                           ('alength', np.float32),\n                           ('color', np.float32, (4,))])\n\n    _shaders = {\n        'vertex': glsl.get('lines/agg.vert'),\n        'fragment': glsl.get('lines/agg.frag'),\n    }\n\n    def __init__(self, parent):\n        self._parent = parent\n        self._vbo = gloo.VertexBuffer()\n\n        self._pos = None\n        self._color = None\n\n        self._da = DashAtlas()\n        dash_index, dash_period = self._da['solid']\n        self._U = dict(dash_index=dash_index, dash_period=dash_period,\n                       linejoin=joins['round'],\n                       linecaps=(caps['round'], caps['round']),\n                       dash_caps=(caps['round'], caps['round']),\n                       antialias=1.0)\n        self._dash_atlas = gloo.Texture2D(self._da._data)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self._index_buffer = gloo.IndexBuffer()\n        # The depth_test being disabled prevents z-ordering, but if\n        # we turn it on the blending of the aa edges produces artifacts.\n        self.set_gl_state('translucent', depth_test=False)\n        self._draw_mode = 'triangles'\n\n    def _prepare_transforms(self, view):\n        data_doc = view.get_transform('visual', 'document')\n        doc_px = view.get_transform('document', 'framebuffer')\n        px_ndc = view.get_transform('framebuffer', 'render')\n        vert = view.view_program.vert\n        vert['transform'] = data_doc\n        vert['doc_px_transform'] = doc_px\n        vert['px_ndc_transform'] = px_ndc\n\n    def _prepare_draw(self, view):\n        bake = False\n        if self._parent._changed['pos']:\n            if self._parent._pos is None:\n                return False\n            self._pos = np.ascontiguousarray(self._parent._pos, dtype=np.float32)\n            bake = True\n\n        if self._parent._changed['color']:\n            color, cmap = self._parent._interpret_color()\n            self._color = color\n            bake = True\n\n        if self._parent._changed['connect']:\n            if self._parent._connect not in [None, 'strip']:\n                raise NotImplementedError(\"Only 'strip' connection mode \"\n                                          \"allowed for agg-method lines.\")\n\n        if bake:\n            V, idxs = self._agg_bake(self._pos, self._color)\n            self._vbo.set_data(V)\n            self._index_buffer.set_data(idxs)\n\n        # self._program.prepare()\n        self.shared_program.bind(self._vbo)\n        uniforms = dict(closed=False, miter_limit=4.0, dash_phase=0.0,\n                        linewidth=self._parent._width)\n        for n, v in uniforms.items():\n            self.shared_program[n] = v\n        for n, v in self._U.items():\n            self.shared_program[n] = v\n        self.shared_program['u_dash_atlas'] = self._dash_atlas\n\n    @classmethod\n    def _agg_bake(cls, vertices, color, closed=False):\n        \"\"\"\n        Bake a list of 2D vertices for rendering them as thick line. Each line\n        segment must have its own vertices because of antialias (this means no\n        vertex sharing between two adjacent line segments).\n        \"\"\"\n        n = len(vertices)\n        P = np.array(vertices).reshape(n, 2).astype(float)\n        idx = np.arange(n)  # used to eventually tile the color array\n\n        dx, dy = P[0] - P[-1]\n        d = np.sqrt(dx*dx+dy*dy)\n\n        # If closed, make sure first vertex = last vertex (+/- epsilon=1e-10)\n        if closed and d > 1e-10:\n            P = np.append(P, P[0]).reshape(n+1, 2)\n            idx = np.append(idx, idx[-1])\n            n += 1\n\n        V = np.zeros(len(P), dtype=cls._agg_vtype)\n        V['a_position'] = P\n\n        # Tangents & norms\n        T = P[1:] - P[:-1]\n\n        N = np.sqrt(T[:, 0]**2 + T[:, 1]**2)\n        # T /= N.reshape(len(T),1)\n        V['a_tangents'][+1:, :2] = T\n        V['a_tangents'][0, :2] = T[-1] if closed else T[0]\n        V['a_tangents'][:-1, 2:] = T\n        V['a_tangents'][-1, 2:] = T[0] if closed else T[-1]\n\n        # Angles\n        T1 = V['a_tangents'][:, :2]\n        T2 = V['a_tangents'][:, 2:]\n        A = np.arctan2(T1[:, 0]*T2[:, 1]-T1[:, 1]*T2[:, 0],\n                       T1[:, 0]*T2[:, 0]+T1[:, 1]*T2[:, 1])\n        V['a_angles'][:-1, 0] = A[:-1]\n        V['a_angles'][:-1, 1] = A[+1:]\n\n        # Segment\n        L = np.cumsum(N)\n        V['a_segment'][+1:, 0] = L\n        V['a_segment'][:-1, 1] = L\n        # V['a_lengths'][:,2] = L[-1]\n\n        # Step 1: A -- B -- C  =>  A -- B, B' -- C\n        V = np.repeat(V, 2, axis=0)[1:-1]\n        V['a_segment'][1:] = V['a_segment'][:-1]\n        V['a_angles'][1:] = V['a_angles'][:-1]\n        V['a_texcoord'][0::2] = -1\n        V['a_texcoord'][1::2] = +1\n        idx = np.repeat(idx, 2)[1:-1]\n\n        # Step 2: A -- B, B' -- C  -> A0/A1 -- B0/B1, B'0/B'1 -- C0/C1\n        V = np.repeat(V, 2, axis=0)\n        V['a_texcoord'][0::2, 1] = -1\n        V['a_texcoord'][1::2, 1] = +1\n        idx = np.repeat(idx, 2)\n\n        idxs = np.resize(np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32),\n                         (n-1)*(2*3))\n        idxs += np.repeat(4*np.arange(n-1, dtype=np.uint32), 6)\n\n        # Length\n        V['alength'] = L[-1] * np.ones(len(V))\n\n        # Color\n        if color.ndim == 1:\n            color = np.tile(color, (len(V), 1))\n        elif color.ndim == 2 and len(color) == n:\n            color = color[idx]\n        else:\n            raise ValueError('Color length %s does not match number of '\n                             'vertices %s' % (len(color), n))\n        V['color'] = color\n\n        return V, idxs",
  "def __init__(self, pos=None, color=(0.5, 0.5, 0.5, 1), width=1,\n                 connect='strip', method='gl', antialias=False):\n        self._line_visual = None\n\n        self._changed = {'pos': False, 'color': False, 'connect': False}\n\n        self._pos = None\n        self._color = None\n        self._width = None\n        self._connect = None\n        self._bounds = None\n        self._antialias = None\n        self._method = 'none'\n\n        CompoundVisual.__init__(self, [])\n\n        # don't call subclass set_data; these often have different\n        # signatures.\n        LineVisual.set_data(self, pos=pos, color=color, width=width,\n                            connect=connect)\n        self.antialias = antialias\n        self.method = method",
  "def join_types(self):\n        return self._join_types",
  "def cap_types(self):\n        return self._cap_types",
  "def antialias(self):\n        return self._antialias",
  "def antialias(self, aa):\n        self._antialias = bool(aa)\n        self.update()",
  "def method(self):\n        \"\"\"The current drawing method\"\"\"\n        return self._method",
  "def method(self, method):\n        if method not in ('agg', 'gl'):\n            raise ValueError('method argument must be \"agg\" or \"gl\".')\n        if method == self._method:\n            return\n\n        self._method = method\n        if self._line_visual is not None:\n            self.remove_subvisual(self._line_visual)\n\n        if method == 'gl':\n            self._line_visual = _GLLineVisual(self)\n        elif method == 'agg':\n            self._line_visual = _AggLineVisual(self)\n        self.add_subvisual(self._line_visual)\n\n        for k in self._changed:\n            self._changed[k] = True",
  "def set_data(self, pos=None, color=None, width=None, connect=None):\n        \"\"\"Set the data used to draw this visual.\n\n        Parameters\n        ----------\n        pos : array\n            Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n        color : Color, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (..., 4) and provide one rgba color per vertex.\n        width:\n            The width of the line in px. Line widths < 1 px will be rounded up\n            to 1 px when using the 'gl' method.\n        connect : str or array\n            Determines which vertices are connected by lines.\n\n                * \"strip\" causes the line to be drawn with each vertex\n                  connected to the next.\n                * \"segments\" causes each pair of vertices to draw an\n                  independent line segment\n                * int numpy arrays specify the exact set of segment pairs to\n                  connect.\n                * bool numpy arrays specify which _adjacent_ pairs to connect.\n\n        \"\"\"\n        if pos is not None:\n            self._bounds = None\n            self._pos = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            self._color = color\n            self._changed['color'] = True\n\n        if width is not None:\n            # width is always updated\n            self._width = width\n\n        if connect is not None:\n            self._connect = connect\n            self._changed['connect'] = True\n\n        self.update()",
  "def color(self):\n        return self._color",
  "def width(self):\n        return self._width",
  "def connect(self):\n        return self._connect",
  "def pos(self):\n        return self._pos",
  "def _interpret_connect(self):\n        if isinstance(self._connect, np.ndarray):\n            # Convert a boolean connection array to a vertex index array\n            if self._connect.ndim == 1 and self._connect.dtype == bool:\n                index = np.empty((len(self._connect), 2), dtype=np.uint32)\n                index[:] = np.arange(len(self._connect))[:, np.newaxis]\n                index[:, 1] += 1\n                return index[self._connect]\n            elif self._connect.ndim == 2 and self._connect.shape[1] == 2:\n                return self._connect.astype(np.uint32)\n            else:\n                raise TypeError(\"Got invalid connect array of shape %r and \"\n                                \"dtype %r\" % (self._connect.shape,\n                                              self._connect.dtype))\n        else:\n            return self._connect",
  "def _interpret_color(self, color_in=None):\n        color_in = self._color if color_in is None else color_in\n        colormap = None\n        if isinstance(color_in, str):\n            try:\n                colormap = get_colormap(color_in)\n                color = Function(colormap.glsl_map)\n            except KeyError:\n                color = Color(color_in).rgba\n        elif isinstance(color_in, Function):\n            color = Function(color_in)\n        else:\n            color = ColorArray(color_in).rgba\n            if len(color) == 1:\n                color = color[0]\n        return color, colormap",
  "def _compute_bounds(self, axis, view):\n        \"\"\"Get the bounds\n\n        Parameters\n        ----------\n        mode : str\n            Describes the type of boundary requested. Can be \"visual\", \"data\",\n            or \"mouse\".\n        axis : 0, 1, 2\n            The axis along which to measure the bounding values, in\n            x-y-z order.\n        \"\"\"\n        # Can and should we calculate bounds?\n        if (self._bounds is None) and self._pos is not None:\n            pos = self._pos\n            self._bounds = [(pos[:, d].min(), pos[:, d].max())\n                            for d in range(pos.shape[1])]\n        # Return what we can\n        if self._bounds is None:\n            return\n        else:\n            if axis < len(self._bounds):\n                return self._bounds[axis]\n            else:\n                return (0, 0)",
  "def _prepare_draw(self, view):\n        if self._width == 0:\n            return False\n        CompoundVisual._prepare_draw(self, view)",
  "def __init__(self, parent):\n        self._parent = parent\n        self._pos_vbo = gloo.VertexBuffer()\n        self._color_vbo = gloo.VertexBuffer()\n        self._connect_ibo = gloo.IndexBuffer()\n        self._connect = None\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self.set_gl_state('translucent')",
  "def _ensure_vec4_func(dims):\n        if dims == 2:\n            func = Function(\"\"\"\n                vec4 vec2to4(vec2 xyz) {\n                    return vec4(xyz, 0.0, 1.0);\n                }\n            \"\"\")\n        elif dims == 3:\n            func = Function(\"\"\"\n                vec4 vec3to4(vec3 xyz) {\n                    return vec4(xyz, 1.0);\n                }\n            \"\"\")\n        else:\n            raise TypeError(\"Vertex data must have shape (...,2) or (...,3).\")\n        return func",
  "def _prepare_transforms(self, view):\n        xform = view.transforms.get_transform()\n        view.view_program.vert['transform'] = xform",
  "def _prepare_draw(self, view):\n        prof = Profiler()\n\n        if self._parent._changed['pos']:\n            if self._parent._pos is None:\n                return False\n            pos = np.ascontiguousarray(self._parent._pos, dtype=np.float32)\n            self._pos_vbo.set_data(pos)\n            self._program.vert['position'] = self._pos_vbo\n            self._program.vert['to_vec4'] = self._ensure_vec4_func(pos.shape[-1])\n            self._parent._changed['pos'] = False\n\n        if self._parent._changed['color']:\n            color, cmap = self._parent._interpret_color()\n            # If color is not visible, just quit now\n            if isinstance(color, Color) and color.is_blank:\n                return False\n            if isinstance(color, Function):\n                # TODO: Change to the parametric coordinate once that is done\n                self._program.vert['color'] = color(\n                    '(gl_Position.x + 1.0) / 2.0')\n            else:\n                if color.ndim == 1:\n                    self._program.vert['color'] = color\n                else:\n                    self._color_vbo.set_data(color)\n                    self._program.vert['color'] = self._color_vbo\n            self._parent._changed['color'] = False\n\n            self.shared_program['texture2D_LUT'] = cmap and cmap.texture_lut()\n\n        self.update_gl_state(line_smooth=bool(self._parent._antialias))\n        px_scale = self.transforms.pixel_scale\n        width = px_scale * self._parent._width\n        self.update_gl_state(line_width=max(width, 1.0))\n\n        if self._parent._changed['connect']:\n            self._connect = self._parent._interpret_connect()\n            if isinstance(self._connect, np.ndarray):\n                self._connect_ibo.set_data(self._connect)\n            self._parent._changed['connect'] = False\n        if self._connect is None:\n            return False\n\n        prof('prepare')\n\n        # Draw\n        if isinstance(self._connect, str) and \\\n                self._connect == 'strip':\n            self._draw_mode = 'line_strip'\n            self._index_buffer = None\n        elif isinstance(self._connect, str) and \\\n                self._connect == 'segments':\n            self._draw_mode = 'lines'\n            self._index_buffer = None\n        elif isinstance(self._connect, np.ndarray):\n            self._draw_mode = 'lines'\n            self._index_buffer = self._connect_ibo\n        else:\n            raise ValueError(\"Invalid line connect mode: %r\" % self._connect)\n\n        prof('draw')",
  "def __init__(self, parent):\n        self._parent = parent\n        self._vbo = gloo.VertexBuffer()\n\n        self._pos = None\n        self._color = None\n\n        self._da = DashAtlas()\n        dash_index, dash_period = self._da['solid']\n        self._U = dict(dash_index=dash_index, dash_period=dash_period,\n                       linejoin=joins['round'],\n                       linecaps=(caps['round'], caps['round']),\n                       dash_caps=(caps['round'], caps['round']),\n                       antialias=1.0)\n        self._dash_atlas = gloo.Texture2D(self._da._data)\n\n        Visual.__init__(self, vcode=self._shaders['vertex'], fcode=self._shaders['fragment'])\n        self._index_buffer = gloo.IndexBuffer()\n        # The depth_test being disabled prevents z-ordering, but if\n        # we turn it on the blending of the aa edges produces artifacts.\n        self.set_gl_state('translucent', depth_test=False)\n        self._draw_mode = 'triangles'",
  "def _prepare_transforms(self, view):\n        data_doc = view.get_transform('visual', 'document')\n        doc_px = view.get_transform('document', 'framebuffer')\n        px_ndc = view.get_transform('framebuffer', 'render')\n        vert = view.view_program.vert\n        vert['transform'] = data_doc\n        vert['doc_px_transform'] = doc_px\n        vert['px_ndc_transform'] = px_ndc",
  "def _prepare_draw(self, view):\n        bake = False\n        if self._parent._changed['pos']:\n            if self._parent._pos is None:\n                return False\n            self._pos = np.ascontiguousarray(self._parent._pos, dtype=np.float32)\n            bake = True\n\n        if self._parent._changed['color']:\n            color, cmap = self._parent._interpret_color()\n            self._color = color\n            bake = True\n\n        if self._parent._changed['connect']:\n            if self._parent._connect not in [None, 'strip']:\n                raise NotImplementedError(\"Only 'strip' connection mode \"\n                                          \"allowed for agg-method lines.\")\n\n        if bake:\n            V, idxs = self._agg_bake(self._pos, self._color)\n            self._vbo.set_data(V)\n            self._index_buffer.set_data(idxs)\n\n        # self._program.prepare()\n        self.shared_program.bind(self._vbo)\n        uniforms = dict(closed=False, miter_limit=4.0, dash_phase=0.0,\n                        linewidth=self._parent._width)\n        for n, v in uniforms.items():\n            self.shared_program[n] = v\n        for n, v in self._U.items():\n            self.shared_program[n] = v\n        self.shared_program['u_dash_atlas'] = self._dash_atlas",
  "def _agg_bake(cls, vertices, color, closed=False):\n        \"\"\"\n        Bake a list of 2D vertices for rendering them as thick line. Each line\n        segment must have its own vertices because of antialias (this means no\n        vertex sharing between two adjacent line segments).\n        \"\"\"\n        n = len(vertices)\n        P = np.array(vertices).reshape(n, 2).astype(float)\n        idx = np.arange(n)  # used to eventually tile the color array\n\n        dx, dy = P[0] - P[-1]\n        d = np.sqrt(dx*dx+dy*dy)\n\n        # If closed, make sure first vertex = last vertex (+/- epsilon=1e-10)\n        if closed and d > 1e-10:\n            P = np.append(P, P[0]).reshape(n+1, 2)\n            idx = np.append(idx, idx[-1])\n            n += 1\n\n        V = np.zeros(len(P), dtype=cls._agg_vtype)\n        V['a_position'] = P\n\n        # Tangents & norms\n        T = P[1:] - P[:-1]\n\n        N = np.sqrt(T[:, 0]**2 + T[:, 1]**2)\n        # T /= N.reshape(len(T),1)\n        V['a_tangents'][+1:, :2] = T\n        V['a_tangents'][0, :2] = T[-1] if closed else T[0]\n        V['a_tangents'][:-1, 2:] = T\n        V['a_tangents'][-1, 2:] = T[0] if closed else T[-1]\n\n        # Angles\n        T1 = V['a_tangents'][:, :2]\n        T2 = V['a_tangents'][:, 2:]\n        A = np.arctan2(T1[:, 0]*T2[:, 1]-T1[:, 1]*T2[:, 0],\n                       T1[:, 0]*T2[:, 0]+T1[:, 1]*T2[:, 1])\n        V['a_angles'][:-1, 0] = A[:-1]\n        V['a_angles'][:-1, 1] = A[+1:]\n\n        # Segment\n        L = np.cumsum(N)\n        V['a_segment'][+1:, 0] = L\n        V['a_segment'][:-1, 1] = L\n        # V['a_lengths'][:,2] = L[-1]\n\n        # Step 1: A -- B -- C  =>  A -- B, B' -- C\n        V = np.repeat(V, 2, axis=0)[1:-1]\n        V['a_segment'][1:] = V['a_segment'][:-1]\n        V['a_angles'][1:] = V['a_angles'][:-1]\n        V['a_texcoord'][0::2] = -1\n        V['a_texcoord'][1::2] = +1\n        idx = np.repeat(idx, 2)[1:-1]\n\n        # Step 2: A -- B, B' -- C  -> A0/A1 -- B0/B1, B'0/B'1 -- C0/C1\n        V = np.repeat(V, 2, axis=0)\n        V['a_texcoord'][0::2, 1] = -1\n        V['a_texcoord'][1::2, 1] = +1\n        idx = np.repeat(idx, 2)\n\n        idxs = np.resize(np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32),\n                         (n-1)*(2*3))\n        idxs += np.repeat(4*np.arange(n-1, dtype=np.uint32), 6)\n\n        # Length\n        V['alength'] = L[-1] * np.ones(len(V))\n\n        # Color\n        if color.ndim == 1:\n            color = np.tile(color, (len(V), 1))\n        elif color.ndim == 2 and len(color) == n:\n            color = color[idx]\n        else:\n            raise ValueError('Color length %s does not match number of '\n                             'vertices %s' % (len(color), n))\n        V['color'] = color\n\n        return V, idxs",
  "class DashAtlas(object):\n\n    \"\"\"  \"\"\"\n\n    def __init__(self, shape=(64, 1024, 4)):\n        # 512 patterns at max\n        self._data = np.zeros(shape, dtype=np.float32)\n        self._index = 0\n        self._atlas = {}\n\n        self['solid'] = (1e20, 0), (1, 1)\n        self['densely dotted'] = (0, 1), (1, 1)\n        self['dotted'] = (0, 2), (1, 1)\n        self['loosely dotted'] = (0, 3), (1, 1)\n        self['densely dashed'] = (1, 1), (1, 1)\n        self['dashed'] = (1, 2), (1, 1)\n        self['loosely dashed'] = (1, 4), (1, 1)\n        self['densely dashdotted'] = (1, 1, 0, 1), (1, 1, 1, 1)\n        self['dashdotted'] = (1, 2, 0, 2), (1, 1, 1, 1)\n        self['loosely dashdotted'] = (1, 3, 0, 3), (1, 1, 1, 1)\n        self['densely dashdotdotted'] = (1, 1, 0, 1, 0, 1), (1, 1, 1, 1)\n        self['dashdotdotted'] = (1, 2, 0, 2, 0, 2), (1, 1, 1, 1, 1, 1)\n        self['loosely dashdotdotted'] = (1, 3, 0, 3, 0, 3), (1, 1, 1, 1)\n\n        self._dirty = True\n\n    def __getitem__(self, key):\n        return self._atlas[key]\n\n    def __setitem__(self, key, value):\n        data, period = self.make_pattern(value[0], value[1])\n        self._data[self._index] = data\n        self._atlas[key] = [self._index / float(self._data.shape[0]), period]\n        self._index += 1\n        self._dirty = True\n        # self.add_pattern(value)\n\n    def make_pattern(self, pattern, caps=[1, 1]):\n        \"\"\" \"\"\"\n\n        # A pattern is defined as on/off sequence of segments\n        # It must be a multiple of 2\n        if len(pattern) > 1 and len(pattern) % 2:\n            pattern = [pattern[0] + pattern[-1]] + pattern[1:-1]\n        P = np.array(pattern)\n\n        # Period is the sum of all segment length\n        period = np.cumsum(P)[-1]\n\n        # Find all start and end of on-segment only\n        C, c = [], 0\n        for i in range(0, len(P) + 2, 2):\n            a = max(0.0001, P[i % len(P)])\n            b = max(0.0001, P[(i + 1) % len(P)])\n            C.extend([c, c + a])\n            c += a + b\n        C = np.array(C)\n\n        # Build pattern\n        length = self._data.shape[1]\n        Z = np.zeros((length, 4), dtype=np.float32)\n        for i in np.arange(0, len(Z)):\n            x = period * (i) / float(len(Z) - 1)\n            index = np.argmin(abs(C - (x)))\n            if index % 2 == 0:\n                if x <= C[index]:\n                    dash_type = +1\n                else:\n                    dash_type = 0\n                dash_start, dash_end = C[index], C[index + 1]\n            else:\n                if x > C[index]:\n                    dash_type = -1\n                else:\n                    dash_type = 0\n                dash_start, dash_end = C[index - 1], C[index]\n            Z[i] = C[index], dash_type, dash_start, dash_end\n        return Z, period",
  "def __init__(self, shape=(64, 1024, 4)):\n        # 512 patterns at max\n        self._data = np.zeros(shape, dtype=np.float32)\n        self._index = 0\n        self._atlas = {}\n\n        self['solid'] = (1e20, 0), (1, 1)\n        self['densely dotted'] = (0, 1), (1, 1)\n        self['dotted'] = (0, 2), (1, 1)\n        self['loosely dotted'] = (0, 3), (1, 1)\n        self['densely dashed'] = (1, 1), (1, 1)\n        self['dashed'] = (1, 2), (1, 1)\n        self['loosely dashed'] = (1, 4), (1, 1)\n        self['densely dashdotted'] = (1, 1, 0, 1), (1, 1, 1, 1)\n        self['dashdotted'] = (1, 2, 0, 2), (1, 1, 1, 1)\n        self['loosely dashdotted'] = (1, 3, 0, 3), (1, 1, 1, 1)\n        self['densely dashdotdotted'] = (1, 1, 0, 1, 0, 1), (1, 1, 1, 1)\n        self['dashdotdotted'] = (1, 2, 0, 2, 0, 2), (1, 1, 1, 1, 1, 1)\n        self['loosely dashdotdotted'] = (1, 3, 0, 3, 0, 3), (1, 1, 1, 1)\n\n        self._dirty = True",
  "def __getitem__(self, key):\n        return self._atlas[key]",
  "def __setitem__(self, key, value):\n        data, period = self.make_pattern(value[0], value[1])\n        self._data[self._index] = data\n        self._atlas[key] = [self._index / float(self._data.shape[0]), period]\n        self._index += 1\n        self._dirty = True",
  "def make_pattern(self, pattern, caps=[1, 1]):\n        \"\"\" \"\"\"\n\n        # A pattern is defined as on/off sequence of segments\n        # It must be a multiple of 2\n        if len(pattern) > 1 and len(pattern) % 2:\n            pattern = [pattern[0] + pattern[-1]] + pattern[1:-1]\n        P = np.array(pattern)\n\n        # Period is the sum of all segment length\n        period = np.cumsum(P)[-1]\n\n        # Find all start and end of on-segment only\n        C, c = [], 0\n        for i in range(0, len(P) + 2, 2):\n            a = max(0.0001, P[i % len(P)])\n            b = max(0.0001, P[(i + 1) % len(P)])\n            C.extend([c, c + a])\n            c += a + b\n        C = np.array(C)\n\n        # Build pattern\n        length = self._data.shape[1]\n        Z = np.zeros((length, 4), dtype=np.float32)\n        for i in np.arange(0, len(Z)):\n            x = period * (i) / float(len(Z) - 1)\n            index = np.argmin(abs(C - (x)))\n            if index % 2 == 0:\n                if x <= C[index]:\n                    dash_type = +1\n                else:\n                    dash_type = 0\n                dash_start, dash_end = C[index], C[index + 1]\n            else:\n                if x > C[index]:\n                    dash_type = -1\n                else:\n                    dash_type = 0\n                dash_start, dash_end = C[index - 1], C[index]\n            Z[i] = C[index], dash_type, dash_start, dash_end\n        return Z, period",
  "class TransformSystem(object):\n    \"\"\"TransformSystem encapsulates information about the coordinate\n    systems needed to draw a Visual.\n\n    Visual rendering operates in six coordinate systems:\n\n    * **Visual** - arbitrary local coordinate frame of the visual. Vertex\n      buffers used by the visual are usually specified in this coordinate\n      system.\n\n    * **Scene** - This is an isometric coordinate system used mainly for \n      lighting calculations.\n\n    * **Document** - This coordinate system has units of _logical_ pixels, and\n      should usually represent the pixel coordinates of the canvas being drawn\n      to. Visuals use this coordinate system to make measurements for font\n      size, line width, and in general anything that is specified in physical\n      units (px, pt, mm, in, etc.). In most circumstances, this is exactly the\n      same as the canvas coordinate system.\n\n    * **Canvas** - This coordinate system represents the logical pixel\n      coordinates of the canvas. It has its origin in the top-left corner of\n      the canvas, and is typically the coordinate system that mouse and touch \n      events are reported in. Note that, by convention, _logical_ pixels\n      are not necessarily the same size as the _physical_ pixels in the\n      framebuffer that is being rendered to.\n\n    * **Framebuffer** - The buffer coordinate system has units of _physical_ \n      pixels, and should usually represent the coordinates of the current \n      framebuffer (on the canvas or an FBO) being rendered to. Visuals use this\n      coordinate system primarily for antialiasing calculations. It is also the\n      coorinate system used by glFragCoord. In most cases,\n      this will have the same scale as the document and canvas coordinate \n      systems because the active framebuffer is the\n      back buffer of the canvas, and the canvas will have _logical_ and\n      _physical_ pixels of the same size. However, the scale may be different\n      in the case of high-resolution displays, or when rendering to an \n      off-screen framebuffer with different scaling or boundaries than the\n      canvas.\n\n    * **Render** - This coordinate system is the obligatory system for\n      vertices returned by a vertex shader. It has coordinates (-1, -1) to\n      (1, 1) across the current glViewport. In OpenGL terminology, this is\n      called clip coordinates.\n\n    Parameters\n    ----------\n    canvas : Canvas\n        The canvas being drawn to.\n    dpi : float\n        The dot-per-inch resolution of the document coordinate system. By\n        default this is set to the resolution of the canvas.\n\n    Notes\n    -----\n    By default, TransformSystems are configured such that the document\n    coordinate system matches the logical pixels of the canvas,\n\n    Examples\n    --------\n    1. To convert local vertex coordinates to normalized device coordinates in\n    the vertex shader, we first need a vertex shader that supports configurable\n    transformations::\n\n        vec4 a_position;\n        void main() {\n            gl_Position = $transform(a_position);\n        }\n\n    Next, we supply the complete chain of transforms when drawing the visual:\n\n        def draw(tr_sys):\n            tr = tr_sys.get_full_transform()\n            self.program['transform'] = tr.shader_map()\n            self.program['a_position'] = self.vertex_buffer\n            self.program.draw('triangles')\n\n    2. Draw a line whose width is given in mm. To start, we need normal vectors\n    for each vertex, which tell us the direction the vertex should move in\n    order to set the line width::\n\n        vec4 a_position;\n        vec4 a_normal;\n        float u_line_width;\n        float u_dpi;\n        void main() {\n            // map vertex position and normal vector to the document cs\n            vec4 doc_pos = $visual_to_doc(a_position);\n            vec4 doc_normal = $visual_to_doc(a_position + a_normal) - doc_pos;\n\n            // Use DPI to convert mm line width to logical pixels\n            float px_width = (u_line_width / 25.4) * dpi;\n\n            // expand by line width\n            doc_pos += normalize(doc_normal) * px_width;\n\n            // finally, map the remainder of the way to normalized device\n            // coordinates.\n            gl_Position = $doc_to_render(a_position);\n        }\n\n    In this case, we need to access\n    the transforms independently, so ``get_full_transform()`` is not useful\n    here::\n\n        def draw(tr_sys):\n            # Send two parts of the full transform separately\n            self.program['visual_to_doc'] = tr_sys.visual_to_doc.shader_map()\n            doc_to_render = (tr_sys.framebuffer_transform *\n                             tr_sys.document_transform)\n            self.program['visual_to_doc'] = doc_to_render.shader_map()\n\n            self.program['u_line_width'] = self.line_width\n            self.program['u_dpi'] = tr_sys.dpi\n            self.program['a_position'] = self.vertex_buffer\n            self.program['a_normal'] = self.normal_buffer\n            self.program.draw('triangles')\n\n    3. Draw a triangle with antialiasing at the edge.\n\n    4. Using inverse transforms in the fragment shader\n    \"\"\"\n\n    def __init__(self, canvas=None, dpi=None):\n        self.changed = EventEmitter(source=self, type='transform_changed')\n        self._canvas = None\n        self._fbo_bounds = None\n        self.canvas = canvas\n        self._cache = TransformCache()\n        self._dpi = dpi\n        self._mappings = {'ct0': None, 'ct1': None, 'ft0': None}\n\n        # Assign a ChainTransform for each step. This allows us to always\n        # return the same transform objects regardless of how the user\n        # configures the system.\n        self._visual_transform = ChainTransform([NullTransform()])\n        self._scene_transform = ChainTransform([NullTransform()])\n        self._document_transform = ChainTransform([NullTransform()])\n        self._canvas_transform = ChainTransform([STTransform(),\n                                                 STTransform()])\n        self._framebuffer_transform = ChainTransform([STTransform()])\n\n        for tr in (self._visual_transform, self._scene_transform, \n                   self._document_transform, self._canvas_transform,\n                   self._framebuffer_transform):\n            tr.changed.connect(self.changed)\n\n    def _update_if_maps_changed(self, transform, map_key, new_maps):\n        \"\"\"Helper to store and check current (from, to) maps against new\n        ones being provided. The new mappings are only applied if a change\n        has occurred (and also stored in the current mappings).\n        \"\"\"\n        if self._mappings[map_key] is None:\n            self._mappings[map_key] = new_maps\n            transform.set_mapping(new_maps[0], new_maps[1])\n        else:\n            if np.any(self._mappings[map_key] != new_maps):\n                self._mappings[map_key] = new_maps\n                transform.set_mapping(new_maps[0], new_maps[1])\n\n    def configure(self, viewport=None, fbo_size=None, fbo_rect=None,\n                  canvas=None):\n        \"\"\"Automatically configure the TransformSystem:\n\n        * canvas_transform maps from the Canvas logical pixel\n          coordinate system to the framebuffer coordinate system, taking into \n          account the logical/physical pixel scale factor, current FBO \n          position, and y-axis inversion.\n        * framebuffer_transform maps from the current GL viewport on the\n          framebuffer coordinate system to clip coordinates (-1 to 1). \n\n\n        Parameters\n        ==========\n        viewport : tuple or None\n            The GL viewport rectangle (x, y, w, h). If None, then it\n            is assumed to cover the entire canvas.\n        fbo_size : tuple or None\n            The size of the active FBO. If None, then it is assumed to have the\n            same size as the canvas's framebuffer.\n        fbo_rect : tuple or None\n            The position and size (x, y, w, h) of the FBO in the coordinate\n            system of the canvas's framebuffer. If None, then the bounds are\n            assumed to cover the entire active framebuffer.\n        canvas : Canvas instance\n            Optionally set the canvas for this TransformSystem. See the \n            `canvas` property.\n        \"\"\"\n        # TODO: check that d2f and f2r transforms still contain a single\n        # STTransform (if the user has modified these, then auto-config should\n        # either fail or replace the transforms)\n        if canvas is not None:\n            self.canvas = canvas\n        canvas = self._canvas\n        if canvas is None:\n            raise RuntimeError(\"No canvas assigned to this TransformSystem.\")\n\n        # By default, this should invert the y axis--canvas origin is in top\n        # left, whereas framebuffer origin is in bottom left.\n        map_from = [(0, 0), canvas.size]\n        map_to = [(0, canvas.physical_size[1]), (canvas.physical_size[0], 0)]\n        self._update_if_maps_changed(self._canvas_transform.transforms[1],\n                                     'ct1', np.array((map_from, map_to)))\n        if fbo_rect is None:\n            self._canvas_transform.transforms[0].scale = (1, 1, 1)\n            self._canvas_transform.transforms[0].translate = (0, 0, 0)\n        else:\n            # Map into FBO coordinates\n            map_from = [(fbo_rect[0], fbo_rect[1]),\n                        (fbo_rect[0] + fbo_rect[2], fbo_rect[1] + fbo_rect[3])]\n            map_to = [(0, 0), fbo_size]\n            self._update_if_maps_changed(self._canvas_transform.transforms[0],\n                                         'ct0', np.array((map_from, map_to)))\n        if viewport is None:\n            if fbo_size is None:\n                # viewport covers entire canvas\n                map_from = [(0, 0), canvas.physical_size]\n            else:\n                # viewport covers entire FBO\n                map_from = [(0, 0), fbo_size]\n        else:\n            map_from = [viewport[:2], \n                        (viewport[0] + viewport[2], viewport[1] + viewport[3])]\n        map_to = [(-1, -1), (1, 1)]\n        self._update_if_maps_changed(self._framebuffer_transform.transforms[0],\n                                     'ft0', np.array((map_from, map_to)))\n\n    @property\n    def canvas(self):\n        \"\"\"The Canvas being drawn to.\"\"\"\n        return self._canvas\n\n    @canvas.setter\n    def canvas(self, canvas):\n        self._canvas = canvas\n\n    @property\n    def dpi(self):\n        \"\"\"Physical resolution of the document coordinate system (dots per inch).\"\"\"\n        if self._dpi is None:\n            if self._canvas is None:\n                return None\n            else:\n                return self.canvas.dpi\n        else:\n            return self._dpi\n\n    @dpi.setter\n    def dpi(self, dpi):\n        assert dpi > 0\n        self._dpi = dpi\n\n    @property\n    def visual_transform(self):\n        \"\"\"Transform mapping from visual local coordinate frame to scene coordinate frame.\"\"\"\n        return self._visual_transform\n\n    @visual_transform.setter\n    def visual_transform(self, tr):\n        self._visual_transform.transforms = tr\n\n    @property\n    def scene_transform(self):\n        \"\"\"Transform mapping from scene coordinate frame to document coordinate frame.\"\"\"\n        return self._scene_transform\n\n    @scene_transform.setter\n    def scene_transform(self, tr):\n        self._scene_transform.transforms = tr\n\n    @property\n    def document_transform(self):\n        \"\"\"Transform mapping from document coordinate frame to the framebuffer (physical pixel) coordinate frame.\"\"\"\n        return self._document_transform\n\n    @document_transform.setter\n    def document_transform(self, tr):\n        self._document_transform.transforms = tr\n\n    @property\n    def canvas_transform(self):\n        \"\"\"Transform mapping from canvas coordinate frame to framebuffer coordinate frame.\"\"\"\n        return self._canvas_transform\n\n    @canvas_transform.setter\n    def canvas_transform(self, tr):\n        self._canvas_transform.transforms = tr\n\n    @property\n    def framebuffer_transform(self):\n        \"\"\"Transform mapping from pixel coordinate frame to rendering coordinate frame.\"\"\"\n        return self._framebuffer_transform\n\n    @framebuffer_transform.setter\n    def framebuffer_transform(self, tr):\n        self._framebuffer_transform.transforms = tr\n\n    def get_transform(self, map_from='visual', map_to='render'):\n        \"\"\"Return a transform mapping between any two coordinate systems.\n\n        Parameters\n        ----------\n        map_from : str\n            The starting coordinate system to map from. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        map_to : str\n            The ending coordinate system to map to. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        \"\"\"\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        ifrom = tr.index(map_from)\n        ito = tr.index(map_to)\n\n        if ifrom < ito:\n            trs = [getattr(self, '_' + t + '_transform')\n                   for t in tr[ifrom:ito]][::-1]\n        else:\n            trs = [getattr(self, '_' + t + '_transform').inverse\n                   for t in tr[ito:ifrom]]\n        return self._cache.get(trs)\n\n    @property\n    def pixel_scale(self):\n        tr = self._canvas_transform\n        return (tr.map((1, 0)) - tr.map((0, 0)))[0]",
  "def __init__(self, canvas=None, dpi=None):\n        self.changed = EventEmitter(source=self, type='transform_changed')\n        self._canvas = None\n        self._fbo_bounds = None\n        self.canvas = canvas\n        self._cache = TransformCache()\n        self._dpi = dpi\n        self._mappings = {'ct0': None, 'ct1': None, 'ft0': None}\n\n        # Assign a ChainTransform for each step. This allows us to always\n        # return the same transform objects regardless of how the user\n        # configures the system.\n        self._visual_transform = ChainTransform([NullTransform()])\n        self._scene_transform = ChainTransform([NullTransform()])\n        self._document_transform = ChainTransform([NullTransform()])\n        self._canvas_transform = ChainTransform([STTransform(),\n                                                 STTransform()])\n        self._framebuffer_transform = ChainTransform([STTransform()])\n\n        for tr in (self._visual_transform, self._scene_transform, \n                   self._document_transform, self._canvas_transform,\n                   self._framebuffer_transform):\n            tr.changed.connect(self.changed)",
  "def _update_if_maps_changed(self, transform, map_key, new_maps):\n        \"\"\"Helper to store and check current (from, to) maps against new\n        ones being provided. The new mappings are only applied if a change\n        has occurred (and also stored in the current mappings).\n        \"\"\"\n        if self._mappings[map_key] is None:\n            self._mappings[map_key] = new_maps\n            transform.set_mapping(new_maps[0], new_maps[1])\n        else:\n            if np.any(self._mappings[map_key] != new_maps):\n                self._mappings[map_key] = new_maps\n                transform.set_mapping(new_maps[0], new_maps[1])",
  "def configure(self, viewport=None, fbo_size=None, fbo_rect=None,\n                  canvas=None):\n        \"\"\"Automatically configure the TransformSystem:\n\n        * canvas_transform maps from the Canvas logical pixel\n          coordinate system to the framebuffer coordinate system, taking into \n          account the logical/physical pixel scale factor, current FBO \n          position, and y-axis inversion.\n        * framebuffer_transform maps from the current GL viewport on the\n          framebuffer coordinate system to clip coordinates (-1 to 1). \n\n\n        Parameters\n        ==========\n        viewport : tuple or None\n            The GL viewport rectangle (x, y, w, h). If None, then it\n            is assumed to cover the entire canvas.\n        fbo_size : tuple or None\n            The size of the active FBO. If None, then it is assumed to have the\n            same size as the canvas's framebuffer.\n        fbo_rect : tuple or None\n            The position and size (x, y, w, h) of the FBO in the coordinate\n            system of the canvas's framebuffer. If None, then the bounds are\n            assumed to cover the entire active framebuffer.\n        canvas : Canvas instance\n            Optionally set the canvas for this TransformSystem. See the \n            `canvas` property.\n        \"\"\"\n        # TODO: check that d2f and f2r transforms still contain a single\n        # STTransform (if the user has modified these, then auto-config should\n        # either fail or replace the transforms)\n        if canvas is not None:\n            self.canvas = canvas\n        canvas = self._canvas\n        if canvas is None:\n            raise RuntimeError(\"No canvas assigned to this TransformSystem.\")\n\n        # By default, this should invert the y axis--canvas origin is in top\n        # left, whereas framebuffer origin is in bottom left.\n        map_from = [(0, 0), canvas.size]\n        map_to = [(0, canvas.physical_size[1]), (canvas.physical_size[0], 0)]\n        self._update_if_maps_changed(self._canvas_transform.transforms[1],\n                                     'ct1', np.array((map_from, map_to)))\n        if fbo_rect is None:\n            self._canvas_transform.transforms[0].scale = (1, 1, 1)\n            self._canvas_transform.transforms[0].translate = (0, 0, 0)\n        else:\n            # Map into FBO coordinates\n            map_from = [(fbo_rect[0], fbo_rect[1]),\n                        (fbo_rect[0] + fbo_rect[2], fbo_rect[1] + fbo_rect[3])]\n            map_to = [(0, 0), fbo_size]\n            self._update_if_maps_changed(self._canvas_transform.transforms[0],\n                                         'ct0', np.array((map_from, map_to)))\n        if viewport is None:\n            if fbo_size is None:\n                # viewport covers entire canvas\n                map_from = [(0, 0), canvas.physical_size]\n            else:\n                # viewport covers entire FBO\n                map_from = [(0, 0), fbo_size]\n        else:\n            map_from = [viewport[:2], \n                        (viewport[0] + viewport[2], viewport[1] + viewport[3])]\n        map_to = [(-1, -1), (1, 1)]\n        self._update_if_maps_changed(self._framebuffer_transform.transforms[0],\n                                     'ft0', np.array((map_from, map_to)))",
  "def canvas(self):\n        \"\"\"The Canvas being drawn to.\"\"\"\n        return self._canvas",
  "def canvas(self, canvas):\n        self._canvas = canvas",
  "def dpi(self):\n        \"\"\"Physical resolution of the document coordinate system (dots per inch).\"\"\"\n        if self._dpi is None:\n            if self._canvas is None:\n                return None\n            else:\n                return self.canvas.dpi\n        else:\n            return self._dpi",
  "def dpi(self, dpi):\n        assert dpi > 0\n        self._dpi = dpi",
  "def visual_transform(self):\n        \"\"\"Transform mapping from visual local coordinate frame to scene coordinate frame.\"\"\"\n        return self._visual_transform",
  "def visual_transform(self, tr):\n        self._visual_transform.transforms = tr",
  "def scene_transform(self):\n        \"\"\"Transform mapping from scene coordinate frame to document coordinate frame.\"\"\"\n        return self._scene_transform",
  "def scene_transform(self, tr):\n        self._scene_transform.transforms = tr",
  "def document_transform(self):\n        \"\"\"Transform mapping from document coordinate frame to the framebuffer (physical pixel) coordinate frame.\"\"\"\n        return self._document_transform",
  "def document_transform(self, tr):\n        self._document_transform.transforms = tr",
  "def canvas_transform(self):\n        \"\"\"Transform mapping from canvas coordinate frame to framebuffer coordinate frame.\"\"\"\n        return self._canvas_transform",
  "def canvas_transform(self, tr):\n        self._canvas_transform.transforms = tr",
  "def framebuffer_transform(self):\n        \"\"\"Transform mapping from pixel coordinate frame to rendering coordinate frame.\"\"\"\n        return self._framebuffer_transform",
  "def framebuffer_transform(self, tr):\n        self._framebuffer_transform.transforms = tr",
  "def get_transform(self, map_from='visual', map_to='render'):\n        \"\"\"Return a transform mapping between any two coordinate systems.\n\n        Parameters\n        ----------\n        map_from : str\n            The starting coordinate system to map from. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        map_to : str\n            The ending coordinate system to map to. Must be one of: visual,\n            scene, document, canvas, framebuffer, or render.\n        \"\"\"\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        ifrom = tr.index(map_from)\n        ito = tr.index(map_to)\n\n        if ifrom < ito:\n            trs = [getattr(self, '_' + t + '_transform')\n                   for t in tr[ifrom:ito]][::-1]\n        else:\n            trs = [getattr(self, '_' + t + '_transform').inverse\n                   for t in tr[ito:ifrom]]\n        return self._cache.get(trs)",
  "def pixel_scale(self):\n        tr = self._canvas_transform\n        return (tr.map((1, 0)) - tr.map((0, 0)))[0]",
  "class BaseTransform(object):\n    \"\"\"\n    BaseTransform is a base class that defines a pair of complementary\n    coordinate mapping functions in both python and GLSL.\n\n    All BaseTransform subclasses define map() and imap() methods that map\n    an object through the forward or inverse transformation, respectively.\n\n    The two class variables glsl_map and glsl_imap are instances of\n    shaders.Function that define the forward- and inverse-mapping GLSL\n    function code.\n\n    Optionally, an inverse() method returns a new transform performing the\n    inverse mapping.\n\n    Note that although all classes should define both map() and imap(), it\n    is not necessarily the case that imap(map(x)) == x; there may be instances\n    where the inverse mapping is ambiguous or otherwise meaningless.\n    \"\"\"\n\n    glsl_map = None  # Must be GLSL code\n    glsl_imap = None\n\n    # Flags used to describe the transformation. Subclasses should define each\n    # as True or False.\n    # (usually used for making optimization decisions)\n\n    # If True, then for any 3 colinear points, the\n    # transformed points will also be colinear.\n    Linear = None\n\n    # The transformation's effect on one axis is independent\n    # of the input position along any other axis.\n    Orthogonal = None\n\n    # If True, then the distance between two points is the\n    # same as the distance between the transformed points.\n    NonScaling = None\n\n    # Scale factors are applied equally to all axes.\n    Isometric = None\n\n    def __init__(self):\n        self._inverse = None\n        self._dynamic = False\n        self.changed = EventEmitter(source=self, type='transform_changed')\n        if self.glsl_map is not None:\n            self._shader_map = Function(self.glsl_map)\n        if self.glsl_imap is not None:\n            self._shader_imap = Function(self.glsl_imap)\n\n    def map(self, obj):\n        \"\"\"\n        Return *obj* mapped through the forward transformation.\n\n        Parameters\n        ----------\n            obj : tuple (x,y) or (x,y,z)\n                  array with shape (..., 2) or (..., 3)\n        \"\"\"\n        raise NotImplementedError()\n\n    def imap(self, obj):\n        \"\"\"\n        Return *obj* mapped through the inverse transformation.\n\n        Parameters\n        ----------\n            obj : tuple (x,y) or (x,y,z)\n                  array with shape (..., 2) or (..., 3)\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def inverse(self):\n        \"\"\"The inverse of this transform.\"\"\"\n        if self._inverse is None:\n            self._inverse = InverseTransform(self)\n        return self._inverse\n\n    @property\n    def dynamic(self):\n        \"\"\"Boolean flag that indicates whether this transform is expected to \n        change frequently.\n\n        Transforms that are flagged as dynamic will not be collapsed in \n        ``ChainTransform.simplified``. This allows changes to the transform\n        to propagate through the chain without requiring the chain to be\n        re-simplified.\n        \"\"\"\n        return self._dynamic\n\n    @dynamic.setter\n    def dynamic(self, d):\n        self._dynamic = d\n\n    def shader_map(self):\n        \"\"\"\n        Return a shader Function that accepts only a single vec4 argument\n        and defines new attributes / uniforms supplying the Function with\n        any static input.\n        \"\"\"\n        return self._shader_map\n\n    def shader_imap(self):\n        \"\"\"See shader_map.\"\"\"\n        return self._shader_imap\n\n    def _shader_object(self):\n        \"\"\"This method allows transforms to be assigned directly to shader\n        template variables. \n\n        Example::\n\n            code = 'void main() { gl_Position = $transform($position); }'\n            func = shaders.Function(code)\n            tr = STTransform()\n            func['transform'] = tr  # use tr's forward mapping for $function\n        \"\"\"\n        return self.shader_map()\n\n    def update(self, *args):\n        \"\"\"Called to inform any listeners that this transform has changed.\"\"\"\n        self.changed(*args)\n\n    def __mul__(self, tr):\n        \"\"\"\n        Transform multiplication returns a new transform that is equivalent to\n        the two operands performed in series.\n\n        By default, multiplying two Transforms `A * B` will return\n        ChainTransform([A, B]). Subclasses may redefine this operation to\n        return more optimized results.\n\n        To ensure that both operands have a chance to simplify the operation,\n        all subclasses should follow the same procedure. For `A * B`:\n\n        1. A.__mul__(B) attempts to generate an optimized transform product.\n        2. If that fails, it must:\n\n               * return super(A).__mul__(B) OR\n               * return NotImplemented if the superclass would return an\n                 invalid result.\n\n        3. When BaseTransform.__mul__(A, B) is called, it returns \n           NotImplemented, which causes B.__rmul__(A) to be invoked.\n        4. B.__rmul__(A) attempts to generate an optimized transform product.\n        5. If that fails, it must:\n\n               * return super(B).__rmul__(A) OR\n               * return ChainTransform([B, A]) if the superclass would return\n                 an invalid result.\n\n        6. When BaseTransform.__rmul__(B, A) is called, ChainTransform([A, B])\n           is returned.\n        \"\"\"\n        # switch to __rmul__ attempts.\n        # Don't use the \"return NotImplemted\" trick, because that won't work if\n        # self and tr are of the same type.\n        return tr.__rmul__(self)\n\n    def __rmul__(self, tr):\n        return ChainTransform([tr, self])\n\n    def __repr__(self):\n        return \"<%s at 0x%x>\" % (self.__class__.__name__, id(self))\n\n    def __del__(self):\n        # we can remove ourselves from *all* events in this situation.\n        self.changed.disconnect()",
  "class InverseTransform(BaseTransform):\n    def __init__(self, transform):\n        BaseTransform.__init__(self)\n        self._inverse = transform\n        self.map = transform.imap\n        self.imap = transform.map\n\n    @property\n    def Linear(self):\n        return self._inverse.Linear\n\n    @property\n    def Orthogonal(self):\n        return self._inverse.Orthogonal\n\n    @property\n    def NonScaling(self):\n        return self._inverse.NonScaling\n\n    @property\n    def Isometric(self):\n        return self._inverse.Isometric\n\n    @property\n    def shader_map(self):\n        return self._inverse.shader_imap\n\n    @property\n    def shader_imap(self):\n        return self._inverse.shader_map\n\n    def __repr__(self):\n        return (\"<Inverse of %r>\" % repr(self._inverse))",
  "def __init__(self):\n        self._inverse = None\n        self._dynamic = False\n        self.changed = EventEmitter(source=self, type='transform_changed')\n        if self.glsl_map is not None:\n            self._shader_map = Function(self.glsl_map)\n        if self.glsl_imap is not None:\n            self._shader_imap = Function(self.glsl_imap)",
  "def map(self, obj):\n        \"\"\"\n        Return *obj* mapped through the forward transformation.\n\n        Parameters\n        ----------\n            obj : tuple (x,y) or (x,y,z)\n                  array with shape (..., 2) or (..., 3)\n        \"\"\"\n        raise NotImplementedError()",
  "def imap(self, obj):\n        \"\"\"\n        Return *obj* mapped through the inverse transformation.\n\n        Parameters\n        ----------\n            obj : tuple (x,y) or (x,y,z)\n                  array with shape (..., 2) or (..., 3)\n        \"\"\"\n        raise NotImplementedError()",
  "def inverse(self):\n        \"\"\"The inverse of this transform.\"\"\"\n        if self._inverse is None:\n            self._inverse = InverseTransform(self)\n        return self._inverse",
  "def dynamic(self):\n        \"\"\"Boolean flag that indicates whether this transform is expected to \n        change frequently.\n\n        Transforms that are flagged as dynamic will not be collapsed in \n        ``ChainTransform.simplified``. This allows changes to the transform\n        to propagate through the chain without requiring the chain to be\n        re-simplified.\n        \"\"\"\n        return self._dynamic",
  "def dynamic(self, d):\n        self._dynamic = d",
  "def shader_map(self):\n        \"\"\"\n        Return a shader Function that accepts only a single vec4 argument\n        and defines new attributes / uniforms supplying the Function with\n        any static input.\n        \"\"\"\n        return self._shader_map",
  "def shader_imap(self):\n        \"\"\"See shader_map.\"\"\"\n        return self._shader_imap",
  "def _shader_object(self):\n        \"\"\"This method allows transforms to be assigned directly to shader\n        template variables. \n\n        Example::\n\n            code = 'void main() { gl_Position = $transform($position); }'\n            func = shaders.Function(code)\n            tr = STTransform()\n            func['transform'] = tr  # use tr's forward mapping for $function\n        \"\"\"\n        return self.shader_map()",
  "def update(self, *args):\n        \"\"\"Called to inform any listeners that this transform has changed.\"\"\"\n        self.changed(*args)",
  "def __mul__(self, tr):\n        \"\"\"\n        Transform multiplication returns a new transform that is equivalent to\n        the two operands performed in series.\n\n        By default, multiplying two Transforms `A * B` will return\n        ChainTransform([A, B]). Subclasses may redefine this operation to\n        return more optimized results.\n\n        To ensure that both operands have a chance to simplify the operation,\n        all subclasses should follow the same procedure. For `A * B`:\n\n        1. A.__mul__(B) attempts to generate an optimized transform product.\n        2. If that fails, it must:\n\n               * return super(A).__mul__(B) OR\n               * return NotImplemented if the superclass would return an\n                 invalid result.\n\n        3. When BaseTransform.__mul__(A, B) is called, it returns \n           NotImplemented, which causes B.__rmul__(A) to be invoked.\n        4. B.__rmul__(A) attempts to generate an optimized transform product.\n        5. If that fails, it must:\n\n               * return super(B).__rmul__(A) OR\n               * return ChainTransform([B, A]) if the superclass would return\n                 an invalid result.\n\n        6. When BaseTransform.__rmul__(B, A) is called, ChainTransform([A, B])\n           is returned.\n        \"\"\"\n        # switch to __rmul__ attempts.\n        # Don't use the \"return NotImplemted\" trick, because that won't work if\n        # self and tr are of the same type.\n        return tr.__rmul__(self)",
  "def __rmul__(self, tr):\n        return ChainTransform([tr, self])",
  "def __repr__(self):\n        return \"<%s at 0x%x>\" % (self.__class__.__name__, id(self))",
  "def __del__(self):\n        # we can remove ourselves from *all* events in this situation.\n        self.changed.disconnect()",
  "def __init__(self, transform):\n        BaseTransform.__init__(self)\n        self._inverse = transform\n        self.map = transform.imap\n        self.imap = transform.map",
  "def Linear(self):\n        return self._inverse.Linear",
  "def Orthogonal(self):\n        return self._inverse.Orthogonal",
  "def NonScaling(self):\n        return self._inverse.NonScaling",
  "def Isometric(self):\n        return self._inverse.Isometric",
  "def shader_map(self):\n        return self._inverse.shader_imap",
  "def shader_imap(self):\n        return self._inverse.shader_map",
  "def __repr__(self):\n        return (\"<Inverse of %r>\" % repr(self._inverse))",
  "class LogTransform(BaseTransform):\n    \"\"\"Transform perfoming logarithmic transformation on three axes.\n\n    Maps (x, y, z) => (log(base.x, x), log(base.y, y), log(base.z, z))\n\n    No transformation is applied for axes with base == 0.\n\n    If base < 0, then the inverse function is applied: x => base.x ** x\n\n    Parameters\n    ----------\n    base : array-like\n        Base for the X, Y, Z axes.\n    \"\"\"\n\n    # TODO: Evaluate the performance costs of using conditionals.\n    # An alternative approach is to transpose the vector before\n    # log-transforming, and then transpose back afterward.\n    glsl_map = \"\"\"\n        vec4 LogTransform_map(vec4 pos) {\n            if($base.x > 1.0)\n                pos.x = log(pos.x) / log($base.x);\n            else if($base.x < -1.0)\n                pos.x = pow(-$base.x, pos.x);\n\n            if($base.y > 1.0)\n                pos.y = log(pos.y) / log($base.y);\n            else if($base.y < -1.0)\n                pos.y = pow(-$base.y, pos.y);\n\n            if($base.z > 1.0)\n                pos.z = log(pos.z) / log($base.z);\n            else if($base.z < -1.0)\n                pos.z = pow(-$base.z, pos.z);\n            return pos;\n        }\n        \"\"\"\n\n    glsl_imap = glsl_map\n\n    Linear = False\n    Orthogonal = True\n    NonScaling = False\n    Isometric = False\n\n    def __init__(self, base=None):\n        super(LogTransform, self).__init__()\n        self._base = np.zeros(3, dtype=np.float32)\n        self.base = (0.0, 0.0, 0.0) if base is None else base\n\n    @property\n    def base(self):\n        \"\"\"\n        *base* is a tuple (x, y, z) containing the log base that should be\n        applied to each axis of the input vector. If any axis has a base <= 0,\n        then that axis is not affected.\n        \"\"\"\n        return self._base.copy()\n\n    @base.setter\n    def base(self, s):\n        self._base[:len(s)] = s\n        self._base[len(s):] = 0.0\n\n    @arg_to_array\n    def map(self, coords, base=None):\n        ret = np.empty(coords.shape, coords.dtype)\n        if base is None:\n            base = self.base\n        for i in range(min(ret.shape[-1], 3)):\n            if base[i] > 1.0:\n                ret[..., i] = np.log(coords[..., i]) / np.log(base[i])\n            elif base[i] < -1.0:\n                ret[..., i] = -base[i] ** coords[..., i]\n            else:\n                ret[..., i] = coords[..., i]\n        return ret\n\n    @arg_to_array\n    def imap(self, coords):\n        return self.map(coords, -self.base)\n\n    def shader_map(self):\n        fn = super(LogTransform, self).shader_map()\n        fn['base'] = self.base  # uniform vec3\n        return fn\n\n    def shader_imap(self):\n        fn = super(LogTransform, self).shader_imap()\n        fn['base'] = -self.base  # uniform vec3\n        return fn\n\n    def __repr__(self):\n        return \"<LogTransform base=%s>\" % (self.base)",
  "class PolarTransform(BaseTransform):\n    \"\"\"Polar transform\n\n    Maps (theta, r, z) to (x, y, z), where `x = r*cos(theta)`\n    and `y = r*sin(theta)`.\n    \"\"\"\n\n    glsl_map = \"\"\"\n        vec4 polar_transform_map(vec4 pos) {\n            return vec4(pos.y * cos(pos.x), pos.y * sin(pos.x), pos.z, 1.);\n        }\n        \"\"\"\n\n    glsl_imap = \"\"\"\n        vec4 polar_transform_map(vec4 pos) {\n            // TODO: need some modulo math to handle larger theta values..?\n            float theta = atan(pos.y, pos.x);\n            float r = length(pos.xy);\n            return vec4(theta, r, pos.z, 1.);\n        }\n        \"\"\"\n\n    Linear = False\n    Orthogonal = False\n    NonScaling = False\n    Isometric = False\n\n    @arg_to_array\n    def map(self, coords):\n        ret = np.empty(coords.shape, coords.dtype)\n        ret[..., 0] = coords[..., 1] * np.cos(coords[..., 0])\n        ret[..., 1] = coords[..., 1] * np.sin(coords[..., 0])\n        for i in range(2, coords.shape[-1]):  # copy any further axes\n            ret[..., i] = coords[..., i]\n        return ret\n\n    @arg_to_array\n    def imap(self, coords):\n        ret = np.empty(coords.shape, coords.dtype)\n        ret[..., 0] = np.arctan2(coords[..., 0], coords[..., 1])\n        ret[..., 1] = (coords[..., 0]**2 + coords[..., 1]**2) ** 0.5\n        for i in range(2, coords.shape[-1]):  # copy any further axes\n            ret[..., i] = coords[..., i]\n        return ret",
  "class MagnifyTransform(BaseTransform):\n    \"\"\"Magnifying lens transform. \n\n    This transform causes a circular region to appear with larger scale around\n    its center point. \n\n    Parameters\n    ----------\n    mag : float\n        Magnification factor. Objects around the transform's center point will\n        appear scaled by this amount relative to objects outside the circle.\n    radii : (float, float)\n        Inner and outer radii of the \"lens\". Objects inside the inner radius\n        appear scaled, whereas objects outside the outer radius are unscaled,\n        and the scale factor transitions smoothly between the two radii.\n    center: (float, float)\n        The center (x, y) point of the \"lens\".\n\n    Notes\n    -----\n    This transform works by segmenting its input coordinates into three\n    regions--inner, outer, and transition. Coordinates in the inner region are\n    multiplied by a constant scale factor around the center point, and \n    coordinates in the transition region are scaled by a factor that \n    transitions smoothly from the inner radius to the outer radius. \n\n    Smooth functions that are appropriate for the transition region also tend \n    to be difficult to invert analytically, so this transform instead samples\n    the function numerically to allow trivial inversion. In OpenGL, the \n    sampling is implemented as a texture holding a lookup table.\n    \"\"\"\n\n    glsl_map = \"\"\"\n        vec4 mag_transform(vec4 pos) {\n            vec2 d = vec2(pos.x - $center.x, pos.y - $center.y);\n            float dist = length(d);\n            if (dist == 0. || dist > $radii.y || ($mag<1.01 && $mag>0.99)) {\n                return pos;\n            }\n            vec2 dir = d / dist;\n            \n            if( dist < $radii.x ) {\n                dist = dist * $mag;\n            }\n            else {\n                \n                float r1 = $radii.x;\n                float r2 = $radii.y;\n                float x = (dist - r1) / (r2 - r1);\n                float s = texture2D($trans, vec2(0., x)).r * $trans_max;\n                \n                dist = s;\n            }\n\n            d = $center + dir * dist;\n            return vec4(d, pos.z, pos.w);\n        }\"\"\"\n\n    glsl_imap = glsl_map\n\n    Linear = False\n\n    _trans_resolution = 1000\n\n    def __init__(self, mag=3, radii=(7, 10), center=(0, 0)):\n        self._center = center\n        self._mag = mag\n        self._radii = radii\n        self._trans = None\n        res = self._trans_resolution\n        self._trans_tex = (gloo.Texture2D((res, 1, 1), interpolation='linear'), \n                           gloo.Texture2D((res, 1, 1), interpolation='linear'))\n        self._trans_tex_max = None\n        super(MagnifyTransform, self).__init__()\n\n    @property\n    def center(self):\n        \"\"\"The (x, y) center point of the transform.\"\"\"\n        return self._center\n\n    @center.setter\n    def center(self, center):\n        if np.allclose(self._center, center):\n            return\n        self._center = center\n        self.shader_map()\n        self.shader_imap()\n\n    @property\n    def mag(self):\n        \"\"\"The scale factor used in the central region of the transform.\"\"\"\n        return self._mag\n\n    @mag.setter\n    def mag(self, mag):\n        if self._mag == mag:\n            return\n        self._mag = mag\n        self._trans = None\n        self.shader_map()\n        self.shader_imap()\n\n    @property\n    def radii(self):\n        \"\"\"The inner and outer radii of the circular area bounding the transform.\"\"\"\n        return self._radii\n\n    @radii.setter\n    def radii(self, radii):\n        if np.allclose(self._radii, radii):\n            return\n        self._radii = radii\n        self._trans = None\n        self.shader_map()\n        self.shader_imap()\n\n    def shader_map(self):\n        fn = super(MagnifyTransform, self).shader_map()\n        fn['center'] = self._center  # uniform vec2\n        fn['mag'] = float(self._mag)\n        fn['radii'] = (self._radii[0] / float(self._mag), self._radii[1])\n        self._get_transition()  # make sure transition texture is up to date\n        fn['trans'] = self._trans_tex[0]\n        fn['trans_max'] = self._trans_tex_max[0]\n        return fn\n\n    def shader_imap(self):\n        fn = super(MagnifyTransform, self).shader_imap()\n        fn['center'] = self._center  # uniform vec2\n        fn['mag'] = 1. / self._mag\n        fn['radii'] = self._radii\n        self._get_transition()  # make sure transition texture is up to date\n        fn['trans'] = self._trans_tex[1]\n        fn['trans_max'] = self._trans_tex_max[1]\n        return fn\n\n    @arg_to_vec4\n    def map(self, x, _inverse=False):\n        c = as_vec4(self.center)[0]\n        m = self.mag\n        r1, r2 = self.radii\n\n        xm = np.empty(x.shape, dtype=x.dtype)\n\n        dx = (x - c)\n        dist = (((dx**2).sum(axis=-1)) ** 0.5)[..., np.newaxis]\n        dist[np.isnan(dist)] = 0\n        unit = dx / np.where(dist != 0, dist, 1)\n        # magnified center region\n        if _inverse:\n            inner = (dist < r1)[:, 0]\n            s = dist / m\n        else:\n            inner = (dist < (r1 / m))[:, 0]\n            s = dist * m\n        xm[inner] = c + unit[inner] * s[inner]\n\n        # unmagnified outer region\n        outer = (dist > r2)[:, 0]  \n        xm[outer] = x[outer]\n\n        # smooth transition region, interpolated from trans\n        trans = ~(inner | outer)\n\n        # look up scale factor from trans\n        temp, itemp = self._get_transition()\n        if _inverse:\n            tind = (dist[trans] - r1) * len(itemp) / (r2 - r1)\n            temp = itemp\n        else:\n            tind = (dist[trans] - (r1/m)) * len(temp) / (r2 - (r1/m))\n        tind = np.clip(tind, 0, temp.shape[0]-1)\n        s = temp[tind.astype(int)]\n\n        xm[trans] = c + unit[trans] * s\n        return xm\n\n    def imap(self, coords):\n        return self.map(coords, _inverse=True)\n\n    def _get_transition(self):\n        # Generate forward/reverse transition templates.\n        # We would prefer to express this with an invertible function, but that\n        # turns out to be tricky. The templates make any function invertible.\n\n        if self._trans is None:\n            m, r1, r2 = self.mag, self.radii[0], self.radii[1]\n            res = self._trans_resolution\n\n            xi = np.linspace(r1, r2, res)\n            t = 0.5 * (1 + np.cos((xi - r2) * np.pi / (r2 - r1)))\n            yi = (xi * t + xi * (1-t) / m).astype(np.float32)\n            x = np.linspace(r1 / m, r2, res)\n            y = np.interp(x, yi, xi).astype(np.float32)\n\n            self._trans = (y, yi)\n            # scale to 0.0-1.0 to prevent clipping (is this necessary?)\n            mx = y.max(), yi.max()\n            self._trans_tex_max = mx\n            self._trans_tex[0].set_data((y/mx[0])[:, np.newaxis, np.newaxis])\n            self._trans_tex[1].set_data((yi/mx[1])[:, np.newaxis, np.newaxis])\n\n        return self._trans",
  "class Magnify1DTransform(MagnifyTransform):\n    \"\"\"A 1-dimensional analog of MagnifyTransform. This transform expands \n    its input along the x-axis, around a center x value.\n    \"\"\"\n\n    glsl_map = \"\"\"\n        vec4 mag_transform(vec4 pos) {\n            float dist = pos.x - $center.x;\n            if (dist == 0. || abs(dist) > $radii.y || $mag == 1) {\n                return pos;\n            }\n            float dir = dist / abs(dist);\n            \n            if( abs(dist) < $radii.x ) {\n                dist = dist * $mag;\n            }\n            else {\n                float r1 = $radii.x;\n                float r2 = $radii.y;\n                float x = (abs(dist) - r1) / (r2 - r1);\n                dist = dir * texture2D($trans, vec2(0., x)).r * $trans_max;\n            }\n\n            return vec4($center.x + dist, pos.y, pos.z, pos.w);\n        }\"\"\"\n\n    glsl_imap = glsl_map",
  "def __init__(self, base=None):\n        super(LogTransform, self).__init__()\n        self._base = np.zeros(3, dtype=np.float32)\n        self.base = (0.0, 0.0, 0.0) if base is None else base",
  "def base(self):\n        \"\"\"\n        *base* is a tuple (x, y, z) containing the log base that should be\n        applied to each axis of the input vector. If any axis has a base <= 0,\n        then that axis is not affected.\n        \"\"\"\n        return self._base.copy()",
  "def base(self, s):\n        self._base[:len(s)] = s\n        self._base[len(s):] = 0.0",
  "def map(self, coords, base=None):\n        ret = np.empty(coords.shape, coords.dtype)\n        if base is None:\n            base = self.base\n        for i in range(min(ret.shape[-1], 3)):\n            if base[i] > 1.0:\n                ret[..., i] = np.log(coords[..., i]) / np.log(base[i])\n            elif base[i] < -1.0:\n                ret[..., i] = -base[i] ** coords[..., i]\n            else:\n                ret[..., i] = coords[..., i]\n        return ret",
  "def imap(self, coords):\n        return self.map(coords, -self.base)",
  "def shader_map(self):\n        fn = super(LogTransform, self).shader_map()\n        fn['base'] = self.base  # uniform vec3\n        return fn",
  "def shader_imap(self):\n        fn = super(LogTransform, self).shader_imap()\n        fn['base'] = -self.base  # uniform vec3\n        return fn",
  "def __repr__(self):\n        return \"<LogTransform base=%s>\" % (self.base)",
  "def map(self, coords):\n        ret = np.empty(coords.shape, coords.dtype)\n        ret[..., 0] = coords[..., 1] * np.cos(coords[..., 0])\n        ret[..., 1] = coords[..., 1] * np.sin(coords[..., 0])\n        for i in range(2, coords.shape[-1]):  # copy any further axes\n            ret[..., i] = coords[..., i]\n        return ret",
  "def imap(self, coords):\n        ret = np.empty(coords.shape, coords.dtype)\n        ret[..., 0] = np.arctan2(coords[..., 0], coords[..., 1])\n        ret[..., 1] = (coords[..., 0]**2 + coords[..., 1]**2) ** 0.5\n        for i in range(2, coords.shape[-1]):  # copy any further axes\n            ret[..., i] = coords[..., i]\n        return ret",
  "def __init__(self, mag=3, radii=(7, 10), center=(0, 0)):\n        self._center = center\n        self._mag = mag\n        self._radii = radii\n        self._trans = None\n        res = self._trans_resolution\n        self._trans_tex = (gloo.Texture2D((res, 1, 1), interpolation='linear'), \n                           gloo.Texture2D((res, 1, 1), interpolation='linear'))\n        self._trans_tex_max = None\n        super(MagnifyTransform, self).__init__()",
  "def center(self):\n        \"\"\"The (x, y) center point of the transform.\"\"\"\n        return self._center",
  "def center(self, center):\n        if np.allclose(self._center, center):\n            return\n        self._center = center\n        self.shader_map()\n        self.shader_imap()",
  "def mag(self):\n        \"\"\"The scale factor used in the central region of the transform.\"\"\"\n        return self._mag",
  "def mag(self, mag):\n        if self._mag == mag:\n            return\n        self._mag = mag\n        self._trans = None\n        self.shader_map()\n        self.shader_imap()",
  "def radii(self):\n        \"\"\"The inner and outer radii of the circular area bounding the transform.\"\"\"\n        return self._radii",
  "def radii(self, radii):\n        if np.allclose(self._radii, radii):\n            return\n        self._radii = radii\n        self._trans = None\n        self.shader_map()\n        self.shader_imap()",
  "def shader_map(self):\n        fn = super(MagnifyTransform, self).shader_map()\n        fn['center'] = self._center  # uniform vec2\n        fn['mag'] = float(self._mag)\n        fn['radii'] = (self._radii[0] / float(self._mag), self._radii[1])\n        self._get_transition()  # make sure transition texture is up to date\n        fn['trans'] = self._trans_tex[0]\n        fn['trans_max'] = self._trans_tex_max[0]\n        return fn",
  "def shader_imap(self):\n        fn = super(MagnifyTransform, self).shader_imap()\n        fn['center'] = self._center  # uniform vec2\n        fn['mag'] = 1. / self._mag\n        fn['radii'] = self._radii\n        self._get_transition()  # make sure transition texture is up to date\n        fn['trans'] = self._trans_tex[1]\n        fn['trans_max'] = self._trans_tex_max[1]\n        return fn",
  "def map(self, x, _inverse=False):\n        c = as_vec4(self.center)[0]\n        m = self.mag\n        r1, r2 = self.radii\n\n        xm = np.empty(x.shape, dtype=x.dtype)\n\n        dx = (x - c)\n        dist = (((dx**2).sum(axis=-1)) ** 0.5)[..., np.newaxis]\n        dist[np.isnan(dist)] = 0\n        unit = dx / np.where(dist != 0, dist, 1)\n        # magnified center region\n        if _inverse:\n            inner = (dist < r1)[:, 0]\n            s = dist / m\n        else:\n            inner = (dist < (r1 / m))[:, 0]\n            s = dist * m\n        xm[inner] = c + unit[inner] * s[inner]\n\n        # unmagnified outer region\n        outer = (dist > r2)[:, 0]  \n        xm[outer] = x[outer]\n\n        # smooth transition region, interpolated from trans\n        trans = ~(inner | outer)\n\n        # look up scale factor from trans\n        temp, itemp = self._get_transition()\n        if _inverse:\n            tind = (dist[trans] - r1) * len(itemp) / (r2 - r1)\n            temp = itemp\n        else:\n            tind = (dist[trans] - (r1/m)) * len(temp) / (r2 - (r1/m))\n        tind = np.clip(tind, 0, temp.shape[0]-1)\n        s = temp[tind.astype(int)]\n\n        xm[trans] = c + unit[trans] * s\n        return xm",
  "def imap(self, coords):\n        return self.map(coords, _inverse=True)",
  "def _get_transition(self):\n        # Generate forward/reverse transition templates.\n        # We would prefer to express this with an invertible function, but that\n        # turns out to be tricky. The templates make any function invertible.\n\n        if self._trans is None:\n            m, r1, r2 = self.mag, self.radii[0], self.radii[1]\n            res = self._trans_resolution\n\n            xi = np.linspace(r1, r2, res)\n            t = 0.5 * (1 + np.cos((xi - r2) * np.pi / (r2 - r1)))\n            yi = (xi * t + xi * (1-t) / m).astype(np.float32)\n            x = np.linspace(r1 / m, r2, res)\n            y = np.interp(x, yi, xi).astype(np.float32)\n\n            self._trans = (y, yi)\n            # scale to 0.0-1.0 to prevent clipping (is this necessary?)\n            mx = y.max(), yi.max()\n            self._trans_tex_max = mx\n            self._trans_tex[0].set_data((y/mx[0])[:, np.newaxis, np.newaxis])\n            self._trans_tex[1].set_data((yi/mx[1])[:, np.newaxis, np.newaxis])\n\n        return self._trans",
  "class PanZoomTransform(STTransform):\n    \"\"\"Pan-zoom transform\n\n    Parameters\n    ----------\n    canvas : instance of Canvas | None\n        The canvas to attch to.\n    aspect : float | None\n        The aspect ratio to apply.\n    **kwargs : dict\n        Keyword arguments to pass to the underlying `STTransform`.\n    \"\"\"\n\n    def __init__(self, canvas=None, aspect=None, **kwargs):\n        self._aspect = aspect\n        self.attach(canvas)\n        STTransform.__init__(self, **kwargs)\n        self.on_resize(None)\n\n    def attach(self, canvas):\n        \"\"\"Attach this tranform to a canvas\n\n        Parameters\n        ----------\n        canvas : instance of Canvas\n            The canvas.\n        \"\"\"\n        self._canvas = canvas\n        canvas.events.resize.connect(self.on_resize)\n        canvas.events.mouse_wheel.connect(self.on_mouse_wheel)\n        canvas.events.mouse_move.connect(self.on_mouse_move)\n\n    @property\n    def canvas_tr(self):\n        return STTransform.from_mapping(\n            [(0, 0), self._canvas.size],\n            [(-1, 1), (1, -1)])\n\n    def on_resize(self, event):\n        \"\"\"Resize handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._aspect is None:\n            return\n        w, h = self._canvas.size\n        aspect = self._aspect / (w / h)\n        self.scale = (self.scale[0], self.scale[0] / aspect)\n        self.shader_map()\n\n    def on_mouse_move(self, event):\n        \"\"\"Mouse move handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.is_dragging:\n            dxy = event.pos - event.last_event.pos\n            button = event.press_event.button\n\n            if button == 1:\n                dxy = self.canvas_tr.map(dxy)\n                o = self.canvas_tr.map([0, 0])\n                t = dxy - o\n                self.move(t)\n            elif button == 2:\n                center = self.canvas_tr.map(event.press_event.pos)\n                if self._aspect is None:\n                    self.zoom(np.exp(dxy * (0.01, -0.01)), center)\n                else:\n                    s = dxy[1] * -0.01\n                    self.zoom(np.exp(np.array([s, s])), center)\n\n            self.shader_map()\n\n    def on_mouse_wheel(self, event):\n        \"\"\"Mouse wheel handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.zoom(np.exp(event.delta * (0.01, -0.01)), event.pos)",
  "def __init__(self, canvas=None, aspect=None, **kwargs):\n        self._aspect = aspect\n        self.attach(canvas)\n        STTransform.__init__(self, **kwargs)\n        self.on_resize(None)",
  "def attach(self, canvas):\n        \"\"\"Attach this tranform to a canvas\n\n        Parameters\n        ----------\n        canvas : instance of Canvas\n            The canvas.\n        \"\"\"\n        self._canvas = canvas\n        canvas.events.resize.connect(self.on_resize)\n        canvas.events.mouse_wheel.connect(self.on_mouse_wheel)\n        canvas.events.mouse_move.connect(self.on_mouse_move)",
  "def canvas_tr(self):\n        return STTransform.from_mapping(\n            [(0, 0), self._canvas.size],\n            [(-1, 1), (1, -1)])",
  "def on_resize(self, event):\n        \"\"\"Resize handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._aspect is None:\n            return\n        w, h = self._canvas.size\n        aspect = self._aspect / (w / h)\n        self.scale = (self.scale[0], self.scale[0] / aspect)\n        self.shader_map()",
  "def on_mouse_move(self, event):\n        \"\"\"Mouse move handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.is_dragging:\n            dxy = event.pos - event.last_event.pos\n            button = event.press_event.button\n\n            if button == 1:\n                dxy = self.canvas_tr.map(dxy)\n                o = self.canvas_tr.map([0, 0])\n                t = dxy - o\n                self.move(t)\n            elif button == 2:\n                center = self.canvas_tr.map(event.press_event.pos)\n                if self._aspect is None:\n                    self.zoom(np.exp(dxy * (0.01, -0.01)), center)\n                else:\n                    s = dxy[1] * -0.01\n                    self.zoom(np.exp(np.array([s, s])), center)\n\n            self.shader_map()",
  "def on_mouse_wheel(self, event):\n        \"\"\"Mouse wheel handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.zoom(np.exp(event.delta * (0.01, -0.01)), event.pos)",
  "class ChainTransform(BaseTransform):\n    \"\"\"\n    BaseTransform subclass that performs a sequence of transformations in\n    order. Internally, this class uses shaders.FunctionChain to generate\n    its glsl_map and glsl_imap functions.\n\n    Parameters\n    ----------\n    transforms : list of BaseTransform instances\n        See ``transforms`` property.\n    \"\"\"\n\n    glsl_map = None\n    glsl_imap = None\n\n    Linear = False\n    Orthogonal = False\n    NonScaling = False\n    Isometric = False\n\n    def __init__(self, *transforms):\n        super(ChainTransform, self).__init__()\n        self._transforms = []\n        self._simplified = None\n        self._null_transform = NullTransform()\n        nmap = self._null_transform.shader_map()\n\n        # ChainTransform does not have shader maps\n        self._shader_map = FunctionChain(\"transform_map_chain\", [nmap])\n        self._shader_imap = FunctionChain(\"transform_imap_chain\", [nmap])\n\n        # Set input transforms\n        trs = []\n        for tr in transforms:\n            if isinstance(tr, (tuple, list)):\n                trs.extend(tr)\n            else:\n                trs.append(tr)\n        self.transforms = trs\n\n    @property\n    def transforms(self):\n        \"\"\"The list of transform that make up the transform chain.\n\n        The order of transforms is given such that the last transform in the \n        list is the first to be invoked when mapping coordinates through \n        the chain. \n\n        For example, the following two mappings are equivalent::\n\n            # Map coordinates through individual transforms:\n            trans1 = STTransform(scale=(2, 3), translate=(0, 1))\n            trans2 = PolarTransform()\n            mapped = trans1.map(trans2.map(coords))\n\n            # Equivalent mapping through chain:\n            chain = ChainTransform([trans1, trans2])\n            mapped = chain.map(coords)\n        \"\"\"\n        return self._transforms\n\n    @transforms.setter\n    def transforms(self, tr):\n        if isinstance(tr, BaseTransform):\n            tr = [tr]\n        if not isinstance(tr, list):\n            raise TypeError(\"Transform chain must be a list\")\n\n        # Avoid extra effort if we already have the correct chain\n        if len(tr) == len(self._transforms):\n            changed = False\n            for i in range(len(tr)):\n                if tr[i] is not self._transforms[i]:\n                    changed = True\n                    break\n            if not changed:\n                return\n\n        for t in self._transforms:\n            t.changed.disconnect(self._subtr_changed)\n        self._transforms = tr\n        for t in self._transforms:\n            t.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()\n\n    @property\n    def simplified(self):\n        \"\"\"A simplified representation of the same transformation.\"\"\"\n        if self._simplified is None:\n            self._simplified = SimplifiedChainTransform(self)\n        return self._simplified\n\n    @property\n    def Linear(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Linear\n        return b\n\n    @property\n    def Orthogonal(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Orthogonal\n        return b\n\n    @property\n    def NonScaling(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.NonScaling\n        return b\n\n    @property\n    def Isometric(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Isometric\n        return b\n\n    def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        for tr in reversed(self.transforms):\n            coords = tr.map(coords)\n        return coords\n\n    def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        for tr in self.transforms:\n            coords = tr.imap(coords)\n        return coords\n\n    def shader_map(self):\n        return self._shader_map\n\n    def shader_imap(self):\n        return self._shader_imap\n\n    def _rebuild_shaders(self):\n        trs = self.transforms\n        if len(trs) == 0:\n            trs = [self._null_transform]\n        self._shader_map.functions = [tr.shader_map() for tr in reversed(trs)]\n        self._shader_imap.functions = [tr.shader_imap() for tr in trs]\n\n    def append(self, tr):\n        \"\"\"\n        Add a new transform to the end of this chain.\n\n        Parameters\n        ----------\n        tr : instance of Transform\n            The transform to use.\n        \"\"\"\n        self.transforms.append(tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()\n\n    def prepend(self, tr):\n        \"\"\"\n        Add a new transform to the beginning of this chain.\n\n        Parameters\n        ----------\n        tr : instance of Transform\n            The transform to use.\n        \"\"\"\n        self.transforms.insert(0, tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()\n\n    def _subtr_changed(self, ev):\n        \"\"\"One of the internal transforms changed; propagate the signal.\"\"\"\n        self.update(ev)\n\n    def __setitem__(self, index, tr):\n        self._transforms[index].changed.disconnect(self._subtr_changed)\n        self._transforms[index] = tr\n        tr.changed.connect(self.subtr_changed)\n        self._rebuild_shaders()\n        self.update()\n\n    def __mul__(self, tr):\n        if isinstance(tr, ChainTransform):\n            trs = tr.transforms\n        else:\n            trs = [tr]\n        return ChainTransform(self.transforms+trs)\n\n    def __rmul__(self, tr):\n        if isinstance(tr, ChainTransform):\n            trs = tr.transforms\n        else:\n            trs = [tr]\n        return ChainTransform(trs+self.transforms)\n\n    def __str__(self):\n        names = [tr.__class__.__name__ for tr in self.transforms]\n        return \"<ChainTransform [%s] at 0x%x>\" % (\", \".join(names), id(self))\n\n    def __repr__(self):\n        tr = \",\\n                 \".join(map(repr, self.transforms))\n        return \"<ChainTransform [%s] at 0x%x>\" % (tr, id(self))\n\n    def __del__(self):\n        # remove all the children transforms from our callback, since we are\n        # being deleted.  (But we do *not* want to remove children from other\n        # callbacks)\n        for t in self._transforms:\n            t.changed.disconnect(self._subtr_changed)\n        self.changed.disconnect()",
  "class SimplifiedChainTransform(ChainTransform):\n    def __init__(self, chain):\n        ChainTransform.__init__(self)\n        self._chain = chain\n        chain.changed.connect(self.source_changed)\n        self.source_changed(None)\n\n    def source_changed(self, event):\n        \"\"\"Generate a simplified chain by joining adjacent transforms.\"\"\"\n        # bail out early if the chain is empty\n        transforms = self._chain.transforms[:]\n        if len(transforms) == 0:\n            self.transforms = []\n            return\n\n        # If the change signal comes from a transform that already appears in\n        # our simplified transform list, then there is no need to re-simplify.\n        if event is not None:\n            for source in event.sources[::-1]:\n                if source in self.transforms:\n                    self.update(event)\n                    return\n\n        # First flatten the chain by expanding all nested chains\n        new_chain = []\n        while len(transforms) > 0:\n            tr = transforms.pop(0)\n            if isinstance(tr, ChainTransform) and not tr.dynamic:\n                transforms = tr.transforms[:] + transforms\n            else:\n                new_chain.append(tr)\n\n        # Now combine together all compatible adjacent transforms\n        cont = True\n        tr = new_chain\n        while cont:\n            new_tr = [tr[0]]\n            cont = False\n            for t2 in tr[1:]:\n                t1 = new_tr[-1]\n                pr = t1 * t2\n                if (not t1.dynamic and not t2.dynamic and not \n                        isinstance(pr, ChainTransform)):\n                    cont = True\n                    new_tr.pop()\n                    new_tr.append(pr)\n                else:\n                    new_tr.append(t2)\n            tr = new_tr\n\n        self.transforms = tr",
  "def __init__(self, *transforms):\n        super(ChainTransform, self).__init__()\n        self._transforms = []\n        self._simplified = None\n        self._null_transform = NullTransform()\n        nmap = self._null_transform.shader_map()\n\n        # ChainTransform does not have shader maps\n        self._shader_map = FunctionChain(\"transform_map_chain\", [nmap])\n        self._shader_imap = FunctionChain(\"transform_imap_chain\", [nmap])\n\n        # Set input transforms\n        trs = []\n        for tr in transforms:\n            if isinstance(tr, (tuple, list)):\n                trs.extend(tr)\n            else:\n                trs.append(tr)\n        self.transforms = trs",
  "def transforms(self):\n        \"\"\"The list of transform that make up the transform chain.\n\n        The order of transforms is given such that the last transform in the \n        list is the first to be invoked when mapping coordinates through \n        the chain. \n\n        For example, the following two mappings are equivalent::\n\n            # Map coordinates through individual transforms:\n            trans1 = STTransform(scale=(2, 3), translate=(0, 1))\n            trans2 = PolarTransform()\n            mapped = trans1.map(trans2.map(coords))\n\n            # Equivalent mapping through chain:\n            chain = ChainTransform([trans1, trans2])\n            mapped = chain.map(coords)\n        \"\"\"\n        return self._transforms",
  "def transforms(self, tr):\n        if isinstance(tr, BaseTransform):\n            tr = [tr]\n        if not isinstance(tr, list):\n            raise TypeError(\"Transform chain must be a list\")\n\n        # Avoid extra effort if we already have the correct chain\n        if len(tr) == len(self._transforms):\n            changed = False\n            for i in range(len(tr)):\n                if tr[i] is not self._transforms[i]:\n                    changed = True\n                    break\n            if not changed:\n                return\n\n        for t in self._transforms:\n            t.changed.disconnect(self._subtr_changed)\n        self._transforms = tr\n        for t in self._transforms:\n            t.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()",
  "def simplified(self):\n        \"\"\"A simplified representation of the same transformation.\"\"\"\n        if self._simplified is None:\n            self._simplified = SimplifiedChainTransform(self)\n        return self._simplified",
  "def Linear(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Linear\n        return b",
  "def Orthogonal(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Orthogonal\n        return b",
  "def NonScaling(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.NonScaling\n        return b",
  "def Isometric(self):\n        b = True\n        for tr in self._transforms:\n            b &= tr.Isometric\n        return b",
  "def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        for tr in reversed(self.transforms):\n            coords = tr.map(coords)\n        return coords",
  "def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        for tr in self.transforms:\n            coords = tr.imap(coords)\n        return coords",
  "def shader_map(self):\n        return self._shader_map",
  "def shader_imap(self):\n        return self._shader_imap",
  "def _rebuild_shaders(self):\n        trs = self.transforms\n        if len(trs) == 0:\n            trs = [self._null_transform]\n        self._shader_map.functions = [tr.shader_map() for tr in reversed(trs)]\n        self._shader_imap.functions = [tr.shader_imap() for tr in trs]",
  "def append(self, tr):\n        \"\"\"\n        Add a new transform to the end of this chain.\n\n        Parameters\n        ----------\n        tr : instance of Transform\n            The transform to use.\n        \"\"\"\n        self.transforms.append(tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()",
  "def prepend(self, tr):\n        \"\"\"\n        Add a new transform to the beginning of this chain.\n\n        Parameters\n        ----------\n        tr : instance of Transform\n            The transform to use.\n        \"\"\"\n        self.transforms.insert(0, tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()",
  "def _subtr_changed(self, ev):\n        \"\"\"One of the internal transforms changed; propagate the signal.\"\"\"\n        self.update(ev)",
  "def __setitem__(self, index, tr):\n        self._transforms[index].changed.disconnect(self._subtr_changed)\n        self._transforms[index] = tr\n        tr.changed.connect(self.subtr_changed)\n        self._rebuild_shaders()\n        self.update()",
  "def __mul__(self, tr):\n        if isinstance(tr, ChainTransform):\n            trs = tr.transforms\n        else:\n            trs = [tr]\n        return ChainTransform(self.transforms+trs)",
  "def __rmul__(self, tr):\n        if isinstance(tr, ChainTransform):\n            trs = tr.transforms\n        else:\n            trs = [tr]\n        return ChainTransform(trs+self.transforms)",
  "def __str__(self):\n        names = [tr.__class__.__name__ for tr in self.transforms]\n        return \"<ChainTransform [%s] at 0x%x>\" % (\", \".join(names), id(self))",
  "def __repr__(self):\n        tr = \",\\n                 \".join(map(repr, self.transforms))\n        return \"<ChainTransform [%s] at 0x%x>\" % (tr, id(self))",
  "def __del__(self):\n        # remove all the children transforms from our callback, since we are\n        # being deleted.  (But we do *not* want to remove children from other\n        # callbacks)\n        for t in self._transforms:\n            t.changed.disconnect(self._subtr_changed)\n        self.changed.disconnect()",
  "def __init__(self, chain):\n        ChainTransform.__init__(self)\n        self._chain = chain\n        chain.changed.connect(self.source_changed)\n        self.source_changed(None)",
  "def source_changed(self, event):\n        \"\"\"Generate a simplified chain by joining adjacent transforms.\"\"\"\n        # bail out early if the chain is empty\n        transforms = self._chain.transforms[:]\n        if len(transforms) == 0:\n            self.transforms = []\n            return\n\n        # If the change signal comes from a transform that already appears in\n        # our simplified transform list, then there is no need to re-simplify.\n        if event is not None:\n            for source in event.sources[::-1]:\n                if source in self.transforms:\n                    self.update(event)\n                    return\n\n        # First flatten the chain by expanding all nested chains\n        new_chain = []\n        while len(transforms) > 0:\n            tr = transforms.pop(0)\n            if isinstance(tr, ChainTransform) and not tr.dynamic:\n                transforms = tr.transforms[:] + transforms\n            else:\n                new_chain.append(tr)\n\n        # Now combine together all compatible adjacent transforms\n        cont = True\n        tr = new_chain\n        while cont:\n            new_tr = [tr[0]]\n            cont = False\n            for t2 in tr[1:]:\n                t1 = new_tr[-1]\n                pr = t1 * t2\n                if (not t1.dynamic and not t2.dynamic and not \n                        isinstance(pr, ChainTransform)):\n                    cont = True\n                    new_tr.pop()\n                    new_tr.append(pr)\n                else:\n                    new_tr.append(t2)\n            tr = new_tr\n\n        self.transforms = tr",
  "class NullTransform(BaseTransform):\n    \"\"\"Transform having no effect on coordinates (identity transform).\"\"\"\n\n    glsl_map = \"vec4 null_transform_map(vec4 pos) {return pos;}\"\n    glsl_imap = \"vec4 null_transform_imap(vec4 pos) {return pos;}\"\n\n    Linear = True\n    Orthogonal = True\n    NonScaling = True\n    Isometric = True\n\n    @arg_to_vec4\n    def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n        \"\"\"\n        return coords\n\n    def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n        \"\"\"\n        return coords\n\n    def __mul__(self, tr):\n        return tr\n\n    def __rmul__(self, tr):\n        return tr",
  "class STTransform(BaseTransform):\n    \"\"\"Transform performing only scale and translate, in that order.\n\n    Parameters\n    ----------\n    scale : array-like\n        Scale factors for X, Y, Z axes.\n    translate : array-like\n        Scale factors for X, Y, Z axes.\n    \"\"\"\n\n    glsl_map = \"\"\"\n        vec4 st_transform_map(vec4 pos) {\n            return vec4(pos.xyz * $scale.xyz + $translate.xyz * pos.w, pos.w);\n        }\n    \"\"\"\n\n    glsl_imap = \"\"\"\n        vec4 st_transform_imap(vec4 pos) {\n            return vec4((pos.xyz - $translate.xyz * pos.w) / $scale.xyz,\n                        pos.w);\n        }\n    \"\"\"\n\n    Linear = True\n    Orthogonal = True\n    NonScaling = False\n    Isometric = False\n\n    def __init__(self, scale=None, translate=None):\n        super(STTransform, self).__init__()\n\n        self._scale = np.ones(4, dtype=np.float32)\n        self._translate = np.zeros(4, dtype=np.float32)\n\n        s = ((1.0, 1.0, 1.0, 1.0) if scale is None else\n             as_vec4(scale, default=(1., 1., 1., 1.)))\n        t = ((0.0, 0.0, 0.0, 0.0) if translate is None else\n             as_vec4(translate, default=(0., 0., 0., 0.)))\n        self._set_st(s, t)\n        self._update_shaders()\n\n    @arg_to_vec4\n    def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        m = np.empty(coords.shape)\n        m[:, :3] = (coords[:, :3] * self.scale[np.newaxis, :3] +\n                    coords[:, 3:] * self.translate[np.newaxis, :3])\n        m[:, 3] = coords[:, 3]\n        return m\n\n    @arg_to_vec4\n    def imap(self, coords):\n        \"\"\"Invert map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        m = np.empty(coords.shape)\n        m[:, :3] = ((coords[:, :3] -\n                     coords[:, 3:] * self.translate[np.newaxis, :3]) /\n                    self.scale[np.newaxis, :3])\n        m[:, 3] = coords[:, 3]\n        return m\n\n    def shader_map(self):\n        return self._shader_map\n\n    def shader_imap(self):\n        return self._shader_imap\n\n    @property\n    def scale(self):\n        return self._scale.copy()\n\n    @scale.setter\n    def scale(self, s):\n        s = as_vec4(s, default=(1, 1, 1, 1))\n        self._set_st(scale=s)\n\n    @property\n    def translate(self):\n        return self._translate.copy()\n\n    @translate.setter\n    def translate(self, t):\n        t = as_vec4(t, default=(0, 0, 0, 0))\n        self._set_st(translate=t)\n\n    def _set_st(self, scale=None, translate=None, update=True):\n        need_update = False\n\n        if scale is not None and not np.all(scale == self._scale):\n            self._scale[:] = scale\n            need_update = True\n\n        if translate is not None and not np.all(translate == self._translate):\n            self._translate[:] = translate\n            need_update = True\n\n        if update and need_update:\n            self._update_shaders()\n            self.update()   # inform listeners there has been a change\n\n    def _update_shaders(self):\n        self._shader_map['scale'] = self.scale\n        self._shader_map['translate'] = self.translate\n        self._shader_imap['scale'] = self.scale\n        self._shader_imap['translate'] = self.translate\n\n    def move(self, move):\n        \"\"\"Change the translation of this transform by the amount given.\n\n        Parameters\n        ----------\n        move : array-like\n            The values to be added to the current translation of the transform.\n        \"\"\"\n        move = as_vec4(move, default=(0, 0, 0, 0))\n        self.translate = self.translate + move\n\n    def zoom(self, zoom, center=(0, 0, 0), mapped=True):\n        \"\"\"Update the transform such that its scale factor is changed, but\n        the specified center point is left unchanged.\n\n        Parameters\n        ----------\n        zoom : array-like\n            Values to multiply the transform's current scale\n            factors.\n        center : array-like\n            The center point around which the scaling will take place.\n        mapped : bool\n            Whether *center* is expressed in mapped coordinates (True) or\n            unmapped coordinates (False).\n        \"\"\"\n        zoom = as_vec4(zoom, default=(1, 1, 1, 1))\n        center = as_vec4(center, default=(0, 0, 0, 0))\n        scale = self.scale * zoom\n        if mapped:\n            trans = center - (center - self.translate) * zoom\n        else:\n            trans = self.scale * (1 - zoom) * center + self.translate\n        self._set_st(scale=scale, translate=trans)\n\n    def as_matrix(self):\n        m = MatrixTransform()\n        m.scale(self.scale)\n        m.translate(self.translate)\n        return m\n\n    @classmethod\n    def from_mapping(cls, x0, x1):\n        \"\"\"Create an STTransform from the given mapping\n\n        See `set_mapping` for details.\n\n        Parameters\n        ----------\n        x0 : array-like\n            Start.\n        x1 : array-like\n            End.\n\n        Returns\n        -------\n        t : instance of STTransform\n            The transform.\n        \"\"\"\n        t = cls()\n        t.set_mapping(x0, x1)\n        return t\n\n    def set_mapping(self, x0, x1, update=True):\n        \"\"\"Configure this transform such that it maps points x0 => x1\n\n        Parameters\n        ----------\n        x0 : array-like, shape (2, 2) or (2, 3)\n            Start location.\n        x1 : array-like, shape (2, 2) or (2, 3)\n            End location.\n        update : bool\n            If False, then the update event is not emitted.\n\n        Examples\n        --------\n        For example, if we wish to map the corners of a rectangle::\n\n            >>> p1 = [[0, 0], [200, 300]]\n\n        onto a unit cube::\n\n            >>> p2 = [[-1, -1], [1, 1]]\n\n        then we can generate the transform as follows::\n\n            >>> tr = STTransform()\n            >>> tr.set_mapping(p1, p2)\n            >>> assert tr.map(p1)[:,:2] == p2  # test\n        \"\"\"\n        # if args are Rect, convert to array first\n        if isinstance(x0, Rect):\n            x0 = x0._transform_in()[:3]\n        if isinstance(x1, Rect):\n            x1 = x1._transform_in()[:3]\n\n        x0 = np.asarray(x0)\n        x1 = np.asarray(x1)\n        if (x0.ndim != 2 or x0.shape[0] != 2 or x1.ndim != 2 or\n                x1.shape[0] != 2):\n            raise TypeError(\"set_mapping requires array inputs of shape \"\n                            \"(2, N).\")\n        denom = x0[1] - x0[0]\n        mask = denom == 0\n        denom[mask] = 1.0\n        s = (x1[1] - x1[0]) / denom\n        s[mask] = 1.0\n        s[x0[1] == x0[0]] = 1.0\n        t = x1[0] - s * x0[0]\n        s = as_vec4(s, default=(1, 1, 1, 1))\n        t = as_vec4(t, default=(0, 0, 0, 0))\n        self._set_st(scale=s, translate=t, update=update)\n\n    def __mul__(self, tr):\n        if isinstance(tr, STTransform):\n            s = self.scale * tr.scale\n            t = self.translate + (tr.translate * self.scale)\n            return STTransform(scale=s, translate=t)\n        elif isinstance(tr, MatrixTransform):\n            return self.as_matrix() * tr\n        else:\n            return super(STTransform, self).__mul__(tr)\n\n    def __rmul__(self, tr):\n        if isinstance(tr, MatrixTransform):\n            return tr * self.as_matrix()\n        return super(STTransform, self).__rmul__(tr)\n\n    def __repr__(self):\n        return (\"<STTransform scale=%s translate=%s at 0x%s>\"\n                % (self.scale, self.translate, id(self)))",
  "class MatrixTransform(BaseTransform):\n    \"\"\"Affine transformation class\n\n    Parameters\n    ----------\n    matrix : array-like | None\n        4x4 array to use for the transform.\n    \"\"\"\n\n    glsl_map = \"\"\"\n        vec4 affine_transform_map(vec4 pos) {\n            return $matrix * pos;\n        }\n    \"\"\"\n\n    glsl_imap = \"\"\"\n        vec4 affine_transform_imap(vec4 pos) {\n            return $inv_matrix * pos;\n        }\n    \"\"\"\n\n    Linear = True\n    Orthogonal = False\n    NonScaling = False\n    Isometric = False\n\n    def __init__(self, matrix=None):\n        super(MatrixTransform, self).__init__()\n        if matrix is not None:\n            self.matrix = matrix\n        else:\n            self.reset()\n\n    @arg_to_vec4\n    def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        # looks backwards, but both matrices are transposed.\n        return np.dot(coords, self.matrix)\n\n    @arg_to_vec4\n    def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        return np.dot(coords, self.inv_matrix)\n\n    def shader_map(self):\n        fn = super(MatrixTransform, self).shader_map()\n        fn['matrix'] = self.matrix  # uniform mat4\n        return fn\n\n    def shader_imap(self):\n        fn = super(MatrixTransform, self).shader_imap()\n        fn['inv_matrix'] = self.inv_matrix  # uniform mat4\n        return fn\n\n    @property\n    def matrix(self):\n        return self._matrix\n\n    @matrix.setter\n    def matrix(self, m):\n        self._matrix = m\n        self._inv_matrix = None\n        self.shader_map()\n        self.shader_imap()\n        self.update()\n\n    @property\n    def inv_matrix(self):\n        if self._inv_matrix is None:\n            self._inv_matrix = np.linalg.inv(self.matrix)\n        return self._inv_matrix\n\n    @arg_to_vec4\n    def translate(self, pos):\n        \"\"\"\n        Translate the matrix\n\n        The translation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        pos : arrayndarray\n            Position to translate by.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.translate(pos[0, :3]))\n\n    def scale(self, scale, center=None):\n        \"\"\"\n        Scale the matrix about a given origin.\n\n        The scaling is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        scale : array-like\n            Scale factors along x, y and z axes.\n        center : array-like or None\n            The x, y and z coordinates to scale around. If None,\n            (0, 0, 0) will be used.\n        \"\"\"\n        scale = transforms.scale(as_vec4(scale, default=(1, 1, 1, 1))[0, :3])\n        if center is not None:\n            center = as_vec4(center)[0, :3]\n            scale = np.dot(np.dot(transforms.translate(-center), scale),\n                           transforms.translate(center))\n        self.matrix = np.dot(self.matrix, scale)\n\n    def rotate(self, angle, axis):\n        \"\"\"\n        Rotate the matrix by some angle about a given axis.\n\n        The rotation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation, in degrees.\n        axis : array-like\n            The x, y and z coordinates of the axis vector to rotate around.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.rotate(angle, axis))\n\n    def set_mapping(self, points1, points2):\n        \"\"\"Set to a 3D transformation matrix that maps points1 onto points2.\n\n        Parameters\n        ----------\n        points1 : array-like, shape (4, 3)\n            Four starting 3D coordinates.\n        points2 : array-like, shape (4, 3)\n            Four ending 3D coordinates.\n        \"\"\"\n        # note: need to transpose because util.functions uses opposite\n        # of standard linear algebra order.\n        self.matrix = transforms.affine_map(points1, points2).T\n\n    def set_ortho(self, l, r, b, t, n, f):  # noqa\n        \"\"\"Set ortho transform\n\n        Parameters\n        ----------\n        l : float\n            Left.\n        r : float\n            Right.\n        b : float\n            Bottom.\n        t : float\n            Top.\n        n : float\n            Near.\n        f : float\n            Far.\n        \"\"\"\n        self.matrix = transforms.ortho(l, r, b, t, n, f)\n\n    def reset(self):\n        self.matrix = np.eye(4)\n\n    def __mul__(self, tr):\n        if (isinstance(tr, MatrixTransform) and not\n                any(tr.matrix[:3, 3] != 0)):\n            # don't multiply if the perspective column is used\n            return MatrixTransform(matrix=np.dot(tr.matrix, self.matrix))\n        else:\n            return tr.__rmul__(self)\n\n    def __repr__(self):\n        s = \"%s(matrix=[\" % self.__class__.__name__\n        indent = \" \"*len(s)\n        s += str(list(self.matrix[0])) + \",\\n\"\n        s += indent + str(list(self.matrix[1])) + \",\\n\"\n        s += indent + str(list(self.matrix[2])) + \",\\n\"\n        s += indent + str(list(self.matrix[3])) + \"] at 0x%x)\" % id(self)\n        return s\n\n    def set_perspective(self, fov, aspect, near, far):\n        \"\"\"Set the perspective\n\n        Parameters\n        ----------\n        fov : float\n            Field of view.\n        aspect : float\n            Aspect ratio.\n        near : float\n            Near location.\n        far : float\n            Far location.\n        \"\"\"\n        self.matrix = transforms.perspective(fov, aspect, near, far)\n\n    def set_frustum(self, l, r, b, t, n, f):  # noqa\n        \"\"\"Set the frustum\n\n        Parameters\n        ----------\n        l : float\n            Left.\n        r : float\n            Right.\n        b : float\n            Bottom.\n        t : float\n            Top.\n        n : float\n            Near.\n        f : float\n            Far.\n        \"\"\"\n        self.matrix = transforms.frustum(l, r, b, t, n, f)",
  "def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n        \"\"\"\n        return coords",
  "def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n        \"\"\"\n        return coords",
  "def __mul__(self, tr):\n        return tr",
  "def __rmul__(self, tr):\n        return tr",
  "def __init__(self, scale=None, translate=None):\n        super(STTransform, self).__init__()\n\n        self._scale = np.ones(4, dtype=np.float32)\n        self._translate = np.zeros(4, dtype=np.float32)\n\n        s = ((1.0, 1.0, 1.0, 1.0) if scale is None else\n             as_vec4(scale, default=(1., 1., 1., 1.)))\n        t = ((0.0, 0.0, 0.0, 0.0) if translate is None else\n             as_vec4(translate, default=(0., 0., 0., 0.)))\n        self._set_st(s, t)\n        self._update_shaders()",
  "def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        m = np.empty(coords.shape)\n        m[:, :3] = (coords[:, :3] * self.scale[np.newaxis, :3] +\n                    coords[:, 3:] * self.translate[np.newaxis, :3])\n        m[:, 3] = coords[:, 3]\n        return m",
  "def imap(self, coords):\n        \"\"\"Invert map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        m = np.empty(coords.shape)\n        m[:, :3] = ((coords[:, :3] -\n                     coords[:, 3:] * self.translate[np.newaxis, :3]) /\n                    self.scale[np.newaxis, :3])\n        m[:, 3] = coords[:, 3]\n        return m",
  "def shader_map(self):\n        return self._shader_map",
  "def shader_imap(self):\n        return self._shader_imap",
  "def scale(self):\n        return self._scale.copy()",
  "def scale(self, s):\n        s = as_vec4(s, default=(1, 1, 1, 1))\n        self._set_st(scale=s)",
  "def translate(self):\n        return self._translate.copy()",
  "def translate(self, t):\n        t = as_vec4(t, default=(0, 0, 0, 0))\n        self._set_st(translate=t)",
  "def _set_st(self, scale=None, translate=None, update=True):\n        need_update = False\n\n        if scale is not None and not np.all(scale == self._scale):\n            self._scale[:] = scale\n            need_update = True\n\n        if translate is not None and not np.all(translate == self._translate):\n            self._translate[:] = translate\n            need_update = True\n\n        if update and need_update:\n            self._update_shaders()\n            self.update()",
  "def _update_shaders(self):\n        self._shader_map['scale'] = self.scale\n        self._shader_map['translate'] = self.translate\n        self._shader_imap['scale'] = self.scale\n        self._shader_imap['translate'] = self.translate",
  "def move(self, move):\n        \"\"\"Change the translation of this transform by the amount given.\n\n        Parameters\n        ----------\n        move : array-like\n            The values to be added to the current translation of the transform.\n        \"\"\"\n        move = as_vec4(move, default=(0, 0, 0, 0))\n        self.translate = self.translate + move",
  "def zoom(self, zoom, center=(0, 0, 0), mapped=True):\n        \"\"\"Update the transform such that its scale factor is changed, but\n        the specified center point is left unchanged.\n\n        Parameters\n        ----------\n        zoom : array-like\n            Values to multiply the transform's current scale\n            factors.\n        center : array-like\n            The center point around which the scaling will take place.\n        mapped : bool\n            Whether *center* is expressed in mapped coordinates (True) or\n            unmapped coordinates (False).\n        \"\"\"\n        zoom = as_vec4(zoom, default=(1, 1, 1, 1))\n        center = as_vec4(center, default=(0, 0, 0, 0))\n        scale = self.scale * zoom\n        if mapped:\n            trans = center - (center - self.translate) * zoom\n        else:\n            trans = self.scale * (1 - zoom) * center + self.translate\n        self._set_st(scale=scale, translate=trans)",
  "def as_matrix(self):\n        m = MatrixTransform()\n        m.scale(self.scale)\n        m.translate(self.translate)\n        return m",
  "def from_mapping(cls, x0, x1):\n        \"\"\"Create an STTransform from the given mapping\n\n        See `set_mapping` for details.\n\n        Parameters\n        ----------\n        x0 : array-like\n            Start.\n        x1 : array-like\n            End.\n\n        Returns\n        -------\n        t : instance of STTransform\n            The transform.\n        \"\"\"\n        t = cls()\n        t.set_mapping(x0, x1)\n        return t",
  "def set_mapping(self, x0, x1, update=True):\n        \"\"\"Configure this transform such that it maps points x0 => x1\n\n        Parameters\n        ----------\n        x0 : array-like, shape (2, 2) or (2, 3)\n            Start location.\n        x1 : array-like, shape (2, 2) or (2, 3)\n            End location.\n        update : bool\n            If False, then the update event is not emitted.\n\n        Examples\n        --------\n        For example, if we wish to map the corners of a rectangle::\n\n            >>> p1 = [[0, 0], [200, 300]]\n\n        onto a unit cube::\n\n            >>> p2 = [[-1, -1], [1, 1]]\n\n        then we can generate the transform as follows::\n\n            >>> tr = STTransform()\n            >>> tr.set_mapping(p1, p2)\n            >>> assert tr.map(p1)[:,:2] == p2  # test\n        \"\"\"\n        # if args are Rect, convert to array first\n        if isinstance(x0, Rect):\n            x0 = x0._transform_in()[:3]\n        if isinstance(x1, Rect):\n            x1 = x1._transform_in()[:3]\n\n        x0 = np.asarray(x0)\n        x1 = np.asarray(x1)\n        if (x0.ndim != 2 or x0.shape[0] != 2 or x1.ndim != 2 or\n                x1.shape[0] != 2):\n            raise TypeError(\"set_mapping requires array inputs of shape \"\n                            \"(2, N).\")\n        denom = x0[1] - x0[0]\n        mask = denom == 0\n        denom[mask] = 1.0\n        s = (x1[1] - x1[0]) / denom\n        s[mask] = 1.0\n        s[x0[1] == x0[0]] = 1.0\n        t = x1[0] - s * x0[0]\n        s = as_vec4(s, default=(1, 1, 1, 1))\n        t = as_vec4(t, default=(0, 0, 0, 0))\n        self._set_st(scale=s, translate=t, update=update)",
  "def __mul__(self, tr):\n        if isinstance(tr, STTransform):\n            s = self.scale * tr.scale\n            t = self.translate + (tr.translate * self.scale)\n            return STTransform(scale=s, translate=t)\n        elif isinstance(tr, MatrixTransform):\n            return self.as_matrix() * tr\n        else:\n            return super(STTransform, self).__mul__(tr)",
  "def __rmul__(self, tr):\n        if isinstance(tr, MatrixTransform):\n            return tr * self.as_matrix()\n        return super(STTransform, self).__rmul__(tr)",
  "def __repr__(self):\n        return (\"<STTransform scale=%s translate=%s at 0x%s>\"\n                % (self.scale, self.translate, id(self)))",
  "def __init__(self, matrix=None):\n        super(MatrixTransform, self).__init__()\n        if matrix is not None:\n            self.matrix = matrix\n        else:\n            self.reset()",
  "def map(self, coords):\n        \"\"\"Map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        # looks backwards, but both matrices are transposed.\n        return np.dot(coords, self.matrix)",
  "def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        return np.dot(coords, self.inv_matrix)",
  "def shader_map(self):\n        fn = super(MatrixTransform, self).shader_map()\n        fn['matrix'] = self.matrix  # uniform mat4\n        return fn",
  "def shader_imap(self):\n        fn = super(MatrixTransform, self).shader_imap()\n        fn['inv_matrix'] = self.inv_matrix  # uniform mat4\n        return fn",
  "def matrix(self):\n        return self._matrix",
  "def matrix(self, m):\n        self._matrix = m\n        self._inv_matrix = None\n        self.shader_map()\n        self.shader_imap()\n        self.update()",
  "def inv_matrix(self):\n        if self._inv_matrix is None:\n            self._inv_matrix = np.linalg.inv(self.matrix)\n        return self._inv_matrix",
  "def translate(self, pos):\n        \"\"\"\n        Translate the matrix\n\n        The translation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        pos : arrayndarray\n            Position to translate by.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.translate(pos[0, :3]))",
  "def scale(self, scale, center=None):\n        \"\"\"\n        Scale the matrix about a given origin.\n\n        The scaling is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        scale : array-like\n            Scale factors along x, y and z axes.\n        center : array-like or None\n            The x, y and z coordinates to scale around. If None,\n            (0, 0, 0) will be used.\n        \"\"\"\n        scale = transforms.scale(as_vec4(scale, default=(1, 1, 1, 1))[0, :3])\n        if center is not None:\n            center = as_vec4(center)[0, :3]\n            scale = np.dot(np.dot(transforms.translate(-center), scale),\n                           transforms.translate(center))\n        self.matrix = np.dot(self.matrix, scale)",
  "def rotate(self, angle, axis):\n        \"\"\"\n        Rotate the matrix by some angle about a given axis.\n\n        The rotation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation, in degrees.\n        axis : array-like\n            The x, y and z coordinates of the axis vector to rotate around.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.rotate(angle, axis))",
  "def set_mapping(self, points1, points2):\n        \"\"\"Set to a 3D transformation matrix that maps points1 onto points2.\n\n        Parameters\n        ----------\n        points1 : array-like, shape (4, 3)\n            Four starting 3D coordinates.\n        points2 : array-like, shape (4, 3)\n            Four ending 3D coordinates.\n        \"\"\"\n        # note: need to transpose because util.functions uses opposite\n        # of standard linear algebra order.\n        self.matrix = transforms.affine_map(points1, points2).T",
  "def set_ortho(self, l, r, b, t, n, f):  # noqa\n        \"\"\"Set ortho transform\n\n        Parameters\n        ----------\n        l : float\n            Left.\n        r : float\n            Right.\n        b : float\n            Bottom.\n        t : float\n            Top.\n        n : float\n            Near.\n        f : float\n            Far.\n        \"\"\"\n        self.matrix = transforms.ortho(l, r, b, t, n, f)",
  "def reset(self):\n        self.matrix = np.eye(4)",
  "def __mul__(self, tr):\n        if (isinstance(tr, MatrixTransform) and not\n                any(tr.matrix[:3, 3] != 0)):\n            # don't multiply if the perspective column is used\n            return MatrixTransform(matrix=np.dot(tr.matrix, self.matrix))\n        else:\n            return tr.__rmul__(self)",
  "def __repr__(self):\n        s = \"%s(matrix=[\" % self.__class__.__name__\n        indent = \" \"*len(s)\n        s += str(list(self.matrix[0])) + \",\\n\"\n        s += indent + str(list(self.matrix[1])) + \",\\n\"\n        s += indent + str(list(self.matrix[2])) + \",\\n\"\n        s += indent + str(list(self.matrix[3])) + \"] at 0x%x)\" % id(self)\n        return s",
  "def set_perspective(self, fov, aspect, near, far):\n        \"\"\"Set the perspective\n\n        Parameters\n        ----------\n        fov : float\n            Field of view.\n        aspect : float\n            Aspect ratio.\n        near : float\n            Near location.\n        far : float\n            Far location.\n        \"\"\"\n        self.matrix = transforms.perspective(fov, aspect, near, far)",
  "def set_frustum(self, l, r, b, t, n, f):  # noqa\n        \"\"\"Set the frustum\n\n        Parameters\n        ----------\n        l : float\n            Left.\n        r : float\n            Right.\n        b : float\n            Bottom.\n        t : float\n            Top.\n        n : float\n            Near.\n        f : float\n            Far.\n        \"\"\"\n        self.matrix = transforms.frustum(l, r, b, t, n, f)",
  "def create_transform(type, *args, **kwargs):\n    return transform_types[type](*args, **kwargs)",
  "def arg_to_array(func):\n    \"\"\"\n    Decorator to convert argument to array.\n\n    Parameters\n    ----------\n    func : function\n        The function to decorate.\n\n    Returns\n    -------\n    func : function\n        The decorated function.\n    \"\"\"\n    @wraps(func)\n    def fn(self, arg, *args, **kwargs):\n        \"\"\"Function\n\n        Parameters\n        ----------\n        arg : array-like\n            Argument to convert.\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n\n        Returns\n        -------\n        value : object\n            The return value of the function.\n        \"\"\"\n        return func(self, np.array(arg), *args, **kwargs)\n    return fn",
  "def as_vec4(obj, default=(0, 0, 0, 1)):\n    \"\"\"\n    Convert `obj` to 4-element vector (numpy array with shape[-1] == 4)\n\n    Parameters\n    ----------\n    obj : array-like\n        Original object.\n    default : array-like\n        The defaults to use if the object does not have 4 entries.\n\n    Returns\n    -------\n    obj : array-like\n        The object promoted to have 4 elements.\n\n    Notes\n    -----\n    `obj` will have at least two dimensions.\n\n    If `obj` has < 4 elements, then new elements are added from `default`.\n    For inputs intended as a position or translation, use default=(0,0,0,1).\n    For inputs intended as scale factors, use default=(1,1,1,1).\n\n    \"\"\"\n    obj = np.atleast_2d(obj)\n    # For multiple vectors, reshape to (..., 4)\n    if obj.shape[-1] < 4:\n        new = np.empty(obj.shape[:-1] + (4,), dtype=obj.dtype)\n        new[:] = default\n        new[..., :obj.shape[-1]] = obj\n        obj = new\n    elif obj.shape[-1] > 4:\n        raise TypeError(\"Array shape %s cannot be converted to vec4\"\n                        % (obj.shape, ))\n    return obj",
  "def arg_to_vec4(func):\n    \"\"\"\n    Decorator for converting argument to vec4 format suitable for 4x4 matrix\n    multiplication.\n\n    [x, y]      =>  [[x, y, 0, 1]]\n\n    [x, y, z]   =>  [[x, y, z, 1]]\n\n    [[x1, y1],      [[x1, y1, 0, 1],\n     [x2, y2],  =>   [x2, y2, 0, 1],\n     [x3, y3]]       [x3, y3, 0, 1]]\n\n    If 1D input is provided, then the return value will be flattened.\n    Accepts input of any dimension, as long as shape[-1] <= 4\n\n    Alternatively, any class may define its own transform conversion interface\n    by defining a _transform_in() method that returns an array with shape\n    (.., 4), and a _transform_out() method that accepts the same array shape\n    and returns a new (mapped) object.\n\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self_, arg, *args, **kwargs):\n        if isinstance(arg, (tuple, list, np.ndarray)):\n            arg = np.array(arg)\n            flatten = arg.ndim == 1\n            arg = as_vec4(arg)\n\n            ret = func(self_, arg, *args, **kwargs)\n            if flatten and ret is not None:\n                return ret.flatten()\n            return ret\n        elif hasattr(arg, '_transform_in'):\n            arr = arg._transform_in()\n            ret = func(self_, arr, *args, **kwargs)\n            return arg._transform_out(ret)\n        else:\n            raise TypeError(\"Cannot convert argument to 4D vector: %s\" % arg)\n\n    return wrapper",
  "class TransformCache(object):\n    \"\"\"Utility class for managing a cache of ChainTransforms.\n\n    This is an LRU cache; items are removed if they are not accessed after\n    *max_age* calls to roll().\n\n    Notes\n    -----\n    This class is used by SceneCanvas to ensure that ChainTransform instances\n    are re-used across calls to draw_visual(). SceneCanvas creates one\n    TransformCache instance for each top-level visual drawn, and calls\n    roll() on each cache before drawing, which removes from the cache any\n    transforms that were not accessed during the last draw cycle.\n    \"\"\"\n\n    def __init__(self, max_age=1):\n        self._cache = {}  # maps {key: [age, transform]}\n        self.max_age = max_age\n\n    def get(self, path):\n        \"\"\"Get a transform from the cache that maps along *path*, which must\n        be a list of Transforms to apply in reverse order (last transform is\n        applied first).\n\n        Accessed items have their age reset to 0.\n        \"\"\"\n        key = tuple(map(id, path))\n        item = self._cache.get(key, None)\n        if item is None:\n            logger.debug(\"Transform cache miss: %s\", key)\n            item = [0, self._create(path)]\n            self._cache[key] = item\n        item[0] = 0  # reset age for this item\n\n        # make sure the chain is up to date\n        # tr = item[1]\n        # for i, node in enumerate(path[1:]):\n        #    if tr.transforms[i] is not node.transform:\n        #        tr[i] = node.transform\n\n        return item[1]\n\n    def _create(self, path):\n        # import here to avoid import cycle\n        from .chain import ChainTransform\n        return ChainTransform(path)\n\n    def roll(self):\n        \"\"\"Increase the age of all items in the cache by 1. Items whose age\n        is greater than self.max_age will be removed from the cache.\n        \"\"\"\n        rem = []\n        for key, item in self._cache.items():\n            if item[0] > self.max_age:\n                rem.append(key)\n            item[0] += 1\n\n        for key in rem:\n            logger.debug(\"TransformCache remove: %s\", key)\n            del self._cache[key]",
  "def fn(self, arg, *args, **kwargs):\n        \"\"\"Function\n\n        Parameters\n        ----------\n        arg : array-like\n            Argument to convert.\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword arguments.\n\n        Returns\n        -------\n        value : object\n            The return value of the function.\n        \"\"\"\n        return func(self, np.array(arg), *args, **kwargs)",
  "def wrapper(self_, arg, *args, **kwargs):\n        if isinstance(arg, (tuple, list, np.ndarray)):\n            arg = np.array(arg)\n            flatten = arg.ndim == 1\n            arg = as_vec4(arg)\n\n            ret = func(self_, arg, *args, **kwargs)\n            if flatten and ret is not None:\n                return ret.flatten()\n            return ret\n        elif hasattr(arg, '_transform_in'):\n            arr = arg._transform_in()\n            ret = func(self_, arr, *args, **kwargs)\n            return arg._transform_out(ret)\n        else:\n            raise TypeError(\"Cannot convert argument to 4D vector: %s\" % arg)",
  "def __init__(self, max_age=1):\n        self._cache = {}  # maps {key: [age, transform]}\n        self.max_age = max_age",
  "def get(self, path):\n        \"\"\"Get a transform from the cache that maps along *path*, which must\n        be a list of Transforms to apply in reverse order (last transform is\n        applied first).\n\n        Accessed items have their age reset to 0.\n        \"\"\"\n        key = tuple(map(id, path))\n        item = self._cache.get(key, None)\n        if item is None:\n            logger.debug(\"Transform cache miss: %s\", key)\n            item = [0, self._create(path)]\n            self._cache[key] = item\n        item[0] = 0  # reset age for this item\n\n        # make sure the chain is up to date\n        # tr = item[1]\n        # for i, node in enumerate(path[1:]):\n        #    if tr.transforms[i] is not node.transform:\n        #        tr[i] = node.transform\n\n        return item[1]",
  "def _create(self, path):\n        # import here to avoid import cycle\n        from .chain import ChainTransform\n        return ChainTransform(path)",
  "def roll(self):\n        \"\"\"Increase the age of all items in the cache by 1. Items whose age\n        is greater than self.max_age will be removed from the cache.\n        \"\"\"\n        rem = []\n        for key, item in self._cache.items():\n            if item[0] > self.max_age:\n                rem.append(key)\n            item[0] += 1\n\n        for key in rem:\n            logger.debug(\"TransformCache remove: %s\", key)\n            del self._cache[key]",
  "def _get_edges(adjacency_mat):\n    func = _sparse_get_edges if issparse(adjacency_mat) else _ndarray_get_edges\n    return func(adjacency_mat)",
  "def _sparse_get_edges(adjacency_mat):\n    return np.concatenate((adjacency_mat.row[:, np.newaxis],\n                           adjacency_mat.col[:, np.newaxis]), axis=-1)",
  "def _ndarray_get_edges(adjacency_mat):\n    # Get indices of all non zero values\n    i, j = np.where(adjacency_mat)\n\n    return np.concatenate((i[:, np.newaxis], j[:, np.newaxis]), axis=-1)",
  "def _get_directed_edges(adjacency_mat):\n    func = _sparse_get_edges if issparse(adjacency_mat) else _ndarray_get_edges\n\n    if issparse(adjacency_mat):\n        triu = sparse.triu\n        tril = sparse.tril\n    else:\n        triu = np.triu\n        tril = np.tril\n\n    upper = triu(adjacency_mat)\n    lower = tril(adjacency_mat)\n\n    return np.concatenate((func(upper), func(lower)))",
  "def _straight_line_vertices(adjacency_mat, node_coords, directed=False):\n    \"\"\"\n    Generate the vertices for straight lines between nodes.\n\n    If it is a directed graph, it also generates the vertices which can be\n    passed to an :class:`ArrowVisual`.\n\n    Parameters\n    ----------\n    adjacency_mat : array\n        The adjacency matrix of the graph\n    node_coords : array\n        The current coordinates of all nodes in the graph\n    directed : bool\n        Wether the graph is directed. If this is true it will also generate\n        the vertices for arrows which can be passed to :class:`ArrowVisual`.\n\n    Returns\n    -------\n    vertices : tuple\n        Returns a tuple containing containing (`line_vertices`,\n        `arrow_vertices`)\n    \"\"\"\n    if not issparse(adjacency_mat):\n        adjacency_mat = np.asarray(adjacency_mat, float)\n\n    if (adjacency_mat.ndim != 2 or adjacency_mat.shape[0] !=\n            adjacency_mat.shape[1]):\n        raise ValueError(\"Adjacency matrix should be square.\")\n\n    arrow_vertices = np.array([])\n\n    edges = _get_edges(adjacency_mat)\n    line_vertices = node_coords[edges.ravel()]\n\n    if directed:\n        arrows = np.array(list(_get_directed_edges(adjacency_mat)))\n        arrow_vertices = node_coords[arrows.ravel()]\n        arrow_vertices = arrow_vertices.reshape((len(arrow_vertices)//2, 4))\n\n    return line_vertices, arrow_vertices",
  "def _rescale_layout(pos, scale=1):\n    \"\"\"\n    Normalize the given coordinate list to the range [0, `scale`].\n\n    Parameters\n    ----------\n    pos : array\n        Coordinate list\n    scale : number\n        The upperbound value for the coordinates range\n\n    Returns\n    -------\n    pos : array\n        The rescaled (normalized) coordinates in the range [0, `scale`].\n\n    Notes\n    -----\n    Changes `pos` in place.\n    \"\"\"\n    pos -= pos.min(axis=0)\n    pos *= scale / pos.max()\n\n    return pos",
  "def issparse(*args, **kwargs):\n        return False",
  "class GraphVisual(CompoundVisual):\n    \"\"\"Visual for displaying graphs or networks.\n\n    Parameters\n    ----------\n    adjacency_mat : array or sparse\n        The adjacency matrix of the graph.\n    directed : bool\n        Whether the graph is directed or not. If True, then this visual will\n        draw arrows for the directed edges.\n    layout : str\n        They layout to use.\n    animate : bool\n        Whether or not to animate.\n    line_color : str or :class:`vispy.color.colormap.ColorMap`\n        The color to use for the edges.\n    line_width : number\n        The edge thickness.\n    arrow_type : str\n        The kind of arrow head to use. See :class:`vispy.visuals.ArrowHead`\n        for more information.\n    arrow_size : number\n        The size of the arrow head.\n    node_symbol : string\n        The marker to use for nodes. See\n        :class:`vispy.visuals.MarkersVisual` for more information.\n    node_size : number\n        The size of the node\n    border_color : str or :class:`vispy.color.colormap.ColorMap`\n        The border color for nodes.\n    face_color : str or :class:`vispy.color.colormap.ColorMap`\n        The face color for nodes.\n    border_width : number\n        The border size for nodes.\n\n    See Also\n    --------\n    ArrowVisual, MarkersVisual\n\n    \"\"\"\n\n    _arrow_attributes = ('arrow_type', 'arrow_size')\n    _arrow_kwargs = ('line_color', 'line_width')\n    _node_kwargs = ('node_symbol', 'node_size', 'border_color', 'face_color',\n                    'border_width')\n\n    _arrow_kw_trans = dict(line_color='color', line_width='width')\n    _node_kw_trans = dict(node_symbol='symbol', node_size='size',\n                          border_color='edge_color', border_width='edge_width')\n    _node_properties_args = ()\n\n    def __init__(self, adjacency_mat=None, directed=False, layout=None,\n                 animate=False, line_color=None, line_width=None,\n                 arrow_type=None, arrow_size=None, node_symbol=None,\n                 node_size=None, border_color=None, face_color=None,\n                 border_width=None):\n\n        self._edges = ArrowVisual(method='gl', connect='segments')\n        self._nodes = MarkersVisual()\n\n        self._arrow_data = {}\n        self._node_data = {}\n        self._node_properties = {}\n\n        self._adjacency_mat = None\n\n        self._layout = None\n        self._layout_iter = None\n        self.layout = layout\n\n        self._directed = directed\n        self.directed = directed\n\n        self._animate = False\n        self.animate = animate\n\n        CompoundVisual.__init__(self, [self._edges, self._nodes])\n\n        self.set_data(adjacency_mat, line_color=line_color,\n                      line_width=line_width, arrow_type=arrow_type,\n                      arrow_size=arrow_size, node_symbol=node_symbol,\n                      node_size=node_size, border_color=border_color,\n                      face_color=face_color, border_width=border_width)\n\n    @property\n    def adjacency_matrix(self):\n        return self._adjacency_mat\n\n    @property\n    def layout(self):\n        return self._layout\n\n    @layout.setter\n    def layout(self, value):\n        if isinstance(value, str):\n            self._layout = layouts.get_layout(value)\n        else:\n            assert callable(value)\n            self._layout = value\n\n        self._layout_iter = None\n\n    @property\n    def directed(self):\n        return self._directed\n\n    @directed.setter\n    def directed(self, value):\n        self._directed = bool(value)\n\n    @property\n    def animate(self):\n        return self._animate\n\n    @animate.setter\n    def animate(self, value):\n        self._animate = bool(value)\n\n    def animate_layout(self):\n        if self._layout_iter is None:\n            if self._adjacency_mat is None:\n                raise ValueError(\"No adjacency matrix set yet. An adjacency \"\n                                 \"matrix is required to calculate the layout.\")\n\n            self._layout_iter = iter(self._layout(self._adjacency_mat,\n                                                  self._directed))\n\n        try:\n            node_vertices, line_vertices, arrows = next(self._layout_iter)\n        except StopIteration:\n            return True\n\n        self._nodes.set_data(pos=node_vertices, **self._node_data)\n        for k, v in self._node_properties.items():\n            setattr(self._nodes, k, v)\n\n        self._edges.set_data(pos=line_vertices, arrows=arrows,\n                             **self._arrow_data)\n\n        return False\n\n    def set_final_layout(self):\n        if self._layout_iter is None:\n            if self._adjacency_mat is None:\n                raise ValueError(\"No adjacency matrix set yet. An adjacency \"\n                                 \"matrix is required to calculate the layout.\")\n\n            self._layout_iter = iter(self._layout(self._adjacency_mat,\n                                                  self._directed))\n\n        # Calculate the final position of the nodes and lines\n        node_vertices = None\n        line_vertices = None\n        arrows = None\n        for node_vertices, line_vertices, arrows in self._layout_iter:\n            pass\n\n        self._nodes.set_data(pos=node_vertices, **self._node_data)\n        for k, v in self._node_properties.items():\n            setattr(self._nodes, k, v)\n\n        self._edges.set_data(pos=line_vertices, arrows=arrows,\n                             **self._arrow_data)\n\n    def reset_layout(self):\n        self._layout_iter = None\n\n    def set_data(self, adjacency_mat=None, **kwargs):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        adjacency_mat : ndarray | None\n            The adjacency matrix.\n        **kwargs : dict\n            Keyword arguments to pass to the arrows.\n        \"\"\"\n        if adjacency_mat is not None:\n            if adjacency_mat.shape[0] != adjacency_mat.shape[1]:\n                raise ValueError(\"Adjacency matrix should be square.\")\n\n            self._adjacency_mat = adjacency_mat\n\n        for k in self._arrow_attributes:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                setattr(self._edges, translated, kwargs.pop(k))\n\n        arrow_kwargs = {}\n        for k in self._arrow_kwargs:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                arrow_kwargs[translated] = kwargs.pop(k)\n\n        node_kwargs = {}\n        for k in self._node_kwargs:\n            if k in kwargs:\n                translated = (self._node_kw_trans[k] if k in\n                              self._node_kw_trans else k)\n\n                node_kwargs[translated] = kwargs.pop(k)\n\n        if len(kwargs) > 0:\n            raise TypeError(\"%s.set_data() got invalid keyword arguments: %s\"\n                            % (self.__class__.__name__, list(kwargs.keys())))\n\n        # some attributes should be set as properties\n        node_properties = {}\n        for k, v in list(node_kwargs.items()):\n            if k in (self._node_properties_args):\n                node_properties[k] = node_kwargs.pop(k)\n\n        # The actual data is set in GraphVisual.animate_layout or\n        # GraphVisual.set_final_layout\n        self._arrow_data = arrow_kwargs\n        self._node_data = node_kwargs\n        self._node_properties = node_properties\n\n        if not self._animate:\n            self.set_final_layout()",
  "def __init__(self, adjacency_mat=None, directed=False, layout=None,\n                 animate=False, line_color=None, line_width=None,\n                 arrow_type=None, arrow_size=None, node_symbol=None,\n                 node_size=None, border_color=None, face_color=None,\n                 border_width=None):\n\n        self._edges = ArrowVisual(method='gl', connect='segments')\n        self._nodes = MarkersVisual()\n\n        self._arrow_data = {}\n        self._node_data = {}\n        self._node_properties = {}\n\n        self._adjacency_mat = None\n\n        self._layout = None\n        self._layout_iter = None\n        self.layout = layout\n\n        self._directed = directed\n        self.directed = directed\n\n        self._animate = False\n        self.animate = animate\n\n        CompoundVisual.__init__(self, [self._edges, self._nodes])\n\n        self.set_data(adjacency_mat, line_color=line_color,\n                      line_width=line_width, arrow_type=arrow_type,\n                      arrow_size=arrow_size, node_symbol=node_symbol,\n                      node_size=node_size, border_color=border_color,\n                      face_color=face_color, border_width=border_width)",
  "def adjacency_matrix(self):\n        return self._adjacency_mat",
  "def layout(self):\n        return self._layout",
  "def layout(self, value):\n        if isinstance(value, str):\n            self._layout = layouts.get_layout(value)\n        else:\n            assert callable(value)\n            self._layout = value\n\n        self._layout_iter = None",
  "def directed(self):\n        return self._directed",
  "def directed(self, value):\n        self._directed = bool(value)",
  "def animate(self):\n        return self._animate",
  "def animate(self, value):\n        self._animate = bool(value)",
  "def animate_layout(self):\n        if self._layout_iter is None:\n            if self._adjacency_mat is None:\n                raise ValueError(\"No adjacency matrix set yet. An adjacency \"\n                                 \"matrix is required to calculate the layout.\")\n\n            self._layout_iter = iter(self._layout(self._adjacency_mat,\n                                                  self._directed))\n\n        try:\n            node_vertices, line_vertices, arrows = next(self._layout_iter)\n        except StopIteration:\n            return True\n\n        self._nodes.set_data(pos=node_vertices, **self._node_data)\n        for k, v in self._node_properties.items():\n            setattr(self._nodes, k, v)\n\n        self._edges.set_data(pos=line_vertices, arrows=arrows,\n                             **self._arrow_data)\n\n        return False",
  "def set_final_layout(self):\n        if self._layout_iter is None:\n            if self._adjacency_mat is None:\n                raise ValueError(\"No adjacency matrix set yet. An adjacency \"\n                                 \"matrix is required to calculate the layout.\")\n\n            self._layout_iter = iter(self._layout(self._adjacency_mat,\n                                                  self._directed))\n\n        # Calculate the final position of the nodes and lines\n        node_vertices = None\n        line_vertices = None\n        arrows = None\n        for node_vertices, line_vertices, arrows in self._layout_iter:\n            pass\n\n        self._nodes.set_data(pos=node_vertices, **self._node_data)\n        for k, v in self._node_properties.items():\n            setattr(self._nodes, k, v)\n\n        self._edges.set_data(pos=line_vertices, arrows=arrows,\n                             **self._arrow_data)",
  "def reset_layout(self):\n        self._layout_iter = None",
  "def set_data(self, adjacency_mat=None, **kwargs):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        adjacency_mat : ndarray | None\n            The adjacency matrix.\n        **kwargs : dict\n            Keyword arguments to pass to the arrows.\n        \"\"\"\n        if adjacency_mat is not None:\n            if adjacency_mat.shape[0] != adjacency_mat.shape[1]:\n                raise ValueError(\"Adjacency matrix should be square.\")\n\n            self._adjacency_mat = adjacency_mat\n\n        for k in self._arrow_attributes:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                setattr(self._edges, translated, kwargs.pop(k))\n\n        arrow_kwargs = {}\n        for k in self._arrow_kwargs:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                arrow_kwargs[translated] = kwargs.pop(k)\n\n        node_kwargs = {}\n        for k in self._node_kwargs:\n            if k in kwargs:\n                translated = (self._node_kw_trans[k] if k in\n                              self._node_kw_trans else k)\n\n                node_kwargs[translated] = kwargs.pop(k)\n\n        if len(kwargs) > 0:\n            raise TypeError(\"%s.set_data() got invalid keyword arguments: %s\"\n                            % (self.__class__.__name__, list(kwargs.keys())))\n\n        # some attributes should be set as properties\n        node_properties = {}\n        for k, v in list(node_kwargs.items()):\n            if k in (self._node_properties_args):\n                node_properties[k] = node_kwargs.pop(k)\n\n        # The actual data is set in GraphVisual.animate_layout or\n        # GraphVisual.set_final_layout\n        self._arrow_data = arrow_kwargs\n        self._node_data = node_kwargs\n        self._node_properties = node_properties\n\n        if not self._animate:\n            self.set_final_layout()",
  "class fruchterman_reingold(object):\n    r\"\"\"Fruchterman-Reingold implementation adapted from NetworkX.\n\n    In the Fruchterman-Reingold algorithm, the whole graph is modelled as a\n    collection of particles, it runs a simplified particle simulation to\n    find a nice layout for the graph.\n\n    Parameters\n    ----------\n    optimal : number\n        Optimal distance between nodes. Defaults to :math:`1/\\\\sqrt{N}` where\n        N is the number of nodes.\n    iterations : int\n        Number of iterations to perform for layout calculation.\n    pos : array\n        Initial positions of the nodes\n\n    Notes\n    -----\n    The algorithm is explained in more detail in the original paper [1]_.\n\n    .. [1] Fruchterman, Thomas MJ, and Edward M. Reingold. \"Graph drawing by\n       force-directed placement.\" Softw., Pract. Exper. 21.11 (1991),\n       1129-1164.\n    \"\"\"\n\n    def __init__(self, optimal=None, iterations=50, pos=None):\n        self.dim = 2\n        self.optimal = optimal\n        self.iterations = iterations\n        self.num_nodes = None\n        self.pos = pos\n\n    def __call__(self, adjacency_mat, directed=False):\n        \"\"\"\n        Starts the calculation of the graph layout.\n\n        This is a generator, and after each iteration it yields the new\n        positions for the nodes, together with the vertices for the edges\n        and the arrows.\n\n        There are two solvers here: one specially adapted for SciPy sparse\n        matrices, and the other for larger networks.\n\n        Parameters\n        ----------\n        adjacency_mat : array\n            The graph adjacency matrix.\n        directed : bool\n            Wether the graph is directed or not. If this is True,\n            it will draw arrows for directed edges.\n\n        Yields\n        ------\n        layout : tuple\n            For each iteration of the layout calculation it yields a tuple\n            containing (node_vertices, line_vertices, arrow_vertices). These\n            vertices can be passed to the `MarkersVisual` and `ArrowVisual`.\n        \"\"\"\n        if adjacency_mat.shape[0] != adjacency_mat.shape[1]:\n            raise ValueError(\"Adjacency matrix should be square.\")\n\n        self.num_nodes = adjacency_mat.shape[0]\n\n        if issparse(adjacency_mat):\n            # Use the sparse solver\n            solver = self._sparse_fruchterman_reingold\n        else:\n            solver = self._fruchterman_reingold\n\n        for result in solver(adjacency_mat, directed):\n            yield result\n\n    def _fruchterman_reingold(self, adjacency_mat, directed=False):\n        if self.optimal is None:\n            self.optimal = 1 / np.sqrt(self.num_nodes)\n\n        if self.pos is None:\n            # Random initial positions\n            pos = np.asarray(\n                np.random.random((self.num_nodes, self.dim)),\n                dtype=np.float32\n            )\n        else:\n            pos = self.pos.astype(np.float32)\n\n        # Yield initial positions\n        line_vertices, arrows = _straight_line_vertices(adjacency_mat, pos,\n                                                        directed)\n        yield pos, line_vertices, arrows\n\n        # The initial \"temperature\"  is about .1 of domain area (=1x1)\n        # this is the largest step allowed in the dynamics.\n        t = 0.1\n\n        # Simple cooling scheme.\n        # Linearly step down by dt on each iteration so last iteration is\n        # size dt.\n        dt = t / float(self.iterations+1)\n        # The inscrutable (but fast) version\n        # This is still O(V^2)\n        # Could use multilevel methods to speed this up significantly\n        for iteration in range(self.iterations):\n            delta_pos = _calculate_delta_pos(adjacency_mat, pos, t,\n                                             self.optimal)\n            pos += delta_pos\n            _rescale_layout(pos)\n\n            # cool temperature\n            t -= dt\n\n            # Calculate edge vertices and arrows\n            line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                            pos, directed)\n\n            yield pos, line_vertices, arrows\n\n    def _sparse_fruchterman_reingold(self, adjacency_mat, directed=False):\n        # Optimal distance between nodes\n        if self.optimal is None:\n            self.optimal = 1 / np.sqrt(self.num_nodes)\n\n        # Change to list of list format\n        # Also construct the matrix in COO format for easy edge construction\n        adjacency_arr = adjacency_mat.toarray()\n        adjacency_coo = adjacency_mat.tocoo()\n\n        if self.pos is None:\n            # Random initial positions\n            pos = np.asarray(\n                np.random.random((self.num_nodes, self.dim)),\n                dtype=np.float32\n            )\n        else:\n            pos = self.pos.astype(np.float32)\n\n        # Yield initial positions\n        line_vertices, arrows = _straight_line_vertices(adjacency_coo, pos,\n                                                        directed)\n        yield pos, line_vertices, arrows\n\n        # The initial \"temperature\"  is about .1 of domain area (=1x1)\n        # This is the largest step allowed in the dynamics.\n        t = 0.1\n        # Simple cooling scheme.\n        # Linearly step down by dt on each iteration so last iteration is\n        # size dt.\n        dt = t / float(self.iterations+1)\n        for iteration in range(self.iterations):\n            delta_pos = _calculate_delta_pos(adjacency_arr, pos, t,\n                                             self.optimal)\n            pos += delta_pos\n            _rescale_layout(pos)\n\n            # Cool temperature\n            t -= dt\n\n            # Calculate line vertices\n            line_vertices, arrows = _straight_line_vertices(adjacency_coo,\n                                                            pos, directed)\n\n            yield pos, line_vertices, arrows",
  "def _calculate_delta_pos(adjacency_arr, pos, t, optimal):\n    \"\"\"Helper to calculate the delta position\"\"\"\n    # XXX eventually this should be refactored for the sparse case to only\n    # do the necessary pairwise distances\n    delta = pos[:, np.newaxis, :] - pos\n\n    # Distance between points\n    distance2 = (delta*delta).sum(axis=-1)\n    # Enforce minimum distance of 0.01\n    distance2 = np.where(distance2 < 0.0001, 0.0001, distance2)\n    distance = np.sqrt(distance2)\n    # Displacement \"force\"\n    displacement = np.zeros((len(delta), 2))\n    for ii in range(2):\n        displacement[:, ii] = (\n            delta[:, :, ii] *\n            ((optimal * optimal) / (distance*distance) -\n             (adjacency_arr * distance) / optimal)).sum(axis=1)\n\n    length = np.sqrt((displacement**2).sum(axis=1))\n    length = np.where(length < 0.01, 0.1, length)\n    delta_pos = displacement * t / length[:, np.newaxis]\n    return delta_pos",
  "def __init__(self, optimal=None, iterations=50, pos=None):\n        self.dim = 2\n        self.optimal = optimal\n        self.iterations = iterations\n        self.num_nodes = None\n        self.pos = pos",
  "def __call__(self, adjacency_mat, directed=False):\n        \"\"\"\n        Starts the calculation of the graph layout.\n\n        This is a generator, and after each iteration it yields the new\n        positions for the nodes, together with the vertices for the edges\n        and the arrows.\n\n        There are two solvers here: one specially adapted for SciPy sparse\n        matrices, and the other for larger networks.\n\n        Parameters\n        ----------\n        adjacency_mat : array\n            The graph adjacency matrix.\n        directed : bool\n            Wether the graph is directed or not. If this is True,\n            it will draw arrows for directed edges.\n\n        Yields\n        ------\n        layout : tuple\n            For each iteration of the layout calculation it yields a tuple\n            containing (node_vertices, line_vertices, arrow_vertices). These\n            vertices can be passed to the `MarkersVisual` and `ArrowVisual`.\n        \"\"\"\n        if adjacency_mat.shape[0] != adjacency_mat.shape[1]:\n            raise ValueError(\"Adjacency matrix should be square.\")\n\n        self.num_nodes = adjacency_mat.shape[0]\n\n        if issparse(adjacency_mat):\n            # Use the sparse solver\n            solver = self._sparse_fruchterman_reingold\n        else:\n            solver = self._fruchterman_reingold\n\n        for result in solver(adjacency_mat, directed):\n            yield result",
  "def _fruchterman_reingold(self, adjacency_mat, directed=False):\n        if self.optimal is None:\n            self.optimal = 1 / np.sqrt(self.num_nodes)\n\n        if self.pos is None:\n            # Random initial positions\n            pos = np.asarray(\n                np.random.random((self.num_nodes, self.dim)),\n                dtype=np.float32\n            )\n        else:\n            pos = self.pos.astype(np.float32)\n\n        # Yield initial positions\n        line_vertices, arrows = _straight_line_vertices(adjacency_mat, pos,\n                                                        directed)\n        yield pos, line_vertices, arrows\n\n        # The initial \"temperature\"  is about .1 of domain area (=1x1)\n        # this is the largest step allowed in the dynamics.\n        t = 0.1\n\n        # Simple cooling scheme.\n        # Linearly step down by dt on each iteration so last iteration is\n        # size dt.\n        dt = t / float(self.iterations+1)\n        # The inscrutable (but fast) version\n        # This is still O(V^2)\n        # Could use multilevel methods to speed this up significantly\n        for iteration in range(self.iterations):\n            delta_pos = _calculate_delta_pos(adjacency_mat, pos, t,\n                                             self.optimal)\n            pos += delta_pos\n            _rescale_layout(pos)\n\n            # cool temperature\n            t -= dt\n\n            # Calculate edge vertices and arrows\n            line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                            pos, directed)\n\n            yield pos, line_vertices, arrows",
  "def _sparse_fruchterman_reingold(self, adjacency_mat, directed=False):\n        # Optimal distance between nodes\n        if self.optimal is None:\n            self.optimal = 1 / np.sqrt(self.num_nodes)\n\n        # Change to list of list format\n        # Also construct the matrix in COO format for easy edge construction\n        adjacency_arr = adjacency_mat.toarray()\n        adjacency_coo = adjacency_mat.tocoo()\n\n        if self.pos is None:\n            # Random initial positions\n            pos = np.asarray(\n                np.random.random((self.num_nodes, self.dim)),\n                dtype=np.float32\n            )\n        else:\n            pos = self.pos.astype(np.float32)\n\n        # Yield initial positions\n        line_vertices, arrows = _straight_line_vertices(adjacency_coo, pos,\n                                                        directed)\n        yield pos, line_vertices, arrows\n\n        # The initial \"temperature\"  is about .1 of domain area (=1x1)\n        # This is the largest step allowed in the dynamics.\n        t = 0.1\n        # Simple cooling scheme.\n        # Linearly step down by dt on each iteration so last iteration is\n        # size dt.\n        dt = t / float(self.iterations+1)\n        for iteration in range(self.iterations):\n            delta_pos = _calculate_delta_pos(adjacency_arr, pos, t,\n                                             self.optimal)\n            pos += delta_pos\n            _rescale_layout(pos)\n\n            # Cool temperature\n            t -= dt\n\n            # Calculate line vertices\n            line_vertices, arrows = _straight_line_vertices(adjacency_coo,\n                                                            pos, directed)\n\n            yield pos, line_vertices, arrows",
  "def issparse(*args, **kwargs):\n        return False",
  "def circular(adjacency_mat, directed=False):\n    \"\"\"Places all nodes on a single circle.\n\n    Parameters\n    ----------\n    adjacency_mat : matrix or sparse\n        The graph adjacency matrix\n    directed : bool\n        Whether the graph is directed. If this is True, is will also\n        generate the vertices for arrows, which can be passed to an\n        ArrowVisual.\n\n    Yields\n    ------\n    (node_vertices, line_vertices, arrow_vertices) : tuple\n        Yields the node and line vertices in a tuple. This layout only yields a\n        single time, and has no builtin animation\n    \"\"\"\n    if issparse(adjacency_mat):\n        adjacency_mat = adjacency_mat.tocoo()\n\n    num_nodes = adjacency_mat.shape[0]\n\n    t = np.linspace(0, 2 * np.pi, num_nodes, endpoint=False)\n\n    # Visual coordinate system is between 0 and 1, so generate a circle with\n    # radius 0.5 and center it at the point (0.5, 0.5).\n    node_coords = (0.5 * np.array([np.cos(t), np.sin(t)]) + 0.5).T\n    node_coords = node_coords.astype(np.float32)\n\n    line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                    node_coords, directed)\n\n    yield node_coords, line_vertices, arrows",
  "class NetworkxCoordinates:\n    def __init__(self, graph=None, layout=None, **kwargs):\n        \"\"\"\n        Converts :graph: into a layout. Can be used in conjunction with networkx layouts or using raw 2D-numpy arrays.\n\n        Parameters\n        ----------\n        graph : a networkx graph.\n        layout : str or dict or iterable-object of float32, optional\n        - When :layout: is s string, a lookup will be performed in the networkx avaiable layouts.\n        - When :layout: is a dict, it will be assumed that it takes the shape (key, value) = (node_id, 2D-coordinate).\n        - When :layout: is numpy array it is assumed it takes the shape (number_of_nodes, 2).\n        kwargs: dict, optional\n        when layout is :str: :kwargs: will act as a setting dictionary for the layout function of networkx\n        \"\"\"\n        if nx is None:\n            raise ValueError(\"networkx not found, please install networkx to use its layouts\")\n        if isinstance(graph, type(None)):\n            raise ValueError(\"Requires networkx input\")\n        self.graph = graph\n        self.positions = np.zeros((len(graph), 2), dtype=np.float32)\n        # default random positions\n        if isinstance(layout, type(None)):\n            self.positions = np.random.rand(*self.positions.shape)\n\n        # check for networkx\n        elif isinstance(layout, str):\n            if not layout.endswith(\"_layout\"):\n                layout += \"_layout\"  # append for nx\n            layout_function = getattr(nx, layout)\n            if layout_function:\n                self.positions = np.asarray(\n                    [i for i in dict(layout_function(graph, **kwargs)).values()])\n            else:\n                raise ValueError(\"Check networkx for layouts\")\n        # assume dict from networkx; values are 2-array\n        elif isinstance(layout, dict):\n            self.positions = np.asarray([i for i in layout.values()])\n\n        # assume given values\n        elif isinstance(layout, np.ndarray):\n            assert layout.ndim == 2\n            assert layout.shape[0] == len(graph)\n            self.positions = layout\n        else:\n            raise ValueError(\"Input not understood\")\n\n        # normalize coordinates\n        self.positions = (self.positions - self.positions.min()) / \\\n            (self.positions.max() - self.positions.min())\n        self.positions = self.positions.astype(np.float32)\n\n    def __call__(self, adjacency_mat, directed=False):\n        \"\"\"\n        Parameters\n        ----------\n        adjacency_mat : sparse adjacency matrix.\n        directed : bool, default False\n\n        Returns\n        ---------\n        (node_vertices, line_vertices, arrow_vertices) : tuple\n        Yields the node and line vertices in a tuple. This layout only yields a\n        single time, and has no builtin animation\n        \"\"\"\n        if issparse(adjacency_mat):\n            adjacency_mat = adjacency_mat.tocoo()\n        line_vertices, arrows = _straight_line_vertices(\n            adjacency_mat, self.positions, directed)\n\n        yield self.positions, line_vertices, arrows\n\n    @property\n    def adj(self):\n        \"\"\"Convenient storage and holder of the adjacency matrix for the :scene.visuals.Graph: function.\"\"\"\n        return nx.adjacency_matrix(self.graph)",
  "def __init__(self, graph=None, layout=None, **kwargs):\n        \"\"\"\n        Converts :graph: into a layout. Can be used in conjunction with networkx layouts or using raw 2D-numpy arrays.\n\n        Parameters\n        ----------\n        graph : a networkx graph.\n        layout : str or dict or iterable-object of float32, optional\n        - When :layout: is s string, a lookup will be performed in the networkx avaiable layouts.\n        - When :layout: is a dict, it will be assumed that it takes the shape (key, value) = (node_id, 2D-coordinate).\n        - When :layout: is numpy array it is assumed it takes the shape (number_of_nodes, 2).\n        kwargs: dict, optional\n        when layout is :str: :kwargs: will act as a setting dictionary for the layout function of networkx\n        \"\"\"\n        if nx is None:\n            raise ValueError(\"networkx not found, please install networkx to use its layouts\")\n        if isinstance(graph, type(None)):\n            raise ValueError(\"Requires networkx input\")\n        self.graph = graph\n        self.positions = np.zeros((len(graph), 2), dtype=np.float32)\n        # default random positions\n        if isinstance(layout, type(None)):\n            self.positions = np.random.rand(*self.positions.shape)\n\n        # check for networkx\n        elif isinstance(layout, str):\n            if not layout.endswith(\"_layout\"):\n                layout += \"_layout\"  # append for nx\n            layout_function = getattr(nx, layout)\n            if layout_function:\n                self.positions = np.asarray(\n                    [i for i in dict(layout_function(graph, **kwargs)).values()])\n            else:\n                raise ValueError(\"Check networkx for layouts\")\n        # assume dict from networkx; values are 2-array\n        elif isinstance(layout, dict):\n            self.positions = np.asarray([i for i in layout.values()])\n\n        # assume given values\n        elif isinstance(layout, np.ndarray):\n            assert layout.ndim == 2\n            assert layout.shape[0] == len(graph)\n            self.positions = layout\n        else:\n            raise ValueError(\"Input not understood\")\n\n        # normalize coordinates\n        self.positions = (self.positions - self.positions.min()) / \\\n            (self.positions.max() - self.positions.min())\n        self.positions = self.positions.astype(np.float32)",
  "def __call__(self, adjacency_mat, directed=False):\n        \"\"\"\n        Parameters\n        ----------\n        adjacency_mat : sparse adjacency matrix.\n        directed : bool, default False\n\n        Returns\n        ---------\n        (node_vertices, line_vertices, arrow_vertices) : tuple\n        Yields the node and line vertices in a tuple. This layout only yields a\n        single time, and has no builtin animation\n        \"\"\"\n        if issparse(adjacency_mat):\n            adjacency_mat = adjacency_mat.tocoo()\n        line_vertices, arrows = _straight_line_vertices(\n            adjacency_mat, self.positions, directed)\n\n        yield self.positions, line_vertices, arrows",
  "def adj(self):\n        \"\"\"Convenient storage and holder of the adjacency matrix for the :scene.visuals.Graph: function.\"\"\"\n        return nx.adjacency_matrix(self.graph)",
  "def get_layout(name, *args, **kwargs):\n    \"\"\"\n    Retrieve a graph layout\n\n    Some graph layouts accept extra options. Please refer to their\n    documentation for more information.\n\n    Parameters\n    ----------\n    name : string\n        The name of the layout. The variable `AVAILABLE_LAYOUTS`\n        contains all available layouts.\n    *args\n        Positional arguments which are passed to the layout.\n    **kwargs\n        Keyword arguments which are passed to the layout.\n\n    Returns\n    -------\n    layout : callable\n        The callable generator which will calculate the graph layout\n    \"\"\"\n    if name not in _layout_map:\n        raise KeyError(\"Graph layout '%s' not found. Should be one of %s\"\n                       % (name, AVAILABLE_LAYOUTS))\n\n    layout = _layout_map[name]\n\n    if inspect.isclass(layout):\n        layout = layout(*args, **kwargs)\n\n    return layout",
  "def random(adjacency_mat, directed=False, random_state=None):\n    \"\"\"\n    Place the graph nodes at random places.\n\n    Parameters\n    ----------\n    adjacency_mat : matrix or sparse\n        The graph adjacency matrix\n    directed : bool\n        Whether the graph is directed. If this is True, is will also\n        generate the vertices for arrows, which can be passed to an\n        ArrowVisual.\n    random_state : instance of RandomState | int | None\n        Random state to use. Can be None to use ``np.random``.\n\n    Yields\n    ------\n    (node_vertices, line_vertices, arrow_vertices) : tuple\n        Yields the node and line vertices in a tuple. This layout only yields a\n        single time, and has no builtin animation\n    \"\"\"\n    if random_state is None:\n        random_state = np.random\n    elif not isinstance(random_state, np.random.RandomState):\n        random_state = np.random.RandomState(random_state)\n\n    if issparse(adjacency_mat):\n        adjacency_mat = adjacency_mat.tocoo()\n\n    # Randomly place nodes, visual coordinate system is between 0 and 1\n    num_nodes = adjacency_mat.shape[0]\n    node_coords = random_state.rand(num_nodes, 2)\n\n    line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                    node_coords, directed)\n\n    yield node_coords, line_vertices, arrows",
  "class SceneMouseEvent(Event):\n    \"\"\"Represents a mouse event that occurred on a SceneCanvas. This event is\n    delivered to all entities whose mouse interaction area is under the event.\n    \"\"\"\n\n    def __init__(self, event, visual):\n        self.mouse_event = event\n        self.visual = visual\n        Event.__init__(self, type=event.type)\n\n    @property\n    def visual(self):\n        return self._visual\n\n    @visual.setter\n    def visual(self, v):\n        self._visual = v\n        self._pos = None\n\n    @property\n    def pos(self):\n        \"\"\"The position of this event in the local coordinate system of the\n        visual.\n        \"\"\"\n        if self._pos is None:\n            tr = self.visual.get_transform('canvas', 'visual')\n            self._pos = tr.map(self.mouse_event.pos)\n        return self._pos\n\n    @property\n    def last_event(self):\n        \"\"\"The mouse event immediately prior to this one. This\n        property is None when no mouse buttons are pressed.\n        \"\"\"\n        if self.mouse_event.last_event is None:\n            return None\n        ev = self.copy()\n        ev.mouse_event = self.mouse_event.last_event\n        return ev\n\n    @property\n    def press_event(self):\n        \"\"\"The mouse press event that initiated a mouse drag, if any.\"\"\"\n        if self.mouse_event.press_event is None:\n            return None\n        ev = self.copy()\n        ev.mouse_event = self.mouse_event.press_event\n        return ev\n\n    @property\n    def button(self):\n        \"\"\"The button pressed or released on this event.\"\"\"\n        return self.mouse_event.button\n\n    @property\n    def buttons(self):\n        \"\"\"A list of all buttons currently pressed on the mouse.\"\"\"\n        return self.mouse_event.buttons\n\n    @property\n    def delta(self):\n        \"\"\"The increment by which the mouse wheel has moved.\"\"\"\n        return self.mouse_event.delta\n\n    def copy(self):\n        ev = self.__class__(self.mouse_event, self.visual)\n        return ev",
  "def __init__(self, event, visual):\n        self.mouse_event = event\n        self.visual = visual\n        Event.__init__(self, type=event.type)",
  "def visual(self):\n        return self._visual",
  "def visual(self, v):\n        self._visual = v\n        self._pos = None",
  "def pos(self):\n        \"\"\"The position of this event in the local coordinate system of the\n        visual.\n        \"\"\"\n        if self._pos is None:\n            tr = self.visual.get_transform('canvas', 'visual')\n            self._pos = tr.map(self.mouse_event.pos)\n        return self._pos",
  "def last_event(self):\n        \"\"\"The mouse event immediately prior to this one. This\n        property is None when no mouse buttons are pressed.\n        \"\"\"\n        if self.mouse_event.last_event is None:\n            return None\n        ev = self.copy()\n        ev.mouse_event = self.mouse_event.last_event\n        return ev",
  "def press_event(self):\n        \"\"\"The mouse press event that initiated a mouse drag, if any.\"\"\"\n        if self.mouse_event.press_event is None:\n            return None\n        ev = self.copy()\n        ev.mouse_event = self.mouse_event.press_event\n        return ev",
  "def button(self):\n        \"\"\"The button pressed or released on this event.\"\"\"\n        return self.mouse_event.button",
  "def buttons(self):\n        \"\"\"A list of all buttons currently pressed on the mouse.\"\"\"\n        return self.mouse_event.buttons",
  "def delta(self):\n        \"\"\"The increment by which the mouse wheel has moved.\"\"\"\n        return self.mouse_event.delta",
  "def copy(self):\n        ev = self.__class__(self.mouse_event, self.visual)\n        return ev",
  "class VisualNode(Node):\n    _next_id = 1\n    _visual_ids = weakref.WeakValueDictionary()\n\n    def __init__(self, parent=None, name=None):\n        Node.__init__(self, parent=parent, name=name,\n                      transforms=self.transforms)\n        self.interactive = False\n        self._opacity_filter = Alpha()\n        self.attach(self._opacity_filter)\n\n        self._id = VisualNode._next_id\n        VisualNode._visual_ids[self._id] = self\n        VisualNode._next_id += 1\n        self._picking_filter = PickingFilter(id_=self._id)\n        self.attach(self._picking_filter)\n\n    def _update_opacity(self):\n        self._opacity_filter.alpha = self._opacity\n        self.update()\n\n    def _set_clipper(self, node, clipper):\n        \"\"\"Assign a clipper that is inherited from a parent node.\n\n        If *clipper* is None, then remove any clippers for *node*.\n        \"\"\"\n        if node in self._clippers:\n            self.detach(self._clippers.pop(node))\n        if clipper is not None:\n            self.attach(clipper)\n            self._clippers[node] = clipper\n\n    @property\n    def picking(self):\n        \"\"\"Boolean that determines whether this node (and its children) are\n        drawn in picking mode.\n        \"\"\"\n        return self._picking\n\n    @picking.setter\n    def picking(self, p):\n        for c in self.children:\n            c.picking = p\n        if self._picking == p:\n            return\n        self._picking = p\n        self._picking_filter.enabled = p\n        self.update_gl_state(blend=not p)\n\n    def _update_trsys(self, event):\n        \"\"\"Transform object(s) have changed for this Node; assign these to the\n        visual's TransformSystem.\n        \"\"\"\n        doc = self.document_node\n        scene = self.scene_node\n        root = self.root_node\n        self.transforms.visual_transform = self.node_transform(scene)\n        self.transforms.scene_transform = scene.node_transform(doc)\n        self.transforms.document_transform = doc.node_transform(root)\n\n        Node._update_trsys(self, event)\n\n    @property\n    def interactive(self):\n        \"\"\"Whether this widget should be allowed to accept mouse and touch\n        events.\n        \"\"\"\n        return self._interactive\n\n    @interactive.setter\n    def interactive(self, i):\n        self._interactive = i\n\n    def draw(self):\n        if self.picking and not self.interactive:\n            return\n        self._visual_superclass.draw(self)",
  "def create_visual_node(subclass: _T) -> _T:\n    # Create a new subclass of Node.\n\n    # Decide on new class name\n    clsname = subclass.__name__\n    if not (clsname.endswith('Visual') and\n            issubclass(subclass, visuals.BaseVisual)):\n        raise RuntimeError('Class \"%s\" must end with Visual, and must '\n                           'subclass BaseVisual' % clsname)\n    clsname = clsname[:-6]\n\n    # Generate new docstring based on visual docstring\n    try:\n        doc = generate_docstring(subclass, clsname)\n    except Exception:\n        # If parsing fails, just return the original Visual docstring\n        doc = subclass.__doc__\n\n    # New __init__ method\n    def __init__(self, *args, **kwargs):\n        parent = kwargs.pop('parent', None)\n        name = kwargs.pop('name', None)\n        self.name = name  # to allow __str__ before Node.__init__\n        self._visual_superclass = subclass\n\n        subclass.__init__(self, *args, **kwargs)\n        self.unfreeze()\n        VisualNode.__init__(self, parent=parent, name=name)\n        self.freeze()\n\n    # Create new class\n    cls = type(clsname, (VisualNode, subclass),\n               {'__init__': __init__, '__doc__': doc})\n\n    return cls",
  "def generate_docstring(subclass, clsname):\n    # Generate a Visual+Node docstring by modifying the Visual's docstring\n    # to include information about Node inheritance and extra init args.\n\n    sc_doc = subclass.__doc__\n    if sc_doc is None:\n        sc_doc = \"\"\n\n    # find locations within docstring to insert new parameters\n    lines = sc_doc.split(\"\\n\")\n\n    # discard blank lines at start\n    while lines and lines[0].strip() == '':\n        lines.pop(0)\n\n    i = 0\n    params_started = False\n    param_indent = None\n    first_blank = None\n    param_end = None\n    while i < len(lines):\n        line = lines[i]\n        # ignore blank lines and '------' lines\n        if re.search(r'\\w', line):\n            indent = len(line) - len(line.lstrip())\n            # If Params section has already started, check for end of params\n            # (that is where we will insert new params)\n            if params_started:\n                if indent < param_indent:\n                    break\n                elif indent == param_indent:\n                    # might be end of parameters block..\n                    if re.match(r'\\s*[a-zA-Z0-9_]+\\s*:\\s*\\S+', line) is None:\n                        break\n                param_end = i + 1\n\n            # Check for beginning of params section\n            elif re.match(r'\\s*Parameters\\s*', line):\n                params_started = True\n                param_indent = indent\n                if first_blank is None:\n                    first_blank = i\n\n        # Check for first blank line\n        # (this is where the Node inheritance description will be\n        # inserted)\n        elif first_blank is None and line.strip() == '':\n            first_blank = i\n\n        i += 1\n        if i == len(lines) and param_end is None:\n            # reached end of docstring; insert here\n            param_end = i\n\n    # If original docstring has no params heading, we need to generate it.\n    if not params_started:\n        lines.extend([\"\", \"    Parameters\", \"    ----------\"])\n        param_end = len(lines)\n        if first_blank is None:\n            first_blank = param_end - 3\n        params_started = True\n\n    # build class and parameter description strings\n    class_desc = (\"\\n    This class inherits from visuals.%sVisual and \"\n                  \"scene.Node, allowing the visual to be placed inside a \"\n                  \"scenegraph.\\n\" % (clsname))\n    parm_doc = (\"    parent : Node\\n\"\n                \"        The parent node to assign to this node (optional).\\n\"\n                \"    name : string\\n\"\n                \"        A name for this node, used primarily for debugging\\n\"\n                \"        (optional).\")\n\n    # assemble all docstring parts\n    lines = (lines[:first_blank] +\n             [class_desc] +\n             lines[first_blank:param_end] +\n             [parm_doc] +\n             lines[param_end:])\n\n    doc = '\\n'.join(lines)\n    return doc",
  "def __init__(self, parent=None, name=None):\n        Node.__init__(self, parent=parent, name=name,\n                      transforms=self.transforms)\n        self.interactive = False\n        self._opacity_filter = Alpha()\n        self.attach(self._opacity_filter)\n\n        self._id = VisualNode._next_id\n        VisualNode._visual_ids[self._id] = self\n        VisualNode._next_id += 1\n        self._picking_filter = PickingFilter(id_=self._id)\n        self.attach(self._picking_filter)",
  "def _update_opacity(self):\n        self._opacity_filter.alpha = self._opacity\n        self.update()",
  "def _set_clipper(self, node, clipper):\n        \"\"\"Assign a clipper that is inherited from a parent node.\n\n        If *clipper* is None, then remove any clippers for *node*.\n        \"\"\"\n        if node in self._clippers:\n            self.detach(self._clippers.pop(node))\n        if clipper is not None:\n            self.attach(clipper)\n            self._clippers[node] = clipper",
  "def picking(self):\n        \"\"\"Boolean that determines whether this node (and its children) are\n        drawn in picking mode.\n        \"\"\"\n        return self._picking",
  "def picking(self, p):\n        for c in self.children:\n            c.picking = p\n        if self._picking == p:\n            return\n        self._picking = p\n        self._picking_filter.enabled = p\n        self.update_gl_state(blend=not p)",
  "def _update_trsys(self, event):\n        \"\"\"Transform object(s) have changed for this Node; assign these to the\n        visual's TransformSystem.\n        \"\"\"\n        doc = self.document_node\n        scene = self.scene_node\n        root = self.root_node\n        self.transforms.visual_transform = self.node_transform(scene)\n        self.transforms.scene_transform = scene.node_transform(doc)\n        self.transforms.document_transform = doc.node_transform(root)\n\n        Node._update_trsys(self, event)",
  "def interactive(self):\n        \"\"\"Whether this widget should be allowed to accept mouse and touch\n        events.\n        \"\"\"\n        return self._interactive",
  "def interactive(self, i):\n        self._interactive = i",
  "def draw(self):\n        if self.picking and not self.interactive:\n            return\n        self._visual_superclass.draw(self)",
  "def __init__(self, *args, **kwargs):\n        parent = kwargs.pop('parent', None)\n        name = kwargs.pop('name', None)\n        self.name = name  # to allow __str__ before Node.__init__\n        self._visual_superclass = subclass\n\n        subclass.__init__(self, *args, **kwargs)\n        self.unfreeze()\n        VisualNode.__init__(self, parent=parent, name=name)\n        self.freeze()",
  "class SceneCanvas(app.Canvas, Frozen):\n    \"\"\"A Canvas that automatically draws the contents of a scene\n\n    Parameters\n    ----------\n    title : str\n        The widget title\n    size : (width, height)\n        The size of the window.\n    position : (x, y)\n        The position of the window in screen coordinates.\n    show : bool\n        Whether to show the widget immediately. Default False.\n    autoswap : bool\n        Whether to swap the buffers automatically after a draw event.\n        Default True. If True, the ``swap_buffers`` Canvas method will\n        be called last (by default) by the ``canvas.draw`` event handler.\n    app : Application | str\n        Give vispy Application instance to use as a backend.\n        (vispy.app is used by default.) If str, then an application\n        using the chosen backend (e.g., 'pyglet') will be created.\n        Note the canvas application can be accessed at ``canvas.app``.\n    create_native : bool\n        Whether to create the widget immediately. Default True.\n    vsync : bool\n        Enable vertical synchronization.\n    resizable : bool\n        Allow the window to be resized.\n    decorate : bool\n        Decorate the window. Default True.\n    fullscreen : bool | int\n        If False, windowed mode is used (default). If True, the default\n        monitor is used. If int, the given monitor number is used.\n    config : dict\n        A dict with OpenGL configuration options, which is combined\n        with the default configuration options and used to initialize\n        the context. See ``canvas.context.config`` for possible\n        options.\n    shared : Canvas | GLContext | None\n        An existing canvas or context to share OpenGL objects with.\n    keys : str | dict | None\n        Default key mapping to use. If 'interactive', escape and F11 will\n        close the canvas and toggle full-screen mode, respectively.\n        If dict, maps keys to functions. If dict values are strings,\n        they are assumed to be ``Canvas`` methods, otherwise they should\n        be callable.\n    parent : widget-object\n        The parent widget if this makes sense for the used backend.\n    dpi : float | None\n        Resolution in dots-per-inch to use for the canvas. If dpi is None,\n        then the value will be determined by querying the global config first,\n        and then the operating system.\n    always_on_top : bool\n        If True, try to create the window in always-on-top mode.\n    px_scale : int > 0\n        A scale factor to apply between logical and physical pixels in addition\n        to the actual scale factor determined by the backend. This option\n        allows the scale factor to be adjusted for testing.\n    bgcolor : Color\n        The background color to use.\n\n    See also\n    --------\n    vispy.app.Canvas\n\n    Notes\n    -----\n    Receives the following events:\n\n        * initialize\n        * resize\n        * draw\n        * mouse_press\n        * mouse_release\n        * mouse_double_click\n        * mouse_move\n        * mouse_wheel\n        * key_press\n        * key_release\n        * stylus\n        * touch\n        * close\n\n    The ordering of the mouse_double_click, mouse_press, and mouse_release\n    events are not guaranteed to be consistent between backends. Only certain\n    backends natively support double-clicking (currently Qt and WX); on other\n    backends, they are detected manually with a fixed time delay.\n    This can cause problems with accessibility, as increasing the OS detection\n    time or using a dedicated double-click button will not be respected.\n    \"\"\"\n\n    def __init__(self, title='VisPy canvas', size=(800, 600), position=None,\n                 show=False, autoswap=True, app=None, create_native=True,\n                 vsync=False, resizable=True, decorate=True, fullscreen=False,\n                 config=None, shared=None, keys=None, parent=None, dpi=None,\n                 always_on_top=False, px_scale=1, bgcolor='black'):\n        self._scene = None\n        # A default widget that follows the shape of the canvas\n        self._central_widget = None\n        self._draw_order = weakref.WeakKeyDictionary()\n        self._drawing = False\n        self._update_pending = False\n        self._fb_stack = []\n        self._vp_stack = []\n        self._mouse_handler = None\n        self.transforms = TransformSystem(canvas=self)\n        self._bgcolor = Color(bgcolor).rgba\n\n        # Set to True to enable sending mouse events even when no button is\n        # pressed. Disabled by default because it is very expensive. Also\n        # private for now because this behavior / API needs more thought.\n        self._send_hover_events = False\n\n        super(SceneCanvas, self).__init__(\n            title, size, position, show, autoswap, app, create_native, vsync,\n            resizable, decorate, fullscreen, config, shared, keys, parent, dpi,\n            always_on_top, px_scale)\n        self.events.mouse_press.connect(self._process_mouse_event)\n        self.events.mouse_move.connect(self._process_mouse_event)\n        self.events.mouse_release.connect(self._process_mouse_event)\n        self.events.mouse_wheel.connect(self._process_mouse_event)\n\n        self.scene = SubScene()\n        self.freeze()\n\n    @property\n    def scene(self):\n        \"\"\"The SubScene object that represents the root node of the\n        scene graph to be displayed.\n        \"\"\"\n        return self._scene\n\n    @scene.setter\n    def scene(self, node):\n        oldscene = self._scene\n        self._scene = node\n        if oldscene is not None:\n            oldscene._set_canvas(None)\n            oldscene.events.children_change.disconnect(self._update_scenegraph)\n        if node is not None:\n            node._set_canvas(self)\n            node.events.children_change.connect(self._update_scenegraph)\n\n    @property\n    def central_widget(self):\n        \"\"\"Returns the default widget that occupies the entire area of the\n        canvas.\n        \"\"\"\n        if self._central_widget is None:\n            self._central_widget = Widget(size=self.size, parent=self.scene)\n        return self._central_widget\n\n    @property\n    def bgcolor(self):\n        return Color(self._bgcolor)\n\n    @bgcolor.setter\n    def bgcolor(self, color):\n        self._bgcolor = Color(color).rgba\n        if hasattr(self, '_backend'):\n            self.update()\n\n    def update(self, node=None):\n        \"\"\"Update the scene\n\n        Parameters\n        ----------\n        node : instance of Node\n            Not used.\n        \"\"\"\n        # TODO: use node bounds to keep track of minimum drawable area\n        if self._drawing:\n            return\n\n        # Keep things civil in the node update system. Once an update\n        # has been scheduled, there is no need to flood the event queue\n        # of the backend with additional updates.\n        if not self._update_pending:\n            self._update_pending = True\n            super(SceneCanvas, self).update()\n\n    def on_draw(self, event):\n        \"\"\"Draw handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The draw event.\n        \"\"\"\n        if self._scene is None:\n            return  # Can happen on initialization\n        logger.debug('Canvas draw')\n\n        # Now that a draw event is going to be handled, open up the\n        # scheduling of further updates\n        self._update_pending = False\n        self._draw_scene()\n\n    def render(self, region=None, size=None, bgcolor=None, crop=None, alpha=True):\n        \"\"\"Render the scene to an offscreen buffer and return the image array.\n\n        Parameters\n        ----------\n        region : tuple | None\n            Specifies the region of the canvas to render. Format is\n            (x, y, w, h). By default, the entire canvas is rendered.\n        size : tuple | None\n            Specifies the size of the image array to return. If no size is\n            given, then the size of the *region* is used, multiplied by the\n            pixel scaling factor of the canvas (see `pixel_scale`). This\n            argument allows the scene to be rendered at resolutions different\n            from the native canvas resolution.\n        bgcolor : instance of Color | None\n            The background color to use.\n        crop : array-like | None\n            If specified it determines the pixels read from the framebuffer.\n            In the format (x, y, w, h), relative to the region being rendered.\n        alpha : bool\n            If True (default) produce an RGBA array (h, w, 4). If False,\n            remove the Alpha channel and return the RGB array (h, w, 3).\n            This may be useful if blending of various elements requires a\n            solid background to produce the expected visualization.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region. If ``alpha`` is ``False``,\n            then only 3 channels will be returned (RGB).\n\n        \"\"\"\n        self.set_current()\n        # Set up a framebuffer to render to\n        offset = (0, 0) if region is None else region[:2]\n        csize = self.size if region is None else region[2:]\n        s = self.pixel_scale\n        size = tuple([int(x * s) for x in csize]) if size is None else size\n        fbo = gloo.FrameBuffer(color=gloo.RenderBuffer(size[::-1]),\n                               depth=gloo.RenderBuffer(size[::-1]))\n\n        self.push_fbo(fbo, offset, csize)\n        try:\n            self._draw_scene(bgcolor=bgcolor)\n            result = fbo.read(crop=crop)\n        finally:\n            self.pop_fbo()\n\n        if not alpha:\n            result = result[..., :3]\n        return result\n\n    def _draw_scene(self, bgcolor=None):\n        if bgcolor is None:\n            bgcolor = self._bgcolor\n        self.context.clear(color=bgcolor, depth=True)\n        self.draw_visual(self.scene)\n\n    def draw_visual(self, visual, event=None):\n        \"\"\"Draw a visual and its children to the canvas or currently active\n        framebuffer.\n\n        Parameters\n        ----------\n        visual : Visual\n            The visual to draw\n        event : None or DrawEvent\n            Optionally specifies the original canvas draw event that initiated\n            this draw.\n        \"\"\"\n        prof = Profiler()\n\n        # make sure this canvas's context is active\n        self.set_current()\n\n        try:\n            self._drawing = True\n            # get order to draw visuals\n            if visual not in self._draw_order:\n                self._draw_order[visual] = self._generate_draw_order()\n            order = self._draw_order[visual]\n\n            # draw (while avoiding branches with visible=False)\n            stack = []\n            invisible_node = None\n            for node, start in order:\n                if start:\n                    stack.append(node)\n                    if invisible_node is None:\n                        if not node.visible:\n                            # disable drawing until we exit this node's subtree\n                            invisible_node = node\n                        else:\n                            if hasattr(node, 'draw'):\n                                node.draw()\n                                prof.mark(str(node))\n                else:\n                    if node is invisible_node:\n                        invisible_node = None\n                    stack.pop()\n        finally:\n            self._drawing = False\n\n    def _generate_draw_order(self, node=None):\n        \"\"\"Return a list giving the order to draw visuals.\n\n        Each node appears twice in the list--(node, True) appears before the\n        node's children are drawn, and (node, False) appears after.\n        \"\"\"\n        if node is None:\n            node = self._scene\n        order = [(node, True)]\n        children = node.children\n        children.sort(key=lambda ch: ch.order)\n        for ch in children:\n            order.extend(self._generate_draw_order(ch))\n        order.append((node, False))\n        return order\n\n    def _update_scenegraph(self, event):\n        \"\"\"Called when topology of scenegraph has changed.\"\"\"\n        self._draw_order.clear()\n        self.update()\n\n    def _process_mouse_event(self, event):\n        prof = Profiler()  # noqa\n        deliver_types = ['mouse_press', 'mouse_wheel']\n        if self._send_hover_events:\n            deliver_types += ['mouse_move']\n\n        picked = self._mouse_handler\n        if picked is None:\n            if event.type in deliver_types:\n                picked = self.visual_at(event.pos)\n\n        # No visual to handle this event; bail out now\n        if picked is None:\n            return\n\n        # Create an event to pass to the picked visual\n        scene_event = SceneMouseEvent(event=event, visual=picked)\n\n        # Deliver the event\n        if picked == self._mouse_handler:\n            # If we already have a mouse handler, then no other node may\n            # receive the event\n            if event.type == 'mouse_release':\n                self._mouse_handler = None\n            getattr(picked.events, event.type)(scene_event)\n        else:\n            # If we don't have a mouse handler, then pass the event through\n            # the chain of parents until a node accepts the event.\n            while picked is not None:\n                getattr(picked.events, event.type)(scene_event)\n                if scene_event.handled:\n                    if event.type == 'mouse_press':\n                        self._mouse_handler = picked\n                    break\n                if event.type in deliver_types:\n                    # events that are not handled get passed to parent\n                    picked = picked.parent\n                    scene_event.visual = picked\n                else:\n                    picked = None\n\n        # If something in the scene handled the scene_event, then we mark\n        # the original event accordingly.\n        event.handled = scene_event.handled\n\n    def visual_at(self, pos):\n        \"\"\"Return the visual at a given position\n\n        Parameters\n        ----------\n        pos : tuple\n            The position in logical coordinates to query.\n\n        Returns\n        -------\n        visual : instance of Visual | None\n            The visual at the position, if it exists.\n        \"\"\"\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        fbpos = tr.map(pos)[:2]\n\n        try:\n            id_ = self._render_picking((fbpos[0], fbpos[1], 1, 1))\n            vis = VisualNode._visual_ids.get(id_[0, 0], None)\n        except RuntimeError:\n            # Don't have read_pixels() support for IPython. Fall back to\n            # bounds checking.\n            return self._visual_bounds_at(pos)\n        return vis\n\n    def _visual_bounds_at(self, pos, node=None):\n        \"\"\"Find a visual whose bounding rect encompasses *pos*.\"\"\"\n        if node is None:\n            node = self.scene\n\n        for ch in node.children:\n            hit = self._visual_bounds_at(pos, ch)\n            if hit is not None:\n                return hit\n\n        if (not isinstance(node, VisualNode) or not node.visible or\n                not node.interactive):\n            return None\n\n        # let nodes know we are picking to handle any special cases (picking meshes)\n        # we can't do this before this or child nodes may be considered visible\n        # which would cause the above 'if' statement to pass when it shouldn't\n        node.picking = True\n        bounds = [node.bounds(axis=i) for i in range(2)]\n        node.picking = False\n\n        if None in bounds:\n            return None\n\n        tr = self.scene.node_transform(node).inverse\n        corners = np.array([\n            [bounds[0][0], bounds[1][0]],\n            [bounds[0][0], bounds[1][1]],\n            [bounds[0][1], bounds[1][0]],\n            [bounds[0][1], bounds[1][1]]])\n        bounds = tr.map(corners)\n        xhit = bounds[:, 0].min() < pos[0] < bounds[:, 0].max()\n        yhit = bounds[:, 1].min() < pos[1] < bounds[:, 1].max()\n        if xhit and yhit:\n            return node\n\n    def visuals_at(self, pos, radius=10):\n        \"\"\"Return a list of visuals within *radius* pixels of *pos*.\n\n        Visuals are sorted by their proximity to *pos*.\n\n        Parameters\n        ----------\n        pos : tuple\n            (x, y) position at which to find visuals.\n        radius : int\n            Distance away from *pos* to search for visuals.\n        \"\"\"\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        pos = tr.map(pos)[:2]\n\n        id = self._render_picking((pos[0]-radius, pos[1]-radius,\n                                   radius * 2 + 1, radius * 2 + 1))\n        ids = []\n        seen = set()\n        for i in range(radius):\n            subr = id[radius-i:radius+i+1, radius-i:radius+i+1]\n            subr_ids = set(list(np.unique(subr)))\n            ids.extend(list(subr_ids - seen))\n            seen |= subr_ids\n        visuals = [VisualNode._visual_ids.get(x, None) for x in ids]\n        return [v for v in visuals if v is not None]\n\n    def _render_picking(self, crop):\n        \"\"\"Render the scene in picking mode, returning a 2D array of visual\n        IDs in the area specified by crop.\n\n        Parameters\n        ----------\n        crop : array-like\n            The crop (x, y, w, h) of the framebuffer to read. For picking the\n            full canvas is rendered and cropped on read as it is much faster\n            than triggering transform updates across the scene with every\n            click.\n        \"\"\"\n        try:\n            self._scene.picking = True\n            img = self.render(bgcolor=(0, 0, 0, 0), crop=crop)\n        finally:\n            self._scene.picking = False\n        img = img.astype('int32') * [2**0, 2**8, 2**16, 2**24]\n        id_ = img.sum(axis=2).astype('int32')\n        return id_\n\n    def on_resize(self, event):\n        \"\"\"Resize handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The resize event.\n        \"\"\"\n        self._update_transforms()\n\n        if self._central_widget is not None:\n            self._central_widget.size = self.size\n\n        if len(self._vp_stack) == 0:\n            self.context.set_viewport(0, 0, *self.physical_size)\n\n    def on_close(self, event):\n        \"\"\"Close event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.events.mouse_press.disconnect(self._process_mouse_event)\n        self.events.mouse_move.disconnect(self._process_mouse_event)\n        self.events.mouse_release.disconnect(self._process_mouse_event)\n        self.events.mouse_wheel.disconnect(self._process_mouse_event)\n\n    # -------------------------------------------------- transform handling ---\n    def push_viewport(self, viewport):\n        \"\"\"Push a viewport (x, y, w, h) on the stack. Values must be integers\n        relative to the active framebuffer.\n\n        Parameters\n        ----------\n        viewport : tuple\n            The viewport as (x, y, w, h).\n        \"\"\"\n        vp = list(viewport)\n        # Normalize viewport before setting;\n        if vp[2] < 0:\n            vp[0] += vp[2]\n            vp[2] *= -1\n        if vp[3] < 0:\n            vp[1] += vp[3]\n            vp[3] *= -1\n\n        self._vp_stack.append(vp)\n        try:\n            self.context.set_viewport(*vp)\n        except Exception:\n            self._vp_stack.pop()\n            raise\n\n        self._update_transforms()\n\n    def pop_viewport(self):\n        \"\"\"Pop a viewport from the stack.\"\"\"\n        vp = self._vp_stack.pop()\n        # Activate latest\n        if len(self._vp_stack) > 0:\n            self.context.set_viewport(*self._vp_stack[-1])\n        else:\n            self.context.set_viewport(0, 0, *self.physical_size)\n\n        self._update_transforms()\n        return vp\n\n    def push_fbo(self, fbo, offset, csize):\n        \"\"\"Push an FBO on the stack.\n\n        This activates the framebuffer and causes subsequent rendering to be\n        written to the framebuffer rather than the canvas's back buffer. This\n        will also set the canvas viewport to cover the boundaries of the\n        framebuffer.\n\n        Parameters\n        ----------\n        fbo : instance of FrameBuffer\n            The framebuffer object .\n        offset : tuple\n            The location of the fbo origin relative to the canvas's framebuffer\n            origin.\n        csize : tuple\n            The size of the region in the canvas's framebuffer that should be\n            covered by this framebuffer object.\n        \"\"\"\n        self._fb_stack.append((fbo, offset, csize))\n        try:\n            fbo.activate()\n            h, w = fbo.color_buffer.shape[:2]\n            self.push_viewport((0, 0, w, h))\n        except Exception:\n            self._fb_stack.pop()\n            raise\n\n        self._update_transforms()\n\n    def pop_fbo(self):\n        \"\"\"Pop an FBO from the stack.\"\"\"\n        fbo = self._fb_stack.pop()\n        fbo[0].deactivate()\n        self.pop_viewport()\n        if len(self._fb_stack) > 0:\n            old_fbo = self._fb_stack[-1]\n            old_fbo[0].activate()\n\n        self._update_transforms()\n        return fbo\n\n    def _current_framebuffer(self):\n        \"\"\"Return (fbo, origin, canvas_size) for the current\n        FBO on the stack, or for the canvas if there is no FBO.\n        \"\"\"\n        if len(self._fb_stack) == 0:\n            return None, (0, 0), self.size\n        else:\n            return self._fb_stack[-1]\n\n    def _update_transforms(self):\n        \"\"\"Update the canvas's TransformSystem to correct for the current\n        canvas size, framebuffer, and viewport.\n        \"\"\"\n        if len(self._fb_stack) == 0:\n            fb_size = fb_rect = None\n        else:\n            fb, origin, fb_size = self._fb_stack[-1]\n            fb_rect = origin + fb_size\n\n        if len(self._vp_stack) == 0:\n            viewport = None\n        else:\n            viewport = self._vp_stack[-1]\n\n        self.transforms.configure(viewport=viewport, fbo_size=fb_size,\n                                  fbo_rect=fb_rect)",
  "def __init__(self, title='VisPy canvas', size=(800, 600), position=None,\n                 show=False, autoswap=True, app=None, create_native=True,\n                 vsync=False, resizable=True, decorate=True, fullscreen=False,\n                 config=None, shared=None, keys=None, parent=None, dpi=None,\n                 always_on_top=False, px_scale=1, bgcolor='black'):\n        self._scene = None\n        # A default widget that follows the shape of the canvas\n        self._central_widget = None\n        self._draw_order = weakref.WeakKeyDictionary()\n        self._drawing = False\n        self._update_pending = False\n        self._fb_stack = []\n        self._vp_stack = []\n        self._mouse_handler = None\n        self.transforms = TransformSystem(canvas=self)\n        self._bgcolor = Color(bgcolor).rgba\n\n        # Set to True to enable sending mouse events even when no button is\n        # pressed. Disabled by default because it is very expensive. Also\n        # private for now because this behavior / API needs more thought.\n        self._send_hover_events = False\n\n        super(SceneCanvas, self).__init__(\n            title, size, position, show, autoswap, app, create_native, vsync,\n            resizable, decorate, fullscreen, config, shared, keys, parent, dpi,\n            always_on_top, px_scale)\n        self.events.mouse_press.connect(self._process_mouse_event)\n        self.events.mouse_move.connect(self._process_mouse_event)\n        self.events.mouse_release.connect(self._process_mouse_event)\n        self.events.mouse_wheel.connect(self._process_mouse_event)\n\n        self.scene = SubScene()\n        self.freeze()",
  "def scene(self):\n        \"\"\"The SubScene object that represents the root node of the\n        scene graph to be displayed.\n        \"\"\"\n        return self._scene",
  "def scene(self, node):\n        oldscene = self._scene\n        self._scene = node\n        if oldscene is not None:\n            oldscene._set_canvas(None)\n            oldscene.events.children_change.disconnect(self._update_scenegraph)\n        if node is not None:\n            node._set_canvas(self)\n            node.events.children_change.connect(self._update_scenegraph)",
  "def central_widget(self):\n        \"\"\"Returns the default widget that occupies the entire area of the\n        canvas.\n        \"\"\"\n        if self._central_widget is None:\n            self._central_widget = Widget(size=self.size, parent=self.scene)\n        return self._central_widget",
  "def bgcolor(self):\n        return Color(self._bgcolor)",
  "def bgcolor(self, color):\n        self._bgcolor = Color(color).rgba\n        if hasattr(self, '_backend'):\n            self.update()",
  "def update(self, node=None):\n        \"\"\"Update the scene\n\n        Parameters\n        ----------\n        node : instance of Node\n            Not used.\n        \"\"\"\n        # TODO: use node bounds to keep track of minimum drawable area\n        if self._drawing:\n            return\n\n        # Keep things civil in the node update system. Once an update\n        # has been scheduled, there is no need to flood the event queue\n        # of the backend with additional updates.\n        if not self._update_pending:\n            self._update_pending = True\n            super(SceneCanvas, self).update()",
  "def on_draw(self, event):\n        \"\"\"Draw handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The draw event.\n        \"\"\"\n        if self._scene is None:\n            return  # Can happen on initialization\n        logger.debug('Canvas draw')\n\n        # Now that a draw event is going to be handled, open up the\n        # scheduling of further updates\n        self._update_pending = False\n        self._draw_scene()",
  "def render(self, region=None, size=None, bgcolor=None, crop=None, alpha=True):\n        \"\"\"Render the scene to an offscreen buffer and return the image array.\n\n        Parameters\n        ----------\n        region : tuple | None\n            Specifies the region of the canvas to render. Format is\n            (x, y, w, h). By default, the entire canvas is rendered.\n        size : tuple | None\n            Specifies the size of the image array to return. If no size is\n            given, then the size of the *region* is used, multiplied by the\n            pixel scaling factor of the canvas (see `pixel_scale`). This\n            argument allows the scene to be rendered at resolutions different\n            from the native canvas resolution.\n        bgcolor : instance of Color | None\n            The background color to use.\n        crop : array-like | None\n            If specified it determines the pixels read from the framebuffer.\n            In the format (x, y, w, h), relative to the region being rendered.\n        alpha : bool\n            If True (default) produce an RGBA array (h, w, 4). If False,\n            remove the Alpha channel and return the RGB array (h, w, 3).\n            This may be useful if blending of various elements requires a\n            solid background to produce the expected visualization.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region. If ``alpha`` is ``False``,\n            then only 3 channels will be returned (RGB).\n\n        \"\"\"\n        self.set_current()\n        # Set up a framebuffer to render to\n        offset = (0, 0) if region is None else region[:2]\n        csize = self.size if region is None else region[2:]\n        s = self.pixel_scale\n        size = tuple([int(x * s) for x in csize]) if size is None else size\n        fbo = gloo.FrameBuffer(color=gloo.RenderBuffer(size[::-1]),\n                               depth=gloo.RenderBuffer(size[::-1]))\n\n        self.push_fbo(fbo, offset, csize)\n        try:\n            self._draw_scene(bgcolor=bgcolor)\n            result = fbo.read(crop=crop)\n        finally:\n            self.pop_fbo()\n\n        if not alpha:\n            result = result[..., :3]\n        return result",
  "def _draw_scene(self, bgcolor=None):\n        if bgcolor is None:\n            bgcolor = self._bgcolor\n        self.context.clear(color=bgcolor, depth=True)\n        self.draw_visual(self.scene)",
  "def draw_visual(self, visual, event=None):\n        \"\"\"Draw a visual and its children to the canvas or currently active\n        framebuffer.\n\n        Parameters\n        ----------\n        visual : Visual\n            The visual to draw\n        event : None or DrawEvent\n            Optionally specifies the original canvas draw event that initiated\n            this draw.\n        \"\"\"\n        prof = Profiler()\n\n        # make sure this canvas's context is active\n        self.set_current()\n\n        try:\n            self._drawing = True\n            # get order to draw visuals\n            if visual not in self._draw_order:\n                self._draw_order[visual] = self._generate_draw_order()\n            order = self._draw_order[visual]\n\n            # draw (while avoiding branches with visible=False)\n            stack = []\n            invisible_node = None\n            for node, start in order:\n                if start:\n                    stack.append(node)\n                    if invisible_node is None:\n                        if not node.visible:\n                            # disable drawing until we exit this node's subtree\n                            invisible_node = node\n                        else:\n                            if hasattr(node, 'draw'):\n                                node.draw()\n                                prof.mark(str(node))\n                else:\n                    if node is invisible_node:\n                        invisible_node = None\n                    stack.pop()\n        finally:\n            self._drawing = False",
  "def _generate_draw_order(self, node=None):\n        \"\"\"Return a list giving the order to draw visuals.\n\n        Each node appears twice in the list--(node, True) appears before the\n        node's children are drawn, and (node, False) appears after.\n        \"\"\"\n        if node is None:\n            node = self._scene\n        order = [(node, True)]\n        children = node.children\n        children.sort(key=lambda ch: ch.order)\n        for ch in children:\n            order.extend(self._generate_draw_order(ch))\n        order.append((node, False))\n        return order",
  "def _update_scenegraph(self, event):\n        \"\"\"Called when topology of scenegraph has changed.\"\"\"\n        self._draw_order.clear()\n        self.update()",
  "def _process_mouse_event(self, event):\n        prof = Profiler()  # noqa\n        deliver_types = ['mouse_press', 'mouse_wheel']\n        if self._send_hover_events:\n            deliver_types += ['mouse_move']\n\n        picked = self._mouse_handler\n        if picked is None:\n            if event.type in deliver_types:\n                picked = self.visual_at(event.pos)\n\n        # No visual to handle this event; bail out now\n        if picked is None:\n            return\n\n        # Create an event to pass to the picked visual\n        scene_event = SceneMouseEvent(event=event, visual=picked)\n\n        # Deliver the event\n        if picked == self._mouse_handler:\n            # If we already have a mouse handler, then no other node may\n            # receive the event\n            if event.type == 'mouse_release':\n                self._mouse_handler = None\n            getattr(picked.events, event.type)(scene_event)\n        else:\n            # If we don't have a mouse handler, then pass the event through\n            # the chain of parents until a node accepts the event.\n            while picked is not None:\n                getattr(picked.events, event.type)(scene_event)\n                if scene_event.handled:\n                    if event.type == 'mouse_press':\n                        self._mouse_handler = picked\n                    break\n                if event.type in deliver_types:\n                    # events that are not handled get passed to parent\n                    picked = picked.parent\n                    scene_event.visual = picked\n                else:\n                    picked = None\n\n        # If something in the scene handled the scene_event, then we mark\n        # the original event accordingly.\n        event.handled = scene_event.handled",
  "def visual_at(self, pos):\n        \"\"\"Return the visual at a given position\n\n        Parameters\n        ----------\n        pos : tuple\n            The position in logical coordinates to query.\n\n        Returns\n        -------\n        visual : instance of Visual | None\n            The visual at the position, if it exists.\n        \"\"\"\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        fbpos = tr.map(pos)[:2]\n\n        try:\n            id_ = self._render_picking((fbpos[0], fbpos[1], 1, 1))\n            vis = VisualNode._visual_ids.get(id_[0, 0], None)\n        except RuntimeError:\n            # Don't have read_pixels() support for IPython. Fall back to\n            # bounds checking.\n            return self._visual_bounds_at(pos)\n        return vis",
  "def _visual_bounds_at(self, pos, node=None):\n        \"\"\"Find a visual whose bounding rect encompasses *pos*.\"\"\"\n        if node is None:\n            node = self.scene\n\n        for ch in node.children:\n            hit = self._visual_bounds_at(pos, ch)\n            if hit is not None:\n                return hit\n\n        if (not isinstance(node, VisualNode) or not node.visible or\n                not node.interactive):\n            return None\n\n        # let nodes know we are picking to handle any special cases (picking meshes)\n        # we can't do this before this or child nodes may be considered visible\n        # which would cause the above 'if' statement to pass when it shouldn't\n        node.picking = True\n        bounds = [node.bounds(axis=i) for i in range(2)]\n        node.picking = False\n\n        if None in bounds:\n            return None\n\n        tr = self.scene.node_transform(node).inverse\n        corners = np.array([\n            [bounds[0][0], bounds[1][0]],\n            [bounds[0][0], bounds[1][1]],\n            [bounds[0][1], bounds[1][0]],\n            [bounds[0][1], bounds[1][1]]])\n        bounds = tr.map(corners)\n        xhit = bounds[:, 0].min() < pos[0] < bounds[:, 0].max()\n        yhit = bounds[:, 1].min() < pos[1] < bounds[:, 1].max()\n        if xhit and yhit:\n            return node",
  "def visuals_at(self, pos, radius=10):\n        \"\"\"Return a list of visuals within *radius* pixels of *pos*.\n\n        Visuals are sorted by their proximity to *pos*.\n\n        Parameters\n        ----------\n        pos : tuple\n            (x, y) position at which to find visuals.\n        radius : int\n            Distance away from *pos* to search for visuals.\n        \"\"\"\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        pos = tr.map(pos)[:2]\n\n        id = self._render_picking((pos[0]-radius, pos[1]-radius,\n                                   radius * 2 + 1, radius * 2 + 1))\n        ids = []\n        seen = set()\n        for i in range(radius):\n            subr = id[radius-i:radius+i+1, radius-i:radius+i+1]\n            subr_ids = set(list(np.unique(subr)))\n            ids.extend(list(subr_ids - seen))\n            seen |= subr_ids\n        visuals = [VisualNode._visual_ids.get(x, None) for x in ids]\n        return [v for v in visuals if v is not None]",
  "def _render_picking(self, crop):\n        \"\"\"Render the scene in picking mode, returning a 2D array of visual\n        IDs in the area specified by crop.\n\n        Parameters\n        ----------\n        crop : array-like\n            The crop (x, y, w, h) of the framebuffer to read. For picking the\n            full canvas is rendered and cropped on read as it is much faster\n            than triggering transform updates across the scene with every\n            click.\n        \"\"\"\n        try:\n            self._scene.picking = True\n            img = self.render(bgcolor=(0, 0, 0, 0), crop=crop)\n        finally:\n            self._scene.picking = False\n        img = img.astype('int32') * [2**0, 2**8, 2**16, 2**24]\n        id_ = img.sum(axis=2).astype('int32')\n        return id_",
  "def on_resize(self, event):\n        \"\"\"Resize handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The resize event.\n        \"\"\"\n        self._update_transforms()\n\n        if self._central_widget is not None:\n            self._central_widget.size = self.size\n\n        if len(self._vp_stack) == 0:\n            self.context.set_viewport(0, 0, *self.physical_size)",
  "def on_close(self, event):\n        \"\"\"Close event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.events.mouse_press.disconnect(self._process_mouse_event)\n        self.events.mouse_move.disconnect(self._process_mouse_event)\n        self.events.mouse_release.disconnect(self._process_mouse_event)\n        self.events.mouse_wheel.disconnect(self._process_mouse_event)",
  "def push_viewport(self, viewport):\n        \"\"\"Push a viewport (x, y, w, h) on the stack. Values must be integers\n        relative to the active framebuffer.\n\n        Parameters\n        ----------\n        viewport : tuple\n            The viewport as (x, y, w, h).\n        \"\"\"\n        vp = list(viewport)\n        # Normalize viewport before setting;\n        if vp[2] < 0:\n            vp[0] += vp[2]\n            vp[2] *= -1\n        if vp[3] < 0:\n            vp[1] += vp[3]\n            vp[3] *= -1\n\n        self._vp_stack.append(vp)\n        try:\n            self.context.set_viewport(*vp)\n        except Exception:\n            self._vp_stack.pop()\n            raise\n\n        self._update_transforms()",
  "def pop_viewport(self):\n        \"\"\"Pop a viewport from the stack.\"\"\"\n        vp = self._vp_stack.pop()\n        # Activate latest\n        if len(self._vp_stack) > 0:\n            self.context.set_viewport(*self._vp_stack[-1])\n        else:\n            self.context.set_viewport(0, 0, *self.physical_size)\n\n        self._update_transforms()\n        return vp",
  "def push_fbo(self, fbo, offset, csize):\n        \"\"\"Push an FBO on the stack.\n\n        This activates the framebuffer and causes subsequent rendering to be\n        written to the framebuffer rather than the canvas's back buffer. This\n        will also set the canvas viewport to cover the boundaries of the\n        framebuffer.\n\n        Parameters\n        ----------\n        fbo : instance of FrameBuffer\n            The framebuffer object .\n        offset : tuple\n            The location of the fbo origin relative to the canvas's framebuffer\n            origin.\n        csize : tuple\n            The size of the region in the canvas's framebuffer that should be\n            covered by this framebuffer object.\n        \"\"\"\n        self._fb_stack.append((fbo, offset, csize))\n        try:\n            fbo.activate()\n            h, w = fbo.color_buffer.shape[:2]\n            self.push_viewport((0, 0, w, h))\n        except Exception:\n            self._fb_stack.pop()\n            raise\n\n        self._update_transforms()",
  "def pop_fbo(self):\n        \"\"\"Pop an FBO from the stack.\"\"\"\n        fbo = self._fb_stack.pop()\n        fbo[0].deactivate()\n        self.pop_viewport()\n        if len(self._fb_stack) > 0:\n            old_fbo = self._fb_stack[-1]\n            old_fbo[0].activate()\n\n        self._update_transforms()\n        return fbo",
  "def _current_framebuffer(self):\n        \"\"\"Return (fbo, origin, canvas_size) for the current\n        FBO on the stack, or for the canvas if there is no FBO.\n        \"\"\"\n        if len(self._fb_stack) == 0:\n            return None, (0, 0), self.size\n        else:\n            return self._fb_stack[-1]",
  "def _update_transforms(self):\n        \"\"\"Update the canvas's TransformSystem to correct for the current\n        canvas size, framebuffer, and viewport.\n        \"\"\"\n        if len(self._fb_stack) == 0:\n            fb_size = fb_rect = None\n        else:\n            fb, origin, fb_size = self._fb_stack[-1]\n            fb_rect = origin + fb_size\n\n        if len(self._vp_stack) == 0:\n            viewport = None\n        else:\n            viewport = self._vp_stack[-1]\n\n        self.transforms.configure(viewport=viewport, fbo_size=fb_size,\n                                  fbo_rect=fb_rect)",
  "class SubScene(Node):\n    \"\"\"A Node subclass that serves as a marker and parent node for certain\n    branches of the scenegraph.\n\n    SubScene nodes are used as the top-level node for the internal scenes of\n    a canvas and a view box.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        Node.__init__(self, **kwargs)\n        self.document = self",
  "def __init__(self, **kwargs):\n        Node.__init__(self, **kwargs)\n        self.document = self",
  "class Node(object):\n    \"\"\"Base class representing an object in a scene.\n\n    A group of nodes connected through parent-child relationships define a \n    scenegraph. Nodes may have any number of children.\n\n    Each Node defines a ``transform`` property, which describes the position,\n    orientation, scale, etc. of the Node relative to its parent. The Node's\n    children inherit this property, and then further apply their own\n    transformations on top of that. \n\n    With the ``transform`` property, each Node implicitly defines a \"local\" \n    coordinate system, and the Nodes and edges in the scenegraph can be thought\n    of as coordinate systems connected by transformation functions.\n\n    Parameters\n    ----------\n    parent : Node\n        The parent of the Node.\n    name : str\n        The name used to identify the node.\n    transforms : instance of TransformSystem | None\n        The associated transforms.\n    \"\"\"\n\n    # Needed to allow subclasses to repr() themselves before Node.__init__()\n    _name = None\n\n    def __init__(self, parent=None, name=None, transforms=None):\n        self.name = name\n        self._visible = True\n        self._canvas = None\n        self._document_node = None\n        self._scene_node = None\n        self._opacity = 1.0\n        self._order = 0\n        self._picking = False\n\n        # clippers inherited from parents\n        self._clippers = weakref.WeakKeyDictionary()  # {node: clipper}\n\n        # whether this widget should clip its children\n        self._clip_children = False\n        self._clipper = None\n\n        self.transforms = (TransformSystem() if transforms is None else \n                           transforms)\n\n        # Add some events to the emitter groups:\n        events = ['canvas_change', 'parent_change', 'children_change', \n                  'transform_change', 'mouse_press', 'mouse_move',\n                  'mouse_release', 'mouse_wheel', 'key_press', 'key_release']\n        # Create event emitter if needed (in subclasses that inherit from\n        # Visual, we already have an emitter to share)\n        if not hasattr(self, 'events'):\n            self.events = EmitterGroup(source=self, auto_connect=True,\n                                       update=Event)\n        self.events.add(**dict([(ev, Event) for ev in events]))\n\n        self._children = []\n        self._transform = NullTransform()\n        self._parent = None\n        if parent is not None:\n            self.parent = parent\n\n        self._document = None\n\n    @property\n    def visible(self):\n        \"\"\"Whether this node should be drawn or not. Only applicable to\n        nodes that can be drawn.\n        \"\"\"\n        return self._visible\n\n    @visible.setter\n    def visible(self, val):\n        self._visible = bool(val)\n        self.update()\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, n):\n        self._name = n\n\n    @property\n    def opacity(self):\n        return self._opacity\n\n    @opacity.setter\n    def opacity(self, o):\n        self._opacity = o\n        self._update_opacity()\n\n    def _update_opacity(self):\n        pass\n\n    def _set_clipper(self, node, clipper):\n        \"\"\"Assign a clipper that is inherited from a parent node.\n\n        If *clipper* is None, then remove any clippers for *node*.\n        \"\"\"\n        pass\n\n    @property\n    def clip_children(self):\n        \"\"\"Boolean indicating whether children of this node will inherit its\n        clipper.\n        \"\"\"\n        return self._clip_children\n\n    @clip_children.setter\n    def clip_children(self, clip):\n        if self._clip_children == clip:\n            return\n        self._clip_children = clip\n\n        for ch in self.children:\n            ch._set_clipper(self, self.clipper) \n\n    @property\n    def clipper(self):\n        \"\"\"A visual filter that can be used to clip visuals to the boundaries\n        of this node.\n        \"\"\"\n        return self._clipper\n\n    @property\n    def order(self):\n        \"\"\"A value used to determine the order in which nodes are drawn.\n\n        Greater values are drawn later. Children are always drawn after their\n        parent.\n        \"\"\"\n        return self._order\n\n    @order.setter\n    def order(self, o):\n        self._order = o\n        self.update()\n\n    @property\n    def children(self):\n        \"\"\"A copy of the list of children of this node. Do not add\n        items to this list, but use ``x.parent = y`` instead.\n        \"\"\"\n        return list(self._children)\n\n    @property\n    def parent(self):\n        \"\"\"The parent of this node in the scenegraph.\n\n        Nodes inherit coordinate transformations and some filters (opacity and\n        clipping by default) from their parents. Setting this property assigns\n        a new parent, changing the topology of the scenegraph.\n\n        May be set to None to remove this node (and its children) from a\n        scenegraph.\n        \"\"\"\n        if self._parent is None:\n            return None\n        else:\n            return self._parent()\n\n    @parent.setter\n    def parent(self, parent):\n        if not isinstance(parent, (Node, type(None))):\n            raise ValueError('Parent must be Node instance or None (got %s).'\n                             % parent.__class__.__name__)\n        prev = self.parent\n        if parent is prev:\n            return\n        if prev is not None:\n            prev._remove_child(self)\n            # remove all clippers inherited from parents\n            for k in list(self._clippers):\n                self._set_clipper(k, None)\n        if parent is None:\n            self._set_canvas(None)\n            self._parent = None\n        else:\n            self._set_canvas(parent.canvas)\n            self._parent = weakref.ref(parent)\n            parent._add_child(self)\n            # inherit clippers from parents\n            p = parent\n            while p is not None:\n                if p.clip_children:\n                    self._set_clipper(p, p.clipper)\n                p = p.parent\n\n        self.events.parent_change(new=parent, old=prev)\n        self._update_trsys(None)\n        self.update()\n\n    def _add_child(self, node):\n        self._children.append(node)\n        self.events.children_change(added=node)\n        node.events.children_change.connect(self.events.children_change)\n        self.events.parent_change.connect(node.events.parent_change)\n\n    def _remove_child(self, node):\n        self._children.remove(node)\n        self.events.children_change(removed=node)\n        node.events.children_change.disconnect(self.events.children_change)\n        self.events.parent_change.disconnect(node.events.parent_change)\n\n    def on_parent_change(self, event):\n        \"\"\"Parent change event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._scene_node = None\n\n    def is_child(self, node):\n        \"\"\"Check if a node is a child of the current node\n\n        Parameters\n        ----------\n        node : instance of Node\n            The potential child.\n\n        Returns\n        -------\n        child : bool\n            Whether or not the node is a child.\n        \"\"\"\n        if node in self.children:\n            return True\n        for c in self.children:\n            if c.is_child(node):\n                return True\n        return False\n\n    @property\n    def canvas(self):\n        \"\"\"The canvas in which this node's scenegraph is being drawn.\"\"\"\n        if self._canvas is None:\n            return None\n        else:\n            return self._canvas()\n\n    @property\n    def document_node(self):\n        \"\"\"The node to be used as the document coordinate system.\n\n        By default, the document node is `self.root_node`.\n        \"\"\"\n        if self._document_node is None:\n            return self.root_node\n        return self._document_node\n\n    @document_node.setter\n    def document_node(self, doc):\n        self._document_node = doc\n        self._update_transform()\n\n    @property\n    def scene_node(self):\n        \"\"\"The first ancestor of this node that is a SubScene instance, or self\n        if no such node exists.\n        \"\"\"\n        if self._scene_node is None:\n            from .subscene import SubScene\n            p = self.parent\n            while True:\n                if isinstance(p, SubScene) or p is None:\n                    self._scene_node = p and weakref.ref(p)\n                    break\n                p = p.parent\n            if self._scene_node is None:\n                self._scene_node = weakref.ref(self)\n        return self._scene_node()\n\n    @property\n    def root_node(self):\n        node = self\n        while True:\n            p = node.parent\n            if p is None:\n                return node\n            node = p\n\n    def _set_canvas(self, c):\n        old = self.canvas\n        if old is c:\n            return\n\n        # Use canvas/framebuffer transforms from canvas\n        self.transforms.canvas = c\n        if c is None:\n            self._canvas = None\n        else:\n            self._canvas = weakref.ref(c)\n            tr = c.transforms\n            self.transforms.canvas_transform = tr.canvas_transform\n            self.transforms.framebuffer_transform = tr.framebuffer_transform\n\n        # update all children\n        for ch in self.children:\n            ch._set_canvas(c)\n\n        self.events.canvas_change(old=old, new=c)\n\n    def update(self):\n        \"\"\"\n        Emit an event to inform listeners that properties of this Node have\n        changed. Also request a canvas update.\n        \"\"\"\n        self.events.update()\n        c = getattr(self, 'canvas', None)\n        if c is not None:\n            c.update(node=self)\n\n    @property\n    def document(self):\n        \"\"\"The document is an optional property that is an node representing\n        the coordinate system from which this node should make physical \n        measurements such as px, mm, pt, in, etc. This coordinate system \n        should be used when determining line widths, font sizes, and any\n        other lengths specified in physical units.\n\n        The default is None; in this case, a default document is used during\n        drawing (usually this is supplied by the SceneCanvas).\n        \"\"\"\n        return self._document\n\n    @document.setter\n    def document(self, doc):\n        if doc is not None and not isinstance(doc, Node):\n            raise TypeError(\"Document property must be Node or None.\")\n        self._document = doc\n        self.update()\n\n    @property\n    def transform(self):\n        \"\"\"The transform that maps the local coordinate frame to the\n        coordinate frame of the parent.\n        \"\"\"\n        return self._transform\n\n    @transform.setter\n    def transform(self, tr):\n        # Other nodes might be interested in this information, but turning it\n        # on by default is too expensive.\n        assert isinstance(tr, BaseTransform)\n        if tr is not self._transform:\n            self._transform = tr\n            self._update_trsys(None)\n\n    def set_transform(self, type_, *args, **kwargs):\n        \"\"\"Create a new transform of *type* and assign it to this node.\n\n        All extra arguments are used in the construction of the transform.\n\n        Parameters\n        ----------\n        type_ : str\n            The transform type.\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keywoard arguments.\n        \"\"\"\n        self.transform = create_transform(type_, *args, **kwargs)\n\n    def _update_trsys(self, event):\n        \"\"\"Called when  has changed.\n\n        This allows the node and its children to react (notably, VisualNode\n        uses this to update its TransformSystem).\n\n        Note that this method is only called when one transform is replaced by\n        another; it is not called if an existing transform internally changes\n        its state.\n        \"\"\"\n        for ch in self.children:\n            ch._update_trsys(event)\n        self.events.transform_change()\n        self.update()\n\n    def parent_chain(self):\n        \"\"\"\n        Return the list of parents starting from this node. The chain ends\n        at the first node with no parents.\n        \"\"\"\n        chain = [self]\n        while True:\n            try:\n                parent = chain[-1].parent\n            except Exception:\n                break\n            if parent is None:\n                break\n            chain.append(parent)\n        return chain\n\n    def describe_tree(self, with_transform=False):\n        \"\"\"Create tree diagram of children\n\n        Parameters\n        ----------\n        with_transform : bool\n            If true, add information about node transform types.\n\n        Returns\n        -------\n        tree : str\n            The tree diagram.\n        \"\"\"\n        # inspired by https://github.com/mbr/asciitree/blob/master/asciitree.py\n        return self._describe_tree('', with_transform)\n\n    def _describe_tree(self, prefix, with_transform):\n        \"\"\"Helper function to actuall construct the tree\"\"\"\n        extra = ': \"%s\"' % self.name if self.name is not None else ''\n        if with_transform:\n            extra += (' [%s]' % self.transform.__class__.__name__)\n        output = ''\n        if len(prefix) > 0:\n            output += prefix[:-3]\n            output += '  +--'\n        output += '%s%s\\n' % (self.__class__.__name__, extra)\n\n        n_children = len(self.children)\n        for ii, child in enumerate(self.children):\n            sub_prefix = prefix + ('   ' if ii+1 == n_children else '  |')\n            output += child._describe_tree(sub_prefix, with_transform)\n        return output\n\n    def common_parent(self, node):\n        \"\"\"\n        Return the common parent of two entities\n\n        If the entities have no common parent, return None.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        parent : instance of Node | None\n            The parent.\n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        for p in p1:\n            if p in p2:\n                return p\n        return None\n\n    def node_path_to_child(self, node):\n        \"\"\"Return a list describing the path from this node to a child node\n\n        If *node* is not a (grand)child of this node, then raise RuntimeError.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The child node.\n\n        Returns\n        -------\n        path : list | None\n            The path.\n        \"\"\"\n        if node is self:\n            return []\n\n        # Go up from the child node as far as we can\n        path1 = [node]\n        child = node\n        while child.parent is not None:\n            child = child.parent\n            path1.append(child)\n            # Early exit\n            if child is self:\n                return list(reversed(path1))\n\n        # Verify that we're not cut off\n        if path1[-1].parent is None:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n\n        def _is_child(path, parent, child):\n            path.append(parent)\n            if child in parent.children:\n                return path\n            else:\n                for c in parent.children:\n                    possible_path = _is_child(path[:], c, child)\n                    if possible_path:\n                        return possible_path\n            return None\n\n        # Search from the parent towards the child\n        path2 = _is_child([], self, path1[-1])\n        if not path2:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n\n        # Return\n        return path2 + list(reversed(path1))\n\n    def node_path(self, node):\n        \"\"\"Return two lists describing the path from this node to another\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        p1 : list\n            First path (see below).\n        p2 : list\n            Second path (see below).\n\n        Notes\n        -----\n        The first list starts with this node and ends with the common parent\n        between the endpoint nodes. The second list contains the remainder of\n        the path from the common parent to the specified ending node.\n\n        For example, consider the following scenegraph::\n\n            A --- B --- C --- D\n                   \\\n                    --- E --- F\n\n        Calling `D.node_path(F)` will return::\n\n            ([D, C, B], [E, F])\n\n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        cp = None\n        for p in p1:\n            if p in p2:\n                cp = p\n                break\n        if cp is None:\n            raise RuntimeError(\"No single-path common parent between nodes %s \"\n                               \"and %s.\" % (self, node))\n\n        p1 = p1[:p1.index(cp)+1]\n        p2 = p2[:p2.index(cp)][::-1]\n        return p1, p2\n\n    def node_path_transforms(self, node):\n        \"\"\"Return the list of transforms along the path to another node.\n\n        The transforms are listed in reverse order, such that the last \n        transform should be applied first when mapping from this node to \n        the other.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        transforms : list\n            A list of Transform instances.\n        \"\"\"\n        a, b = self.node_path(node)\n        return ([n.transform for n in a[:-1]] + \n                [n.transform.inverse for n in b])[::-1]\n\n    def node_transform(self, node):\n        \"\"\"\n        Return the transform that maps from the coordinate system of\n        *self* to the local coordinate system of *node*.\n\n        Note that there must be a _single_ path in the scenegraph that connects\n        the two entities; otherwise an exception will be raised.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        transform : instance of ChainTransform\n            The transform.\n        \"\"\"\n        return ChainTransform(self.node_path_transforms(node))\n\n    def __repr__(self):\n        name = \"\" if self.name is None else \" name=\"+self.name\n        return \"<%s%s at 0x%x>\" % (self.__class__.__name__, name, id(self))\n\n    @property\n    def picking(self):\n        \"\"\"Boolean that determines whether this node (and its children) are\n        drawn in picking mode.\n        \"\"\"\n        return self._picking\n\n    @picking.setter\n    def picking(self, p):\n        for c in self.children:\n            c.picking = p\n        self._picking = p",
  "def __init__(self, parent=None, name=None, transforms=None):\n        self.name = name\n        self._visible = True\n        self._canvas = None\n        self._document_node = None\n        self._scene_node = None\n        self._opacity = 1.0\n        self._order = 0\n        self._picking = False\n\n        # clippers inherited from parents\n        self._clippers = weakref.WeakKeyDictionary()  # {node: clipper}\n\n        # whether this widget should clip its children\n        self._clip_children = False\n        self._clipper = None\n\n        self.transforms = (TransformSystem() if transforms is None else \n                           transforms)\n\n        # Add some events to the emitter groups:\n        events = ['canvas_change', 'parent_change', 'children_change', \n                  'transform_change', 'mouse_press', 'mouse_move',\n                  'mouse_release', 'mouse_wheel', 'key_press', 'key_release']\n        # Create event emitter if needed (in subclasses that inherit from\n        # Visual, we already have an emitter to share)\n        if not hasattr(self, 'events'):\n            self.events = EmitterGroup(source=self, auto_connect=True,\n                                       update=Event)\n        self.events.add(**dict([(ev, Event) for ev in events]))\n\n        self._children = []\n        self._transform = NullTransform()\n        self._parent = None\n        if parent is not None:\n            self.parent = parent\n\n        self._document = None",
  "def visible(self):\n        \"\"\"Whether this node should be drawn or not. Only applicable to\n        nodes that can be drawn.\n        \"\"\"\n        return self._visible",
  "def visible(self, val):\n        self._visible = bool(val)\n        self.update()",
  "def name(self):\n        return self._name",
  "def name(self, n):\n        self._name = n",
  "def opacity(self):\n        return self._opacity",
  "def opacity(self, o):\n        self._opacity = o\n        self._update_opacity()",
  "def _update_opacity(self):\n        pass",
  "def _set_clipper(self, node, clipper):\n        \"\"\"Assign a clipper that is inherited from a parent node.\n\n        If *clipper* is None, then remove any clippers for *node*.\n        \"\"\"\n        pass",
  "def clip_children(self):\n        \"\"\"Boolean indicating whether children of this node will inherit its\n        clipper.\n        \"\"\"\n        return self._clip_children",
  "def clip_children(self, clip):\n        if self._clip_children == clip:\n            return\n        self._clip_children = clip\n\n        for ch in self.children:\n            ch._set_clipper(self, self.clipper)",
  "def clipper(self):\n        \"\"\"A visual filter that can be used to clip visuals to the boundaries\n        of this node.\n        \"\"\"\n        return self._clipper",
  "def order(self):\n        \"\"\"A value used to determine the order in which nodes are drawn.\n\n        Greater values are drawn later. Children are always drawn after their\n        parent.\n        \"\"\"\n        return self._order",
  "def order(self, o):\n        self._order = o\n        self.update()",
  "def children(self):\n        \"\"\"A copy of the list of children of this node. Do not add\n        items to this list, but use ``x.parent = y`` instead.\n        \"\"\"\n        return list(self._children)",
  "def parent(self):\n        \"\"\"The parent of this node in the scenegraph.\n\n        Nodes inherit coordinate transformations and some filters (opacity and\n        clipping by default) from their parents. Setting this property assigns\n        a new parent, changing the topology of the scenegraph.\n\n        May be set to None to remove this node (and its children) from a\n        scenegraph.\n        \"\"\"\n        if self._parent is None:\n            return None\n        else:\n            return self._parent()",
  "def parent(self, parent):\n        if not isinstance(parent, (Node, type(None))):\n            raise ValueError('Parent must be Node instance or None (got %s).'\n                             % parent.__class__.__name__)\n        prev = self.parent\n        if parent is prev:\n            return\n        if prev is not None:\n            prev._remove_child(self)\n            # remove all clippers inherited from parents\n            for k in list(self._clippers):\n                self._set_clipper(k, None)\n        if parent is None:\n            self._set_canvas(None)\n            self._parent = None\n        else:\n            self._set_canvas(parent.canvas)\n            self._parent = weakref.ref(parent)\n            parent._add_child(self)\n            # inherit clippers from parents\n            p = parent\n            while p is not None:\n                if p.clip_children:\n                    self._set_clipper(p, p.clipper)\n                p = p.parent\n\n        self.events.parent_change(new=parent, old=prev)\n        self._update_trsys(None)\n        self.update()",
  "def _add_child(self, node):\n        self._children.append(node)\n        self.events.children_change(added=node)\n        node.events.children_change.connect(self.events.children_change)\n        self.events.parent_change.connect(node.events.parent_change)",
  "def _remove_child(self, node):\n        self._children.remove(node)\n        self.events.children_change(removed=node)\n        node.events.children_change.disconnect(self.events.children_change)\n        self.events.parent_change.disconnect(node.events.parent_change)",
  "def on_parent_change(self, event):\n        \"\"\"Parent change event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._scene_node = None",
  "def is_child(self, node):\n        \"\"\"Check if a node is a child of the current node\n\n        Parameters\n        ----------\n        node : instance of Node\n            The potential child.\n\n        Returns\n        -------\n        child : bool\n            Whether or not the node is a child.\n        \"\"\"\n        if node in self.children:\n            return True\n        for c in self.children:\n            if c.is_child(node):\n                return True\n        return False",
  "def canvas(self):\n        \"\"\"The canvas in which this node's scenegraph is being drawn.\"\"\"\n        if self._canvas is None:\n            return None\n        else:\n            return self._canvas()",
  "def document_node(self):\n        \"\"\"The node to be used as the document coordinate system.\n\n        By default, the document node is `self.root_node`.\n        \"\"\"\n        if self._document_node is None:\n            return self.root_node\n        return self._document_node",
  "def document_node(self, doc):\n        self._document_node = doc\n        self._update_transform()",
  "def scene_node(self):\n        \"\"\"The first ancestor of this node that is a SubScene instance, or self\n        if no such node exists.\n        \"\"\"\n        if self._scene_node is None:\n            from .subscene import SubScene\n            p = self.parent\n            while True:\n                if isinstance(p, SubScene) or p is None:\n                    self._scene_node = p and weakref.ref(p)\n                    break\n                p = p.parent\n            if self._scene_node is None:\n                self._scene_node = weakref.ref(self)\n        return self._scene_node()",
  "def root_node(self):\n        node = self\n        while True:\n            p = node.parent\n            if p is None:\n                return node\n            node = p",
  "def _set_canvas(self, c):\n        old = self.canvas\n        if old is c:\n            return\n\n        # Use canvas/framebuffer transforms from canvas\n        self.transforms.canvas = c\n        if c is None:\n            self._canvas = None\n        else:\n            self._canvas = weakref.ref(c)\n            tr = c.transforms\n            self.transforms.canvas_transform = tr.canvas_transform\n            self.transforms.framebuffer_transform = tr.framebuffer_transform\n\n        # update all children\n        for ch in self.children:\n            ch._set_canvas(c)\n\n        self.events.canvas_change(old=old, new=c)",
  "def update(self):\n        \"\"\"\n        Emit an event to inform listeners that properties of this Node have\n        changed. Also request a canvas update.\n        \"\"\"\n        self.events.update()\n        c = getattr(self, 'canvas', None)\n        if c is not None:\n            c.update(node=self)",
  "def document(self):\n        \"\"\"The document is an optional property that is an node representing\n        the coordinate system from which this node should make physical \n        measurements such as px, mm, pt, in, etc. This coordinate system \n        should be used when determining line widths, font sizes, and any\n        other lengths specified in physical units.\n\n        The default is None; in this case, a default document is used during\n        drawing (usually this is supplied by the SceneCanvas).\n        \"\"\"\n        return self._document",
  "def document(self, doc):\n        if doc is not None and not isinstance(doc, Node):\n            raise TypeError(\"Document property must be Node or None.\")\n        self._document = doc\n        self.update()",
  "def transform(self):\n        \"\"\"The transform that maps the local coordinate frame to the\n        coordinate frame of the parent.\n        \"\"\"\n        return self._transform",
  "def transform(self, tr):\n        # Other nodes might be interested in this information, but turning it\n        # on by default is too expensive.\n        assert isinstance(tr, BaseTransform)\n        if tr is not self._transform:\n            self._transform = tr\n            self._update_trsys(None)",
  "def set_transform(self, type_, *args, **kwargs):\n        \"\"\"Create a new transform of *type* and assign it to this node.\n\n        All extra arguments are used in the construction of the transform.\n\n        Parameters\n        ----------\n        type_ : str\n            The transform type.\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keywoard arguments.\n        \"\"\"\n        self.transform = create_transform(type_, *args, **kwargs)",
  "def _update_trsys(self, event):\n        \"\"\"Called when  has changed.\n\n        This allows the node and its children to react (notably, VisualNode\n        uses this to update its TransformSystem).\n\n        Note that this method is only called when one transform is replaced by\n        another; it is not called if an existing transform internally changes\n        its state.\n        \"\"\"\n        for ch in self.children:\n            ch._update_trsys(event)\n        self.events.transform_change()\n        self.update()",
  "def parent_chain(self):\n        \"\"\"\n        Return the list of parents starting from this node. The chain ends\n        at the first node with no parents.\n        \"\"\"\n        chain = [self]\n        while True:\n            try:\n                parent = chain[-1].parent\n            except Exception:\n                break\n            if parent is None:\n                break\n            chain.append(parent)\n        return chain",
  "def describe_tree(self, with_transform=False):\n        \"\"\"Create tree diagram of children\n\n        Parameters\n        ----------\n        with_transform : bool\n            If true, add information about node transform types.\n\n        Returns\n        -------\n        tree : str\n            The tree diagram.\n        \"\"\"\n        # inspired by https://github.com/mbr/asciitree/blob/master/asciitree.py\n        return self._describe_tree('', with_transform)",
  "def _describe_tree(self, prefix, with_transform):\n        \"\"\"Helper function to actuall construct the tree\"\"\"\n        extra = ': \"%s\"' % self.name if self.name is not None else ''\n        if with_transform:\n            extra += (' [%s]' % self.transform.__class__.__name__)\n        output = ''\n        if len(prefix) > 0:\n            output += prefix[:-3]\n            output += '  +--'\n        output += '%s%s\\n' % (self.__class__.__name__, extra)\n\n        n_children = len(self.children)\n        for ii, child in enumerate(self.children):\n            sub_prefix = prefix + ('   ' if ii+1 == n_children else '  |')\n            output += child._describe_tree(sub_prefix, with_transform)\n        return output",
  "def common_parent(self, node):\n        \"\"\"\n        Return the common parent of two entities\n\n        If the entities have no common parent, return None.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        parent : instance of Node | None\n            The parent.\n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        for p in p1:\n            if p in p2:\n                return p\n        return None",
  "def node_path_to_child(self, node):\n        \"\"\"Return a list describing the path from this node to a child node\n\n        If *node* is not a (grand)child of this node, then raise RuntimeError.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The child node.\n\n        Returns\n        -------\n        path : list | None\n            The path.\n        \"\"\"\n        if node is self:\n            return []\n\n        # Go up from the child node as far as we can\n        path1 = [node]\n        child = node\n        while child.parent is not None:\n            child = child.parent\n            path1.append(child)\n            # Early exit\n            if child is self:\n                return list(reversed(path1))\n\n        # Verify that we're not cut off\n        if path1[-1].parent is None:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n\n        def _is_child(path, parent, child):\n            path.append(parent)\n            if child in parent.children:\n                return path\n            else:\n                for c in parent.children:\n                    possible_path = _is_child(path[:], c, child)\n                    if possible_path:\n                        return possible_path\n            return None\n\n        # Search from the parent towards the child\n        path2 = _is_child([], self, path1[-1])\n        if not path2:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n\n        # Return\n        return path2 + list(reversed(path1))",
  "def node_path(self, node):\n        \"\"\"Return two lists describing the path from this node to another\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        p1 : list\n            First path (see below).\n        p2 : list\n            Second path (see below).\n\n        Notes\n        -----\n        The first list starts with this node and ends with the common parent\n        between the endpoint nodes. The second list contains the remainder of\n        the path from the common parent to the specified ending node.\n\n        For example, consider the following scenegraph::\n\n            A --- B --- C --- D\n                   \\\n                    --- E --- F\n\n        Calling `D.node_path(F)` will return::\n\n            ([D, C, B], [E, F])\n\n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        cp = None\n        for p in p1:\n            if p in p2:\n                cp = p\n                break\n        if cp is None:\n            raise RuntimeError(\"No single-path common parent between nodes %s \"\n                               \"and %s.\" % (self, node))\n\n        p1 = p1[:p1.index(cp)+1]\n        p2 = p2[:p2.index(cp)][::-1]\n        return p1, p2",
  "def node_path_transforms(self, node):\n        \"\"\"Return the list of transforms along the path to another node.\n\n        The transforms are listed in reverse order, such that the last \n        transform should be applied first when mapping from this node to \n        the other.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        transforms : list\n            A list of Transform instances.\n        \"\"\"\n        a, b = self.node_path(node)\n        return ([n.transform for n in a[:-1]] + \n                [n.transform.inverse for n in b])[::-1]",
  "def node_transform(self, node):\n        \"\"\"\n        Return the transform that maps from the coordinate system of\n        *self* to the local coordinate system of *node*.\n\n        Note that there must be a _single_ path in the scenegraph that connects\n        the two entities; otherwise an exception will be raised.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        transform : instance of ChainTransform\n            The transform.\n        \"\"\"\n        return ChainTransform(self.node_path_transforms(node))",
  "def __repr__(self):\n        name = \"\" if self.name is None else \" name=\"+self.name\n        return \"<%s%s at 0x%x>\" % (self.__class__.__name__, name, id(self))",
  "def picking(self):\n        \"\"\"Boolean that determines whether this node (and its children) are\n        drawn in picking mode.\n        \"\"\"\n        return self._picking",
  "def picking(self, p):\n        for c in self.children:\n            c.picking = p\n        self._picking = p",
  "def _is_child(path, parent, child):\n            path.append(parent)\n            if child in parent.children:\n                return path\n            else:\n                for c in parent.children:\n                    possible_path = _is_child(path[:], c, child)\n                    if possible_path:\n                        return possible_path\n            return None",
  "class Label(Widget):\n    \"\"\"Label widget\n\n    Parameters\n    ----------\n    text : str\n        The label.\n    rotation : float\n        The rotation of the label.\n    **kwargs : dict\n        Keyword arguments to pass to TextVisual.\n    \"\"\"\n\n    def __init__(self, text, rotation=0., **kwargs):\n        self._text_visual = TextVisual(text=text, rotation=rotation, **kwargs)\n        self.rotation = rotation\n        Widget.__init__(self)\n        self.add_subvisual(self._text_visual)\n        self._set_pos()\n\n    def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._set_pos()\n\n    def _set_pos(self):\n        self._text_visual.pos = self.rect.center\n\n    @property\n    def text(self):\n        return self._text_visual.text\n\n    @text.setter\n    def text(self, t):\n        self._text_visual.text = t",
  "def __init__(self, text, rotation=0., **kwargs):\n        self._text_visual = TextVisual(text=text, rotation=rotation, **kwargs)\n        self.rotation = rotation\n        Widget.__init__(self)\n        self.add_subvisual(self._text_visual)\n        self._set_pos()",
  "def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._set_pos()",
  "def _set_pos(self):\n        self._text_visual.pos = self.rect.center",
  "def text(self):\n        return self._text_visual.text",
  "def text(self, t):\n        self._text_visual.text = t",
  "class ViewBox(Widget):\n    \"\"\"Provides a rectangular widget to which its subscene is rendered.\n\n    Three classes work together when using a ViewBox:\n    * The :class:`SubScene` class describes a \"world\" coordinate system and the\n    entities that live inside it.\n    * ViewBox is a \"window\" through which we view the\n    subscene. Multiple ViewBoxes may view the same subscene.\n    * :class:`Camera` describes both the perspective from which the\n    subscene is rendered, and the way user interaction affects that\n    perspective.\n\n    In general it is only necessary to create the ViewBox; a SubScene and\n    Camera will be generated automatically.\n\n    Parameters\n    ----------\n    camera : instance of Camera | str | None\n        The camera through which to view the SubScene. If None, then a\n        PanZoomCamera (2D interaction) is used. If str, then the string is\n        used as the argument to :func:`make_camera`.\n    **kwargs : dict\n        Extra keyword arguments to pass to `Widget`.\n    \"\"\"\n\n    def __init__(self, camera=None, **kwargs):\n        self._camera = None\n        self._scene = None\n        Widget.__init__(self, **kwargs)\n        self.interactive = True\n\n        # Each viewbox has an internal scene node, which has a transform that\n        # represents the transformation imposed by camera.\n        if self.name is not None:\n            name = str(self.name) + \"_Scene\"\n        else:\n            name = None\n\n        self._scene = SubScene(name=name, parent=self)\n        self._scene._clipper = Clipper()\n        self._scene.clip_children = True\n        self.transforms.changed.connect(self._update_scene_clipper)\n\n        # Camera is a helper object that handles scene transformation\n        # and user interaction.\n        if camera is None:\n            camera = 'base'\n        if isinstance(camera, str):\n            self.camera = make_camera(camera, parent=self.scene)\n        elif isinstance(camera, BaseCamera):\n            self.camera = camera\n        else:\n            raise TypeError('Argument \"camera\" must be None, str, or Camera.')\n\n    @property\n    def camera(self) -> BaseCamera:\n        \"\"\"Get/set the Camera in use by this ViewBox\n\n        If a string is given (e.g. 'panzoom', 'turntable', 'fly'). A\n        corresponding camera is selected if it already exists in the\n        scene, otherwise a new camera is created.\n\n        The camera object is made a child of the scene (if it is not\n        already in the scene).\n\n        Multiple cameras can exist in one scene, although only one can\n        be active at a time. A single camera can be used by multiple\n        viewboxes at the same time.\n        \"\"\"\n        return self._camera\n\n    @camera.setter\n    def camera(self, cam: Union[str, BaseCamera]):\n        if isinstance(cam, str):\n            # Try to select an existing camera\n            for child in self.scene.children:\n                if isinstance(child, BaseCamera):\n                    this_cam_type = child.__class__.__name__.lower()[:-6]\n                    if this_cam_type == cam:\n                        self.camera = child\n                        return\n            else:\n                # No such camera yet, create it then\n                self.camera = make_camera(cam)\n\n        elif isinstance(cam, BaseCamera):\n            # Ensure that the camera is in the scene\n            if not self.is_in_scene(cam):\n                cam.parent = self.scene\n            # Disconnect / connect\n            if self._camera is not None:\n                self._camera._viewbox_unset(self)\n            self._camera = cam\n            if self._camera is not None:\n                self._camera._viewbox_set(self)\n            # Update view\n            cam.view_changed()\n\n        else:\n            raise ValueError('Not a camera object.')\n\n    def is_in_scene(self, node):\n        \"\"\"Get whether the given node is inside the scene of this viewbox.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The node.\n        \"\"\"\n        return self.scene.is_child(node)\n\n    def get_scene_bounds(self, dim=None):\n        \"\"\"Get the total bounds based on the visuals present in the scene\n\n        Parameters\n        ----------\n        dim : int | None\n            Dimension to return.\n\n        Returns\n        -------\n        bounds : list | tuple\n            If ``dim is None``, Returns a list of 3 tuples, otherwise\n            the bounds for the requested dimension.\n        \"\"\"\n        # todo: handle sub-children\n        # todo: handle transformations\n        # Init\n        bounds = [(np.inf, -np.inf), (np.inf, -np.inf), (np.inf, -np.inf)]\n        # Get bounds of all children\n        for ob in self.scene.children:\n            if hasattr(ob, 'bounds'):\n                for axis in (0, 1, 2):\n                    if (dim is not None) and dim != axis:\n                        continue\n                    b = ob.bounds(axis)\n                    if b is not None:\n                        b = min(b), max(b)  # Ensure correct order\n                        bounds[axis] = (min(bounds[axis][0], b[0]),\n                                        max(bounds[axis][1], b[1]))\n        # Set defaults\n        for axis in (0, 1, 2):\n            if any(np.isinf(bounds[axis])):\n                bounds[axis] = -1, 1\n\n        if dim is not None:\n            return bounds[dim]\n        else:\n            return bounds\n\n    @property\n    def scene(self):\n        \"\"\"The root node of the scene viewed by this ViewBox.\"\"\"\n        return self._scene\n\n    def add(self, node):\n        \"\"\"Add an Node to the scene for this ViewBox.\n\n        This is a convenience method equivalent to\n        `node.parent = viewbox.scene`\n\n        Parameters\n        ----------\n        node : instance of Node\n            The node to add.\n        \"\"\"\n        node.parent = self.scene\n\n    def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._scene is None:\n            # happens during init\n            return\n        self._update_scene_clipper()\n\n    def _update_scene_clipper(self, event=None):\n        tr = self.get_transform('visual', 'framebuffer')\n        self._scene._clipper.bounds = tr.map(self.inner_rect)",
  "def __init__(self, camera=None, **kwargs):\n        self._camera = None\n        self._scene = None\n        Widget.__init__(self, **kwargs)\n        self.interactive = True\n\n        # Each viewbox has an internal scene node, which has a transform that\n        # represents the transformation imposed by camera.\n        if self.name is not None:\n            name = str(self.name) + \"_Scene\"\n        else:\n            name = None\n\n        self._scene = SubScene(name=name, parent=self)\n        self._scene._clipper = Clipper()\n        self._scene.clip_children = True\n        self.transforms.changed.connect(self._update_scene_clipper)\n\n        # Camera is a helper object that handles scene transformation\n        # and user interaction.\n        if camera is None:\n            camera = 'base'\n        if isinstance(camera, str):\n            self.camera = make_camera(camera, parent=self.scene)\n        elif isinstance(camera, BaseCamera):\n            self.camera = camera\n        else:\n            raise TypeError('Argument \"camera\" must be None, str, or Camera.')",
  "def camera(self) -> BaseCamera:\n        \"\"\"Get/set the Camera in use by this ViewBox\n\n        If a string is given (e.g. 'panzoom', 'turntable', 'fly'). A\n        corresponding camera is selected if it already exists in the\n        scene, otherwise a new camera is created.\n\n        The camera object is made a child of the scene (if it is not\n        already in the scene).\n\n        Multiple cameras can exist in one scene, although only one can\n        be active at a time. A single camera can be used by multiple\n        viewboxes at the same time.\n        \"\"\"\n        return self._camera",
  "def camera(self, cam: Union[str, BaseCamera]):\n        if isinstance(cam, str):\n            # Try to select an existing camera\n            for child in self.scene.children:\n                if isinstance(child, BaseCamera):\n                    this_cam_type = child.__class__.__name__.lower()[:-6]\n                    if this_cam_type == cam:\n                        self.camera = child\n                        return\n            else:\n                # No such camera yet, create it then\n                self.camera = make_camera(cam)\n\n        elif isinstance(cam, BaseCamera):\n            # Ensure that the camera is in the scene\n            if not self.is_in_scene(cam):\n                cam.parent = self.scene\n            # Disconnect / connect\n            if self._camera is not None:\n                self._camera._viewbox_unset(self)\n            self._camera = cam\n            if self._camera is not None:\n                self._camera._viewbox_set(self)\n            # Update view\n            cam.view_changed()\n\n        else:\n            raise ValueError('Not a camera object.')",
  "def is_in_scene(self, node):\n        \"\"\"Get whether the given node is inside the scene of this viewbox.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The node.\n        \"\"\"\n        return self.scene.is_child(node)",
  "def get_scene_bounds(self, dim=None):\n        \"\"\"Get the total bounds based on the visuals present in the scene\n\n        Parameters\n        ----------\n        dim : int | None\n            Dimension to return.\n\n        Returns\n        -------\n        bounds : list | tuple\n            If ``dim is None``, Returns a list of 3 tuples, otherwise\n            the bounds for the requested dimension.\n        \"\"\"\n        # todo: handle sub-children\n        # todo: handle transformations\n        # Init\n        bounds = [(np.inf, -np.inf), (np.inf, -np.inf), (np.inf, -np.inf)]\n        # Get bounds of all children\n        for ob in self.scene.children:\n            if hasattr(ob, 'bounds'):\n                for axis in (0, 1, 2):\n                    if (dim is not None) and dim != axis:\n                        continue\n                    b = ob.bounds(axis)\n                    if b is not None:\n                        b = min(b), max(b)  # Ensure correct order\n                        bounds[axis] = (min(bounds[axis][0], b[0]),\n                                        max(bounds[axis][1], b[1]))\n        # Set defaults\n        for axis in (0, 1, 2):\n            if any(np.isinf(bounds[axis])):\n                bounds[axis] = -1, 1\n\n        if dim is not None:\n            return bounds[dim]\n        else:\n            return bounds",
  "def scene(self):\n        \"\"\"The root node of the scene viewed by this ViewBox.\"\"\"\n        return self._scene",
  "def add(self, node):\n        \"\"\"Add an Node to the scene for this ViewBox.\n\n        This is a convenience method equivalent to\n        `node.parent = viewbox.scene`\n\n        Parameters\n        ----------\n        node : instance of Node\n            The node to add.\n        \"\"\"\n        node.parent = self.scene",
  "def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._scene is None:\n            # happens during init\n            return\n        self._update_scene_clipper()",
  "def _update_scene_clipper(self, event=None):\n        tr = self.get_transform('visual', 'framebuffer')\n        self._scene._clipper.bounds = tr.map(self.inner_rect)",
  "class Widget(Compound):\n    \"\"\"A widget takes up a rectangular space, intended for use in\n    a 2D pixel coordinate frame.\n\n    The widget is positioned using the transform attribute (as any\n    node), and its extent (size) is kept as a separate property.\n\n    Parameters\n    ----------\n    pos : (x, y)\n        A 2-element tuple to specify the top left corner of the widget.\n    size : (w, h)\n        A 2-element tuple to spicify the size of the widget.\n    border_color : color\n        The color of the border.\n    border_width : float\n        The width of the border line in pixels.\n    bgcolor : color\n        The background color.\n    padding : int\n        The amount of padding in the widget (i.e. the space reserved between\n        the contents and the border).\n    margin : int\n        The margin to keep outside the widget's border.\n    \"\"\"\n\n    def __init__(self, pos=(0, 0), size=(10, 10), border_color=None,\n                 border_width=1, bgcolor=None, padding=0, margin=0, **kwargs):\n        # For drawing border.\n        # A mesh is required because GL lines cannot be drawn with predictable\n        # shape across all platforms.\n        self._mesh = MeshVisual(color=border_color, mode='triangles')\n        self._mesh.set_gl_state('translucent', depth_test=False,\n                                cull_face=False)\n        self._picking_mesh = MeshVisual(mode='triangle_fan')\n        self._picking_mesh.set_gl_state(cull_face=False, depth_test=False)\n        self._picking_mesh.visible = False\n\n        # reserved space inside border\n        self._padding = padding\n\n        self._border_width = border_width\n\n        # reserved space outside border\n        self._margin = margin\n        self._size = 100, 100\n\n        # layout interaction\n        self._width_limits = [0, None]\n        self._height_limits = [0, None]\n        self._stretch = [None, None]\n\n        # used by the constraint solver\n        # in Grid - these are Cassowary variables\n        self._var_w = self._var_h = None\n        self._var_x = self._var_y = None\n\n        self._widgets = []\n        self._border_color = Color(border_color)\n        self._bgcolor = Color(bgcolor)\n        self._face_colors = None\n\n        # Flag to allow rect setter to know if pos or size changed.\n        self._pos_or_size_changed = False\n\n        Compound.__init__(self, [self._mesh, self._picking_mesh], **kwargs)\n\n        self.transform = STTransform()\n        self.events.add(resize=Event)\n        self.pos = pos\n        self._update_colors()\n        self.size = size\n\n    @property\n    def pos(self):\n        return tuple(self.transform.translate[:2])\n\n    @pos.setter\n    def pos(self, p):\n        assert isinstance(p, tuple)\n        assert len(p) == 2\n        # Handle floating point discrepancies\n        if abs(p[0] - self.pos[0]) < 1e-4 and \\\n           abs(p[1] - self.pos[1]) < 1e-4:\n            return\n        self._pos_or_size_changed = True\n        self.transform.translate = p[0], p[1], 0, 0\n        self._update_line()\n\n    @property\n    def size(self):\n        \"\"\"The size (w, h) of this widget.\n\n        If the widget is a child of another widget, then its size is assigned\n        automatically by its parent.\n        \"\"\"\n        return self._size\n\n    @size.setter\n    def size(self, s):\n        assert isinstance(s, tuple)\n        assert len(s) == 2\n        # Handle floating point discrepancies\n        if abs(s[0] - self._size[0]) < 1e-4 and \\\n           abs(s[1] - self._size[1]) < 1e-4:\n            return\n        self._pos_or_size_changed = True\n        self._size = s\n        self._update_line()\n        self._update_child_widgets()\n        self._update_clipper()\n        self.events.resize()\n\n    @property\n    def width(self):\n        \"\"\"The actual width of this widget\"\"\"\n        return self._size[0]\n\n    @property\n    def width_min(self):\n        \"\"\"The minimum width the widget can have\"\"\"\n        return self._width_limits[0]\n\n    @width_min.setter\n    def width_min(self, width_min):\n        \"\"\"Set the minimum height of the widget\n\n        Parameters\n        ----------\n        height_min: float\n            the minimum height of the widget\n        \"\"\"\n        if width_min is None:\n            self._width_limits[0] = 0\n            return\n\n        width_min = float(width_min)\n        assert(0 <= width_min)\n\n        self._width_limits[0] = width_min\n        self._update_layout()\n\n    @property\n    def width_max(self):\n        \"\"\"The maximum width the widget can have\"\"\"\n        return self._width_limits[1]\n\n    @width_max.setter\n    def width_max(self, width_max):\n        \"\"\"Set the maximum width of the widget.\n\n        Parameters\n        ----------\n        width_max: None | float\n            the maximum width of the widget. if None, maximum width\n            is unbounded\n        \"\"\"\n        if width_max is None:\n            self._width_limits[1] = None\n            return\n\n        width_max = float(width_max)\n        assert(self.width_min <= width_max)\n\n        self._width_limits[1] = width_max\n        self._update_layout()\n\n    @property\n    def height(self):\n        \"\"\"The actual height of the widget\"\"\"\n        return self._size[1]\n\n    @property\n    def height_min(self):\n        \"\"\"The minimum height of the widget\"\"\"\n        return self._height_limits[0]\n\n    @height_min.setter\n    def height_min(self, height_min):\n        \"\"\"Set the minimum height of the widget\n\n        Parameters\n        ----------\n        height_min: float\n            the minimum height of the widget\n        \"\"\"\n        if height_min is None:\n            self._height_limits[0] = 0\n            return\n\n        height_min = float(height_min)\n        assert(height_min >= 0)\n\n        self._height_limits[0] = height_min\n        self._update_layout()\n\n    @property\n    def height_max(self):\n        \"\"\"The maximum height of the widget\"\"\"\n        return self._height_limits[1]\n\n    @height_max.setter\n    def height_max(self, height_max):\n        \"\"\"Set the maximum height of the widget.\n\n        Parameters\n        ----------\n        height_max: None | float\n            the maximum height of the widget. if None, maximum height\n            is unbounded\n        \"\"\"\n        if height_max is None:\n            self._height_limits[1] = None\n            return\n\n        height_max = float(height_max)\n        assert(0 <= self.height_min <= height_max)\n        self._height_limits[1] = height_max\n        self._update_layout()\n\n    @property\n    def rect(self):\n        return Rect((0, 0), self.size)\n\n    @rect.setter\n    def rect(self, r):\n        self._pos_or_size_changed = False\n        with self.events.resize.blocker():\n            self.pos = r.pos\n            self.size = r.size\n        if self._pos_or_size_changed:\n            self.update()\n            self.events.resize()\n\n    @property\n    def inner_rect(self):\n        \"\"\"The rectangular area inside the margin, border, and padding.\n\n        Generally widgets should avoid drawing or placing sub-widgets outside\n        this rectangle.\n        \"\"\"\n        m = self.margin + self._border_width + self.padding\n        if not self.border_color.is_blank:\n            m += 1\n        return Rect((m, m), (self.size[0]-2*m, self.size[1]-2*m))\n\n    @property\n    def stretch(self):\n        \"\"\"Stretch factors (w, h) used when determining how much space to\n        allocate to this widget in a layout.\n\n        If either stretch factor is None, then it will be assigned when the\n        widget is added to a layout based on the number of columns or rows it\n        occupies.\n        \"\"\"\n        return self._stretch\n\n    @stretch.setter\n    def stretch(self, s):\n        self._stretch = [float(s[0]), float(s[1])]\n\n        if self._stretch[0] == 0:\n            raise RuntimeError(\"received 0 as stretch parameter: %s\", s)\n\n        if self._stretch[1] == 0:\n            raise RuntimeError(\"received 0 as stretch parameter: %s\", s)\n\n        self._update_layout()\n\n    def _update_layout(self):\n        if isinstance(self.parent, Widget):\n            self.parent._update_child_widgets()\n\n    def _update_clipper(self):\n        \"\"\"Called whenever the clipper for this widget may need to be updated.\"\"\"\n        if self.clip_children and self._clipper is None:\n            self._clipper = Clipper()\n        elif not self.clip_children:\n            self._clipper = None\n\n        if self._clipper is None:\n            return\n        self._clipper.rect = self.inner_rect\n        self._clipper.transform = self.get_transform('framebuffer', 'visual')\n\n    @property\n    def border_color(self):\n        \"\"\"The color of the border.\"\"\"\n        return self._border_color\n\n    @border_color.setter\n    def border_color(self, b):\n        self._border_color = Color(b)\n        self._update_colors()\n        self._update_line()\n        self.update()\n\n    @property\n    def bgcolor(self):\n        \"\"\"The background color of the Widget.\"\"\"\n        return self._bgcolor\n\n    @bgcolor.setter\n    def bgcolor(self, value):\n        self._bgcolor = Color(value)\n        self._update_colors()\n        self._update_line()\n        self.update()\n\n    @property\n    def margin(self):\n        return self._margin\n\n    @margin.setter\n    def margin(self, m):\n        self._margin = m\n        self._update_child_widgets()\n        self._update_line()\n        self.update()\n        self.events.resize()\n\n    @property\n    def padding(self):\n        return self._padding\n\n    @padding.setter\n    def padding(self, p):\n        self._padding = p\n        self._update_child_widgets()\n        self.update()\n\n    def _update_line(self):\n        \"\"\"Update border line to match new shape\"\"\"\n        w = self._border_width\n        m = self.margin\n        # border is drawn within the boundaries of the widget:\n        #\n        #  size = (8, 7)  margin=2\n        #  internal rect = (3, 3, 2, 1)\n        #  ........\n        #  ........\n        #  ..BBBB..\n        #  ..B  B..\n        #  ..BBBB..\n        #  ........\n        #  ........\n        #\n        left = bot = m\n        right = self.size[0] - m\n        top = self.size[1] - m\n        pos = np.array([\n            [left, bot], [left+w, bot+w],\n            [right, bot], [right-w, bot+w],\n            [right, top], [right-w, top-w],\n            [left, top], [left+w, top-w],\n        ], dtype=np.float32)\n        faces = np.array([\n            [0, 2, 1],\n            [1, 2, 3],\n            [2, 4, 3],\n            [3, 5, 4],\n            [4, 5, 6],\n            [5, 7, 6],\n            [6, 0, 7],\n            [7, 0, 1],\n            [5, 3, 1],\n            [1, 5, 7],\n        ], dtype=np.int32)\n        start = 8 if self._border_color.is_blank else 0\n        stop = 8 if self._bgcolor.is_blank else 10\n        face_colors = None\n        if self._face_colors is not None:\n            face_colors = self._face_colors[start:stop]\n        self._mesh.set_data(vertices=pos, faces=faces[start:stop],\n                            face_colors=face_colors)\n\n        # picking mesh covers the entire area\n        self._picking_mesh.set_data(vertices=pos[::2])\n\n    def _update_colors(self):\n        self._face_colors = np.concatenate(\n            (np.tile(self.border_color.rgba, (8, 1)),\n             np.tile(self.bgcolor.rgba, (2, 1)))).astype(np.float32)\n        self._update_visibility()\n\n    @property\n    def picking(self):\n        return self._picking\n\n    @picking.setter\n    def picking(self, p):\n        Compound.picking.fset(self, p)\n        self._update_visibility()\n\n    def _update_visibility(self):\n        blank = self.border_color.is_blank and self.bgcolor.is_blank\n        picking = self.picking\n        self._picking_mesh.visible = picking and self.interactive\n        self._mesh.visible = not picking and not blank\n\n    def _update_child_widgets(self):\n        # Set the position and size of child boxes (only those added\n        # using add_widget)\n        for ch in self._widgets:\n            ch.rect = self.rect.padded(self.padding + self.margin)\n\n    def add_widget(self, widget):\n        \"\"\"\n        Add a Widget as a managed child of this Widget.\n\n        The child will be\n        automatically positioned and sized to fill the entire space inside\n        this Widget (unless _update_child_widgets is redefined).\n\n        Parameters\n        ----------\n        widget : instance of Widget\n            The widget to add.\n\n        Returns\n        -------\n        widget : instance of Widget\n            The widget.\n        \"\"\"\n        self._widgets.append(widget)\n        widget.parent = self\n        self._update_child_widgets()\n        return widget\n\n    def add_grid(self, *args, **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        All arguments are given to Grid().\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(*args, **kwargs)\n        return self.add_widget(grid)\n\n    def add_view(self, *args, **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        All arguments are given to ViewBox().\n        \"\"\"\n        from .viewbox import ViewBox\n        view = ViewBox(*args, **kwargs)\n        return self.add_widget(view)\n\n    def remove_widget(self, widget):\n        \"\"\"\n        Remove a Widget as a managed child of this Widget.\n\n        Parameters\n        ----------\n        widget : instance of Widget\n            The widget to remove.\n        \"\"\"\n        self._widgets.remove(widget)\n        widget.parent = None\n        self._update_child_widgets()",
  "def __init__(self, pos=(0, 0), size=(10, 10), border_color=None,\n                 border_width=1, bgcolor=None, padding=0, margin=0, **kwargs):\n        # For drawing border.\n        # A mesh is required because GL lines cannot be drawn with predictable\n        # shape across all platforms.\n        self._mesh = MeshVisual(color=border_color, mode='triangles')\n        self._mesh.set_gl_state('translucent', depth_test=False,\n                                cull_face=False)\n        self._picking_mesh = MeshVisual(mode='triangle_fan')\n        self._picking_mesh.set_gl_state(cull_face=False, depth_test=False)\n        self._picking_mesh.visible = False\n\n        # reserved space inside border\n        self._padding = padding\n\n        self._border_width = border_width\n\n        # reserved space outside border\n        self._margin = margin\n        self._size = 100, 100\n\n        # layout interaction\n        self._width_limits = [0, None]\n        self._height_limits = [0, None]\n        self._stretch = [None, None]\n\n        # used by the constraint solver\n        # in Grid - these are Cassowary variables\n        self._var_w = self._var_h = None\n        self._var_x = self._var_y = None\n\n        self._widgets = []\n        self._border_color = Color(border_color)\n        self._bgcolor = Color(bgcolor)\n        self._face_colors = None\n\n        # Flag to allow rect setter to know if pos or size changed.\n        self._pos_or_size_changed = False\n\n        Compound.__init__(self, [self._mesh, self._picking_mesh], **kwargs)\n\n        self.transform = STTransform()\n        self.events.add(resize=Event)\n        self.pos = pos\n        self._update_colors()\n        self.size = size",
  "def pos(self):\n        return tuple(self.transform.translate[:2])",
  "def pos(self, p):\n        assert isinstance(p, tuple)\n        assert len(p) == 2\n        # Handle floating point discrepancies\n        if abs(p[0] - self.pos[0]) < 1e-4 and \\\n           abs(p[1] - self.pos[1]) < 1e-4:\n            return\n        self._pos_or_size_changed = True\n        self.transform.translate = p[0], p[1], 0, 0\n        self._update_line()",
  "def size(self):\n        \"\"\"The size (w, h) of this widget.\n\n        If the widget is a child of another widget, then its size is assigned\n        automatically by its parent.\n        \"\"\"\n        return self._size",
  "def size(self, s):\n        assert isinstance(s, tuple)\n        assert len(s) == 2\n        # Handle floating point discrepancies\n        if abs(s[0] - self._size[0]) < 1e-4 and \\\n           abs(s[1] - self._size[1]) < 1e-4:\n            return\n        self._pos_or_size_changed = True\n        self._size = s\n        self._update_line()\n        self._update_child_widgets()\n        self._update_clipper()\n        self.events.resize()",
  "def width(self):\n        \"\"\"The actual width of this widget\"\"\"\n        return self._size[0]",
  "def width_min(self):\n        \"\"\"The minimum width the widget can have\"\"\"\n        return self._width_limits[0]",
  "def width_min(self, width_min):\n        \"\"\"Set the minimum height of the widget\n\n        Parameters\n        ----------\n        height_min: float\n            the minimum height of the widget\n        \"\"\"\n        if width_min is None:\n            self._width_limits[0] = 0\n            return\n\n        width_min = float(width_min)\n        assert(0 <= width_min)\n\n        self._width_limits[0] = width_min\n        self._update_layout()",
  "def width_max(self):\n        \"\"\"The maximum width the widget can have\"\"\"\n        return self._width_limits[1]",
  "def width_max(self, width_max):\n        \"\"\"Set the maximum width of the widget.\n\n        Parameters\n        ----------\n        width_max: None | float\n            the maximum width of the widget. if None, maximum width\n            is unbounded\n        \"\"\"\n        if width_max is None:\n            self._width_limits[1] = None\n            return\n\n        width_max = float(width_max)\n        assert(self.width_min <= width_max)\n\n        self._width_limits[1] = width_max\n        self._update_layout()",
  "def height(self):\n        \"\"\"The actual height of the widget\"\"\"\n        return self._size[1]",
  "def height_min(self):\n        \"\"\"The minimum height of the widget\"\"\"\n        return self._height_limits[0]",
  "def height_min(self, height_min):\n        \"\"\"Set the minimum height of the widget\n\n        Parameters\n        ----------\n        height_min: float\n            the minimum height of the widget\n        \"\"\"\n        if height_min is None:\n            self._height_limits[0] = 0\n            return\n\n        height_min = float(height_min)\n        assert(height_min >= 0)\n\n        self._height_limits[0] = height_min\n        self._update_layout()",
  "def height_max(self):\n        \"\"\"The maximum height of the widget\"\"\"\n        return self._height_limits[1]",
  "def height_max(self, height_max):\n        \"\"\"Set the maximum height of the widget.\n\n        Parameters\n        ----------\n        height_max: None | float\n            the maximum height of the widget. if None, maximum height\n            is unbounded\n        \"\"\"\n        if height_max is None:\n            self._height_limits[1] = None\n            return\n\n        height_max = float(height_max)\n        assert(0 <= self.height_min <= height_max)\n        self._height_limits[1] = height_max\n        self._update_layout()",
  "def rect(self):\n        return Rect((0, 0), self.size)",
  "def rect(self, r):\n        self._pos_or_size_changed = False\n        with self.events.resize.blocker():\n            self.pos = r.pos\n            self.size = r.size\n        if self._pos_or_size_changed:\n            self.update()\n            self.events.resize()",
  "def inner_rect(self):\n        \"\"\"The rectangular area inside the margin, border, and padding.\n\n        Generally widgets should avoid drawing or placing sub-widgets outside\n        this rectangle.\n        \"\"\"\n        m = self.margin + self._border_width + self.padding\n        if not self.border_color.is_blank:\n            m += 1\n        return Rect((m, m), (self.size[0]-2*m, self.size[1]-2*m))",
  "def stretch(self):\n        \"\"\"Stretch factors (w, h) used when determining how much space to\n        allocate to this widget in a layout.\n\n        If either stretch factor is None, then it will be assigned when the\n        widget is added to a layout based on the number of columns or rows it\n        occupies.\n        \"\"\"\n        return self._stretch",
  "def stretch(self, s):\n        self._stretch = [float(s[0]), float(s[1])]\n\n        if self._stretch[0] == 0:\n            raise RuntimeError(\"received 0 as stretch parameter: %s\", s)\n\n        if self._stretch[1] == 0:\n            raise RuntimeError(\"received 0 as stretch parameter: %s\", s)\n\n        self._update_layout()",
  "def _update_layout(self):\n        if isinstance(self.parent, Widget):\n            self.parent._update_child_widgets()",
  "def _update_clipper(self):\n        \"\"\"Called whenever the clipper for this widget may need to be updated.\"\"\"\n        if self.clip_children and self._clipper is None:\n            self._clipper = Clipper()\n        elif not self.clip_children:\n            self._clipper = None\n\n        if self._clipper is None:\n            return\n        self._clipper.rect = self.inner_rect\n        self._clipper.transform = self.get_transform('framebuffer', 'visual')",
  "def border_color(self):\n        \"\"\"The color of the border.\"\"\"\n        return self._border_color",
  "def border_color(self, b):\n        self._border_color = Color(b)\n        self._update_colors()\n        self._update_line()\n        self.update()",
  "def bgcolor(self):\n        \"\"\"The background color of the Widget.\"\"\"\n        return self._bgcolor",
  "def bgcolor(self, value):\n        self._bgcolor = Color(value)\n        self._update_colors()\n        self._update_line()\n        self.update()",
  "def margin(self):\n        return self._margin",
  "def margin(self, m):\n        self._margin = m\n        self._update_child_widgets()\n        self._update_line()\n        self.update()\n        self.events.resize()",
  "def padding(self):\n        return self._padding",
  "def padding(self, p):\n        self._padding = p\n        self._update_child_widgets()\n        self.update()",
  "def _update_line(self):\n        \"\"\"Update border line to match new shape\"\"\"\n        w = self._border_width\n        m = self.margin\n        # border is drawn within the boundaries of the widget:\n        #\n        #  size = (8, 7)  margin=2\n        #  internal rect = (3, 3, 2, 1)\n        #  ........\n        #  ........\n        #  ..BBBB..\n        #  ..B  B..\n        #  ..BBBB..\n        #  ........\n        #  ........\n        #\n        left = bot = m\n        right = self.size[0] - m\n        top = self.size[1] - m\n        pos = np.array([\n            [left, bot], [left+w, bot+w],\n            [right, bot], [right-w, bot+w],\n            [right, top], [right-w, top-w],\n            [left, top], [left+w, top-w],\n        ], dtype=np.float32)\n        faces = np.array([\n            [0, 2, 1],\n            [1, 2, 3],\n            [2, 4, 3],\n            [3, 5, 4],\n            [4, 5, 6],\n            [5, 7, 6],\n            [6, 0, 7],\n            [7, 0, 1],\n            [5, 3, 1],\n            [1, 5, 7],\n        ], dtype=np.int32)\n        start = 8 if self._border_color.is_blank else 0\n        stop = 8 if self._bgcolor.is_blank else 10\n        face_colors = None\n        if self._face_colors is not None:\n            face_colors = self._face_colors[start:stop]\n        self._mesh.set_data(vertices=pos, faces=faces[start:stop],\n                            face_colors=face_colors)\n\n        # picking mesh covers the entire area\n        self._picking_mesh.set_data(vertices=pos[::2])",
  "def _update_colors(self):\n        self._face_colors = np.concatenate(\n            (np.tile(self.border_color.rgba, (8, 1)),\n             np.tile(self.bgcolor.rgba, (2, 1)))).astype(np.float32)\n        self._update_visibility()",
  "def picking(self):\n        return self._picking",
  "def picking(self, p):\n        Compound.picking.fset(self, p)\n        self._update_visibility()",
  "def _update_visibility(self):\n        blank = self.border_color.is_blank and self.bgcolor.is_blank\n        picking = self.picking\n        self._picking_mesh.visible = picking and self.interactive\n        self._mesh.visible = not picking and not blank",
  "def _update_child_widgets(self):\n        # Set the position and size of child boxes (only those added\n        # using add_widget)\n        for ch in self._widgets:\n            ch.rect = self.rect.padded(self.padding + self.margin)",
  "def add_widget(self, widget):\n        \"\"\"\n        Add a Widget as a managed child of this Widget.\n\n        The child will be\n        automatically positioned and sized to fill the entire space inside\n        this Widget (unless _update_child_widgets is redefined).\n\n        Parameters\n        ----------\n        widget : instance of Widget\n            The widget to add.\n\n        Returns\n        -------\n        widget : instance of Widget\n            The widget.\n        \"\"\"\n        self._widgets.append(widget)\n        widget.parent = self\n        self._update_child_widgets()\n        return widget",
  "def add_grid(self, *args, **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        All arguments are given to Grid().\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(*args, **kwargs)\n        return self.add_widget(grid)",
  "def add_view(self, *args, **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        All arguments are given to ViewBox().\n        \"\"\"\n        from .viewbox import ViewBox\n        view = ViewBox(*args, **kwargs)\n        return self.add_widget(view)",
  "def remove_widget(self, widget):\n        \"\"\"\n        Remove a Widget as a managed child of this Widget.\n\n        Parameters\n        ----------\n        widget : instance of Widget\n            The widget to remove.\n        \"\"\"\n        self._widgets.remove(widget)\n        widget.parent = None\n        self._update_child_widgets()",
  "class ColorBarWidget(Widget):\n    \"\"\"Widget containing a ColorBar\n\n    Parameters\n    ----------\n    cmap : str | vispy.color.ColorMap\n        Either the name of the ColorMap to be used from the standard\n        set of names (refer to `vispy.color.get_colormap`),\n        or a custom ColorMap object.\n        The ColorMap is used to apply a gradient on the colorbar.\n    orientation : {'left', 'right', 'top', 'bottom'}\n        The orientation of the colorbar, used for rendering. The\n        orientation can be thought of as the position of the label\n        relative to the color bar.\n\n        When the orientation is 'left' or 'right', the colorbar is\n        vertically placed. When it is 'top' or 'bottom', the colorbar is\n        horizontally placed. The colorbar automatically resizes when its\n        container's dimension changes.\n\n            * 'top': the colorbar is horizontal.\n              Color is applied from left to right.\n              Minimum corresponds to left and maximum to right.\n              Label is to the top of the colorbar\n\n            * 'bottom': Same as top, except that\n              label is to the bottom of the colorbar\n\n            * 'left': the colorbar is vertical.\n              Color is applied from bottom to top.\n              Minimum corresponds to bottom and maximum to top.\n              Label is to the left of the colorbar\n\n            * 'right': Same as left, except that the\n              label is placed to the right of the colorbar\n    label : str\n        The label that is to be drawn with the colorbar\n        that provides information about the colorbar.\n    label_color : str | vispy.color.Color\n        The color of labels. This can either be a\n        str as the color's name or an actual instace of a vipy.color.Color\n    clim : tuple (min, max)\n        the minimum and maximum values of the data that\n        is given to the colorbar. This is used to draw the scale\n        on the side of the colorbar.\n    border_width : float (in px)\n        The width of the border the colormap should have. This measurement\n        is given in pixels\n    border_color : str | vispy.color.Color\n        The color of the border of the colormap. This can either be a\n        str as the color's name or an actual instace of a vipy.color.Color\n    padding : tuple (major_axis, minor_axis) [0, 1]\n        padding with respect to the major and minor axis\n    axis_ratio : float\n        ratio of minor axis to major axis\n    \"\"\"\n\n    def __init__(self, cmap, orientation,\n                 label=\"\", label_color='black', clim=(\"\", \"\"),\n                 border_width=0.0, border_color=\"black\",\n                 padding=(0.2, 0.2), axis_ratio=0.05, **kwargs):\n\n        dummy_size = (1, 1)\n        self._major_axis_padding = padding[0]\n        self._minor_axis_padding = padding[1]\n        self._minor_axis_ratio = axis_ratio\n\n        self._colorbar = ColorBarVisual(size=dummy_size, cmap=cmap,\n                                        orientation=orientation,\n                                        label=label, clim=clim,\n                                        label_color=label_color,\n                                        border_width=border_width,\n                                        border_color=border_color, **kwargs)\n\n        Widget.__init__(self)\n\n        self.add_subvisual(self._colorbar)\n        self._update_colorbar()\n\n    def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._update_colorbar()\n\n    def _update_colorbar(self):\n        self._colorbar.pos = self.rect.center\n        self._colorbar.size = self._calc_size()\n\n    def _calc_size(self):\n        \"\"\"Calculate a size\"\"\"\n        (total_halfx, total_halfy) = (self.rect.right, self.rect.top)\n        if self._colorbar.orientation in [\"bottom\", \"top\"]:\n            (total_major_axis, total_minor_axis) = (total_halfx, total_halfy)\n        else:\n            (total_major_axis, total_minor_axis) = (total_halfy, total_halfx)\n\n        major_axis = total_major_axis * (1.0 -\n                                         self._major_axis_padding)\n        minor_axis = major_axis * self._minor_axis_ratio\n\n        # if the minor axis is \"leaking\" from the padding, then clamp\n        minor_axis = np.minimum(minor_axis,\n                                total_minor_axis *\n                                (1.0 - self._minor_axis_padding))\n\n        return (major_axis, minor_axis)\n\n    @property\n    def cmap(self):\n        return self._colorbar.cmap\n\n    @cmap.setter\n    def cmap(self, cmap):\n        self._colorbar.cmap = cmap\n\n    @property\n    def label(self):\n        return self._colorbar.label\n\n    @label.setter\n    def label(self, label):\n        self._colorbar.label = label\n\n    @property\n    def ticks(self):\n        return self._colorbar.ticks\n\n    @ticks.setter\n    def ticks(self, ticks):\n        self._colorbar.ticks = ticks\n\n    @property\n    def clim(self):\n        return self._colorbar.clim\n\n    @clim.setter\n    def clim(self, clim):\n        self._colorbar.clim = clim\n\n    @property\n    def border_color(self):\n        \"\"\"The color of the border around the ColorBar in pixels\"\"\"\n        return self._colorbar.border_color\n\n    @border_color.setter\n    def border_color(self, border_color):\n        self._colorbar.border_color = border_color\n\n    @property\n    def border_width(self):\n        \"\"\"The width of the border around the ColorBar in pixels\"\"\"\n        return self._colorbar.border_width\n\n    @border_width.setter\n    def border_width(self, border_width):\n        self._colorbar.border_width = border_width\n\n    @property\n    def orientation(self):\n        return self._colorbar.orientation",
  "def __init__(self, cmap, orientation,\n                 label=\"\", label_color='black', clim=(\"\", \"\"),\n                 border_width=0.0, border_color=\"black\",\n                 padding=(0.2, 0.2), axis_ratio=0.05, **kwargs):\n\n        dummy_size = (1, 1)\n        self._major_axis_padding = padding[0]\n        self._minor_axis_padding = padding[1]\n        self._minor_axis_ratio = axis_ratio\n\n        self._colorbar = ColorBarVisual(size=dummy_size, cmap=cmap,\n                                        orientation=orientation,\n                                        label=label, clim=clim,\n                                        label_color=label_color,\n                                        border_width=border_width,\n                                        border_color=border_color, **kwargs)\n\n        Widget.__init__(self)\n\n        self.add_subvisual(self._colorbar)\n        self._update_colorbar()",
  "def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._update_colorbar()",
  "def _update_colorbar(self):\n        self._colorbar.pos = self.rect.center\n        self._colorbar.size = self._calc_size()",
  "def _calc_size(self):\n        \"\"\"Calculate a size\"\"\"\n        (total_halfx, total_halfy) = (self.rect.right, self.rect.top)\n        if self._colorbar.orientation in [\"bottom\", \"top\"]:\n            (total_major_axis, total_minor_axis) = (total_halfx, total_halfy)\n        else:\n            (total_major_axis, total_minor_axis) = (total_halfy, total_halfx)\n\n        major_axis = total_major_axis * (1.0 -\n                                         self._major_axis_padding)\n        minor_axis = major_axis * self._minor_axis_ratio\n\n        # if the minor axis is \"leaking\" from the padding, then clamp\n        minor_axis = np.minimum(minor_axis,\n                                total_minor_axis *\n                                (1.0 - self._minor_axis_padding))\n\n        return (major_axis, minor_axis)",
  "def cmap(self):\n        return self._colorbar.cmap",
  "def cmap(self, cmap):\n        self._colorbar.cmap = cmap",
  "def label(self):\n        return self._colorbar.label",
  "def label(self, label):\n        self._colorbar.label = label",
  "def ticks(self):\n        return self._colorbar.ticks",
  "def ticks(self, ticks):\n        self._colorbar.ticks = ticks",
  "def clim(self):\n        return self._colorbar.clim",
  "def clim(self, clim):\n        self._colorbar.clim = clim",
  "def border_color(self):\n        \"\"\"The color of the border around the ColorBar in pixels\"\"\"\n        return self._colorbar.border_color",
  "def border_color(self, border_color):\n        self._colorbar.border_color = border_color",
  "def border_width(self):\n        \"\"\"The width of the border around the ColorBar in pixels\"\"\"\n        return self._colorbar.border_width",
  "def border_width(self, border_width):\n        self._colorbar.border_width = border_width",
  "def orientation(self):\n        return self._colorbar.orientation",
  "class Console(Widget):\n    \"\"\"Fast and failsafe text console\n\n    Parameters\n    ----------\n    text_color : instance of Color\n        Color to use.\n    font_size : float\n        Point size to use.\n    \"\"\"\n\n    def __init__(self, text_color='black', font_size=12., **kwargs):\n        self._visual = ConsoleVisual(text_color, font_size)\n        Widget.__init__(self, **kwargs)\n        self.add_subvisual(self._visual)\n\n    def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._visual.size = self.size\n\n    def clear(self):\n        \"\"\"Clear the console\"\"\"\n        self._visual.clear()\n\n    def write(self, text='', wrap=True):\n        \"\"\"Write text and scroll\n\n        Parameters\n        ----------\n        text : str\n            Text to write. ``''`` can be used for a blank line, as a newline\n            is automatically added to the end of each line.\n        wrap : str\n            If True, long messages will be wrapped to span multiple lines.\n        \"\"\"\n        self._visual.write(text)\n\n    @property\n    def text_color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._visual._text_color\n\n    @text_color.setter\n    def text_color(self, color):\n        self._visual._text_color = Color(color)\n\n    @property\n    def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._visual._font_size\n\n    @font_size.setter\n    def font_size(self, font_size):\n        self._visual._font_size = float(font_size)",
  "class ConsoleVisual(Visual):\n    def __init__(self, text_color, font_size, **kwargs):\n        # Harcoded because of font above and shader program\n        self.text_color = text_color\n        self.font_size = font_size\n        self._char_width = 6\n        self._char_height = 10\n        self._pending_writes = []\n        self._text_lines = []\n        self._col = 0\n        self._current_sizes = (-1,) * 3\n        self._size = (100, 100)\n        Visual.__init__(self, VERTEX_SHADER, FRAGMENT_SHADER)\n        self._draw_mode = 'points'\n        self.set_gl_state(depth_test=False, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, s):\n        self._size = s\n\n    @property\n    def text_color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._text_color\n\n    @text_color.setter\n    def text_color(self, color):\n        self._text_color = Color(color)\n\n    @property\n    def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._font_size\n\n    @font_size.setter\n    def font_size(self, font_size):\n        self._font_size = float(font_size)\n\n    def _resize_buffers(self, font_scale):\n        \"\"\"Resize buffers only if necessary\"\"\"\n        new_sizes = (font_scale,) + self.size\n        if new_sizes == self._current_sizes:  # don't need resize\n            return\n        self._n_rows = int(max(self.size[1] /\n                               (self._char_height * font_scale), 1))\n        self._n_cols = int(max(self.size[0] /\n                               (self._char_width * font_scale), 1))\n        self._bytes_012 = np.zeros((self._n_rows, self._n_cols, 3), np.float32)\n        self._bytes_345 = np.zeros((self._n_rows, self._n_cols, 3), np.float32)\n        pos = np.empty((self._n_rows, self._n_cols, 2), np.float32)\n        C, R = np.meshgrid(np.arange(self._n_cols), np.arange(self._n_rows))\n        # We are in left, top orientation\n        x_off = 4.\n        y_off = 4 - self.size[1] / font_scale\n        pos[..., 0] = x_off + self._char_width * C\n        pos[..., 1] = y_off + self._char_height * R\n        self._position = VertexBuffer(pos)\n\n        # Restore lines\n        for ii, line in enumerate(self._text_lines[:self._n_rows]):\n            self._insert_text_buf(line, ii)\n        self._current_sizes = new_sizes\n\n    def _prepare_draw(self, view):\n        xform = view.get_transform()\n        tr = view.get_transform('document', 'render')\n        logical_scale = np.diff(tr.map(([0, 1], [1, 0])), axis=0)[0, :2]\n        tr = view.get_transform('document', 'framebuffer')\n        log_to_phy = np.mean(np.diff(tr.map(([0, 1], [1, 0])), axis=0)[0, :2])\n        n_pix = (self.font_size / 72.) * 92.  # num of pixels tall\n        # The -2 here is because the char_height has a gap built in\n        font_scale = max(n_pix / float((self._char_height-2)), 1)\n        self._resize_buffers(font_scale)\n        self._do_pending_writes()\n        self._program['u_origin'] = xform.map((0, 0, 0, 1))\n        self._program['u_logical_scale'] = font_scale * logical_scale\n        self._program['u_color'] = self.text_color.rgba\n        self._program['u_physical_scale'] = font_scale * log_to_phy\n        self._program['a_position'] = self._position\n        self._program['a_bytes_012'] = VertexBuffer(self._bytes_012)\n        self._program['a_bytes_345'] = VertexBuffer(self._bytes_345)\n\n    def _prepare_transforms(self, view):\n        pass\n\n    def clear(self):\n        \"\"\"Clear the console\"\"\"\n        if hasattr(self, '_bytes_012'):\n            self._bytes_012.fill(0)\n            self._bytes_345.fill(0)\n        self._text_lines = [] * self._n_rows\n        self._pending_writes = []\n\n    def write(self, text='', wrap=True):\n        \"\"\"Write text and scroll\n\n        Parameters\n        ----------\n        text : str\n            Text to write. ``''`` can be used for a blank line, as a newline\n            is automatically added to the end of each line.\n        wrap : str\n            If True, long messages will be wrapped to span multiple lines.\n        \"\"\"\n        # Clear line\n        if not isinstance(text, str):\n            raise TypeError('text must be a string')\n        # ensure we only have ASCII chars\n        text = text.encode('utf-8').decode('ascii', errors='replace')\n        self._pending_writes.append((text, wrap))\n        self.update()\n\n    def _do_pending_writes(self):\n        \"\"\"Do any pending text writes\"\"\"\n        for text, wrap in self._pending_writes:\n            # truncate in case of *really* long messages\n            text = text[-self._n_cols*self._n_rows:]\n            text = text.split('\\n')\n            text = [t if len(t) > 0 else '' for t in text]\n            nr, nc = self._n_rows, self._n_cols\n            for para in text:\n                para = para[:nc] if not wrap else para\n                lines = [para[ii:(ii+nc)] for ii in range(0, len(para), nc)]\n                lines = [''] if len(lines) == 0 else lines\n                for line in lines:\n                    # Update row and scroll if necessary\n                    self._text_lines.insert(0, line)\n                    self._text_lines = self._text_lines[:nr]\n                    self._bytes_012[1:] = self._bytes_012[:-1]\n                    self._bytes_345[1:] = self._bytes_345[:-1]\n                    self._insert_text_buf(line, 0)\n        self._pending_writes = []\n\n    def _insert_text_buf(self, line, idx):\n        \"\"\"Insert text into bytes buffers\"\"\"\n        self._bytes_012[idx] = 0\n        self._bytes_345[idx] = 0\n        # Crop text if necessary\n        ord_chars = np.array([ord(c) - 32 for c in line[:self._n_cols]])\n        ord_chars = np.clip(ord_chars, 0, len(__font_6x8__)-1)\n        if len(ord_chars) > 0:\n            b = __font_6x8__[ord_chars]\n            self._bytes_012[idx, :len(ord_chars)] = b[:, :3]\n            self._bytes_345[idx, :len(ord_chars)] = b[:, 3:]",
  "def __init__(self, text_color='black', font_size=12., **kwargs):\n        self._visual = ConsoleVisual(text_color, font_size)\n        Widget.__init__(self, **kwargs)\n        self.add_subvisual(self._visual)",
  "def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._visual.size = self.size",
  "def clear(self):\n        \"\"\"Clear the console\"\"\"\n        self._visual.clear()",
  "def write(self, text='', wrap=True):\n        \"\"\"Write text and scroll\n\n        Parameters\n        ----------\n        text : str\n            Text to write. ``''`` can be used for a blank line, as a newline\n            is automatically added to the end of each line.\n        wrap : str\n            If True, long messages will be wrapped to span multiple lines.\n        \"\"\"\n        self._visual.write(text)",
  "def text_color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._visual._text_color",
  "def text_color(self, color):\n        self._visual._text_color = Color(color)",
  "def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._visual._font_size",
  "def font_size(self, font_size):\n        self._visual._font_size = float(font_size)",
  "def __init__(self, text_color, font_size, **kwargs):\n        # Harcoded because of font above and shader program\n        self.text_color = text_color\n        self.font_size = font_size\n        self._char_width = 6\n        self._char_height = 10\n        self._pending_writes = []\n        self._text_lines = []\n        self._col = 0\n        self._current_sizes = (-1,) * 3\n        self._size = (100, 100)\n        Visual.__init__(self, VERTEX_SHADER, FRAGMENT_SHADER)\n        self._draw_mode = 'points'\n        self.set_gl_state(depth_test=False, blend=True,\n                          blend_func=('src_alpha', 'one_minus_src_alpha'))",
  "def size(self):\n        return self._size",
  "def size(self, s):\n        self._size = s",
  "def text_color(self):\n        \"\"\"The color of the text\"\"\"\n        return self._text_color",
  "def text_color(self, color):\n        self._text_color = Color(color)",
  "def font_size(self):\n        \"\"\"The font size (in points) of the text\"\"\"\n        return self._font_size",
  "def font_size(self, font_size):\n        self._font_size = float(font_size)",
  "def _resize_buffers(self, font_scale):\n        \"\"\"Resize buffers only if necessary\"\"\"\n        new_sizes = (font_scale,) + self.size\n        if new_sizes == self._current_sizes:  # don't need resize\n            return\n        self._n_rows = int(max(self.size[1] /\n                               (self._char_height * font_scale), 1))\n        self._n_cols = int(max(self.size[0] /\n                               (self._char_width * font_scale), 1))\n        self._bytes_012 = np.zeros((self._n_rows, self._n_cols, 3), np.float32)\n        self._bytes_345 = np.zeros((self._n_rows, self._n_cols, 3), np.float32)\n        pos = np.empty((self._n_rows, self._n_cols, 2), np.float32)\n        C, R = np.meshgrid(np.arange(self._n_cols), np.arange(self._n_rows))\n        # We are in left, top orientation\n        x_off = 4.\n        y_off = 4 - self.size[1] / font_scale\n        pos[..., 0] = x_off + self._char_width * C\n        pos[..., 1] = y_off + self._char_height * R\n        self._position = VertexBuffer(pos)\n\n        # Restore lines\n        for ii, line in enumerate(self._text_lines[:self._n_rows]):\n            self._insert_text_buf(line, ii)\n        self._current_sizes = new_sizes",
  "def _prepare_draw(self, view):\n        xform = view.get_transform()\n        tr = view.get_transform('document', 'render')\n        logical_scale = np.diff(tr.map(([0, 1], [1, 0])), axis=0)[0, :2]\n        tr = view.get_transform('document', 'framebuffer')\n        log_to_phy = np.mean(np.diff(tr.map(([0, 1], [1, 0])), axis=0)[0, :2])\n        n_pix = (self.font_size / 72.) * 92.  # num of pixels tall\n        # The -2 here is because the char_height has a gap built in\n        font_scale = max(n_pix / float((self._char_height-2)), 1)\n        self._resize_buffers(font_scale)\n        self._do_pending_writes()\n        self._program['u_origin'] = xform.map((0, 0, 0, 1))\n        self._program['u_logical_scale'] = font_scale * logical_scale\n        self._program['u_color'] = self.text_color.rgba\n        self._program['u_physical_scale'] = font_scale * log_to_phy\n        self._program['a_position'] = self._position\n        self._program['a_bytes_012'] = VertexBuffer(self._bytes_012)\n        self._program['a_bytes_345'] = VertexBuffer(self._bytes_345)",
  "def _prepare_transforms(self, view):\n        pass",
  "def clear(self):\n        \"\"\"Clear the console\"\"\"\n        if hasattr(self, '_bytes_012'):\n            self._bytes_012.fill(0)\n            self._bytes_345.fill(0)\n        self._text_lines = [] * self._n_rows\n        self._pending_writes = []",
  "def write(self, text='', wrap=True):\n        \"\"\"Write text and scroll\n\n        Parameters\n        ----------\n        text : str\n            Text to write. ``''`` can be used for a blank line, as a newline\n            is automatically added to the end of each line.\n        wrap : str\n            If True, long messages will be wrapped to span multiple lines.\n        \"\"\"\n        # Clear line\n        if not isinstance(text, str):\n            raise TypeError('text must be a string')\n        # ensure we only have ASCII chars\n        text = text.encode('utf-8').decode('ascii', errors='replace')\n        self._pending_writes.append((text, wrap))\n        self.update()",
  "def _do_pending_writes(self):\n        \"\"\"Do any pending text writes\"\"\"\n        for text, wrap in self._pending_writes:\n            # truncate in case of *really* long messages\n            text = text[-self._n_cols*self._n_rows:]\n            text = text.split('\\n')\n            text = [t if len(t) > 0 else '' for t in text]\n            nr, nc = self._n_rows, self._n_cols\n            for para in text:\n                para = para[:nc] if not wrap else para\n                lines = [para[ii:(ii+nc)] for ii in range(0, len(para), nc)]\n                lines = [''] if len(lines) == 0 else lines\n                for line in lines:\n                    # Update row and scroll if necessary\n                    self._text_lines.insert(0, line)\n                    self._text_lines = self._text_lines[:nr]\n                    self._bytes_012[1:] = self._bytes_012[:-1]\n                    self._bytes_345[1:] = self._bytes_345[:-1]\n                    self._insert_text_buf(line, 0)\n        self._pending_writes = []",
  "def _insert_text_buf(self, line, idx):\n        \"\"\"Insert text into bytes buffers\"\"\"\n        self._bytes_012[idx] = 0\n        self._bytes_345[idx] = 0\n        # Crop text if necessary\n        ord_chars = np.array([ord(c) - 32 for c in line[:self._n_cols]])\n        ord_chars = np.clip(ord_chars, 0, len(__font_6x8__)-1)\n        if len(ord_chars) > 0:\n            b = __font_6x8__[ord_chars]\n            self._bytes_012[idx, :len(ord_chars)] = b[:, :3]\n            self._bytes_345[idx, :len(ord_chars)] = b[:, 3:]",
  "class AxisWidget(Widget):\n    \"\"\"Widget containing an axis\n\n    Parameters\n    ----------\n    orientation : str\n        Orientation of the axis, 'left' or 'bottom'.\n    **kwargs : dict\n        Keyword arguments to pass to AxisVisual.\n    \"\"\"\n\n    def __init__(self, orientation='left', **kwargs):\n        if 'tick_direction' not in kwargs:\n            tickdir = {'left': (-1, 0), 'right': (1, 0), 'bottom': (0, 1),\n                       'top': (0, -1)}[orientation]\n            kwargs['tick_direction'] = tickdir\n        self.axis = AxisVisual(**kwargs)\n        self.orientation = orientation\n        self._linked_view = None\n        Widget.__init__(self)\n        self.add_subvisual(self.axis)\n\n    def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._update_axis()\n\n    def _update_axis(self):\n        self.axis.pos = self._axis_ends()\n\n    def _axis_ends(self):\n        r = self.rect\n        if self.orientation == 'left':\n            return np.array([[r.right, r.top], [r.right, r.bottom]])\n        elif self.orientation == 'bottom':\n            return np.array([[r.left, r.bottom], [r.right, r.bottom]])\n        elif self.orientation == 'right':\n            return np.array([[r.left, r.top], [r.left, r.bottom]])\n        elif self.orientation == 'top':\n            return np.array([[r.left, r.top], [r.right, r.top]])\n        else:\n            raise RuntimeError(\n                'Orientation %s not supported.' % self.orientation)\n\n    def link_view(self, view):\n        \"\"\"Link this axis to a ViewBox\n\n        This makes it so that the axis's domain always matches the\n        visible range in the ViewBox.\n\n        Parameters\n        ----------\n        view : instance of ViewBox\n            The ViewBox to link.\n        \"\"\"\n        if view is self._linked_view:\n            return\n        if self._linked_view is not None:\n            self._linked_view.scene.transform.changed.disconnect(\n                self._view_changed)\n        self._linked_view = view\n        view.scene.transform.changed.connect(self._view_changed)\n        self._view_changed()\n\n    def _view_changed(self, event=None):\n        \"\"\"Linked view transform has changed; update ticks.\"\"\"\n        tr = self.node_transform(self._linked_view.scene)\n        p1, p2 = tr.map(self._axis_ends())\n        if self.orientation in ('left', 'right'):\n            self.axis.domain = (p1[1], p2[1])\n        else:\n            self.axis.domain = (p1[0], p2[0])",
  "def __init__(self, orientation='left', **kwargs):\n        if 'tick_direction' not in kwargs:\n            tickdir = {'left': (-1, 0), 'right': (1, 0), 'bottom': (0, 1),\n                       'top': (0, -1)}[orientation]\n            kwargs['tick_direction'] = tickdir\n        self.axis = AxisVisual(**kwargs)\n        self.orientation = orientation\n        self._linked_view = None\n        Widget.__init__(self)\n        self.add_subvisual(self.axis)",
  "def on_resize(self, event):\n        \"\"\"Resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self._update_axis()",
  "def _update_axis(self):\n        self.axis.pos = self._axis_ends()",
  "def _axis_ends(self):\n        r = self.rect\n        if self.orientation == 'left':\n            return np.array([[r.right, r.top], [r.right, r.bottom]])\n        elif self.orientation == 'bottom':\n            return np.array([[r.left, r.bottom], [r.right, r.bottom]])\n        elif self.orientation == 'right':\n            return np.array([[r.left, r.top], [r.left, r.bottom]])\n        elif self.orientation == 'top':\n            return np.array([[r.left, r.top], [r.right, r.top]])\n        else:\n            raise RuntimeError(\n                'Orientation %s not supported.' % self.orientation)",
  "def link_view(self, view):\n        \"\"\"Link this axis to a ViewBox\n\n        This makes it so that the axis's domain always matches the\n        visible range in the ViewBox.\n\n        Parameters\n        ----------\n        view : instance of ViewBox\n            The ViewBox to link.\n        \"\"\"\n        if view is self._linked_view:\n            return\n        if self._linked_view is not None:\n            self._linked_view.scene.transform.changed.disconnect(\n                self._view_changed)\n        self._linked_view = view\n        view.scene.transform.changed.connect(self._view_changed)\n        self._view_changed()",
  "def _view_changed(self, event=None):\n        \"\"\"Linked view transform has changed; update ticks.\"\"\"\n        tr = self.node_transform(self._linked_view.scene)\n        p1, p2 = tr.map(self._axis_ends())\n        if self.orientation in ('left', 'right'):\n            self.axis.domain = (p1[1], p2[1])\n        else:\n            self.axis.domain = (p1[0], p2[0])",
  "class Anchor(Node):\n    \"\"\"\n    Anchor is a node derives parts of its transform from some other\n    coordinate system in the scene.\n\n    The purpose is to allow children of an Anchor to draw using a position\n    (and optionally rotation) specified by one coordinate system, and scaling/\n    projection specified by another.\n\n    For example, text attached to a point in a 3D scene should be drawn in\n    a coordinate system with a simple relationship to the screen pixels, but\n    should derive its location from a position within the 3D coordinate\n    system::\n\n        root = Box()\n        view = ViewBox(parent=box)\n        plot = LineVisual(parent=ViewBox)\n        anchor = Anchor(parent=root, anchor_to=plot, anchor_pos=(10, 0))\n        text = Text(parent=anchor,\n                    text=\"Always points to (10,0) relative to line.\")\n\n    \"\"\"",
  "class Grid(Widget):\n    \"\"\"Widget for proportionally dividing its internal area into a grid.\n\n    This widget will automatically set the position and size of child widgets\n    according to provided constraints.\n\n    Parameters\n    ----------\n    spacing : int\n        Spacing between widgets.\n    **kwargs : dict\n        Keyword arguments to pass to `Widget`.\n    \"\"\"\n\n    def __init__(self, spacing=6, **kwargs):\n        \"\"\"Create solver and basic grid parameters.\"\"\"\n        self._next_cell = [0, 0]  # row, col\n        self._cells = {}\n        self._grid_widgets = {}\n        self.spacing = spacing\n        self._n_added = 0\n        self._default_class = ViewBox  # what to add when __getitem__ is used\n        self._solver = Solver()\n        self._need_solver_recreate = True\n\n        # width and height of the Rect used to place child widgets\n        self._var_w = Variable(\"w_rect\")\n        self._var_h = Variable(\"h_rect\")\n\n        self._width_grid = None\n        self._height_grid = None\n\n        # self._height_stay = None\n        # self._width_stay = None\n\n        Widget.__init__(self, **kwargs)\n\n    def __getitem__(self, idxs):\n        \"\"\"Return an item or create it if the location is available.\"\"\"\n        if not isinstance(idxs, tuple):\n            idxs = (idxs,)\n        if len(idxs) == 1:\n            idxs = idxs + (slice(0, 1, None),)\n        elif len(idxs) != 2:\n            raise ValueError('Incorrect index: %s' % (idxs,))\n        lims = np.empty((2, 2), int)\n        for ii, idx in enumerate(idxs):\n            if isinstance(idx, int):\n                idx = slice(idx, idx + 1, None)\n            if not isinstance(idx, slice):\n                raise ValueError('indices must be slices or integers, not %s'\n                                 % (type(idx),))\n            if idx.step is not None and idx.step != 1:\n                raise ValueError('step must be one or None, not %s' % idx.step)\n            start = 0 if idx.start is None else idx.start\n            end = self.grid_size[ii] if idx.stop is None else idx.stop\n            lims[ii] = [start, end]\n        layout = self.layout_array\n        existing = layout[lims[0, 0]:lims[0, 1], lims[1, 0]:lims[1, 1]] + 1\n        if existing.any():\n            existing = set(list(existing.ravel()))\n            ii = list(existing)[0] - 1\n            if len(existing) != 1 or ((layout == ii).sum() !=\n                                      np.prod(np.diff(lims))):\n                raise ValueError('Cannot add widget (collision)')\n            return self._grid_widgets[ii][-1]\n        spans = np.diff(lims)[:, 0]\n        item = self.add_widget(self._default_class(),\n                               row=lims[0, 0], col=lims[1, 0],\n                               row_span=spans[0], col_span=spans[1])\n        return item\n\n    def add_widget(self, widget=None, row=None, col=None, row_span=1,\n                   col_span=1, **kwargs):\n        \"\"\"Add a new widget to this grid.\n\n        This will cause other widgets in the grid to be resized to make room\n        for the new widget. Can be used to replace a widget as well.\n\n        Parameters\n        ----------\n        widget : Widget | None\n            The Widget to add. New widget is constructed if widget is None.\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            parameters sent to the new Widget that is constructed if\n            widget is None\n\n        Notes\n        -----\n        The widget's parent is automatically set to this grid, and all other\n        parent(s) are removed.\n        \"\"\"\n        if row is None:\n            row = self._next_cell[0]\n        if col is None:\n            col = self._next_cell[1]\n\n        if widget is None:\n            widget = Widget(**kwargs)\n        else:\n            if kwargs:\n                raise ValueError(\"cannot send kwargs if widget is given\")\n\n        _row = self._cells.setdefault(row, {})\n        _row[col] = widget\n        self._grid_widgets[self._n_added] = (row, col, row_span, col_span,\n                                             widget)\n        self._n_added += 1\n        widget.parent = self\n\n        self._next_cell = [row, col+col_span]\n\n        widget._var_w = Variable(\"w-(row: %s | col: %s)\" % (row, col))\n        widget._var_h = Variable(\"h-(row: %s | col: %s)\" % (row, col))\n\n        # update stretch based on colspan/rowspan\n        # usually, if you make something consume more grids or columns,\n        # you also want it to actually *take it up*, ratio wise.\n        # otherwise, it will never *use* the extra rows and columns,\n        # thereby collapsing the extras to 0.\n        stretch = list(widget.stretch)\n        stretch[0] = col_span if stretch[0] is None else stretch[0]\n        stretch[1] = row_span if stretch[1] is None else stretch[1]\n        widget.stretch = stretch\n\n        self._need_solver_recreate = True\n\n        return widget\n\n    def remove_widget(self, widget):\n        \"\"\"Remove a widget from this grid.\n\n        Parameters\n        ----------\n        widget : Widget\n            The Widget to remove\n        \"\"\"\n        self._grid_widgets = dict((key, val)\n                                  for (key, val) in self._grid_widgets.items()\n                                  if val[-1] != widget)\n\n        self._need_solver_recreate = True\n\n    def resize_widget(self, widget, row_span, col_span):\n        \"\"\"Resize a widget in the grid to new dimensions.\n\n        Parameters\n        ----------\n        widget : Widget\n            The widget to resize\n        row_span : int\n            The number of rows to be occupied by this widget.\n        col_span : int\n            The number of columns to be occupied by this widget.\n        \"\"\"\n        row = None\n        col = None\n\n        for (r, c, _rspan, _cspan, w) in self._grid_widgets.values():\n            if w == widget:\n                row = r\n                col = c\n\n                break\n\n        if row is None or col is None:\n            raise ValueError(\"%s not found in grid\" % widget)\n\n        self.remove_widget(widget)\n        self.add_widget(widget, row, col, row_span, col_span)\n        self._need_solver_recreate = True\n\n    def _prepare_draw(self, view):\n        self._update_child_widget_dim()\n\n    def add_grid(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to the new `Grid`.\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(**kwargs)\n        return self.add_widget(grid, row, col, row_span, col_span)\n\n    def add_view(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to `ViewBox`.\n        \"\"\"\n        view = ViewBox(**kwargs)\n        return self.add_widget(view, row, col, row_span, col_span)\n\n    def next_row(self):\n        self._next_cell = [self._next_cell[0] + 1, 0]\n\n    @property\n    def grid_size(self):\n        rvals = [widget[0]+widget[2] for widget in self._grid_widgets.values()]\n        cvals = [widget[1]+widget[3] for widget in self._grid_widgets.values()]\n        return max(rvals + [0]), max(cvals + [0])\n\n    @property\n    def layout_array(self):\n        locs = -1 * np.ones(self.grid_size, int)\n        for key in self._grid_widgets.keys():\n            r, c, rs, cs = self._grid_widgets[key][:4]\n            locs[r:r + rs, c:c + cs] = key\n        return locs\n\n    def __repr__(self):\n        return (('<Grid at %s:\\n' % hex(id(self))) +\n                str(self.layout_array + 1) + '>')\n\n    @staticmethod\n    def _add_total_width_constraints(solver, width_grid, _var_w):\n        for ws in width_grid:\n            width_expr = ws[0]\n            for w in ws[1:]:\n                width_expr += w\n            solver.addConstraint(width_expr == _var_w)\n\n    @staticmethod\n    def _add_total_height_constraints(solver, height_grid, _var_h):\n        for hs in height_grid:\n            height_expr = hs[0]\n            for h in hs[1:]:\n                height_expr += h\n            solver.addConstraint(height_expr == _var_h)\n\n    @staticmethod\n    def _add_gridding_width_constraints(solver, width_grid):\n        # access widths of one \"y\", different x\n        for ws in width_grid.T:\n            for w in ws[1:]:\n                solver.addConstraint(ws[0] == w)\n\n    @staticmethod\n    def _add_gridding_height_constraints(solver, height_grid):\n        # access heights of one \"y\"\n        for hs in height_grid.T:\n            for h in hs[1:]:\n                solver.addConstraint(hs[0] == h)\n\n    @staticmethod\n    def _add_stretch_constraints(solver, width_grid, height_grid,\n                                 grid_widgets, widget_grid):\n        xmax = len(height_grid)\n        ymax = len(width_grid)\n\n        stretch_widths = [[] for _ in range(0, ymax)]\n        stretch_heights = [[] for _ in range(0, xmax)]\n\n        for (y, x, ys, xs, widget) in grid_widgets.values():\n            for ws in width_grid[y:y+ys]:\n                total_w = np.sum(ws[x:x+xs])\n\n                for sw in stretch_widths[y:y+ys]:\n                    sw.append((total_w, widget.stretch[0]))\n\n            for hs in height_grid[x:x+xs]:\n                total_h = np.sum(hs[y:y+ys])\n\n                for sh in stretch_heights[x:x+xs]:\n                    sh.append((total_h, widget.stretch[1]))\n\n        for (x, xs) in enumerate(widget_grid):\n            for(y, widget) in enumerate(xs):\n                if widget is None:\n                    stretch_widths[y].append((width_grid[y][x], 1))\n                    stretch_heights[x].append((height_grid[x][y], 1))\n\n        for sws in stretch_widths:\n            if len(sws) <= 1:\n                continue\n\n            comparator = sws[0][0] / sws[0][1]\n\n            for (stretch_term, stretch_val) in sws[1:]:\n                solver.addConstraint((comparator == stretch_term/stretch_val) |\n                                     'weak')\n\n        for sws in stretch_heights:\n            if len(sws) <= 1:\n                continue\n\n            comparator = sws[0][0] / sws[0][1]\n\n            for (stretch_term, stretch_val) in sws[1:]:\n                solver.addConstraint((comparator == stretch_term/stretch_val) |\n                                     'weak')\n\n    @staticmethod\n    def _add_widget_dim_constraints(solver, width_grid, height_grid,\n                                    total_var_w, total_var_h, grid_widgets):\n        assert(total_var_w is not None)\n        assert(total_var_h is not None)\n\n        for ws in width_grid:\n            for w in ws:\n                solver.addConstraint(w >= 0,)\n\n        for hs in height_grid:\n            for h in hs:\n                solver.addConstraint(h >= 0)\n\n        for (_, val) in grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n\n            for ws in width_grid[y:y+ys]:\n                total_w = np.sum(ws[x:x+xs])\n                # assert(total_w is not None)\n                solver.addConstraint(total_w >= widget.width_min)\n\n                if widget.width_max is not None:\n                    solver.addConstraint(total_w <= widget.width_max)\n                else:\n                    solver.addConstraint(total_w <= total_var_w)\n\n            for hs in height_grid[x:x+xs]:\n                total_h = np.sum(hs[y:y+ys])\n                solver.addConstraint(total_h >= widget.height_min)\n\n                if widget.height_max is not None:\n                    solver.addConstraint(total_h <= widget.height_max)\n                else:\n                    solver.addConstraint(total_h <= total_var_h)\n\n    def _recreate_solver(self):\n        self._solver.reset()\n        self._var_w = Variable(\"w_rect\")\n        self._var_h = Variable(\"h_rect\")\n        self._solver.addEditVariable(self._var_w, 'strong')\n        self._solver.addEditVariable(self._var_h, 'strong')\n\n        rect = self.rect.padded(self.padding + self.margin)\n        ymax, xmax = self.grid_size\n\n        self._solver.suggestValue(self._var_w, rect.width)\n        self._solver.suggestValue(self._var_h, rect.height)\n\n        self._solver.addConstraint(self._var_w >= 0)\n        self._solver.addConstraint(self._var_h >= 0)\n\n        # self._height_stay = None\n        # self._width_stay = None\n\n        # add widths\n        self._width_grid = np.array([[Variable(\"width(x: %s, y: %s)\" % (x, y))\n                                      for x in range(0, xmax)]\n                                     for y in range(0, ymax)])\n\n        # add heights\n        self._height_grid = np.array([[Variable(\"height(x: %s, y: %s\" % (x, y))\n                                       for y in range(0, ymax)]\n                                      for x in range(0, xmax)])\n\n        # setup stretch\n        stretch_grid = np.zeros(shape=(xmax, ymax, 2), dtype=float)\n        stretch_grid.fill(1)\n\n        for (_, val) in self._grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n            stretch_grid[x:x+xs, y:y+ys] = widget.stretch\n\n        # even though these are REQUIRED, these should never fail\n        # since they're added first, and thus the slack will \"simply work\".\n        Grid._add_total_width_constraints(self._solver,\n                                          self._width_grid, self._var_w)\n        Grid._add_total_height_constraints(self._solver,\n                                           self._height_grid, self._var_h)\n\n        try:\n            # these are REQUIRED constraints for width and height.\n            # These are the constraints which can fail if\n            # the corresponding dimension of the widget cannot be fit in the\n            # grid.\n            Grid._add_gridding_width_constraints(self._solver,\n                                                 self._width_grid)\n            Grid._add_gridding_height_constraints(self._solver,\n                                                  self._height_grid)\n        except UnsatisfiableConstraint:\n            self._need_solver_recreate = True\n\n        # these are WEAK constraints, so these constraints will never fail\n        # with a RequiredFailure.\n        Grid._add_stretch_constraints(self._solver,\n                                      self._width_grid,\n                                      self._height_grid,\n                                      self._grid_widgets,\n                                      self._widget_grid)\n\n        Grid._add_widget_dim_constraints(self._solver,\n                                         self._width_grid,\n                                         self._height_grid,\n                                         self._var_w,\n                                         self._var_h,\n                                         self._grid_widgets)\n\n        self._solver.updateVariables()\n\n    def _update_child_widget_dim(self):\n        # think in terms of (x, y). (row, col) makes code harder to read\n        ymax, xmax = self.grid_size\n        if ymax <= 0 or xmax <= 0:\n            return\n\n        rect = self.rect  # .padded(self.padding + self.margin)\n        if rect.width <= 0 or rect.height <= 0:\n            return\n        if self._need_solver_recreate:\n            self._need_solver_recreate = False\n            self._recreate_solver()\n\n        # we only need to remove and add the height and width constraints of\n        # the solver if they are not the same as the current value\n        h_changed = abs(rect.height - self._var_h.value()) > 1e-4\n        w_changed = abs(rect.width - self._var_w.value()) > 1e-4\n        if h_changed:\n            self._solver.suggestValue(self._var_h, rect.height)\n\n        if w_changed:\n            self._solver.suggestValue(self._var_w, rect.width)\n        if h_changed or w_changed:\n            self._solver.updateVariables()\n\n        value_vectorized = np.vectorize(lambda x: x.value())\n\n        for (_, val) in self._grid_widgets.items():\n            (row, col, rspan, cspan, widget) = val\n\n            width = np.sum(value_vectorized(\n                           self._width_grid[row][col:col+cspan]))\n            height = np.sum(value_vectorized(\n                            self._height_grid[col][row:row+rspan]))\n            if col == 0:\n                x = 0\n            else:\n                x = np.sum(value_vectorized(self._width_grid[row][0:col]))\n\n            if row == 0:\n                y = 0\n            else:\n                y = np.sum(value_vectorized(self._height_grid[col][0:row]))\n\n            if isinstance(widget, ViewBox):\n                widget.rect = Rect(x, y, width, height)\n            else:\n                widget.size = (width, height)\n                widget.pos = (x, y)\n\n    @property\n    def _widget_grid(self):\n        ymax, xmax = self.grid_size\n        widget_grid = np.array([[None for _ in range(0, ymax)]\n                                for _ in range(0, xmax)])\n        for (_, val) in self._grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n            widget_grid[x:x+xs, y:y+ys] = widget\n\n        return widget_grid",
  "def __init__(self, spacing=6, **kwargs):\n        \"\"\"Create solver and basic grid parameters.\"\"\"\n        self._next_cell = [0, 0]  # row, col\n        self._cells = {}\n        self._grid_widgets = {}\n        self.spacing = spacing\n        self._n_added = 0\n        self._default_class = ViewBox  # what to add when __getitem__ is used\n        self._solver = Solver()\n        self._need_solver_recreate = True\n\n        # width and height of the Rect used to place child widgets\n        self._var_w = Variable(\"w_rect\")\n        self._var_h = Variable(\"h_rect\")\n\n        self._width_grid = None\n        self._height_grid = None\n\n        # self._height_stay = None\n        # self._width_stay = None\n\n        Widget.__init__(self, **kwargs)",
  "def __getitem__(self, idxs):\n        \"\"\"Return an item or create it if the location is available.\"\"\"\n        if not isinstance(idxs, tuple):\n            idxs = (idxs,)\n        if len(idxs) == 1:\n            idxs = idxs + (slice(0, 1, None),)\n        elif len(idxs) != 2:\n            raise ValueError('Incorrect index: %s' % (idxs,))\n        lims = np.empty((2, 2), int)\n        for ii, idx in enumerate(idxs):\n            if isinstance(idx, int):\n                idx = slice(idx, idx + 1, None)\n            if not isinstance(idx, slice):\n                raise ValueError('indices must be slices or integers, not %s'\n                                 % (type(idx),))\n            if idx.step is not None and idx.step != 1:\n                raise ValueError('step must be one or None, not %s' % idx.step)\n            start = 0 if idx.start is None else idx.start\n            end = self.grid_size[ii] if idx.stop is None else idx.stop\n            lims[ii] = [start, end]\n        layout = self.layout_array\n        existing = layout[lims[0, 0]:lims[0, 1], lims[1, 0]:lims[1, 1]] + 1\n        if existing.any():\n            existing = set(list(existing.ravel()))\n            ii = list(existing)[0] - 1\n            if len(existing) != 1 or ((layout == ii).sum() !=\n                                      np.prod(np.diff(lims))):\n                raise ValueError('Cannot add widget (collision)')\n            return self._grid_widgets[ii][-1]\n        spans = np.diff(lims)[:, 0]\n        item = self.add_widget(self._default_class(),\n                               row=lims[0, 0], col=lims[1, 0],\n                               row_span=spans[0], col_span=spans[1])\n        return item",
  "def add_widget(self, widget=None, row=None, col=None, row_span=1,\n                   col_span=1, **kwargs):\n        \"\"\"Add a new widget to this grid.\n\n        This will cause other widgets in the grid to be resized to make room\n        for the new widget. Can be used to replace a widget as well.\n\n        Parameters\n        ----------\n        widget : Widget | None\n            The Widget to add. New widget is constructed if widget is None.\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            parameters sent to the new Widget that is constructed if\n            widget is None\n\n        Notes\n        -----\n        The widget's parent is automatically set to this grid, and all other\n        parent(s) are removed.\n        \"\"\"\n        if row is None:\n            row = self._next_cell[0]\n        if col is None:\n            col = self._next_cell[1]\n\n        if widget is None:\n            widget = Widget(**kwargs)\n        else:\n            if kwargs:\n                raise ValueError(\"cannot send kwargs if widget is given\")\n\n        _row = self._cells.setdefault(row, {})\n        _row[col] = widget\n        self._grid_widgets[self._n_added] = (row, col, row_span, col_span,\n                                             widget)\n        self._n_added += 1\n        widget.parent = self\n\n        self._next_cell = [row, col+col_span]\n\n        widget._var_w = Variable(\"w-(row: %s | col: %s)\" % (row, col))\n        widget._var_h = Variable(\"h-(row: %s | col: %s)\" % (row, col))\n\n        # update stretch based on colspan/rowspan\n        # usually, if you make something consume more grids or columns,\n        # you also want it to actually *take it up*, ratio wise.\n        # otherwise, it will never *use* the extra rows and columns,\n        # thereby collapsing the extras to 0.\n        stretch = list(widget.stretch)\n        stretch[0] = col_span if stretch[0] is None else stretch[0]\n        stretch[1] = row_span if stretch[1] is None else stretch[1]\n        widget.stretch = stretch\n\n        self._need_solver_recreate = True\n\n        return widget",
  "def remove_widget(self, widget):\n        \"\"\"Remove a widget from this grid.\n\n        Parameters\n        ----------\n        widget : Widget\n            The Widget to remove\n        \"\"\"\n        self._grid_widgets = dict((key, val)\n                                  for (key, val) in self._grid_widgets.items()\n                                  if val[-1] != widget)\n\n        self._need_solver_recreate = True",
  "def resize_widget(self, widget, row_span, col_span):\n        \"\"\"Resize a widget in the grid to new dimensions.\n\n        Parameters\n        ----------\n        widget : Widget\n            The widget to resize\n        row_span : int\n            The number of rows to be occupied by this widget.\n        col_span : int\n            The number of columns to be occupied by this widget.\n        \"\"\"\n        row = None\n        col = None\n\n        for (r, c, _rspan, _cspan, w) in self._grid_widgets.values():\n            if w == widget:\n                row = r\n                col = c\n\n                break\n\n        if row is None or col is None:\n            raise ValueError(\"%s not found in grid\" % widget)\n\n        self.remove_widget(widget)\n        self.add_widget(widget, row, col, row_span, col_span)\n        self._need_solver_recreate = True",
  "def _prepare_draw(self, view):\n        self._update_child_widget_dim()",
  "def add_grid(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to the new `Grid`.\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(**kwargs)\n        return self.add_widget(grid, row, col, row_span, col_span)",
  "def add_view(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to `ViewBox`.\n        \"\"\"\n        view = ViewBox(**kwargs)\n        return self.add_widget(view, row, col, row_span, col_span)",
  "def next_row(self):\n        self._next_cell = [self._next_cell[0] + 1, 0]",
  "def grid_size(self):\n        rvals = [widget[0]+widget[2] for widget in self._grid_widgets.values()]\n        cvals = [widget[1]+widget[3] for widget in self._grid_widgets.values()]\n        return max(rvals + [0]), max(cvals + [0])",
  "def layout_array(self):\n        locs = -1 * np.ones(self.grid_size, int)\n        for key in self._grid_widgets.keys():\n            r, c, rs, cs = self._grid_widgets[key][:4]\n            locs[r:r + rs, c:c + cs] = key\n        return locs",
  "def __repr__(self):\n        return (('<Grid at %s:\\n' % hex(id(self))) +\n                str(self.layout_array + 1) + '>')",
  "def _add_total_width_constraints(solver, width_grid, _var_w):\n        for ws in width_grid:\n            width_expr = ws[0]\n            for w in ws[1:]:\n                width_expr += w\n            solver.addConstraint(width_expr == _var_w)",
  "def _add_total_height_constraints(solver, height_grid, _var_h):\n        for hs in height_grid:\n            height_expr = hs[0]\n            for h in hs[1:]:\n                height_expr += h\n            solver.addConstraint(height_expr == _var_h)",
  "def _add_gridding_width_constraints(solver, width_grid):\n        # access widths of one \"y\", different x\n        for ws in width_grid.T:\n            for w in ws[1:]:\n                solver.addConstraint(ws[0] == w)",
  "def _add_gridding_height_constraints(solver, height_grid):\n        # access heights of one \"y\"\n        for hs in height_grid.T:\n            for h in hs[1:]:\n                solver.addConstraint(hs[0] == h)",
  "def _add_stretch_constraints(solver, width_grid, height_grid,\n                                 grid_widgets, widget_grid):\n        xmax = len(height_grid)\n        ymax = len(width_grid)\n\n        stretch_widths = [[] for _ in range(0, ymax)]\n        stretch_heights = [[] for _ in range(0, xmax)]\n\n        for (y, x, ys, xs, widget) in grid_widgets.values():\n            for ws in width_grid[y:y+ys]:\n                total_w = np.sum(ws[x:x+xs])\n\n                for sw in stretch_widths[y:y+ys]:\n                    sw.append((total_w, widget.stretch[0]))\n\n            for hs in height_grid[x:x+xs]:\n                total_h = np.sum(hs[y:y+ys])\n\n                for sh in stretch_heights[x:x+xs]:\n                    sh.append((total_h, widget.stretch[1]))\n\n        for (x, xs) in enumerate(widget_grid):\n            for(y, widget) in enumerate(xs):\n                if widget is None:\n                    stretch_widths[y].append((width_grid[y][x], 1))\n                    stretch_heights[x].append((height_grid[x][y], 1))\n\n        for sws in stretch_widths:\n            if len(sws) <= 1:\n                continue\n\n            comparator = sws[0][0] / sws[0][1]\n\n            for (stretch_term, stretch_val) in sws[1:]:\n                solver.addConstraint((comparator == stretch_term/stretch_val) |\n                                     'weak')\n\n        for sws in stretch_heights:\n            if len(sws) <= 1:\n                continue\n\n            comparator = sws[0][0] / sws[0][1]\n\n            for (stretch_term, stretch_val) in sws[1:]:\n                solver.addConstraint((comparator == stretch_term/stretch_val) |\n                                     'weak')",
  "def _add_widget_dim_constraints(solver, width_grid, height_grid,\n                                    total_var_w, total_var_h, grid_widgets):\n        assert(total_var_w is not None)\n        assert(total_var_h is not None)\n\n        for ws in width_grid:\n            for w in ws:\n                solver.addConstraint(w >= 0,)\n\n        for hs in height_grid:\n            for h in hs:\n                solver.addConstraint(h >= 0)\n\n        for (_, val) in grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n\n            for ws in width_grid[y:y+ys]:\n                total_w = np.sum(ws[x:x+xs])\n                # assert(total_w is not None)\n                solver.addConstraint(total_w >= widget.width_min)\n\n                if widget.width_max is not None:\n                    solver.addConstraint(total_w <= widget.width_max)\n                else:\n                    solver.addConstraint(total_w <= total_var_w)\n\n            for hs in height_grid[x:x+xs]:\n                total_h = np.sum(hs[y:y+ys])\n                solver.addConstraint(total_h >= widget.height_min)\n\n                if widget.height_max is not None:\n                    solver.addConstraint(total_h <= widget.height_max)\n                else:\n                    solver.addConstraint(total_h <= total_var_h)",
  "def _recreate_solver(self):\n        self._solver.reset()\n        self._var_w = Variable(\"w_rect\")\n        self._var_h = Variable(\"h_rect\")\n        self._solver.addEditVariable(self._var_w, 'strong')\n        self._solver.addEditVariable(self._var_h, 'strong')\n\n        rect = self.rect.padded(self.padding + self.margin)\n        ymax, xmax = self.grid_size\n\n        self._solver.suggestValue(self._var_w, rect.width)\n        self._solver.suggestValue(self._var_h, rect.height)\n\n        self._solver.addConstraint(self._var_w >= 0)\n        self._solver.addConstraint(self._var_h >= 0)\n\n        # self._height_stay = None\n        # self._width_stay = None\n\n        # add widths\n        self._width_grid = np.array([[Variable(\"width(x: %s, y: %s)\" % (x, y))\n                                      for x in range(0, xmax)]\n                                     for y in range(0, ymax)])\n\n        # add heights\n        self._height_grid = np.array([[Variable(\"height(x: %s, y: %s\" % (x, y))\n                                       for y in range(0, ymax)]\n                                      for x in range(0, xmax)])\n\n        # setup stretch\n        stretch_grid = np.zeros(shape=(xmax, ymax, 2), dtype=float)\n        stretch_grid.fill(1)\n\n        for (_, val) in self._grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n            stretch_grid[x:x+xs, y:y+ys] = widget.stretch\n\n        # even though these are REQUIRED, these should never fail\n        # since they're added first, and thus the slack will \"simply work\".\n        Grid._add_total_width_constraints(self._solver,\n                                          self._width_grid, self._var_w)\n        Grid._add_total_height_constraints(self._solver,\n                                           self._height_grid, self._var_h)\n\n        try:\n            # these are REQUIRED constraints for width and height.\n            # These are the constraints which can fail if\n            # the corresponding dimension of the widget cannot be fit in the\n            # grid.\n            Grid._add_gridding_width_constraints(self._solver,\n                                                 self._width_grid)\n            Grid._add_gridding_height_constraints(self._solver,\n                                                  self._height_grid)\n        except UnsatisfiableConstraint:\n            self._need_solver_recreate = True\n\n        # these are WEAK constraints, so these constraints will never fail\n        # with a RequiredFailure.\n        Grid._add_stretch_constraints(self._solver,\n                                      self._width_grid,\n                                      self._height_grid,\n                                      self._grid_widgets,\n                                      self._widget_grid)\n\n        Grid._add_widget_dim_constraints(self._solver,\n                                         self._width_grid,\n                                         self._height_grid,\n                                         self._var_w,\n                                         self._var_h,\n                                         self._grid_widgets)\n\n        self._solver.updateVariables()",
  "def _update_child_widget_dim(self):\n        # think in terms of (x, y). (row, col) makes code harder to read\n        ymax, xmax = self.grid_size\n        if ymax <= 0 or xmax <= 0:\n            return\n\n        rect = self.rect  # .padded(self.padding + self.margin)\n        if rect.width <= 0 or rect.height <= 0:\n            return\n        if self._need_solver_recreate:\n            self._need_solver_recreate = False\n            self._recreate_solver()\n\n        # we only need to remove and add the height and width constraints of\n        # the solver if they are not the same as the current value\n        h_changed = abs(rect.height - self._var_h.value()) > 1e-4\n        w_changed = abs(rect.width - self._var_w.value()) > 1e-4\n        if h_changed:\n            self._solver.suggestValue(self._var_h, rect.height)\n\n        if w_changed:\n            self._solver.suggestValue(self._var_w, rect.width)\n        if h_changed or w_changed:\n            self._solver.updateVariables()\n\n        value_vectorized = np.vectorize(lambda x: x.value())\n\n        for (_, val) in self._grid_widgets.items():\n            (row, col, rspan, cspan, widget) = val\n\n            width = np.sum(value_vectorized(\n                           self._width_grid[row][col:col+cspan]))\n            height = np.sum(value_vectorized(\n                            self._height_grid[col][row:row+rspan]))\n            if col == 0:\n                x = 0\n            else:\n                x = np.sum(value_vectorized(self._width_grid[row][0:col]))\n\n            if row == 0:\n                y = 0\n            else:\n                y = np.sum(value_vectorized(self._height_grid[col][0:row]))\n\n            if isinstance(widget, ViewBox):\n                widget.rect = Rect(x, y, width, height)\n            else:\n                widget.size = (width, height)\n                widget.pos = (x, y)",
  "def _widget_grid(self):\n        ymax, xmax = self.grid_size\n        widget_grid = np.array([[None for _ in range(0, ymax)]\n                                for _ in range(0, xmax)])\n        for (_, val) in self._grid_widgets.items():\n            (y, x, ys, xs, widget) = val\n            widget_grid[x:x+xs, y:y+ys] = widget\n\n        return widget_grid",
  "class PerspectiveCamera(BaseCamera):\n    \"\"\"Base class for 3D cameras supporting orthographic and\n    perspective projections.\n\n    Parameters\n    ----------\n    fov : float\n        Field of view. Default 60.0.\n    scale_factor : scalar\n        A measure for the scale/range of the scene that the camera\n        should show. The exact meaning differs per camera type.\n    **kwargs : dict\n        Keyword arguments to pass to `BaseCamera`.\n    \"\"\"\n\n    _state_props = ('scale_factor', 'center', 'fov')\n\n    def __init__(self, fov=60.0, scale_factor=None, center=None, **kwargs):\n        super(PerspectiveCamera, self).__init__(**kwargs)\n        # Camera transform\n        self.transform = MatrixTransform()\n\n        # Set camera attributes\n        self.fov = fov\n        self._scale_factor = None\n        self._center = None\n\n        # Only set if they are given. They're set during _set_range if None\n        if scale_factor is not None:\n            self.scale_factor = scale_factor\n        if center is not None:\n            self.center = center\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox received a mouse event; update transform\n        accordingly.\n        Default implementation adjusts scale factor when scolling.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        BaseCamera.viewbox_mouse_event(self, event)\n        if event.type == 'mouse_wheel':\n            s = 1.1 ** - event.delta[1]\n            self._scale_factor *= s\n            if self._distance is not None:\n                self._distance *= s\n            self.view_changed()\n\n    @property\n    def scale_factor(self):\n        \"\"\"The measure for the scale or range that the camera should cover\n\n        For the PanZoomCamera and TurnTableCamera this translates to\n        zooming: set to smaller values to zoom in.\n        \"\"\"\n        return self._scale_factor\n\n    @scale_factor.setter\n    def scale_factor(self, value):\n        self._scale_factor = abs(float(value))\n        self.view_changed()\n\n    @property\n    def near_clip_distance(self):\n        \"\"\"The distance of the near clipping plane from the camera's position.\"\"\"\n        return self._near_clip_distance\n\n    def _set_range(self, init):\n        \"\"\"Reset the camera view using the known limits.\"\"\"\n        if init and (self._scale_factor is not None):\n            return  # We don't have to set our scale factor\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        if (w == 0) or (h == 0):\n            return\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Convert to screen coordinates. In screen x, only x and y have effect.\n        # In screen y, all three dimensions have effect. The idea of the lines\n        # below is to calculate the range on screen when that will fit the\n        # data under any rotation.\n        rxs = (rx**2 + ry**2)**0.5\n        rys = (rx**2 + ry**2 + rz**2)**0.5\n\n        self.scale_factor = max(rxs, rys) * 1.04  # 4% extra space\n\n    def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize handler to update the transform\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.view_changed()\n\n    def _update_transform(self, event=None):\n        # Do we have a viewbox\n        if self._viewbox is None:\n            return\n\n        # Calculate viewing range for x and y\n        fx = fy = self._scale_factor\n\n        # Correct for window size\n        w, h = self._viewbox.size\n\n        if (w == 0) or (h == 0):\n            return\n\n        if w / h > 1:\n            fx *= w / h\n        else:\n            fy *= h / w\n\n        self._update_projection_transform(fx, fy)\n\n        # assemble complete transform mapping to viewbox bounds\n        unit = [[-1, 1], [1, -1]]\n        vrect = [[0, 0], self._viewbox.size]\n        self._viewbox_tr.set_mapping(unit, vrect)\n        transforms = [n.transform for n in\n                      self._viewbox.scene.node_path_to_child(self)[1:]]\n        camera_tr = self._transform_cache.get(transforms).inverse\n        full_tr = self._transform_cache.get([self._viewbox_tr,\n                                             self._projection,\n                                             camera_tr])\n        self._transform_cache.roll()\n        self._set_scene_transform(full_tr)\n\n    def _update_projection_transform(self, fx, fy):\n        d = self.depth_value\n        fov = max(0.01, self._fov)\n        dist = fy / (2 * math.tan(math.radians(fov)/2))\n        val = math.sqrt(d)\n        self._projection.set_perspective(fov, fx/fy, dist/val, dist*val)",
  "class Base3DRotationCamera(PerspectiveCamera):\n    \"\"\"Base class for TurntableCamera and ArcballCamera\"\"\"\n\n    def __init__(self, fov=0.0, **kwargs):\n        super(Base3DRotationCamera, self).__init__(fov=fov, **kwargs)\n        self._actual_distance = 0.0\n        self._event_value = None\n\n    @property\n    def distance(self):\n        \"\"\"The user-set distance. If None (default), the distance is\n        internally calculated from the scale factor and fov.\n        \"\"\"\n        return self._distance\n\n    @distance.setter\n    def distance(self, distance):\n        if distance is None:\n            self._distance = None\n        else:\n            self._distance = float(distance)\n        self.view_changed()\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"\n        The viewbox received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_release':\n            self._event_value = None  # Reset\n        elif event.type == 'mouse_press':\n            event.handled = True\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n            if 1 in event.buttons and 2 in event.buttons:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n            d = p2 - p1\n\n            if 1 in event.buttons and not modifiers:\n                # Rotate\n                self._update_rotation(event)\n\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                if self._event_value is None:\n                    self._event_value = (self._scale_factor, self._distance)\n                zoomy = (1 + self.zoom_factor) ** d[1]\n\n                self.scale_factor = self._event_value[0] * zoomy\n                # Modify distance if its given\n                if self._distance is not None:\n                    self._distance = self._event_value[1] * zoomy\n                self.view_changed()\n\n            elif 1 in event.buttons and keys.SHIFT in modifiers:\n                # Translate\n                norm = np.mean(self._viewbox.size)\n                if self._event_value is None or len(self._event_value) == 2:\n                    self._event_value = self.center\n                dist = (p1 - p2) / norm * self._scale_factor\n                dist[1] *= -1\n                # Black magic part 1: turn 2D into 3D translations\n                dx, dy, dz = self._dist_to_trans(dist)\n                # Black magic part 2: take up-vector and flipping into account\n                ff = self._flip_factors\n                up, forward, right = self._get_dim_vectors()\n                dx, dy, dz = right * dx + forward * dy + up * dz\n                dx, dy, dz = ff[0] * dx, ff[1] * dy, dz * ff[2]\n                c = self._event_value\n                self.center = c[0] + dx, c[1] + dy, c[2] + dz\n\n            elif 2 in event.buttons and keys.SHIFT in modifiers:\n                # Change fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                fov = self._event_value - d[1] / 5.0\n                self.fov = min(180.0, max(0.0, fov))\n\n    def _update_camera_pos(self):\n        \"\"\"Set the camera position and orientation\"\"\"\n        # transform will be updated several times; do not update camera\n        # transform until we are done.\n        ch_em = self.events.transform_change\n        with ch_em.blocker(self._update_transform):\n            up, forward, right = self._get_dim_vectors()\n\n            # Create mapping so correct dim is up\n            pp1 = np.array([(0, 0, 0), (0, 0, -1), (1, 0, 0), (0, 1, 0)])\n            pp2 = np.array([(0, 0, 0), forward, right, up])\n            pos = -self._actual_distance * forward\n            scale = [1.0/a for a in self._flip_factors]\n\n            self.transform.matrix = np.linalg.multi_dot((\n                transforms.affine_map(pp1, pp2).T,\n                transforms.translate(pos),\n                self._get_rotation_tr(),\n                transforms.scale(scale),\n                transforms.translate(self.center)\n            ))\n\n    def _get_dim_vectors(self):\n        # Specify up and forward vector\n        M = {'+z': [(0, 0, +1), (0, 1, 0)],\n             '-z': [(0, 0, -1), (0, 1, 0)],\n             '+y': [(0, +1, 0), (1, 0, 0)],\n             '-y': [(0, -1, 0), (1, 0, 0)],\n             '+x': [(+1, 0, 0), (0, 0, 1)],\n             '-x': [(-1, 0, 0), (0, 0, 1)],\n             }\n        up, forward = M[self.up]\n        right = np.cross(forward, up)\n        return np.array(up), np.array(forward), right\n\n    def _update_projection_transform(self, fx, fy):\n        d = self.depth_value\n        if self._fov == 0:\n            self._projection.set_ortho(-0.5*fx, 0.5*fx, -0.5*fy, 0.5*fy, -d, d)\n            self._actual_distance = self._distance or 0.0\n        else:\n            # Figure distance to center in order to have correct FoV and fy.\n            # Use that auto-distance, or the given distance (if not None).\n            fov = max(0.01, self._fov)\n            dist = fy / (2 * math.tan(math.radians(fov)/2))\n            self._actual_distance = dist = self._distance or dist\n            val = math.sqrt(d*10)\n            self._projection.set_perspective(fov, fx/fy, dist/val, dist*val)\n        # Update camera pos, which will use our calculated _distance to offset\n        # the camera\n        self._update_camera_pos()\n\n    def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        raise NotImplementedError\n\n    def _rotate_tr(self):\n        \"\"\"Rotate the transformation matrix based on camera parameters\"\"\"\n        raise NotImplementedError\n\n    def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        raise NotImplementedError",
  "def __init__(self, fov=60.0, scale_factor=None, center=None, **kwargs):\n        super(PerspectiveCamera, self).__init__(**kwargs)\n        # Camera transform\n        self.transform = MatrixTransform()\n\n        # Set camera attributes\n        self.fov = fov\n        self._scale_factor = None\n        self._center = None\n\n        # Only set if they are given. They're set during _set_range if None\n        if scale_factor is not None:\n            self.scale_factor = scale_factor\n        if center is not None:\n            self.center = center",
  "def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox received a mouse event; update transform\n        accordingly.\n        Default implementation adjusts scale factor when scolling.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        BaseCamera.viewbox_mouse_event(self, event)\n        if event.type == 'mouse_wheel':\n            s = 1.1 ** - event.delta[1]\n            self._scale_factor *= s\n            if self._distance is not None:\n                self._distance *= s\n            self.view_changed()",
  "def scale_factor(self):\n        \"\"\"The measure for the scale or range that the camera should cover\n\n        For the PanZoomCamera and TurnTableCamera this translates to\n        zooming: set to smaller values to zoom in.\n        \"\"\"\n        return self._scale_factor",
  "def scale_factor(self, value):\n        self._scale_factor = abs(float(value))\n        self.view_changed()",
  "def near_clip_distance(self):\n        \"\"\"The distance of the near clipping plane from the camera's position.\"\"\"\n        return self._near_clip_distance",
  "def _set_range(self, init):\n        \"\"\"Reset the camera view using the known limits.\"\"\"\n        if init and (self._scale_factor is not None):\n            return  # We don't have to set our scale factor\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        if (w == 0) or (h == 0):\n            return\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Convert to screen coordinates. In screen x, only x and y have effect.\n        # In screen y, all three dimensions have effect. The idea of the lines\n        # below is to calculate the range on screen when that will fit the\n        # data under any rotation.\n        rxs = (rx**2 + ry**2)**0.5\n        rys = (rx**2 + ry**2 + rz**2)**0.5\n\n        self.scale_factor = max(rxs, rys) * 1.04",
  "def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize handler to update the transform\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.view_changed()",
  "def _update_transform(self, event=None):\n        # Do we have a viewbox\n        if self._viewbox is None:\n            return\n\n        # Calculate viewing range for x and y\n        fx = fy = self._scale_factor\n\n        # Correct for window size\n        w, h = self._viewbox.size\n\n        if (w == 0) or (h == 0):\n            return\n\n        if w / h > 1:\n            fx *= w / h\n        else:\n            fy *= h / w\n\n        self._update_projection_transform(fx, fy)\n\n        # assemble complete transform mapping to viewbox bounds\n        unit = [[-1, 1], [1, -1]]\n        vrect = [[0, 0], self._viewbox.size]\n        self._viewbox_tr.set_mapping(unit, vrect)\n        transforms = [n.transform for n in\n                      self._viewbox.scene.node_path_to_child(self)[1:]]\n        camera_tr = self._transform_cache.get(transforms).inverse\n        full_tr = self._transform_cache.get([self._viewbox_tr,\n                                             self._projection,\n                                             camera_tr])\n        self._transform_cache.roll()\n        self._set_scene_transform(full_tr)",
  "def _update_projection_transform(self, fx, fy):\n        d = self.depth_value\n        fov = max(0.01, self._fov)\n        dist = fy / (2 * math.tan(math.radians(fov)/2))\n        val = math.sqrt(d)\n        self._projection.set_perspective(fov, fx/fy, dist/val, dist*val)",
  "def __init__(self, fov=0.0, **kwargs):\n        super(Base3DRotationCamera, self).__init__(fov=fov, **kwargs)\n        self._actual_distance = 0.0\n        self._event_value = None",
  "def distance(self):\n        \"\"\"The user-set distance. If None (default), the distance is\n        internally calculated from the scale factor and fov.\n        \"\"\"\n        return self._distance",
  "def distance(self, distance):\n        if distance is None:\n            self._distance = None\n        else:\n            self._distance = float(distance)\n        self.view_changed()",
  "def viewbox_mouse_event(self, event):\n        \"\"\"\n        The viewbox received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_release':\n            self._event_value = None  # Reset\n        elif event.type == 'mouse_press':\n            event.handled = True\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n            if 1 in event.buttons and 2 in event.buttons:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n            d = p2 - p1\n\n            if 1 in event.buttons and not modifiers:\n                # Rotate\n                self._update_rotation(event)\n\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                if self._event_value is None:\n                    self._event_value = (self._scale_factor, self._distance)\n                zoomy = (1 + self.zoom_factor) ** d[1]\n\n                self.scale_factor = self._event_value[0] * zoomy\n                # Modify distance if its given\n                if self._distance is not None:\n                    self._distance = self._event_value[1] * zoomy\n                self.view_changed()\n\n            elif 1 in event.buttons and keys.SHIFT in modifiers:\n                # Translate\n                norm = np.mean(self._viewbox.size)\n                if self._event_value is None or len(self._event_value) == 2:\n                    self._event_value = self.center\n                dist = (p1 - p2) / norm * self._scale_factor\n                dist[1] *= -1\n                # Black magic part 1: turn 2D into 3D translations\n                dx, dy, dz = self._dist_to_trans(dist)\n                # Black magic part 2: take up-vector and flipping into account\n                ff = self._flip_factors\n                up, forward, right = self._get_dim_vectors()\n                dx, dy, dz = right * dx + forward * dy + up * dz\n                dx, dy, dz = ff[0] * dx, ff[1] * dy, dz * ff[2]\n                c = self._event_value\n                self.center = c[0] + dx, c[1] + dy, c[2] + dz\n\n            elif 2 in event.buttons and keys.SHIFT in modifiers:\n                # Change fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                fov = self._event_value - d[1] / 5.0\n                self.fov = min(180.0, max(0.0, fov))",
  "def _update_camera_pos(self):\n        \"\"\"Set the camera position and orientation\"\"\"\n        # transform will be updated several times; do not update camera\n        # transform until we are done.\n        ch_em = self.events.transform_change\n        with ch_em.blocker(self._update_transform):\n            up, forward, right = self._get_dim_vectors()\n\n            # Create mapping so correct dim is up\n            pp1 = np.array([(0, 0, 0), (0, 0, -1), (1, 0, 0), (0, 1, 0)])\n            pp2 = np.array([(0, 0, 0), forward, right, up])\n            pos = -self._actual_distance * forward\n            scale = [1.0/a for a in self._flip_factors]\n\n            self.transform.matrix = np.linalg.multi_dot((\n                transforms.affine_map(pp1, pp2).T,\n                transforms.translate(pos),\n                self._get_rotation_tr(),\n                transforms.scale(scale),\n                transforms.translate(self.center)\n            ))",
  "def _get_dim_vectors(self):\n        # Specify up and forward vector\n        M = {'+z': [(0, 0, +1), (0, 1, 0)],\n             '-z': [(0, 0, -1), (0, 1, 0)],\n             '+y': [(0, +1, 0), (1, 0, 0)],\n             '-y': [(0, -1, 0), (1, 0, 0)],\n             '+x': [(+1, 0, 0), (0, 0, 1)],\n             '-x': [(-1, 0, 0), (0, 0, 1)],\n             }\n        up, forward = M[self.up]\n        right = np.cross(forward, up)\n        return np.array(up), np.array(forward), right",
  "def _update_projection_transform(self, fx, fy):\n        d = self.depth_value\n        if self._fov == 0:\n            self._projection.set_ortho(-0.5*fx, 0.5*fx, -0.5*fy, 0.5*fy, -d, d)\n            self._actual_distance = self._distance or 0.0\n        else:\n            # Figure distance to center in order to have correct FoV and fy.\n            # Use that auto-distance, or the given distance (if not None).\n            fov = max(0.01, self._fov)\n            dist = fy / (2 * math.tan(math.radians(fov)/2))\n            self._actual_distance = dist = self._distance or dist\n            val = math.sqrt(d*10)\n            self._projection.set_perspective(fov, fx/fy, dist/val, dist*val)\n        # Update camera pos, which will use our calculated _distance to offset\n        # the camera\n        self._update_camera_pos()",
  "def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        raise NotImplementedError",
  "def _rotate_tr(self):\n        \"\"\"Rotate the transformation matrix based on camera parameters\"\"\"\n        raise NotImplementedError",
  "def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        raise NotImplementedError",
  "def make_camera(cam_type, *args, **kwargs):\n    \"\"\"Factory function for creating new cameras using a string name.\n\n    Parameters\n    ----------\n    cam_type : str\n        May be one of:\n\n            * 'panzoom' : Creates :class:`PanZoomCamera`\n            * 'turntable' : Creates :class:`TurntableCamera`\n            * None : Creates :class:`Camera`\n\n    Notes\n    -----\n    All extra arguments are passed to the __init__ method of the selected\n    Camera class.\n    \"\"\"\n    cam_types = {None: BaseCamera}\n    for camType in (BaseCamera, PanZoomCamera, PerspectiveCamera,\n                    TurntableCamera, FlyCamera, ArcballCamera):\n        cam_types[camType.__name__[:-6].lower()] = camType\n\n    try:\n        return cam_types[cam_type](*args, **kwargs)\n    except KeyError:\n        raise KeyError('Unknown camera type \"%s\". Options are: %s' %\n                       (cam_type, cam_types.keys()))",
  "class FlyCamera(PerspectiveCamera):\n    \"\"\"The fly camera provides a way to explore 3D data using an\n    interaction style that resembles a flight simulator.\n\n    For this camera, the ``scale_factor`` indicates the speed of the\n    camera in units per second, and the ``center`` indicates the\n    position of the camera.\n\n    Parameters\n    ----------\n    fov : float\n        Field of view. Default 60.0.\n    rotation : float | None\n        Rotation to use.\n    **kwargs : dict\n        Keyword arguments to pass to `BaseCamera`.\n\n    Notes\n    -----\n    Interacting with this camera might need a bit of practice.\n    The reaction to key presses can be customized by modifying the\n    keymap property.\n\n    Moving:\n\n      * arrow keys, or WASD to move forward, backward, left and right\n      * F and C keys move up and down\n      * Space bar to brake\n\n    Viewing:\n\n      * Use the mouse while holding down LMB to control the pitch and yaw.\n      * Alternatively, the pitch and yaw can be changed using the keys\n        IKJL\n      * The camera auto-rotates to make the bottom point down, manual\n        rolling can be performed using Q and E.\n\n    \"\"\"\n\n    # Using _rotation1 and _rotation2 for camera states instead of _rotation\n    _state_props = PerspectiveCamera._state_props + ('rotation1', 'rotation2')\n\n    def __init__(self, fov=60, rotation=None, **kwargs):\n\n        # Motion speed vector\n        self._speed = np.zeros((6,), 'float64')\n        self._distance = None\n\n        # Acceleration and braking vectors, set from keyboard\n        self._brake = np.zeros((6,), 'uint8')  # bool-ish\n        self._acc = np.zeros((6,), 'float64')\n\n        # Init rotations\n        self._auto_roll = True  # Whether to roll to make Z up\n        self._rotation1 = Quaternion()  # The base rotation\n        self._rotation2 = Quaternion()  # The delta yaw and pitch rotation\n\n        PerspectiveCamera.__init__(self, fov=fov, **kwargs)\n\n        # Set camera attributes\n        self.rotation1 = rotation.normalize() if (rotation is not None) else Quaternion()\n\n        # To store data at start of interaction\n        self._event_value = None\n\n        # Whether the mouse-system wants a transform update\n        self._update_from_mouse = False\n\n        # Mapping that defines keys to thrusters\n        self._keymap = {\n            keys.UP: (+1, 1), keys.DOWN: (-1, 1),\n            keys.RIGHT: (+1, 2), keys.LEFT: (-1, 2),\n            #\n            'W': (+1, 1), 'S': (-1, 1),\n            'D': (+1, 2), 'A': (-1, 2),\n            'F': (+1, 3), 'C': (-1, 3),\n            #\n            'I': (+1, 4), 'K': (-1, 4),\n            'L': (+1, 5), 'J': (-1, 5),\n            'Q': (+1, 6), 'E': (-1, 6),\n            #\n            keys.SPACE: (0, 1, 2, 3),  # 0 means brake, apply to translation\n            # keys.ALT: (+5, 1),  # Turbo\n        }\n\n        # Timer. Each tick we calculate new speed and new position\n        self._timer = Timer(0.01, start=False, connect=self.on_timer)\n\n    @property\n    def rotation(self):\n        \"\"\"Get the full rotation. This rotation is composed of the\n        normal rotation plus the extra rotation due to the current\n        interaction of the user.\n        \"\"\"\n        rotation = self._rotation2 * self._rotation1\n        return rotation.normalize()\n\n    @rotation.setter\n    def rotation(self, value):\n        print(\"rotation.setter called, use rotation1.setter instead\")\n\n    @property\n    def rotation1(self):\n        \"\"\"rotation1 records confirmed camera rotation\"\"\"\n        return self._rotation1\n\n    @rotation1.setter\n    def rotation1(self, value):\n        assert isinstance(value, Quaternion)\n        self._rotation1 = value.normalize()\n\n    @property\n    def rotation2(self):\n        \"\"\"rotation2 records on going camera rotation.\"\"\"\n        return self._rotation2\n\n    @rotation2.setter\n    def rotation2(self, value):\n        assert isinstance(value, Quaternion)\n        self._rotation2 = value.normalize()\n\n    @property\n    def auto_roll(self):\n        \"\"\"Whether to rotate the camera automaticall to try and attempt\n        to keep Z up.\n        \"\"\"\n        return self._auto_roll\n\n    @auto_roll.setter\n    def auto_roll(self, value):\n        self._auto_roll = bool(value)\n\n    @property\n    def keymap(self):\n        \"\"\"A dictionary that maps keys to thruster directions\n\n        The keys in this dictionary are vispy key descriptions (from\n        vispy.keys) or characters that represent keys. These are matched\n        to the \"key\" attribute of key-press and key-release events.\n\n        The values are tuples, in which the first element specifies the\n        magnitude of the acceleration, using negative values for\n        \"backward\" thrust. A value of zero means to brake. The remaining\n        elements specify the dimension to which the acceleration should\n        be applied. These are 1, 2, 3 for forward/backward, left/right,\n        up/down, and 4, 5, 6 for pitch, yaw, roll.\n        \"\"\"\n        return self._keymap\n\n    def _set_range(self, init):\n        \"\"\"Reset the view.\"\"\"\n        # PerspectiveCamera._set_range(self, init)\n        # Stop moving\n        self._speed *= 0.0\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Do not convert to screen coordinates. This camera does not need\n        # to fit everything on screen, but we need to estimate the scale\n        # of the data in the scene.\n\n        # Set scale, depending on data range. Initial speed is such that\n        # the scene can be traversed in about three seconds.\n        self._scale_factor = max(rx, ry, rz) / 3.0\n\n        # Set initial position to a corner of the scene\n        margin = np.mean([rx, ry, rz]) * 0.1\n        self._center = x1 - margin, y1 - margin, z1 + margin\n\n        # Determine initial view direction based on flip axis\n        yaw = 45 * self._flip_factors[0]\n        pitch = -90 - 20 * self._flip_factors[2]\n        if self._flip_factors[1] < 0:\n            yaw += 90 * np.sign(self._flip_factors[0])\n\n        # Set orientation\n        q1 = Quaternion.create_from_axis_angle(pitch*math.pi/180, 1, 0, 0)\n        q2 = Quaternion.create_from_axis_angle(0*math.pi/180, 0, 1, 0)\n        q3 = Quaternion.create_from_axis_angle(yaw*math.pi/180, 0, 0, 1)\n        #\n        self._rotation1 = (q1 * q2 * q3).normalize()\n        self._rotation2 = Quaternion()\n\n        # Update\n        self.view_changed()\n\n    def _get_directions(self):\n\n        # Get reference points in reference coordinates\n        # p0 = Point(0,0,0)\n        pf = (0, 0, -1)  # front\n        pr = (1, 0, 0)  # right\n        pl = (-1, 0, 0)  # left\n        pu = (0, 1, 0)  # up\n\n        # Get total rotation\n        rotation = self.rotation.inverse()\n\n        # Transform to real coordinates\n        pf = rotation.rotate_point(pf)\n        pr = rotation.rotate_point(pr)\n        pl = rotation.rotate_point(pl)\n        pu = rotation.rotate_point(pu)\n\n        def _normalize(p):\n            L = sum(x**2 for x in p) ** 0.5\n            return np.array(p, 'float64') / L\n\n        pf = _normalize(pf)\n        pr = _normalize(pr)\n        pl = _normalize(pl)\n        pu = _normalize(pu)\n\n        return pf, pr, pl, pu\n\n    def on_timer(self, event):\n        \"\"\"Timer event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        # Set relative speed and acceleration\n        rel_speed = event.dt\n        rel_acc = 0.1\n\n        # Get what's forward\n        pf, pr, pl, pu = self._get_directions()\n\n        # Increase speed through acceleration\n        # Note that self._speed is relative. We can balance rel_acc and\n        # rel_speed to get a nice smooth or direct control\n        self._speed += self._acc * rel_acc\n\n        # Reduce speed. Simulate resistance. Using brakes slows down faster.\n        # Note that the way that we reduce speed, allows for higher\n        # speeds if keys ar bound to higher acc values (i.e. turbo)\n        reduce = np.array([0.05, 0.05, 0.05, 0.1, 0.1, 0.1])\n        reduce[self._brake > 0] = 0.2\n        self._speed -= self._speed * reduce\n        if np.abs(self._speed).max() < 0.05:\n            self._speed *= 0.0\n\n        # --- Determine new position from translation speed\n\n        if self._speed[:3].any():\n\n            # Create speed vectors, use scale_factor as a reference\n            dv = np.array([1.0/d for d in self._flip_factors])\n            #\n            vf = pf * dv * rel_speed * self._scale_factor\n            vr = pr * dv * rel_speed * self._scale_factor\n            vu = pu * dv * rel_speed * self._scale_factor\n            direction = vf, vr, vu\n\n            # Set position\n            center_loc = np.array(self._center, dtype='float32')\n            center_loc += (self._speed[0] * direction[0] +\n                           self._speed[1] * direction[1] +\n                           self._speed[2] * direction[2])\n            self._center = tuple(center_loc)\n\n        # --- Determine new orientation from rotation speed\n\n        roll_angle = 0\n\n        # Calculate manual roll (from speed)\n        if self._speed[3:].any():\n            angleGain = np.array([1.0, 1.5, 1.0]) * 3 * math.pi / 180\n            angles = self._speed[3:] * angleGain\n\n            q1 = Quaternion.create_from_axis_angle(angles[0], -1, 0, 0)\n            q2 = Quaternion.create_from_axis_angle(angles[1], 0, 1, 0)\n            q3 = Quaternion.create_from_axis_angle(angles[2], 0, 0, -1)\n            q = q1 * q2 * q3\n            self._rotation1 = (q * self._rotation1).normalize()\n\n        # Calculate auto-roll\n        if self.auto_roll:\n            up = {'x': (1, 0, 0), 'y': (0, 1, 0), 'z': (0, 0, 1)}[self.up[1]]\n            up = np.array(up) * {'+': +1, '-': -1}[self.up[0]]\n\n            def angle(p1, p2):\n                return np.arccos(p1.dot(p2))\n            # au = angle(pu, (0, 0, 1))\n            ar = angle(pr, up)\n            al = angle(pl, up)\n            af = angle(pf, up)\n            # Roll angle that's off from being leveled (in unit strength)\n            roll_angle = math.sin(0.5*(al - ar))\n            # Correct for pitch\n            roll_angle *= abs(math.sin(af))  # abs(math.sin(au))\n            if abs(roll_angle) < 0.05:\n                roll_angle = 0\n            if roll_angle:\n                # Correct to soften the force at 90 degree angle\n                roll_angle = np.sign(roll_angle) * np.abs(roll_angle)**0.5\n                # Get correction for this iteration and apply\n                angle_correction = 1.0 * roll_angle * math.pi / 180\n                q = Quaternion.create_from_axis_angle(angle_correction,\n                                                      0, 0, 1)\n                self._rotation1 = (q * self._rotation1).normalize()\n\n        # Update\n        if self._speed.any() or roll_angle or self._update_from_mouse:\n            self._update_from_mouse = False\n            self.view_changed()\n\n    def viewbox_key_event(self, event):\n        \"\"\"The ViewBox key event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        PerspectiveCamera.viewbox_key_event(self, event)\n\n        if event.handled or not self.interactive:\n            return\n\n        # Ensure the timer runs\n        if not self._timer.running:\n            self._timer.start()\n\n        if event.key in self._keymap:\n            val_dims = self._keymap[event.key]\n            val = val_dims[0]\n            # Brake or accelarate?\n            if val == 0:\n                vec = self._brake\n                val = 1\n            else:\n                vec = self._acc\n            # Set\n            if event.type == 'key_release':\n                val = 0\n            for dim in val_dims[1:]:\n                factor = 1.0\n                vec[dim-1] = val * factor\n            event.handled = True\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.handled or not self.interactive:\n            return\n\n        if event.type == 'mouse_wheel':\n            if not event.mouse_event.modifiers:\n                # Move forward / backward\n                self._speed[0] += 0.5 * event.delta[1]\n            elif keys.SHIFT in event.mouse_event.modifiers:\n                # Speed\n                s = 1.1 ** - event.delta[1]\n                self.scale_factor /= s  # divide instead of multiply\n                print('scale factor: %1.1f units/s' % self.scale_factor)\n            return\n\n        if event.type == 'mouse_press':\n            event.handled = True\n\n        if event.type == 'mouse_release':\n            # Reset\n            self._event_value = None\n            # Apply rotation\n            self._rotation1 = (self._rotation2 * self._rotation1).normalize()\n            self._rotation2 = Quaternion()\n            event.handled = True\n        elif not self._timer.running:\n            # Ensure the timer runs\n            self._timer.start()\n\n        if event.type == 'mouse_move':\n\n            if event.press_event is None:\n                return\n            if not event.buttons:\n                return\n\n            # Prepare\n            modifiers = event.mouse_event.modifiers\n            pos1 = event.mouse_event.press_event.pos\n            pos2 = event.mouse_event.pos\n            w, h = self._viewbox.size\n\n            if 1 in event.buttons and not modifiers:\n                # rotate\n\n                # get normalized delta values\n                d_az = -float(pos2[0] - pos1[0]) / w\n                d_el = +float(pos2[1] - pos1[1]) / h\n                # Apply gain\n                d_az *= - 0.5 * math.pi  # * self._speed_rot\n                d_el *= + 0.5 * math.pi  # * self._speed_rot\n                # Create temporary quaternions\n                q_az = Quaternion.create_from_axis_angle(d_az, 0, 1, 0)\n                q_el = Quaternion.create_from_axis_angle(d_el, 1, 0, 0)\n\n                # Apply to global quaternion\n                self._rotation2 = (q_el.normalize() * q_az).normalize()\n                event.handled = True\n\n            elif 2 in event.buttons and keys.CONTROL in modifiers:\n                # zoom --> fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                p1 = np.array(event.press_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1c = event.map_to_canvas(p1)[:2]\n                p2c = event.map_to_canvas(p2)[:2]\n                d = p2c - p1c\n                fov = self._event_value * math.exp(-0.01*d[1])\n                self._fov = min(90.0, max(10, fov))\n                event.handled = True\n\n        # Make transform be updated on the next timer tick.\n        # By doing it at timer tick, we avoid shaky behavior\n        self._update_from_mouse = True\n\n    def _update_projection_transform(self, fx, fy):\n        PerspectiveCamera._update_projection_transform(self, fx, fy)\n\n        # Turn our internal quaternion representation into rotation\n        # of our transform\n\n        axis_angle = self.rotation.get_axis_angle()\n        angle = axis_angle[0] * 180 / math.pi\n\n        tr = self.transform\n        tr.reset()\n        #\n        tr.rotate(-angle, axis_angle[1:])\n        tr.scale([1.0/a for a in self._flip_factors])\n        tr.translate(self._center)",
  "def __init__(self, fov=60, rotation=None, **kwargs):\n\n        # Motion speed vector\n        self._speed = np.zeros((6,), 'float64')\n        self._distance = None\n\n        # Acceleration and braking vectors, set from keyboard\n        self._brake = np.zeros((6,), 'uint8')  # bool-ish\n        self._acc = np.zeros((6,), 'float64')\n\n        # Init rotations\n        self._auto_roll = True  # Whether to roll to make Z up\n        self._rotation1 = Quaternion()  # The base rotation\n        self._rotation2 = Quaternion()  # The delta yaw and pitch rotation\n\n        PerspectiveCamera.__init__(self, fov=fov, **kwargs)\n\n        # Set camera attributes\n        self.rotation1 = rotation.normalize() if (rotation is not None) else Quaternion()\n\n        # To store data at start of interaction\n        self._event_value = None\n\n        # Whether the mouse-system wants a transform update\n        self._update_from_mouse = False\n\n        # Mapping that defines keys to thrusters\n        self._keymap = {\n            keys.UP: (+1, 1), keys.DOWN: (-1, 1),\n            keys.RIGHT: (+1, 2), keys.LEFT: (-1, 2),\n            #\n            'W': (+1, 1), 'S': (-1, 1),\n            'D': (+1, 2), 'A': (-1, 2),\n            'F': (+1, 3), 'C': (-1, 3),\n            #\n            'I': (+1, 4), 'K': (-1, 4),\n            'L': (+1, 5), 'J': (-1, 5),\n            'Q': (+1, 6), 'E': (-1, 6),\n            #\n            keys.SPACE: (0, 1, 2, 3),  # 0 means brake, apply to translation\n            # keys.ALT: (+5, 1),  # Turbo\n        }\n\n        # Timer. Each tick we calculate new speed and new position\n        self._timer = Timer(0.01, start=False, connect=self.on_timer)",
  "def rotation(self):\n        \"\"\"Get the full rotation. This rotation is composed of the\n        normal rotation plus the extra rotation due to the current\n        interaction of the user.\n        \"\"\"\n        rotation = self._rotation2 * self._rotation1\n        return rotation.normalize()",
  "def rotation(self, value):\n        print(\"rotation.setter called, use rotation1.setter instead\")",
  "def rotation1(self):\n        \"\"\"rotation1 records confirmed camera rotation\"\"\"\n        return self._rotation1",
  "def rotation1(self, value):\n        assert isinstance(value, Quaternion)\n        self._rotation1 = value.normalize()",
  "def rotation2(self):\n        \"\"\"rotation2 records on going camera rotation.\"\"\"\n        return self._rotation2",
  "def rotation2(self, value):\n        assert isinstance(value, Quaternion)\n        self._rotation2 = value.normalize()",
  "def auto_roll(self):\n        \"\"\"Whether to rotate the camera automaticall to try and attempt\n        to keep Z up.\n        \"\"\"\n        return self._auto_roll",
  "def auto_roll(self, value):\n        self._auto_roll = bool(value)",
  "def keymap(self):\n        \"\"\"A dictionary that maps keys to thruster directions\n\n        The keys in this dictionary are vispy key descriptions (from\n        vispy.keys) or characters that represent keys. These are matched\n        to the \"key\" attribute of key-press and key-release events.\n\n        The values are tuples, in which the first element specifies the\n        magnitude of the acceleration, using negative values for\n        \"backward\" thrust. A value of zero means to brake. The remaining\n        elements specify the dimension to which the acceleration should\n        be applied. These are 1, 2, 3 for forward/backward, left/right,\n        up/down, and 4, 5, 6 for pitch, yaw, roll.\n        \"\"\"\n        return self._keymap",
  "def _set_range(self, init):\n        \"\"\"Reset the view.\"\"\"\n        # PerspectiveCamera._set_range(self, init)\n        # Stop moving\n        self._speed *= 0.0\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Do not convert to screen coordinates. This camera does not need\n        # to fit everything on screen, but we need to estimate the scale\n        # of the data in the scene.\n\n        # Set scale, depending on data range. Initial speed is such that\n        # the scene can be traversed in about three seconds.\n        self._scale_factor = max(rx, ry, rz) / 3.0\n\n        # Set initial position to a corner of the scene\n        margin = np.mean([rx, ry, rz]) * 0.1\n        self._center = x1 - margin, y1 - margin, z1 + margin\n\n        # Determine initial view direction based on flip axis\n        yaw = 45 * self._flip_factors[0]\n        pitch = -90 - 20 * self._flip_factors[2]\n        if self._flip_factors[1] < 0:\n            yaw += 90 * np.sign(self._flip_factors[0])\n\n        # Set orientation\n        q1 = Quaternion.create_from_axis_angle(pitch*math.pi/180, 1, 0, 0)\n        q2 = Quaternion.create_from_axis_angle(0*math.pi/180, 0, 1, 0)\n        q3 = Quaternion.create_from_axis_angle(yaw*math.pi/180, 0, 0, 1)\n        #\n        self._rotation1 = (q1 * q2 * q3).normalize()\n        self._rotation2 = Quaternion()\n\n        # Update\n        self.view_changed()",
  "def _get_directions(self):\n\n        # Get reference points in reference coordinates\n        # p0 = Point(0,0,0)\n        pf = (0, 0, -1)  # front\n        pr = (1, 0, 0)  # right\n        pl = (-1, 0, 0)  # left\n        pu = (0, 1, 0)  # up\n\n        # Get total rotation\n        rotation = self.rotation.inverse()\n\n        # Transform to real coordinates\n        pf = rotation.rotate_point(pf)\n        pr = rotation.rotate_point(pr)\n        pl = rotation.rotate_point(pl)\n        pu = rotation.rotate_point(pu)\n\n        def _normalize(p):\n            L = sum(x**2 for x in p) ** 0.5\n            return np.array(p, 'float64') / L\n\n        pf = _normalize(pf)\n        pr = _normalize(pr)\n        pl = _normalize(pl)\n        pu = _normalize(pu)\n\n        return pf, pr, pl, pu",
  "def on_timer(self, event):\n        \"\"\"Timer event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        # Set relative speed and acceleration\n        rel_speed = event.dt\n        rel_acc = 0.1\n\n        # Get what's forward\n        pf, pr, pl, pu = self._get_directions()\n\n        # Increase speed through acceleration\n        # Note that self._speed is relative. We can balance rel_acc and\n        # rel_speed to get a nice smooth or direct control\n        self._speed += self._acc * rel_acc\n\n        # Reduce speed. Simulate resistance. Using brakes slows down faster.\n        # Note that the way that we reduce speed, allows for higher\n        # speeds if keys ar bound to higher acc values (i.e. turbo)\n        reduce = np.array([0.05, 0.05, 0.05, 0.1, 0.1, 0.1])\n        reduce[self._brake > 0] = 0.2\n        self._speed -= self._speed * reduce\n        if np.abs(self._speed).max() < 0.05:\n            self._speed *= 0.0\n\n        # --- Determine new position from translation speed\n\n        if self._speed[:3].any():\n\n            # Create speed vectors, use scale_factor as a reference\n            dv = np.array([1.0/d for d in self._flip_factors])\n            #\n            vf = pf * dv * rel_speed * self._scale_factor\n            vr = pr * dv * rel_speed * self._scale_factor\n            vu = pu * dv * rel_speed * self._scale_factor\n            direction = vf, vr, vu\n\n            # Set position\n            center_loc = np.array(self._center, dtype='float32')\n            center_loc += (self._speed[0] * direction[0] +\n                           self._speed[1] * direction[1] +\n                           self._speed[2] * direction[2])\n            self._center = tuple(center_loc)\n\n        # --- Determine new orientation from rotation speed\n\n        roll_angle = 0\n\n        # Calculate manual roll (from speed)\n        if self._speed[3:].any():\n            angleGain = np.array([1.0, 1.5, 1.0]) * 3 * math.pi / 180\n            angles = self._speed[3:] * angleGain\n\n            q1 = Quaternion.create_from_axis_angle(angles[0], -1, 0, 0)\n            q2 = Quaternion.create_from_axis_angle(angles[1], 0, 1, 0)\n            q3 = Quaternion.create_from_axis_angle(angles[2], 0, 0, -1)\n            q = q1 * q2 * q3\n            self._rotation1 = (q * self._rotation1).normalize()\n\n        # Calculate auto-roll\n        if self.auto_roll:\n            up = {'x': (1, 0, 0), 'y': (0, 1, 0), 'z': (0, 0, 1)}[self.up[1]]\n            up = np.array(up) * {'+': +1, '-': -1}[self.up[0]]\n\n            def angle(p1, p2):\n                return np.arccos(p1.dot(p2))\n            # au = angle(pu, (0, 0, 1))\n            ar = angle(pr, up)\n            al = angle(pl, up)\n            af = angle(pf, up)\n            # Roll angle that's off from being leveled (in unit strength)\n            roll_angle = math.sin(0.5*(al - ar))\n            # Correct for pitch\n            roll_angle *= abs(math.sin(af))  # abs(math.sin(au))\n            if abs(roll_angle) < 0.05:\n                roll_angle = 0\n            if roll_angle:\n                # Correct to soften the force at 90 degree angle\n                roll_angle = np.sign(roll_angle) * np.abs(roll_angle)**0.5\n                # Get correction for this iteration and apply\n                angle_correction = 1.0 * roll_angle * math.pi / 180\n                q = Quaternion.create_from_axis_angle(angle_correction,\n                                                      0, 0, 1)\n                self._rotation1 = (q * self._rotation1).normalize()\n\n        # Update\n        if self._speed.any() or roll_angle or self._update_from_mouse:\n            self._update_from_mouse = False\n            self.view_changed()",
  "def viewbox_key_event(self, event):\n        \"\"\"The ViewBox key event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        PerspectiveCamera.viewbox_key_event(self, event)\n\n        if event.handled or not self.interactive:\n            return\n\n        # Ensure the timer runs\n        if not self._timer.running:\n            self._timer.start()\n\n        if event.key in self._keymap:\n            val_dims = self._keymap[event.key]\n            val = val_dims[0]\n            # Brake or accelarate?\n            if val == 0:\n                vec = self._brake\n                val = 1\n            else:\n                vec = self._acc\n            # Set\n            if event.type == 'key_release':\n                val = 0\n            for dim in val_dims[1:]:\n                factor = 1.0\n                vec[dim-1] = val * factor\n            event.handled = True",
  "def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.handled or not self.interactive:\n            return\n\n        if event.type == 'mouse_wheel':\n            if not event.mouse_event.modifiers:\n                # Move forward / backward\n                self._speed[0] += 0.5 * event.delta[1]\n            elif keys.SHIFT in event.mouse_event.modifiers:\n                # Speed\n                s = 1.1 ** - event.delta[1]\n                self.scale_factor /= s  # divide instead of multiply\n                print('scale factor: %1.1f units/s' % self.scale_factor)\n            return\n\n        if event.type == 'mouse_press':\n            event.handled = True\n\n        if event.type == 'mouse_release':\n            # Reset\n            self._event_value = None\n            # Apply rotation\n            self._rotation1 = (self._rotation2 * self._rotation1).normalize()\n            self._rotation2 = Quaternion()\n            event.handled = True\n        elif not self._timer.running:\n            # Ensure the timer runs\n            self._timer.start()\n\n        if event.type == 'mouse_move':\n\n            if event.press_event is None:\n                return\n            if not event.buttons:\n                return\n\n            # Prepare\n            modifiers = event.mouse_event.modifiers\n            pos1 = event.mouse_event.press_event.pos\n            pos2 = event.mouse_event.pos\n            w, h = self._viewbox.size\n\n            if 1 in event.buttons and not modifiers:\n                # rotate\n\n                # get normalized delta values\n                d_az = -float(pos2[0] - pos1[0]) / w\n                d_el = +float(pos2[1] - pos1[1]) / h\n                # Apply gain\n                d_az *= - 0.5 * math.pi  # * self._speed_rot\n                d_el *= + 0.5 * math.pi  # * self._speed_rot\n                # Create temporary quaternions\n                q_az = Quaternion.create_from_axis_angle(d_az, 0, 1, 0)\n                q_el = Quaternion.create_from_axis_angle(d_el, 1, 0, 0)\n\n                # Apply to global quaternion\n                self._rotation2 = (q_el.normalize() * q_az).normalize()\n                event.handled = True\n\n            elif 2 in event.buttons and keys.CONTROL in modifiers:\n                # zoom --> fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                p1 = np.array(event.press_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1c = event.map_to_canvas(p1)[:2]\n                p2c = event.map_to_canvas(p2)[:2]\n                d = p2c - p1c\n                fov = self._event_value * math.exp(-0.01*d[1])\n                self._fov = min(90.0, max(10, fov))\n                event.handled = True\n\n        # Make transform be updated on the next timer tick.\n        # By doing it at timer tick, we avoid shaky behavior\n        self._update_from_mouse = True",
  "def _update_projection_transform(self, fx, fy):\n        PerspectiveCamera._update_projection_transform(self, fx, fy)\n\n        # Turn our internal quaternion representation into rotation\n        # of our transform\n\n        axis_angle = self.rotation.get_axis_angle()\n        angle = axis_angle[0] * 180 / math.pi\n\n        tr = self.transform\n        tr.reset()\n        #\n        tr.rotate(-angle, axis_angle[1:])\n        tr.scale([1.0/a for a in self._flip_factors])\n        tr.translate(self._center)",
  "def _normalize(p):\n            L = sum(x**2 for x in p) ** 0.5\n            return np.array(p, 'float64') / L",
  "def angle(p1, p2):\n                return np.arccos(p1.dot(p2))",
  "class TurntableCamera(Base3DRotationCamera):\n    \"\"\"3D camera class that orbits around a center point while\n    maintaining a view on a center point.\n\n    For this camera, the ``scale_factor`` indicates the zoom level, and\n    the ``center`` indicates the position to put at the center of the\n    view.\n\n    Parameters\n    ----------\n    fov : float\n        Field of view. Zero (default) means orthographic projection.\n    elevation : float\n        Elevation angle in degrees. Positive angles place the camera\n        above the cente point, negative angles place the camera below\n        the center point.\n    azimuth : float\n        Azimuth angle in degrees. Zero degrees places the camera on the\n        positive x-axis, pointing in the negative x direction.\n    roll : float\n        Roll angle in degrees\n    distance : float | None\n        The distance of the camera from the rotation point (only makes sense\n        if fov > 0). If None (default) the distance is determined from the\n        scale_factor and fov.\n    translate_speed : float\n        Scale factor on translation speed when moving the camera center point.\n    **kwargs : dict\n        Keyword arguments to pass to `BaseCamera`.\n\n    Notes\n    -----\n    Interaction:\n\n        * LMB: orbits the view around its center point.\n        * RMB or scroll: change scale_factor (i.e. zoom level)\n        * SHIFT + LMB: translate the center point\n        * SHIFT + RMB: change FOV\n\n    \"\"\"\n\n    _state_props = Base3DRotationCamera._state_props + ('elevation',\n                                                        'azimuth', 'roll')\n\n    def __init__(self, fov=45.0, elevation=30.0, azimuth=30.0, roll=0.0,\n                 distance=None, translate_speed=1.0, **kwargs):\n        super(TurntableCamera, self).__init__(fov=fov, **kwargs)\n\n        # Set camera attributes\n        self.azimuth = azimuth\n        self.elevation = elevation\n        self.roll = roll  # interaction not implemented yet\n        self.distance = distance  # None means auto-distance\n        self.translate_speed = translate_speed\n\n    @property\n    def elevation(self):\n        \"\"\"The angle of the camera in degrees above the horizontal (x, z)\n        plane.\n        \"\"\"\n        return self._elevation\n\n    @elevation.setter\n    def elevation(self, elev):\n        elev = float(elev)\n        self._elevation = min(90, max(-90, elev))\n        self.view_changed()\n\n    @property\n    def azimuth(self):\n        \"\"\"The angle of the camera in degrees around the y axis. An angle of\n        0 places the camera within the (y, z) plane.\n        \"\"\"\n        return self._azimuth\n\n    @azimuth.setter\n    def azimuth(self, azim):\n        azim = float(azim)\n        while azim < -180:\n            azim += 360\n        while azim > 180:\n            azim -= 360\n        self._azimuth = azim\n        self.view_changed()\n\n    @property\n    def roll(self):\n        \"\"\"The angle of the camera in degrees around the z axis. An angle of\n        0 places puts the camera upright.\n        \"\"\"\n        return self._roll\n\n    @roll.setter\n    def roll(self, roll):\n        roll = float(roll)\n        while roll < -180:\n            roll += 360\n        while roll > 180:\n            roll -= 360\n        self._roll = roll\n        self.view_changed()\n\n    def orbit(self, azim, elev):\n        \"\"\"Orbits the camera around the center position.\n\n        Parameters\n        ----------\n        azim : float\n            Angle in degrees to rotate horizontally around the center point.\n        elev : float\n            Angle in degrees to rotate vertically around the center point.\n        \"\"\"\n        self.azimuth += azim\n        self.elevation = np.clip(self.elevation + elev, -90, 90)\n        self.view_changed()\n\n    def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        p1 = event.mouse_event.press_event.pos\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = self.azimuth, self.elevation\n        self.azimuth = self._event_value[0] - (p2 - p1)[0] * 0.5\n        self.elevation = self._event_value[1] + (p2 - p1)[1] * 0.5\n\n    def _get_rotation_tr(self):\n        \"\"\"Return a rotation matrix based on camera parameters\"\"\"\n        up, forward, right = self._get_dim_vectors()\n        return np.dot(\n            transforms.rotate(self.elevation, -right),\n            transforms.rotate(self.azimuth, up)\n        )\n\n    def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        rae = np.array([self.roll, self.azimuth, self.elevation]) * np.pi / 180\n        sro, saz, sel = np.sin(rae)\n        cro, caz, cel = np.cos(rae)\n        d0, d1 = dist[0], dist[1]\n        dx = (+ d0 * (cro * caz + sro * sel * saz)\n              + d1 * (sro * caz - cro * sel * saz)) * self.translate_speed\n        dy = (+ d0 * (cro * saz - sro * sel * caz)\n              + d1 * (sro * saz + cro * sel * caz)) * self.translate_speed\n        dz = (- d0 * sro * cel + d1 * cro * cel) * self.translate_speed\n        return dx, dy, dz",
  "def __init__(self, fov=45.0, elevation=30.0, azimuth=30.0, roll=0.0,\n                 distance=None, translate_speed=1.0, **kwargs):\n        super(TurntableCamera, self).__init__(fov=fov, **kwargs)\n\n        # Set camera attributes\n        self.azimuth = azimuth\n        self.elevation = elevation\n        self.roll = roll  # interaction not implemented yet\n        self.distance = distance  # None means auto-distance\n        self.translate_speed = translate_speed",
  "def elevation(self):\n        \"\"\"The angle of the camera in degrees above the horizontal (x, z)\n        plane.\n        \"\"\"\n        return self._elevation",
  "def elevation(self, elev):\n        elev = float(elev)\n        self._elevation = min(90, max(-90, elev))\n        self.view_changed()",
  "def azimuth(self):\n        \"\"\"The angle of the camera in degrees around the y axis. An angle of\n        0 places the camera within the (y, z) plane.\n        \"\"\"\n        return self._azimuth",
  "def azimuth(self, azim):\n        azim = float(azim)\n        while azim < -180:\n            azim += 360\n        while azim > 180:\n            azim -= 360\n        self._azimuth = azim\n        self.view_changed()",
  "def roll(self):\n        \"\"\"The angle of the camera in degrees around the z axis. An angle of\n        0 places puts the camera upright.\n        \"\"\"\n        return self._roll",
  "def roll(self, roll):\n        roll = float(roll)\n        while roll < -180:\n            roll += 360\n        while roll > 180:\n            roll -= 360\n        self._roll = roll\n        self.view_changed()",
  "def orbit(self, azim, elev):\n        \"\"\"Orbits the camera around the center position.\n\n        Parameters\n        ----------\n        azim : float\n            Angle in degrees to rotate horizontally around the center point.\n        elev : float\n            Angle in degrees to rotate vertically around the center point.\n        \"\"\"\n        self.azimuth += azim\n        self.elevation = np.clip(self.elevation + elev, -90, 90)\n        self.view_changed()",
  "def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        p1 = event.mouse_event.press_event.pos\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = self.azimuth, self.elevation\n        self.azimuth = self._event_value[0] - (p2 - p1)[0] * 0.5\n        self.elevation = self._event_value[1] + (p2 - p1)[1] * 0.5",
  "def _get_rotation_tr(self):\n        \"\"\"Return a rotation matrix based on camera parameters\"\"\"\n        up, forward, right = self._get_dim_vectors()\n        return np.dot(\n            transforms.rotate(self.elevation, -right),\n            transforms.rotate(self.azimuth, up)\n        )",
  "def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        rae = np.array([self.roll, self.azimuth, self.elevation]) * np.pi / 180\n        sro, saz, sel = np.sin(rae)\n        cro, caz, cel = np.cos(rae)\n        d0, d1 = dist[0], dist[1]\n        dx = (+ d0 * (cro * caz + sro * sel * saz)\n              + d1 * (sro * caz - cro * sel * saz)) * self.translate_speed\n        dy = (+ d0 * (cro * saz - sro * sel * caz)\n              + d1 * (sro * saz + cro * sel * caz)) * self.translate_speed\n        dz = (- d0 * sro * cel + d1 * cro * cel) * self.translate_speed\n        return dx, dy, dz",
  "def nested_getattr(obj, names):\n    for name in names:\n        obj = getattr(obj, name)\n    return obj",
  "def nested_setattr(obj, names, val):\n    target = nested_getattr(obj, names[:-1])\n    setattr(target, names[-1], val)",
  "class BaseCamera(Node):\n    \"\"\"Base camera class.\n\n    The Camera describes the perspective from which a ViewBox views its\n    subscene, and the way that user interaction affects that perspective.\n\n    Most functionality is implemented in subclasses. This base class has\n    no user interaction and causes the subscene to use the same coordinate\n    system as the ViewBox.\n\n    Parameters\n    ----------\n    interactive : bool\n        Whether the camera processes mouse and keyboard events.\n    flip : tuple of bools\n        For each dimension, specify whether it is flipped.\n    up : {'+z', '-z', '+y', '-y', '+x', '-x'}\n        The direction that is considered up. Default '+z'. Not all\n        camera's may support this (yet).\n    parent : Node\n        The parent of the camera.\n    name : str\n        Name used to identify the camera in the scene.\n    \"\"\"\n\n    # These define the state of the camera\n    _state_props = ()\n\n    # The fractional zoom to apply for a single pixel of mouse motion\n    zoom_factor = 0.007\n\n    def __init__(self, interactive=True, flip=None, up='+z', parent=None,\n                 name=None):\n        super(BaseCamera, self).__init__(parent, name)\n\n        # The viewbox for which this camera is active\n        self._viewbox = None\n\n        # Linked cameras\n        self._linked_cameras = {}\n        self._linked_cameras_no_update = None\n\n        # Variables related to transforms\n        self.transform = NullTransform()\n        self._pre_transform = None\n        self._viewbox_tr = STTransform()  # correction for viewbox\n        self._projection = MatrixTransform()\n        self._transform_cache = TransformCache()\n\n        # For internal use, to store event related information\n        self._event_value = None\n\n        # Flags\n        self._resetting = False  # Avoid lots of updates during set_range\n        self._key_events_bound = False  # Have we connected to key events\n        self._set_range_args = None  # hold set_range() args\n\n        # Limits set in reset (interesting region of the scene)\n        self._xlim = None  # None is flag that no reset has been performed\n        self._ylim = None\n        self._zlim = None\n\n        # Our default state to apply when resetting\n        self._default_state = None\n\n        # We initialize these parameters here, because we want these props\n        # available in all cameras. Note that PanZoom does not use _center\n        self._fov = 0.0\n        self._center = None\n        self._depth_value = 1e6  # bit+depth >= 24, otherwise should do 3e3\n\n        # Set parameters. These are all not part of the \"camera state\"\n        self.interactive = bool(interactive)\n        self.flip = flip if (flip is not None) else (False, False, False)\n        self.up = up\n\n    @property\n    def depth_value(self):\n        \"\"\"The depth value to use  in orthographic and perspective projection\n\n        For orthographic projections, ``depth_value`` is the distance between\n        the near and far clipping planes. For perspective projections, it is\n        the ratio between the near and far clipping plane distances.\n\n        GL has a fixed amount of precision in the depth buffer, and a fixed\n        constant will not work for both a very large range and very high\n        precision. This property provides the user a way to override\n        the default value if necessary.\n        \"\"\"\n        return self._depth_value\n\n    @depth_value.setter\n    def depth_value(self, value):\n        value = float(value)\n        if value <= 0:\n            raise ValueError('depth value must be positive')\n        self._depth_value = value\n        self.view_changed()\n\n    def _depth_to_z(self, depth):\n        \"\"\"Get the z-coord, given the depth value.\"\"\"\n        val = self.depth_value\n        return val - depth * 2 * val\n\n    def _viewbox_set(self, viewbox):\n        \"\"\"Friend method of viewbox to register itself.\"\"\"\n        self._viewbox = viewbox\n        # Connect\n        viewbox.events.mouse_press.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_release.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_move.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_wheel.connect(self.viewbox_mouse_event)\n        viewbox.events.resize.connect(self.viewbox_resize_event)\n        # todo: also add key events! (and also on viewbox (they're missing)\n\n    def _viewbox_unset(self, viewbox):\n        \"\"\"Friend method of viewbox to unregister itself.\"\"\"\n        self._viewbox = None\n        # Disconnect\n        viewbox.events.mouse_press.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_release.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_move.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_wheel.disconnect(self.viewbox_mouse_event)\n        viewbox.events.resize.disconnect(self.viewbox_resize_event)\n\n    @property\n    def viewbox(self):\n        \"\"\"The viewbox that this camera applies to.\"\"\"\n        return self._viewbox\n\n    # Camera attributes\n\n    @property\n    def interactive(self):\n        \"\"\"Boolean describing whether the camera should enable or disable\n        user interaction.\n        \"\"\"\n        return self._interactive\n\n    @interactive.setter\n    def interactive(self, value):\n        self._interactive = bool(value)\n\n    @property\n    def flip(self):\n        return self._flip\n\n    @flip.setter\n    def flip(self, value):\n        if not isinstance(value, (list, tuple)):\n            raise ValueError('Flip must be a tuple or list.')\n        if len(value) == 2:\n            self._flip = bool(value[0]), bool(value[1]), False\n        elif len(value) == 3:\n            self._flip = bool(value[0]), bool(value[1]), bool(value[2])\n        else:\n            raise ValueError('Flip must have 2 or 3 elements.')\n        self._flip_factors = tuple([(1-x*2) for x in self._flip])\n        self.view_changed()\n\n    @property\n    def up(self):\n        \"\"\"The dimension that is considered up.\"\"\"\n        return self._up\n\n    @up.setter\n    def up(self, value):\n        value = value.lower()\n        value = ('+' + value) if value in 'zyx' else value\n        if value not in ('+z', '-z', '+y', '-y', '+x', '-x'):\n            raise ValueError('Invalid value for up.')\n        self._up = value\n        self.view_changed()\n\n    @property\n    def center(self):\n        \"\"\"The center location for this camera\n\n        The exact meaning of this value differs per type of camera, but\n        generally means the point of interest or the rotation point.\n        \"\"\"\n        return self._center or (0, 0, 0)\n\n    @center.setter\n    def center(self, val):\n        if len(val) == 2:\n            self._center = float(val[0]), float(val[1]), 0.0\n        elif len(val) == 3:\n            self._center = float(val[0]), float(val[1]), float(val[2])\n        else:\n            raise ValueError('Center must be a 2 or 3 element tuple')\n        self.view_changed()\n\n    @property\n    def fov(self):\n        \"\"\"Field-of-view angle of the camera. If 0, the camera is in\n        orthographic mode.\n        \"\"\"\n        return self._fov\n\n    @fov.setter\n    def fov(self, fov):\n        fov = float(fov)\n        if fov < 0 or fov >= 180:\n            raise ValueError(\"fov must be between 0 and 180.\")\n        self._fov = fov\n        self.view_changed()\n\n    # Camera methods\n\n    def set_range(self, x=None, y=None, z=None, margin=0.05):\n        \"\"\"Set the range of the view region for the camera\n\n        Parameters\n        ----------\n        x : tuple | None\n            X range.\n        y : tuple | None\n            Y range.\n        z : tuple | None\n            Z range.\n        margin : float\n            Margin to use.\n\n        Notes\n        -----\n        The view is set to the given range or to the scene boundaries\n        if ranges are not specified. The ranges should be 2-element\n        tuples specifying the min and max for each dimension.\n\n        For the PanZoomCamera the view is fully defined by the range.\n        For e.g. the TurntableCamera the elevation and azimuth are not\n        set. One should use reset() for that.\n        \"\"\"\n        # Flag to indicate that this is an initializing (not user-invoked)\n        init = self._xlim is None\n\n        # Collect given bounds\n        bounds = [None, None, None]\n        if x is not None:\n            bounds[0] = float(x[0]), float(x[1])\n        if y is not None:\n            bounds[1] = float(y[0]), float(y[1])\n        if z is not None:\n            bounds[2] = float(z[0]), float(z[1])\n        # If there is no viewbox, store given bounds in lim variables, and stop\n        if self._viewbox is None:\n            self._set_range_args = bounds[0], bounds[1], bounds[2], margin\n            return\n\n        # There is a viewbox, we're going to set the range for real\n        self._resetting = True\n\n        # Get bounds from viewbox if not given\n        if all([(b is None) for b in bounds]):\n            bounds = self._viewbox.get_scene_bounds()\n        else:\n            for i in range(3):\n                if bounds[i] is None:\n                    bounds[i] = self._viewbox.get_scene_bounds(i)\n\n        # Calculate ranges and margins\n        ranges = [b[1] - b[0] for b in bounds]\n        margins = [(r*margin or 0.1) for r in ranges]\n        # Assign limits for this camera\n        bounds_margins = [(b[0]-m, b[1]+m) for b, m in zip(bounds, margins)]\n        self._xlim, self._ylim, self._zlim = bounds_margins\n        # Store center location\n        if (not init) or (self._center is None):\n            self._center = [(b[0] + r / 2) for b, r in zip(bounds, ranges)]\n\n        # Let specific camera handle it\n        self._set_range(init)\n\n        # Finish\n        self._resetting = False\n        self.view_changed()\n\n    def _set_range(self, init):\n        pass\n\n    def reset(self):\n        \"\"\"Reset the view to the default state.\"\"\"\n        self.set_state(self._default_state)\n\n    def set_default_state(self):\n        \"\"\"Set the current state to be the default state to be applied\n        when calling reset().\n        \"\"\"\n        self._default_state = self.get_state()\n\n    def get_state(self, props=None):\n        \"\"\"Get the current view state of the camera\n\n        Returns a dict of key-value pairs. The exact keys depend on the\n        camera. Can be passed to set_state() (of this or another camera\n        of the same type) to reproduce the state.\n\n        Parameters\n        ----------\n        props : list of strings | None\n            List of properties to include in the returned dict. If None,\n            all of camera state is returned.\n        \"\"\"\n        if props is None:\n            props = self._state_props\n        state = {}\n        for key in props:\n            # We support tuple keys to accomodate camera linking.\n            if isinstance(key, tuple):\n                state[key] = nested_getattr(self, key)\n            else:\n                state[key] = getattr(self, key)\n        return state\n\n    def set_state(self, state=None, **kwargs):\n        \"\"\"Set the view state of the camera\n\n        Should be a dict (or kwargs) as returned by get_state. It can\n        be an incomlete dict, in which case only the specified\n        properties are set.\n\n        Parameters\n        ----------\n        state : dict\n            The camera state.\n        **kwargs : dict\n            Unused keyword arguments.\n        \"\"\"\n        state = state or {}\n        state.update(kwargs)\n\n        # In first pass, process tuple keys which select subproperties. This\n        # is an undocumented feature used for selective linking of camera state.\n        #\n        # Subproperties are handled by first copying old value of the root\n        # property, then setting the subproperty on this copy, and finally\n        # assigning the copied object back to the camera property. There needs\n        # to be an assignment of the root property so setters are called and\n        # update is triggered.\n        for key in list(state.keys()):\n            if isinstance(key, tuple):\n                key1 = key[0]\n                if key1 not in state:\n                    root_prop = getattr(self, key1)\n                    # We make copies by passing the old object to the type's\n                    # constructor. This needs to be supported as is the case in\n                    # e.g. the geometry.Rect class.\n                    state[key1] = root_prop.__class__(root_prop)\n                nested_setattr(state[key1], key[1:], state[key])\n\n        # In second pass, assign the new root properties.\n        for key, val in state.items():\n            if isinstance(key, tuple):\n                continue\n            if key not in self._state_props:\n                raise KeyError('Not a valid camera state property %r' % key)\n            setattr(self, key, val)\n\n    def link(self, camera, props=None, axis=None):\n        \"\"\"Link this camera with another camera of the same type\n\n        Linked camera's keep each-others' state in sync.\n\n        Parameters\n        ----------\n        camera : instance of Camera\n            The other camera to link.\n        props : list of strings | tuple of strings | None\n            List of camera state properties to keep in sync between\n            the two cameras. If None, all of camera state is kept in sync.\n        axis : \"x\" | \"y\" | None\n            An axis to link between two PanZoomCamera instances. If not None,\n            view limits in the selected axis only will be kept in sync between\n            the cameras.\n        \"\"\"\n        if axis is not None:\n            props = props or []\n            if axis == \"x\":\n                props += [(\"rect\", \"left\"), (\"rect\", \"right\")]\n            elif axis == \"y\":\n                props += [(\"rect\", \"bottom\"), (\"rect\", \"top\")]\n            else:\n                raise ValueError(\"Axis can be 'x' or 'y', not %r\" % axis)\n        if props is None:\n            props = self._state_props\n\n        cam1, cam2 = self, camera\n        while cam1 in cam2._linked_cameras:\n            del cam2._linked_cameras[cam1]\n        while cam2 in cam1._linked_cameras:\n            del cam1._linked_cameras[cam2]\n        # Link both ways\n        cam1._linked_cameras[cam2] = props\n        cam2._linked_cameras[cam1] = props\n\n    # Event-related methods\n\n    def view_changed(self):\n        \"\"\"Called when this camera is changes its view. Also called\n        when its associated with a viewbox.\n        \"\"\"\n        if self._resetting:\n            return  # don't update anything while resetting (are in set_range)\n        if self._viewbox:\n            # Set range if necessary\n            if self._xlim is None:\n                args = self._set_range_args or ()\n                self.set_range(*args)\n            # Store default state if we have not set it yet\n            if self._default_state is None:\n                self.set_default_state()\n            # Do the actual update\n            self._update_transform()\n\n    @property\n    def pre_transform(self):\n        \"\"\"A transform to apply to the beginning of the scene transform, in\n        addition to anything else provided by this Camera.\n        \"\"\"\n        return self._pre_transform\n\n    @pre_transform.setter\n    def pre_transform(self, tr):\n        self._pre_transform = tr\n        self.view_changed()\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"Viewbox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        pass\n\n    def on_canvas_change(self, event):\n        \"\"\"Canvas change event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        # Connect key events from canvas to camera. \n        # TODO: canvas should keep track of a single node with keyboard focus.\n        if event.old is not None:\n            event.old.events.key_press.disconnect(self.viewbox_key_event)\n            event.old.events.key_release.disconnect(self.viewbox_key_event)\n        if event.new is not None:\n            event.new.events.key_press.connect(self.viewbox_key_event)\n            event.new.events.key_release.connect(self.viewbox_key_event)\n\n    def viewbox_key_event(self, event):\n        \"\"\"The ViewBox key event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.key == keys.BACKSPACE:\n            self.reset()\n\n    def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize handler to update the transform\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        pass\n\n    def _update_transform(self):\n        \"\"\"Subclasses should reimplement this method to update the scene\n        transform by calling self._set_scene_transform.\n        \"\"\"\n        self._set_scene_transform(self.transform)\n\n    def _set_scene_transform(self, tr):\n        \"\"\"Called by subclasses to configure the viewbox scene transform.\"\"\"\n        # todo: check whether transform has changed, connect to\n        # transform.changed event\n        pre_tr = self.pre_transform\n        if pre_tr is None:\n            self._scene_transform = tr\n        else:\n            self._transform_cache.roll()\n            self._scene_transform = self._transform_cache.get([pre_tr, tr])\n\n        # Mark the transform dynamic so that it will not be collapsed with\n        # others \n        self._scene_transform.dynamic = True\n\n        # Update scene\n        self._viewbox.scene.transform = self._scene_transform\n        self._viewbox.update()\n\n        # Apply same state to linked cameras, but prevent that camera\n        # to return the favor\n        for cam in self._linked_cameras:\n            if cam is self._linked_cameras_no_update:\n                continue\n            try:\n                cam._linked_cameras_no_update = self\n                linked_props = self._linked_cameras[cam]\n                cam.set_state(self.get_state(linked_props))\n            finally:\n                cam._linked_cameras_no_update = None",
  "def __init__(self, interactive=True, flip=None, up='+z', parent=None,\n                 name=None):\n        super(BaseCamera, self).__init__(parent, name)\n\n        # The viewbox for which this camera is active\n        self._viewbox = None\n\n        # Linked cameras\n        self._linked_cameras = {}\n        self._linked_cameras_no_update = None\n\n        # Variables related to transforms\n        self.transform = NullTransform()\n        self._pre_transform = None\n        self._viewbox_tr = STTransform()  # correction for viewbox\n        self._projection = MatrixTransform()\n        self._transform_cache = TransformCache()\n\n        # For internal use, to store event related information\n        self._event_value = None\n\n        # Flags\n        self._resetting = False  # Avoid lots of updates during set_range\n        self._key_events_bound = False  # Have we connected to key events\n        self._set_range_args = None  # hold set_range() args\n\n        # Limits set in reset (interesting region of the scene)\n        self._xlim = None  # None is flag that no reset has been performed\n        self._ylim = None\n        self._zlim = None\n\n        # Our default state to apply when resetting\n        self._default_state = None\n\n        # We initialize these parameters here, because we want these props\n        # available in all cameras. Note that PanZoom does not use _center\n        self._fov = 0.0\n        self._center = None\n        self._depth_value = 1e6  # bit+depth >= 24, otherwise should do 3e3\n\n        # Set parameters. These are all not part of the \"camera state\"\n        self.interactive = bool(interactive)\n        self.flip = flip if (flip is not None) else (False, False, False)\n        self.up = up",
  "def depth_value(self):\n        \"\"\"The depth value to use  in orthographic and perspective projection\n\n        For orthographic projections, ``depth_value`` is the distance between\n        the near and far clipping planes. For perspective projections, it is\n        the ratio between the near and far clipping plane distances.\n\n        GL has a fixed amount of precision in the depth buffer, and a fixed\n        constant will not work for both a very large range and very high\n        precision. This property provides the user a way to override\n        the default value if necessary.\n        \"\"\"\n        return self._depth_value",
  "def depth_value(self, value):\n        value = float(value)\n        if value <= 0:\n            raise ValueError('depth value must be positive')\n        self._depth_value = value\n        self.view_changed()",
  "def _depth_to_z(self, depth):\n        \"\"\"Get the z-coord, given the depth value.\"\"\"\n        val = self.depth_value\n        return val - depth * 2 * val",
  "def _viewbox_set(self, viewbox):\n        \"\"\"Friend method of viewbox to register itself.\"\"\"\n        self._viewbox = viewbox\n        # Connect\n        viewbox.events.mouse_press.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_release.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_move.connect(self.viewbox_mouse_event)\n        viewbox.events.mouse_wheel.connect(self.viewbox_mouse_event)\n        viewbox.events.resize.connect(self.viewbox_resize_event)",
  "def _viewbox_unset(self, viewbox):\n        \"\"\"Friend method of viewbox to unregister itself.\"\"\"\n        self._viewbox = None\n        # Disconnect\n        viewbox.events.mouse_press.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_release.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_move.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_wheel.disconnect(self.viewbox_mouse_event)\n        viewbox.events.resize.disconnect(self.viewbox_resize_event)",
  "def viewbox(self):\n        \"\"\"The viewbox that this camera applies to.\"\"\"\n        return self._viewbox",
  "def interactive(self):\n        \"\"\"Boolean describing whether the camera should enable or disable\n        user interaction.\n        \"\"\"\n        return self._interactive",
  "def interactive(self, value):\n        self._interactive = bool(value)",
  "def flip(self):\n        return self._flip",
  "def flip(self, value):\n        if not isinstance(value, (list, tuple)):\n            raise ValueError('Flip must be a tuple or list.')\n        if len(value) == 2:\n            self._flip = bool(value[0]), bool(value[1]), False\n        elif len(value) == 3:\n            self._flip = bool(value[0]), bool(value[1]), bool(value[2])\n        else:\n            raise ValueError('Flip must have 2 or 3 elements.')\n        self._flip_factors = tuple([(1-x*2) for x in self._flip])\n        self.view_changed()",
  "def up(self):\n        \"\"\"The dimension that is considered up.\"\"\"\n        return self._up",
  "def up(self, value):\n        value = value.lower()\n        value = ('+' + value) if value in 'zyx' else value\n        if value not in ('+z', '-z', '+y', '-y', '+x', '-x'):\n            raise ValueError('Invalid value for up.')\n        self._up = value\n        self.view_changed()",
  "def center(self):\n        \"\"\"The center location for this camera\n\n        The exact meaning of this value differs per type of camera, but\n        generally means the point of interest or the rotation point.\n        \"\"\"\n        return self._center or (0, 0, 0)",
  "def center(self, val):\n        if len(val) == 2:\n            self._center = float(val[0]), float(val[1]), 0.0\n        elif len(val) == 3:\n            self._center = float(val[0]), float(val[1]), float(val[2])\n        else:\n            raise ValueError('Center must be a 2 or 3 element tuple')\n        self.view_changed()",
  "def fov(self):\n        \"\"\"Field-of-view angle of the camera. If 0, the camera is in\n        orthographic mode.\n        \"\"\"\n        return self._fov",
  "def fov(self, fov):\n        fov = float(fov)\n        if fov < 0 or fov >= 180:\n            raise ValueError(\"fov must be between 0 and 180.\")\n        self._fov = fov\n        self.view_changed()",
  "def set_range(self, x=None, y=None, z=None, margin=0.05):\n        \"\"\"Set the range of the view region for the camera\n\n        Parameters\n        ----------\n        x : tuple | None\n            X range.\n        y : tuple | None\n            Y range.\n        z : tuple | None\n            Z range.\n        margin : float\n            Margin to use.\n\n        Notes\n        -----\n        The view is set to the given range or to the scene boundaries\n        if ranges are not specified. The ranges should be 2-element\n        tuples specifying the min and max for each dimension.\n\n        For the PanZoomCamera the view is fully defined by the range.\n        For e.g. the TurntableCamera the elevation and azimuth are not\n        set. One should use reset() for that.\n        \"\"\"\n        # Flag to indicate that this is an initializing (not user-invoked)\n        init = self._xlim is None\n\n        # Collect given bounds\n        bounds = [None, None, None]\n        if x is not None:\n            bounds[0] = float(x[0]), float(x[1])\n        if y is not None:\n            bounds[1] = float(y[0]), float(y[1])\n        if z is not None:\n            bounds[2] = float(z[0]), float(z[1])\n        # If there is no viewbox, store given bounds in lim variables, and stop\n        if self._viewbox is None:\n            self._set_range_args = bounds[0], bounds[1], bounds[2], margin\n            return\n\n        # There is a viewbox, we're going to set the range for real\n        self._resetting = True\n\n        # Get bounds from viewbox if not given\n        if all([(b is None) for b in bounds]):\n            bounds = self._viewbox.get_scene_bounds()\n        else:\n            for i in range(3):\n                if bounds[i] is None:\n                    bounds[i] = self._viewbox.get_scene_bounds(i)\n\n        # Calculate ranges and margins\n        ranges = [b[1] - b[0] for b in bounds]\n        margins = [(r*margin or 0.1) for r in ranges]\n        # Assign limits for this camera\n        bounds_margins = [(b[0]-m, b[1]+m) for b, m in zip(bounds, margins)]\n        self._xlim, self._ylim, self._zlim = bounds_margins\n        # Store center location\n        if (not init) or (self._center is None):\n            self._center = [(b[0] + r / 2) for b, r in zip(bounds, ranges)]\n\n        # Let specific camera handle it\n        self._set_range(init)\n\n        # Finish\n        self._resetting = False\n        self.view_changed()",
  "def _set_range(self, init):\n        pass",
  "def reset(self):\n        \"\"\"Reset the view to the default state.\"\"\"\n        self.set_state(self._default_state)",
  "def set_default_state(self):\n        \"\"\"Set the current state to be the default state to be applied\n        when calling reset().\n        \"\"\"\n        self._default_state = self.get_state()",
  "def get_state(self, props=None):\n        \"\"\"Get the current view state of the camera\n\n        Returns a dict of key-value pairs. The exact keys depend on the\n        camera. Can be passed to set_state() (of this or another camera\n        of the same type) to reproduce the state.\n\n        Parameters\n        ----------\n        props : list of strings | None\n            List of properties to include in the returned dict. If None,\n            all of camera state is returned.\n        \"\"\"\n        if props is None:\n            props = self._state_props\n        state = {}\n        for key in props:\n            # We support tuple keys to accomodate camera linking.\n            if isinstance(key, tuple):\n                state[key] = nested_getattr(self, key)\n            else:\n                state[key] = getattr(self, key)\n        return state",
  "def set_state(self, state=None, **kwargs):\n        \"\"\"Set the view state of the camera\n\n        Should be a dict (or kwargs) as returned by get_state. It can\n        be an incomlete dict, in which case only the specified\n        properties are set.\n\n        Parameters\n        ----------\n        state : dict\n            The camera state.\n        **kwargs : dict\n            Unused keyword arguments.\n        \"\"\"\n        state = state or {}\n        state.update(kwargs)\n\n        # In first pass, process tuple keys which select subproperties. This\n        # is an undocumented feature used for selective linking of camera state.\n        #\n        # Subproperties are handled by first copying old value of the root\n        # property, then setting the subproperty on this copy, and finally\n        # assigning the copied object back to the camera property. There needs\n        # to be an assignment of the root property so setters are called and\n        # update is triggered.\n        for key in list(state.keys()):\n            if isinstance(key, tuple):\n                key1 = key[0]\n                if key1 not in state:\n                    root_prop = getattr(self, key1)\n                    # We make copies by passing the old object to the type's\n                    # constructor. This needs to be supported as is the case in\n                    # e.g. the geometry.Rect class.\n                    state[key1] = root_prop.__class__(root_prop)\n                nested_setattr(state[key1], key[1:], state[key])\n\n        # In second pass, assign the new root properties.\n        for key, val in state.items():\n            if isinstance(key, tuple):\n                continue\n            if key not in self._state_props:\n                raise KeyError('Not a valid camera state property %r' % key)\n            setattr(self, key, val)",
  "def link(self, camera, props=None, axis=None):\n        \"\"\"Link this camera with another camera of the same type\n\n        Linked camera's keep each-others' state in sync.\n\n        Parameters\n        ----------\n        camera : instance of Camera\n            The other camera to link.\n        props : list of strings | tuple of strings | None\n            List of camera state properties to keep in sync between\n            the two cameras. If None, all of camera state is kept in sync.\n        axis : \"x\" | \"y\" | None\n            An axis to link between two PanZoomCamera instances. If not None,\n            view limits in the selected axis only will be kept in sync between\n            the cameras.\n        \"\"\"\n        if axis is not None:\n            props = props or []\n            if axis == \"x\":\n                props += [(\"rect\", \"left\"), (\"rect\", \"right\")]\n            elif axis == \"y\":\n                props += [(\"rect\", \"bottom\"), (\"rect\", \"top\")]\n            else:\n                raise ValueError(\"Axis can be 'x' or 'y', not %r\" % axis)\n        if props is None:\n            props = self._state_props\n\n        cam1, cam2 = self, camera\n        while cam1 in cam2._linked_cameras:\n            del cam2._linked_cameras[cam1]\n        while cam2 in cam1._linked_cameras:\n            del cam1._linked_cameras[cam2]\n        # Link both ways\n        cam1._linked_cameras[cam2] = props\n        cam2._linked_cameras[cam1] = props",
  "def view_changed(self):\n        \"\"\"Called when this camera is changes its view. Also called\n        when its associated with a viewbox.\n        \"\"\"\n        if self._resetting:\n            return  # don't update anything while resetting (are in set_range)\n        if self._viewbox:\n            # Set range if necessary\n            if self._xlim is None:\n                args = self._set_range_args or ()\n                self.set_range(*args)\n            # Store default state if we have not set it yet\n            if self._default_state is None:\n                self.set_default_state()\n            # Do the actual update\n            self._update_transform()",
  "def pre_transform(self):\n        \"\"\"A transform to apply to the beginning of the scene transform, in\n        addition to anything else provided by this Camera.\n        \"\"\"\n        return self._pre_transform",
  "def pre_transform(self, tr):\n        self._pre_transform = tr\n        self.view_changed()",
  "def viewbox_mouse_event(self, event):\n        \"\"\"Viewbox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        pass",
  "def on_canvas_change(self, event):\n        \"\"\"Canvas change event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        # Connect key events from canvas to camera. \n        # TODO: canvas should keep track of a single node with keyboard focus.\n        if event.old is not None:\n            event.old.events.key_press.disconnect(self.viewbox_key_event)\n            event.old.events.key_release.disconnect(self.viewbox_key_event)\n        if event.new is not None:\n            event.new.events.key_press.connect(self.viewbox_key_event)\n            event.new.events.key_release.connect(self.viewbox_key_event)",
  "def viewbox_key_event(self, event):\n        \"\"\"The ViewBox key event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.key == keys.BACKSPACE:\n            self.reset()",
  "def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize handler to update the transform\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        pass",
  "def _update_transform(self):\n        \"\"\"Subclasses should reimplement this method to update the scene\n        transform by calling self._set_scene_transform.\n        \"\"\"\n        self._set_scene_transform(self.transform)",
  "def _set_scene_transform(self, tr):\n        \"\"\"Called by subclasses to configure the viewbox scene transform.\"\"\"\n        # todo: check whether transform has changed, connect to\n        # transform.changed event\n        pre_tr = self.pre_transform\n        if pre_tr is None:\n            self._scene_transform = tr\n        else:\n            self._transform_cache.roll()\n            self._scene_transform = self._transform_cache.get([pre_tr, tr])\n\n        # Mark the transform dynamic so that it will not be collapsed with\n        # others \n        self._scene_transform.dynamic = True\n\n        # Update scene\n        self._viewbox.scene.transform = self._scene_transform\n        self._viewbox.update()\n\n        # Apply same state to linked cameras, but prevent that camera\n        # to return the favor\n        for cam in self._linked_cameras:\n            if cam is self._linked_cameras_no_update:\n                continue\n            try:\n                cam._linked_cameras_no_update = self\n                linked_props = self._linked_cameras[cam]\n                cam.set_state(self.get_state(linked_props))\n            finally:\n                cam._linked_cameras_no_update = None",
  "class PanZoomCamera(BaseCamera):\n    \"\"\"Camera implementing 2D pan/zoom mouse interaction.\n\n    For this camera, the ``scale_factor`` indicates the zoom level, and\n    the ``center`` indicates the center position of the view.\n\n    By default, this camera inverts the y axis of the scene. This usually\n    results in the scene +y axis pointing upward because widgets (including\n    ViewBox) have their +y axis pointing downward.\n\n    Parameters\n    ----------\n    rect : Rect\n        A Rect object or 4-element tuple that specifies the rectangular\n        area to show.\n    aspect : float | None\n        The aspect ratio (i.e. scaling) between x and y dimension of\n        the scene. E.g. to show a square image as square, the aspect\n        should be 1. If None (default) the x and y dimensions are scaled\n        independently.\n    **kwargs : dict\n        Keyword arguments to pass to `BaseCamera`.\n\n    Notes\n    -----\n    Interaction:\n\n        * LMB: pan the view\n        * RMB or scroll: zooms the view\n\n    \"\"\"\n\n    _state_props = BaseCamera._state_props + ('rect', )\n\n    def __init__(self, rect=DEFAULT_RECT_TUPLE, aspect=None, **kwargs):\n        super(PanZoomCamera, self).__init__(**kwargs)\n\n        self.transform = STTransform()\n        self.tf_mat = MatrixTransform()\n\n        # Set camera attributes\n        self.aspect = aspect\n        self._rect = None\n        self.rect = rect\n\n    @property\n    def aspect(self):\n        \"\"\"The ratio between the x and y dimension. E.g. to show a\n        square image as square, the aspect should be 1. If None, the\n        dimensions are scaled automatically, dependening on the\n        available space. Otherwise the ratio between the dimensions\n        is fixed.\n        \"\"\"\n        return self._aspect\n\n    @aspect.setter\n    def aspect(self, value):\n        if value is None:\n            self._aspect = None\n        else:\n            self._aspect = float(value)\n        self.view_changed()\n\n    def zoom(self, factor, center=None):\n        \"\"\"Zoom in (or out) at the given center\n\n        Parameters\n        ----------\n        factor : float or tuple\n            Fraction by which the scene should be zoomed (e.g. a factor of 2\n            causes the scene to appear twice as large).\n        center : tuple of 2-4 elements\n            The center of the view. If not given or None, use the\n            current center.\n        \"\"\"\n        # Init some variables\n        center = center if (center is not None) else self.center\n        assert len(center) in (2, 3, 4)\n        # Get scale factor, take scale ratio into account\n        if np.isscalar(factor):\n            scale = [factor, factor]\n        else:\n            if len(factor) != 2:\n                raise TypeError(\"factor must be scalar or length-2 sequence.\")\n            scale = list(factor)\n        if self.aspect is not None:\n            scale[0] = scale[1]\n\n        # Make a new object (copy), so that allocation will\n        # trigger view_changed:\n        rect = Rect(self.rect)\n        # Get space from given center to edges\n        left_space = center[0] - rect.left\n        right_space = rect.right - center[0]\n        bottom_space = center[1] - rect.bottom\n        top_space = rect.top - center[1]\n        # Scale these spaces\n        rect.left = center[0] - left_space * scale[0]\n        rect.right = center[0] + right_space * scale[0]\n        rect.bottom = center[1] - bottom_space * scale[1]\n        rect.top = center[1] + top_space * scale[1]\n        self.rect = rect\n\n    def pan(self, *pan):\n        \"\"\"Pan the view.\n\n        Parameters\n        ----------\n        *pan : length-2 sequence\n            The distance to pan the view, in the coordinate system of the\n            scene.\n        \"\"\"\n        if len(pan) == 1:\n            pan = pan[0]\n        self.rect = self.rect + pan\n\n    @property\n    def rect(self):\n        \"\"\"The rectangular border of the ViewBox visible area.\n        \n        This is expressed in the coordinate system of the scene.\n        See :class:`~vispy.geometry.rect.Rect` for different ways this can\n        be specified.\n\n        Note that the rectangle can have negative width or height, in\n        which case the corresponding dimension is flipped (this flipping\n        is independent from the camera's ``flip`` property).\n        \"\"\"\n        return self._rect\n\n    @rect.setter\n    def rect(self, args):\n        if isinstance(args, tuple):\n            rect = Rect(*args)\n        else:\n            rect = Rect(args)\n\n        if self._rect != rect:\n            self._rect = rect\n            self.view_changed()\n\n    @property\n    def center(self):\n        rect = self._rect\n        return (*rect.center, 0)\n\n    @center.setter\n    def center(self, center):\n        if not (isinstance(center, (tuple, list)) and len(center) in (2, 3)):\n            raise ValueError('center must be a 2 or 3 element tuple')\n        rect = Rect(self.rect) or Rect(*DEFAULT_RECT_TUPLE)\n        rect.center = center[:2]\n        self.rect = rect\n\n    def _set_range(self, init):\n        if init and self._rect is not None:\n            return\n        # Convert limits to rect\n        w = self._xlim[1] - self._xlim[0]\n        h = self._ylim[1] - self._ylim[0]\n        self.rect = self._xlim[0], self._ylim[0], w, h\n\n    def viewbox_resize_event(self, event):\n        \"\"\"Modify the data aspect and scale factor, to adjust to\n        the new window size.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.view_changed()\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"\n        The SubScene received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        # Scrolling\n        BaseCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_wheel':\n            center = self._scene_transform.imap(event.pos)\n            self.zoom((1 + self.zoom_factor)**(-event.delta[1] * 30), center)\n            event.handled = True\n\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n\n            if 1 in event.buttons and not modifiers:\n                # Translate\n                p1 = np.array(event.last_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1s = self._transform.imap(p1)\n                p2s = self._transform.imap(p2)\n                self.pan(p1s - p2s)\n                event.handled = True\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                p1c = np.array(event.last_event.pos)[:2]\n                p2c = np.array(event.pos)[:2]\n                scale = ((1 + self.zoom_factor)**((p1c - p2c) *\n                                                  np.array([1, -1])))\n                center = self._transform.imap(event.press_event.pos[:2])\n                self.zoom(scale, center)\n                event.handled = True\n            else:\n                event.handled = False\n        elif event.type == 'mouse_press':\n            # accept the event if it is button 1 or 2.\n            # This is required in order to receive future events\n            event.handled = event.button in [1, 2]\n        else:\n            event.handled = False\n\n    def _update_transform(self):\n        rect = self.rect\n        self._real_rect = Rect(rect)\n        vbr = self._viewbox.rect.flipped(x=self.flip[0], y=(not self.flip[1]))\n        d = self.depth_value\n\n        # apply scale ratio constraint\n        if self._aspect is not None:\n            # Aspect ratio of the requested range\n            requested_aspect = (rect.width /\n                                rect.height if rect.height != 0 else 1)\n            # Aspect ratio of the viewbox\n            view_aspect = vbr.width / vbr.height if vbr.height != 0 else 1\n            # View aspect ratio needed to obey the scale constraint\n            constrained_aspect = abs(view_aspect / self._aspect)\n\n            if requested_aspect > constrained_aspect:\n                # view range needs to be taller than requested\n                dy = 0.5 * (rect.width / constrained_aspect - rect.height)\n                self._real_rect.top += dy\n                self._real_rect.bottom -= dy\n            else:\n                # view range needs to be wider than requested\n                dx = 0.5 * (rect.height * constrained_aspect - rect.width)\n                self._real_rect.left -= dx\n                self._real_rect.right += dx\n\n        # Apply mapping between viewbox and cam view\n        self.transform.set_mapping(self._real_rect, vbr, update=False)\n        # Scale z, so that the clipping planes are between -alot and +alot\n        self.transform.zoom((1, 1, 1 / d))\n\n        # We've now set self.transform, which represents our 2D\n        # transform When up is +z this is all. In other cases,\n        # self.transform is now set up correctly to allow pan/zoom, but\n        # for the scene we need a different (3D) mapping. When there\n        # is a minus in up, we simply look at the scene from the other\n        # side (as if z was flipped).\n        if self.up == '+z':\n            self.tf_mat.matrix = self.transform.as_matrix().matrix\n        else:\n            rr = self._real_rect\n            d = d if (self.up[0] == '+') else -d\n            pp1 = [(vbr.left, vbr.bottom, 0), (vbr.left, vbr.top, 0),\n                   (vbr.right, vbr.bottom, 0), (vbr.left, vbr.bottom, 1)]\n            # Get Mapping\n            if self.up[1] == 'z':\n                pp2 = [(rr.left, rr.bottom, 0), (rr.left, rr.top, 0),\n                       (rr.right, rr.bottom, 0), (rr.left, rr.bottom, d)]\n            elif self.up[1] == 'y':\n                pp2 = [(rr.left, 0, rr.bottom), (rr.left, 0, rr.top),\n                       (rr.right, 0, rr.bottom), (rr.left, d, rr.bottom)]\n            elif self.up[1] == 'x':\n                pp2 = [(0, rr.left, rr.bottom), (0, rr.left, rr.top),\n                       (0, rr.right, rr.bottom), (d, rr.left, rr.bottom)]\n\n            # Apply\n            self.tf_mat.set_mapping(np.array(pp2), np.array(pp1))\n\n        # Set on viewbox\n        self._set_scene_transform(self.tf_mat)",
  "def __init__(self, rect=DEFAULT_RECT_TUPLE, aspect=None, **kwargs):\n        super(PanZoomCamera, self).__init__(**kwargs)\n\n        self.transform = STTransform()\n        self.tf_mat = MatrixTransform()\n\n        # Set camera attributes\n        self.aspect = aspect\n        self._rect = None\n        self.rect = rect",
  "def aspect(self):\n        \"\"\"The ratio between the x and y dimension. E.g. to show a\n        square image as square, the aspect should be 1. If None, the\n        dimensions are scaled automatically, dependening on the\n        available space. Otherwise the ratio between the dimensions\n        is fixed.\n        \"\"\"\n        return self._aspect",
  "def aspect(self, value):\n        if value is None:\n            self._aspect = None\n        else:\n            self._aspect = float(value)\n        self.view_changed()",
  "def zoom(self, factor, center=None):\n        \"\"\"Zoom in (or out) at the given center\n\n        Parameters\n        ----------\n        factor : float or tuple\n            Fraction by which the scene should be zoomed (e.g. a factor of 2\n            causes the scene to appear twice as large).\n        center : tuple of 2-4 elements\n            The center of the view. If not given or None, use the\n            current center.\n        \"\"\"\n        # Init some variables\n        center = center if (center is not None) else self.center\n        assert len(center) in (2, 3, 4)\n        # Get scale factor, take scale ratio into account\n        if np.isscalar(factor):\n            scale = [factor, factor]\n        else:\n            if len(factor) != 2:\n                raise TypeError(\"factor must be scalar or length-2 sequence.\")\n            scale = list(factor)\n        if self.aspect is not None:\n            scale[0] = scale[1]\n\n        # Make a new object (copy), so that allocation will\n        # trigger view_changed:\n        rect = Rect(self.rect)\n        # Get space from given center to edges\n        left_space = center[0] - rect.left\n        right_space = rect.right - center[0]\n        bottom_space = center[1] - rect.bottom\n        top_space = rect.top - center[1]\n        # Scale these spaces\n        rect.left = center[0] - left_space * scale[0]\n        rect.right = center[0] + right_space * scale[0]\n        rect.bottom = center[1] - bottom_space * scale[1]\n        rect.top = center[1] + top_space * scale[1]\n        self.rect = rect",
  "def pan(self, *pan):\n        \"\"\"Pan the view.\n\n        Parameters\n        ----------\n        *pan : length-2 sequence\n            The distance to pan the view, in the coordinate system of the\n            scene.\n        \"\"\"\n        if len(pan) == 1:\n            pan = pan[0]\n        self.rect = self.rect + pan",
  "def rect(self):\n        \"\"\"The rectangular border of the ViewBox visible area.\n        \n        This is expressed in the coordinate system of the scene.\n        See :class:`~vispy.geometry.rect.Rect` for different ways this can\n        be specified.\n\n        Note that the rectangle can have negative width or height, in\n        which case the corresponding dimension is flipped (this flipping\n        is independent from the camera's ``flip`` property).\n        \"\"\"\n        return self._rect",
  "def rect(self, args):\n        if isinstance(args, tuple):\n            rect = Rect(*args)\n        else:\n            rect = Rect(args)\n\n        if self._rect != rect:\n            self._rect = rect\n            self.view_changed()",
  "def center(self):\n        rect = self._rect\n        return (*rect.center, 0)",
  "def center(self, center):\n        if not (isinstance(center, (tuple, list)) and len(center) in (2, 3)):\n            raise ValueError('center must be a 2 or 3 element tuple')\n        rect = Rect(self.rect) or Rect(*DEFAULT_RECT_TUPLE)\n        rect.center = center[:2]\n        self.rect = rect",
  "def _set_range(self, init):\n        if init and self._rect is not None:\n            return\n        # Convert limits to rect\n        w = self._xlim[1] - self._xlim[0]\n        h = self._ylim[1] - self._ylim[0]\n        self.rect = self._xlim[0], self._ylim[0], w, h",
  "def viewbox_resize_event(self, event):\n        \"\"\"Modify the data aspect and scale factor, to adjust to\n        the new window size.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.view_changed()",
  "def viewbox_mouse_event(self, event):\n        \"\"\"\n        The SubScene received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        # Scrolling\n        BaseCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_wheel':\n            center = self._scene_transform.imap(event.pos)\n            self.zoom((1 + self.zoom_factor)**(-event.delta[1] * 30), center)\n            event.handled = True\n\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n\n            if 1 in event.buttons and not modifiers:\n                # Translate\n                p1 = np.array(event.last_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1s = self._transform.imap(p1)\n                p2s = self._transform.imap(p2)\n                self.pan(p1s - p2s)\n                event.handled = True\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                p1c = np.array(event.last_event.pos)[:2]\n                p2c = np.array(event.pos)[:2]\n                scale = ((1 + self.zoom_factor)**((p1c - p2c) *\n                                                  np.array([1, -1])))\n                center = self._transform.imap(event.press_event.pos[:2])\n                self.zoom(scale, center)\n                event.handled = True\n            else:\n                event.handled = False\n        elif event.type == 'mouse_press':\n            # accept the event if it is button 1 or 2.\n            # This is required in order to receive future events\n            event.handled = event.button in [1, 2]\n        else:\n            event.handled = False",
  "def _update_transform(self):\n        rect = self.rect\n        self._real_rect = Rect(rect)\n        vbr = self._viewbox.rect.flipped(x=self.flip[0], y=(not self.flip[1]))\n        d = self.depth_value\n\n        # apply scale ratio constraint\n        if self._aspect is not None:\n            # Aspect ratio of the requested range\n            requested_aspect = (rect.width /\n                                rect.height if rect.height != 0 else 1)\n            # Aspect ratio of the viewbox\n            view_aspect = vbr.width / vbr.height if vbr.height != 0 else 1\n            # View aspect ratio needed to obey the scale constraint\n            constrained_aspect = abs(view_aspect / self._aspect)\n\n            if requested_aspect > constrained_aspect:\n                # view range needs to be taller than requested\n                dy = 0.5 * (rect.width / constrained_aspect - rect.height)\n                self._real_rect.top += dy\n                self._real_rect.bottom -= dy\n            else:\n                # view range needs to be wider than requested\n                dx = 0.5 * (rect.height * constrained_aspect - rect.width)\n                self._real_rect.left -= dx\n                self._real_rect.right += dx\n\n        # Apply mapping between viewbox and cam view\n        self.transform.set_mapping(self._real_rect, vbr, update=False)\n        # Scale z, so that the clipping planes are between -alot and +alot\n        self.transform.zoom((1, 1, 1 / d))\n\n        # We've now set self.transform, which represents our 2D\n        # transform When up is +z this is all. In other cases,\n        # self.transform is now set up correctly to allow pan/zoom, but\n        # for the scene we need a different (3D) mapping. When there\n        # is a minus in up, we simply look at the scene from the other\n        # side (as if z was flipped).\n        if self.up == '+z':\n            self.tf_mat.matrix = self.transform.as_matrix().matrix\n        else:\n            rr = self._real_rect\n            d = d if (self.up[0] == '+') else -d\n            pp1 = [(vbr.left, vbr.bottom, 0), (vbr.left, vbr.top, 0),\n                   (vbr.right, vbr.bottom, 0), (vbr.left, vbr.bottom, 1)]\n            # Get Mapping\n            if self.up[1] == 'z':\n                pp2 = [(rr.left, rr.bottom, 0), (rr.left, rr.top, 0),\n                       (rr.right, rr.bottom, 0), (rr.left, rr.bottom, d)]\n            elif self.up[1] == 'y':\n                pp2 = [(rr.left, 0, rr.bottom), (rr.left, 0, rr.top),\n                       (rr.right, 0, rr.bottom), (rr.left, d, rr.bottom)]\n            elif self.up[1] == 'x':\n                pp2 = [(0, rr.left, rr.bottom), (0, rr.left, rr.top),\n                       (0, rr.right, rr.bottom), (d, rr.left, rr.bottom)]\n\n            # Apply\n            self.tf_mat.set_mapping(np.array(pp2), np.array(pp1))\n\n        # Set on viewbox\n        self._set_scene_transform(self.tf_mat)",
  "class MagnifyCamera(PanZoomCamera):\n    \"\"\"Camera implementing a MagnifyTransform combined with PanZoomCamera.\n\n    Parameters\n    ----------\n    size_factor : float\n        The size factor to use.\n    radius_ratio : float\n        The radius ratio to use.\n    **kwargs : dict\n        Keyword arguments to pass to `PanZoomCamera` and create a transform.\n\n    Notes\n    -----\n    This Camera uses the mouse cursor position to set the center position of\n    the MagnifyTransform, and uses mouse wheel events to adjust the \n    magnification factor.\n\n    At high magnification, very small mouse movements can result in large\n    changes, so we use a timer to animate transitions in the transform \n    properties.\n\n    The camera also adjusts the size of its \"lens\" area when the view is\n    resized.\n    \"\"\"\n\n    transform_class = MagnifyTransform\n\n    def __init__(self, size_factor=0.25, radius_ratio=0.9, **kwargs):\n        # what fraction of the view width to use for radius\n        self.size_factor = size_factor\n\n        # ratio of inner to outer lens radius\n        self.radius_ratio = radius_ratio\n\n        # Extract kwargs for panzoom\n        camkwargs = {}\n        for key in ('parent', 'name', 'rect', 'aspect'):\n            if key in kwargs:\n                camkwargs[key] = kwargs.pop(key)\n\n        # Create the mag transform - kwrds go here\n        self.mag = self.transform_class(**kwargs)\n\n        # for handling smooth transitions\n        self.mag_target = self.mag.mag\n        self.mag._mag = self.mag_target\n        self.mouse_pos = None\n        self.timer = Timer(interval=0.016, connect=self.on_timer)\n\n        super(MagnifyCamera, self).__init__(**camkwargs)\n\n        # This tells the camera to insert the magnification transform at the\n        # beginning of the transform it applies to the scene. This is the \n        # correct place for the mag transform because:\n        # 1. We want it to apply to everything inside the scene, and not to\n        #    the ViewBox itself or anything outside of the ViewBox.\n        # 2. We do _not_ want the pan/zoom transforms applied first, because\n        #    the scale factors implemented there should not change the shape\n        #    of the lens.\n        self.pre_transform = self.mag\n\n    def _viewbox_set(self, viewbox):\n        PanZoomCamera._viewbox_set(self, viewbox)\n\n    def _viewbox_unset(self, viewbox):\n        PanZoomCamera._viewbox_unset(self, viewbox)\n        self.timer.stop()\n\n    def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The mouse event.\n        \"\"\"\n        # When the attached ViewBox reseives a mouse event, it is sent to the\n        # camera here.\n\n        self.mouse_pos = event.pos[:2]\n        if event.type == 'mouse_wheel':\n            # wheel rolled; adjust the magnification factor and hide the \n            # event from the superclass\n            m = self.mag_target \n            m *= 1.2 ** event.delta[1]\n            m = m if m > 1 else 1\n            self.mag_target = m\n        else:\n            # send everything _except_ wheel events to the superclass\n            super(MagnifyCamera, self).viewbox_mouse_event(event)\n\n        # start the timer to smoothly modify the transform properties. \n        if not self.timer.running:\n            self.timer.start()\n\n        self._update_transform()\n\n    def on_timer(self, event=None):\n        \"\"\"Timer event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The timer event.\n        \"\"\"\n        # Smoothly update center and magnification properties of the transform\n        k = np.clip(100. / self.mag.mag, 10, 100)\n        s = 10**(-k * event.dt)\n\n        c = np.array(self.mag.center)\n        c1 = c * s + self.mouse_pos * (1-s)\n\n        m = self.mag.mag * s + self.mag_target * (1-s)\n\n        # If changes are very small, then it is safe to stop the timer.\n        if (np.all(np.abs((c - c1) / c1) < 1e-5) and \n                (np.abs(np.log(m / self.mag.mag)) < 1e-3)):\n            self.timer.stop()\n\n        self.mag.center = c1\n        self.mag.mag = m\n\n        self._update_transform()\n\n    def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The viewbox resize event.\n        \"\"\"\n        PanZoomCamera.viewbox_resize_event(self, event)\n        self.view_changed()\n\n    def view_changed(self):\n        # make sure radii are updated when a view is attached.\n        # when the view resizes, we change the lens radii to match.\n        if self._viewbox is not None:\n            vbs = self._viewbox.size\n            r = min(vbs) * self.size_factor\n            self.mag.radii = r * self.radius_ratio, r\n\n        PanZoomCamera.view_changed(self)",
  "class Magnify1DCamera(MagnifyCamera):\n    transform_class = Magnify1DTransform\n    __doc__ = MagnifyCamera.__doc__",
  "def __init__(self, size_factor=0.25, radius_ratio=0.9, **kwargs):\n        # what fraction of the view width to use for radius\n        self.size_factor = size_factor\n\n        # ratio of inner to outer lens radius\n        self.radius_ratio = radius_ratio\n\n        # Extract kwargs for panzoom\n        camkwargs = {}\n        for key in ('parent', 'name', 'rect', 'aspect'):\n            if key in kwargs:\n                camkwargs[key] = kwargs.pop(key)\n\n        # Create the mag transform - kwrds go here\n        self.mag = self.transform_class(**kwargs)\n\n        # for handling smooth transitions\n        self.mag_target = self.mag.mag\n        self.mag._mag = self.mag_target\n        self.mouse_pos = None\n        self.timer = Timer(interval=0.016, connect=self.on_timer)\n\n        super(MagnifyCamera, self).__init__(**camkwargs)\n\n        # This tells the camera to insert the magnification transform at the\n        # beginning of the transform it applies to the scene. This is the \n        # correct place for the mag transform because:\n        # 1. We want it to apply to everything inside the scene, and not to\n        #    the ViewBox itself or anything outside of the ViewBox.\n        # 2. We do _not_ want the pan/zoom transforms applied first, because\n        #    the scale factors implemented there should not change the shape\n        #    of the lens.\n        self.pre_transform = self.mag",
  "def _viewbox_set(self, viewbox):\n        PanZoomCamera._viewbox_set(self, viewbox)",
  "def _viewbox_unset(self, viewbox):\n        PanZoomCamera._viewbox_unset(self, viewbox)\n        self.timer.stop()",
  "def viewbox_mouse_event(self, event):\n        \"\"\"The ViewBox mouse event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The mouse event.\n        \"\"\"\n        # When the attached ViewBox reseives a mouse event, it is sent to the\n        # camera here.\n\n        self.mouse_pos = event.pos[:2]\n        if event.type == 'mouse_wheel':\n            # wheel rolled; adjust the magnification factor and hide the \n            # event from the superclass\n            m = self.mag_target \n            m *= 1.2 ** event.delta[1]\n            m = m if m > 1 else 1\n            self.mag_target = m\n        else:\n            # send everything _except_ wheel events to the superclass\n            super(MagnifyCamera, self).viewbox_mouse_event(event)\n\n        # start the timer to smoothly modify the transform properties. \n        if not self.timer.running:\n            self.timer.start()\n\n        self._update_transform()",
  "def on_timer(self, event=None):\n        \"\"\"Timer event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The timer event.\n        \"\"\"\n        # Smoothly update center and magnification properties of the transform\n        k = np.clip(100. / self.mag.mag, 10, 100)\n        s = 10**(-k * event.dt)\n\n        c = np.array(self.mag.center)\n        c1 = c * s + self.mouse_pos * (1-s)\n\n        m = self.mag.mag * s + self.mag_target * (1-s)\n\n        # If changes are very small, then it is safe to stop the timer.\n        if (np.all(np.abs((c - c1) / c1) < 1e-5) and \n                (np.abs(np.log(m / self.mag.mag)) < 1e-3)):\n            self.timer.stop()\n\n        self.mag.center = c1\n        self.mag.mag = m\n\n        self._update_transform()",
  "def viewbox_resize_event(self, event):\n        \"\"\"The ViewBox resize event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The viewbox resize event.\n        \"\"\"\n        PanZoomCamera.viewbox_resize_event(self, event)\n        self.view_changed()",
  "def view_changed(self):\n        # make sure radii are updated when a view is attached.\n        # when the view resizes, we change the lens radii to match.\n        if self._viewbox is not None:\n            vbs = self._viewbox.size\n            r = min(vbs) * self.size_factor\n            self.mag.radii = r * self.radius_ratio, r\n\n        PanZoomCamera.view_changed(self)",
  "class ArcballCamera(Base3DRotationCamera):\n    \"\"\"3D camera class that orbits around a center point while\n    maintaining a view on a center point.\n\n    For this camera, the ``scale_factor`` indicates the zoom level, and\n    the ``center`` indicates the position to put at the center of the\n    view.\n\n    Parameters\n    ----------\n    fov : float\n        Field of view. Zero (default) means orthographic projection.\n    distance : float | None\n        The distance of the camera from the rotation point (only makes sense\n        if fov > 0). If None (default) the distance is determined from the\n        scale_factor and fov.\n    translate_speed : float\n        Scale factor on translation speed when moving the camera center point.\n    **kwargs : dict\n        Keyword arguments to pass to `BaseCamera`.\n\n    Notes\n    -----\n    Interaction:\n\n        * LMB: orbits the view around its center point.\n        * RMB or scroll: change scale_factor (i.e. zoom level)\n        * SHIFT + LMB: translate the center point\n        * SHIFT + RMB: change FOV\n\n    \"\"\"\n\n    _state_props = Base3DRotationCamera._state_props + ('_quaternion',)\n\n    def __init__(self, fov=45.0, distance=None, translate_speed=1.0, **kwargs):\n        super(ArcballCamera, self).__init__(fov=fov, **kwargs)\n\n        # Set camera attributes\n        self._quaternion = Quaternion()\n        self.distance = distance  # None means auto-distance\n        self.translate_speed = translate_speed\n\n    def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = p2\n        wh = self._viewbox.size\n        self._quaternion = (Quaternion(*_arcball(p2, wh)) *\n                            Quaternion(*_arcball(self._event_value, wh)) *\n                            self._quaternion)\n        self._event_value = p2\n        self.view_changed()\n\n    def _get_rotation_tr(self):\n        \"\"\"Return a rotation matrix based on camera parameters\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        return transforms.rotate(180 * rot / np.pi, (x, z, y))\n\n    def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        tr = MatrixTransform()\n        tr.rotate(180 * rot / np.pi, (x, y, z))\n        dx, dz, dy = np.dot(tr.matrix[:3, :3],\n                            (dist[0], dist[1], 0.)) * self.translate_speed\n        return dx, dy, dz\n\n    def _get_dim_vectors(self):\n        # Override vectors, camera has no sense of \"up\"\n        return np.eye(3)[::-1]",
  "def _arcball(xy, wh):\n    \"\"\"Convert x,y coordinates to w,x,y,z Quaternion parameters\n\n    Adapted from:\n\n    linalg library\n\n    Copyright (c) 2010-2015, Renaud Blanch <rndblnch at gmail dot com>\n    Licence at your convenience:\n    GPLv3 or higher <http://www.gnu.org/licenses/gpl.html>\n    BSD new <http://opensource.org/licenses/BSD-3-Clause>\n    \"\"\"\n    x, y = xy\n    w, h = wh\n    r = (w + h) / 2.\n    x, y = -(2. * x - w) / r, (2. * y - h) / r\n    h = np.sqrt(x*x + y*y)\n    return (0., x/h, y/h, 0.) if h > 1. else (0., x, y, np.sqrt(1. - h*h))",
  "def __init__(self, fov=45.0, distance=None, translate_speed=1.0, **kwargs):\n        super(ArcballCamera, self).__init__(fov=fov, **kwargs)\n\n        # Set camera attributes\n        self._quaternion = Quaternion()\n        self.distance = distance  # None means auto-distance\n        self.translate_speed = translate_speed",
  "def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = p2\n        wh = self._viewbox.size\n        self._quaternion = (Quaternion(*_arcball(p2, wh)) *\n                            Quaternion(*_arcball(self._event_value, wh)) *\n                            self._quaternion)\n        self._event_value = p2\n        self.view_changed()",
  "def _get_rotation_tr(self):\n        \"\"\"Return a rotation matrix based on camera parameters\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        return transforms.rotate(180 * rot / np.pi, (x, z, y))",
  "def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        tr = MatrixTransform()\n        tr.rotate(180 * rot / np.pi, (x, y, z))\n        dx, dz, dy = np.dot(tr.matrix[:3, :3],\n                            (dist[0], dist[1], 0.)) * self.translate_speed\n        return dx, dy, dz",
  "def _get_dim_vectors(self):\n        # Override vectors, camera has no sense of \"up\"\n        return np.eye(3)[::-1]",
  "def encoding_for_ctype(vartype):\n    typecodes = {c_char: b'c', c_int: b'i', c_short: b's', c_long: b'l',\n                 c_longlong: b'q', c_ubyte: b'C', c_uint: b'I', c_ushort: b'S',\n                 c_ulong: b'L', c_ulonglong: b'Q', c_float: b'f',\n                 c_double: b'd', c_bool: b'B', c_char_p: b'*', c_void_p: b'@',\n                 py_object: PyObjectEncoding}\n    return typecodes.get(vartype, b'?')",
  "class NSPoint(Structure):\n    _fields_ = [(\"x\", CGFloat), (\"y\", CGFloat)]",
  "class NSSize(Structure):\n    _fields_ = [(\"width\", CGFloat), (\"height\", CGFloat)]",
  "class NSRect(Structure):\n    _fields_ = [(\"origin\", NSPoint), (\"size\", NSSize)]",
  "class CFRange(Structure):\n    _fields_ = [(\"location\", CFIndex), (\"length\", CFIndex)]",
  "class NSRange(Structure):\n    _fields_ = [(\"location\", NSUInteger), (\"length\", NSUInteger)]",
  "class OBJC_METHOD_DESCRIPTION(Structure):\n    _fields_ = [(\"name\", c_void_p), (\"types\", c_char_p)]",
  "def ensure_bytes(x):\n    if isinstance(x, bytes):\n        return x\n    return x.encode('ascii')",
  "def get_selector(name):\n    return c_void_p(objc.sel_registerName(ensure_bytes(name)))",
  "def get_class(name):\n    return c_void_p(objc.objc_getClass(ensure_bytes(name)))",
  "def get_object_class(obj):\n    return c_void_p(objc.object_getClass(obj))",
  "def get_metaclass(name):\n    return c_void_p(objc.objc_getMetaClass(ensure_bytes(name)))",
  "def get_superclass_of_object(obj):\n    cls = c_void_p(objc.object_getClass(obj))\n    return c_void_p(objc.class_getSuperclass(cls))",
  "def x86_should_use_stret(restype):\n    if not isinstance(restype, type(Structure)):\n        return False\n    if not __LP64__ and sizeof(restype) <= 8:\n        return False\n    if __LP64__ and sizeof(restype) <= 16:  # maybe? I don't know?\n        return False\n    return True",
  "def should_use_fpret(restype):\n    if not __i386__:\n        return False\n    if __LP64__ and restype == c_longdouble:\n        return True\n    if not __LP64__ and restype in (c_float, c_double, c_longdouble):\n        return True\n    return False",
  "def send_message(receiver, selName, *args, **kwargs):\n    if isinstance(receiver, string_types):\n        receiver = get_class(receiver)\n    selector = get_selector(selName)\n    restype = kwargs.get('restype', c_void_p)\n    argtypes = kwargs.get('argtypes', [])\n    if should_use_fpret(restype):\n        objc.objc_msgSend_fpret.restype = restype\n        objc.objc_msgSend_fpret.argtypes = [c_void_p, c_void_p] + argtypes\n        result = objc.objc_msgSend_fpret(receiver, selector, *args)\n    elif x86_should_use_stret(restype):\n        objc.objc_msgSend_stret.argtypes = [POINTER(restype), c_void_p,\n                                            c_void_p] + argtypes\n        result = restype()\n        objc.objc_msgSend_stret(byref(result), receiver, selector, *args)\n    else:\n        objc.objc_msgSend.restype = restype\n        objc.objc_msgSend.argtypes = [c_void_p, c_void_p] + argtypes\n        result = objc.objc_msgSend(receiver, selector, *args)\n        if restype == c_void_p:\n            result = c_void_p(result)\n    return result",
  "class OBJC_SUPER(Structure):\n    _fields_ = [('receiver', c_void_p), ('class', c_void_p)]",
  "def send_super(receiver, selName, *args, **kwargs):\n    if hasattr(receiver, '_as_parameter_'):\n        receiver = receiver._as_parameter_\n    superclass = get_superclass_of_object(receiver)\n    super_struct = OBJC_SUPER(receiver, superclass)\n    selector = get_selector(selName)\n    restype = kwargs.get('restype', c_void_p)\n    argtypes = kwargs.get('argtypes', None)\n    objc.objc_msgSendSuper.restype = restype\n    if argtypes:\n        objc.objc_msgSendSuper.argtypes = [OBJC_SUPER_PTR, c_void_p] + argtypes\n    else:\n        objc.objc_msgSendSuper.argtypes = None\n    result = objc.objc_msgSendSuper(byref(super_struct), selector, *args)\n    if restype == c_void_p:\n        result = c_void_p(result)\n    return result",
  "def parse_type_encoding(encoding):\n    type_encodings = []\n    brace_count = 0    # number of unclosed curly braces\n    bracket_count = 0  # number of unclosed square brackets\n    typecode = b''\n    for c in encoding:\n        if isinstance(c, int):\n            c = bytes([c])\n\n        if c == b'{':\n            if typecode and typecode[-1:] != b'^' and brace_count == 0 and \\\n                    bracket_count == 0:\n                type_encodings.append(typecode)\n                typecode = b''\n            typecode += c\n            brace_count += 1\n        elif c == b'}':\n            typecode += c\n            brace_count -= 1\n            assert(brace_count >= 0)\n        elif c == b'[':\n            if typecode and typecode[-1:] != b'^' and brace_count == 0 and \\\n                    bracket_count == 0:\n                type_encodings.append(typecode)\n                typecode = b''\n            typecode += c\n            bracket_count += 1\n        elif c == b']':\n            typecode += c\n            bracket_count -= 1\n            assert(bracket_count >= 0)\n        elif brace_count or bracket_count:\n            typecode += c\n        elif c in b'0123456789':\n            pass\n        elif c in b'rnNoORV':\n            pass\n        elif c in b'^cislqCISLQfdBv*@#:b?':\n            if typecode and typecode[-1:] == b'^':\n                typecode += c\n            else:\n                if typecode:\n                    type_encodings.append(typecode)\n                typecode = c\n\n    if typecode:\n        type_encodings.append(typecode)\n\n    return type_encodings",
  "def cfunctype_for_encoding(encoding):\n    if encoding in cfunctype_table:\n        return cfunctype_table[encoding]\n    typecodes = {b'c': c_char, b'i': c_int, b's': c_short, b'l': c_long,\n                 b'q': c_longlong, b'C': c_ubyte, b'I': c_uint, b'S': c_ushort,\n                 b'L': c_ulong, b'Q': c_ulonglong, b'f': c_float,\n                 b'd': c_double, b'B': c_bool, b'v': None, b'*': c_char_p,\n                 b'@': c_void_p, b'#': c_void_p, b':': c_void_p,\n                 NSPointEncoding: NSPoint, NSSizeEncoding: NSSize,\n                 NSRectEncoding: NSRect, NSRangeEncoding: NSRange,\n                 PyObjectEncoding: py_object}\n    argtypes = []\n    for code in parse_type_encoding(encoding):\n        if code in typecodes:\n            argtypes.append(typecodes[code])\n        elif code[0:1] == b'^' and code[1:] in typecodes:\n            argtypes.append(POINTER(typecodes[code[1:]]))\n        else:\n            raise Exception('unknown type encoding: ' + code)\n\n    cfunctype = CFUNCTYPE(*argtypes)\n    cfunctype_table[encoding] = cfunctype\n    return cfunctype",
  "def create_subclass(superclass, name):\n    if isinstance(superclass, string_types):\n        superclass = get_class(superclass)\n    return c_void_p(objc.objc_allocateClassPair(superclass,\n                                                ensure_bytes(name), 0))",
  "def register_subclass(subclass):\n    objc.objc_registerClassPair(subclass)",
  "def add_method(cls, selName, method, types):\n    type_encodings = parse_type_encoding(types)\n    assert(type_encodings[1] == b'@')  # ensure id self typecode\n    assert(type_encodings[2] == b':')  # ensure SEL cmd typecode\n    selector = get_selector(selName)\n    cfunctype = cfunctype_for_encoding(types)\n    imp = cfunctype(method)\n    objc.class_addMethod.argtypes = [c_void_p, c_void_p, cfunctype, c_char_p]\n    objc.class_addMethod(cls, selector, imp, types)\n    return imp",
  "def add_ivar(cls, name, vartype):\n    return objc.class_addIvar(cls, ensure_bytes(name), sizeof(vartype),\n                              alignment(vartype), encoding_for_ctype(vartype))",
  "def set_instance_variable(obj, varname, value, vartype):\n    objc.object_setInstanceVariable.argtypes = [c_void_p, c_char_p, vartype]\n    objc.object_setInstanceVariable(obj, ensure_bytes(varname), value)",
  "def get_instance_variable(obj, varname, vartype):\n    variable = vartype()\n    objc.object_getInstanceVariable(obj, ensure_bytes(varname),\n                                    byref(variable))\n    return variable.value",
  "class ObjCMethod(object):\n    \"\"\"This represents an unbound Objective-C method (really an IMP).\"\"\"\n\n    typecodes = {b'c': c_byte, b'i': c_int, b's': c_short, b'l': c_long,\n                 b'q': c_longlong, b'C': c_ubyte, b'I': c_uint, b'S': c_ushort,\n                 b'L': c_ulong, b'Q': c_ulonglong, b'f': c_float,\n                 b'd': c_double, b'B': c_bool, b'v': None, b'Vv': None,\n                 b'*': c_char_p, b'@': c_void_p, b'#': c_void_p,\n                 b':': c_void_p, b'^v': c_void_p, b'?': c_void_p,\n                 NSPointEncoding: NSPoint, NSSizeEncoding: NSSize,\n                 NSRectEncoding: NSRect, NSRangeEncoding: NSRange,\n                 PyObjectEncoding: py_object}\n    cfunctype_table = {}\n\n    def __init__(self, method):\n        self.selector = c_void_p(objc.method_getName(method))\n        self.name = objc.sel_getName(self.selector)\n        self.pyname = self.name.replace(b':', b'_')\n        self.encoding = objc.method_getTypeEncoding(method)\n        self.return_type = objc.method_copyReturnType(method)\n        self.nargs = objc.method_getNumberOfArguments(method)\n        self.imp = c_void_p(objc.method_getImplementation(method))\n        self.argument_types = []\n        for i in range(self.nargs):\n            buffer = c_buffer(512)\n            objc.method_getArgumentType(method, i, buffer, len(buffer))\n            self.argument_types.append(buffer.value)\n        try:\n            self.argtypes = [self.ctype_for_encoding(t)\n                             for t in self.argument_types]\n        except ValueError:\n            self.argtypes = None\n        try:\n            if self.return_type == b'@':\n                self.restype = ObjCInstance\n            elif self.return_type == b'#':\n                self.restype = ObjCClass\n            else:\n                self.restype = self.ctype_for_encoding(self.return_type)\n        except ValueError:\n            self.restype = None\n        self.func = None\n\n    def ctype_for_encoding(self, encoding):\n        \"\"\"Return ctypes type for an encoded Objective-C type.\"\"\"\n        if encoding in self.typecodes:\n            return self.typecodes[encoding]\n        elif encoding[0:1] == b'^' and encoding[1:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[1:]])\n        elif encoding[0:1] == b'^' and encoding[1:] in [CGImageEncoding,\n                                                        NSZoneEncoding]:\n            return c_void_p\n        elif encoding[0:1] == b'r' and encoding[1:] in self.typecodes:\n            return self.typecodes[encoding[1:]]\n        elif encoding[0:2] == b'r^' and encoding[2:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[2:]])\n        else:\n            raise ValueError('unknown encoding for %s: %s'\n                             % (self.name, encoding))\n\n    def get_prototype(self):\n        if self.restype == ObjCInstance or self.restype == ObjCClass:\n            self.prototype = CFUNCTYPE(c_void_p, *self.argtypes)\n        else:\n            self.prototype = CFUNCTYPE(self.restype, *self.argtypes)\n        return self.prototype\n\n    def __repr__(self):\n        return \"<ObjCMethod: %s %s>\" % (self.name, self.encoding)\n\n    def get_callable(self):\n        if not self.func:\n            prototype = self.get_prototype()\n            self.func = cast(self.imp, prototype)\n            if self.restype == ObjCInstance or self.restype == ObjCClass:\n                self.func.restype = c_void_p\n            else:\n                self.func.restype = self.restype\n            self.func.argtypes = self.argtypes\n        return self.func\n\n    def __call__(self, objc_id, *args):\n        f = self.get_callable()\n        try:\n            result = f(objc_id, self.selector, *args)\n            if self.restype == ObjCInstance:\n                result = ObjCInstance(result)\n            elif self.restype == ObjCClass:\n                result = ObjCClass(result)\n            return result\n        except ArgumentError as error:\n            error.args += ('selector = ' + self.name,\n                           'argtypes =' + str(self.argtypes),\n                           'encoding = ' + self.encoding)\n            raise",
  "class ObjCBoundMethod(object):\n    def __init__(self, method, objc_id):\n        self.method = method\n        self.objc_id = objc_id\n\n    def __repr__(self):\n        return '<ObjCBoundMethod %s (%s)>' % (self.method.name, self.objc_id)\n\n    def __call__(self, *args):\n        return self.method(self.objc_id, *args)",
  "class ObjCClass(object):\n    _registered_classes = {}\n\n    def __new__(cls, class_name_or_ptr):\n        if isinstance(class_name_or_ptr, string_types):\n            name = class_name_or_ptr\n            ptr = get_class(name)\n        else:\n            ptr = class_name_or_ptr\n            if not isinstance(ptr, c_void_p):\n                ptr = c_void_p(ptr)\n            name = objc.class_getName(ptr)\n\n        if name in cls._registered_classes:\n            return cls._registered_classes[name]\n\n        objc_class = super(ObjCClass, cls).__new__(cls)\n        objc_class.ptr = ptr\n        objc_class.name = name\n        objc_class.instance_methods = {}   # mapping of name -> instance method\n        objc_class.class_methods = {}      # mapping of name -> class method\n        objc_class._as_parameter_ = ptr    # for ctypes argument passing\n\n        cls._registered_classes[name] = objc_class\n        objc_class.cache_instance_methods()\n        objc_class.cache_class_methods()\n        return objc_class\n\n    def __repr__(self):\n        return \"<ObjCClass: %s at %s>\" % (self.name, str(self.ptr.value))\n\n    def cache_instance_methods(self):\n        count = c_uint()\n        method_array = objc.class_copyMethodList(self.ptr, byref(count))\n        for i in range(count.value):\n            method = c_void_p(method_array[i])\n            objc_method = ObjCMethod(method)\n            self.instance_methods[objc_method.pyname] = objc_method\n\n    def cache_class_methods(self):\n        count = c_uint()\n        args = [objc.object_getClass(self.ptr), byref(count)]\n        method_array = objc.class_copyMethodList(*args)\n        for i in range(count.value):\n            method = c_void_p(method_array[i])\n            objc_method = ObjCMethod(method)\n            self.class_methods[objc_method.pyname] = objc_method\n\n    def get_instance_method(self, name):\n        if name in self.instance_methods:\n            return self.instance_methods[name]\n        else:\n            selector = get_selector(name.replace(b'_', b':'))\n            method = c_void_p(objc.class_getInstanceMethod(self.ptr, selector))\n            if method.value:\n                objc_method = ObjCMethod(method)\n                self.instance_methods[name] = objc_method\n                return objc_method\n        return None\n\n    def get_class_method(self, name):\n        if name in self.class_methods:\n            return self.class_methods[name]\n        else:\n            selector = get_selector(name.replace(b'_', b':'))\n            method = c_void_p(objc.class_getClassMethod(self.ptr, selector))\n            if method.value:\n                objc_method = ObjCMethod(method)\n                self.class_methods[name] = objc_method\n                return objc_method\n        return None\n\n    def __getattr__(self, name):\n        name = ensure_bytes(name)\n        method = self.get_class_method(name)\n        if method:\n            return ObjCBoundMethod(method, self.ptr)\n        method = self.get_instance_method(name)\n        if method:\n            return method\n        raise AttributeError('ObjCClass %s has no attribute %s'\n                             % (self.name, name))",
  "class ObjCInstance(object):\n    _cached_objects = {}\n\n    def __new__(cls, object_ptr):\n        if not isinstance(object_ptr, c_void_p):\n            object_ptr = c_void_p(object_ptr)\n        if not object_ptr.value:\n            return None\n        if object_ptr.value in cls._cached_objects:\n            return cls._cached_objects[object_ptr.value]\n\n        objc_instance = super(ObjCInstance, cls).__new__(cls)\n        objc_instance.ptr = object_ptr\n        objc_instance._as_parameter_ = object_ptr\n        class_ptr = c_void_p(objc.object_getClass(object_ptr))\n        objc_instance.objc_class = ObjCClass(class_ptr)\n\n        cls._cached_objects[object_ptr.value] = objc_instance\n        observer = send_message(send_message('DeallocationObserver', 'alloc'),\n                                'initWithObject:', objc_instance)\n        objc.objc_setAssociatedObject(objc_instance, observer, observer, 0x301)\n        send_message(observer, 'release')\n        return objc_instance\n\n    def __repr__(self):\n        if self.objc_class.name == b'NSCFString':\n            from .cocoalibs import cfstring_to_string\n            string = cfstring_to_string(self)\n            return (\"<ObjCInstance %#x: %s (%s) at %s>\"\n                    % (id(self), self.objc_class.name, string,\n                       str(self.ptr.value)))\n        return (\"<ObjCInstance %#x: %s at %s>\"\n                % (id(self), self.objc_class.name, str(self.ptr.value)))\n\n    def __getattr__(self, name):\n        name = ensure_bytes(name)\n        method = self.objc_class.get_instance_method(name)\n        if method:\n            return ObjCBoundMethod(method, self)\n        method = self.objc_class.get_class_method(name)\n        if method:\n            return ObjCBoundMethod(method, self.objc_class.ptr)\n        keys = list(self.objc_class.instance_methods.keys())\n        raise AttributeError('ObjCInstance %s has no attribute %s, only:\\n%s'\n                             % (self.objc_class.name, name, keys))",
  "def convert_method_arguments(encoding, args):\n    new_args = []\n    arg_encodings = parse_type_encoding(encoding)[3:]\n    for e, a in zip(arg_encodings, args):\n        if e == b'@':\n            new_args.append(ObjCInstance(a))\n        elif e == b'#':\n            new_args.append(ObjCClass(a))\n        else:\n            new_args.append(a)\n    return new_args",
  "class ObjCSubclass(object):\n\n    def __init__(self, superclass, name, register=True):\n        self._imp_table = {}\n        self.name = name\n        self.objc_cls = create_subclass(superclass, name)\n        self._as_parameter_ = self.objc_cls\n        if register:\n            self.register()\n\n    def register(self):\n        objc.objc_registerClassPair(self.objc_cls)\n        self.objc_metaclass = get_metaclass(self.name)\n\n    def add_ivar(self, varname, vartype):\n        return add_ivar(self.objc_cls, varname, vartype)\n\n    def add_method(self, method, name, encoding):\n        imp = add_method(self.objc_cls, name, method, encoding)\n        self._imp_table[name] = imp\n\n    def add_class_method(self, method, name, encoding):\n        imp = add_method(self.objc_metaclass, name, method, encoding)\n        self._imp_table[name] = imp\n\n    def rawmethod(self, encoding):\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            name = f.__name__.replace('_', ':')\n            self.add_method(f, name, encoding)\n            return f\n        return decorator\n\n    def method(self, encoding):\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            def objc_method(objc_self, objc_cmd, *args):\n                py_self = ObjCInstance(objc_self)\n                py_self.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_self, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_method(objc_method, name, encoding)\n            return objc_method\n        return decorator\n\n    def classmethod(self, encoding):\n        \"\"\"Function decorator for class methods.\"\"\"\n        # Add encodings for hidden self and cmd arguments.\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            def objc_class_method(objc_cls, objc_cmd, *args):\n                py_cls = ObjCClass(objc_cls)\n                py_cls.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_cls, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_class_method(objc_class_method, name, encoding)\n            return objc_class_method\n        return decorator",
  "def CFSTR(string):\n    args = [None, string.encode('utf8'), kCFStringEncodingUTF8]\n    return ObjCInstance(c_void_p(cf.CFStringCreateWithCString(*args)))",
  "def get_NSString(string):\n    \"\"\"Autoreleased version of CFSTR\"\"\"\n    return CFSTR(string).autorelease()",
  "def cfstring_to_string(cfstring):\n    length = cf.CFStringGetLength(cfstring)\n    size = cf.CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8)\n    buffer = c_buffer(size + 1)\n    result = cf.CFStringGetCString(cfstring, buffer, len(buffer),\n                                   kCFStringEncodingUTF8)\n    if result:\n        return buffer.value.decode('utf8')",
  "def cfnumber_to_number(cfnumber):\n    \"\"\"Convert CFNumber to python int or float.\"\"\"\n    numeric_type = cf.CFNumberGetType(cfnumber)\n    cfnum_to_ctype = {kCFNumberSInt8Type: c_int8, kCFNumberSInt16Type: c_int16,\n                      kCFNumberSInt32Type: c_int32,\n                      kCFNumberSInt64Type: c_int64,\n                      kCFNumberFloat32Type: c_float,\n                      kCFNumberFloat64Type: c_double,\n                      kCFNumberCharType: c_byte, kCFNumberShortType: c_short,\n                      kCFNumberIntType: c_int, kCFNumberLongType: c_long,\n                      kCFNumberLongLongType: c_longlong,\n                      kCFNumberFloatType: c_float,\n                      kCFNumberDoubleType: c_double,\n                      kCFNumberCFIndexType: CFIndex,\n                      kCFNumberCGFloatType: CGFloat}\n\n    if numeric_type in cfnum_to_ctype:\n        t = cfnum_to_ctype[numeric_type]\n        result = t()\n        if cf.CFNumberGetValue(cfnumber, numeric_type, byref(result)):\n            return result.value\n    else:\n        raise Exception(\n            'cfnumber_to_number: unhandled CFNumber type %d' % numeric_type)",
  "def cftype_to_value(cftype):\n    \"\"\"Convert a CFType into an equivalent python type.\n    The convertible CFTypes are taken from the known_cftypes\n    dictionary, which may be added to if another library implements\n    its own conversion methods.\n    \"\"\"\n    if not cftype:\n        return None\n    typeID = cf.CFGetTypeID(cftype)\n    if typeID in known_cftypes:\n        convert_function = known_cftypes[typeID]\n        return convert_function(cftype)\n    else:\n        return cftype",
  "def cfset_to_set(cfset):\n    \"\"\"Convert CFSet to python set.\"\"\"\n    count = cf.CFSetGetCount(cfset)\n    buffer = (c_void_p * count)()\n    cf.CFSetGetValues(cfset, byref(buffer))\n    return set([cftype_to_value(c_void_p(buffer[i])) for i in range(count)])",
  "def cfarray_to_list(cfarray):\n    \"\"\"Convert CFArray to python list.\"\"\"\n    count = cf.CFArrayGetCount(cfarray)\n    return [cftype_to_value(c_void_p(cf.CFArrayGetValueAtIndex(cfarray, i)))\n            for i in range(count)]",
  "def __init__(self, method):\n        self.selector = c_void_p(objc.method_getName(method))\n        self.name = objc.sel_getName(self.selector)\n        self.pyname = self.name.replace(b':', b'_')\n        self.encoding = objc.method_getTypeEncoding(method)\n        self.return_type = objc.method_copyReturnType(method)\n        self.nargs = objc.method_getNumberOfArguments(method)\n        self.imp = c_void_p(objc.method_getImplementation(method))\n        self.argument_types = []\n        for i in range(self.nargs):\n            buffer = c_buffer(512)\n            objc.method_getArgumentType(method, i, buffer, len(buffer))\n            self.argument_types.append(buffer.value)\n        try:\n            self.argtypes = [self.ctype_for_encoding(t)\n                             for t in self.argument_types]\n        except ValueError:\n            self.argtypes = None\n        try:\n            if self.return_type == b'@':\n                self.restype = ObjCInstance\n            elif self.return_type == b'#':\n                self.restype = ObjCClass\n            else:\n                self.restype = self.ctype_for_encoding(self.return_type)\n        except ValueError:\n            self.restype = None\n        self.func = None",
  "def ctype_for_encoding(self, encoding):\n        \"\"\"Return ctypes type for an encoded Objective-C type.\"\"\"\n        if encoding in self.typecodes:\n            return self.typecodes[encoding]\n        elif encoding[0:1] == b'^' and encoding[1:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[1:]])\n        elif encoding[0:1] == b'^' and encoding[1:] in [CGImageEncoding,\n                                                        NSZoneEncoding]:\n            return c_void_p\n        elif encoding[0:1] == b'r' and encoding[1:] in self.typecodes:\n            return self.typecodes[encoding[1:]]\n        elif encoding[0:2] == b'r^' and encoding[2:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[2:]])\n        else:\n            raise ValueError('unknown encoding for %s: %s'\n                             % (self.name, encoding))",
  "def get_prototype(self):\n        if self.restype == ObjCInstance or self.restype == ObjCClass:\n            self.prototype = CFUNCTYPE(c_void_p, *self.argtypes)\n        else:\n            self.prototype = CFUNCTYPE(self.restype, *self.argtypes)\n        return self.prototype",
  "def __repr__(self):\n        return \"<ObjCMethod: %s %s>\" % (self.name, self.encoding)",
  "def get_callable(self):\n        if not self.func:\n            prototype = self.get_prototype()\n            self.func = cast(self.imp, prototype)\n            if self.restype == ObjCInstance or self.restype == ObjCClass:\n                self.func.restype = c_void_p\n            else:\n                self.func.restype = self.restype\n            self.func.argtypes = self.argtypes\n        return self.func",
  "def __call__(self, objc_id, *args):\n        f = self.get_callable()\n        try:\n            result = f(objc_id, self.selector, *args)\n            if self.restype == ObjCInstance:\n                result = ObjCInstance(result)\n            elif self.restype == ObjCClass:\n                result = ObjCClass(result)\n            return result\n        except ArgumentError as error:\n            error.args += ('selector = ' + self.name,\n                           'argtypes =' + str(self.argtypes),\n                           'encoding = ' + self.encoding)\n            raise",
  "def __init__(self, method, objc_id):\n        self.method = method\n        self.objc_id = objc_id",
  "def __repr__(self):\n        return '<ObjCBoundMethod %s (%s)>' % (self.method.name, self.objc_id)",
  "def __call__(self, *args):\n        return self.method(self.objc_id, *args)",
  "def __new__(cls, class_name_or_ptr):\n        if isinstance(class_name_or_ptr, string_types):\n            name = class_name_or_ptr\n            ptr = get_class(name)\n        else:\n            ptr = class_name_or_ptr\n            if not isinstance(ptr, c_void_p):\n                ptr = c_void_p(ptr)\n            name = objc.class_getName(ptr)\n\n        if name in cls._registered_classes:\n            return cls._registered_classes[name]\n\n        objc_class = super(ObjCClass, cls).__new__(cls)\n        objc_class.ptr = ptr\n        objc_class.name = name\n        objc_class.instance_methods = {}   # mapping of name -> instance method\n        objc_class.class_methods = {}      # mapping of name -> class method\n        objc_class._as_parameter_ = ptr    # for ctypes argument passing\n\n        cls._registered_classes[name] = objc_class\n        objc_class.cache_instance_methods()\n        objc_class.cache_class_methods()\n        return objc_class",
  "def __repr__(self):\n        return \"<ObjCClass: %s at %s>\" % (self.name, str(self.ptr.value))",
  "def cache_instance_methods(self):\n        count = c_uint()\n        method_array = objc.class_copyMethodList(self.ptr, byref(count))\n        for i in range(count.value):\n            method = c_void_p(method_array[i])\n            objc_method = ObjCMethod(method)\n            self.instance_methods[objc_method.pyname] = objc_method",
  "def cache_class_methods(self):\n        count = c_uint()\n        args = [objc.object_getClass(self.ptr), byref(count)]\n        method_array = objc.class_copyMethodList(*args)\n        for i in range(count.value):\n            method = c_void_p(method_array[i])\n            objc_method = ObjCMethod(method)\n            self.class_methods[objc_method.pyname] = objc_method",
  "def get_instance_method(self, name):\n        if name in self.instance_methods:\n            return self.instance_methods[name]\n        else:\n            selector = get_selector(name.replace(b'_', b':'))\n            method = c_void_p(objc.class_getInstanceMethod(self.ptr, selector))\n            if method.value:\n                objc_method = ObjCMethod(method)\n                self.instance_methods[name] = objc_method\n                return objc_method\n        return None",
  "def get_class_method(self, name):\n        if name in self.class_methods:\n            return self.class_methods[name]\n        else:\n            selector = get_selector(name.replace(b'_', b':'))\n            method = c_void_p(objc.class_getClassMethod(self.ptr, selector))\n            if method.value:\n                objc_method = ObjCMethod(method)\n                self.class_methods[name] = objc_method\n                return objc_method\n        return None",
  "def __getattr__(self, name):\n        name = ensure_bytes(name)\n        method = self.get_class_method(name)\n        if method:\n            return ObjCBoundMethod(method, self.ptr)\n        method = self.get_instance_method(name)\n        if method:\n            return method\n        raise AttributeError('ObjCClass %s has no attribute %s'\n                             % (self.name, name))",
  "def __new__(cls, object_ptr):\n        if not isinstance(object_ptr, c_void_p):\n            object_ptr = c_void_p(object_ptr)\n        if not object_ptr.value:\n            return None\n        if object_ptr.value in cls._cached_objects:\n            return cls._cached_objects[object_ptr.value]\n\n        objc_instance = super(ObjCInstance, cls).__new__(cls)\n        objc_instance.ptr = object_ptr\n        objc_instance._as_parameter_ = object_ptr\n        class_ptr = c_void_p(objc.object_getClass(object_ptr))\n        objc_instance.objc_class = ObjCClass(class_ptr)\n\n        cls._cached_objects[object_ptr.value] = objc_instance\n        observer = send_message(send_message('DeallocationObserver', 'alloc'),\n                                'initWithObject:', objc_instance)\n        objc.objc_setAssociatedObject(objc_instance, observer, observer, 0x301)\n        send_message(observer, 'release')\n        return objc_instance",
  "def __repr__(self):\n        if self.objc_class.name == b'NSCFString':\n            from .cocoalibs import cfstring_to_string\n            string = cfstring_to_string(self)\n            return (\"<ObjCInstance %#x: %s (%s) at %s>\"\n                    % (id(self), self.objc_class.name, string,\n                       str(self.ptr.value)))\n        return (\"<ObjCInstance %#x: %s at %s>\"\n                % (id(self), self.objc_class.name, str(self.ptr.value)))",
  "def __getattr__(self, name):\n        name = ensure_bytes(name)\n        method = self.objc_class.get_instance_method(name)\n        if method:\n            return ObjCBoundMethod(method, self)\n        method = self.objc_class.get_class_method(name)\n        if method:\n            return ObjCBoundMethod(method, self.objc_class.ptr)\n        keys = list(self.objc_class.instance_methods.keys())\n        raise AttributeError('ObjCInstance %s has no attribute %s, only:\\n%s'\n                             % (self.objc_class.name, name, keys))",
  "def __init__(self, superclass, name, register=True):\n        self._imp_table = {}\n        self.name = name\n        self.objc_cls = create_subclass(superclass, name)\n        self._as_parameter_ = self.objc_cls\n        if register:\n            self.register()",
  "def register(self):\n        objc.objc_registerClassPair(self.objc_cls)\n        self.objc_metaclass = get_metaclass(self.name)",
  "def add_ivar(self, varname, vartype):\n        return add_ivar(self.objc_cls, varname, vartype)",
  "def add_method(self, method, name, encoding):\n        imp = add_method(self.objc_cls, name, method, encoding)\n        self._imp_table[name] = imp",
  "def add_class_method(self, method, name, encoding):\n        imp = add_method(self.objc_metaclass, name, method, encoding)\n        self._imp_table[name] = imp",
  "def rawmethod(self, encoding):\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            name = f.__name__.replace('_', ':')\n            self.add_method(f, name, encoding)\n            return f\n        return decorator",
  "def method(self, encoding):\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            def objc_method(objc_self, objc_cmd, *args):\n                py_self = ObjCInstance(objc_self)\n                py_self.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_self, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_method(objc_method, name, encoding)\n            return objc_method\n        return decorator",
  "def classmethod(self, encoding):\n        \"\"\"Function decorator for class methods.\"\"\"\n        # Add encodings for hidden self and cmd arguments.\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            def objc_class_method(objc_cls, objc_cmd, *args):\n                py_cls = ObjCClass(objc_cls)\n                py_cls.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_cls, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_class_method(objc_class_method, name, encoding)\n            return objc_class_method\n        return decorator",
  "def new_util_find_library(name):\n        res = orig_util_find_library(name)\n        if res:\n            return res\n        lut = {\n            'objc': 'libobjc.dylib',\n            'quartz': 'Quartz.framework/Quartz'\n        }\n        return lut.get(name, name+'.framework/'+name)",
  "def decorator(f):\n            name = f.__name__.replace('_', ':')\n            self.add_method(f, name, encoding)\n            return f",
  "def decorator(f):\n            def objc_method(objc_self, objc_cmd, *args):\n                py_self = ObjCInstance(objc_self)\n                py_self.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_self, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_method(objc_method, name, encoding)\n            return objc_method",
  "def decorator(f):\n            def objc_class_method(objc_cls, objc_cmd, *args):\n                py_cls = ObjCClass(objc_cls)\n                py_cls.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_cls, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_class_method(objc_class_method, name, encoding)\n            return objc_class_method",
  "def objc_method(objc_self, objc_cmd, *args):\n                py_self = ObjCInstance(objc_self)\n                py_self.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_self, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result",
  "def objc_class_method(objc_cls, objc_cmd, *args):\n                py_cls = ObjCClass(objc_cls)\n                py_cls.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_cls, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result",
  "def eglGetError():\n    \"\"\"Check for errors, returns an enum (int).\"\"\"\n    return _lib.eglGetError()",
  "def eglGetDisplay(display=EGL_DEFAULT_DISPLAY):\n    \"\"\"Connect to the EGL display server.\"\"\"\n    res = _lib.eglGetDisplay(display)\n    if not res or res == EGL_NO_DISPLAY:\n        raise RuntimeError('Could not create display')\n    return c_void_p(res)",
  "def eglInitialize(display):\n    \"\"\"Initialize EGL and return EGL version tuple.\"\"\"\n    majorVersion = (_c_int*1)()\n    minorVersion = (_c_int*1)()\n    res = _lib.eglInitialize(display, majorVersion, minorVersion)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not initialize')\n    return majorVersion[0], minorVersion[0]",
  "def eglTerminate(display):\n    \"\"\"Terminate an EGL display connection.\"\"\"\n    _lib.eglTerminate(display)",
  "def eglQueryString(display, name):\n    \"\"\"Query string from display\"\"\"\n    out = _lib.eglQueryString(display, name)\n    if not out:\n        raise RuntimeError('Could not query %s' % name)\n    return out",
  "def _convert_attrib_list(attribList):\n    attribList = attribList or []\n    attribList = [a for a in attribList] + [EGL_NONE]\n    attribList = (_c_int*len(attribList))(*attribList)\n    return attribList",
  "def eglChooseConfig(display, attribList=DEFAULT_ATTRIB_LIST):\n    attribList = _convert_attrib_list(attribList)\n    numConfigs = (_c_int*1)()\n    _lib.eglChooseConfig(display, attribList, None, 0, numConfigs)\n    n = numConfigs[0]\n    if n <= 0:\n        raise RuntimeError('Could not find any suitable config.')\n    config = (c_void_p*n)()\n    _lib.eglChooseConfig(display, attribList, config, n, numConfigs)\n    return config",
  "def _check_res(res):\n    if res == EGL_NO_SURFACE:\n        e = eglGetError()\n    else:\n        return res\n    if e == EGL_BAD_MATCH:\n        raise ValueError('Cannot create surface: attributes do not match ' +\n                         'or given config cannot render in window.')\n    elif e == EGL_BAD_CONFIG:\n        raise ValueError('Cannot create surface: given config is not ' +\n                         'supported by this system.')\n    elif e == EGL_BAD_NATIVE_WINDOW:\n        raise ValueError('Cannot create surface: the given native window ' +\n                         'handle is invalid.')\n    elif e == EGL_BAD_ALLOC:\n        raise RuntimeError('Could not allocate surface: not enough ' +\n                           'resources or native window already associated ' +\n                           'with another config.')\n    else:\n        raise RuntimeError('Could not create window surface due to ' +\n                           'unknown error: %i' % e)",
  "def eglCreateWindowSurface(display, config, window, attribList=None):\n    # Deal with attrib list\n    attribList = _convert_attrib_list(attribList)\n    surface = c_void_p(_lib.eglCreateWindowSurface(display, config, window, attribList))\n    return _check_res(surface)",
  "def eglCreatePbufferSurface(display, config, attribList=None):\n    # Deal with attrib list\n    attribList = _convert_attrib_list(attribList)\n    #\n    surface = c_void_p(_lib.eglCreatePbufferSurface(display, config, attribList))\n    return _check_res(surface)",
  "def eglCreateContext(display, config, shareContext=EGL_NO_CONTEXT,\n                     attribList=None):\n    # Deal with attrib list\n    attribList = attribList or [EGL_CONTEXT_CLIENT_VERSION, 2]\n    attribList = [a for a in attribList] + [EGL_NONE]\n    attribList = (_c_int*len(attribList))(*attribList)\n    #\n    res = c_void_p(_lib.eglCreateContext(display, config, shareContext, attribList))\n    if res == EGL_NO_CONTEXT:\n        e = eglGetError()\n        if e == EGL_BAD_CONFIG:\n            raise ValueError('Could not create context: given config is ' +\n                             'not supported by this system.')\n        else:\n            raise RuntimeError('Could not create context due to ' +\n                               'unknown error: %i' % e)\n    return res",
  "def eglMakeCurrent(display, draw, read, context):\n    res = _lib.eglMakeCurrent(display, draw, read, context)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not make the context current.')",
  "def eglBindAPI(api):\n    \"\"\"Set the current rendering API (OpenGL, OpenGL ES or OpenVG)\"\"\"\n    res = _lib.eglBindAPI(api)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not bind API %d' % api)\n    return res",
  "def eglSwapBuffers(display, surface):\n    res = _lib.eglSwapBuffers(display, surface)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not swap buffers.')",
  "def eglDestroySurface(display, surface):\n    res = _lib.eglDestroySurface(display, surface)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not destroy surface')",
  "def cubehelix(start=0.5, rot=1, gamma=1.0, reverse=True, nlev=256.,\n         minSat=1.2, maxSat=1.2, minLight=0., maxLight=1.,\n         **kwargs):\n    \"\"\"\n    A full implementation of Dave Green's \"cubehelix\" for Matplotlib.\n    Based on the FORTRAN 77 code provided in\n    D.A. Green, 2011, BASI, 39, 289.\n\n    http://adsabs.harvard.edu/abs/2011arXiv1108.5083G\n\n    User can adjust all parameters of the cubehelix algorithm.\n    This enables much greater flexibility in choosing color maps, while\n    always ensuring the color map scales in intensity from black\n    to white. A few simple examples:\n\n    Default color map settings produce the standard \"cubehelix\".\n\n    Create color map in only blues by setting rot=0 and start=0.\n\n    Create reverse (white to black) backwards through the rainbow once\n    by setting rot=1 and reverse=True.\n\n    Parameters\n    ----------\n    start : scalar, optional\n        Sets the starting position in the color space. 0=blue, 1=red,\n        2=green. Defaults to 0.5.\n    rot : scalar, optional\n        The number of rotations through the rainbow. Can be positive\n        or negative, indicating direction of rainbow. Negative values\n        correspond to Blue->Red direction. Defaults to -1.5\n    gamma : scalar, optional\n        The gamma correction for intensity. Defaults to 1.0\n    reverse : boolean, optional\n        Set to True to reverse the color map. Will go from black to\n        white. Good for density plots where shade~density. Defaults to False\n    nlev : scalar, optional\n        Defines the number of discrete levels to render colors at.\n        Defaults to 256.\n    sat : scalar, optional\n        The saturation intensity factor. Defaults to 1.2\n        NOTE: this was formerly known as \"hue\" parameter\n    minSat : scalar, optional\n        Sets the minimum-level saturation. Defaults to 1.2\n    maxSat : scalar, optional\n        Sets the maximum-level saturation. Defaults to 1.2\n    startHue : scalar, optional\n        Sets the starting color, ranging from [0, 360], as in\n        D3 version by @mbostock\n        NOTE: overrides values in start parameter\n    endHue : scalar, optional\n        Sets the ending color, ranging from [0, 360], as in\n        D3 version by @mbostock\n        NOTE: overrides values in rot parameter\n    minLight : scalar, optional\n        Sets the minimum lightness value. Defaults to 0.\n    maxLight : scalar, optional\n        Sets the maximum lightness value. Defaults to 1.\n\n    Returns\n    -------\n    data : ndarray, shape (N, 3)\n        Control points.\n    \"\"\"\n\n# override start and rot if startHue and endHue are set\n    if kwargs is not None:\n        if 'startHue' in kwargs:\n            start = (kwargs.get('startHue') / 360. - 1.) * 3.\n        if 'endHue' in kwargs:\n            rot = kwargs.get('endHue') / 360. - start / 3. - 1.\n        if 'sat' in kwargs:\n            minSat = kwargs.get('sat')\n            maxSat = kwargs.get('sat')\n\n# set up the parameters\n    fract = np.linspace(minLight, maxLight, nlev)\n    angle = 2.0 * pi * (start / 3.0 + rot * fract + 1.)\n    fract = fract**gamma\n\n    satar = np.linspace(minSat, maxSat, nlev)\n    amp = satar * fract * (1. - fract) / 2.\n\n# compute the RGB vectors according to main equations\n    red = fract + amp * (-0.14861 * np.cos(angle) + 1.78277 * np.sin(angle))\n    grn = fract + amp * (-0.29227 * np.cos(angle) - 0.90649 * np.sin(angle))\n    blu = fract + amp * (1.97294 * np.cos(angle))\n\n# find where RBB are outside the range [0,1], clip\n    red[np.where((red > 1.))] = 1.\n    grn[np.where((grn > 1.))] = 1.\n    blu[np.where((blu > 1.))] = 1.\n\n    red[np.where((red < 0.))] = 0.\n    grn[np.where((grn < 0.))] = 0.\n    blu[np.where((blu < 0.))] = 0.\n\n# optional color reverse\n    if reverse is True:\n        red = red[::-1]\n        blu = blu[::-1]\n        grn = grn[::-1]\n\n    return np.array((red, grn, blu)).T",
  "class POINT(Structure):\n    _fields_ = [('x', LONG), ('y', LONG)]",
  "class RECT(Structure):\n    _fields_ = [('left', LONG), ('top', LONG),\n                ('right', LONG), ('bottom', LONG)]",
  "class PANOSE(Structure):\n    _fields_ = [\n        ('bFamilyType', BYTE), ('bSerifStyle', BYTE), ('bWeight', BYTE),\n        ('bProportion', BYTE), ('bContrast', BYTE), ('bStrokeVariation', BYTE),\n        ('bArmStyle', BYTE), ('bLetterform', BYTE), ('bMidline', BYTE),\n        ('bXHeight', BYTE)]",
  "class TEXTMETRIC(Structure):\n    _fields_ = [\n        ('tmHeight', LONG), ('tmAscent', LONG), ('tmDescent', LONG),\n        ('tmInternalLeading', LONG), ('tmExternalLeading', LONG),\n        ('tmAveCharWidth', LONG), ('tmMaxCharWidth', LONG),\n        ('tmWeight', LONG), ('tmOverhang', LONG),\n        ('tmDigitizedAspectX', LONG), ('tmDigitizedAspectY', LONG),\n        ('tmFirstChar', TCHAR), ('tmLastChar', TCHAR),\n        ('tmDefaultChar', TCHAR), ('tmBreakChar', TCHAR),\n        ('tmItalic', BYTE), ('tmUnderlined', BYTE),\n        ('tmStruckOut', BYTE), ('tmPitchAndFamily', BYTE),\n        ('tmCharSet', BYTE)]",
  "class OUTLINETEXTMETRIC(Structure):\n    _fields_ = [\n        ('otmSize', UINT), ('otmTextMetrics', TEXTMETRIC),\n        ('otmMysteryBytes', BYTE), ('otmPanoseNumber', PANOSE),\n        ('otmMysteryByte', BYTE),\n        ('otmfsSelection', UINT), ('otmfsType', UINT),\n        ('otmsCharSlopeRise', INT), ('otmsCharSlopeRun', INT),\n        ('otmItalicAngle', INT), ('otmEMSquare', UINT), ('otmAscent', INT),\n        ('otmDescent', INT), ('otmLineGap', UINT), ('otmsCapEmHeight', UINT),\n        ('otmsXHeight', UINT), ('otmrcFontBox', RECT), ('otmMacAscent', INT),\n        ('otmMacDescent', INT), ('otmMacLineGap', UINT),\n        ('otmusMinimumPPEM', UINT), ('otmptSubscriptSize', POINT),\n        ('otmptSubscriptOffset', POINT), ('otmptSuperscriptSize', POINT),\n        ('otmptSuperscriptOffset', POINT), ('otmsStrikeoutSize', UINT),\n        ('otmsStrikeoutPosition', INT), ('otmsUnderscoreSize', INT),\n        ('otmsUnderscorePosition', INT), ('otmpFamilyName', PSTR),\n        ('otmpFaceName', PSTR), ('otmpStyleName', PSTR),\n        ('otmpFullName', PSTR), ('junk', (BYTE) * 1024)]",
  "class LOGFONT(Structure):\n    _fields_ = [\n        ('lfHeight', LONG), ('lfWidth', LONG), ('lfEscapement', LONG),\n        ('lfOrientation', LONG), ('lfWeight', LONG), ('lfItalic', BYTE),\n        ('lfUnderline', BYTE), ('lfStrikeOut', BYTE), ('lfCharSet', BYTE),\n        ('lfOutPrecision', BYTE), ('lfClipPrecision', BYTE),\n        ('lfQuality', BYTE), ('lfPitchAndFamily', BYTE),\n        ('lfFaceName', (TCHAR * LF_FACESIZE))]",
  "class GdiplusStartupInput(Structure):\n    _fields_ = [\n        ('GdiplusVersion', UINT32), ('DebugEventCallback', c_void_p),\n        ('SuppressBackgroundThread', BOOL), ('SuppressExternalCodecs', BOOL)]",
  "class GdiplusStartupOutput(Structure):\n    _fields = [('NotificationHookProc', c_void_p),\n               ('NotificationUnhookProc', c_void_p)]",
  "def gdiplus_init():\n    token = c_ulong()\n    startup_in = GdiplusStartupInput()\n    startup_in.GdiplusVersion = 1\n    startup_out = GdiplusStartupOutput()\n    gdiplus.GdiplusStartup(byref(token), byref(startup_in), byref(startup_out))\n    atexit.register(partial(gdiplus.GdiplusShutdown, token))",
  "def allocate_pixels_buffer(width, height):\n    \"\"\"Helper function to allocate a buffer to contain an image of\n    width * height suitable for OSMesaMakeCurrent\n    \"\"\"\n    # Seems like OSMesa has some trouble with non-RGBA buffers, so enforce\n    # RGBA\n    return (_c_uint * width * height * 4)()",
  "def OSMesaCreateContext():\n    return ctypes.cast(_lib.OSMesaCreateContext(OSMESA_RGBA, None), c_void_p)",
  "def OSMesaDestroyContext(context):\n    _lib.OSMesaDestroyContext(context)",
  "def OSMesaMakeCurrent(context, buffer, width, height):\n    ret = _lib.OSMesaMakeCurrent(context, buffer, GL_UNSIGNED_BYTE,\n                                 width, height)\n    return ret != 0",
  "def OSMesaGetCurrentContext():\n    return c_void_p(_lib.OSMesaGetCurrentContext())",
  "class _FcValueUnion(Union):\n    _fields_ = [('s', c_char_p), ('i', c_int), ('b', c_int), ('d', c_double),\n                ('m', c_void_p), ('c', c_void_p), ('f', c_void_p),\n                ('p', c_void_p), ('l', c_void_p)]",
  "class FcValue(Structure):\n    _fields_ = [('type', FcType), ('u', _FcValueUnion)]",
  "class FcFontSet(Structure):\n    _fields_ = [('nfont', c_int), ('sfont', c_int),\n                ('fonts', POINTER(c_void_p))]",
  "class FcObjectSet(Structure):\n    _fields_ = [('nobject', c_int), ('sobject', c_int), ('objects', c_void_p)]",
  "def find_font(face, bold, italic):\n    \"\"\"Find font\"\"\"\n    bold = FC_WEIGHT_BOLD if bold else FC_WEIGHT_REGULAR\n    italic = FC_SLANT_ITALIC if italic else FC_SLANT_ROMAN\n    face = face.encode('utf8')\n    fontconfig.FcInit()\n    pattern = fontconfig.FcPatternCreate()\n    fontconfig.FcPatternAddInteger(pattern, FC_WEIGHT, bold)\n    fontconfig.FcPatternAddInteger(pattern, FC_SLANT, italic)\n    fontconfig.FcPatternAddString(pattern, FC_FAMILY, face)\n    fontconfig.FcConfigSubstitute(0, pattern, FcMatchPattern)\n    fontconfig.FcDefaultSubstitute(pattern)\n    result = FcType()\n    match = fontconfig.FcFontMatch(0, pattern, byref(result))\n    fontconfig.FcPatternDestroy(pattern)\n    if not match:\n        raise RuntimeError('Could not match font \"%s\"' % face)\n    value = FcValue()\n    fontconfig.FcPatternGet(match, FC_FAMILY, 0, byref(value))\n    if(value.u.s != face):\n        warnings.warn('Could not find face match \"%s\", falling back to \"%s\"'\n                      % (face, value.u.s))\n    result = fontconfig.FcPatternGet(match, FC_FILE, 0, byref(value))\n    if result != 0:\n        raise RuntimeError('No filename or FT face for \"%s\"' % face)\n    fname = value.u.s\n    return fname.decode('utf-8')",
  "def _list_fonts():\n    \"\"\"List system fonts\"\"\"\n    stdout_, stderr = run_subprocess(['fc-list', ':scalable=true', 'family'])\n    vals = [v.split(',')[0] for v in stdout_.strip().splitlines(False)]\n    return vals",
  "def _make_png(data, level=6):\n    \"\"\"Convert numpy array to PNG byte array.\n\n    Parameters\n    ----------\n    data : numpy.ndarray\n        Data must be (H, W, 3 | 4) with dtype = np.ubyte (np.uint8)\n    level : int\n        https://docs.python.org/2/library/zlib.html#zlib.compress\n        An integer from 0 to 9 controlling the level of compression:\n\n            * 1 is fastest and produces the least compression,\n            * 9 is slowest and produces the most.\n            * 0 is no compression.\n\n        The default value is 6.\n\n    Returns\n    -------\n    png : array\n        PNG formatted array\n    \"\"\"\n    # Eventually we might want to use ext/png.py for this, but this\n    # routine *should* be faster b/c it's specialized for our use case\n\n    def mkchunk(data, name):\n        if isinstance(data, np.ndarray):\n            size = data.nbytes\n        else:\n            size = len(data)\n        chunk = np.empty(size + 12, dtype=np.ubyte)\n        chunk.data[0:4] = np.array(size, '>u4').tobytes()\n        chunk.data[4:8] = name.encode('ASCII')\n        chunk.data[8:8 + size] = data\n        # and-ing may not be necessary, but is done for safety:\n        # https://docs.python.org/3/library/zlib.html#zlib.crc32\n        chunk.data[-4:] = np.array(zlib.crc32(chunk[4:-4]) & 0xffffffff,\n                                   '>u4').tobytes()\n        return chunk\n\n    if data.dtype != np.ubyte:\n        raise TypeError('data.dtype must be np.ubyte (np.uint8)')\n\n    dim = data.shape[2]  # Dimension\n    if dim not in (3, 4):\n        raise TypeError('data.shape[2] must be in (3, 4)')\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IHDR\n    if dim == 4:\n        ctyp = 0b0110  # RGBA\n    else:\n        ctyp = 0b0010  # RGB\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Structure.html\n    header = b'\\x89PNG\\x0d\\x0a\\x1a\\x0a'  # header\n\n    h, w = data.shape[:2]\n    depth = data.itemsize * 8\n    ihdr = struct.pack('!IIBBBBB', w, h, depth, ctyp, 0, 0, 0)\n    c1 = mkchunk(ihdr, 'IHDR')\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IDAT\n    # insert filter byte at each scanline\n    idat = np.empty((h, w * dim + 1), dtype=np.ubyte)\n    idat[:, 1:] = data.reshape(h, w * dim)\n    idat[:, 0] = 0\n\n    comp_data = zlib.compress(idat, level)\n    c2 = mkchunk(comp_data, 'IDAT')\n    c3 = mkchunk(np.empty((0,), dtype=np.ubyte), 'IEND')\n\n    # concatenate\n    lh = len(header)\n    png = np.empty(lh + c1.nbytes + c2.nbytes + c3.nbytes, dtype=np.ubyte)\n    png.data[:lh] = header\n    p = lh\n\n    for chunk in (c1, c2, c3):\n        png[p:p + len(chunk)] = chunk\n        p += chunk.nbytes\n\n    return png",
  "def read_png(filename):\n    \"\"\"Read a PNG file to RGB8 or RGBA8\n    Requires Pillow.\n\n    Parameters\n    ----------\n    filename : str\n        File to read.\n\n    Returns\n    -------\n    data : array\n        Image data.\n\n    See also\n    --------\n    write_png, imread, imsave\n    \"\"\"\n    try:\n        from PIL import Image\n        x = Image.open(filename)\n        try:\n            y = np.asarray(x)\n            y = np.array([yy for yy in y], np.uint8)\n        finally:\n            x.close()\n        return y\n    except ImportError:\n        raise RuntimeError(\"read_png requires the Pillow package.\")",
  "def write_png(filename, data):\n    \"\"\"Write a PNG file\n\n    Unlike imsave, this requires no external dependencies.\n\n    Parameters\n    ----------\n    filename : str\n        File to save to.\n    data : array\n        Image data.\n\n    See also\n    --------\n    read_png, imread, imsave\n    \"\"\"\n    data = np.asarray(data)\n    if not data.ndim == 3 and data.shape[-1] in (3, 4):\n        raise ValueError('data must be a 3D array with last dimension 3 or 4')\n    with open(filename, 'wb') as f:\n        f.write(_make_png(data))",
  "def imread(filename, format=None):\n    \"\"\"Read image data from disk\n\n    Requires imageio or PIL.\n\n    Parameters\n    ----------\n    filename : str\n        Filename to read.\n    format : str | None\n        Format of the file. If None, it will be inferred from the filename.\n\n    Returns\n    -------\n    data : array\n        Image data.\n\n    See also\n    --------\n    imsave, read_png, write_png\n    \"\"\"\n    imageio, PIL = _check_img_lib()\n    if imageio is not None:\n        return imageio.imread(filename, format)\n    elif PIL is not None:\n        im = PIL.Image.open(filename)\n        if im.mode == 'P':\n            im = im.convert()\n        # Make numpy array\n        a = np.asarray(im)\n        if len(a.shape) == 0:\n            raise MemoryError(\"Too little memory to convert PIL image to \"\n                              \"array\")\n        return a\n    else:\n        raise RuntimeError(\"imread requires the imageio or PIL package.\")",
  "def imsave(filename, im, format=None):\n    \"\"\"Save image data to disk\n\n    Requires imageio or PIL.\n\n    Parameters\n    ----------\n    filename : str\n        Filename to write.\n    im : array\n        Image data.\n    format : str | None\n        Format of the file. If None, it will be inferred from the filename.\n\n    See also\n    --------\n    imread, read_png, write_png\n    \"\"\"\n    # Import imageio or PIL\n    imageio, PIL = _check_img_lib()\n    if imageio is not None:\n        return imageio.imsave(filename, im, format)\n    elif PIL is not None:\n        pim = PIL.Image.fromarray(im)\n        pim.save(filename, format)\n    else:\n        raise RuntimeError(\"imsave requires the imageio or PIL package.\")",
  "def _check_img_lib():\n    \"\"\"Utility to search for imageio or PIL\"\"\"\n    # Import imageio or PIL\n    imageio = PIL = None\n    try:\n        import imageio\n    except ImportError:\n        try:\n            import PIL.Image\n        except ImportError:\n            pass\n    return imageio, PIL",
  "def mkchunk(data, name):\n        if isinstance(data, np.ndarray):\n            size = data.nbytes\n        else:\n            size = len(data)\n        chunk = np.empty(size + 12, dtype=np.ubyte)\n        chunk.data[0:4] = np.array(size, '>u4').tobytes()\n        chunk.data[4:8] = name.encode('ASCII')\n        chunk.data[8:8 + size] = data\n        # and-ing may not be necessary, but is done for safety:\n        # https://docs.python.org/3/library/zlib.html#zlib.crc32\n        chunk.data[-4:] = np.array(zlib.crc32(chunk[4:-4]) & 0xffffffff,\n                                   '>u4').tobytes()\n        return chunk",
  "def load_iris():\n    \"\"\"Load the iris dataset\n\n    Returns\n    -------\n    iris : NpzFile\n        data['data'] : a (150, 4) NumPy array with the iris' features\n        data['group'] : a (150,) NumPy array with the iris' group\n    \"\"\"\n    return np.load(load_data_file('iris/iris.npz',\n                                  force_download='2014-09-04'))",
  "def load_crate():\n    \"\"\"Load an image of a crate\n\n    Returns\n    -------\n    crate : array\n        256x256x3 crate image.\n    \"\"\"\n    return np.load(load_data_file('orig/crate.npz'))['crate']",
  "def pack_unit(value):\n    \"\"\"Packs float values between [0,1] into 4 unsigned int8\n\n    Returns\n    -------\n    pack: array\n        packed interpolation kernel\n    \"\"\"\n    pack = np.zeros(value.shape + (4,), dtype=np.ubyte)\n    for i in range(4):\n        value, pack[..., i] = np.modf(value * 256.)\n    return pack",
  "def pack_ieee(value):\n    \"\"\"Packs float ieee binary representation into 4 unsigned int8\n\n    Returns\n    -------\n    pack: array\n        packed interpolation kernel\n    \"\"\"\n    return np.fromstring(value.tobytes(),\n                         np.ubyte).reshape((value.shape + (4,)))",
  "def load_spatial_filters(packed=True):\n    \"\"\"Load spatial-filters kernel\n\n    Parameters\n    ----------\n    packed : bool\n        Whether or not the data should be in \"packed\" representation\n        for use in GLSL code.\n\n    Returns\n    -------\n    kernel : array\n        16x1024x4 (packed float in rgba) or\n        16x1024 (unpacked float)\n        16 interpolation kernel with length 1024 each.\n\n    names : tuple of strings\n        Respective interpolation names, plus \"Nearest\" which does\n        not require a filter but can still be used\n    \"\"\"\n    names = (\"Linear\", \"Hanning\", \"Hamming\", \"Hermite\",\n             \"Kaiser\", \"Quadric\", \"Cubic\", \"CatRom\",\n             \"Mitchell\", \"Spline16\", \"Spline36\", \"Gaussian\",\n             \"Bessel\", \"Sinc\", \"Lanczos\", \"Blackman\", \"Nearest\")\n\n    kernel = np.load(op.join(DATA_DIR, 'spatial-filters.npy'))\n    if packed:\n        # convert the kernel to a packed representation\n        kernel = pack_unit(kernel)\n\n    return kernel, names",
  "def read_mesh(fname):\n    \"\"\"Read mesh data from file.\n\n    Parameters\n    ----------\n    fname : str\n        File name to read. Format will be inferred from the filename.\n        Currently only '.obj' and '.obj.gz' are supported.\n\n    Returns\n    -------\n    vertices : array\n        Vertices.\n    faces : array | None\n        Triangle face definitions.\n    normals : array\n        Normals for the mesh.\n    texcoords : array | None\n        Texture coordinates.\n    \"\"\"\n    # Check format\n    fmt = op.splitext(fname)[1].lower()\n    if fmt == '.gz':\n        fmt = op.splitext(op.splitext(fname)[0])[1].lower()\n\n    if fmt in ('.obj'):\n        return WavefrontReader.read(fname)\n    elif fmt in ('.stl'):\n        file_obj = open(fname, mode='rb')\n        mesh = load_stl(file_obj)\n        vertices = mesh['vertices']\n        faces = mesh['faces']\n        normals = mesh['face_normals']\n        texcoords = None\n        return vertices, faces, normals, texcoords\n    else:\n        try:\n            import meshio\n        except ImportError:\n            raise ValueError('read_mesh does not understand format %s.' % fmt)\n\n        try:\n            mesh = meshio.read(fname)\n        except meshio.ReadError:\n            raise ValueError('read_mesh does not understand format %s.' % fmt)\n\n        triangles = mesh.get_cells_type(\"triangle\")\n        if len(triangles) == 0:\n            raise ValueError('mesh file does not contain triangles.')\n\n        return mesh.points, triangles, None, None",
  "def write_mesh(fname, vertices, faces, normals, texcoords, name='',\n               format=None, overwrite=False, reshape_faces=True):\n    \"\"\"Write mesh data to file.\n\n    Parameters\n    ----------\n    fname : str\n        Filename to write. Must end with \".obj\" or \".gz\".\n    vertices : array\n        Vertices.\n    faces : array | None\n        Triangle face definitions.\n    normals : array\n        Normals for the mesh.\n    texcoords : array | None\n        Texture coordinates.\n    name : str\n        Name of the object.\n    format : str\n        Currently only \"obj\" is supported.\n    overwrite : bool\n        If the file exists, overwrite it.\n    reshape_faces : bool\n        Reshape the `faces` array to (Nf, 3). Set to `False`\n        if you need to write a mesh with non triangular faces.\n    \"\"\"\n    # Check file\n    if op.isfile(fname) and not overwrite:\n        raise IOError('file \"%s\" exists, use overwrite=True' % fname)\n\n    if format is None:\n        format = os.path.splitext(fname)[1][1:]\n\n    # Check format\n    if format == 'obj':\n        WavefrontWriter.write(fname, vertices, faces,\n                              normals, texcoords, name, reshape_faces)\n        return\n\n    try:\n        import meshio\n    except ImportError:\n        raise ValueError('write_mesh does not understand format %s.' % format)\n\n    cell_data = {}\n    if normals is not None:\n        cell_data[\"normals\"] = [normals]\n    if texcoords is not None:\n        cell_data[\"texcoords\"] = [texcoords]\n\n    mesh = meshio.Mesh(vertices, [(\"triangle\", faces)], cell_data=cell_data)\n\n    try:\n        mesh.write(fname, file_format=format)\n    except meshio.WriteError:\n        raise ValueError('write_mesh does not understand format %s.' % format)",
  "class WavefrontReader(object):\n\n    def __init__(self, f):\n        self._f = f\n\n        # Original vertices, normals and texture coords.\n        # These are not necessarily of the same length.\n        self._v = []\n        self._vn = []\n        self._vt = []\n\n        # Final vertices, normals and texture coords.\n        # All three lists are of the same length, as opengl wants it.\n        self._vertices = []\n        self._normals = []\n        self._texcords = []\n\n        # The faces, indices to vertex/normal/texcords arrays.\n        self._faces = []\n\n        # Dictionary to keep track of processed face data, so we can\n        # convert the original v/vn/vn to the final vertices/normals/texcords.\n        self._facemap = {}\n\n    @classmethod\n    def read(cls, fname):\n        \"\"\"Entry point for reading OBJ files.\n\n        Parameters\n        ----------\n        fname : str\n            The name of the file to read.\n\n        \"\"\"\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        assert fmt in ('.obj', '.gz')\n        opener = open if fmt == '.obj' else GzipFile\n        with opener(fname, 'rb') as f:\n            try:\n                reader = WavefrontReader(f)\n                while True:\n                    reader.readLine()\n            except EOFError:\n                pass\n\n        # Done\n        t0 = time.time()\n        mesh = reader.finish()\n        logger.debug('reading mesh took ' +\n                     str(time.time() - t0) +\n                     ' seconds')\n        return mesh\n\n    def readLine(self):\n        \"\"\"The method that reads a line and processes it.\"\"\"\n        # Read line\n        line = self._f.readline().decode('ascii', 'ignore')\n        if not line:\n            raise EOFError()\n        line = line.strip()\n\n        if line.startswith('v '):\n            # self._vertices.append( *self.readTuple(line) )\n            self._v.append(self.readTuple(line))\n        elif line.startswith('vt '):\n            self._vt.append(self.readTuple(line, 3))\n        elif line.startswith('vn '):\n            self._vn.append(self.readTuple(line))\n        elif line.startswith('f '):\n            self._faces.append(self.readFace(line))\n        elif line.startswith('#'):\n            pass  # Comment\n        elif line.startswith('mtllib '):\n            logger.warning('Notice reading .OBJ: material properties are '\n                           'ignored.')\n        elif any(line.startswith(x) for x in ('g ', 's ', 'o ', 'usemtl ')):\n            pass  # Ignore groups and smoothing groups, obj names, material\n        elif not line.strip():\n            pass\n        else:\n            logger.warning('Notice reading .OBJ: ignoring %s command.'\n                           % line.strip())\n\n    def readTuple(self, line, n=3):\n        \"\"\"Reads a tuple of numbers. e.g. vertices, normals or teture coords.\"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]\n\n    def readFace(self, line):\n        \"\"\"Each face consists of three or more sets of indices. Each set\n        consists of 1, 2 or 3 indices to vertices/normals/texcords.\n        \"\"\"\n        # Get parts (skip first)\n        indexSets = [num for num in line.split(' ') if num][1:]\n\n        final_face = []\n        for indexSet in indexSets:\n\n            # Did we see this exact index earlier? If so, it's easy\n            final_index = self._facemap.get(indexSet)\n            if final_index is not None:\n                final_face.append(final_index)\n                continue\n\n            # If not, we need to sync the vertices/normals/texcords ...\n\n            # Get and store final index\n            final_index = len(self._vertices)\n            final_face.append(final_index)\n            self._facemap[indexSet] = final_index\n\n            # What indices were given?\n            indices = [i for i in indexSet.split('/')]\n\n            # Store new set of vertex/normal/texcords.\n            # If there is a single face that does not specify the texcord\n            # index, the texcords are ignored. Likewise for the normals.\n            if True:\n                vertex_index = self._absint(indices[0], len(self._v))\n                self._vertices.append(self._v[vertex_index])\n            if self._texcords is not None:\n                if len(indices) > 1 and indices[1]:\n                    texcord_index = self._absint(indices[1], len(self._vt))\n                    self._texcords.append(self._vt[texcord_index])\n                else:\n                    if self._texcords:\n                        logger.warning('Ignoring texture coordinates because '\n                                       'it is not specified for all faces.')\n                    self._texcords = None\n            if self._normals is not None:\n                if len(indices) > 2 and indices[2]:\n                    normal_index = self._absint(indices[2], len(self._vn))\n                    self._normals.append(self._vn[normal_index])\n                else:\n                    if self._normals:\n                        logger.warning('Ignoring normals because it is not '\n                                       'specified for all faces.')\n                    self._normals = None\n\n        # Check face\n        if self._faces and len(self._faces[0]) != len(final_face):\n            raise RuntimeError(\n                'Vispy requires that all faces are either triangles or quads.')\n\n        # Done\n        return final_face\n\n    def _absint(self, i, ref):\n        i = int(i)\n        if i > 0:\n            return i - 1\n        else:\n            return ref + i\n\n    def _calculate_normals(self):\n        vertices, faces = self._vertices, self._faces\n        if faces is None:\n            # ensure it's always 2D so we can use our methods\n            faces = np.arange(0, vertices.size, dtype=np.uint32)[:, np.newaxis]\n        normals = _calculate_normals(vertices, faces)\n        return normals\n\n    def finish(self):\n        \"\"\"Converts gathere lists to numpy arrays and creates\n        BaseMesh instance.\n        \"\"\"\n        self._vertices = np.array(self._vertices, 'float32')\n        if self._faces:\n            self._faces = np.array(self._faces, 'uint32')\n        else:\n            # Use vertices only\n            self._vertices = np.array(self._v, 'float32')\n            self._faces = None\n        if self._normals:\n            self._normals = np.array(self._normals, 'float32')\n        else:\n            self._normals = self._calculate_normals()\n        if self._texcords:\n            self._texcords = np.array(self._texcords, 'float32')\n        else:\n            self._texcords = None\n\n        return self._vertices, self._faces, self._normals, self._texcords",
  "class WavefrontWriter(object):\n\n    def __init__(self, f):\n        self._f = f\n\n    @classmethod\n    def write(cls, fname, vertices, faces, normals,\n              texcoords, name='', reshape_faces=True):\n        \"\"\"This classmethod is the entry point for writing mesh data to OBJ.\n\n        Parameters\n        ----------\n        fname : string\n            The filename to write to. Must end with \".obj\" or \".gz\".\n        vertices : numpy array\n            The vertex data\n        faces : numpy array\n            The face data\n        texcoords : numpy array\n            The texture coordinate per vertex\n        name : str\n            The name of the object (e.g. 'teapot')\n        reshape_faces : bool\n            Reshape the `faces` array to (Nf, 3). Set to `False`\n            if you need to write a mesh with non triangular faces.\n        \"\"\"\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        if fmt not in ('.obj', '.gz'):\n            raise ValueError('Filename must end with .obj or .gz, not \"%s\"'\n                             % (fmt,))\n        opener = open if fmt == '.obj' else GzipFile\n        f = opener(fname, 'wb')\n        try:\n            writer = WavefrontWriter(f)\n            writer.writeMesh(vertices, faces, normals,\n                             texcoords, name, reshape_faces=reshape_faces)\n        except EOFError:\n            pass\n        finally:\n            f.close()\n\n    def writeLine(self, text):\n        \"\"\"Simple writeLine function to write a line of code to the file.\n        The encoding is done here, and a newline character is added.\n        \"\"\"\n        text += '\\n'\n        self._f.write(text.encode('ascii'))\n\n    def writeTuple(self, val, what):\n        \"\"\"Writes a tuple of numbers (on one line).\"\"\"\n        # Limit to three values. so RGBA data drops the alpha channel\n        # Format can handle up to 3 texcords\n        val = val[:3]\n        # Make string\n        val = ' '.join([str(v) for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))\n\n    def writeFace(self, val, what='f'):\n        \"\"\"Write the face info to the net line.\"\"\"\n        # OBJ counts from 1\n        val = [v + 1 for v in val]\n        # Make string\n        if self._hasValues and self._hasNormals:\n            val = ' '.join(['%i/%i/%i' % (v, v, v) for v in val])\n        elif self._hasNormals:\n            val = ' '.join(['%i//%i' % (v, v) for v in val])\n        elif self._hasValues:\n            val = ' '.join(['%i/%i' % (v, v) for v in val])\n        else:\n            val = ' '.join(['%i' % v for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))\n\n    def writeMesh(self, vertices, faces, normals, values,\n                  name='', reshape_faces=True):\n        \"\"\"Write the given mesh instance.\"\"\"\n        # Store properties\n        self._hasNormals = normals is not None\n        self._hasValues = values is not None\n        self._hasFaces = faces is not None\n\n        # Get faces and number of vertices\n        if faces is None:\n            faces = np.arange(len(vertices))\n            reshape_faces = True\n\n        if reshape_faces:\n            Nfaces = faces.size // 3\n            faces = faces.reshape((Nfaces, 3))\n        else:\n            is_triangular = np.array([len(f) == 3\n                                      for f in faces])\n            if not(np.all(is_triangular)):\n                logger.warning('''Faces doesn't appear to be triangular,\n                be advised the file cannot be read back in vispy''')\n        # Number of vertices\n        N = vertices.shape[0]\n\n        # Get string with stats\n        stats = []\n        stats.append('%i vertices' % N)\n        if self._hasValues:\n            stats.append('%i texcords' % N)\n        else:\n            stats.append('no texcords')\n        if self._hasNormals:\n            stats.append('%i normals' % N)\n        else:\n            stats.append('no normals')\n        stats.append('%i faces' % faces.shape[0])\n\n        # Write header\n        self.writeLine('# Wavefront OBJ file')\n        self.writeLine('# Created by vispy.')\n        self.writeLine('#')\n        if name:\n            self.writeLine('# object %s' % name)\n        else:\n            self.writeLine('# unnamed object')\n        self.writeLine('# %s' % ', '.join(stats))\n        self.writeLine('')\n\n        # Write data\n        if True:\n            for i in range(N):\n                self.writeTuple(vertices[i], 'v')\n        if self._hasNormals:\n            for i in range(N):\n                self.writeTuple(normals[i], 'vn')\n        if self._hasValues:\n            for i in range(N):\n                self.writeTuple(values[i], 'vt')\n        if True:\n            for i in range(faces.shape[0]):\n                self.writeFace(faces[i])",
  "def __init__(self, f):\n        self._f = f\n\n        # Original vertices, normals and texture coords.\n        # These are not necessarily of the same length.\n        self._v = []\n        self._vn = []\n        self._vt = []\n\n        # Final vertices, normals and texture coords.\n        # All three lists are of the same length, as opengl wants it.\n        self._vertices = []\n        self._normals = []\n        self._texcords = []\n\n        # The faces, indices to vertex/normal/texcords arrays.\n        self._faces = []\n\n        # Dictionary to keep track of processed face data, so we can\n        # convert the original v/vn/vn to the final vertices/normals/texcords.\n        self._facemap = {}",
  "def read(cls, fname):\n        \"\"\"Entry point for reading OBJ files.\n\n        Parameters\n        ----------\n        fname : str\n            The name of the file to read.\n\n        \"\"\"\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        assert fmt in ('.obj', '.gz')\n        opener = open if fmt == '.obj' else GzipFile\n        with opener(fname, 'rb') as f:\n            try:\n                reader = WavefrontReader(f)\n                while True:\n                    reader.readLine()\n            except EOFError:\n                pass\n\n        # Done\n        t0 = time.time()\n        mesh = reader.finish()\n        logger.debug('reading mesh took ' +\n                     str(time.time() - t0) +\n                     ' seconds')\n        return mesh",
  "def readLine(self):\n        \"\"\"The method that reads a line and processes it.\"\"\"\n        # Read line\n        line = self._f.readline().decode('ascii', 'ignore')\n        if not line:\n            raise EOFError()\n        line = line.strip()\n\n        if line.startswith('v '):\n            # self._vertices.append( *self.readTuple(line) )\n            self._v.append(self.readTuple(line))\n        elif line.startswith('vt '):\n            self._vt.append(self.readTuple(line, 3))\n        elif line.startswith('vn '):\n            self._vn.append(self.readTuple(line))\n        elif line.startswith('f '):\n            self._faces.append(self.readFace(line))\n        elif line.startswith('#'):\n            pass  # Comment\n        elif line.startswith('mtllib '):\n            logger.warning('Notice reading .OBJ: material properties are '\n                           'ignored.')\n        elif any(line.startswith(x) for x in ('g ', 's ', 'o ', 'usemtl ')):\n            pass  # Ignore groups and smoothing groups, obj names, material\n        elif not line.strip():\n            pass\n        else:\n            logger.warning('Notice reading .OBJ: ignoring %s command.'\n                           % line.strip())",
  "def readTuple(self, line, n=3):\n        \"\"\"Reads a tuple of numbers. e.g. vertices, normals or teture coords.\"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]",
  "def readFace(self, line):\n        \"\"\"Each face consists of three or more sets of indices. Each set\n        consists of 1, 2 or 3 indices to vertices/normals/texcords.\n        \"\"\"\n        # Get parts (skip first)\n        indexSets = [num for num in line.split(' ') if num][1:]\n\n        final_face = []\n        for indexSet in indexSets:\n\n            # Did we see this exact index earlier? If so, it's easy\n            final_index = self._facemap.get(indexSet)\n            if final_index is not None:\n                final_face.append(final_index)\n                continue\n\n            # If not, we need to sync the vertices/normals/texcords ...\n\n            # Get and store final index\n            final_index = len(self._vertices)\n            final_face.append(final_index)\n            self._facemap[indexSet] = final_index\n\n            # What indices were given?\n            indices = [i for i in indexSet.split('/')]\n\n            # Store new set of vertex/normal/texcords.\n            # If there is a single face that does not specify the texcord\n            # index, the texcords are ignored. Likewise for the normals.\n            if True:\n                vertex_index = self._absint(indices[0], len(self._v))\n                self._vertices.append(self._v[vertex_index])\n            if self._texcords is not None:\n                if len(indices) > 1 and indices[1]:\n                    texcord_index = self._absint(indices[1], len(self._vt))\n                    self._texcords.append(self._vt[texcord_index])\n                else:\n                    if self._texcords:\n                        logger.warning('Ignoring texture coordinates because '\n                                       'it is not specified for all faces.')\n                    self._texcords = None\n            if self._normals is not None:\n                if len(indices) > 2 and indices[2]:\n                    normal_index = self._absint(indices[2], len(self._vn))\n                    self._normals.append(self._vn[normal_index])\n                else:\n                    if self._normals:\n                        logger.warning('Ignoring normals because it is not '\n                                       'specified for all faces.')\n                    self._normals = None\n\n        # Check face\n        if self._faces and len(self._faces[0]) != len(final_face):\n            raise RuntimeError(\n                'Vispy requires that all faces are either triangles or quads.')\n\n        # Done\n        return final_face",
  "def _absint(self, i, ref):\n        i = int(i)\n        if i > 0:\n            return i - 1\n        else:\n            return ref + i",
  "def _calculate_normals(self):\n        vertices, faces = self._vertices, self._faces\n        if faces is None:\n            # ensure it's always 2D so we can use our methods\n            faces = np.arange(0, vertices.size, dtype=np.uint32)[:, np.newaxis]\n        normals = _calculate_normals(vertices, faces)\n        return normals",
  "def finish(self):\n        \"\"\"Converts gathere lists to numpy arrays and creates\n        BaseMesh instance.\n        \"\"\"\n        self._vertices = np.array(self._vertices, 'float32')\n        if self._faces:\n            self._faces = np.array(self._faces, 'uint32')\n        else:\n            # Use vertices only\n            self._vertices = np.array(self._v, 'float32')\n            self._faces = None\n        if self._normals:\n            self._normals = np.array(self._normals, 'float32')\n        else:\n            self._normals = self._calculate_normals()\n        if self._texcords:\n            self._texcords = np.array(self._texcords, 'float32')\n        else:\n            self._texcords = None\n\n        return self._vertices, self._faces, self._normals, self._texcords",
  "def __init__(self, f):\n        self._f = f",
  "def write(cls, fname, vertices, faces, normals,\n              texcoords, name='', reshape_faces=True):\n        \"\"\"This classmethod is the entry point for writing mesh data to OBJ.\n\n        Parameters\n        ----------\n        fname : string\n            The filename to write to. Must end with \".obj\" or \".gz\".\n        vertices : numpy array\n            The vertex data\n        faces : numpy array\n            The face data\n        texcoords : numpy array\n            The texture coordinate per vertex\n        name : str\n            The name of the object (e.g. 'teapot')\n        reshape_faces : bool\n            Reshape the `faces` array to (Nf, 3). Set to `False`\n            if you need to write a mesh with non triangular faces.\n        \"\"\"\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        if fmt not in ('.obj', '.gz'):\n            raise ValueError('Filename must end with .obj or .gz, not \"%s\"'\n                             % (fmt,))\n        opener = open if fmt == '.obj' else GzipFile\n        f = opener(fname, 'wb')\n        try:\n            writer = WavefrontWriter(f)\n            writer.writeMesh(vertices, faces, normals,\n                             texcoords, name, reshape_faces=reshape_faces)\n        except EOFError:\n            pass\n        finally:\n            f.close()",
  "def writeLine(self, text):\n        \"\"\"Simple writeLine function to write a line of code to the file.\n        The encoding is done here, and a newline character is added.\n        \"\"\"\n        text += '\\n'\n        self._f.write(text.encode('ascii'))",
  "def writeTuple(self, val, what):\n        \"\"\"Writes a tuple of numbers (on one line).\"\"\"\n        # Limit to three values. so RGBA data drops the alpha channel\n        # Format can handle up to 3 texcords\n        val = val[:3]\n        # Make string\n        val = ' '.join([str(v) for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))",
  "def writeFace(self, val, what='f'):\n        \"\"\"Write the face info to the net line.\"\"\"\n        # OBJ counts from 1\n        val = [v + 1 for v in val]\n        # Make string\n        if self._hasValues and self._hasNormals:\n            val = ' '.join(['%i/%i/%i' % (v, v, v) for v in val])\n        elif self._hasNormals:\n            val = ' '.join(['%i//%i' % (v, v) for v in val])\n        elif self._hasValues:\n            val = ' '.join(['%i/%i' % (v, v) for v in val])\n        else:\n            val = ' '.join(['%i' % v for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))",
  "def writeMesh(self, vertices, faces, normals, values,\n                  name='', reshape_faces=True):\n        \"\"\"Write the given mesh instance.\"\"\"\n        # Store properties\n        self._hasNormals = normals is not None\n        self._hasValues = values is not None\n        self._hasFaces = faces is not None\n\n        # Get faces and number of vertices\n        if faces is None:\n            faces = np.arange(len(vertices))\n            reshape_faces = True\n\n        if reshape_faces:\n            Nfaces = faces.size // 3\n            faces = faces.reshape((Nfaces, 3))\n        else:\n            is_triangular = np.array([len(f) == 3\n                                      for f in faces])\n            if not(np.all(is_triangular)):\n                logger.warning('''Faces doesn't appear to be triangular,\n                be advised the file cannot be read back in vispy''')\n        # Number of vertices\n        N = vertices.shape[0]\n\n        # Get string with stats\n        stats = []\n        stats.append('%i vertices' % N)\n        if self._hasValues:\n            stats.append('%i texcords' % N)\n        else:\n            stats.append('no texcords')\n        if self._hasNormals:\n            stats.append('%i normals' % N)\n        else:\n            stats.append('no normals')\n        stats.append('%i faces' % faces.shape[0])\n\n        # Write header\n        self.writeLine('# Wavefront OBJ file')\n        self.writeLine('# Created by vispy.')\n        self.writeLine('#')\n        if name:\n            self.writeLine('# object %s' % name)\n        else:\n            self.writeLine('# unnamed object')\n        self.writeLine('# %s' % ', '.join(stats))\n        self.writeLine('')\n\n        # Write data\n        if True:\n            for i in range(N):\n                self.writeTuple(vertices[i], 'v')\n        if self._hasNormals:\n            for i in range(N):\n                self.writeTuple(normals[i], 'vn')\n        if self._hasValues:\n            for i in range(N):\n                self.writeTuple(values[i], 'vt')\n        if True:\n            for i in range(faces.shape[0]):\n                self.writeFace(faces[i])",
  "class HeaderError(Exception):\n    # the exception raised if an STL file object doesn't match its header\n    pass",
  "def load_stl(file_obj, file_type=None):\n    \"\"\"\n    Load an STL file from a file object.\n\n    Parameters\n    ----------\n    file_obj: open file- like object\n    file_type: not used\n\n    Returns\n    -------\n    loaded: kwargs for a Trimesh constructor with keys:\n              vertices:     (n,3) float, vertices\n              faces:        (m,3) int, indexes of vertices\n              face_normals: (m,3) float, normal vector of each face\n    \"\"\"\n    # save start of file obj\n    file_pos = file_obj.tell()\n    try:\n        # check the file for a header which matches the file length\n        # if that is true, it is almost certainly a binary STL file\n        # if the header doesn't match the file length a HeaderError will be\n        # raised\n        return load_stl_binary(file_obj)\n    except HeaderError:\n        # move the file back to where it was initially\n        file_obj.seek(file_pos)\n        # try to load the file as an ASCII STL\n        # if the header doesn't match the file length a HeaderError will be\n        # raised\n        return load_stl_ascii(file_obj)",
  "def load_stl_binary(file_obj):\n    \"\"\"\n    Load a binary STL file from a file object.\n\n    Parameters\n    ----------\n    file_obj: open file- like object\n\n    Returns\n    -------\n    loaded: kwargs for a Trimesh constructor with keys:\n              vertices:     (n,3) float, vertices\n              faces:        (m,3) int, indexes of vertices\n              face_normals: (m,3) float, normal vector of each face\n    \"\"\"\n    # the header is always 84 bytes long, we just reference the dtype.itemsize\n    # to be explicit about where that magical number comes from\n    header_length = _stl_dtype_header.itemsize\n    header_data = file_obj.read(header_length)\n    if len(header_data) < header_length:\n        raise HeaderError('Binary STL file not long enough to contain header!')\n\n    header = np.fromstring(header_data, dtype=_stl_dtype_header)\n\n    # now we check the length from the header versus the length of the file\n    # data_start should always be position 84, but hard coding that felt ugly\n    data_start = file_obj.tell()\n    # this seeks to the end of the file\n    # position 0, relative to the end of the file 'whence=2'\n    file_obj.seek(0, 2)\n    # we save the location of the end of the file and seek back to where we\n    # started from\n    data_end = file_obj.tell()\n    file_obj.seek(data_start)\n\n    # the binary format has a rigidly defined structure, and if the length\n    # of the file doesn't match the header, the loaded version is almost\n    # certainly going to be garbage.\n    len_data = data_end - data_start\n    len_expected = header['face_count'] * _stl_dtype.itemsize\n\n    # this check is to see if this really is a binary STL file.\n    # if we don't do this and try to load a file that isn't structured properly\n    # we will be producing garbage or crashing hard\n    # so it's much better to raise an exception here.\n    if len_data != len_expected:\n        raise HeaderError('Binary STL has incorrect length in header!')\n\n    # all of our vertices will be loaded in order due to the STL format,\n    # so faces are just sequential indices reshaped.\n    faces = np.arange(header['face_count'] * 3).reshape((-1, 3))\n    blob = np.fromstring(file_obj.read(), dtype=_stl_dtype)\n\n    result = {'vertices': blob['vertices'].reshape((-1, 3)),\n              'face_normals': blob['normals'].reshape((-1, 3)),\n              'faces': faces}\n    return result",
  "def load_stl_ascii(file_obj):\n    \"\"\"\n    Load an ASCII STL file from a file object.\n\n    Parameters\n    ----------\n    file_obj: open file- like object\n\n    Returns\n    -------\n    loaded: kwargs for a Trimesh constructor with keys:\n              vertices:     (n,3) float, vertices\n              faces:        (m,3) int, indexes of vertices\n              face_normals: (m,3) float, normal vector of each face\n    \"\"\"\n    # header (not used by this function)\n    file_obj.readline()\n\n    text = file_obj.read()\n    if hasattr(text, 'decode'):\n        text = text.decode('utf-8')\n    text = text.lower().split('endsolid')[0]\n    blob = np.array(text.split())\n\n    # there are 21 'words' in each face\n    face_len = 21\n    face_count = len(blob) / face_len\n    if (len(blob) % face_len) != 0:\n        raise HeaderError('Incorrect number of values in STL file!')\n\n    face_count = int(face_count)\n    # this offset is to be added to a fixed set of indices that is tiled\n    offset = face_len * np.arange(face_count).reshape((-1, 1))\n    normal_index = np.tile([2, 3, 4], (face_count, 1)) + offset\n    vertex_index = np.tile(\n        [8, 9, 10, 12, 13, 14, 16, 17, 18], (face_count, 1)) + offset\n\n    # faces are groups of three sequential vertices, as vertices are not\n    # references\n    faces = np.arange(face_count * 3).reshape((-1, 3))\n    face_normals = blob[normal_index].astype(np.float64)\n    vertices = blob[vertex_index.reshape((-1, 3))].astype(np.float64)\n\n    return {'vertices': vertices,\n            'faces': faces,\n            'face_normals': face_normals}",
  "def has_matplotlib(version='1.2'):\n    \"\"\"Determine if mpl is a usable version\"\"\"\n    try:\n        import matplotlib\n    except Exception:\n        has_mpl = False\n    else:\n        if LooseVersion(matplotlib.__version__) >= LooseVersion(version):\n            has_mpl = True\n        else:\n            has_mpl = False\n    return has_mpl",
  "def has_skimage(version='0.11'):\n    \"\"\"Determine if scikit-image is a usable version\"\"\"\n    try:\n        import skimage\n    except ImportError:\n        return False\n    sk_version = LooseVersion(skimage.__version__)\n    return sk_version >= LooseVersion(version)",
  "def has_backend(backend, has=(), capable=(), out=()):\n    from ..app.backends import BACKENDMAP\n    using = os.getenv('_VISPY_TESTING_APP', None)\n    if using is not None and using != backend:\n        # e.g., we are on  a 'pyglet' run but the test requires PyQt4\n        ret = (False,) if len(out) > 0 else False\n        for o in out:\n            ret += (None,)\n        return ret\n\n    # let's follow the standard code path\n    module_name = BACKENDMAP[backend.lower()][1]\n    with use_log_level('warning', print_msg=False):\n        mod = __import__('app.backends.%s' % module_name, globals(), level=2)\n    mod = getattr(mod.backends, module_name)\n    good = mod.testable\n    for h in has:\n        good = (good and getattr(mod, 'has_%s' % h))\n    for cap in capable:\n        good = (good and mod.capability[cap])\n    ret = (good,) if len(out) > 0 else good\n    for o in out:\n        ret += (getattr(mod, o),)\n    return ret",
  "def time():\n    # return reference starting time + delta of performance counters\n    return START_TIME + systime.perf_counter()",
  "class VisPyGalleryScraper:\n    \"\"\"Custom sphinx-gallery scraper to save the current Canvas to an image.\"\"\"\n\n    def __repr__(self):\n        return self.__class__.__name__\n\n    def __call__(self, block, block_vars, gallery_conf):\n        \"\"\"Scrape VisPy Canvases and applications.\n\n        Parameters\n        ----------\n        block : tuple\n            A tuple containing the (label, content, line_number) of the block.\n        block_vars : dict\n            Dict of block variables.\n        gallery_conf : dict\n            Contains the configuration of Sphinx-Gallery\n\n        Returns\n        -------\n        rst : str\n            The ReSTructuredText that will be rendered to HTML containing\n            the images. This is often produced by\n            :func:`sphinx_gallery.scrapers.figure_rst`.\n\n        \"\"\"\n        example_fn = block_vars[\"src_file\"]\n        frame_num_list = self._get_frame_list_from_source(example_fn)\n        image_path_iterator = block_vars['image_path_iterator']\n        canvas_or_widget = get_canvaslike_from_globals(block_vars[\"example_globals\"])\n        if not frame_num_list:\n            image_paths = []\n        elif isinstance(frame_num_list[0], str):\n            # example produces an image/animation as output\n            image_paths = []\n            for frame_image, image_path in zip(frame_num_list, image_path_iterator):\n                image_path = os.path.splitext(image_path)[0] + os.path.splitext(frame_image)[1]\n                shutil.move(frame_image, image_path)\n                image_paths.append(image_path)\n        else:\n            image_paths = self._save_example_to_files(\n                canvas_or_widget, frame_num_list, gallery_conf, image_path_iterator)\n\n        fig_titles = \"\"  # alt text\n        # FUTURE: Handle non-images (ex. MP4s) with raw HTML\n        return figure_rst(image_paths, gallery_conf['src_dir'], fig_titles)\n\n    def _save_example_to_files(self, canvas_or_widget, frame_num_list, gallery_conf, image_path_iterator):\n        image_path = next(image_path_iterator)\n        frame_grabber = FrameGrabber(canvas_or_widget, frame_num_list)\n        frame_grabber.collect_frames()\n        if len(frame_num_list) > 1:\n            # let's make an animation\n            # FUTURE: mp4 with imageio?\n            image_path = os.path.splitext(image_path)[0] + \".gif\"\n            frame_grabber.save_animation(image_path)\n        else:\n            frame_grabber.save_frame(image_path)\n        if 'images' in gallery_conf['compress_images']:\n            optipng(image_path, gallery_conf['compress_images_args'])\n        return [image_path]\n\n    def _get_frame_list_from_source(self, filename):\n        lines = open(filename, 'rb').read().decode('utf-8').splitlines()\n        for line in lines[:10]:\n            if not line.startswith(\"# vispy:\"):\n                continue\n            if \"gallery-exports\" in line:\n                _frames = line.split('gallery-exports')[1].split(',')[0].strip()\n                frames = self._frame_exports_to_list(_frames)\n                break\n            if \"gallery \" in line:\n                # Get what frames to grab\n                _frames = line.split('gallery')[1].split(',')[0].strip()\n                frames = self._frame_specifier_to_list(_frames)\n                break\n        else:\n            # no frame number hint - don't grab any frames\n            frames = []\n        return frames\n\n    def _frame_specifier_to_list(self, frame_specifier):\n        _frames = frame_specifier or '0'\n        frames = [int(i) for i in _frames.split(':')]\n        if not frames:\n            frames = [5]\n        if len(frames) > 1:\n            frames = list(range(*frames))\n        return frames\n\n    def _frame_exports_to_list(self, frame_specifier):\n        frames = frame_specifier.split(\" \")\n        frame_paths = []\n        for frame_fn in frames:\n            # existing image file created by the example\n            if not os.path.isfile(frame_fn):\n                raise FileNotFoundError(\n                    \"Example gallery frame specifier must be a frame number, \"\n                    \"frame range, or relative filename produced by the example.\")\n            frame_paths.append(frame_fn)\n        return frame_paths",
  "def get_canvaslike_from_globals(globals_dict):\n    qt_widget = _get_qt_top_parent(globals_dict)\n    if qt_widget is not None:\n        return qt_widget\n\n    # Get canvas\n    if \"canvas\" in globals_dict:\n        return globals_dict[\"canvas\"]\n    if \"Canvas\" in globals_dict:\n        return globals_dict[\"Canvas\"]()\n    if \"fig\" in globals_dict:\n        return globals_dict[\"fig\"]\n    return None",
  "def _get_qt_top_parent(globals_dict):\n    if \"QWidget\" not in globals_dict and \"QMainWindow\" not in globals_dict and \"QtWidgets\" not in globals_dict:\n        return None\n\n    qtwidgets = globals_dict.get(\"QtWidgets\")\n    qmainwindow = globals_dict.get(\"QMainWindow\", getattr(qtwidgets, \"QMainWindow\", None))\n    qwidget = globals_dict.get(\"QWidget\", getattr(qtwidgets, \"QWidget\", qmainwindow))\n    all_qt_widgets = [widget for widget in globals_dict.values()\n                      if isinstance(widget, qwidget) and widget is not None]\n    all_qt_mains = [widget for widget in all_qt_widgets if isinstance(widget, qmainwindow)]\n    if all_qt_mains:\n        return all_qt_mains[0]\n    if all_qt_widgets:\n        return all_qt_widgets[0]\n    return None",
  "class FrameGrabber:\n    \"\"\"Helper to grab a series of screenshots from the current Canvas-like object.\"\"\"\n\n    def __init__(self, canvas_obj, frame_grab_list: list[int]):\n        self._canvas = canvas_obj\n        self._done = False\n        self._current_frame = -1\n        self._collected_images = []\n        self._frames_to_grab = frame_grab_list[:]  # copy so original list is preserved\n\n    def on_draw(self, _):\n        if self._done:\n            return  # Grab only once\n        self._current_frame += 1\n        if self._current_frame in self._frames_to_grab:\n            self._frames_to_grab.remove(self._current_frame)\n            if isinstance(self._canvas, SceneCanvas):\n                im = self._canvas.render(alpha=True)\n            else:\n                im = _screenshot()\n            self._collected_images.append(im)\n        if not self._frames_to_grab or self._current_frame > self._frames_to_grab[0]:\n            self._done = True\n\n    def collect_frames(self):\n        \"\"\"Show current Canvas and render and collect all frames requested.\"\"\"\n        if self._is_qt_widget():\n            self._grab_qt_screenshot()\n        else:\n            self._grab_vispy_screenshots()\n\n    def _is_qt_widget(self):\n        try:\n            from PyQt5.QtWidgets import QWidget\n        except ImportError:\n            return False\n        return isinstance(self._canvas, QWidget)\n\n    def _grab_qt_screenshot(self):\n        from PyQt5.QtWidgets import QApplication\n        from PyQt5.QtCore import QTimer\n        self._canvas.show()\n        # Qt is going to grab from the screen so we need the window on top\n        self._canvas.raise_()\n        # We need to give the GUI event loop and OS time to draw everything\n        time.sleep(1.5)\n        QApplication.processEvents()\n        QTimer.singleShot(1000, self._grab_widget_screenshot)\n        time.sleep(1.5)\n        QApplication.processEvents()\n\n    def _grab_widget_screenshot(self):\n        from PyQt5.QtWidgets import QApplication\n        screen = QApplication.screenAt(self._canvas.pos())\n        screenshot = screen.grabWindow(int(self._canvas.windowHandle().winId()))\n        arr = self._qpixmap_to_ndarray(screenshot)\n        self._collected_images.append(arr)\n\n    @staticmethod\n    def _qpixmap_to_ndarray(pixmap):\n        from PyQt5 import QtGui\n        import numpy as np\n        im = pixmap.toImage().convertToFormat(QtGui.QImage.Format.Format_RGB32)\n        size = pixmap.size()\n        width = size.width()\n        height = size.height()\n        im_bits = im.constBits()\n        im_bits.setsize(height * width * 4)\n        # Convert 0xffRRGGBB buffer -> (B, G, R, 0xff) -> (R, G, B)\n        return np.array(im_bits).reshape((height, width, 4))[:, :, 2::-1]\n\n    def _grab_vispy_screenshots(self):\n        os.environ['VISPY_IGNORE_OLD_VERSION'] = 'true'\n        self._canvas.events.draw.connect(self.on_draw, position='last')\n        with self._canvas as c:\n            self._collect_frames(c)\n\n    def _collect_frames(self, canvas, limit=10000):\n        n = 0\n        while not self._done and n < limit:\n            canvas.update()\n            canvas.app.process_events()\n            n += 1\n        if n >= limit or len(self._frames_to_grab) > 0:\n            raise RuntimeError(\"Could not collect any images\")\n\n    def save_frame(self, filename, frame_index=0):\n        imsave(filename, self._collected_images[frame_index])\n\n    def save_animation(self, filename):\n        import imageio  # multiple gif not properly supported yet\n        imageio.mimsave(filename, self._collected_images)",
  "def __repr__(self):\n        return self.__class__.__name__",
  "def __call__(self, block, block_vars, gallery_conf):\n        \"\"\"Scrape VisPy Canvases and applications.\n\n        Parameters\n        ----------\n        block : tuple\n            A tuple containing the (label, content, line_number) of the block.\n        block_vars : dict\n            Dict of block variables.\n        gallery_conf : dict\n            Contains the configuration of Sphinx-Gallery\n\n        Returns\n        -------\n        rst : str\n            The ReSTructuredText that will be rendered to HTML containing\n            the images. This is often produced by\n            :func:`sphinx_gallery.scrapers.figure_rst`.\n\n        \"\"\"\n        example_fn = block_vars[\"src_file\"]\n        frame_num_list = self._get_frame_list_from_source(example_fn)\n        image_path_iterator = block_vars['image_path_iterator']\n        canvas_or_widget = get_canvaslike_from_globals(block_vars[\"example_globals\"])\n        if not frame_num_list:\n            image_paths = []\n        elif isinstance(frame_num_list[0], str):\n            # example produces an image/animation as output\n            image_paths = []\n            for frame_image, image_path in zip(frame_num_list, image_path_iterator):\n                image_path = os.path.splitext(image_path)[0] + os.path.splitext(frame_image)[1]\n                shutil.move(frame_image, image_path)\n                image_paths.append(image_path)\n        else:\n            image_paths = self._save_example_to_files(\n                canvas_or_widget, frame_num_list, gallery_conf, image_path_iterator)\n\n        fig_titles = \"\"  # alt text\n        # FUTURE: Handle non-images (ex. MP4s) with raw HTML\n        return figure_rst(image_paths, gallery_conf['src_dir'], fig_titles)",
  "def _save_example_to_files(self, canvas_or_widget, frame_num_list, gallery_conf, image_path_iterator):\n        image_path = next(image_path_iterator)\n        frame_grabber = FrameGrabber(canvas_or_widget, frame_num_list)\n        frame_grabber.collect_frames()\n        if len(frame_num_list) > 1:\n            # let's make an animation\n            # FUTURE: mp4 with imageio?\n            image_path = os.path.splitext(image_path)[0] + \".gif\"\n            frame_grabber.save_animation(image_path)\n        else:\n            frame_grabber.save_frame(image_path)\n        if 'images' in gallery_conf['compress_images']:\n            optipng(image_path, gallery_conf['compress_images_args'])\n        return [image_path]",
  "def _get_frame_list_from_source(self, filename):\n        lines = open(filename, 'rb').read().decode('utf-8').splitlines()\n        for line in lines[:10]:\n            if not line.startswith(\"# vispy:\"):\n                continue\n            if \"gallery-exports\" in line:\n                _frames = line.split('gallery-exports')[1].split(',')[0].strip()\n                frames = self._frame_exports_to_list(_frames)\n                break\n            if \"gallery \" in line:\n                # Get what frames to grab\n                _frames = line.split('gallery')[1].split(',')[0].strip()\n                frames = self._frame_specifier_to_list(_frames)\n                break\n        else:\n            # no frame number hint - don't grab any frames\n            frames = []\n        return frames",
  "def _frame_specifier_to_list(self, frame_specifier):\n        _frames = frame_specifier or '0'\n        frames = [int(i) for i in _frames.split(':')]\n        if not frames:\n            frames = [5]\n        if len(frames) > 1:\n            frames = list(range(*frames))\n        return frames",
  "def _frame_exports_to_list(self, frame_specifier):\n        frames = frame_specifier.split(\" \")\n        frame_paths = []\n        for frame_fn in frames:\n            # existing image file created by the example\n            if not os.path.isfile(frame_fn):\n                raise FileNotFoundError(\n                    \"Example gallery frame specifier must be a frame number, \"\n                    \"frame range, or relative filename produced by the example.\")\n            frame_paths.append(frame_fn)\n        return frame_paths",
  "def __init__(self, canvas_obj, frame_grab_list: list[int]):\n        self._canvas = canvas_obj\n        self._done = False\n        self._current_frame = -1\n        self._collected_images = []\n        self._frames_to_grab = frame_grab_list[:]",
  "def on_draw(self, _):\n        if self._done:\n            return  # Grab only once\n        self._current_frame += 1\n        if self._current_frame in self._frames_to_grab:\n            self._frames_to_grab.remove(self._current_frame)\n            if isinstance(self._canvas, SceneCanvas):\n                im = self._canvas.render(alpha=True)\n            else:\n                im = _screenshot()\n            self._collected_images.append(im)\n        if not self._frames_to_grab or self._current_frame > self._frames_to_grab[0]:\n            self._done = True",
  "def collect_frames(self):\n        \"\"\"Show current Canvas and render and collect all frames requested.\"\"\"\n        if self._is_qt_widget():\n            self._grab_qt_screenshot()\n        else:\n            self._grab_vispy_screenshots()",
  "def _is_qt_widget(self):\n        try:\n            from PyQt5.QtWidgets import QWidget\n        except ImportError:\n            return False\n        return isinstance(self._canvas, QWidget)",
  "def _grab_qt_screenshot(self):\n        from PyQt5.QtWidgets import QApplication\n        from PyQt5.QtCore import QTimer\n        self._canvas.show()\n        # Qt is going to grab from the screen so we need the window on top\n        self._canvas.raise_()\n        # We need to give the GUI event loop and OS time to draw everything\n        time.sleep(1.5)\n        QApplication.processEvents()\n        QTimer.singleShot(1000, self._grab_widget_screenshot)\n        time.sleep(1.5)\n        QApplication.processEvents()",
  "def _grab_widget_screenshot(self):\n        from PyQt5.QtWidgets import QApplication\n        screen = QApplication.screenAt(self._canvas.pos())\n        screenshot = screen.grabWindow(int(self._canvas.windowHandle().winId()))\n        arr = self._qpixmap_to_ndarray(screenshot)\n        self._collected_images.append(arr)",
  "def _qpixmap_to_ndarray(pixmap):\n        from PyQt5 import QtGui\n        import numpy as np\n        im = pixmap.toImage().convertToFormat(QtGui.QImage.Format.Format_RGB32)\n        size = pixmap.size()\n        width = size.width()\n        height = size.height()\n        im_bits = im.constBits()\n        im_bits.setsize(height * width * 4)\n        # Convert 0xffRRGGBB buffer -> (B, G, R, 0xff) -> (R, G, B)\n        return np.array(im_bits).reshape((height, width, 4))[:, :, 2::-1]",
  "def _grab_vispy_screenshots(self):\n        os.environ['VISPY_IGNORE_OLD_VERSION'] = 'true'\n        self._canvas.events.draw.connect(self.on_draw, position='last')\n        with self._canvas as c:\n            self._collect_frames(c)",
  "def _collect_frames(self, canvas, limit=10000):\n        n = 0\n        while not self._done and n < limit:\n            canvas.update()\n            canvas.app.process_events()\n            n += 1\n        if n >= limit or len(self._frames_to_grab) > 0:\n            raise RuntimeError(\"Could not collect any images\")",
  "def save_frame(self, filename, frame_index=0):\n        imsave(filename, self._collected_images[frame_index])",
  "def save_animation(self, filename):\n        import imageio  # multiple gif not properly supported yet\n        imageio.mimsave(filename, self._collected_images)",
  "def gaussian_filter(data, sigma):\n    \"\"\"\n    Drop-in replacement for scipy.ndimage.gaussian_filter.\n\n    (note: results are only approximately equal to the output of\n     gaussian_filter)\n    \"\"\"\n    if np.isscalar(sigma):\n        sigma = (sigma,) * data.ndim\n\n    baseline = data.mean()\n    filtered = data - baseline\n    for ax in range(data.ndim):\n        s = float(sigma[ax])\n        if s == 0:\n            continue\n\n        # generate 1D gaussian kernel\n        ksize = int(s * 6)\n        x = np.arange(-ksize, ksize)\n        kernel = np.exp(-x**2 / (2*s**2))\n        kshape = [1, ] * data.ndim\n        kshape[ax] = len(kernel)\n        kernel = kernel.reshape(kshape)\n\n        # convolve as product of FFTs\n        shape = data.shape[ax] + ksize\n        scale = 1.0 / (abs(s) * (2*np.pi)**0.5)\n        filtered = scale * np.fft.irfft(np.fft.rfft(filtered, shape, axis=ax) *\n                                        np.fft.rfft(kernel, shape, axis=ax),\n                                        axis=ax)\n\n        # clip off extra data\n        sl = [slice(None)] * data.ndim\n        sl[ax] = slice(filtered.shape[ax]-data.shape[ax], None, None)\n        filtered = filtered[tuple(sl)]\n    return filtered + baseline",
  "def stft(x, n_fft=1024, step=512, fs=2*np.pi, window='hann'):\n    \"\"\"Compute the STFT\n\n    Parameters\n    ----------\n    x : array-like\n        1D signal to operate on. ``If len(x) < n_fft``, x will be zero-padded\n        to length ``n_fft``.\n    n_fft : int\n        Number of FFT points. Much faster for powers of two.\n    step : int | None\n        Step size between calculations. If None, ``n_fft // 2``\n        will be used.\n    fs : float\n        The sample rate of the data.\n    window : str | None\n        Window function to use. Can be ``'hann'`` for Hann window, or None\n        for no windowing.\n\n    Returns\n    -------\n    stft : ndarray\n        Spectrogram of the data, shape (n_freqs, n_steps).\n\n    See also\n    --------\n    fft_freqs\n    \"\"\"\n    x = np.asarray(x, float)\n    if x.ndim != 1:\n        raise ValueError('x must be 1D')\n    if window is not None:\n        if window not in ('hann',):\n            raise ValueError('window must be \"hann\" or None')\n        w = np.hanning(n_fft)\n    else:\n        w = np.ones(n_fft)\n    n_fft = int(n_fft)\n    step = max(n_fft // 2, 1) if step is None else int(step)\n    fs = float(fs)\n    zero_pad = n_fft - len(x)\n    if zero_pad > 0:\n        x = np.concatenate((x, np.zeros(zero_pad, float)))\n    n_freqs = n_fft // 2 + 1\n    n_estimates = (len(x) - n_fft) // step + 1\n    result = np.empty((n_freqs, n_estimates), np.complex128)\n    for ii in range(n_estimates):\n        result[:, ii] = np.fft.rfft(w * x[ii * step:ii * step + n_fft]) / n_fft\n    return result",
  "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)",
  "def _get_vispy_caller():\n    \"\"\"Helper to get vispy calling function from the stack\"\"\"\n    records = inspect.stack()\n    # first few records are vispy-based logging calls\n    for record in records[5:]:\n        module = record[0].f_globals['__name__']\n        if module.startswith('vispy'):\n            line = str(record[0].f_lineno)\n            func = record[3]\n            cls = record[0].f_locals.get('self', None)\n            clsname = \"\" if cls is None else cls.__class__.__name__ + '.'\n            caller = \"{0}:{1}{2}({3}): \".format(module, clsname, func, line)\n            return caller\n    return 'unknown'",
  "class _VispyFormatter(logging.Formatter):\n    \"\"\"Formatter that optionally prepends caller\"\"\"\n\n    def __init__(self):\n        logging.Formatter.__init__(self, '%(levelname)s: %(message)s')\n        self._vispy_prepend_caller = False\n\n    def _vispy_set_prepend(self, prepend):\n        self._vispy_prepend_caller = prepend\n\n    def format(self, record):\n        out = logging.Formatter.format(self, record)\n        if self._vispy_prepend_caller:\n            out = _get_vispy_caller() + out\n        return out",
  "class _VispyStreamHandler(logging.StreamHandler):\n    \"\"\"Stream handler allowing matching and recording\n\n    This handler has two useful optional additions:\n\n        1. Recording emitted messages.\n        2. Performing regexp substring matching.\n\n    Prepending of traceback information is done in _VispyFormatter.\n    \"\"\"\n\n    def __init__(self):\n        logging.StreamHandler.__init__(self, sys.stderr)\n        self._vispy_formatter = _lf\n        self.setFormatter(self._vispy_formatter)\n        self._vispy_match = None\n        self._vispy_emit_list = list()\n        self._vispy_set_emit_record(False)\n        self._vispy_set_match(None)\n        self._vispy_print_msg = True\n\n    def _vispy_emit_match_andor_record(self, record):\n        \"\"\"Log message emitter that optionally matches and/or records\"\"\"\n        test = record.getMessage()\n        match = self._vispy_match\n        if (match is None or re.search(match, test) or\n                re.search(match, _get_vispy_caller())):\n            if self._vispy_emit_record:\n                fmt_rec = self._vispy_formatter.format(record)\n                self._vispy_emit_list.append(fmt_rec)\n            if self._vispy_print_msg:\n                return logging.StreamHandler.emit(self, record)\n            else:\n                return\n\n    def _vispy_set_match(self, match):\n        old_match = self._vispy_match\n        self._vispy_match = match\n        # Triage here to avoid a bunch of if's later (more efficient)\n        if match is not None or self._vispy_emit_record:\n            self.emit = self._vispy_emit_match_andor_record\n        else:\n            self.emit = partial(logging.StreamHandler.emit, self)\n        return old_match\n\n    def _vispy_set_emit_record(self, record):\n        self._vispy_emit_record = record\n        match = self._vispy_match\n        # Triage here to avoid a bunch of if's later (more efficient)\n        if match is not None or self._vispy_emit_record:\n            self.emit = self._vispy_emit_match_andor_record\n        else:\n            self.emit = partial(logging.StreamHandler.emit, self)\n\n    def _vispy_reset_list(self):\n        self._vispy_emit_list = list()",
  "def set_log_level(verbose, match=None, return_old=False):\n    \"\"\"Convenience function for setting the logging level\n\n    Parameters\n    ----------\n    verbose : bool, str, int, or None\n        The verbosity of messages to print. If a str, it can be either DEBUG,\n        INFO, WARNING, ERROR, or CRITICAL. Note that these are for\n        convenience and are equivalent to passing in logging.DEBUG, etc.\n        For bool, True is the same as 'INFO', False is the same as 'WARNING'.\n    match : str | None\n        String to match. Only those messages that both contain a substring\n        that regexp matches ``'match'`` (and the ``verbose`` level) will be\n        displayed.\n    return_old : bool\n        If True, return the old verbosity level and old match.\n\n    Notes\n    -----\n    If ``verbose=='debug'``, then the ``vispy`` method emitting the log\n    message will be prepended to each log message, which is useful for\n    debugging. If ``verbose=='debug'`` or ``match is not None``, then a\n    small performance overhead is added. Thus it is suggested to only use\n    these options when performance is not crucial.\n\n    See also\n    --------\n    vispy.util.use_log_level\n    \"\"\"\n    # This method is responsible for setting properties of the handler and\n    # formatter such that proper messages (possibly with the vispy caller\n    # prepended) are displayed. Storing log messages is only available\n    # via the context handler (use_log_level), so that configuration is\n    # done by the context handler itself.\n    if isinstance(verbose, bool):\n        verbose = 'info' if verbose else 'warning'\n    if isinstance(verbose, str):\n        verbose = verbose.lower()\n        if verbose not in logging_types:\n            raise ValueError('Invalid argument \"%s\"' % verbose)\n        verbose = logging_types[verbose]\n    else:\n        raise TypeError('verbose must be a bool or string')\n    logger = logging.getLogger('vispy')\n    old_verbose = logger.level\n    old_match = _lh._vispy_set_match(match)\n    logger.setLevel(verbose)\n    if verbose <= logging.DEBUG:\n        _lf._vispy_set_prepend(True)\n    else:\n        _lf._vispy_set_prepend(False)\n    out = None\n    if return_old:\n        out = (old_verbose, old_match)\n    return out",
  "class use_log_level(object):\n    \"\"\"Context manager that temporarily sets logging level\n\n    Parameters\n    ----------\n    level : str\n        See ``set_log_level`` for options.\n    match : str | None\n        The string to match.\n    record : bool\n        If True, the context manager will keep a record of the logging\n        messages generated by vispy. Otherwise, an empty list will\n        be returned.\n    print_msg : bool\n        If False, printing of (all) messages will be suppressed. This is\n        mainly useful in testing. False only works in `record=True` mode, if\n        not recording messages, consider setting `level` appropriately.\n\n    Returns\n    -------\n    records : list\n        As a context manager, an empty list or the list of logging messages\n        will be returned (depending on the input ``record``).\n    \"\"\"\n\n    # This method mostly wraps to set_log_level, but also takes\n    # care of enabling/disabling message recording in the formatter.\n\n    def __init__(self, level, match=None, record=False, print_msg=True):\n        self._new_level = level\n        self._new_match = match\n        self._print_msg = print_msg\n        self._record = record\n        if match is not None and not isinstance(match, str):\n            raise TypeError('match must be None or str')\n\n    def __enter__(self):\n        # set the log level\n        old_level, old_match = set_log_level(self._new_level,\n                                             self._new_match, return_old=True)\n        for key, value in logging_types.items():\n            if value == old_level:\n                old_level = key\n        self._old_level = old_level\n        self._old_match = old_match\n        if not self._print_msg:\n            _lh._vispy_print_msg = False\n        # set handler to record, if appropriate\n        _lh._vispy_reset_list()\n        if self._record:\n            _lh._vispy_set_emit_record(True)\n            return _lh._vispy_emit_list\n        else:\n            return list()\n\n    def __exit__(self, type, value, traceback):\n        # reset log level\n        set_log_level(self._old_level, self._old_match)\n        # reset handler\n        if self._record:\n            _lh._vispy_set_emit_record(False)\n        if not self._print_msg:\n            _lh._vispy_print_msg = True",
  "def log_exception(level='warning', tb_skip=2):\n    \"\"\"\n    Send an exception and traceback to the logger.\n\n    This function is used in cases where an exception is handled safely but\n    nevertheless should generate a descriptive error message. An extra line\n    is inserted into the stack trace indicating where the exception was caught.\n\n    Parameters\n    ----------\n    level : str\n        See ``set_log_level`` for options.\n    tb_skip : int\n        The number of traceback entries to ignore, prior to the point where\n        the exception was caught. The default is 2.\n    \"\"\"\n    stack = \"\".join(traceback.format_stack()[:-tb_skip])\n    tb = traceback.format_exception(*sys.exc_info())\n    msg = tb[0]  # \"Traceback (most recent call last):\"\n    msg += stack\n    msg += \"  << caught exception here: >>\\n\"\n    msg += \"\".join(tb[1:]).rstrip()\n    logger.log(logging_types[level], msg)",
  "def _handle_exception(ignore_callback_errors, print_callback_errors, obj,\n                      cb_event=None, node=None):\n    \"\"\"Helper for prining errors in callbacks\n\n    See EventEmitter._invoke_callback for a use example.\n    \"\"\"\n    if not hasattr(obj, '_vispy_err_registry'):\n        obj._vispy_err_registry = {}\n    registry = obj._vispy_err_registry\n\n    if cb_event is not None:\n        cb, event = cb_event\n        exp_type = 'callback'\n    else:\n        exp_type = 'node'\n    type_, value, tb = sys.exc_info()\n    tb = tb.tb_next  # Skip *this* frame\n    sys.last_type = type_\n    sys.last_value = value\n    sys.last_traceback = tb\n    del tb  # Get rid of it in this namespace\n    # Handle\n    if not ignore_callback_errors:\n        raise\n    if print_callback_errors != \"never\":\n        this_print = 'full'\n        if print_callback_errors in ('first', 'reminders'):\n            # need to check to see if we've hit this yet\n            if exp_type == 'callback':\n                key = repr(cb) + repr(event)\n            else:\n                key = repr(node)\n            if key in registry:\n                registry[key] += 1\n                if print_callback_errors == 'first':\n                    this_print = None\n                else:  # reminders\n                    ii = registry[key]\n                    # Use logarithmic selection\n                    # (1, 2, ..., 10, 20, ..., 100, 200, ...)\n                    if ii == (2 ** int(np.log2(ii))):\n                        this_print = ii\n                    else:\n                        this_print = None\n            else:\n                registry[key] = 1\n        if this_print == 'full':\n            logger.log_exception()\n            if exp_type == 'callback':\n                logger.error(\"Invoking %s for %s\" % (cb, event))\n            else:  # == 'node':\n                logger.error(\"Drawing node %s\" % node)\n        elif this_print is not None:\n            if exp_type == 'callback':\n                logger.error(\"Invoking %s repeat %s\"\n                             % (cb, this_print))\n            else:  # == 'node':\n                logger.error(\"Drawing node %s repeat %s\"\n                             % (node, this_print))",
  "def _serialize_buffer(buffer, array_serialization=None):\n    \"\"\"Serialize a NumPy array.\"\"\"\n    if array_serialization == 'binary':\n        return buffer.ravel().tobytes()\n    elif array_serialization == 'base64':\n        return {'storage_type': 'base64',\n                'buffer': base64.b64encode(buffer).decode('ascii')\n                }\n    raise ValueError(\"The array serialization method should be 'binary' or \"\n                     \"'base64'.\")",
  "class NumPyJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, np.ndarray):\n            return _serialize_buffer(obj, array_serialization='base64')\n        elif isinstance(obj, np.generic):\n            return obj.item()\n\n        return json.JSONEncoder.default(self, obj)",
  "def __init__(self):\n        logging.Formatter.__init__(self, '%(levelname)s: %(message)s')\n        self._vispy_prepend_caller = False",
  "def _vispy_set_prepend(self, prepend):\n        self._vispy_prepend_caller = prepend",
  "def format(self, record):\n        out = logging.Formatter.format(self, record)\n        if self._vispy_prepend_caller:\n            out = _get_vispy_caller() + out\n        return out",
  "def __init__(self):\n        logging.StreamHandler.__init__(self, sys.stderr)\n        self._vispy_formatter = _lf\n        self.setFormatter(self._vispy_formatter)\n        self._vispy_match = None\n        self._vispy_emit_list = list()\n        self._vispy_set_emit_record(False)\n        self._vispy_set_match(None)\n        self._vispy_print_msg = True",
  "def _vispy_emit_match_andor_record(self, record):\n        \"\"\"Log message emitter that optionally matches and/or records\"\"\"\n        test = record.getMessage()\n        match = self._vispy_match\n        if (match is None or re.search(match, test) or\n                re.search(match, _get_vispy_caller())):\n            if self._vispy_emit_record:\n                fmt_rec = self._vispy_formatter.format(record)\n                self._vispy_emit_list.append(fmt_rec)\n            if self._vispy_print_msg:\n                return logging.StreamHandler.emit(self, record)\n            else:\n                return",
  "def _vispy_set_match(self, match):\n        old_match = self._vispy_match\n        self._vispy_match = match\n        # Triage here to avoid a bunch of if's later (more efficient)\n        if match is not None or self._vispy_emit_record:\n            self.emit = self._vispy_emit_match_andor_record\n        else:\n            self.emit = partial(logging.StreamHandler.emit, self)\n        return old_match",
  "def _vispy_set_emit_record(self, record):\n        self._vispy_emit_record = record\n        match = self._vispy_match\n        # Triage here to avoid a bunch of if's later (more efficient)\n        if match is not None or self._vispy_emit_record:\n            self.emit = self._vispy_emit_match_andor_record\n        else:\n            self.emit = partial(logging.StreamHandler.emit, self)",
  "def _vispy_reset_list(self):\n        self._vispy_emit_list = list()",
  "def __init__(self, level, match=None, record=False, print_msg=True):\n        self._new_level = level\n        self._new_match = match\n        self._print_msg = print_msg\n        self._record = record\n        if match is not None and not isinstance(match, str):\n            raise TypeError('match must be None or str')",
  "def __enter__(self):\n        # set the log level\n        old_level, old_match = set_log_level(self._new_level,\n                                             self._new_match, return_old=True)\n        for key, value in logging_types.items():\n            if value == old_level:\n                old_level = key\n        self._old_level = old_level\n        self._old_match = old_match\n        if not self._print_msg:\n            _lh._vispy_print_msg = False\n        # set handler to record, if appropriate\n        _lh._vispy_reset_list()\n        if self._record:\n            _lh._vispy_set_emit_record(True)\n            return _lh._vispy_emit_list\n        else:\n            return list()",
  "def __exit__(self, type, value, traceback):\n        # reset log level\n        set_log_level(self._old_level, self._old_match)\n        # reset handler\n        if self._record:\n            _lh._vispy_set_emit_record(False)\n        if not self._print_msg:\n            _lh._vispy_print_msg = True",
  "def default(self, obj):\n        if isinstance(obj, np.ndarray):\n            return _serialize_buffer(obj, array_serialization='base64')\n        elif isinstance(obj, np.generic):\n            return obj.item()\n\n        return json.JSONEncoder.default(self, obj)",
  "class Frozen(object):\n    __isfrozen = False\n\n    def __setattr__(self, key, value):\n        if self.__isfrozen and not hasattr(self, key):\n            raise AttributeError('%r is not an attribute of class %s. Call '\n                                 '\"unfreeze()\" to allow addition of new '\n                                 'attributes' % (key, self))\n        object.__setattr__(self, key, value)\n\n    def freeze(self):\n        \"\"\"Freeze the object so that only existing properties can be set\"\"\"\n        self.__isfrozen = True\n\n    def unfreeze(self):\n        \"\"\"Unfreeze the object so that additional properties can be added\"\"\"\n        self.__isfrozen = False",
  "def __setattr__(self, key, value):\n        if self.__isfrozen and not hasattr(self, key):\n            raise AttributeError('%r is not an attribute of class %s. Call '\n                                 '\"unfreeze()\" to allow addition of new '\n                                 'attributes' % (key, self))\n        object.__setattr__(self, key, value)",
  "def freeze(self):\n        \"\"\"Freeze the object so that only existing properties can be set\"\"\"\n        self.__isfrozen = True",
  "def unfreeze(self):\n        \"\"\"Unfreeze the object so that additional properties can be added\"\"\"\n        self.__isfrozen = False",
  "def load_data_file(fname, directory=None, force_download=False):\n    \"\"\"Get a standard vispy demo data file\n\n    Parameters\n    ----------\n    fname : str\n        The filename on the remote ``demo-data`` repository to download,\n        e.g. ``'molecular_viewer/micelle.npy'``. These correspond to paths\n        on ``https://github.com/vispy/demo-data/``.\n    directory : str | None\n        Directory to use to save the file. By default, the vispy\n        configuration directory is used.\n    force_download : bool | str\n        If True, the file will be downloaded even if a local copy exists\n        (and this copy will be overwritten). Can also be a YYYY-MM-DD date\n        to ensure a file is up-to-date (modified date of a file on disk,\n        if present, is checked).\n\n    Returns\n    -------\n    fname : str\n        The path to the file on the local system.\n    \"\"\"\n    _url_root = 'https://raw.githubusercontent.com/vispy/demo-data/main/'\n    url = _url_root + fname\n    if directory is None:\n        directory = config['data_path']\n        if directory is None:\n            raise ValueError('config[\"data_path\"] is not defined, '\n                             'so directory must be supplied')\n\n    fname = op.join(directory, op.normcase(fname))  # convert to native\n    if op.isfile(fname):\n        if not force_download:  # we're done\n            return fname\n        if isinstance(force_download, str):\n            ntime = time.strptime(force_download, '%Y-%m-%d')\n            ftime = time.gmtime(op.getctime(fname))\n            if ftime >= ntime:\n                return fname\n            else:\n                print('File older than %s, updating...' % force_download)\n    if not op.isdir(op.dirname(fname)):\n        os.makedirs(op.abspath(op.dirname(fname)))\n    # let's go get the file\n    _fetch_file(url, fname)\n    return fname",
  "class ProgressBar(object):\n    \"\"\"Class for generating a command-line progressbar\n\n    Parameters\n    ----------\n    max_value : int\n        Maximum value of process (e.g. number of samples to process, bytes to\n        download, etc.).\n    initial_value : int\n        Initial value of process, useful when resuming process from a specific\n        value, defaults to 0.\n    mesg : str\n        Message to include at end of progress bar.\n    max_chars : int\n        Number of characters to use for progress bar (be sure to save some room\n        for the message and % complete as well).\n    progress_character : char\n        Character in the progress bar that indicates the portion completed.\n    spinner : bool\n        Show a spinner.  Useful for long-running processes that may not\n        increment the progress bar very often.  This provides the user with\n        feedback that the progress has not stalled.\n    \"\"\"\n\n    spinner_symbols = ['|', '/', '-', '\\\\']\n    template = '\\r[{0}{1}] {2:.05f} {3} {4}   '\n\n    def __init__(self, max_value, initial_value=0, mesg='', max_chars=40,\n                 progress_character='.', spinner=False):\n        self.cur_value = initial_value\n        self.max_value = float(max_value)\n        self.mesg = mesg\n        self.max_chars = max_chars\n        self.progress_character = progress_character\n        self.spinner = spinner\n        self.spinner_index = 0\n        self.n_spinner = len(self.spinner_symbols)\n\n    def update(self, cur_value, mesg=None):\n        \"\"\"Update progressbar with current value of process\n\n        Parameters\n        ----------\n        cur_value : number\n            Current value of process.  Should be <= max_value (but this is not\n            enforced).  The percent of the progressbar will be computed as\n            (cur_value / max_value) * 100\n        mesg : str\n            Message to display to the right of the progressbar.  If None, the\n            last message provided will be used.  To clear the current message,\n            pass a null string, ''.\n        \"\"\"\n        # Ensure floating-point division so we can get fractions of a percent\n        # for the progressbar.\n        self.cur_value = cur_value\n        progress = float(self.cur_value) / self.max_value\n        num_chars = int(progress * self.max_chars)\n        num_left = self.max_chars - num_chars\n\n        # Update the message\n        if mesg is not None:\n            self.mesg = mesg\n\n        # The \\r tells the cursor to return to the beginning of the line rather\n        # than starting a new line.  This allows us to have a progressbar-style\n        # display in the console window.\n        bar = self.template.format(self.progress_character * num_chars,\n                                   ' ' * num_left,\n                                   progress * 100,\n                                   self.spinner_symbols[self.spinner_index],\n                                   self.mesg)\n        sys.stdout.write(bar)\n        # Increament the spinner\n        if self.spinner:\n            self.spinner_index = (self.spinner_index + 1) % self.n_spinner\n\n        # Force a flush because sometimes when using bash scripts and pipes,\n        # the output is not printed until after the program exits.\n        sys.stdout.flush()\n\n    def update_with_increment_value(self, increment_value, mesg=None):\n        \"\"\"Update progressbar with the value of the increment instead of the\n        current value of process as in update()\n\n        Parameters\n        ----------\n        increment_value : int\n            Value of the increment of process.  The percent of the progressbar\n            will be computed as\n            (self.cur_value + increment_value / max_value) * 100\n        mesg : str\n            Message to display to the right of the progressbar.  If None, the\n            last message provided will be used.  To clear the current message,\n            pass a null string, ''.\n        \"\"\"\n        self.cur_value += increment_value\n        self.update(self.cur_value, mesg)",
  "def _chunk_read(response, local_file, chunk_size=65536, initial_size=0):\n    \"\"\"Download a file chunk by chunk and show advancement\n\n    Can also be used when resuming downloads over http.\n\n    Parameters\n    ----------\n    response: urllib.response.addinfourl\n        Response to the download request in order to get file size.\n    local_file: file\n        Hard disk file where data should be written.\n    chunk_size: integer, optional\n        Size of downloaded chunks. Default: 8192\n    initial_size: int, optional\n        If resuming, indicate the initial size of the file.\n    \"\"\"\n    # Adapted from NISL:\n    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py\n\n    bytes_so_far = initial_size\n    # Returns only amount left to download when resuming, not the size of the\n    # entire file\n    total_size = int(response.headers['Content-Length'].strip())\n    total_size += initial_size\n\n    progress = ProgressBar(total_size, initial_value=bytes_so_far,\n                           max_chars=40, spinner=True, mesg='downloading')\n    while True:\n        chunk = response.read(chunk_size)\n        bytes_so_far += len(chunk)\n        if not chunk:\n            sys.stderr.write('\\n')\n            break\n        _chunk_write(chunk, local_file, progress)",
  "def _chunk_write(chunk, local_file, progress):\n    \"\"\"Write a chunk to file and update the progress bar\"\"\"\n    local_file.write(chunk)\n    progress.update_with_increment_value(len(chunk))",
  "def _fetch_file(url, file_name, print_destination=True):\n    \"\"\"Load requested file, downloading it if needed or requested\n\n    Parameters\n    ----------\n    url: string\n        The url of file to be downloaded.\n    file_name: string\n        Name, along with the path, of where downloaded file will be saved.\n    print_destination: bool, optional\n        If true, destination of where file was saved will be printed after\n        download finishes.\n    \"\"\"\n    # Adapted from NISL:\n    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py\n\n    temp_file_name = file_name + \".part\"\n    local_file = None\n    initial_size = 0\n    # Checking file size and displaying it alongside the download url\n    n_try = 3\n    for ii in range(n_try):\n        try:\n            data = urllib.request.urlopen(url, timeout=15.)\n        except Exception as e:\n            if ii == n_try - 1:\n                raise RuntimeError('Error while fetching file %s.\\n'\n                                   'Dataset fetching aborted (%s)' % (url, e))\n    try:\n        file_size = int(data.headers['Content-Length'].strip())\n        print('Downloading data from %s (%s)' % (url, sizeof_fmt(file_size)))\n        local_file = open(temp_file_name, \"wb\")\n        _chunk_read(data, local_file, initial_size=initial_size)\n        # temp file must be closed prior to the move\n        if not local_file.closed:\n            local_file.close()\n        shutil.move(temp_file_name, file_name)\n        if print_destination is True:\n            sys.stdout.write('File saved as %s.\\n' % file_name)\n    except Exception as e:\n        raise RuntimeError('Error while fetching file %s.\\n'\n                           'Dataset fetching aborted (%s)' % (url, e))\n    finally:\n        if local_file is not None:\n            if not local_file.closed:\n                local_file.close()",
  "def sizeof_fmt(num):\n    \"\"\"Turn number of bytes into human-readable str\"\"\"\n    units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB']\n    decimals = [0, 0, 1, 2, 2, 2]\n    \"\"\"Human friendly file size\"\"\"\n    if num > 1:\n        exponent = min(int(log(num, 1024)), len(units) - 1)\n        quotient = float(num) / 1024 ** exponent\n        unit = units[exponent]\n        num_decimals = decimals[exponent]\n        format_string = '{0:.%sf} {1}' % (num_decimals)\n        return format_string.format(quotient, unit)\n    return '0 bytes' if num == 0 else '1 byte'",
  "def __init__(self, max_value, initial_value=0, mesg='', max_chars=40,\n                 progress_character='.', spinner=False):\n        self.cur_value = initial_value\n        self.max_value = float(max_value)\n        self.mesg = mesg\n        self.max_chars = max_chars\n        self.progress_character = progress_character\n        self.spinner = spinner\n        self.spinner_index = 0\n        self.n_spinner = len(self.spinner_symbols)",
  "def update(self, cur_value, mesg=None):\n        \"\"\"Update progressbar with current value of process\n\n        Parameters\n        ----------\n        cur_value : number\n            Current value of process.  Should be <= max_value (but this is not\n            enforced).  The percent of the progressbar will be computed as\n            (cur_value / max_value) * 100\n        mesg : str\n            Message to display to the right of the progressbar.  If None, the\n            last message provided will be used.  To clear the current message,\n            pass a null string, ''.\n        \"\"\"\n        # Ensure floating-point division so we can get fractions of a percent\n        # for the progressbar.\n        self.cur_value = cur_value\n        progress = float(self.cur_value) / self.max_value\n        num_chars = int(progress * self.max_chars)\n        num_left = self.max_chars - num_chars\n\n        # Update the message\n        if mesg is not None:\n            self.mesg = mesg\n\n        # The \\r tells the cursor to return to the beginning of the line rather\n        # than starting a new line.  This allows us to have a progressbar-style\n        # display in the console window.\n        bar = self.template.format(self.progress_character * num_chars,\n                                   ' ' * num_left,\n                                   progress * 100,\n                                   self.spinner_symbols[self.spinner_index],\n                                   self.mesg)\n        sys.stdout.write(bar)\n        # Increament the spinner\n        if self.spinner:\n            self.spinner_index = (self.spinner_index + 1) % self.n_spinner\n\n        # Force a flush because sometimes when using bash scripts and pipes,\n        # the output is not printed until after the program exits.\n        sys.stdout.flush()",
  "def update_with_increment_value(self, increment_value, mesg=None):\n        \"\"\"Update progressbar with the value of the increment instead of the\n        current value of process as in update()\n\n        Parameters\n        ----------\n        increment_value : int\n            Value of the increment of process.  The percent of the progressbar\n            will be computed as\n            (self.cur_value + increment_value / max_value) * 100\n        mesg : str\n            Message to display to the right of the progressbar.  If None, the\n            last message provided will be used.  To clear the current message,\n            pass a null string, ''.\n        \"\"\"\n        self.cur_value += increment_value\n        self.update(self.cur_value, mesg)",
  "class Event(object):\n    \"\"\"Class describing events that occur and can be reacted to with callbacks.\n    Each event instance contains information about a single event that has\n    occurred such as a key press, mouse motion, timer activation, etc.\n\n    Subclasses: :class:`KeyEvent`, :class:`MouseEvent`, :class:`TouchEvent`,\n    :class:`StylusEvent`\n\n    The creation of events and passing of events to the appropriate callback\n    functions is the responsibility of :class:`EventEmitter` instances.\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    native : object (optional)\n       The native GUI event object\n    **kwargs : keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    \"\"\"\n\n    def __init__(self, type, native=None, **kwargs):\n        # stack of all sources this event has been emitted through\n        self._sources = []\n        self._handled = False\n        self._blocked = False\n        # Store args\n        self._type = type\n        self._native = native\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    @property\n    def source(self):\n        \"\"\"The object that the event applies to (i.e. the source of the event).\"\"\"\n        return self._sources[-1] if self._sources else None\n\n    @property\n    def sources(self):\n        \"\"\"List of objects that the event applies to (i.e. are or have\n        been a source of the event). Can contain multiple objects in case\n        the event traverses a hierarchy of objects.\n        \"\"\"\n        return self._sources\n\n    def _push_source(self, source):\n        self._sources.append(source)\n\n    def _pop_source(self):\n        return self._sources.pop()\n\n    @property\n    def type(self):\n        # No docstring; documeted in class docstring\n        return self._type\n\n    @property\n    def native(self):\n        # No docstring; documeted in class docstring\n        return self._native\n\n    @property\n    def handled(self):\n        \"\"\"This boolean property indicates whether the event has already been\n        acted on by an event handler. Since many handlers may have access to\n        the same events, it is recommended that each check whether the event\n        has already been handled as well as set handled=True if it decides to\n        act on the event.\n        \"\"\"\n        return self._handled\n\n    @handled.setter\n    def handled(self, val):\n        self._handled = bool(val)\n\n    @property\n    def blocked(self):\n        \"\"\"This boolean property indicates whether the event will be delivered\n        to event callbacks. If it is set to True, then no further callbacks\n        will receive the event. When possible, it is recommended to use\n        Event.handled rather than Event.blocked.\n        \"\"\"\n        return self._blocked\n\n    @blocked.setter\n    def blocked(self, val):\n        self._blocked = bool(val)\n\n    def __repr__(self):\n        # Try to generate a nice string representation of the event that\n        # includes the interesting properties.\n        # need to keep track of depth because it is\n        # very difficult to avoid excessive recursion.\n        global _event_repr_depth\n        _event_repr_depth += 1\n        try:\n            if _event_repr_depth > 2:\n                return \"<...>\"\n            attrs = []\n            for name in dir(self):\n                if name.startswith('_'):\n                    continue\n                # select only properties\n                if not hasattr(type(self), name) or \\\n                        not isinstance(getattr(type(self), name), property):\n                    continue\n                attr = getattr(self, name)\n\n                attrs.append(\"%s=%s\" % (name, attr))\n            return \"<%s %s>\" % (self.__class__.__name__, \" \".join(attrs))\n        finally:\n            _event_repr_depth -= 1\n\n    def __str__(self):\n        \"\"\"Shorter string representation\"\"\"\n        return self.__class__.__name__",
  "class EventEmitter(object):\n\n    \"\"\"Encapsulates a list of event callbacks.\n\n    Each instance of EventEmitter represents the source of a stream of similar\n    events, such as mouse click events or timer activation events. For\n    example, the following diagram shows the propagation of a mouse click\n    event to the list of callbacks that are registered to listen for that\n    event::\n\n       User clicks    |Canvas creates\n       mouse on       |MouseEvent:                |'mouse_press' EventEmitter:         |callbacks in sequence: # noqa\n       Canvas         |                           |                                    |  # noqa\n                   -->|event = MouseEvent(...) -->|Canvas.events.mouse_press(event) -->|callback1(event)  # noqa\n                      |                           |                                 -->|callback2(event)  # noqa\n                      |                           |                                 -->|callback3(event)  # noqa\n\n    Callback functions may be added or removed from an EventEmitter using\n    :func:`connect() <vispy.event.EventEmitter.connect>` or\n    :func:`disconnect() <vispy.event.EventEmitter.disconnect>`.\n\n    Calling an instance of EventEmitter will cause each of its callbacks\n    to be invoked in sequence. All callbacks are invoked with a single\n    argument which will be an instance of :class:`Event <vispy.event.Event>`.\n\n    EventEmitters are generally created by an EmitterGroup instance.\n\n    Parameters\n    ----------\n    source : object\n        The object that the generated events apply to. All emitted Events will\n        have their .source property set to this value.\n    type : str or None\n        String indicating the event type (e.g. mouse_press, key_release)\n    event_class : subclass of Event\n        The class of events that this emitter will generate.\n    \"\"\"\n\n    def __init__(self, source=None, type=None, event_class=Event):\n        self._callbacks = []\n        self._callback_refs = []\n\n        # count number of times this emitter is blocked for each callback.\n        self._blocked = {None: 0}\n\n        # used to detect emitter loops\n        self._emitting = 0\n        self.source = source\n        self.default_args = {}\n        if type is not None:\n            self.default_args['type'] = type\n\n        assert inspect.isclass(event_class)\n        self.event_class = event_class\n\n        self._ignore_callback_errors = True\n        self.print_callback_errors = 'reminders'\n\n    @property\n    def ignore_callback_errors(self):\n        \"\"\"Whether exceptions during callbacks will be caught by the emitter\n\n        This allows it to continue invoking other callbacks if an error\n        occurs.\n        \"\"\"\n        return self._ignore_callback_errors\n\n    @ignore_callback_errors.setter\n    def ignore_callback_errors(self, val):\n        self._ignore_callback_errors = val\n\n    @property\n    def print_callback_errors(self):\n        \"\"\"Print a message and stack trace if a callback raises an exception\n\n        Valid values are \"first\" (only show first instance), \"reminders\" (show\n        complete first instance, then counts), \"always\" (always show full\n        traceback), or \"never\".\n\n        This assumes ignore_callback_errors=True. These will be raised as\n        warnings, so ensure that the vispy logging level is set to at\n        least \"warning\".\n        \"\"\"\n        return self._print_callback_errors\n\n    @print_callback_errors.setter\n    def print_callback_errors(self, val):\n        if val not in ('first', 'reminders', 'always', 'never'):\n            raise ValueError('print_callback_errors must be \"first\", '\n                             '\"reminders\", \"always\", or \"never\"')\n        self._print_callback_errors = val\n\n    @property\n    def callback_refs(self):\n        \"\"\"The set of callback references\"\"\"\n        return tuple(self._callback_refs)\n\n    @property\n    def callbacks(self):\n        \"\"\"The set of callbacks\"\"\"\n        return tuple(self._callbacks)\n\n    @property\n    def source(self):\n        \"\"\"The object that events generated by this emitter apply to\"\"\"\n        return None if self._source is None else self._source(\n        )  # get object behind weakref\n\n    @source.setter\n    def source(self, s):\n        if s is None:\n            self._source = None\n        else:\n            self._source = weakref.ref(s)\n\n    def connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\"Connect this emitter to a new callback.\n\n        Parameters\n        ----------\n        callback : function | tuple\n            *callback* may be either a callable object or a tuple\n            (object, attr_name) where object.attr_name will point to a\n            callable object. Note that only a weak reference to ``object``\n            will be kept.\n        ref : bool | str\n            Reference used to identify the callback in ``before``/``after``.\n            If True, the callback ref will automatically determined (see\n            Notes). If False, the callback cannot be referred to by a string.\n            If str, the given string will be used. Note that if ``ref``\n            is not unique in ``callback_refs``, an error will be thrown.\n        position : str\n            If ``'first'``, the first eligible position is used (that\n            meets the before and after criteria), ``'last'`` will use\n            the last position.\n        before : str | callback | list of str or callback | None\n            List of callbacks that the current callback should precede.\n            Can be None if no before-criteria should be used.\n        after : str | callback | list of str or callback | None\n            List of callbacks that the current callback should follow.\n            Can be None if no after-criteria should be used.\n\n        Notes\n        -----\n        If ``ref=True``, the callback reference will be determined from:\n\n            1. If ``callback`` is ``tuple``, the secend element in the tuple.\n            2. The ``__name__`` attribute.\n            3. The ``__class__.__name__`` attribute.\n\n        The current list of callback refs can be obtained using\n        ``event.callback_refs``. Callbacks can be referred to by either\n        their string reference (if given), or by the actual callback that\n        was attached (e.g., ``(canvas, 'swap_buffers')``).\n\n        If the specified callback is already connected, then the request is\n        ignored.\n\n        If before is None and after is None (default), the new callback will\n        be added to the beginning of the callback list. Thus the\n        callback that is connected _last_ will be the _first_ to receive\n        events from the emitter.\n        \"\"\"\n        callbacks = self.callbacks\n        callback_refs = self.callback_refs\n\n        callback = self._normalize_cb(callback)\n\n        if callback in callbacks:\n            return\n\n        # deal with the ref\n        if isinstance(ref, bool):\n            if ref:\n                if isinstance(callback, tuple):\n                    ref = callback[1]\n                elif hasattr(callback, '__name__'):  # function\n                    ref = callback.__name__\n                else:  # Method, or other\n                    ref = callback.__class__.__name__\n            else:\n                ref = None\n        elif not isinstance(ref, str):\n            raise TypeError('ref must be a bool or string')\n        if ref is not None and ref in self._callback_refs:\n            raise ValueError('ref \"%s\" is not unique' % ref)\n\n        # positions\n        if position not in ('first', 'last'):\n            raise ValueError('position must be \"first\" or \"last\", not %s'\n                             % position)\n\n        # bounds\n        bounds = list()  # upper & lower bnds (inclusive) of possible cb locs\n        for ri, criteria in enumerate((before, after)):\n            if criteria is None or criteria == []:\n                bounds.append(len(callback_refs) if ri == 0 else 0)\n            else:\n                if not isinstance(criteria, list):\n                    criteria = [criteria]\n                for c in criteria:\n                    count = sum([(c == cn or c == cc) for cn, cc\n                                 in zip(callback_refs, callbacks)])\n                    if count != 1:\n                        raise ValueError('criteria \"%s\" is in the current '\n                                         'callback list %s times:\\n%s\\n%s'\n                                         % (criteria, count,\n                                            callback_refs, callbacks))\n                matches = [ci for ci, (cn, cc) in enumerate(zip(callback_refs,\n                                                                callbacks))\n                           if (cc in criteria or cn in criteria)]\n                bounds.append(matches[0] if ri == 0 else (matches[-1] + 1))\n        if bounds[0] < bounds[1]:  # i.e., \"place before\" < \"place after\"\n            raise RuntimeError('cannot place callback before \"%s\" '\n                               'and after \"%s\" for callbacks: %s'\n                               % (before, after, callback_refs))\n        idx = bounds[1] if position == 'first' else bounds[0]  # 'last'\n\n        # actually add the callback\n        self._callbacks.insert(idx, callback)\n        self._callback_refs.insert(idx, ref)\n        return callback  # allows connect to be used as a decorator\n\n    def disconnect(self, callback=None):\n        \"\"\"Disconnect a callback from this emitter.\n\n        If no callback is specified, then *all* callbacks are removed.\n        If the callback was not already connected, then the call does nothing.\n        \"\"\"\n        if callback is None:\n            self._callbacks = []\n            self._callback_refs = []\n        else:\n            callback = self._normalize_cb(callback)\n            if callback in self._callbacks:\n                idx = self._callbacks.index(callback)\n                self._callbacks.pop(idx)\n                self._callback_refs.pop(idx)\n\n    def _normalize_cb(self, callback):\n        # dereference methods into a (self, method_name) pair so that we can\n        # make the connection without making a strong reference to the\n        # instance.\n        if inspect.ismethod(callback):\n            callback = (callback.__self__, callback.__name__)\n\n        # always use a weak ref\n        if (isinstance(callback, tuple) and not\n                isinstance(callback[0], weakref.ref)):\n            callback = (weakref.ref(callback[0]),) + callback[1:]\n\n        return callback\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"__call__(**kwargs)\n        Invoke all callbacks for this emitter.\n\n        Emit a new event object, created with the given keyword\n        arguments, which must match with the input arguments of the\n        corresponding event class. Note that the 'type' argument is\n        filled in by the emitter.\n\n        Alternatively, the emitter can also be called with an Event\n        instance as the only argument. In this case, the specified\n        Event will be used rather than generating a new one. This allows\n        customized Event instances to be emitted and also allows EventEmitters\n        to be chained by connecting one directly to another.\n\n        Note that the same Event instance is sent to all callbacks.\n        This allows some level of communication between the callbacks\n        (notably, via Event.handled) but also requires that callbacks\n        be careful not to inadvertently modify the Event.\n        \"\"\"\n        # This is a VERY highly used method; must be fast!\n        blocked = self._blocked\n\n        # create / massage event as needed\n        event = self._prepare_event(*args, **kwargs)\n\n        # Add our source to the event; remove it after all callbacks have been\n        # invoked.\n        event._push_source(self.source)\n        self._emitting += 1\n        try:\n            if blocked.get(None, 0) > 0:  # this is the same as self.blocked()\n                return event\n\n            rem = []\n            for cb in self._callbacks[:]:\n                if isinstance(cb, tuple):\n                    obj = cb[0]()\n                    if obj is None:\n                        rem.append(cb)\n                        continue\n                    cb = getattr(obj, cb[1], None)\n                    if cb is None:\n                        continue\n\n                if blocked.get(cb, 0) > 0:\n                    continue\n\n                if self._emitting > 1:\n                    raise RuntimeError('EventEmitter loop detected!')\n\n                self._invoke_callback(cb, event)\n                if event.blocked:\n                    break\n\n            # remove callbacks to dead objects\n            for cb in rem:\n                self.disconnect(cb)\n        finally:\n            self._emitting -= 1\n            if event._pop_source() != self.source:\n                raise RuntimeError(\"Event source-stack mismatch.\")\n\n        return event\n\n    def _invoke_callback(self, cb, event):\n        try:\n            cb(event)\n        except Exception:\n            _handle_exception(self.ignore_callback_errors,\n                              self.print_callback_errors,\n                              self, cb_event=(cb, event))\n\n    def _prepare_event(self, *args, **kwargs):\n        # When emitting, this method is called to create or otherwise alter\n        # an event before it is sent to callbacks. Subclasses may extend\n        # this method to make custom modifications to the event.\n        if len(args) == 1 and not kwargs and isinstance(args[0], Event):\n            event = args[0]\n            # Ensure that the given event matches what we want to emit\n            assert isinstance(event, self.event_class)\n        elif not args:\n            args = self.default_args.copy()\n            args.update(kwargs)\n            event = self.event_class(**args)\n        else:\n            raise ValueError(\"Event emitters can be called with an Event \"\n                             \"instance or with keyword arguments only.\")\n        return event\n\n    def blocked(self, callback=None):\n        \"\"\"Return boolean indicating whether the emitter is blocked for\n        the given callback.\n        \"\"\"\n        return self._blocked.get(callback, 0) > 0\n\n    def block(self, callback=None):\n        \"\"\"Block this emitter. Any attempts to emit an event while blocked\n        will be silently ignored. If *callback* is given, then the emitter\n        is only blocked for that specific callback.\n\n        Calls to block are cumulative; the emitter must be unblocked the same\n        number of times as it is blocked.\n        \"\"\"\n        self._blocked[callback] = self._blocked.get(callback, 0) + 1\n\n    def unblock(self, callback=None):\n        \"\"\"Unblock this emitter. See :func:`event.EventEmitter.block`.\n\n        Note: Use of ``unblock(None)`` only reverses the effect of\n        ``block(None)``; it does not unblock callbacks that were explicitly\n        blocked using ``block(callback)``.\n        \"\"\"\n        if callback not in self._blocked or self._blocked[callback] == 0:\n            raise RuntimeError(\"Cannot unblock %s for callback %s; emitter \"\n                               \"was not previously blocked.\" %\n                               (self, callback))\n        b = self._blocked[callback] - 1\n        if b == 0 and callback is not None:\n            del self._blocked[callback]\n        else:\n            self._blocked[callback] = b\n\n    def blocker(self, callback=None):\n        \"\"\"Return an EventBlocker to be used in 'with' statements.\n\n        Examples\n        --------\n        For example, one could do::\n\n            with emitter.blocker():\n                pass  # ..do stuff; no events will be emitted..\n\n        \"\"\"\n        return EventBlocker(self, callback)",
  "class WarningEmitter(EventEmitter):\n    \"\"\"\n    EventEmitter subclass used to allow deprecated events to be used with a\n    warning message.\n    \"\"\"\n\n    def __init__(self, message, *args, **kwargs):\n        self._message = message\n        self._warned = False\n        EventEmitter.__init__(self, *args, **kwargs)\n\n    def connect(self, cb, *args, **kwargs):\n        self._warn(cb)\n        return EventEmitter.connect(self, cb, *args, **kwargs)\n\n    def _invoke_callback(self, cb, event):\n        self._warn(cb)\n        return EventEmitter._invoke_callback(self, cb, event)\n\n    def _warn(self, cb):\n        if self._warned:\n            return\n\n        # don't warn about unimplemented connections\n        if isinstance(cb, tuple) and getattr(cb[0], cb[1], None) is None:\n            return\n\n        traceback.print_stack()\n        logger.warning(self._message)\n        self._warned = True",
  "class EmitterGroup(EventEmitter):\n    \"\"\"EmitterGroup instances manage a set of related\n    :class:`EventEmitters <vispy.event.EventEmitter>`.\n    Its primary purpose is to provide organization for objects\n    that make use of multiple emitters and to reduce the boilerplate code\n    needed to initialize those emitters with default connections.\n\n    EmitterGroup instances are usually stored as an 'events' attribute on\n    objects that use multiple emitters. For example::\n\n         EmitterGroup  EventEmitter\n                 |       |\n        Canvas.events.mouse_press\n        Canvas.events.resized\n        Canvas.events.key_press\n\n    EmitterGroup is also a subclass of\n    :class:`EventEmitters <vispy.event.EventEmitter>`,\n    allowing it to emit its own\n    events. Any callback that connects directly to the EmitterGroup will\n    receive *all* of the events generated by the group's emitters.\n\n    Parameters\n    ----------\n    source : object\n        The object that the generated events apply to.\n    auto_connect : bool\n        If *auto_connect* is True (default), then one connection will\n        be made for each emitter that looks like\n        :func:`emitter.connect((source, 'on_' + event_name))\n        <vispy.event.EventEmitter.connect>`.\n        This provides a simple mechanism for automatically connecting a large\n        group of emitters to default callbacks.\n    emitters : keyword arguments\n        See the :func:`add <vispy.event.EmitterGroup.add>` method.\n    \"\"\"\n\n    def __init__(self, source=None, auto_connect=True, **emitters):\n        EventEmitter.__init__(self, source)\n\n        self.auto_connect = auto_connect\n        self.auto_connect_format = \"on_%s\"\n        self._emitters = OrderedDict()\n        # whether the sub-emitters have been connected to the group:\n        self._emitters_connected = False\n        self.add(**emitters)\n\n    def __getitem__(self, name):\n        \"\"\"\n        Return the emitter assigned to the specified name.\n        Note that emitters may also be retrieved as an attribute of the\n        EmitterGroup.\n        \"\"\"\n        return self._emitters[name]\n\n    def __setitem__(self, name, emitter):\n        \"\"\"Alias for EmitterGroup.add(name=emitter)\"\"\"\n        self.add(**{name: emitter})\n\n    def add(self, auto_connect=None, **kwargs):\n        \"\"\"Add one or more EventEmitter instances to this emitter group.\n        Each keyword argument may be specified as either an EventEmitter\n        instance or an Event subclass, in which case an EventEmitter will be\n        generated automatically::\n\n            # This statement:\n            group.add(mouse_press=MouseEvent,\n                      mouse_release=MouseEvent)\n\n            # ..is equivalent to this statement:\n            group.add(mouse_press=EventEmitter(group.source, 'mouse_press',\n                                               MouseEvent),\n                      mouse_release=EventEmitter(group.source, 'mouse_press',\n                                                 MouseEvent))\n        \"\"\"\n        if auto_connect is None:\n            auto_connect = self.auto_connect\n\n        # check all names before adding anything\n        for name in kwargs:\n            if name in self._emitters:\n                raise ValueError(\n                    \"EmitterGroup already has an emitter named '%s'\" %\n                    name)\n            elif hasattr(self, name):\n                raise ValueError(\"The name '%s' cannot be used as an emitter; \"\n                                 \"it is already an attribute of EmitterGroup\"\n                                 % name)\n\n        # add each emitter specified in the keyword arguments\n        for name, emitter in kwargs.items():\n            if emitter is None:\n                emitter = Event\n\n            if inspect.isclass(emitter) and issubclass(emitter, Event):\n                emitter = EventEmitter(\n                    source=self.source,\n                    type=name,\n                    event_class=emitter)\n            elif not isinstance(emitter, EventEmitter):\n                raise Exception('Emitter must be specified as either an '\n                                'EventEmitter instance or Event subclass. '\n                                '(got %s=%s)' % (name, emitter))\n\n            # give this emitter the same source as the group.\n            emitter.source = self.source\n\n            setattr(self, name, emitter)\n            self._emitters[name] = emitter\n\n            if auto_connect and self.source is not None:\n                emitter.connect((self.source, self.auto_connect_format % name))\n\n            # If emitters are connected to the group already, then this one\n            # should be connected as well.\n            if self._emitters_connected:\n                emitter.connect(self)\n\n    @property\n    def emitters(self):\n        \"\"\"List of current emitters in this group.\"\"\"\n        return self._emitters\n\n    def __iter__(self):\n        \"\"\"Iterates over the names of emitters in this group.\"\"\"\n        for k in self._emitters:\n            yield k\n\n    def block_all(self):\n        \"\"\"Block all emitters in this group.\"\"\"\n        self.block()\n        for em in self._emitters.values():\n            em.block()\n\n    def unblock_all(self):\n        \"\"\"Unblock all emitters in this group.\"\"\"\n        self.unblock()\n        for em in self._emitters.values():\n            em.unblock()\n\n    def connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\"Connect the callback to the event group. The callback will receive\n        events from *all* of the emitters in the group.\n\n        See :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>`\n        for arguments.\n        \"\"\"\n        self._connect_emitters(True)\n        return EventEmitter.connect(self, callback, ref, position,\n                                    before, after)\n\n    def disconnect(self, callback=None):\n        \"\"\"Disconnect the callback from this group. See\n        :func:`connect() <vispy.event.EmitterGroup.connect>` and\n        :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>` for\n        more information.\n        \"\"\"\n        ret = EventEmitter.disconnect(self, callback)\n        if len(self._callbacks) == 0:\n            self._connect_emitters(False)\n        return ret\n\n    def _connect_emitters(self, connect):\n        # Connect/disconnect all sub-emitters from the group. This allows the\n        # group to emit an event whenever _any_ of the sub-emitters emit,\n        # while simultaneously eliminating the overhead if nobody is listening.\n        if connect:\n            for emitter in self:\n                self[emitter].connect(self)\n        else:\n            for emitter in self:\n                self[emitter].disconnect(self)\n\n        self._emitters_connected = connect\n\n    @property\n    def ignore_callback_errors(self):\n        return super(EventEmitter, self).ignore_callback_errors\n\n    @ignore_callback_errors.setter\n    def ignore_callback_errors(self, ignore):\n        EventEmitter.ignore_callback_errors.fset(self, ignore)\n        for emitter in self._emitters.values():\n            if isinstance(emitter, EventEmitter):\n                emitter.ignore_callback_errors = ignore\n            elif isinstance(emitter, EmitterGroup):\n                emitter.ignore_callback_errors_all(ignore)",
  "class EventBlocker(object):\n    \"\"\"Represents a block for an EventEmitter to be used in a context\n    manager (i.e. 'with' statement).\n    \"\"\"\n\n    def __init__(self, target, callback=None):\n        self.target = target\n        self.callback = callback\n\n    def __enter__(self):\n        self.target.block(self.callback)\n\n    def __exit__(self, *args):\n        self.target.unblock(self.callback)",
  "def __init__(self, type, native=None, **kwargs):\n        # stack of all sources this event has been emitted through\n        self._sources = []\n        self._handled = False\n        self._blocked = False\n        # Store args\n        self._type = type\n        self._native = native\n        for k, v in kwargs.items():\n            setattr(self, k, v)",
  "def source(self):\n        \"\"\"The object that the event applies to (i.e. the source of the event).\"\"\"\n        return self._sources[-1] if self._sources else None",
  "def sources(self):\n        \"\"\"List of objects that the event applies to (i.e. are or have\n        been a source of the event). Can contain multiple objects in case\n        the event traverses a hierarchy of objects.\n        \"\"\"\n        return self._sources",
  "def _push_source(self, source):\n        self._sources.append(source)",
  "def _pop_source(self):\n        return self._sources.pop()",
  "def type(self):\n        # No docstring; documeted in class docstring\n        return self._type",
  "def native(self):\n        # No docstring; documeted in class docstring\n        return self._native",
  "def handled(self):\n        \"\"\"This boolean property indicates whether the event has already been\n        acted on by an event handler. Since many handlers may have access to\n        the same events, it is recommended that each check whether the event\n        has already been handled as well as set handled=True if it decides to\n        act on the event.\n        \"\"\"\n        return self._handled",
  "def handled(self, val):\n        self._handled = bool(val)",
  "def blocked(self):\n        \"\"\"This boolean property indicates whether the event will be delivered\n        to event callbacks. If it is set to True, then no further callbacks\n        will receive the event. When possible, it is recommended to use\n        Event.handled rather than Event.blocked.\n        \"\"\"\n        return self._blocked",
  "def blocked(self, val):\n        self._blocked = bool(val)",
  "def __repr__(self):\n        # Try to generate a nice string representation of the event that\n        # includes the interesting properties.\n        # need to keep track of depth because it is\n        # very difficult to avoid excessive recursion.\n        global _event_repr_depth\n        _event_repr_depth += 1\n        try:\n            if _event_repr_depth > 2:\n                return \"<...>\"\n            attrs = []\n            for name in dir(self):\n                if name.startswith('_'):\n                    continue\n                # select only properties\n                if not hasattr(type(self), name) or \\\n                        not isinstance(getattr(type(self), name), property):\n                    continue\n                attr = getattr(self, name)\n\n                attrs.append(\"%s=%s\" % (name, attr))\n            return \"<%s %s>\" % (self.__class__.__name__, \" \".join(attrs))\n        finally:\n            _event_repr_depth -= 1",
  "def __str__(self):\n        \"\"\"Shorter string representation\"\"\"\n        return self.__class__.__name__",
  "def __init__(self, source=None, type=None, event_class=Event):\n        self._callbacks = []\n        self._callback_refs = []\n\n        # count number of times this emitter is blocked for each callback.\n        self._blocked = {None: 0}\n\n        # used to detect emitter loops\n        self._emitting = 0\n        self.source = source\n        self.default_args = {}\n        if type is not None:\n            self.default_args['type'] = type\n\n        assert inspect.isclass(event_class)\n        self.event_class = event_class\n\n        self._ignore_callback_errors = True\n        self.print_callback_errors = 'reminders'",
  "def ignore_callback_errors(self):\n        \"\"\"Whether exceptions during callbacks will be caught by the emitter\n\n        This allows it to continue invoking other callbacks if an error\n        occurs.\n        \"\"\"\n        return self._ignore_callback_errors",
  "def ignore_callback_errors(self, val):\n        self._ignore_callback_errors = val",
  "def print_callback_errors(self):\n        \"\"\"Print a message and stack trace if a callback raises an exception\n\n        Valid values are \"first\" (only show first instance), \"reminders\" (show\n        complete first instance, then counts), \"always\" (always show full\n        traceback), or \"never\".\n\n        This assumes ignore_callback_errors=True. These will be raised as\n        warnings, so ensure that the vispy logging level is set to at\n        least \"warning\".\n        \"\"\"\n        return self._print_callback_errors",
  "def print_callback_errors(self, val):\n        if val not in ('first', 'reminders', 'always', 'never'):\n            raise ValueError('print_callback_errors must be \"first\", '\n                             '\"reminders\", \"always\", or \"never\"')\n        self._print_callback_errors = val",
  "def callback_refs(self):\n        \"\"\"The set of callback references\"\"\"\n        return tuple(self._callback_refs)",
  "def callbacks(self):\n        \"\"\"The set of callbacks\"\"\"\n        return tuple(self._callbacks)",
  "def source(self):\n        \"\"\"The object that events generated by this emitter apply to\"\"\"\n        return None if self._source is None else self._source(\n        )",
  "def source(self, s):\n        if s is None:\n            self._source = None\n        else:\n            self._source = weakref.ref(s)",
  "def connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\"Connect this emitter to a new callback.\n\n        Parameters\n        ----------\n        callback : function | tuple\n            *callback* may be either a callable object or a tuple\n            (object, attr_name) where object.attr_name will point to a\n            callable object. Note that only a weak reference to ``object``\n            will be kept.\n        ref : bool | str\n            Reference used to identify the callback in ``before``/``after``.\n            If True, the callback ref will automatically determined (see\n            Notes). If False, the callback cannot be referred to by a string.\n            If str, the given string will be used. Note that if ``ref``\n            is not unique in ``callback_refs``, an error will be thrown.\n        position : str\n            If ``'first'``, the first eligible position is used (that\n            meets the before and after criteria), ``'last'`` will use\n            the last position.\n        before : str | callback | list of str or callback | None\n            List of callbacks that the current callback should precede.\n            Can be None if no before-criteria should be used.\n        after : str | callback | list of str or callback | None\n            List of callbacks that the current callback should follow.\n            Can be None if no after-criteria should be used.\n\n        Notes\n        -----\n        If ``ref=True``, the callback reference will be determined from:\n\n            1. If ``callback`` is ``tuple``, the secend element in the tuple.\n            2. The ``__name__`` attribute.\n            3. The ``__class__.__name__`` attribute.\n\n        The current list of callback refs can be obtained using\n        ``event.callback_refs``. Callbacks can be referred to by either\n        their string reference (if given), or by the actual callback that\n        was attached (e.g., ``(canvas, 'swap_buffers')``).\n\n        If the specified callback is already connected, then the request is\n        ignored.\n\n        If before is None and after is None (default), the new callback will\n        be added to the beginning of the callback list. Thus the\n        callback that is connected _last_ will be the _first_ to receive\n        events from the emitter.\n        \"\"\"\n        callbacks = self.callbacks\n        callback_refs = self.callback_refs\n\n        callback = self._normalize_cb(callback)\n\n        if callback in callbacks:\n            return\n\n        # deal with the ref\n        if isinstance(ref, bool):\n            if ref:\n                if isinstance(callback, tuple):\n                    ref = callback[1]\n                elif hasattr(callback, '__name__'):  # function\n                    ref = callback.__name__\n                else:  # Method, or other\n                    ref = callback.__class__.__name__\n            else:\n                ref = None\n        elif not isinstance(ref, str):\n            raise TypeError('ref must be a bool or string')\n        if ref is not None and ref in self._callback_refs:\n            raise ValueError('ref \"%s\" is not unique' % ref)\n\n        # positions\n        if position not in ('first', 'last'):\n            raise ValueError('position must be \"first\" or \"last\", not %s'\n                             % position)\n\n        # bounds\n        bounds = list()  # upper & lower bnds (inclusive) of possible cb locs\n        for ri, criteria in enumerate((before, after)):\n            if criteria is None or criteria == []:\n                bounds.append(len(callback_refs) if ri == 0 else 0)\n            else:\n                if not isinstance(criteria, list):\n                    criteria = [criteria]\n                for c in criteria:\n                    count = sum([(c == cn or c == cc) for cn, cc\n                                 in zip(callback_refs, callbacks)])\n                    if count != 1:\n                        raise ValueError('criteria \"%s\" is in the current '\n                                         'callback list %s times:\\n%s\\n%s'\n                                         % (criteria, count,\n                                            callback_refs, callbacks))\n                matches = [ci for ci, (cn, cc) in enumerate(zip(callback_refs,\n                                                                callbacks))\n                           if (cc in criteria or cn in criteria)]\n                bounds.append(matches[0] if ri == 0 else (matches[-1] + 1))\n        if bounds[0] < bounds[1]:  # i.e., \"place before\" < \"place after\"\n            raise RuntimeError('cannot place callback before \"%s\" '\n                               'and after \"%s\" for callbacks: %s'\n                               % (before, after, callback_refs))\n        idx = bounds[1] if position == 'first' else bounds[0]  # 'last'\n\n        # actually add the callback\n        self._callbacks.insert(idx, callback)\n        self._callback_refs.insert(idx, ref)\n        return callback",
  "def disconnect(self, callback=None):\n        \"\"\"Disconnect a callback from this emitter.\n\n        If no callback is specified, then *all* callbacks are removed.\n        If the callback was not already connected, then the call does nothing.\n        \"\"\"\n        if callback is None:\n            self._callbacks = []\n            self._callback_refs = []\n        else:\n            callback = self._normalize_cb(callback)\n            if callback in self._callbacks:\n                idx = self._callbacks.index(callback)\n                self._callbacks.pop(idx)\n                self._callback_refs.pop(idx)",
  "def _normalize_cb(self, callback):\n        # dereference methods into a (self, method_name) pair so that we can\n        # make the connection without making a strong reference to the\n        # instance.\n        if inspect.ismethod(callback):\n            callback = (callback.__self__, callback.__name__)\n\n        # always use a weak ref\n        if (isinstance(callback, tuple) and not\n                isinstance(callback[0], weakref.ref)):\n            callback = (weakref.ref(callback[0]),) + callback[1:]\n\n        return callback",
  "def __call__(self, *args, **kwargs):\n        \"\"\"__call__(**kwargs)\n        Invoke all callbacks for this emitter.\n\n        Emit a new event object, created with the given keyword\n        arguments, which must match with the input arguments of the\n        corresponding event class. Note that the 'type' argument is\n        filled in by the emitter.\n\n        Alternatively, the emitter can also be called with an Event\n        instance as the only argument. In this case, the specified\n        Event will be used rather than generating a new one. This allows\n        customized Event instances to be emitted and also allows EventEmitters\n        to be chained by connecting one directly to another.\n\n        Note that the same Event instance is sent to all callbacks.\n        This allows some level of communication between the callbacks\n        (notably, via Event.handled) but also requires that callbacks\n        be careful not to inadvertently modify the Event.\n        \"\"\"\n        # This is a VERY highly used method; must be fast!\n        blocked = self._blocked\n\n        # create / massage event as needed\n        event = self._prepare_event(*args, **kwargs)\n\n        # Add our source to the event; remove it after all callbacks have been\n        # invoked.\n        event._push_source(self.source)\n        self._emitting += 1\n        try:\n            if blocked.get(None, 0) > 0:  # this is the same as self.blocked()\n                return event\n\n            rem = []\n            for cb in self._callbacks[:]:\n                if isinstance(cb, tuple):\n                    obj = cb[0]()\n                    if obj is None:\n                        rem.append(cb)\n                        continue\n                    cb = getattr(obj, cb[1], None)\n                    if cb is None:\n                        continue\n\n                if blocked.get(cb, 0) > 0:\n                    continue\n\n                if self._emitting > 1:\n                    raise RuntimeError('EventEmitter loop detected!')\n\n                self._invoke_callback(cb, event)\n                if event.blocked:\n                    break\n\n            # remove callbacks to dead objects\n            for cb in rem:\n                self.disconnect(cb)\n        finally:\n            self._emitting -= 1\n            if event._pop_source() != self.source:\n                raise RuntimeError(\"Event source-stack mismatch.\")\n\n        return event",
  "def _invoke_callback(self, cb, event):\n        try:\n            cb(event)\n        except Exception:\n            _handle_exception(self.ignore_callback_errors,\n                              self.print_callback_errors,\n                              self, cb_event=(cb, event))",
  "def _prepare_event(self, *args, **kwargs):\n        # When emitting, this method is called to create or otherwise alter\n        # an event before it is sent to callbacks. Subclasses may extend\n        # this method to make custom modifications to the event.\n        if len(args) == 1 and not kwargs and isinstance(args[0], Event):\n            event = args[0]\n            # Ensure that the given event matches what we want to emit\n            assert isinstance(event, self.event_class)\n        elif not args:\n            args = self.default_args.copy()\n            args.update(kwargs)\n            event = self.event_class(**args)\n        else:\n            raise ValueError(\"Event emitters can be called with an Event \"\n                             \"instance or with keyword arguments only.\")\n        return event",
  "def blocked(self, callback=None):\n        \"\"\"Return boolean indicating whether the emitter is blocked for\n        the given callback.\n        \"\"\"\n        return self._blocked.get(callback, 0) > 0",
  "def block(self, callback=None):\n        \"\"\"Block this emitter. Any attempts to emit an event while blocked\n        will be silently ignored. If *callback* is given, then the emitter\n        is only blocked for that specific callback.\n\n        Calls to block are cumulative; the emitter must be unblocked the same\n        number of times as it is blocked.\n        \"\"\"\n        self._blocked[callback] = self._blocked.get(callback, 0) + 1",
  "def unblock(self, callback=None):\n        \"\"\"Unblock this emitter. See :func:`event.EventEmitter.block`.\n\n        Note: Use of ``unblock(None)`` only reverses the effect of\n        ``block(None)``; it does not unblock callbacks that were explicitly\n        blocked using ``block(callback)``.\n        \"\"\"\n        if callback not in self._blocked or self._blocked[callback] == 0:\n            raise RuntimeError(\"Cannot unblock %s for callback %s; emitter \"\n                               \"was not previously blocked.\" %\n                               (self, callback))\n        b = self._blocked[callback] - 1\n        if b == 0 and callback is not None:\n            del self._blocked[callback]\n        else:\n            self._blocked[callback] = b",
  "def blocker(self, callback=None):\n        \"\"\"Return an EventBlocker to be used in 'with' statements.\n\n        Examples\n        --------\n        For example, one could do::\n\n            with emitter.blocker():\n                pass  # ..do stuff; no events will be emitted..\n\n        \"\"\"\n        return EventBlocker(self, callback)",
  "def __init__(self, message, *args, **kwargs):\n        self._message = message\n        self._warned = False\n        EventEmitter.__init__(self, *args, **kwargs)",
  "def connect(self, cb, *args, **kwargs):\n        self._warn(cb)\n        return EventEmitter.connect(self, cb, *args, **kwargs)",
  "def _invoke_callback(self, cb, event):\n        self._warn(cb)\n        return EventEmitter._invoke_callback(self, cb, event)",
  "def _warn(self, cb):\n        if self._warned:\n            return\n\n        # don't warn about unimplemented connections\n        if isinstance(cb, tuple) and getattr(cb[0], cb[1], None) is None:\n            return\n\n        traceback.print_stack()\n        logger.warning(self._message)\n        self._warned = True",
  "def __init__(self, source=None, auto_connect=True, **emitters):\n        EventEmitter.__init__(self, source)\n\n        self.auto_connect = auto_connect\n        self.auto_connect_format = \"on_%s\"\n        self._emitters = OrderedDict()\n        # whether the sub-emitters have been connected to the group:\n        self._emitters_connected = False\n        self.add(**emitters)",
  "def __getitem__(self, name):\n        \"\"\"\n        Return the emitter assigned to the specified name.\n        Note that emitters may also be retrieved as an attribute of the\n        EmitterGroup.\n        \"\"\"\n        return self._emitters[name]",
  "def __setitem__(self, name, emitter):\n        \"\"\"Alias for EmitterGroup.add(name=emitter)\"\"\"\n        self.add(**{name: emitter})",
  "def add(self, auto_connect=None, **kwargs):\n        \"\"\"Add one or more EventEmitter instances to this emitter group.\n        Each keyword argument may be specified as either an EventEmitter\n        instance or an Event subclass, in which case an EventEmitter will be\n        generated automatically::\n\n            # This statement:\n            group.add(mouse_press=MouseEvent,\n                      mouse_release=MouseEvent)\n\n            # ..is equivalent to this statement:\n            group.add(mouse_press=EventEmitter(group.source, 'mouse_press',\n                                               MouseEvent),\n                      mouse_release=EventEmitter(group.source, 'mouse_press',\n                                                 MouseEvent))\n        \"\"\"\n        if auto_connect is None:\n            auto_connect = self.auto_connect\n\n        # check all names before adding anything\n        for name in kwargs:\n            if name in self._emitters:\n                raise ValueError(\n                    \"EmitterGroup already has an emitter named '%s'\" %\n                    name)\n            elif hasattr(self, name):\n                raise ValueError(\"The name '%s' cannot be used as an emitter; \"\n                                 \"it is already an attribute of EmitterGroup\"\n                                 % name)\n\n        # add each emitter specified in the keyword arguments\n        for name, emitter in kwargs.items():\n            if emitter is None:\n                emitter = Event\n\n            if inspect.isclass(emitter) and issubclass(emitter, Event):\n                emitter = EventEmitter(\n                    source=self.source,\n                    type=name,\n                    event_class=emitter)\n            elif not isinstance(emitter, EventEmitter):\n                raise Exception('Emitter must be specified as either an '\n                                'EventEmitter instance or Event subclass. '\n                                '(got %s=%s)' % (name, emitter))\n\n            # give this emitter the same source as the group.\n            emitter.source = self.source\n\n            setattr(self, name, emitter)\n            self._emitters[name] = emitter\n\n            if auto_connect and self.source is not None:\n                emitter.connect((self.source, self.auto_connect_format % name))\n\n            # If emitters are connected to the group already, then this one\n            # should be connected as well.\n            if self._emitters_connected:\n                emitter.connect(self)",
  "def emitters(self):\n        \"\"\"List of current emitters in this group.\"\"\"\n        return self._emitters",
  "def __iter__(self):\n        \"\"\"Iterates over the names of emitters in this group.\"\"\"\n        for k in self._emitters:\n            yield k",
  "def block_all(self):\n        \"\"\"Block all emitters in this group.\"\"\"\n        self.block()\n        for em in self._emitters.values():\n            em.block()",
  "def unblock_all(self):\n        \"\"\"Unblock all emitters in this group.\"\"\"\n        self.unblock()\n        for em in self._emitters.values():\n            em.unblock()",
  "def connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\"Connect the callback to the event group. The callback will receive\n        events from *all* of the emitters in the group.\n\n        See :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>`\n        for arguments.\n        \"\"\"\n        self._connect_emitters(True)\n        return EventEmitter.connect(self, callback, ref, position,\n                                    before, after)",
  "def disconnect(self, callback=None):\n        \"\"\"Disconnect the callback from this group. See\n        :func:`connect() <vispy.event.EmitterGroup.connect>` and\n        :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>` for\n        more information.\n        \"\"\"\n        ret = EventEmitter.disconnect(self, callback)\n        if len(self._callbacks) == 0:\n            self._connect_emitters(False)\n        return ret",
  "def _connect_emitters(self, connect):\n        # Connect/disconnect all sub-emitters from the group. This allows the\n        # group to emit an event whenever _any_ of the sub-emitters emit,\n        # while simultaneously eliminating the overhead if nobody is listening.\n        if connect:\n            for emitter in self:\n                self[emitter].connect(self)\n        else:\n            for emitter in self:\n                self[emitter].disconnect(self)\n\n        self._emitters_connected = connect",
  "def ignore_callback_errors(self):\n        return super(EventEmitter, self).ignore_callback_errors",
  "def ignore_callback_errors(self, ignore):\n        EventEmitter.ignore_callback_errors.fset(self, ignore)\n        for emitter in self._emitters.values():\n            if isinstance(emitter, EventEmitter):\n                emitter.ignore_callback_errors = ignore\n            elif isinstance(emitter, EmitterGroup):\n                emitter.ignore_callback_errors_all(ignore)",
  "def __init__(self, target, callback=None):\n        self.target = target\n        self.callback = callback",
  "def __enter__(self):\n        self.target.block(self.callback)",
  "def __exit__(self, *args):\n        self.target.unblock(self.callback)",
  "class Key(object):\n    \"\"\"Represent the identity of a certain key.\n\n    This represents one or more names that the key in question is known by.\n\n    A Key object can be compared to one of its string names (case\n    insensitive), to the integer ordinal of the key (only for keys that\n    represent characters), and to another Key instance.\n    \"\"\"\n\n    def __init__(self, *names):\n        self._names = names\n        self._names_upper = tuple([v.upper() for v in names])\n\n    @property\n    def name(self):\n        \"\"\"The primary name of the key.\"\"\"\n        return self._names[0]\n\n    def __hash__(self):\n        return self._names[0].__hash__()\n\n    def __repr__(self):\n        return \"<Key %s>\" % ', '.join([repr(v) for v in self._names])\n\n    def __eq__(self, other):\n        if isinstance(other, str):\n            return other.upper() in self._names_upper\n        elif isinstance(other, Key):\n            return self._names[0] == other\n        elif isinstance(other, int):\n            return other in [ord(v) for v in self._names_upper if len(v) == 1]\n        elif other is None:\n            return False\n        else:\n            raise ValueError('Key can only be compared to str, int and Key.')",
  "def __init__(self, *names):\n        self._names = names\n        self._names_upper = tuple([v.upper() for v in names])",
  "def name(self):\n        \"\"\"The primary name of the key.\"\"\"\n        return self._names[0]",
  "def __hash__(self):\n        return self._names[0].__hash__()",
  "def __repr__(self):\n        return \"<Key %s>\" % ', '.join([repr(v) for v in self._names])",
  "def __eq__(self, other):\n        if isinstance(other, str):\n            return other.upper() in self._names_upper\n        elif isinstance(other, Key):\n            return self._names[0] == other\n        elif isinstance(other, int):\n            return other in [ord(v) for v in self._names_upper if len(v) == 1]\n        elif other is None:\n            return False\n        else:\n            raise ValueError('Key can only be compared to str, int and Key.')",
  "def _init():\n    \"\"\"Create global Config object, parse command flags.\"\"\"\n    global config, _data_path, _allowed_config_keys\n\n    app_dir = _get_vispy_app_dir()\n    if app_dir is not None:\n        _data_path = op.join(app_dir, 'data')\n        _test_data_path = op.join(app_dir, 'test_data')\n    else:\n        _data_path = _test_data_path = None\n\n    # All allowed config keys and the types they may have\n    _allowed_config_keys = {\n        'data_path': (str,),\n        'default_backend': (str,),\n        'gl_backend': (str,),\n        'gl_debug': (bool,),\n        'glir_file': (str,) + file_types,\n        'include_path': list,\n        'logging_level': (str,),\n        'qt_lib': (str,),\n        'dpi': (int, type(None)),\n        'profile': (str, type(None),),\n        'audit_tests': (bool,),\n        'test_data_path': (str, type(None),),\n    }\n\n    # Default values for all config options\n    default_config_options = {\n        'data_path': _data_path,\n        'default_backend': '',\n        'gl_backend': 'gl2',\n        'gl_debug': False,\n        'glir_file': '',\n        'include_path': [],\n        'logging_level': 'warning',\n        'qt_lib': 'any',\n        'dpi': None,\n        'profile': None,\n        'audit_tests': False,\n        'test_data_path': _test_data_path,\n    }\n\n    config = Config(**default_config_options)\n\n    try:\n        config.update(**_load_config())\n    except Exception as err:\n        raise Exception('Error while reading vispy config file \"%s\":\\n  %s' %\n                        (_get_config_fname(), str(err)))\n    set_log_level(config['logging_level'])\n\n    _parse_command_line_arguments()",
  "def _parse_command_line_arguments():\n    \"\"\"Transform vispy specific command line args to vispy config.\n    Put into a function so that any variables dont leak in the vispy namespace.\n    \"\"\"\n    global config\n    # Get command line args for vispy\n    argnames = ['vispy-backend=', 'vispy-gl-debug', 'vispy-glir-file=',\n                'vispy-log=', 'vispy-help', 'vispy-profile=', 'vispy-cprofile',\n                'vispy-dpi=', 'vispy-audit-tests']\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], '', argnames)\n    except getopt.GetoptError:\n        opts = []\n    # Use them to set the config values\n    for o, a in opts:\n        if o.startswith('--vispy'):\n            if o == '--vispy-backend':\n                config['default_backend'] = a\n                logger.info('vispy backend: %s', a)\n            elif o == '--vispy-gl-debug':\n                config['gl_debug'] = True\n            elif o == '--vispy-glir-file':\n                config['glir_file'] = a\n            elif o == '--vispy-log':\n                if ',' in a:\n                    verbose, match = a.split(',')\n                else:\n                    verbose = a\n                    match = None\n                config['logging_level'] = a\n                set_log_level(verbose, match)\n            elif o == '--vispy-profile':\n                config['profile'] = a\n            elif o == '--vispy-cprofile':\n                _enable_profiling()\n            elif o == '--vispy-help':\n                print(VISPY_HELP)\n            elif o == '--vispy-dpi':\n                config['dpi'] = int(a)\n            elif o == '--vispy-audit-tests':\n                config['audit_tests'] = True\n            else:\n                logger.warning(\"Unsupported vispy flag: %s\" % o)",
  "def _get_vispy_app_dir():\n    \"\"\"Helper to get the default directory for storing vispy data\"\"\"\n    # Define default user directory\n    user_dir = os.path.expanduser('~')\n\n    # Get system app data dir\n    path = None\n    if sys.platform.startswith('win'):\n        path1, path2 = os.getenv('LOCALAPPDATA'), os.getenv('APPDATA')\n        path = path1 or path2\n    elif sys.platform.startswith('darwin'):\n        path = os.path.join(user_dir, 'Library', 'Application Support')\n    # On Linux and as fallback\n    if not (path and os.path.isdir(path)):\n        path = user_dir\n\n    # Maybe we should store things local to the executable (in case of a\n    # portable distro or a frozen application that wants to be portable)\n    prefix = sys.prefix\n    if getattr(sys, 'frozen', None):  # See application_dir() function\n        prefix = os.path.abspath(os.path.dirname(sys.path[0]))\n    for reldir in ('settings', '../settings'):\n        localpath = os.path.abspath(os.path.join(prefix, reldir))\n        if os.path.isdir(localpath):\n            try:\n                open(os.path.join(localpath, 'test.write'), 'wb').close()\n                os.remove(os.path.join(localpath, 'test.write'))\n            except IOError:\n                pass  # We cannot write in this directory\n            else:\n                path = localpath\n                break\n\n    # Get path specific for this app\n    appname = '.vispy' if path == user_dir else 'vispy'\n    path = os.path.join(path, appname)\n    return path",
  "class ConfigEvent(Event):\n    \"\"\"Event indicating a configuration change.\n\n    This class has a 'changes' attribute which is a dict of all name:value\n    pairs that have changed in the configuration.\n    \"\"\"\n\n    def __init__(self, changes):\n        Event.__init__(self, type='config_change')\n        self.changes = changes",
  "class Config(object):\n    \"\"\"Container for global settings used application-wide in vispy.\n\n    Events:\n\n    - Config.events.changed - Emits ConfigEvent whenever the configuration changes.\n\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.events = EmitterGroup(source=self)\n        self.events['changed'] = EventEmitter(\n            event_class=ConfigEvent,\n            source=self)\n        self._config = {}\n        self.update(**kwargs)\n        self._known_keys = get_config_keys()\n\n    def __getitem__(self, item):\n        return self._config[item]\n\n    def __setitem__(self, item, val):\n        self._check_key_val(item, val)\n        self._config[item] = val\n        # inform any listeners that a configuration option has changed\n        self.events.changed(changes={item: val})\n\n    def _check_key_val(self, key, val):\n        global _allowed_config_keys\n        # check values against acceptable ones\n        known_keys = _allowed_config_keys\n        if key not in known_keys:\n            raise KeyError('key \"%s\" not in known keys: \"%s\"'\n                           % (key, known_keys))\n        if not isinstance(val, known_keys[key]):\n            raise TypeError('Value for key \"%s\" must be one of %s, not %s.'\n                            % (key, known_keys[key], type(val)))\n\n    def update(self, **kwargs):\n        for key, val in kwargs.items():\n            self._check_key_val(key, val)\n        self._config.update(kwargs)\n        self.events.changed(changes=kwargs)\n\n    def __repr__(self):\n        return repr(self._config)",
  "def get_config_keys():\n    \"\"\"The config keys known by vispy and their allowed data types.\n\n    Returns\n    -------\n    keys : dict\n        Dict of {key: (types,)} pairs.\n    \"\"\"\n    global _allowed_config_keys\n    return _allowed_config_keys.copy()",
  "def _get_config_fname():\n    \"\"\"Helper for the vispy config file\"\"\"\n    directory = _get_vispy_app_dir()\n    if directory is None:\n        return None\n    fname = op.join(directory, 'vispy.json')\n    if os.environ.get('_VISPY_CONFIG_TESTING', None) is not None:\n        fname = op.join(_TempDir(), 'vispy.json')\n    return fname",
  "def _load_config():\n    \"\"\"Helper to load prefs from ~/.vispy/vispy.json\"\"\"\n    fname = _get_config_fname()\n    if fname is None or not op.isfile(fname):\n        return dict()\n    with open(fname, 'r') as fid:\n        config = json.load(fid)\n    return config",
  "def save_config(**kwargs):\n    \"\"\"Save configuration keys to vispy config file\n\n    Parameters\n    ----------\n    **kwargs : keyword arguments\n        Key/value pairs to save to the config file.\n    \"\"\"\n    if kwargs == {}:\n        kwargs = config._config\n    current_config = _load_config()\n    current_config.update(**kwargs)\n    # write to disk\n    fname = _get_config_fname()\n    if fname is None:\n        raise RuntimeError('config filename could not be determined')\n    if not op.isdir(op.dirname(fname)):\n        os.mkdir(op.dirname(fname))\n    with open(fname, 'w') as fid:\n        json.dump(current_config, fid, sort_keys=True, indent=0)",
  "def set_data_dir(directory=None, create=False, save=False):\n    \"\"\"Set vispy data download directory\n\n    Parameters\n    ----------\n    directory : str | None\n        The directory to use.\n    create : bool\n        If True, create directory if it doesn't exist.\n    save : bool\n        If True, save the configuration to the vispy config.\n    \"\"\"\n    if directory is None:\n        directory = _data_path\n        if _data_path is None:\n            raise IOError('default path cannot be determined, please '\n                          'set it manually (directory != None)')\n    if not op.isdir(directory):\n        if not create:\n            raise IOError('directory \"%s\" does not exist, perhaps try '\n                          'create=True to create it?' % directory)\n        os.mkdir(directory)\n    config.update(data_path=directory)\n    if save:\n        save_config(data_path=directory)",
  "def _enable_profiling():\n    \"\"\"Start profiling and register callback to print stats when the program\n    exits.\n    \"\"\"\n    import cProfile\n    import atexit\n    global _profiler\n    _profiler = cProfile.Profile()\n    _profiler.enable()\n    atexit.register(_profile_atexit)",
  "def _profile_atexit():\n    global _profiler\n    _profiler.print_stats(sort='cumulative')",
  "def sys_info(fname=None, overwrite=False):\n    \"\"\"Get relevant system and debugging information\n\n    Parameters\n    ----------\n    fname : str | None\n        Filename to dump info to. Use None to simply print.\n    overwrite : bool\n        If True, overwrite file (if it exists).\n\n    Returns\n    -------\n    out : str\n        The system information as a string.\n    \"\"\"\n    if fname is not None and op.isfile(fname) and not overwrite:\n        raise IOError('file exists, use overwrite=True to overwrite')\n\n    out = 'Platform: %s\\n' % platform.platform()\n    out += 'Python:   %s\\n' % str(sys.version).replace('\\n', ' ')\n    out += 'NumPy:    %s\\n' % (np.__version__,)\n    try:\n        # Nest all imports here to avoid any circular imports\n        from ..app import use_app, Canvas\n        from ..app.backends import BACKEND_NAMES\n        from ..gloo import gl\n        from .check_environment import has_backend\n        # get default app\n        with use_log_level('warning'):\n            app = use_app(call_reuse=False)  # suppress messages\n        out += 'Backend:  %s\\n' % app.backend_name\n        for backend in BACKEND_NAMES:\n            if backend.startswith('ipynb_'):\n                continue\n            with use_log_level('warning', print_msg=False):\n                which = has_backend(backend, out=['which'])[1]\n            out += '{0:<9} {1}\\n'.format(backend + ':', which)\n        out += '\\n'\n        # We need an OpenGL context to get GL info\n        canvas = Canvas('Test', (10, 10), show=False, app=app)\n        canvas._backend._vispy_set_current()\n        out += 'GL version:  %r\\n' % (gl.glGetParameter(gl.GL_VERSION),)\n        x_ = gl.GL_MAX_TEXTURE_SIZE\n        out += 'MAX_TEXTURE_SIZE: %r\\n' % (gl.glGetParameter(x_),)\n        out += 'Extensions: %r\\n' % (gl.glGetParameter(gl.GL_EXTENSIONS),)\n        canvas.close()\n    except Exception:  # don't stop printing info\n        out += 'App info-gathering error:\\n%s' % traceback.format_exc()\n        pass\n    if fname is not None:\n        with open(fname, 'w') as fid:\n            fid.write(out)\n    return out",
  "class _TempDir(str):\n    \"\"\"Class for creating and auto-destroying temp dir\n\n    This is designed to be used with testing modules.\n\n    We cannot simply use __del__() method for cleanup here because the rmtree\n    function may be cleaned up before this object, so we use the atexit module\n    instead.\n    \"\"\"\n\n    def __new__(self):\n        new = str.__new__(self, tempfile.mkdtemp())\n        return new\n\n    def __init__(self):\n        self._path = self.__str__()\n        atexit.register(self.cleanup)\n\n    def cleanup(self):\n        rmtree(self._path, ignore_errors=True)",
  "def __init__(self, changes):\n        Event.__init__(self, type='config_change')\n        self.changes = changes",
  "def __init__(self, **kwargs):\n        self.events = EmitterGroup(source=self)\n        self.events['changed'] = EventEmitter(\n            event_class=ConfigEvent,\n            source=self)\n        self._config = {}\n        self.update(**kwargs)\n        self._known_keys = get_config_keys()",
  "def __getitem__(self, item):\n        return self._config[item]",
  "def __setitem__(self, item, val):\n        self._check_key_val(item, val)\n        self._config[item] = val\n        # inform any listeners that a configuration option has changed\n        self.events.changed(changes={item: val})",
  "def _check_key_val(self, key, val):\n        global _allowed_config_keys\n        # check values against acceptable ones\n        known_keys = _allowed_config_keys\n        if key not in known_keys:\n            raise KeyError('key \"%s\" not in known keys: \"%s\"'\n                           % (key, known_keys))\n        if not isinstance(val, known_keys[key]):\n            raise TypeError('Value for key \"%s\" must be one of %s, not %s.'\n                            % (key, known_keys[key], type(val)))",
  "def update(self, **kwargs):\n        for key, val in kwargs.items():\n            self._check_key_val(key, val)\n        self._config.update(kwargs)\n        self.events.changed(changes=kwargs)",
  "def __repr__(self):\n        return repr(self._config)",
  "def __new__(self):\n        new = str.__new__(self, tempfile.mkdtemp())\n        return new",
  "def __init__(self):\n        self._path = self.__str__()\n        atexit.register(self.cleanup)",
  "def cleanup(self):\n        rmtree(self._path, ignore_errors=True)",
  "def _get_args(function, varargs=False):\n        params = inspect.signature(function).parameters\n        args = [key for key, param in params.items()\n                if param.kind not in (param.VAR_POSITIONAL, param.VAR_KEYWORD)]\n        if varargs:\n            varargs = [param.name for param in params.values()\n                       if param.kind == param.VAR_POSITIONAL]\n            if len(varargs) == 0:\n                varargs = None\n            return args, varargs\n        else:\n            return args",
  "def _get_args(function, varargs=False):\n        out = inspect.getargspec(function)  # args, varargs, keywords, defaults\n        if varargs:\n            return out[:2]\n        else:\n            return out[0]",
  "def fix_osmesa_gl_lib():\n    \"\"\"\n    When using OSMesa, the gl functions (from libGL) are included\n    in libOSMesa.so. This function modifies the VISPY_GL_LIB env variable\n    so gl2 picks up libOSMesa.so as the OpenGL library.\n\n    This modification must be done before vispy.gloo is imported for the\n    first time.\n    \"\"\"\n    if 'VISPY_GL_LIB' in os.environ:\n        logger.warning('VISPY_GL_LIB is ignored when using OSMesa. Use '\n                       'OSMESA_LIBRARY instead.')\n    os.environ['VISPY_GL_LIB'] = os.getenv('OSMESA_LIBRARY', 'libOSMesa.so')",
  "class Profiler(object):\n    \"\"\"Simple profiler allowing directed, hierarchical measurement of time\n    intervals.\n\n    By default, profilers are disabled.  To enable profiling, set the\n    environment variable `VISPYPROFILE` to a comma-separated list of\n    fully-qualified names of profiled functions.\n\n    Calling a profiler registers a message (defaulting to an increasing\n    counter) that contains the time elapsed since the last call.  When the\n    profiler is about to be garbage-collected, the messages are passed to the\n    outer profiler if one is running, or printed to stdout otherwise.\n\n    If `delayed` is set to False, messages are immediately printed instead.\n\n    Example:\n        def function(...):\n            profiler = Profiler()\n            ... do stuff ...\n            profiler('did stuff')\n            ... do other stuff ...\n            profiler('did other stuff')\n            # profiler is garbage-collected and flushed at function end\n\n    If this function is a method of class C, setting `VISPYPROFILE` to\n    \"C.function\" (without the module name) will enable this profiler.\n\n    For regular functions, use the qualified name of the function, stripping\n    only the initial \"vispy..\" prefix from the module.\n    \"\"\"\n\n    _profilers = (config['profile'].split(\",\") if config['profile'] is not None\n                  else [])\n\n    _depth = 0\n    _msgs = []\n    # set this flag to disable all or individual profilers at runtime\n    disable = False\n\n    class DisabledProfiler(object):\n        def __init__(self, *args, **kwds):\n            pass\n\n        def __call__(self, *args):\n            pass\n\n        def finish(self):\n            pass\n\n        def mark(self, msg=None):\n            pass\n\n    _disabled_profiler = DisabledProfiler()\n\n    def __new__(cls, msg=None, disabled='env', delayed=True):\n        \"\"\"Optionally create a new profiler based on caller's qualname.\"\"\"\n        if (disabled is True or \n                (disabled == 'env' and len(cls._profilers) == 0)):\n            return cls._disabled_profiler\n\n        # determine the qualified name of the caller function\n        caller_frame = sys._getframe(1)\n        try:\n            caller_object_type = type(caller_frame.f_locals[\"self\"])\n        except KeyError:  # we are in a regular function\n            qualifier = caller_frame.f_globals[\"__name__\"].split(\".\", 1)[1]\n        else:  # we are in a method\n            qualifier = caller_object_type.__name__\n        func_qualname = qualifier + \".\" + caller_frame.f_code.co_name\n        if (disabled == 'env' and func_qualname not in cls._profilers and\n                'all' not in cls._profilers):  # don't do anything\n            return cls._disabled_profiler\n        # create an actual profiling object\n        cls._depth += 1\n        obj = super(Profiler, cls).__new__(cls)\n        obj._name = msg or func_qualname\n        obj._delayed = delayed\n        obj._mark_count = 0\n        obj._finished = False\n        obj._firstTime = obj._last_time = ptime.time()\n        obj._new_msg(\"> Entering \" + obj._name)\n        return obj\n\n    def __call__(self, msg=None, *args):\n        \"\"\"Register or print a new message with timing information.\"\"\"\n        if self.disable:\n            return\n        if msg is None:\n            msg = str(self._mark_count)\n        self._mark_count += 1\n        new_time = ptime.time()\n        elapsed = (new_time - self._last_time) * 1000\n        self._new_msg(\"  \" + msg + \": %0.4f ms\", *(args + (elapsed,)))\n        self._last_time = new_time\n\n    def mark(self, msg=None):\n        self(msg)\n\n    def _new_msg(self, msg, *args):\n        msg = \"  \" * (self._depth - 1) + msg\n        if self._delayed:\n            self._msgs.append((msg, args))\n        else:\n            self.flush()\n            print(msg % args)\n\n    def __del__(self):\n        self.finish()\n\n    def finish(self, msg=None):\n        \"\"\"Add a final message; flush the message list if no parent profiler.\"\"\"\n        if self._finished or self.disable:\n            return        \n        self._finished = True\n        if msg is not None:\n            self(msg)\n        self._new_msg(\"< Exiting %s, total time: %0.4f ms\", \n                      self._name, (ptime.time() - self._firstTime) * 1000)\n        type(self)._depth -= 1\n        if self._depth < 1:\n            self.flush()\n\n    def flush(self):\n        if self._msgs:\n            print(\"\\n\".join([m[0] % m[1] for m in self._msgs]))\n            type(self)._msgs = []",
  "class DisabledProfiler(object):\n        def __init__(self, *args, **kwds):\n            pass\n\n        def __call__(self, *args):\n            pass\n\n        def finish(self):\n            pass\n\n        def mark(self, msg=None):\n            pass",
  "def __new__(cls, msg=None, disabled='env', delayed=True):\n        \"\"\"Optionally create a new profiler based on caller's qualname.\"\"\"\n        if (disabled is True or \n                (disabled == 'env' and len(cls._profilers) == 0)):\n            return cls._disabled_profiler\n\n        # determine the qualified name of the caller function\n        caller_frame = sys._getframe(1)\n        try:\n            caller_object_type = type(caller_frame.f_locals[\"self\"])\n        except KeyError:  # we are in a regular function\n            qualifier = caller_frame.f_globals[\"__name__\"].split(\".\", 1)[1]\n        else:  # we are in a method\n            qualifier = caller_object_type.__name__\n        func_qualname = qualifier + \".\" + caller_frame.f_code.co_name\n        if (disabled == 'env' and func_qualname not in cls._profilers and\n                'all' not in cls._profilers):  # don't do anything\n            return cls._disabled_profiler\n        # create an actual profiling object\n        cls._depth += 1\n        obj = super(Profiler, cls).__new__(cls)\n        obj._name = msg or func_qualname\n        obj._delayed = delayed\n        obj._mark_count = 0\n        obj._finished = False\n        obj._firstTime = obj._last_time = ptime.time()\n        obj._new_msg(\"> Entering \" + obj._name)\n        return obj",
  "def __call__(self, msg=None, *args):\n        \"\"\"Register or print a new message with timing information.\"\"\"\n        if self.disable:\n            return\n        if msg is None:\n            msg = str(self._mark_count)\n        self._mark_count += 1\n        new_time = ptime.time()\n        elapsed = (new_time - self._last_time) * 1000\n        self._new_msg(\"  \" + msg + \": %0.4f ms\", *(args + (elapsed,)))\n        self._last_time = new_time",
  "def mark(self, msg=None):\n        self(msg)",
  "def _new_msg(self, msg, *args):\n        msg = \"  \" * (self._depth - 1) + msg\n        if self._delayed:\n            self._msgs.append((msg, args))\n        else:\n            self.flush()\n            print(msg % args)",
  "def __del__(self):\n        self.finish()",
  "def finish(self, msg=None):\n        \"\"\"Add a final message; flush the message list if no parent profiler.\"\"\"\n        if self._finished or self.disable:\n            return        \n        self._finished = True\n        if msg is not None:\n            self(msg)\n        self._new_msg(\"< Exiting %s, total time: %0.4f ms\", \n                      self._name, (ptime.time() - self._firstTime) * 1000)\n        type(self)._depth -= 1\n        if self._depth < 1:\n            self.flush()",
  "def flush(self):\n        if self._msgs:\n            print(\"\\n\".join([m[0] % m[1] for m in self._msgs]))\n            type(self)._msgs = []",
  "def __init__(self, *args, **kwds):\n            pass",
  "def __call__(self, *args):\n            pass",
  "def finish(self):\n            pass",
  "def mark(self, msg=None):\n            pass",
  "def eq(a, b):\n    \"\"\"The great missing equivalence function: Guaranteed evaluation\n    to a single bool value.\n    \"\"\"\n    if a is b:\n        return True\n    if a is None or b is None:\n        return True if a is None and b is None else False\n\n    try:\n        e = a == b\n    except ValueError:\n        return False\n    except AttributeError:\n        return False\n    except Exception:\n        print(\"a:\", str(type(a)), str(a))\n        print(\"b:\", str(type(b)), str(b))\n        raise\n    t = type(e)\n    if t is bool:\n        return e\n    elif t is bool_:\n        return bool(e)\n    elif isinstance(e, ndarray):\n        try:\n            # disaster: if a is empty and b is not, then e.all() is True\n            if a.shape != b.shape:\n                return False\n        except Exception:\n            return False\n        if (hasattr(e, 'implements') and e.implements('MetaArray')):\n            return e.asarray().all()\n        else:\n            return e.all()\n    else:\n        raise Exception(\"== operator returned type %s\" % str(type(e)))",
  "def use(app=None, gl=None):\n    \"\"\"Set the usage options for vispy\n\n    Specify what app backend and GL backend to use.\n\n    Parameters\n    ----------\n    app : str\n        The app backend to use (case insensitive). Standard backends:\n            * 'PyQt4': use Qt widget toolkit via PyQt4.\n            * 'PyQt5': use Qt widget toolkit via PyQt5.\n            * 'PyQt6': use Qt widget toolkit via PyQt6.\n            * 'PySide': use Qt widget toolkit via PySide.\n            * 'PySide2': use Qt widget toolkit via PySide2.\n            * 'PySide6': use Qt widget toolkit via PySide6.\n            * 'PyGlet': use Pyglet backend.\n            * 'Glfw': use Glfw backend (successor of Glut). Widely available\n              on Linux.\n            * 'SDL2': use SDL v2 backend.\n            * 'osmesa': Use OSMesa backend\n        Additional backends:\n            * 'jupyter_rfb': show vispy canvases in Jupyter lab/notebook\n              (depends on the jupyter_rfb library).\n\n    gl : str\n        The gl backend to use (case insensitive). Options are:\n            * 'gl2': use Vispy's desktop OpenGL API.\n            * 'pyopengl2': use PyOpenGL's desktop OpenGL API. Mostly for\n              testing.\n            * 'es2': (TO COME) use real OpenGL ES 2.0 on Windows via Angle.\n              Availability of ES 2.0 is larger for Windows, since it relies\n              on DirectX.\n            * 'gl+': use the full OpenGL functionality available on\n              your system (via PyOpenGL).\n\n    Notes\n    -----\n    If the app option is given, ``vispy.app.use_app()`` is called. If\n    the gl option is given, ``vispy.gloo.use_gl()`` is called.\n\n    If an app backend name is provided, and that backend could not be\n    loaded, an error is raised.\n\n    If no backend name is provided, Vispy will first check if the GUI\n    toolkit corresponding to each backend is already imported, and try\n    that backend first. If this is unsuccessful, it will try the\n    'default_backend' provided in the vispy config. If still not\n    succesful, it will try each backend in a predetermined order.\n\n    See Also\n    --------\n    vispy.app.use_app\n    vispy.gloo.gl.use_gl\n    \"\"\"\n    if app is None and gl is None:\n        raise TypeError('Must specify at least one of \"app\" or \"gl\".')\n\n    if app == 'osmesa':\n        from ..util.osmesa_gl import fix_osmesa_gl_lib\n        fix_osmesa_gl_lib()\n        if gl is not None:\n            raise ValueError(\"Do not specify gl when using osmesa\")\n\n    # Apply now\n    if gl:\n        from .. import gloo, config\n        config['gl_backend'] = gl\n        gloo.gl.use_gl(gl)\n    if app:\n        from ..app import use_app\n        use_app(app)",
  "def run_subprocess(command, return_code=False, **kwargs):\n    \"\"\"Run command using subprocess.Popen\n\n    Run command and wait for command to complete. If the return code was zero\n    then return, otherwise raise CalledProcessError.\n    By default, this will also add stdout= and stderr=subproces.PIPE\n    to the call to Popen to suppress printing to the terminal.\n\n    Parameters\n    ----------\n    command : list of str\n        Command to run as subprocess (see subprocess.Popen documentation).\n    return_code : bool\n        If True, the returncode will be returned, and no error checking\n        will be performed (so this function should always return without\n        error).\n    **kwargs : dict\n        Additional kwargs to pass to ``subprocess.Popen``.\n\n    Returns\n    -------\n    stdout : str\n        Stdout returned by the process.\n    stderr : str\n        Stderr returned by the process.\n    code : int\n        The command exit code. Only returned if ``return_code`` is True.\n    \"\"\"\n    # code adapted with permission from mne-python\n    use_kwargs = dict(stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    use_kwargs.update(kwargs)\n\n    p = subprocess.Popen(command, **use_kwargs)\n    output = p.communicate()\n\n    # communicate() may return bytes, str, or None depending on the kwargs\n    # passed to Popen(). Convert all to unicode str:\n    output = ['' if s is None else s for s in output]\n    output = [s.decode('utf-8') if isinstance(s, bytes) else s for s in output]\n    output = tuple(output)\n\n    if not return_code and p.returncode:\n        print(output[0])\n        print(output[1])\n        err_fun = subprocess.CalledProcessError.__init__\n        if 'output' in _get_args(err_fun):\n            raise subprocess.CalledProcessError(p.returncode, command, output)\n        else:\n            raise subprocess.CalledProcessError(p.returncode, command)\n    if return_code:\n        output = output + (p.returncode,)\n    return output",
  "def test(*args, **kwargs):\n    \"\"\"Proxy function to delay `.testing` import\"\"\"\n    from vispy.testing import test as _test  # noqa\n    return _test(*args, **kwargs)",
  "def translate(offset, dtype=None):\n    \"\"\"Translate by an offset (x, y, z) .\n\n    Parameters\n    ----------\n    offset : array-like, shape (3,)\n        Translation in x, y, z.\n    dtype : dtype | None\n        Output type (if None, don't cast).\n\n    Returns\n    -------\n    M : ndarray\n        Transformation matrix describing the translation.\n    \"\"\"\n    assert len(offset) == 3\n    x, y, z = offset\n    M = np.array([[1., 0., 0., 0.],\n                  [0., 1., 0., 0.],\n                  [0., 0., 1., 0.],\n                  [x, y, z, 1.0]], dtype)\n    return M",
  "def scale(s, dtype=None):\n    \"\"\"Non-uniform scaling along the x, y, and z axes\n\n    Parameters\n    ----------\n    s : array-like, shape (3,)\n        Scaling in x, y, z.\n    dtype : dtype | None\n        Output type (if None, don't cast).\n\n    Returns\n    -------\n    M : ndarray\n        Transformation matrix describing the scaling.\n    \"\"\"\n    assert len(s) == 3\n    return np.array(np.diag(np.concatenate([s, (1.,)])), dtype)",
  "def rotate(angle, axis, dtype=None):\n    \"\"\"The 4x4 rotation matrix for rotation about a vector.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : ndarray\n        The x, y, z coordinates of the axis direction vector.\n\n    Returns\n    -------\n    M : ndarray\n        Transformation matrix describing the rotation.\n    \"\"\"\n    angle = np.radians(angle)\n    assert len(axis) == 3\n    x, y, z = axis / np.linalg.norm(axis)\n    c, s = math.cos(angle), math.sin(angle)\n    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z\n    M = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, .0],\n                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0.],\n                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0.],\n                  [0., 0., 0., 1.]], dtype).T\n    return M",
  "def ortho(left, right, bottom, top, znear, zfar):\n    \"\"\"Create orthographic projection matrix\n\n    Parameters\n    ----------\n    left : float\n        Left coordinate of the field of view.\n    right : float\n        Right coordinate of the field of view.\n    bottom : float\n        Bottom coordinate of the field of view.\n    top : float\n        Top coordinate of the field of view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : ndarray\n        Orthographic projection matrix (4x4).\n    \"\"\"\n    assert(right != left)\n    assert(bottom != top)\n    assert(znear != zfar)\n\n    M = np.zeros((4, 4), dtype=np.float32)\n    M[0, 0] = +2.0 / (right - left)\n    M[3, 0] = -(right + left) / float(right - left)\n    M[1, 1] = +2.0 / (top - bottom)\n    M[3, 1] = -(top + bottom) / float(top - bottom)\n    M[2, 2] = -2.0 / (zfar - znear)\n    M[3, 2] = -(zfar + znear) / float(zfar - znear)\n    M[3, 3] = 1.0\n    return M",
  "def frustum(left, right, bottom, top, znear, zfar):\n    \"\"\"Create view frustum\n\n    Parameters\n    ----------\n    left : float\n        Left coordinate of the field of view.\n    right : float\n        Right coordinate of the field of view.\n    bottom : float\n        Bottom coordinate of the field of view.\n    top : float\n        Top coordinate of the field of view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : ndarray\n        View frustum matrix (4x4).\n    \"\"\"\n    assert(right != left)\n    assert(bottom != top)\n    assert(znear != zfar)\n\n    M = np.zeros((4, 4), dtype=np.float32)\n    M[0, 0] = +2.0 * znear / float(right - left)\n    M[2, 0] = (right + left) / float(right - left)\n    M[1, 1] = +2.0 * znear / float(top - bottom)\n    M[2, 1] = (top + bottom) / float(top - bottom)\n    M[2, 2] = -(zfar + znear) / float(zfar - znear)\n    M[3, 2] = -2.0 * znear * zfar / float(zfar - znear)\n    M[2, 3] = -1.0\n    return M",
  "def perspective(fovy, aspect, znear, zfar):\n    \"\"\"Create perspective projection matrix\n\n    Parameters\n    ----------\n    fovy : float\n        The field of view along the y axis.\n    aspect : float\n        Aspect ratio of the view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : ndarray\n        Perspective projection matrix (4x4).\n    \"\"\"\n    assert(znear != zfar)\n    h = math.tan(fovy / 360.0 * math.pi) * znear\n    w = h * aspect\n    return frustum(-w, w, -h, h, znear, zfar)",
  "def affine_map(points1, points2):\n    \"\"\"Find a 3D transformation matrix that maps points1 onto points2.\n\n    Arguments are specified as arrays of four 3D coordinates, shape (4, 3).\n    \"\"\"\n    A = np.ones((4, 4))\n    A[:, :3] = points1\n    B = np.ones((4, 4))\n    B[:, :3] = points2\n\n    # solve 3 sets of linear equations to determine\n    # transformation matrix elements\n    matrix = np.eye(4)\n    for i in range(3):\n        # solve Ax = B; x is one row of the desired transformation matrix\n        matrix[i] = np.linalg.solve(A, B[:, i])\n\n    return matrix",
  "class Quaternion(object):\n    \"\"\"Quaternion(w=1, x=0, y=0, z=0, normalize=True)\n\n    A quaternion is a mathematically convenient way to\n    describe rotations.\n\n    \"\"\"\n\n    def __init__(self, w=1, x=0, y=0, z=0, normalize=True):\n\n        self.w = float(w)\n        self.x, self.y, self.z = float(x), float(y), float(z)\n        if normalize:\n            self._normalize()\n\n    def __repr__(self):\n        return \"<Quaternion object %1.3g + %1.3gi + %1.3gj + %1.3gk>\" % (\n               self.w, self.x, self.y, self.z)\n\n    def copy(self):\n        \"\"\"Create an exact copy of this quaternion.\"\"\"\n        return Quaternion(self.w, self.x, self.y, self.z, False)\n\n    def norm(self):\n        \"\"\"Returns the norm of the quaternion\n\n        norm = w**2 + x**2 + y**2 + z**2\n        \"\"\"\n        tmp = self.w**2 + self.x**2 + self.y**2 + self.z**2\n        return tmp**0.5\n\n    def _normalize(self):\n        \"\"\"Make the quaternion unit length.\"\"\"\n        # Get length\n        L = self.norm()\n        if not L:\n            raise ValueError('Quaternion cannot have 0-length.')\n        # Correct\n        self.w /= L\n        self.x /= L\n        self.y /= L\n        self.z /= L\n\n    def normalize(self):\n        \"\"\"Returns a normalized (unit length) version of the quaternion.\"\"\"\n        new = self.copy()\n        new._normalize()\n        return new\n\n    def conjugate(self):\n        \"\"\"Obtain the conjugate of the quaternion.\n\n        This is simply the same quaternion but with the sign of the\n        imaginary (vector) parts reversed.\n        \"\"\"\n        new = self.copy()\n        new.x *= -1\n        new.y *= -1\n        new.z *= -1\n        return new\n\n    def inverse(self):\n        \"\"\"Returns q.conjugate()/q.norm()**2\n\n        So if the quaternion is unit length, it is the same\n        as the conjugate.\n        \"\"\"\n        new = self.conjugate()\n        tmp = self.norm()**2\n        new.w /= tmp\n        new.x /= tmp\n        new.y /= tmp\n        new.z /= tmp\n        return new\n\n    def exp(self):\n        \"\"\"Returns the exponent of the quaternion. \n        (not tested)\n        \"\"\"\n        # Init\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        wPart = np.exp(self.w)        \n        q = Quaternion()\n\n        # Calculate\n        q.w = wPart * np.cos(vecNorm)\n        q.x = wPart * self.x * np.sin(vecNorm) / vecNorm\n        q.y = wPart * self.y * np.sin(vecNorm) / vecNorm\n        q.z = wPart * self.z * np.sin(vecNorm) / vecNorm\n\n        return q\n\n    def log(self):\n        \"\"\"Returns the natural logarithm of the quaternion. \n        (not tested)\n        \"\"\"\n        # Init\n        norm = self.norm()\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        tmp = self.w / norm\n        q = Quaternion()\n\n        # Calculate\n        q.w = np.log(norm)\n        q.x = np.log(norm) * self.x * np.arccos(tmp) / vecNorm\n        q.y = np.log(norm) * self.y * np.arccos(tmp) / vecNorm\n        q.z = np.log(norm) * self.z * np.arccos(tmp) / vecNorm\n\n        return q\n\n    def __add__(self, q):\n        \"\"\"Add quaternions.\"\"\"\n        new = self.copy()\n        new.w += q.w\n        new.x += q.x\n        new.y += q.y\n        new.z += q.z\n        return new\n\n    def __sub__(self, q):\n        \"\"\"Subtract quaternions.\"\"\"\n        new = self.copy()\n        new.w -= q.w\n        new.x -= q.x\n        new.y -= q.y\n        new.z -= q.z\n        return new\n\n    def __mul__(self, q2):\n        \"\"\"Multiply two quaternions.\"\"\"\n        new = Quaternion()\n        q1 = self       \n        new.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z\n        new.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y\n        new.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z\n        new.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x\n        return new\n\n    def rotate_point(self, p):\n        \"\"\"Rotate a Point instance using this quaternion.\"\"\"\n        # Prepare \n        p = Quaternion(0, p[0], p[1], p[2], False)  # Do not normalize!\n        q1 = self.normalize()\n        q2 = self.inverse()\n        # Apply rotation\n        r = (q1*p)*q2\n        # Make point and return        \n        return r.x, r.y, r.z\n\n    def get_matrix(self):\n        \"\"\"Create a 4x4 homography matrix that represents the rotation\n        of the quaternion.\n        \"\"\"\n        # Init matrix (remember, a matrix, not an array)\n        a = np.zeros((4, 4), dtype=np.float32)\n        w, x, y, z = self.w, self.x, self.y, self.z\n        # First row\n        a[0, 0] = - 2.0 * (y * y + z * z) + 1.0\n        a[1, 0] = + 2.0 * (x * y + z * w)\n        a[2, 0] = + 2.0 * (x * z - y * w)\n        a[3, 0] = 0.0\n        # Second row\n        a[0, 1] = + 2.0 * (x * y - z * w)\n        a[1, 1] = - 2.0 * (x * x + z * z) + 1.0\n        a[2, 1] = + 2.0 * (z * y + x * w)\n        a[3, 1] = 0.0\n        # Third row\n        a[0, 2] = + 2.0 * (x * z + y * w)\n        a[1, 2] = + 2.0 * (y * z - x * w)\n        a[2, 2] = - 2.0 * (x * x + y * y) + 1.0\n        a[3, 2] = 0.0\n        # Fourth row\n        a[0, 3] = 0.0\n        a[1, 3] = 0.0\n        a[2, 3] = 0.0\n        a[3, 3] = 1.0\n        return a\n\n    def get_axis_angle(self):\n        \"\"\"Get the axis-angle representation of the quaternion. \n        (The angle is in radians)\n        \"\"\"\n        # Init\n        angle = 2 * np.arccos(max(min(self.w, 1.), -1.))\n        scale = (self.x**2 + self.y**2 + self.z**2)**0.5    \n\n        # Calc axis\n        if scale:\n            ax = self.x / scale\n            ay = self.y / scale\n            az = self.z / scale\n        else:\n            # No rotation, so arbitrary axis\n            ax, ay, az = 1, 0, 0\n        # Return\n        return angle, ax, ay, az\n\n    @classmethod\n    def create_from_axis_angle(cls, angle, ax, ay, az, degrees=False):\n        \"\"\"Classmethod to create a quaternion from an axis-angle representation. \n        (angle should be in radians).\n        \"\"\"\n        if degrees:\n            angle = np.radians(angle)\n        while angle < 0:\n            angle += np.pi*2\n        angle2 = angle/2.0\n        sinang2 = np.sin(angle2)\n        return Quaternion(np.cos(angle2), ax*sinang2, ay*sinang2, az*sinang2)\n\n    @classmethod\n    def create_from_euler_angles(cls, rx, ry, rz, degrees=False):\n        \"\"\"Classmethod to create a quaternion given the euler angles.\"\"\"\n        if degrees:\n            rx, ry, rz = np.radians([rx, ry, rz])\n        # Obtain quaternions\n        qx = Quaternion(np.cos(rx/2), 0, 0, np.sin(rx/2))\n        qy = Quaternion(np.cos(ry/2), 0, np.sin(ry/2), 0)\n        qz = Quaternion(np.cos(rz/2), np.sin(rz/2), 0, 0)\n        # Almost done\n        return qx*qy*qz",
  "def __init__(self, w=1, x=0, y=0, z=0, normalize=True):\n\n        self.w = float(w)\n        self.x, self.y, self.z = float(x), float(y), float(z)\n        if normalize:\n            self._normalize()",
  "def __repr__(self):\n        return \"<Quaternion object %1.3g + %1.3gi + %1.3gj + %1.3gk>\" % (\n               self.w, self.x, self.y, self.z)",
  "def copy(self):\n        \"\"\"Create an exact copy of this quaternion.\"\"\"\n        return Quaternion(self.w, self.x, self.y, self.z, False)",
  "def norm(self):\n        \"\"\"Returns the norm of the quaternion\n\n        norm = w**2 + x**2 + y**2 + z**2\n        \"\"\"\n        tmp = self.w**2 + self.x**2 + self.y**2 + self.z**2\n        return tmp**0.5",
  "def _normalize(self):\n        \"\"\"Make the quaternion unit length.\"\"\"\n        # Get length\n        L = self.norm()\n        if not L:\n            raise ValueError('Quaternion cannot have 0-length.')\n        # Correct\n        self.w /= L\n        self.x /= L\n        self.y /= L\n        self.z /= L",
  "def normalize(self):\n        \"\"\"Returns a normalized (unit length) version of the quaternion.\"\"\"\n        new = self.copy()\n        new._normalize()\n        return new",
  "def conjugate(self):\n        \"\"\"Obtain the conjugate of the quaternion.\n\n        This is simply the same quaternion but with the sign of the\n        imaginary (vector) parts reversed.\n        \"\"\"\n        new = self.copy()\n        new.x *= -1\n        new.y *= -1\n        new.z *= -1\n        return new",
  "def inverse(self):\n        \"\"\"Returns q.conjugate()/q.norm()**2\n\n        So if the quaternion is unit length, it is the same\n        as the conjugate.\n        \"\"\"\n        new = self.conjugate()\n        tmp = self.norm()**2\n        new.w /= tmp\n        new.x /= tmp\n        new.y /= tmp\n        new.z /= tmp\n        return new",
  "def exp(self):\n        \"\"\"Returns the exponent of the quaternion. \n        (not tested)\n        \"\"\"\n        # Init\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        wPart = np.exp(self.w)        \n        q = Quaternion()\n\n        # Calculate\n        q.w = wPart * np.cos(vecNorm)\n        q.x = wPart * self.x * np.sin(vecNorm) / vecNorm\n        q.y = wPart * self.y * np.sin(vecNorm) / vecNorm\n        q.z = wPart * self.z * np.sin(vecNorm) / vecNorm\n\n        return q",
  "def log(self):\n        \"\"\"Returns the natural logarithm of the quaternion. \n        (not tested)\n        \"\"\"\n        # Init\n        norm = self.norm()\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        tmp = self.w / norm\n        q = Quaternion()\n\n        # Calculate\n        q.w = np.log(norm)\n        q.x = np.log(norm) * self.x * np.arccos(tmp) / vecNorm\n        q.y = np.log(norm) * self.y * np.arccos(tmp) / vecNorm\n        q.z = np.log(norm) * self.z * np.arccos(tmp) / vecNorm\n\n        return q",
  "def __add__(self, q):\n        \"\"\"Add quaternions.\"\"\"\n        new = self.copy()\n        new.w += q.w\n        new.x += q.x\n        new.y += q.y\n        new.z += q.z\n        return new",
  "def __sub__(self, q):\n        \"\"\"Subtract quaternions.\"\"\"\n        new = self.copy()\n        new.w -= q.w\n        new.x -= q.x\n        new.y -= q.y\n        new.z -= q.z\n        return new",
  "def __mul__(self, q2):\n        \"\"\"Multiply two quaternions.\"\"\"\n        new = Quaternion()\n        q1 = self       \n        new.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z\n        new.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y\n        new.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z\n        new.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x\n        return new",
  "def rotate_point(self, p):\n        \"\"\"Rotate a Point instance using this quaternion.\"\"\"\n        # Prepare \n        p = Quaternion(0, p[0], p[1], p[2], False)  # Do not normalize!\n        q1 = self.normalize()\n        q2 = self.inverse()\n        # Apply rotation\n        r = (q1*p)*q2\n        # Make point and return        \n        return r.x, r.y, r.z",
  "def get_matrix(self):\n        \"\"\"Create a 4x4 homography matrix that represents the rotation\n        of the quaternion.\n        \"\"\"\n        # Init matrix (remember, a matrix, not an array)\n        a = np.zeros((4, 4), dtype=np.float32)\n        w, x, y, z = self.w, self.x, self.y, self.z\n        # First row\n        a[0, 0] = - 2.0 * (y * y + z * z) + 1.0\n        a[1, 0] = + 2.0 * (x * y + z * w)\n        a[2, 0] = + 2.0 * (x * z - y * w)\n        a[3, 0] = 0.0\n        # Second row\n        a[0, 1] = + 2.0 * (x * y - z * w)\n        a[1, 1] = - 2.0 * (x * x + z * z) + 1.0\n        a[2, 1] = + 2.0 * (z * y + x * w)\n        a[3, 1] = 0.0\n        # Third row\n        a[0, 2] = + 2.0 * (x * z + y * w)\n        a[1, 2] = + 2.0 * (y * z - x * w)\n        a[2, 2] = - 2.0 * (x * x + y * y) + 1.0\n        a[3, 2] = 0.0\n        # Fourth row\n        a[0, 3] = 0.0\n        a[1, 3] = 0.0\n        a[2, 3] = 0.0\n        a[3, 3] = 1.0\n        return a",
  "def get_axis_angle(self):\n        \"\"\"Get the axis-angle representation of the quaternion. \n        (The angle is in radians)\n        \"\"\"\n        # Init\n        angle = 2 * np.arccos(max(min(self.w, 1.), -1.))\n        scale = (self.x**2 + self.y**2 + self.z**2)**0.5    \n\n        # Calc axis\n        if scale:\n            ax = self.x / scale\n            ay = self.y / scale\n            az = self.z / scale\n        else:\n            # No rotation, so arbitrary axis\n            ax, ay, az = 1, 0, 0\n        # Return\n        return angle, ax, ay, az",
  "def create_from_axis_angle(cls, angle, ax, ay, az, degrees=False):\n        \"\"\"Classmethod to create a quaternion from an axis-angle representation. \n        (angle should be in radians).\n        \"\"\"\n        if degrees:\n            angle = np.radians(angle)\n        while angle < 0:\n            angle += np.pi*2\n        angle2 = angle/2.0\n        sinang2 = np.sin(angle2)\n        return Quaternion(np.cos(angle2), ax*sinang2, ay*sinang2, az*sinang2)",
  "def create_from_euler_angles(cls, rx, ry, rz, degrees=False):\n        \"\"\"Classmethod to create a quaternion given the euler angles.\"\"\"\n        if degrees:\n            rx, ry, rz = np.radians([rx, ry, rz])\n        # Obtain quaternions\n        qx = Quaternion(np.cos(rx/2), 0, 0, np.sin(rx/2))\n        qy = Quaternion(np.cos(ry/2), 0, np.sin(ry/2), 0)\n        qz = Quaternion(np.cos(rz/2), np.sin(rz/2), 0, 0)\n        # Almost done\n        return qx*qy*qz",
  "class SimpleBunch(dict):\n    \"\"\"Container object for datasets: dictionnary-like object that\n    exposes its keys as attributes.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        dict.__init__(self, kwargs)\n        self.__dict__ = self",
  "def __init__(self, **kwargs):\n        dict.__init__(self, kwargs)\n        self.__dict__ = self",
  "def _load_font(face, bold, italic):\n    from freetype import Face, FT_FACE_FLAG_SCALABLE\n    key = '%s-%s-%s' % (face, bold, italic)\n    if key in _font_dict:\n        return _font_dict[key]\n    if face in _vispy_fonts:\n        fname = _get_vispy_font_filename(face, bold, italic)\n    else:\n        fname = find_font(face, bold, italic)\n    font = Face(fname)\n    if (FT_FACE_FLAG_SCALABLE & font.face_flags) == 0:\n        raise RuntimeError('Font %s is not scalable, so cannot be loaded'\n                           % face)\n    _font_dict[key] = font\n    return font",
  "def _load_glyph(f, char, glyphs_dict):\n    \"\"\"Load glyph from font into dict\"\"\"\n    from freetype import (FT_LOAD_RENDER, FT_LOAD_NO_HINTING,\n                          FT_LOAD_NO_AUTOHINT)\n    flags = FT_LOAD_RENDER | FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT\n    face = _load_font(f['face'], f['bold'], f['italic'])\n    face.set_char_size(f['size'] * 64)\n    # get the character of interest\n    face.load_char(char, flags)\n    bitmap = face.glyph.bitmap\n    width = face.glyph.bitmap.width\n    height = face.glyph.bitmap.rows\n    bitmap = np.array(bitmap.buffer)\n    w0 = bitmap.size // height if bitmap.size > 0 else 0\n    bitmap.shape = (height, w0)\n    bitmap = bitmap[:, :width].astype(np.ubyte)\n\n    left = face.glyph.bitmap_left\n    top = face.glyph.bitmap_top\n    advance = face.glyph.advance.x / 64.\n    glyph = dict(char=char, offset=(left, top), bitmap=bitmap,\n                 advance=advance, kerning={})\n    glyphs_dict[char] = glyph\n    # Generate kerning\n    for other_char, other_glyph in glyphs_dict.items():\n        kerning = face.get_kerning(other_char, char)\n        glyph['kerning'][other_char] = kerning.x / 64.\n        kerning = face.get_kerning(char, other_char)\n        other_glyph['kerning'][char] = kerning.x / 64.",
  "def _get_vispy_font_filename(face, bold, italic):\n    \"\"\"Fetch a remote vispy font\"\"\"\n    name = face + '-'\n    name += 'Regular' if not bold and not italic else ''\n    name += 'Bold' if bold else ''\n    name += 'Italic' if italic else ''\n    name += '.ttf'\n    return op.join(op.dirname(__file__), 'data', name)",
  "def find_font(face, bold, italic, orig_face=None):\n    style_dict = {'Regular': 0, 'Bold': 1, 'Italic': 2, 'Bold Italic': 3}\n\n    # Figure out which font to actually use by trying to instantiate by name\n    dc = user32.GetDC(0)  # noqa, analysis:ignore\n    gdi32.SetGraphicsMode(dc, GM_ADVANCED)  # only TT and OT fonts\n    logfont = LOGFONT()\n    logfont.lfHeight = -12  # conv point to pixels\n    logfont.lfWeight = FW_BOLD if bold else FW_NORMAL\n    logfont.lfItalic = italic\n    logfont.lfFaceName = face  # logfont needs Unicode\n    hfont = gdi32.CreateFontIndirectW(byref(logfont))\n    original = gdi32.SelectObject(dc, hfont)\n    n_byte = gdi32.GetOutlineTextMetricsW(dc, 0, None)\n    assert n_byte > 0\n    metrics = OUTLINETEXTMETRIC()\n    assert sizeof(metrics) >= n_byte\n    assert gdi32.GetOutlineTextMetricsW(dc, n_byte, byref(metrics))\n    gdi32.SelectObject(dc, original)\n    user32.ReleaseDC(None, dc)\n    use_face = cast(byref(metrics, metrics.otmpFamilyName), c_wchar_p).value\n    if use_face != face:\n        warnings.warn('Could not find face match \"%s\", falling back to \"%s\"'\n                      % (orig_face or face, use_face))\n    use_style = cast(byref(metrics, metrics.otmpStyleName), c_wchar_p).value\n    use_style = style_dict.get(use_style, 'Regular')\n    # AK: I get \"Standaard\" for use_style, which is Dutch for standard/regular\n\n    # Now we match by creating private font collections until we find\n    # the one that was used\n    font_dir = op.join(os.environ['WINDIR'], 'Fonts')\n    reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    key = 'SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Fonts'\n    reg_vals = winreg.OpenKey(reg, key)\n    n_values = winreg.QueryInfoKey(reg_vals)[1]\n    fname = None\n    for vi in range(n_values):\n        name, ff = winreg.EnumValue(reg_vals, vi)[:2]\n        if name.endswith('(TrueType)'):\n            ff = op.join(font_dir, ff) if op.basename(ff) == ff else ff\n            assert op.isfile(ff)\n            pc = c_void_p()\n            assert gdiplus.GdipNewPrivateFontCollection(byref(pc)) == 0\n            gdiplus.GdipPrivateAddFontFile(pc, ff)\n            family = c_void_p()\n            if gdiplus.GdipCreateFontFamilyFromName(use_face, pc,\n                                                    byref(family)) == 0:\n                val = BOOL()\n                assert gdiplus.GdipIsStyleAvailable(family, use_style,\n                                                    byref(val)) == 0\n                if val.value:\n                    buf = create_unicode_buffer(LF_FACESIZE)\n                    assert gdiplus.GdipGetFamilyName(family, buf, 0) == 0\n                    assert buf.value == use_face\n                    fname = ff\n                    break\n    fname = fname or find_font('', bold, italic, face)  # fall back to default\n    return fname",
  "def _list_fonts():\n    dc = user32.GetDC(0)\n    gdi32.SetGraphicsMode(dc, GM_ADVANCED)  # only TT and OT fonts\n    logfont = LOGFONT()\n    logfont.lfCharSet = DEFAULT_CHARSET\n    logfont.lfFaceName = ''\n    logfont.lfPitchandFamily = 0\n    fonts = list()\n\n    def enum_fun(lp_logfont, lp_text_metric, font_type, l_param):\n        # Only support TTF for now (silly Windows shortcomings)\n        if font_type == TRUETYPE_FONTTYPE:\n            font = lp_logfont.contents.lfFaceName\n            if not font.startswith('@') and font not in fonts:\n                fonts.append(font)\n        return 1\n\n    gdi32.EnumFontFamiliesExW(dc, byref(logfont), FONTENUMPROC(enum_fun), 0, 0)\n    user32.ReleaseDC(None, dc)\n    return fonts",
  "def enum_fun(lp_logfont, lp_text_metric, font_type, l_param):\n        # Only support TTF for now (silly Windows shortcomings)\n        if font_type == TRUETYPE_FONTTYPE:\n            font = lp_logfont.contents.lfFaceName\n            if not font.startswith('@') and font not in fonts:\n                fonts.append(font)\n        return 1",
  "def list_fonts():\n    \"\"\"List system fonts\n\n    Returns\n    -------\n    fonts : list of str\n        List of system fonts.\n    \"\"\"\n    vals = _list_fonts()\n    for font in _vispy_fonts:\n        vals += [font] if font not in vals else []\n    vals = sorted(vals, key=lambda s: s.lower())\n    return vals",
  "def _load_vispy_font(face, bold, italic):\n    # http://stackoverflow.com/questions/2703085/\n    # how-can-you-load-a-font-ttf-from-a-file-using-core-text\n    fname = _get_vispy_font_filename(face, bold, italic)\n    url = cf.CFURLCreateWithFileSystemPath(None, CFSTR(fname), 0, False)\n    # data_provider = quartz.CGDataProviderCreateWithURL(url)\n    # cg_font = quartz.CGFontCreateWithDataProvider(data_provider)\n    # font = ct.CTFontCreateWithGraphicsFont(cg_font, 12., None, None)\n    array = ct.CTFontManagerCreateFontDescriptorsFromURL(url)\n    desc = cf.CFArrayGetValueAtIndex(array, 0)\n    font = ct.CTFontCreateWithFontDescriptor(desc, 12., None)\n    cf.CFRelease(array)\n    cf.CFRelease(url)\n    if not font:\n        raise RuntimeError(\"Couldn't load font: %s\" % face)\n    key = '%s-%s-%s' % (face, bold, italic)\n    _font_dict[key] = font\n    return font",
  "def _load_font(face, bold, italic):\n    key = '%s-%s-%s' % (face, bold, italic)\n    if key in _font_dict:\n        return _font_dict[key]\n    if face in _vispy_fonts:\n        return _load_vispy_font(face, bold, italic)\n    traits = 0\n    traits |= kCTFontBoldTrait if bold else 0\n    traits |= kCTFontItalicTrait if italic else 0\n\n    # Create an attribute dictionary.\n    args = [None, 0, cf.kCFTypeDictionaryKeyCallBacks,\n            cf.kCFTypeDictionaryValueCallBacks]\n    attributes = cf.CFDictionaryCreateMutable(*args)\n    # Add family name to attributes.\n    cfname = CFSTR(face)\n    cf.CFDictionaryAddValue(attributes, kCTFontFamilyNameAttribute, cfname)\n    cf.CFRelease(cfname)\n    # Construct a CFNumber to represent the traits.\n    itraits = c_int32(traits)\n    sym_traits = cf.CFNumberCreate(None, kCFNumberSInt32Type, byref(itraits))\n    if sym_traits:\n        # Construct a dictionary to hold the traits values.\n        args = [None, 0, cf.kCFTypeDictionaryKeyCallBacks,\n                cf.kCFTypeDictionaryValueCallBacks]\n        traits_dict = cf.CFDictionaryCreateMutable(*args)\n        if traits_dict:\n            # Add CFNumber traits to traits dictionary.\n            cf.CFDictionaryAddValue(traits_dict, kCTFontSymbolicTrait,\n                                    sym_traits)\n            # Add traits dictionary to attributes.\n            cf.CFDictionaryAddValue(attributes, kCTFontTraitsAttribute,\n                                    traits_dict)\n            cf.CFRelease(traits_dict)\n        cf.CFRelease(sym_traits)\n    # Create font descriptor with attributes.\n    desc = ct.CTFontDescriptorCreateWithAttributes(attributes)\n    cf.CFRelease(attributes)\n    font = ct.CTFontCreateWithFontDescriptor(desc, 12., None)\n    if not font:\n        raise RuntimeError(\"Couldn't load font: %s\" % face)\n    _font_dict[key] = font\n    return font",
  "def _load_glyph(f, char, glyphs_dict):\n    font = _load_font(f['face'], f['bold'], f['italic'])\n    # resize loaded font\n    args = [None, 0, cf.kCFTypeDictionaryKeyCallBacks,\n            cf.kCFTypeDictionaryValueCallBacks]\n    attributes = cf.CFDictionaryCreateMutable(*args)\n    desc = ct.CTFontDescriptorCreateWithAttributes(attributes)\n    cf.CFRelease(attributes)\n    font = ct.CTFontCreateCopyWithAttributes(font, f['size'], None, desc)\n    cf.CFRelease(desc)\n    if not font:\n        raise RuntimeError(\"Couldn't load font\")\n    # Create an attributed string using text and font.\n    args = [None, 1, cf.kCFTypeDictionaryKeyCallBacks,\n            cf.kCFTypeDictionaryValueCallBacks]\n    attributes = cf.CFDictionaryCreateMutable(*args)\n    cf.CFDictionaryAddValue(attributes, kCTFontAttributeName, font)\n    string = cf.CFAttributedStringCreate(None, CFSTR(char), attributes)\n    # Create a CTLine object to render the string.\n    line = ct.CTLineCreateWithAttributedString(string)\n    cf.CFRelease(string)\n    cf.CFRelease(attributes)\n    # Get a bounding rectangle for glyphs in string.\n    chars = (UniChar * 1)(*map(ord, char))\n    glyphs = (CGGlyph * 1)()\n    ct.CTFontGetGlyphsForCharacters(font, chars, glyphs, 1)\n    rect = ct.CTFontGetBoundingRectsForGlyphs(font, 0, glyphs, None, 1)\n    # Get advance for all glyphs in string.\n    advance = ct.CTFontGetAdvancesForGlyphs(font, 1, glyphs, None, 1)\n    width = max(int(np.ceil(rect.size.width) + 1), 1)\n    height = max(int(np.ceil(rect.size.height) + 1), 1)\n\n    left = rect.origin.x\n    baseline = -rect.origin.y\n    top = height - baseline\n\n    bits_per_component = 8\n    bytes_per_row = 4*width\n    color_space = quartz.CGColorSpaceCreateDeviceRGB()\n    args = [None, width, height, bits_per_component, bytes_per_row,\n            color_space, kCGImageAlphaPremultipliedLast]\n    bitmap = quartz.CGBitmapContextCreate(*args)\n    # Draw text to bitmap context.\n    quartz.CGContextSetShouldAntialias(bitmap, True)\n    quartz.CGContextSetTextPosition(bitmap, -left, baseline)\n    ct.CTLineDraw(line, bitmap)\n    cf.CFRelease(line)\n    # Create an image to get the data out.\n    image_ref = quartz.CGBitmapContextCreateImage(bitmap)\n    assert quartz.CGImageGetBytesPerRow(image_ref) == bytes_per_row\n    data_provider = quartz.CGImageGetDataProvider(image_ref)\n    image_data = quartz.CGDataProviderCopyData(data_provider)\n    buffer_size = cf.CFDataGetLength(image_data)\n    assert buffer_size == width * height * 4\n    buffer = (c_byte * buffer_size)()\n    byte_range = CFRange(0, buffer_size)\n    cf.CFDataGetBytes(image_data, byte_range, buffer)\n    quartz.CGImageRelease(image_ref)\n    quartz.CGDataProviderRelease(image_data)\n    cf.CFRelease(bitmap)\n    cf.CFRelease(color_space)\n\n    # reshape bitmap (don't know why it's only alpha on OSX...)\n    bitmap = np.array(buffer, np.ubyte)\n    bitmap.shape = (height, width, 4)\n    bitmap = bitmap[:, :, 3].copy()\n    glyph = dict(char=char, offset=(left, top), bitmap=bitmap,\n                 advance=advance, kerning={})\n    glyphs_dict[char] = glyph\n    # Generate kerning\n    for other_char, other_glyph in glyphs_dict.items():\n        glyph['kerning'][other_char] = (_get_k_p_a(font, other_char, char) -\n                                        other_glyph['advance'])\n        other_glyph['kerning'][char] = (_get_k_p_a(font, char, other_char) -\n                                        glyph['advance'])\n    cf.CFRelease(font)",
  "def _get_k_p_a(font, left, right):\n    \"\"\"This actually calculates the kerning + advance\"\"\"\n    # http://lists.apple.com/archives/coretext-dev/2010/Dec/msg00020.html\n    # 1) set up a CTTypesetter\n    chars = left + right\n    args = [None, 1, cf.kCFTypeDictionaryKeyCallBacks,\n            cf.kCFTypeDictionaryValueCallBacks]\n    attributes = cf.CFDictionaryCreateMutable(*args)\n    cf.CFDictionaryAddValue(attributes, kCTFontAttributeName, font)\n    string = cf.CFAttributedStringCreate(None, CFSTR(chars), attributes)\n    typesetter = ct.CTTypesetterCreateWithAttributedString(string)\n    cf.CFRelease(string)\n    cf.CFRelease(attributes)\n    # 2) extract a CTLine from it\n    range = CFRange(0, 1)\n    line = ct.CTTypesetterCreateLine(typesetter, range)\n    # 3) use CTLineGetOffsetForStringIndex to get the character positions\n    offset = ct.CTLineGetOffsetForStringIndex(line, 1, None)\n    cf.CFRelease(line)\n    cf.CFRelease(typesetter)\n    return offset",
  "def _list_fonts():\n    manager = ObjCClass('NSFontManager').sharedFontManager()\n    avail = manager.availableFontFamilies()\n    fonts = [avail.objectAtIndex_(ii).UTF8String().decode('utf-8')\n             for ii in range(avail.count())]\n    return fonts",
  "def _get_dpi_from(cmd, pattern, func):\n    \"\"\"Match pattern against the output of func, passing the results as\n    floats to func.  If anything fails, return None.\n    \"\"\"\n    try:\n        out, _ = run_subprocess([cmd])\n    except (OSError, CalledProcessError):\n        pass\n    else:\n        match = re.search(pattern, out)\n        if match:\n            return func(*map(float, match.groups()))",
  "def _xrandr_calc(x_px, y_px, x_mm, y_mm):\n    if x_mm == 0 or y_mm == 0:\n        logger.warning(\"'xrandr' output has screen dimension of 0mm, \" +\n                       \"can't compute proper DPI\")\n        return 96.\n    return 25.4 * (x_px / x_mm + y_px / y_mm) / 2",
  "def get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    # If we are running without an X server (e.g. OSMesa), use a fixed DPI\n    if 'DISPLAY' not in os.environ:\n        return 96.\n\n    from_xdpyinfo = _get_dpi_from(\n        'xdpyinfo', r'(\\d+)x(\\d+) dots per inch',\n        lambda x_dpi, y_dpi: (x_dpi + y_dpi) / 2)\n    if from_xdpyinfo is not None:\n        return from_xdpyinfo\n\n    from_xrandr = _get_dpi_from(\n        'xrandr', r'(\\d+)x(\\d+).*?(\\d+)mm x (\\d+)mm',\n        _xrandr_calc)\n    if from_xrandr is not None:\n        return from_xrandr\n    if raise_error:\n        raise RuntimeError('could not determine DPI')\n    else:\n        logger.warning('could not determine DPI')\n    return 96",
  "def get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    try:\n        user32.SetProcessDPIAware()\n    except AttributeError:\n        pass  # not present on XP\n    dc = user32.GetDC(0)\n    h_size = gdi32.GetDeviceCaps(dc, HORZSIZE)\n    v_size = gdi32.GetDeviceCaps(dc, VERTSIZE)\n    h_res = gdi32.GetDeviceCaps(dc, HORZRES)\n    v_res = gdi32.GetDeviceCaps(dc, VERTRES)\n    user32.ReleaseDC(None, dc)\n    return (h_res/float(h_size) + v_res/float(v_size)) * 0.5 * 25.4",
  "def get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    display = quartz.CGMainDisplayID()\n    mm = quartz.CGDisplayScreenSize(display)\n    px = quartz.CGDisplayBounds(display).size\n    return (px.width/mm.width + px.height/mm.height) * 0.5 * 25.4",
  "class Command(object):\n\n    def __repr__(self):\n        s = '%s ' % self._command\n        for arg in self._args:\n            s += \"%.2f \" % arg\n        return s\n\n    def origin(self, current=None, previous=None):\n        relative = self._command in \"mlvhcsqtaz\"\n\n        if relative and current:\n            return current\n        else:\n            return 0.0, 0.0",
  "class Line(Command):\n\n    def __init__(self, x=0, y=0, relative=True):\n        self._command = 'l' if relative else 'L'\n        self._args = [x, y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x, y = self._args\n        self.previous = x, y\n\n        return (ox + x, oy + y),",
  "class VLine(Command):\n\n    def __init__(self, y=0, relative=True):\n        self._command = 'v' if relative else 'V'\n        self._args = [y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        y = self._args[0]\n        self.previous = ox, oy + y\n\n        return (ox, oy + y),",
  "class HLine(Command):\n\n    def __init__(self, x=0, relative=True):\n        self._command = 'h' if relative else 'H'\n        self._args = [x]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x = self._args[0]\n        self.previous = ox + x, oy\n\n        return (ox + x, oy),",
  "class Move(Command):\n\n    def __init__(self, x=0, y=0, relative=True):\n        self._command = 'm' if relative else 'M'\n        self._args = [x, y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x, y = self._args\n        x, y = x + ox, y + oy\n        self.previous = x, y\n        return (x, y),",
  "class Close(Command):\n\n    def __init__(self, relative=True):\n        self._command = 'z' if relative else 'Z'\n        self._args = []\n\n    def vertices(self, current, previous=None):\n        self.previous = current\n        return []",
  "class Arc(Command):\n\n    def __init__(self, r1=1, r2=1, angle=2 * math.pi, large=True, sweep=True,\n                 x=0, y=0, relative=True):\n        self._command = 'a' if relative else 'A'\n        self._args = [r1, r2, angle, large, sweep, x, y]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        rx, ry, angle, large, sweep, x, y = self._args\n        x, y = x + ox, y + oy\n        x0, y0 = current\n        self.previous = x, y\n        vertices = geometry.elliptical_arc(\n            x0, y0, rx, ry, angle, large, sweep, x, y)\n        return vertices[1:]",
  "class Cubic(Command):\n\n    def __init__(self, x1=0, y1=0, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = 'c' if relative else 'C'\n        self._args = [x1, y1, x2, y2, x3, y3]\n\n    def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x0, y0 = current\n        x1, y1, x2, y2, x3, y3 = self._args\n        x1, y1 = x1 + ox, y1 + oy\n        x2, y2 = x2 + ox, y2 + oy\n        x3, y3 = x3 + ox, y3 + oy\n        self.previous = x2, y2\n        vertices = geometry.cubic((x0, y0), (x1, y1), (x2, y2), (x3, y3))\n        return vertices[1:]",
  "class Quadratic(Command):\n\n    def __init__(self, x1=0, y1=0, x2=0, y2=0, relative=True):\n        self._command = 'q' if relative else 'Q'\n        self._args = [x1, y1, x2, y2]\n\n    def vertices(self, current, last_control_point=None):\n        ox, oy = self.origin(current)\n        x1, y1, x2, y2 = self._args\n        x0, y0 = current\n        x1, y1 = x1 + ox, y1 + oy\n        x2, y2 = x2 + ox, y2 + oy\n        self.previous = x1, y1\n        vertices = geometry.quadratic((x0, y0), (x1, y1), (x2, y2))\n\n        return vertices[1:]",
  "class SmoothCubic(Command):\n\n    def __init__(self, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = 's' if relative else 'S'\n        self._args = [x2, y2, x3, y3]\n\n    def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x0, y0 = current\n        x2, y2, x3, y3 = self._args\n        x2, y2 = x2 + ox, y2 + oy\n        x3, y3 = x3 + ox, y3 + oy\n        x1, y1 = 2 * x0 - previous[0], 2 * y0 - previous[1]\n        self.previous = x2, y2\n        vertices = geometry.cubic((x0, y0), (x1, y1), (x2, y2), (x3, y3))\n\n        return vertices[1:]",
  "class SmoothQuadratic(Command):\n\n    def __init__(self, x2=0, y2=0, relative=True):\n        self._command = 't' if relative else 'T'\n        self._args = [x2, y2]\n\n    def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x2, y2 = self._args\n        x0, y0 = current\n        x1, y1 = 2 * x0 - previous[0], 2 * y0 - previous[1]\n        x2, y2 = x2 + ox, y2 + oy\n        self.previous = x1, y1\n        vertices = geometry.quadratic((x0, y0), (x1, y1), (x2, y2))\n\n        return vertices[1:]",
  "class Path(Transformable):\n\n    def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n        self._paths = []\n\n        if not isinstance(content, str):\n            content = content.get(\"d\", \"\")\n\n        commands = re.compile(\n            r\"(?P<command>[MLVHCSQTAZmlvhcsqtaz])\"\n            r\"(?P<points>[+\\-0-9.e, \\n\\t]*)\")\n\n        path = []\n        for match in re.finditer(commands, content):\n            command = match.group(\"command\")\n            points = match.group(\"points\").replace(',', ' ')\n            points = [float(v) for v in points.split()]\n            relative = command in \"mlvhcsqtaz\"\n            command = command.upper()\n\n            while len(points) or command == 'Z':\n                if command == 'M':\n                    if len(path):\n                        self._paths.append(path)\n                    path = []\n                    path.append(Move(*points[:2], relative=relative))\n                    points = points[2:]\n                elif command == 'L':\n                    path.append(Line(*points[:2], relative=relative))\n                    points = points[2:]\n                elif command == 'V':\n                    path.append(VLine(*points[:1], relative=relative))\n                    points = points[1:]\n                elif command == 'H':\n                    path.append(HLine(*points[:1], relative=relative))\n                    points = points[1:]\n                elif command == 'C':\n                    path.append(Cubic(*points[:6], relative=relative))\n                    points = points[6:]\n                elif command == 'S':\n                    path.append(SmoothCubic(*points[:4], relative=relative))\n                    points = points[4:]\n                elif command == 'Q':\n                    path.append(Quadratic(*points[:4], relative=relative))\n                    points = points[4:]\n                elif command == 'T':\n                    path.append(\n                        SmoothQuadratic(*points[2:], relative=relative))\n                    points = points[2:]\n                elif command == 'A':\n                    path.append(Arc(*points[:7], relative=relative))\n                    points = points[7:]\n                elif command == 'Z':\n                    path.append(Close(relative=relative))\n                    self._paths.append(path)\n                    path = []\n                    break\n                else:\n                    raise RuntimeError(\n                        \"Unknown SVG path command(%s)\" % command)\n\n        if len(path):\n            self._paths.append(path)\n\n    def __repr__(self):\n        s = \"\"\n        for path in self._paths:\n            for item in path:\n                s += repr(item)\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=\"\"):\n        s = prefix + \"<path \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._style.xml\n        s += '\\n'\n        t = '     ' + prefix + ' d=\"'\n        s += t\n        prefix = ' ' * len(t)\n        first = True\n        for i, path in enumerate(self._paths):\n            for j, item in enumerate(path):\n                if first:\n                    s += repr(item)\n                    first = False\n                else:\n                    s += prefix + repr(item)\n                if i < len(self._paths) - 1 or j < len(path) - 1:\n                    s += '\\n'\n        s += '\"/>\\n'\n        return s\n\n    @property\n    def vertices(self):\n        self._vertices = []\n        current = 0, 0\n        previous = 0, 0\n\n        for path in self._paths:\n            vertices = []\n            for command in path:\n                V = command.vertices(current, previous)\n                previous = command.previous\n                vertices.extend(V)\n                if len(V) > 0:\n                    current = V[-1]\n                else:\n                    current = 0, 0\n\n            closed = False\n            if isinstance(command, Close):\n                closed = True\n                if len(vertices) > 2:\n                    d = geometry.calc_sq_distance(vertices[-1][0], vertices[-1][1],  # noqa\n                                                  vertices[0][0], vertices[0][1])  # noqa\n                    if d < epsilon:\n                        vertices = vertices[:-1]\n\n            # Apply transformation\n            V = np.ones((len(vertices), 3))\n            V[:, :2] = vertices\n            V = np.dot(V, self.transform.matrix.T)\n            V[:, 2] = 0\n            self._vertices.append((V, closed))\n\n        return self._vertices",
  "def __repr__(self):\n        s = '%s ' % self._command\n        for arg in self._args:\n            s += \"%.2f \" % arg\n        return s",
  "def origin(self, current=None, previous=None):\n        relative = self._command in \"mlvhcsqtaz\"\n\n        if relative and current:\n            return current\n        else:\n            return 0.0, 0.0",
  "def __init__(self, x=0, y=0, relative=True):\n        self._command = 'l' if relative else 'L'\n        self._args = [x, y]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x, y = self._args\n        self.previous = x, y\n\n        return (ox + x, oy + y),",
  "def __init__(self, y=0, relative=True):\n        self._command = 'v' if relative else 'V'\n        self._args = [y]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        y = self._args[0]\n        self.previous = ox, oy + y\n\n        return (ox, oy + y),",
  "def __init__(self, x=0, relative=True):\n        self._command = 'h' if relative else 'H'\n        self._args = [x]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x = self._args[0]\n        self.previous = ox + x, oy\n\n        return (ox + x, oy),",
  "def __init__(self, x=0, y=0, relative=True):\n        self._command = 'm' if relative else 'M'\n        self._args = [x, y]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x, y = self._args\n        x, y = x + ox, y + oy\n        self.previous = x, y\n        return (x, y),",
  "def __init__(self, relative=True):\n        self._command = 'z' if relative else 'Z'\n        self._args = []",
  "def vertices(self, current, previous=None):\n        self.previous = current\n        return []",
  "def __init__(self, r1=1, r2=1, angle=2 * math.pi, large=True, sweep=True,\n                 x=0, y=0, relative=True):\n        self._command = 'a' if relative else 'A'\n        self._args = [r1, r2, angle, large, sweep, x, y]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        rx, ry, angle, large, sweep, x, y = self._args\n        x, y = x + ox, y + oy\n        x0, y0 = current\n        self.previous = x, y\n        vertices = geometry.elliptical_arc(\n            x0, y0, rx, ry, angle, large, sweep, x, y)\n        return vertices[1:]",
  "def __init__(self, x1=0, y1=0, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = 'c' if relative else 'C'\n        self._args = [x1, y1, x2, y2, x3, y3]",
  "def vertices(self, current, previous=None):\n        ox, oy = self.origin(current)\n        x0, y0 = current\n        x1, y1, x2, y2, x3, y3 = self._args\n        x1, y1 = x1 + ox, y1 + oy\n        x2, y2 = x2 + ox, y2 + oy\n        x3, y3 = x3 + ox, y3 + oy\n        self.previous = x2, y2\n        vertices = geometry.cubic((x0, y0), (x1, y1), (x2, y2), (x3, y3))\n        return vertices[1:]",
  "def __init__(self, x1=0, y1=0, x2=0, y2=0, relative=True):\n        self._command = 'q' if relative else 'Q'\n        self._args = [x1, y1, x2, y2]",
  "def vertices(self, current, last_control_point=None):\n        ox, oy = self.origin(current)\n        x1, y1, x2, y2 = self._args\n        x0, y0 = current\n        x1, y1 = x1 + ox, y1 + oy\n        x2, y2 = x2 + ox, y2 + oy\n        self.previous = x1, y1\n        vertices = geometry.quadratic((x0, y0), (x1, y1), (x2, y2))\n\n        return vertices[1:]",
  "def __init__(self, x2=0, y2=0, x3=0, y3=0, relative=True):\n        self._command = 's' if relative else 'S'\n        self._args = [x2, y2, x3, y3]",
  "def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x0, y0 = current\n        x2, y2, x3, y3 = self._args\n        x2, y2 = x2 + ox, y2 + oy\n        x3, y3 = x3 + ox, y3 + oy\n        x1, y1 = 2 * x0 - previous[0], 2 * y0 - previous[1]\n        self.previous = x2, y2\n        vertices = geometry.cubic((x0, y0), (x1, y1), (x2, y2), (x3, y3))\n\n        return vertices[1:]",
  "def __init__(self, x2=0, y2=0, relative=True):\n        self._command = 't' if relative else 'T'\n        self._args = [x2, y2]",
  "def vertices(self, current, previous):\n        ox, oy = self.origin(current)\n        x2, y2 = self._args\n        x0, y0 = current\n        x1, y1 = 2 * x0 - previous[0], 2 * y0 - previous[1]\n        x2, y2 = x2 + ox, y2 + oy\n        self.previous = x1, y1\n        vertices = geometry.quadratic((x0, y0), (x1, y1), (x2, y2))\n\n        return vertices[1:]",
  "def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n        self._paths = []\n\n        if not isinstance(content, str):\n            content = content.get(\"d\", \"\")\n\n        commands = re.compile(\n            r\"(?P<command>[MLVHCSQTAZmlvhcsqtaz])\"\n            r\"(?P<points>[+\\-0-9.e, \\n\\t]*)\")\n\n        path = []\n        for match in re.finditer(commands, content):\n            command = match.group(\"command\")\n            points = match.group(\"points\").replace(',', ' ')\n            points = [float(v) for v in points.split()]\n            relative = command in \"mlvhcsqtaz\"\n            command = command.upper()\n\n            while len(points) or command == 'Z':\n                if command == 'M':\n                    if len(path):\n                        self._paths.append(path)\n                    path = []\n                    path.append(Move(*points[:2], relative=relative))\n                    points = points[2:]\n                elif command == 'L':\n                    path.append(Line(*points[:2], relative=relative))\n                    points = points[2:]\n                elif command == 'V':\n                    path.append(VLine(*points[:1], relative=relative))\n                    points = points[1:]\n                elif command == 'H':\n                    path.append(HLine(*points[:1], relative=relative))\n                    points = points[1:]\n                elif command == 'C':\n                    path.append(Cubic(*points[:6], relative=relative))\n                    points = points[6:]\n                elif command == 'S':\n                    path.append(SmoothCubic(*points[:4], relative=relative))\n                    points = points[4:]\n                elif command == 'Q':\n                    path.append(Quadratic(*points[:4], relative=relative))\n                    points = points[4:]\n                elif command == 'T':\n                    path.append(\n                        SmoothQuadratic(*points[2:], relative=relative))\n                    points = points[2:]\n                elif command == 'A':\n                    path.append(Arc(*points[:7], relative=relative))\n                    points = points[7:]\n                elif command == 'Z':\n                    path.append(Close(relative=relative))\n                    self._paths.append(path)\n                    path = []\n                    break\n                else:\n                    raise RuntimeError(\n                        \"Unknown SVG path command(%s)\" % command)\n\n        if len(path):\n            self._paths.append(path)",
  "def __repr__(self):\n        s = \"\"\n        for path in self._paths:\n            for item in path:\n                s += repr(item)\n        return s",
  "def xml(self):\n        return self._xml()",
  "def _xml(self, prefix=\"\"):\n        s = prefix + \"<path \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._style.xml\n        s += '\\n'\n        t = '     ' + prefix + ' d=\"'\n        s += t\n        prefix = ' ' * len(t)\n        first = True\n        for i, path in enumerate(self._paths):\n            for j, item in enumerate(path):\n                if first:\n                    s += repr(item)\n                    first = False\n                else:\n                    s += prefix + repr(item)\n                if i < len(self._paths) - 1 or j < len(path) - 1:\n                    s += '\\n'\n        s += '\"/>\\n'\n        return s",
  "def vertices(self):\n        self._vertices = []\n        current = 0, 0\n        previous = 0, 0\n\n        for path in self._paths:\n            vertices = []\n            for command in path:\n                V = command.vertices(current, previous)\n                previous = command.previous\n                vertices.extend(V)\n                if len(V) > 0:\n                    current = V[-1]\n                else:\n                    current = 0, 0\n\n            closed = False\n            if isinstance(command, Close):\n                closed = True\n                if len(vertices) > 2:\n                    d = geometry.calc_sq_distance(vertices[-1][0], vertices[-1][1],  # noqa\n                                                  vertices[0][0], vertices[0][1])  # noqa\n                    if d < epsilon:\n                        vertices = vertices[:-1]\n\n            # Apply transformation\n            V = np.ones((len(vertices), 3))\n            V[:, :2] = vertices\n            V = np.dot(V, self.transform.matrix.T)\n            V[:, 2] = 0\n            self._vertices.append((V, closed))\n\n        return self._vertices",
  "class Style(object):\n\n    def __init__(self):\n        self._unset = True\n        for key in _converters.keys():\n            key_ = key.replace(\"-\", \"_\")\n            self.__setattr__(key_, None)\n\n    def update(self, content):\n        if not content:\n            return\n\n        self._unset = False\n        items = content.strip().split(\";\")\n        attributes = dict([item.strip().split(\":\") for item in items if item])\n        for key, value in attributes.items():\n            if key in _converters:\n                key_ = key.replace(\"-\", \"_\")\n                self.__setattr__(key_, _converters[key](value))\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=\"\"):\n        if self._unset:\n            return \"\"\n\n        s = 'style=\"'\n        for key in _converters.keys():\n            key_ = key.replace(\"-\", \"_\")\n            value = self.__getattribute__(key_)\n            if value is not None:\n                s += '%s:%s ' % (key, value)\n        s += '\"'\n        return s",
  "def __init__(self):\n        self._unset = True\n        for key in _converters.keys():\n            key_ = key.replace(\"-\", \"_\")\n            self.__setattr__(key_, None)",
  "def update(self, content):\n        if not content:\n            return\n\n        self._unset = False\n        items = content.strip().split(\";\")\n        attributes = dict([item.strip().split(\":\") for item in items if item])\n        for key, value in attributes.items():\n            if key in _converters:\n                key_ = key.replace(\"-\", \"_\")\n                self.__setattr__(key_, _converters[key](value))",
  "def xml(self):\n        return self._xml()",
  "def _xml(self, prefix=\"\"):\n        if self._unset:\n            return \"\"\n\n        s = 'style=\"'\n        for key in _converters.keys():\n            key_ = key.replace(\"-\", \"_\")\n            value = self.__getattribute__(key_)\n            if value is not None:\n                s += '%s:%s ' % (key, value)\n        s += '\"'\n        return s",
  "class Element(object):\n    \"\"\"Generic SVG element\"\"\"\n\n    def __init__(self, content=None, parent=None):\n        self._parent = parent\n        self._id = hex(id(self))\n        self._style = Style()\n        self._computed_style = Style()\n\n        if isinstance(content, str):\n            return\n\n        self._id = content.get('id', self._id)\n        self._style.update(content.get(\"style\", None))\n        self._computed_style = Style()\n        if parent and parent.style:\n            self._computed_style = copy.copy(parent.style)\n            self._computed_style.update(content.get(\"style\", None))\n\n    @property\n    def root(self):\n        if self._parent:\n            return self._parent.root\n        return self\n\n    @property\n    def parent(self):\n        if self._parent:\n            return self._parent\n        return None\n\n    @property\n    def style(self):\n        return self._computed_style\n\n    @property\n    def viewport(self):\n        if self._parent:\n            return self._parent.viewport\n        return None",
  "def __init__(self, content=None, parent=None):\n        self._parent = parent\n        self._id = hex(id(self))\n        self._style = Style()\n        self._computed_style = Style()\n\n        if isinstance(content, str):\n            return\n\n        self._id = content.get('id', self._id)\n        self._style.update(content.get(\"style\", None))\n        self._computed_style = Style()\n        if parent and parent.style:\n            self._computed_style = copy.copy(parent.style)\n            self._computed_style.update(content.get(\"style\", None))",
  "def root(self):\n        if self._parent:\n            return self._parent.root\n        return self",
  "def parent(self):\n        if self._parent:\n            return self._parent\n        return None",
  "def style(self):\n        return self._computed_style",
  "def viewport(self):\n        if self._parent:\n            return self._parent.viewport\n        return None",
  "class SVG(Group):\n\n    def __init__(self, content=None, parent=None):\n        Group.__init__(self, content, parent)\n        self._viewport = Viewport(content)\n\n    @property\n    def viewport(self):\n        return self._viewport\n\n    def __repr__(self):\n        s = \"\"\n        for item in self._items:\n            s += repr(item) + \"\\n\"\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=\"\"):\n        s = \"<svg \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._viewport.xml\n        s += self._transform.xml\n        s += \"\\n\"\n        for item in self._items:\n            s += item._xml(prefix=prefix + \"    \") + \"\\n\"\n        s += \"</svg>\\n\"\n        return s",
  "def __init__(self, content=None, parent=None):\n        Group.__init__(self, content, parent)\n        self._viewport = Viewport(content)",
  "def viewport(self):\n        return self._viewport",
  "def __repr__(self):\n        s = \"\"\n        for item in self._items:\n            s += repr(item) + \"\\n\"\n        return s",
  "def xml(self):\n        return self._xml()",
  "def _xml(self, prefix=\"\"):\n        s = \"<svg \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._viewport.xml\n        s += self._transform.xml\n        s += \"\\n\"\n        for item in self._items:\n            s += item._xml(prefix=prefix + \"    \") + \"\\n\"\n        s += \"</svg>\\n\"\n        return s",
  "class Viewport(object):\n\n    def __init__(self, content=None, parent=None):\n\n        self._x = None\n        self._computed_x = 0\n        if content.get('x'):\n            self._x = XLength(content.get('x'), parent)\n            self._computed_x = float(self._x)\n\n        self._y = None\n        self._computed_y = 0\n        if content.get('y'):\n            self._y = XLength(content.get('y'), parent)\n            self._computed_y = float(self._y)\n\n        self._width = None\n        self._computed_width = 800\n        if content.get('width'):\n            self._width = XLength(content.get('width'), parent)\n            self._computed_width = float(self._width)\n\n        self._height = None\n        self._computed_height = 800\n        if content.get('height'):\n            self._height = YLength(content.get('height'), parent)\n            self._computed_height = float(self._height)\n\n    @property\n    def x(self):\n        return self._computed_x\n\n    @property\n    def y(self):\n        return self._computed_y\n\n    @property\n    def width(self):\n        return self._computed_width\n\n    @property\n    def height(self):\n        return self._computed_height\n\n    def __repr__(self):\n        s = repr((self._x, self._y, self._width, self._height))\n        return s\n\n    @property\n    def xml(self):\n        return self._xml\n\n    @property\n    def _xml(self, prefix=\"\"):\n        s = \"\"\n        if self._x:\n            s += 'x=\"%s\" ' % repr(self._x)\n        if self._y:\n            s += 'y=\"%s\" ' % repr(self._y)\n        if self._width:\n            s += 'width=\"%s\" ' % repr(self._width)\n        if self._height:\n            s += 'height=\"%s\" ' % repr(self._height)\n        return s",
  "def __init__(self, content=None, parent=None):\n\n        self._x = None\n        self._computed_x = 0\n        if content.get('x'):\n            self._x = XLength(content.get('x'), parent)\n            self._computed_x = float(self._x)\n\n        self._y = None\n        self._computed_y = 0\n        if content.get('y'):\n            self._y = XLength(content.get('y'), parent)\n            self._computed_y = float(self._y)\n\n        self._width = None\n        self._computed_width = 800\n        if content.get('width'):\n            self._width = XLength(content.get('width'), parent)\n            self._computed_width = float(self._width)\n\n        self._height = None\n        self._computed_height = 800\n        if content.get('height'):\n            self._height = YLength(content.get('height'), parent)\n            self._computed_height = float(self._height)",
  "def x(self):\n        return self._computed_x",
  "def y(self):\n        return self._computed_y",
  "def width(self):\n        return self._computed_width",
  "def height(self):\n        return self._computed_height",
  "def __repr__(self):\n        s = repr((self._x, self._y, self._width, self._height))\n        return s",
  "def xml(self):\n        return self._xml",
  "def _xml(self, prefix=\"\"):\n        s = \"\"\n        if self._x:\n            s += 'x=\"%s\" ' % repr(self._x)\n        if self._y:\n            s += 'y=\"%s\" ' % repr(self._y)\n        if self._width:\n            s += 'width=\"%s\" ' % repr(self._width)\n        if self._height:\n            s += 'height=\"%s\" ' % repr(self._height)\n        return s",
  "class Matrix(object):\n\n    def __init__(self, a=1, b=0, c=0, d=1, e=0, f=0):\n        self._matrix = np.array([[a, c, e],\n                                 [b, d, f],\n                                 [0, 0, 1]], dtype=float)\n\n    @property\n    def matrix(self):\n        return self._matrix\n\n    def __array__(self, *args):\n        return self._matrix\n\n    def __repr__(self):\n        a, c, e = self._matrix[0]\n        b, d, f = self._matrix[1]\n        return \"Matrix(%g,%g,%g,%g,%g,%g)\" % (a, b, c, d, e, f)",
  "class Identity(Matrix):\n\n    def __init__(self):\n        Matrix.__init__(self)\n        self._matrix[...] = ([[1, 0, 0],\n                              [0, 1, 0],\n                              [0, 0, 1]])\n\n    def __repr__(self):\n        return \"Identity()\"",
  "class Translate(Matrix):\n    \"\"\"\n    Translation is equivalent to the matrix [1 0 0 1 tx ty], where tx and ty\n    are the distances to translate coordinates in X and Y, respectively.\n    \"\"\"\n\n    def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x, self._y = x, y\n        self._matrix[...] = ([[1, 0, x],\n                              [0, 1, y],\n                              [0, 0, 1]])\n\n    def __repr__(self):\n        return \"Translate(%g,%g)\" % (self._x, self._y)",
  "class Scale(Matrix):\n    \"\"\"\n    Scaling is equivalent to the matrix [sx 0 0 sy 0 0]. One unit in the X and\n    Y directions in the new coordinate system equals sx and sy units in the\n    previous coordinate system, respectively.\n    \"\"\"\n\n    def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x = x\n        self._y = y or x\n        self._matrix[...] = ([[x, 0, 0],\n                              [0, y, 0],\n                              [0, 0, 1]])\n\n    def __repr__(self):\n        return \"Scale(%g,%g)\" % (self._x, self._y)",
  "class Rotate(Matrix):\n    \"\"\"\n    Rotation about the origin is equivalent to the matrix [cos(a) sin(a)\n    -sin(a) cos(a) 0 0], which has the effect of rotating the coordinate system\n    axes by angle a.\n    \"\"\"\n\n    def __init__(self, angle, x=0, y=0):\n        Matrix.__init__(self)\n        self._angle = angle\n        self._x = x\n        self._y = y\n\n        angle = math.pi * angle / 180.0\n        rotate = np.array([[math.cos(angle), -math.sin(angle), 0],\n                           [math.sin(angle), math.cos(angle), 0],\n                           [0, 0, 1]], dtype=float)\n        forward = np.array([[1, 0, x],\n                            [0, 1, y],\n                            [0, 0, 1]], dtype=float)\n        inverse = np.array([[1, 0, -x],\n                            [0, 1, -y],\n                            [0, 0, 1]], dtype=float)\n        self._matrix = np.dot(inverse, np.dot(rotate, forward))\n\n    def __repr__(self):\n        return \"Rotate(%g,%g,%g)\" % (self._angle, self._x, self._y)",
  "class SkewX(Matrix):\n    \"\"\"\n    A skew transformation along the x-axis is equivalent to the matrix [1 0\n    tan(a) 1 0 0], which has the effect of skewing X coordinates by angle a.\n    \"\"\"\n\n    def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi * angle / 180.0\n        self._matrix[...] = ([[1, math.tan(angle), 0],\n                              [0, 1, 0],\n                              [0, 0, 1]])\n\n    def __repr__(self):\n        return \"SkewX(%g)\" % (self._angle)",
  "class SkewY(Matrix):\n    \"\"\"\n    A skew transformation along the y-axis is equivalent to the matrix [1\n    tan(a) 0 1 0 0], which has the effect of skewing Y coordinates by angle a.\n    \"\"\"\n\n    def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi * angle / 180.0\n        self._matrix[...] = ([[1, 0, 0],\n                              [math.tan(angle), 1, 0],\n                              [0, 0, 1]])\n\n    def __repr__(self):\n        return \"SkewY(%g)\" % (self._angle)",
  "class Transform(object):\n    \"\"\"\n    A Transform is defined as a list of transform definitions, which are\n    applied in the order provided. The individual transform definitions are\n    separated by whitespace and/or a comma.\n    \"\"\"\n\n    def __init__(self, content=\"\"):\n        self._transforms = []\n        if not content:\n            return\n\n        converters = {\"matrix\": Matrix,\n                      \"scale\": Scale,\n                      \"rotate\": Rotate,\n                      \"translate\": Translate,\n                      \"skewx\": SkewX,\n                      \"skewy\": SkewY}\n        keys = \"|\".join(converters.keys())\n        pattern = r\"(?P<name>%s)\\s*\\((?P<args>[^)]*)\\)\" % keys\n\n        for match in re.finditer(pattern, content):\n            name = match.group(\"name\").strip()\n            args = match.group(\"args\").strip().replace(',', ' ')\n            args = [float(value) for value in args.split()]\n            transform = converters[name](*args)\n            self._transforms.append(transform)\n\n    def __add__(self, other):\n        T = Transform()\n        T._transforms.extend(self._transforms)\n        T._transforms.extend(other._transforms)\n        return T\n\n    def __radd__(self, other):\n        self._transforms.extend(other._transforms)\n        return self\n\n    @property\n    def matrix(self):\n        M = np.eye(3)\n        for transform in self._transforms:\n            M = np.dot(M, transform)\n        return M\n\n    def __array__(self, *args):\n        return self._matrix\n\n    def __repr__(self):\n        s = \"\"\n        for i in range(len(self._transforms)):\n            s += repr(self._transforms[i])\n            if i < len(self._transforms) - 1:\n                s += \", \"\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=\"\"):\n\n        identity = True\n        for transform in self._transforms:\n            if not isinstance(transform, Identity):\n                identity = False\n                break\n        if identity:\n            return \"\"\n\n        return 'transform=\"%s\" ' % repr(self)",
  "def __init__(self, a=1, b=0, c=0, d=1, e=0, f=0):\n        self._matrix = np.array([[a, c, e],\n                                 [b, d, f],\n                                 [0, 0, 1]], dtype=float)",
  "def matrix(self):\n        return self._matrix",
  "def __array__(self, *args):\n        return self._matrix",
  "def __repr__(self):\n        a, c, e = self._matrix[0]\n        b, d, f = self._matrix[1]\n        return \"Matrix(%g,%g,%g,%g,%g,%g)\" % (a, b, c, d, e, f)",
  "def __init__(self):\n        Matrix.__init__(self)\n        self._matrix[...] = ([[1, 0, 0],\n                              [0, 1, 0],\n                              [0, 0, 1]])",
  "def __repr__(self):\n        return \"Identity()\"",
  "def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x, self._y = x, y\n        self._matrix[...] = ([[1, 0, x],\n                              [0, 1, y],\n                              [0, 0, 1]])",
  "def __repr__(self):\n        return \"Translate(%g,%g)\" % (self._x, self._y)",
  "def __init__(self, x, y=0):\n        Matrix.__init__(self)\n        self._x = x\n        self._y = y or x\n        self._matrix[...] = ([[x, 0, 0],\n                              [0, y, 0],\n                              [0, 0, 1]])",
  "def __repr__(self):\n        return \"Scale(%g,%g)\" % (self._x, self._y)",
  "def __init__(self, angle, x=0, y=0):\n        Matrix.__init__(self)\n        self._angle = angle\n        self._x = x\n        self._y = y\n\n        angle = math.pi * angle / 180.0\n        rotate = np.array([[math.cos(angle), -math.sin(angle), 0],\n                           [math.sin(angle), math.cos(angle), 0],\n                           [0, 0, 1]], dtype=float)\n        forward = np.array([[1, 0, x],\n                            [0, 1, y],\n                            [0, 0, 1]], dtype=float)\n        inverse = np.array([[1, 0, -x],\n                            [0, 1, -y],\n                            [0, 0, 1]], dtype=float)\n        self._matrix = np.dot(inverse, np.dot(rotate, forward))",
  "def __repr__(self):\n        return \"Rotate(%g,%g,%g)\" % (self._angle, self._x, self._y)",
  "def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi * angle / 180.0\n        self._matrix[...] = ([[1, math.tan(angle), 0],\n                              [0, 1, 0],\n                              [0, 0, 1]])",
  "def __repr__(self):\n        return \"SkewX(%g)\" % (self._angle)",
  "def __init__(self, angle):\n        Matrix.__init__(self)\n        self._angle = angle\n        angle = math.pi * angle / 180.0\n        self._matrix[...] = ([[1, 0, 0],\n                              [math.tan(angle), 1, 0],\n                              [0, 0, 1]])",
  "def __repr__(self):\n        return \"SkewY(%g)\" % (self._angle)",
  "def __init__(self, content=\"\"):\n        self._transforms = []\n        if not content:\n            return\n\n        converters = {\"matrix\": Matrix,\n                      \"scale\": Scale,\n                      \"rotate\": Rotate,\n                      \"translate\": Translate,\n                      \"skewx\": SkewX,\n                      \"skewy\": SkewY}\n        keys = \"|\".join(converters.keys())\n        pattern = r\"(?P<name>%s)\\s*\\((?P<args>[^)]*)\\)\" % keys\n\n        for match in re.finditer(pattern, content):\n            name = match.group(\"name\").strip()\n            args = match.group(\"args\").strip().replace(',', ' ')\n            args = [float(value) for value in args.split()]\n            transform = converters[name](*args)\n            self._transforms.append(transform)",
  "def __add__(self, other):\n        T = Transform()\n        T._transforms.extend(self._transforms)\n        T._transforms.extend(other._transforms)\n        return T",
  "def __radd__(self, other):\n        self._transforms.extend(other._transforms)\n        return self",
  "def matrix(self):\n        M = np.eye(3)\n        for transform in self._transforms:\n            M = np.dot(M, transform)\n        return M",
  "def __array__(self, *args):\n        return self._matrix",
  "def __repr__(self):\n        s = \"\"\n        for i in range(len(self._transforms)):\n            s += repr(self._transforms[i])\n            if i < len(self._transforms) - 1:\n                s += \", \"\n        return s",
  "def xml(self):\n        return self._xml()",
  "def _xml(self, prefix=\"\"):\n\n        identity = True\n        for transform in self._transforms:\n            if not isinstance(transform, Identity):\n                identity = False\n                break\n        if identity:\n            return \"\"\n\n        return 'transform=\"%s\" ' % repr(self)",
  "class Rect(object):\n\n    def __init__(self, x=0, y=0, width=1, height=1, rx=0, ry=0):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.height = height\n        self.rx = rx\n        self.ry = ry\n\n    def parse(self, expression):\n        \"\"\" \"\"\"",
  "class Line(object):\n\n    def __init__(self, x1=0, y1=0, x2=0, y2=0):\n        self.x1 = x2\n        self.y1 = y2\n        self.x2 = x2\n        self.y2 = y2",
  "class Circle(object):\n\n    def __init__(self, cx=0, cy=0, r=1):\n        self.cx = cx\n        self.cy = cy\n        self.r = r",
  "class Ellipse(object):\n\n    def __init__(self, cx=0, cy=0, rx=1, ry=1):\n        self.cx = cx\n        self.cy = cy\n        self.rx = rx\n        self.ry = ry",
  "class Polygon(object):\n\n    def __init__(self, points=[]):\n        self.points = points",
  "class Polyline(object):\n\n    def __init__(self, points=[]):\n        self.points = points",
  "def __init__(self, x=0, y=0, width=1, height=1, rx=0, ry=0):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.height = height\n        self.rx = rx\n        self.ry = ry",
  "def parse(self, expression):\n        \"\"\" \"\"\"",
  "def __init__(self, x1=0, y1=0, x2=0, y2=0):\n        self.x1 = x2\n        self.y1 = y2\n        self.x2 = x2\n        self.y2 = y2",
  "def __init__(self, cx=0, cy=0, r=1):\n        self.cx = cx\n        self.cy = cy\n        self.r = r",
  "def __init__(self, cx=0, cy=0, rx=1, ry=1):\n        self.cx = cx\n        self.cy = cy\n        self.rx = rx\n        self.ry = ry",
  "def __init__(self, points=[]):\n        self.points = points",
  "def __init__(self, points=[]):\n        self.points = points",
  "class Transformable(Element):\n    \"\"\"Transformable SVG element\"\"\"\n\n    def __init__(self, content=None, parent=None):\n        Element.__init__(self, content, parent)\n\n        if isinstance(content, str):\n            self._transform = Transform()\n            self._computed_transform = self._transform\n        else:\n            self._transform = Transform(content.get(\"transform\", None))\n            self._computed_transform = self._transform\n            if parent:\n                self._computed_transform = self._transform + \\\n                    self.parent.transform\n\n    @property\n    def transform(self):\n        return self._computed_transform",
  "def __init__(self, content=None, parent=None):\n        Element.__init__(self, content, parent)\n\n        if isinstance(content, str):\n            self._transform = Transform()\n            self._computed_transform = self._transform\n        else:\n            self._transform = Transform(content.get(\"transform\", None))\n            self._computed_transform = self._transform\n            if parent:\n                self._computed_transform = self._transform + \\\n                    self.parent.transform",
  "def transform(self):\n        return self._computed_transform",
  "class Length(object):\n\n    def __init__(self, content, mode='x', parent=None):\n\n        if not content:\n            self._unit = None\n            self._value = 0\n            self._computed_value = 0\n            return\n\n        re_number = r'[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?'\n        re_unit = r'em|ex|px|in|cm|mm|pt|pc|%'\n        re_length = r'(?P<value>%s)\\s*(?P<unit>%s)*' % (re_number, re_unit)\n        match = re.match(re_length, content)\n\n        if match:\n            self._value = float(match.group(\"value\"))\n            self._unit = match.group(\"unit\") or \"px\"\n        else:\n            self._value = 0.0\n            self._unit = None\n\n        scale = 1\n        if self._unit == '%':\n            if not parent:\n                logger.warn(\"No parent for computing length using percent\")\n            elif hasattr(parent, 'viewport'):\n                w, h = parent.viewport\n                if mode == 'x':\n                    scale = w\n                elif mode == 'y':\n                    scale = h\n                elif mode == 'xy':\n                    scale = math.sqrt(w * w + h * h) / math.sqrt(2.0)\n            else:\n                logger.warn(\"Parent doesn't have a viewport\")\n\n        self._computed_value = self._value * units[self._unit] * scale\n\n    def __float__(self):\n        return self._computed_value\n\n    @property\n    def value(self):\n        return self._computed_value\n\n    def __repr__(self):\n        if self._unit:\n            return \"%g%s\" % (self._value, self._unit)\n        else:\n            return \"%g\" % (self._value)",
  "class XLength(Length):\n\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'x', parent)",
  "class YLength(Length):\n\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'y', parent)",
  "class XYLength(Length):\n\n    def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'xy', parent)",
  "def __init__(self, content, mode='x', parent=None):\n\n        if not content:\n            self._unit = None\n            self._value = 0\n            self._computed_value = 0\n            return\n\n        re_number = r'[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?'\n        re_unit = r'em|ex|px|in|cm|mm|pt|pc|%'\n        re_length = r'(?P<value>%s)\\s*(?P<unit>%s)*' % (re_number, re_unit)\n        match = re.match(re_length, content)\n\n        if match:\n            self._value = float(match.group(\"value\"))\n            self._unit = match.group(\"unit\") or \"px\"\n        else:\n            self._value = 0.0\n            self._unit = None\n\n        scale = 1\n        if self._unit == '%':\n            if not parent:\n                logger.warn(\"No parent for computing length using percent\")\n            elif hasattr(parent, 'viewport'):\n                w, h = parent.viewport\n                if mode == 'x':\n                    scale = w\n                elif mode == 'y':\n                    scale = h\n                elif mode == 'xy':\n                    scale = math.sqrt(w * w + h * h) / math.sqrt(2.0)\n            else:\n                logger.warn(\"Parent doesn't have a viewport\")\n\n        self._computed_value = self._value * units[self._unit] * scale",
  "def __float__(self):\n        return self._computed_value",
  "def value(self):\n        return self._computed_value",
  "def __repr__(self):\n        if self._unit:\n            return \"%g%s\" % (self._value, self._unit)\n        else:\n            return \"%g\" % (self._value)",
  "def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'x', parent)",
  "def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'y', parent)",
  "def __init__(self, content, parent=None):\n        Length.__init__(self, content, 'xy', parent)",
  "class Number(object):\n\n    def __init__(self, content):\n        if not content:\n            self._value = 0\n        else:\n            content = content.strip()\n            self._value = float(content)\n\n    def __float__(self):\n        return self._value\n\n    @property\n    def value(self):\n        return self._value\n\n    def __repr__(self):\n        return repr(self._value)",
  "def __init__(self, content):\n        if not content:\n            self._value = 0\n        else:\n            content = content.strip()\n            self._value = float(content)",
  "def __float__(self):\n        return self._value",
  "def value(self):\n        return self._value",
  "def __repr__(self):\n        return repr(self._value)",
  "def Document(filename):\n    tree = ElementTree.parse(filename)\n    root = tree.getroot()\n    if root.tag != namespace + 'svg':\n        text = 'File \"%s\" does not seem to be a valid SVG file' % filename\n        raise TypeError(text)\n    return SVG(root)",
  "def _rgb(triplet):\n    return _HEXDEC[triplet[0:2]], _HEXDEC[triplet[2:4]], _HEXDEC[triplet[4:6]]",
  "class Color(object):\n\n    def __init__(self, content):\n\n        color = content.strip()\n        if color.startswith(\"#\"):\n            rgb = color[1:]\n            if len(rgb) == 3:\n                r, g, b = tuple(ord((c + c).decode('hex')) for c in rgb)\n            else:\n                # r,g,b = tuple(ord(c) for c in rgb.decode('hex'))\n                r, g, b = tuple(c for c in _rgb(rgb))\n        elif color.startswith(\"rgb(\"):\n            rgb = color[4:-1]\n            r, g, b = [value.strip() for value in rgb.split(',')]\n            if r.endswith(\"%\"):\n                r = 255 * int(r[:-1]) // 100\n            else:\n                r = int(r)\n            if g.endswith(\"%\"):\n                g = 255 * int(g[:-1]) // 100\n            else:\n                g = int(r)\n            if b.endswith(\"%\"):\n                b = 255 * int(b[:-1]) // 100\n            else:\n                b = int(r)\n        elif color in _keyword_colors:\n            r, g, b = _keyword_colors[color]\n        else:\n            # text = \"Unknown color (%s)\" % color\n            r, g, b = 0, 0, 0\n        self._rgb = r / 255., g / 255., b / 255.\n\n    @property\n    def rgb(self):\n        r, g, b = self._rgb\n        return r, g, b\n\n    @property\n    def rgba(self):\n        r, g, b = self._rgb\n        return r, g, b, 1\n\n    def __repr__(self):\n        r, g, b = self._rgb\n        r, g, b = int(r * 255), int(g * 255), int(b * 255)\n        return \"#%02x%02x%02x\" % (r, g, b)",
  "def __init__(self, content):\n\n        color = content.strip()\n        if color.startswith(\"#\"):\n            rgb = color[1:]\n            if len(rgb) == 3:\n                r, g, b = tuple(ord((c + c).decode('hex')) for c in rgb)\n            else:\n                # r,g,b = tuple(ord(c) for c in rgb.decode('hex'))\n                r, g, b = tuple(c for c in _rgb(rgb))\n        elif color.startswith(\"rgb(\"):\n            rgb = color[4:-1]\n            r, g, b = [value.strip() for value in rgb.split(',')]\n            if r.endswith(\"%\"):\n                r = 255 * int(r[:-1]) // 100\n            else:\n                r = int(r)\n            if g.endswith(\"%\"):\n                g = 255 * int(g[:-1]) // 100\n            else:\n                g = int(r)\n            if b.endswith(\"%\"):\n                b = 255 * int(b[:-1]) // 100\n            else:\n                b = int(r)\n        elif color in _keyword_colors:\n            r, g, b = _keyword_colors[color]\n        else:\n            # text = \"Unknown color (%s)\" % color\n            r, g, b = 0, 0, 0\n        self._rgb = r / 255., g / 255., b / 255.",
  "def rgb(self):\n        r, g, b = self._rgb\n        return r, g, b",
  "def rgba(self):\n        r, g, b = self._rgb\n        return r, g, b, 1",
  "def __repr__(self):\n        r, g, b = self._rgb\n        r, g, b = int(r * 255), int(g * 255), int(b * 255)\n        return \"#%02x%02x%02x\" % (r, g, b)",
  "class Group(Transformable):\n\n    def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n\n        self._items = []\n        for element in content:\n            if not element.tag.startswith(namespace):\n                continue\n            tag = element.tag[len(namespace):]\n            if tag == \"g\":\n                item = Group(element, self)\n            elif tag == \"path\":\n                item = Path(element, self)\n            else:\n                logger.warn(\"Unhandled SVG tag (%s)\" % tag)\n                continue\n            self._items.append(item)\n\n    @property\n    def flatten(self):\n        i = 0\n        L = copy.deepcopy(self._items)\n        while i < len(L):\n            while isinstance(L[i], Group) and len(L[i]._items):\n                L[i:i + 1] = L[i]._items\n            i += 1\n        return L\n\n    @property\n    def paths(self):\n        return [item for item in self.flatten if isinstance(item, Path)]\n\n    def __repr__(self):\n        s = \"\"\n        for item in self._items:\n            s += repr(item)\n        return s\n\n    @property\n    def xml(self):\n        return self._xml()\n\n    def _xml(self, prefix=\"\"):\n        s = prefix + \"<g \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._transform.xml\n        s += self._style.xml\n        s += \">\\n\"\n        for item in self._items:\n            s += item._xml(prefix=prefix + \"   \")\n        s += prefix + \"</g>\\n\"\n        return s",
  "def __init__(self, content=None, parent=None):\n        Transformable.__init__(self, content, parent)\n\n        self._items = []\n        for element in content:\n            if not element.tag.startswith(namespace):\n                continue\n            tag = element.tag[len(namespace):]\n            if tag == \"g\":\n                item = Group(element, self)\n            elif tag == \"path\":\n                item = Path(element, self)\n            else:\n                logger.warn(\"Unhandled SVG tag (%s)\" % tag)\n                continue\n            self._items.append(item)",
  "def flatten(self):\n        i = 0\n        L = copy.deepcopy(self._items)\n        while i < len(L):\n            while isinstance(L[i], Group) and len(L[i]._items):\n                L[i:i + 1] = L[i]._items\n            i += 1\n        return L",
  "def paths(self):\n        return [item for item in self.flatten if isinstance(item, Path)]",
  "def __repr__(self):\n        s = \"\"\n        for item in self._items:\n            s += repr(item)\n        return s",
  "def xml(self):\n        return self._xml()",
  "def _xml(self, prefix=\"\"):\n        s = prefix + \"<g \"\n        s += 'id=\"%s\" ' % self._id\n        s += self._transform.xml\n        s += self._style.xml\n        s += \">\\n\"\n        for item in self._items:\n            s += item._xml(prefix=prefix + \"   \")\n        s += prefix + \"</g>\\n\"\n        return s",
  "def calc_sq_distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    return dx * dx + dy * dy",
  "def quadratic_recursive(points, x1, y1, x2, y2, x3, y3, level=0):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12 = (x1 + x2) / 2.\n    y12 = (y1 + y2) / 2.\n    x23 = (x2 + x3) / 2.\n    y23 = (y2 + y3) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n\n    dx = x3 - x1\n    dy = y3 - y1\n    d = math.fabs((x2 - x3) * dy - (y2 - y3) * dx)\n\n    if d > curve_collinearity_epsilon:\n        # Regular case\n        # ------------\n        if d * d <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x123, y123))\n                return\n\n            # Angle & Cusp Condition\n            da = math.fabs(\n                math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da >= math.pi:\n                da = 2 * math.pi - da\n\n            if da < m_angle_tolerance:\n                # Finally we can stop the recursion\n                points.append((x123, y123))\n                return\n    else:\n        # Collinear case\n        # --------------\n        da = dx * dx + dy * dy\n        if da == 0:\n            d = calc_sq_distance(x1, y1, x2, y2)\n        else:\n            d = ((x2 - x1) * dx + (y2 - y1) * dy) / da\n            if d > 0 and d < 1:\n                # Simple collinear case, 1---2---3, we can leave just two\n                # endpoints\n                return\n            if(d <= 0):\n                d = calc_sq_distance(x2, y2, x1, y1)\n            elif d >= 1:\n                d = calc_sq_distance(x2, y2, x3, y3)\n            else:\n                d = calc_sq_distance(x2, y2, x1 + d * dx, y1 + d * dy)\n\n        if d < m_distance_tolerance_square:\n            points.append((x2, y2))\n            return\n\n    # Continue subdivision\n    # --------------------\n    quadratic_recursive(points, x1, y1, x12, y12, x123, y123, level + 1)\n    quadratic_recursive(points, x123, y123, x23, y23, x3, y3, level + 1)",
  "def cubic_recursive(points, x1, y1, x2, y2, x3, y3, x4, y4, level=0):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    # -------------------------------------------------\n    x12 = (x1 + x2) / 2.\n    y12 = (y1 + y2) / 2.\n    x23 = (x2 + x3) / 2.\n    y23 = (y2 + y3) / 2.\n    x34 = (x3 + x4) / 2.\n    y34 = (y3 + y4) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n    x234 = (x23 + x34) / 2.\n    y234 = (y23 + y34) / 2.\n    x1234 = (x123 + x234) / 2.\n    y1234 = (y123 + y234) / 2.\n\n    # Try to approximate the full cubic curve by a single straight line\n    # -----------------------------------------------------------------\n    dx = x4 - x1\n    dy = y4 - y1\n    d2 = math.fabs(((x2 - x4) * dy - (y2 - y4) * dx))\n    d3 = math.fabs(((x3 - x4) * dy - (y3 - y4) * dx))\n\n    s = int((d2 > curve_collinearity_epsilon) << 1) + \\\n        int(d3 > curve_collinearity_epsilon)\n\n    if s == 0:\n        # All collinear OR p1==p4\n        # ----------------------\n        k = dx * dx + dy * dy\n        if k == 0:\n            d2 = calc_sq_distance(x1, y1, x2, y2)\n            d3 = calc_sq_distance(x4, y4, x3, y3)\n\n        else:\n            k = 1. / k\n            da1 = x2 - x1\n            da2 = y2 - y1\n            d2 = k * (da1 * dx + da2 * dy)\n            da1 = x3 - x1\n            da2 = y3 - y1\n            d3 = k * (da1 * dx + da2 * dy)\n            if d2 > 0 and d2 < 1 and d3 > 0 and d3 < 1:\n                # Simple collinear case, 1---2---3---4\n                # We can leave just two endpoints\n                return\n\n            if d2 <= 0:\n                d2 = calc_sq_distance(x2, y2, x1, y1)\n            elif d2 >= 1:\n                d2 = calc_sq_distance(x2, y2, x4, y4)\n            else:\n                d2 = calc_sq_distance(x2, y2, x1 + d2 * dx, y1 + d2 * dy)\n\n            if d3 <= 0:\n                d3 = calc_sq_distance(x3, y3, x1, y1)\n            elif d3 >= 1:\n                d3 = calc_sq_distance(x3, y3, x4, y4)\n            else:\n                d3 = calc_sq_distance(x3, y3, x1 + d3 * dx, y1 + d3 * dy)\n\n        if d2 > d3:\n            if d2 < m_distance_tolerance_square:\n                points.append((x2, y2))\n                return\n        else:\n            if d3 < m_distance_tolerance_square:\n                points.append((x3, y3))\n                return\n\n    elif s == 1:\n        # p1,p2,p4 are collinear, p3 is significant\n        # -----------------------------------------\n        if d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(\n                math.atan2(y4 - y3, x4 - x3) - math.atan2(y3 - y2, x3 - x2))\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend([(x2, y2), (x3, y3)])\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x3, y3))\n                    return\n\n    elif s == 2:\n        # p1,p3,p4 are collinear, p2 is significant\n        # -----------------------------------------\n        if d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(\n                math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend([(x2, y2), (x3, y3)])\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x2, y2))\n                    return\n\n    elif s == 3:\n        # Regular case\n        # ------------\n        if (d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy):  # noqa\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle & Cusp Condition\n            # ----------------------\n            k = math.atan2(y3 - y2, x3 - x2)\n            da1 = math.fabs(k - math.atan2(y2 - y1, x2 - x1))\n            da2 = math.fabs(math.atan2(y4 - y3, x4 - x3) - k)\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n            if da2 >= math.pi:\n                da2 = 2 * math.pi - da2\n\n            if da1 + da2 < m_angle_tolerance:\n                # Finally we can stop the recursion\n                # ---------------------------------\n                points.append((x23, y23))\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x2, y2))\n                    return\n\n                if da2 > m_cusp_limit:\n                    points.append((x3, y3))\n                    return\n\n    # Continue subdivision\n    # --------------------\n    cubic_recursive(\n        points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1)\n    cubic_recursive(\n        points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1)",
  "def quadratic(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    points = []\n    quadratic_recursive(points, x1, y1, x2, y2, x3, y3)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > epsilon:\n        points.insert(0, (x1, y1))\n\n    dx, dy = points[-1][0] - x3, points[-1][1] - y3\n    if (dx * dx + dy * dy) > epsilon:\n        points.append((x3, y3))\n\n    return points",
  "def cubic(p1, p2, p3, p4):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    points = []\n    cubic_recursive(points, x1, y1, x2, y2, x3, y3, x4, y4)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > epsilon:\n        points.insert(0, (x1, y1))\n    dx, dy = points[-1][0] - x4, points[-1][1] - y4\n    if (dx * dx + dy * dy) > epsilon:\n        points.append((x4, y4))\n\n    return points",
  "def arc(cx, cy, rx, ry, a1, a2, ccw=False):\n    scale = 1.0\n    ra = (abs(rx) + abs(ry)) / 2.0\n    da = math.acos(ra / (ra + 0.125 / scale)) * 2.0\n    if ccw:\n        while a2 < a1:\n            a2 += math.pi * 2.0\n    else:\n        while a1 < a2:\n            a1 += math.pi * 2.0\n        da = -da\n    a_start = a1\n    a_end = a2\n\n    vertices = []\n    angle = a_start\n    while (angle < a_end - da / 4) == ccw:\n        x = cx + math.cos(angle) * rx\n        y = cy + math.sin(angle) * ry\n        vertices.append((x, y))\n        angle += da\n    x = cx + math.cos(a_end) * rx\n    y = cy + math.sin(a_end) * ry\n    vertices.append((x, y))\n    return vertices",
  "def elliptical_arc(x0, y0, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2):\n    radii_ok = True\n    cos_a = math.cos(angle)\n    sin_a = math.sin(angle)\n    if rx < 0.0:\n        rx = -rx\n    if ry < 0.0:\n        ry = -rx\n\n    # Calculate the middle point between\n    # the current and the final points\n    # ------------------------\n    dx2 = (x0 - x2) / 2.0\n    dy2 = (y0 - y2) / 2.0\n\n    # Calculate (x1, y1)\n    # ------------------------\n    x1 = cos_a * dx2 + sin_a * dy2\n    y1 = -sin_a * dx2 + cos_a * dy2\n\n    # Check that radii are large enough\n    # ------------------------\n    prx, pry = rx * rx, ry * ry\n    px1, py1 = x1 * x1, y1 * y1\n\n    radii_check = px1 / prx + py1 / pry\n    if radii_check > 1.0:\n        rx = math.sqrt(radii_check) * rx\n        ry = math.sqrt(radii_check) * ry\n        prx = rx * rx\n        pry = ry * ry\n        if radii_check > 10.0:\n            radii_ok = False  # noqa\n\n    # Calculate (cx1, cy1)\n    # ------------------------\n    if large_arc_flag == sweep_flag:\n        sign = -1\n    else:\n        sign = +1\n    sq = (prx * pry - prx * py1 - pry * px1) / (prx * py1 + pry * px1)\n    coef = sign * math.sqrt(max(sq, 0))\n    cx1 = coef * ((rx * y1) / ry)\n    cy1 = coef * -((ry * x1) / rx)\n\n    # Calculate (cx, cy) from (cx1, cy1)\n    # ------------------------\n    sx2 = (x0 + x2) / 2.0\n    sy2 = (y0 + y2) / 2.0\n    cx = sx2 + (cos_a * cx1 - sin_a * cy1)\n    cy = sy2 + (sin_a * cx1 + cos_a * cy1)\n\n    # Calculate the start_angle (angle1) and the sweep_angle (dangle)\n    # ------------------------\n    ux = (x1 - cx1) / rx\n    uy = (y1 - cy1) / ry\n    vx = (-x1 - cx1) / rx\n    vy = (-y1 - cy1) / ry\n\n    # Calculate the angle start\n    # ------------------------\n    n = math.sqrt(ux * ux + uy * uy)\n    p = ux\n    if uy < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    if v < -1.0:\n        v = -1.0\n    if v > 1.0:\n        v = 1.0\n    start_angle = sign * math.acos(v)\n\n    # Calculate the sweep angle\n    # ------------------------\n    n = math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy))\n    p = ux * vx + uy * vy\n    if ux * vy - uy * vx < 0:\n        sign = -1.0\n    else:\n        sign = +1.0\n    v = p / n\n    v = min(max(v, -1.0), +1.0)\n    sweep_angle = sign * math.acos(v)\n    if not sweep_flag and sweep_angle > 0:\n        sweep_angle -= math.pi * 2.0\n    elif sweep_flag and sweep_angle < 0:\n        sweep_angle += math.pi * 2.0\n\n    start_angle = math.fmod(start_angle, 2.0 * math.pi)\n    if sweep_angle >= 2.0 * math.pi:\n        sweep_angle = 2.0 * math.pi\n    if sweep_angle <= -2.0 * math.pi:\n        sweep_angle = -2.0 * math.pi\n\n    V = arc(cx, cy, rx, ry, start_angle, start_angle + sweep_angle, sweep_flag)\n    c = math.cos(angle)\n    s = math.sin(angle)\n    X, Y = V[:, 0] - cx, V[:, 1] - cy\n    V[:, 0] = c * X - s * Y + cx\n    V[:, 1] = s * X + c * Y + cy\n    return V",
  "def _screenshot(viewport=None, alpha=True):\n    \"\"\"Take a screenshot using glReadPixels. Not sure where to put this\n    yet, so a private function for now. Used in make.py.\n\n    Parameters\n    ----------\n    viewport : array-like | None\n        4-element list of x, y, w, h parameters. If None (default),\n        the current GL viewport will be queried and used.\n    alpha : bool\n        If True (default), the returned array has 4 elements (RGBA).\n        Otherwise, it has 3 (RGB)\n\n    Returns\n    -------\n    pixels : array\n        3D array of pixels in np.uint8 format\n    \"\"\"\n    # gl.glReadBuffer(gl.GL_BACK)  Not avaliable in ES 2.0\n    return read_pixels(viewport, alpha)",
  "def check_variable(name):\n    \"\"\"\n    Return None if *name* is expected to be a valid variable name in any GLSL\n    version. Otherwise, return a string describing the problem.\n    \"\"\"\n    # Limit imposed by glGetActive* in pyopengl\n    if len(name) > 31:\n        return (\"Variable names >31 characters may not function on some \"\n                \"systems.\")\n\n    return check_identifier(name)",
  "def check_identifier(name):\n    if '__' in name:\n        return \"Identifiers may not contain double-underscores.\"\n\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return \"Identifiers may not begin with gl_ or GL_.\"\n\n    if name in KEYWORDS:\n        return \"Identifier is a reserved keyword.\"",
  "def check_enum(enum, name=None, valid=None):\n    \"\"\"Get lowercase string representation of enum.\"\"\"\n    name = name or 'enum'\n    # Try to convert\n    res = None\n    if isinstance(enum, int):\n        if hasattr(enum, 'name') and enum.name.startswith('GL_'):\n            res = enum.name[3:].lower()\n    elif isinstance(enum, str):\n        res = enum.lower()\n    # Check\n    if res is None:\n        raise ValueError('Could not determine string representation for'\n                         'enum %r' % enum)\n    elif valid and res not in valid:\n        raise ValueError('Value of %s must be one of %r, not %r' %\n                         (name, valid, enum))\n    return res",
  "def draw_texture(tex):\n    \"\"\"Draw a 2D texture to the current viewport\n\n    Parameters\n    ----------\n    tex : instance of Texture2D\n        The texture to draw.\n    \"\"\"\n    from .program import Program\n    program = Program(vert_draw, frag_draw)\n    program['u_texture'] = tex\n    program['a_position'] = [[-1., -1.], [-1., 1.], [1., -1.], [1., 1.]]\n    program['a_texcoord'] = [[0., 1.], [0., 0.], [1., 1.], [1., 0.]]\n    program.draw('triangle_strip')",
  "def remove_comments(code):\n    \"\"\"Remove C-style comment from GLSL code string.\"\"\"\n    pattern = r\"(\\\".*?\\\"|\\'.*?\\')|(/\\*.*?\\*/|//[^\\r\\n]*\\n)\"\n    # first group captures quoted strings (double or single)\n    # second group captures comments (//single-line or /* multi-line */)\n    regex = re.compile(pattern, re.MULTILINE | re.DOTALL)\n\n    def do_replace(match):\n        # if the 2nd group (capturing comments) is not None,\n        # it means we have captured a non-quoted (real) comment string.\n        if match.group(2) is not None:\n            return \"\"  # so we will return empty to remove the comment\n        else:  # otherwise, we will return the 1st group\n            return match.group(1)  # captured quoted-string\n\n    return regex.sub(do_replace, code)",
  "def merge_includes(code):\n    \"\"\"Merge all includes recursively.\"\"\"\n    pattern = r'\\#\\s*include\\s*\"(?P<filename>[a-zA-Z0-9\\_\\-\\.\\/]+)\"'\n    regex = re.compile(pattern)\n    includes = []\n\n    def replace(match):\n        filename = match.group(\"filename\")\n\n        if filename not in includes:\n            includes.append(filename)\n            path = glsl.find(filename)\n            if not path:\n                logger.critical('\"%s\" not found' % filename)\n                raise RuntimeError(\"File not found\", filename)\n            text = '\\n// --- start of \"%s\" ---\\n' % filename\n            with open(path) as fh:\n                text += fh.read()\n            text += '// --- end of \"%s\" ---\\n' % filename\n            return text\n        return ''\n\n    # Limit recursion to depth 10\n    for i in range(10):\n        if re.search(regex, code):\n            code = re.sub(regex, replace, code)\n        else:\n            break\n\n    return code",
  "def preprocess(code):\n    \"\"\"Preprocess a code by removing comments, version and merging includes.\"\"\"\n    if code:\n        # code = remove_comments(code)\n        code = merge_includes(code)\n    return code",
  "def do_replace(match):\n        # if the 2nd group (capturing comments) is not None,\n        # it means we have captured a non-quoted (real) comment string.\n        if match.group(2) is not None:\n            return \"\"  # so we will return empty to remove the comment\n        else:  # otherwise, we will return the 1st group\n            return match.group(1)",
  "def replace(match):\n        filename = match.group(\"filename\")\n\n        if filename not in includes:\n            includes.append(filename)\n            path = glsl.find(filename)\n            if not path:\n                logger.critical('\"%s\" not found' % filename)\n                raise RuntimeError(\"File not found\", filename)\n            text = '\\n// --- start of \"%s\" ---\\n' % filename\n            with open(path) as fh:\n                text += fh.read()\n            text += '// --- end of \"%s\" ---\\n' % filename\n            return text\n        return ''",
  "def get_default_config():\n    \"\"\"Get the default OpenGL context configuration\n\n    Returns\n    -------\n    config : dict\n        Dictionary of config values.\n    \"\"\"\n    return deepcopy(_default_dict)",
  "def get_current_canvas():\n    \"\"\"Get the currently active canvas\n\n    Returns None if there is no canvas available. A canvas is made\n    active on initialization and before the draw event is emitted.\n\n    When a gloo object is created, it is associated with the currently\n    active Canvas, or with the next Canvas to be created if there is\n    no current Canvas. Use Canvas.set_current() to manually activate a\n    canvas.\n    \"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    if cc:\n        return cc[-1]\n    else:\n        return None",
  "def set_current_canvas(canvas):\n    \"\"\"Make a canvas active. Used primarily by the canvas itself.\"\"\"\n    # Notify glir \n    canvas.context._do_CURRENT_command = True\n    # Try to be quick\n    if canvasses and canvasses[-1]() is canvas:\n        return\n    # Make this the current\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    cc.append(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]",
  "def forget_canvas(canvas):\n    \"\"\"Forget about the given canvas. Used by the canvas when closed.\"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]",
  "class GLContext(BaseGlooFunctions):\n    \"\"\"An object encapsulating data necessary for a OpenGL context\n\n    Parameters\n    ----------\n    config : dict | None\n        The requested configuration.\n    shared : instance of GLContext | None\n        The shared context.\n    \"\"\"\n\n    def __init__(self, config=None, shared=None):\n        self._set_config(config)\n        self._shared = shared if (shared is not None) else GLShared()\n        assert isinstance(self._shared, GLShared)\n        self._glir = GlirQueue()\n        self._do_CURRENT_command = False  # flag that CURRENT cmd must be given\n        self._last_viewport = None\n\n    def __repr__(self):\n        return \"<GLContext at 0x%x>\" % id(self)\n\n    def _set_config(self, config):\n        self._config = deepcopy(_default_dict)\n        self._config.update(config or {})\n        # Check the config dict\n        for key, val in self._config.items():\n            if key not in _default_dict:\n                raise KeyError('Key %r is not a valid GL config key.' % key)\n            if not isinstance(val, type(_default_dict[key])):\n                raise TypeError('Context value of %r has invalid type.' % key)\n\n    def create_shared(self, name, ref):\n        \"\"\"For the app backends to create the GLShared object.\n\n        Parameters\n        ----------\n        name : str\n            The name.\n        ref : object\n            The reference.\n        \"\"\"\n        if self._shared is not None:\n            raise RuntimeError('Can only set_shared once.')\n        self._shared = GLShared(name, ref)\n\n    @property\n    def config(self):\n        \"\"\"A dictionary describing the configuration of this GL context.\"\"\"\n        return self._config\n\n    @property\n    def glir(self):\n        \"\"\"The glir queue for the context. This queue is for objects\n        that can be shared accross canvases (if they share a contex).\n        \"\"\"\n        return self._glir\n\n    @property\n    def shared(self):\n        \"\"\"Get the object that represents the namespace that can\n        potentially be shared between multiple contexts.\n        \"\"\"\n        return self._shared\n\n    @property\n    def capabilities(self):\n        \"\"\"The OpenGL capabilities\"\"\"\n        return deepcopy(self.shared.parser.capabilities)\n\n    def flush_commands(self, event=None):\n        \"\"\"Flush\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._do_CURRENT_command:\n            self._do_CURRENT_command = False\n            canvas = get_current_canvas()\n            if canvas and hasattr(canvas, '_backend'):\n                fbo = canvas._backend._vispy_get_fb_bind_location()\n            else:\n                fbo = 0\n            self.shared.parser.parse([('CURRENT', 0, fbo)])\n        self.glir.flush(self.shared.parser)\n\n    def set_viewport(self, *args):\n        BaseGlooFunctions.set_viewport(self, *args)\n        self._last_viewport = args\n\n    def get_viewport(self):\n        return self._last_viewport",
  "class GLShared(object):\n    \"\"\"Representation of a \"namespace\" that can be shared between\n    different contexts. App backends can associate themselves with this\n    object via add_ref().\n\n    This object can be used to establish whether two contexts/canvases\n    share objects, and can be used as a placeholder to store shared\n    information, such as glyph atlasses.\n    \"\"\"\n\n    # We keep a (weak) ref of each backend that gets associated with\n    # this object. In theory, this means that multiple canvases can\n    # be created and also deleted; as long as there is at least one\n    # left, things should Just Work. \n\n    def __init__(self):\n        glir_file = config['glir_file']\n\n        parser_cls = GlirParser\n        if glir_file:\n            parser_cls = glir_logger(parser_cls, glir_file)\n\n        self._parser = parser_cls()\n        self._name = None\n        self._refs = []\n\n    def __repr__(self):\n        return \"<GLShared of %s backend at 0x%x>\" % (str(self.name), id(self))\n\n    @property\n    def parser(self):\n        \"\"\"The GLIR parser (shared between contexts)\"\"\"\n        return self._parser\n\n    @parser.setter\n    def parser(self, parser):\n        assert isinstance(parser, BaseGlirParser) or parser is None\n        self._parser = parser\n\n    def add_ref(self, name, ref):\n        \"\"\"Add a reference for the backend object that gives access\n        to the low level context. Used in vispy.app.canvas.backends.\n        The given name must match with that of previously added\n        references.\n        \"\"\"\n        if self._name is None:\n            self._name = name\n        elif name != self._name:\n            raise RuntimeError('Contexts can only share between backends of '\n                               'the same type')\n        self._refs.append(weakref.ref(ref))\n\n    @property\n    def name(self):\n        \"\"\"The name of the canvas backend that this shared namespace is\n        associated with. Can be None.\n        \"\"\"\n        return self._name\n\n    @property\n    def ref(self):\n        \"\"\"A reference (stored internally via a weakref) to an object\n        that the backend system can use to obtain the low-level\n        information of the \"reference context\". In Vispy this will\n        typically be the CanvasBackend object.\n        \"\"\"\n        # Clean\n        self._refs = [r for r in self._refs if (r() is not None)]\n        # Get ref\n        ref = self._refs[0]() if self._refs else None\n        if ref is not None:\n            return ref\n        else:\n            raise RuntimeError('No reference for available for GLShared')",
  "class FakeCanvas(object):\n    \"\"\"Fake canvas to allow using gloo without vispy.app\n\n    Instantiate this class to collect GLIR commands from gloo\n    interactions. Call flush() in your draw event handler to execute\n    the commands in the active contect.\n    \"\"\"\n\n    def __init__(self):\n        self.context = GLContext()\n        set_current_canvas(self)\n\n    def flush(self):\n        \"\"\"Flush commands. Call this after setting to context to current.\"\"\"\n        self.context.flush_commands()",
  "def __init__(self, config=None, shared=None):\n        self._set_config(config)\n        self._shared = shared if (shared is not None) else GLShared()\n        assert isinstance(self._shared, GLShared)\n        self._glir = GlirQueue()\n        self._do_CURRENT_command = False  # flag that CURRENT cmd must be given\n        self._last_viewport = None",
  "def __repr__(self):\n        return \"<GLContext at 0x%x>\" % id(self)",
  "def _set_config(self, config):\n        self._config = deepcopy(_default_dict)\n        self._config.update(config or {})\n        # Check the config dict\n        for key, val in self._config.items():\n            if key not in _default_dict:\n                raise KeyError('Key %r is not a valid GL config key.' % key)\n            if not isinstance(val, type(_default_dict[key])):\n                raise TypeError('Context value of %r has invalid type.' % key)",
  "def create_shared(self, name, ref):\n        \"\"\"For the app backends to create the GLShared object.\n\n        Parameters\n        ----------\n        name : str\n            The name.\n        ref : object\n            The reference.\n        \"\"\"\n        if self._shared is not None:\n            raise RuntimeError('Can only set_shared once.')\n        self._shared = GLShared(name, ref)",
  "def config(self):\n        \"\"\"A dictionary describing the configuration of this GL context.\"\"\"\n        return self._config",
  "def glir(self):\n        \"\"\"The glir queue for the context. This queue is for objects\n        that can be shared accross canvases (if they share a contex).\n        \"\"\"\n        return self._glir",
  "def shared(self):\n        \"\"\"Get the object that represents the namespace that can\n        potentially be shared between multiple contexts.\n        \"\"\"\n        return self._shared",
  "def capabilities(self):\n        \"\"\"The OpenGL capabilities\"\"\"\n        return deepcopy(self.shared.parser.capabilities)",
  "def flush_commands(self, event=None):\n        \"\"\"Flush\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._do_CURRENT_command:\n            self._do_CURRENT_command = False\n            canvas = get_current_canvas()\n            if canvas and hasattr(canvas, '_backend'):\n                fbo = canvas._backend._vispy_get_fb_bind_location()\n            else:\n                fbo = 0\n            self.shared.parser.parse([('CURRENT', 0, fbo)])\n        self.glir.flush(self.shared.parser)",
  "def set_viewport(self, *args):\n        BaseGlooFunctions.set_viewport(self, *args)\n        self._last_viewport = args",
  "def get_viewport(self):\n        return self._last_viewport",
  "def __init__(self):\n        glir_file = config['glir_file']\n\n        parser_cls = GlirParser\n        if glir_file:\n            parser_cls = glir_logger(parser_cls, glir_file)\n\n        self._parser = parser_cls()\n        self._name = None\n        self._refs = []",
  "def __repr__(self):\n        return \"<GLShared of %s backend at 0x%x>\" % (str(self.name), id(self))",
  "def parser(self):\n        \"\"\"The GLIR parser (shared between contexts)\"\"\"\n        return self._parser",
  "def parser(self, parser):\n        assert isinstance(parser, BaseGlirParser) or parser is None\n        self._parser = parser",
  "def add_ref(self, name, ref):\n        \"\"\"Add a reference for the backend object that gives access\n        to the low level context. Used in vispy.app.canvas.backends.\n        The given name must match with that of previously added\n        references.\n        \"\"\"\n        if self._name is None:\n            self._name = name\n        elif name != self._name:\n            raise RuntimeError('Contexts can only share between backends of '\n                               'the same type')\n        self._refs.append(weakref.ref(ref))",
  "def name(self):\n        \"\"\"The name of the canvas backend that this shared namespace is\n        associated with. Can be None.\n        \"\"\"\n        return self._name",
  "def ref(self):\n        \"\"\"A reference (stored internally via a weakref) to an object\n        that the backend system can use to obtain the low-level\n        information of the \"reference context\". In Vispy this will\n        typically be the CanvasBackend object.\n        \"\"\"\n        # Clean\n        self._refs = [r for r in self._refs if (r() is not None)]\n        # Get ref\n        ref = self._refs[0]() if self._refs else None\n        if ref is not None:\n            return ref\n        else:\n            raise RuntimeError('No reference for available for GLShared')",
  "def __init__(self):\n        self.context = GLContext()\n        set_current_canvas(self)",
  "def flush(self):\n        \"\"\"Flush commands. Call this after setting to context to current.\"\"\"\n        self.context.flush_commands()",
  "class RenderBuffer(GLObject):\n    \"\"\"Base class for render buffer object\n\n    A render buffer can be in color, depth or stencil format. If this\n    format is not specified, it is set when attached to the FrameBuffer.\n\n    Parameters\n    ----------\n    shape : tuple\n        The shape of the render buffer.\n    format : {None, 'color', 'depth', 'stencil'}\n        The format of the render buffer. See resize.\n    resizeable : bool\n        Indicates whether texture can be resized\n    \"\"\"\n\n    _GLIR_TYPE = 'RenderBuffer'\n\n    def __init__(self, shape=None, format=None, resizeable=True):\n        GLObject.__init__(self)\n        self._format = None\n        self._resizeable = True\n        self.resize(shape, format)\n        self._resizeable = bool(resizeable)\n\n    @property\n    def shape(self):\n        \"\"\"Render Buffer shape\"\"\"\n        return self._shape\n\n    @property\n    def format(self):\n        \"\"\"Render Buffer format\"\"\"\n        return self._format\n\n    def resize(self, shape, format=None):\n        \"\"\"Set the render-buffer size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New shape in yx order. A render buffer is always 2D. For\n            symmetry with the texture class, a 3-element tuple can also\n            be given, in which case the last dimension is ignored.\n        format : {None, 'color', 'depth', 'stencil'}\n            The buffer format. If None, the current format is maintained.\n            If that is also None, the format will be set upon attaching\n            it to a framebuffer. One can also specify the explicit enum:\n            GL_RGB565, GL_RGBA4, GL_RGB5_A1, GL_DEPTH_COMPONENT16, or\n            GL_STENCIL_INDEX8\n        \"\"\"\n        if not self._resizeable:\n            raise RuntimeError(\"RenderBuffer is not resizeable\")\n        # Check shape\n        if not (isinstance(shape, tuple) and len(shape) in (2, 3)):\n            raise ValueError('RenderBuffer shape must be a 2/3 element tuple')\n        # Check format\n        if format is None:\n            format = self._format  # Use current format (may be None)\n        elif isinstance(format, int):\n            pass  # Do not check, maybe user needs desktop GL formats\n        elif isinstance(format, str):\n            if format not in ('color', 'depth', 'stencil'):\n                raise ValueError('RenderBuffer format must be \"color\", \"depth\"'\n                                 ' or \"stencil\", not %r' % format)\n        else:\n            raise ValueError('Invalid RenderBuffer format: %r' % format)\n\n        # Store and send GLIR command\n        self._shape = tuple(shape[:2])\n        self._format = format\n        if self._format is not None:\n            self._glir.command('SIZE', self._id, self._shape, self._format)",
  "class FrameBuffer(GLObject):\n    \"\"\"Frame buffer object\n\n    Parameters\n    ----------\n    color : RenderBuffer (optional)\n        The color buffer to attach to this frame buffer\n    depth : RenderBuffer (optional)\n        The depth buffer to attach to this frame buffer\n    stencil : RenderBuffer (optional)\n        The stencil buffer to attach to this frame buffer\n    \"\"\"\n\n    _GLIR_TYPE = 'FrameBuffer'\n\n    def __init__(self, color=None, depth=None, stencil=None):\n        GLObject.__init__(self)\n        # Init buffers\n        self._color_buffer = None\n        self._depth_buffer = None\n        self._stencil_buffer = None\n        if color is not None:\n            self.color_buffer = color\n        if depth is not None:\n            self.depth_buffer = depth\n        if stencil is not None:\n            self.stencil_buffer = stencil\n\n    def activate(self):\n        \"\"\"Activate/use this frame buffer.\"\"\"\n        # Send command\n        self._glir.command('FRAMEBUFFER', self._id, True)\n        # Associate canvas now\n        canvas = get_current_canvas()\n        if canvas is not None:\n            canvas.context.glir.associate(self.glir)\n\n    def deactivate(self):\n        \"\"\"Stop using this frame buffer, the previous framebuffer will be\n        made active.\n        \"\"\"\n        self._glir.command('FRAMEBUFFER', self._id, False)\n\n    def __enter__(self):\n        self.activate()\n        return self\n\n    def __exit__(self, t, val, trace):\n        self.deactivate()\n\n    def _set_buffer(self, buffer, format):\n        formats = ('color', 'depth', 'stencil')\n        assert format in formats\n        # Auto-format or check render buffer\n        if isinstance(buffer, RenderBuffer):\n            if buffer.format is None:\n                buffer.resize(buffer.shape, format)\n            elif buffer.format in formats and buffer.format != format:\n                raise ValueError('Cannot attach a %s buffer as %s buffer.' %\n                                 (buffer.format, format))\n        # Attach\n        if buffer is None:\n            setattr(self, '_%s_buffer' % format, None)\n            self._glir.command('ATTACH', self._id, format, 0)\n        elif isinstance(buffer, (Texture2D, RenderBuffer)):\n            self.glir.associate(buffer.glir)\n            setattr(self, '_%s_buffer' % format, buffer)\n            self._glir.command('ATTACH', self._id, format, buffer.id)\n        else:\n            raise TypeError(\"Buffer must be a RenderBuffer, Texture2D or None.\"\n                            \" (got %s)\" % type(buffer))\n\n    @property\n    def color_buffer(self):\n        \"\"\"Color buffer attachment\"\"\"\n        return self._color_buffer\n\n    @color_buffer.setter\n    def color_buffer(self, buffer):\n        self._set_buffer(buffer, 'color')\n\n    @property\n    def depth_buffer(self):\n        \"\"\"Depth buffer attachment\"\"\"\n        return self._depth_buffer\n\n    @depth_buffer.setter\n    def depth_buffer(self, buffer):\n        self._set_buffer(buffer, 'depth')\n\n    @property\n    def stencil_buffer(self):\n        \"\"\"Stencil buffer attachment\"\"\"\n        return self._stencil_buffer\n\n    @stencil_buffer.setter\n    def stencil_buffer(self, buffer):\n        self._set_buffer(buffer, 'stencil')\n\n    @property\n    def shape(self):\n        \"\"\"The shape of the Texture/RenderBuffer attached to this FrameBuffer\"\"\"\n        if self.color_buffer is not None:\n            return self.color_buffer.shape[:2]  # in case its a texture\n        if self.depth_buffer is not None:\n            return self.depth_buffer.shape[:2]\n        if self.stencil_buffer is not None:\n            return self.stencil_buffer.shape[:2]\n        raise RuntimeError('FrameBuffer without buffers has undefined shape')\n\n    def resize(self, shape):\n        \"\"\"Resize all attached buffers with the given shape\n\n        Parameters\n        ----------\n        shape : tuple of two integers\n            New buffer shape (h, w), to be applied to all currently\n            attached buffers. For buffers that are a texture, the number\n            of color channels is preserved.\n        \"\"\"\n        # Check\n        if not (isinstance(shape, tuple) and len(shape) == 2):\n            raise ValueError('RenderBuffer shape must be a 2-element tuple')\n        # Resize our buffers\n        for buf in (self.color_buffer, self.depth_buffer, self.stencil_buffer):\n            if buf is None:\n                continue\n            shape_ = shape\n            if isinstance(buf, Texture2D):\n                shape_ = shape + (buf._inv_formats[buf.format], )\n            buf.resize(shape_, buf.format)\n\n    def read(self, mode='color', alpha=True, crop=None):\n        \"\"\"Return array of pixel values in an attached buffer\n\n        Parameters\n        ----------\n        mode : str\n            The buffer type to read. May be 'color', 'depth', or 'stencil'.\n        alpha : bool\n            If True, returns RGBA array. Otherwise, returns RGB.\n        crop : array-like\n            If not None, specifies pixels to read from buffer.\n            Format is (x, y, w, h).\n\n        Returns\n        -------\n        buffer : array\n            3D array of pixels in np.uint8 format.\n            The array shape is (h, w, 3) or (h, w, 4), with the top-left\n            corner of the framebuffer at index [0, 0] in the returned array if\n            crop was not specified. If crop was given, the result will match\n            the offset and dimensions of the crop.\n\n        \"\"\"\n        _check_valid('mode', mode, ['color', 'depth', 'stencil'])\n        buffer = getattr(self, mode + '_buffer')\n        if buffer is None:\n            raise ValueError(\"Can't read pixels for buffer {}, \"\n                             \"buffer does not exist.\".format(mode))\n        if crop is None:\n            h, w = buffer.shape[:2]\n            crop = (0, 0, w, h)\n\n        # todo: this is ostensibly required, but not available in gloo.gl\n        # gl.glReadBuffer(buffer._target)\n        return read_pixels(crop, alpha=alpha, mode=mode)",
  "def __init__(self, shape=None, format=None, resizeable=True):\n        GLObject.__init__(self)\n        self._format = None\n        self._resizeable = True\n        self.resize(shape, format)\n        self._resizeable = bool(resizeable)",
  "def shape(self):\n        \"\"\"Render Buffer shape\"\"\"\n        return self._shape",
  "def format(self):\n        \"\"\"Render Buffer format\"\"\"\n        return self._format",
  "def resize(self, shape, format=None):\n        \"\"\"Set the render-buffer size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New shape in yx order. A render buffer is always 2D. For\n            symmetry with the texture class, a 3-element tuple can also\n            be given, in which case the last dimension is ignored.\n        format : {None, 'color', 'depth', 'stencil'}\n            The buffer format. If None, the current format is maintained.\n            If that is also None, the format will be set upon attaching\n            it to a framebuffer. One can also specify the explicit enum:\n            GL_RGB565, GL_RGBA4, GL_RGB5_A1, GL_DEPTH_COMPONENT16, or\n            GL_STENCIL_INDEX8\n        \"\"\"\n        if not self._resizeable:\n            raise RuntimeError(\"RenderBuffer is not resizeable\")\n        # Check shape\n        if not (isinstance(shape, tuple) and len(shape) in (2, 3)):\n            raise ValueError('RenderBuffer shape must be a 2/3 element tuple')\n        # Check format\n        if format is None:\n            format = self._format  # Use current format (may be None)\n        elif isinstance(format, int):\n            pass  # Do not check, maybe user needs desktop GL formats\n        elif isinstance(format, str):\n            if format not in ('color', 'depth', 'stencil'):\n                raise ValueError('RenderBuffer format must be \"color\", \"depth\"'\n                                 ' or \"stencil\", not %r' % format)\n        else:\n            raise ValueError('Invalid RenderBuffer format: %r' % format)\n\n        # Store and send GLIR command\n        self._shape = tuple(shape[:2])\n        self._format = format\n        if self._format is not None:\n            self._glir.command('SIZE', self._id, self._shape, self._format)",
  "def __init__(self, color=None, depth=None, stencil=None):\n        GLObject.__init__(self)\n        # Init buffers\n        self._color_buffer = None\n        self._depth_buffer = None\n        self._stencil_buffer = None\n        if color is not None:\n            self.color_buffer = color\n        if depth is not None:\n            self.depth_buffer = depth\n        if stencil is not None:\n            self.stencil_buffer = stencil",
  "def activate(self):\n        \"\"\"Activate/use this frame buffer.\"\"\"\n        # Send command\n        self._glir.command('FRAMEBUFFER', self._id, True)\n        # Associate canvas now\n        canvas = get_current_canvas()\n        if canvas is not None:\n            canvas.context.glir.associate(self.glir)",
  "def deactivate(self):\n        \"\"\"Stop using this frame buffer, the previous framebuffer will be\n        made active.\n        \"\"\"\n        self._glir.command('FRAMEBUFFER', self._id, False)",
  "def __enter__(self):\n        self.activate()\n        return self",
  "def __exit__(self, t, val, trace):\n        self.deactivate()",
  "def _set_buffer(self, buffer, format):\n        formats = ('color', 'depth', 'stencil')\n        assert format in formats\n        # Auto-format or check render buffer\n        if isinstance(buffer, RenderBuffer):\n            if buffer.format is None:\n                buffer.resize(buffer.shape, format)\n            elif buffer.format in formats and buffer.format != format:\n                raise ValueError('Cannot attach a %s buffer as %s buffer.' %\n                                 (buffer.format, format))\n        # Attach\n        if buffer is None:\n            setattr(self, '_%s_buffer' % format, None)\n            self._glir.command('ATTACH', self._id, format, 0)\n        elif isinstance(buffer, (Texture2D, RenderBuffer)):\n            self.glir.associate(buffer.glir)\n            setattr(self, '_%s_buffer' % format, buffer)\n            self._glir.command('ATTACH', self._id, format, buffer.id)\n        else:\n            raise TypeError(\"Buffer must be a RenderBuffer, Texture2D or None.\"\n                            \" (got %s)\" % type(buffer))",
  "def color_buffer(self):\n        \"\"\"Color buffer attachment\"\"\"\n        return self._color_buffer",
  "def color_buffer(self, buffer):\n        self._set_buffer(buffer, 'color')",
  "def depth_buffer(self):\n        \"\"\"Depth buffer attachment\"\"\"\n        return self._depth_buffer",
  "def depth_buffer(self, buffer):\n        self._set_buffer(buffer, 'depth')",
  "def stencil_buffer(self):\n        \"\"\"Stencil buffer attachment\"\"\"\n        return self._stencil_buffer",
  "def stencil_buffer(self, buffer):\n        self._set_buffer(buffer, 'stencil')",
  "def shape(self):\n        \"\"\"The shape of the Texture/RenderBuffer attached to this FrameBuffer\"\"\"\n        if self.color_buffer is not None:\n            return self.color_buffer.shape[:2]  # in case its a texture\n        if self.depth_buffer is not None:\n            return self.depth_buffer.shape[:2]\n        if self.stencil_buffer is not None:\n            return self.stencil_buffer.shape[:2]\n        raise RuntimeError('FrameBuffer without buffers has undefined shape')",
  "def resize(self, shape):\n        \"\"\"Resize all attached buffers with the given shape\n\n        Parameters\n        ----------\n        shape : tuple of two integers\n            New buffer shape (h, w), to be applied to all currently\n            attached buffers. For buffers that are a texture, the number\n            of color channels is preserved.\n        \"\"\"\n        # Check\n        if not (isinstance(shape, tuple) and len(shape) == 2):\n            raise ValueError('RenderBuffer shape must be a 2-element tuple')\n        # Resize our buffers\n        for buf in (self.color_buffer, self.depth_buffer, self.stencil_buffer):\n            if buf is None:\n                continue\n            shape_ = shape\n            if isinstance(buf, Texture2D):\n                shape_ = shape + (buf._inv_formats[buf.format], )\n            buf.resize(shape_, buf.format)",
  "def read(self, mode='color', alpha=True, crop=None):\n        \"\"\"Return array of pixel values in an attached buffer\n\n        Parameters\n        ----------\n        mode : str\n            The buffer type to read. May be 'color', 'depth', or 'stencil'.\n        alpha : bool\n            If True, returns RGBA array. Otherwise, returns RGB.\n        crop : array-like\n            If not None, specifies pixels to read from buffer.\n            Format is (x, y, w, h).\n\n        Returns\n        -------\n        buffer : array\n            3D array of pixels in np.uint8 format.\n            The array shape is (h, w, 3) or (h, w, 4), with the top-left\n            corner of the framebuffer at index [0, 0] in the returned array if\n            crop was not specified. If crop was given, the result will match\n            the offset and dimensions of the crop.\n\n        \"\"\"\n        _check_valid('mode', mode, ['color', 'depth', 'stencil'])\n        buffer = getattr(self, mode + '_buffer')\n        if buffer is None:\n            raise ValueError(\"Can't read pixels for buffer {}, \"\n                             \"buffer does not exist.\".format(mode))\n        if crop is None:\n            h, w = buffer.shape[:2]\n            crop = (0, 0, w, h)\n\n        # todo: this is ostensibly required, but not available in gloo.gl\n        # gl.glReadBuffer(buffer._target)\n        return read_pixels(crop, alpha=alpha, mode=mode)",
  "def as_enum(enum):\n    \"\"\"Turn a possibly string enum into an integer enum.\"\"\"\n    if isinstance(enum, str):\n        try:\n            enum = getattr(gl, 'GL_' + enum.upper())\n        except AttributeError:\n            try:\n                enum = _internalformats['GL_' + enum.upper()]\n            except KeyError:\n                raise ValueError('Could not find int value for enum %r' % enum)\n    return enum",
  "class _GlirQueueShare(object):\n    \"\"\"This class contains the actual queues of GLIR commands that are\n    collected until a context becomes available to execute the commands.\n\n    Instances of this class are further wrapped by GlirQueue to allow the\n    underlying queues to be transparently merged when GL objects become\n    associated.\n\n    The motivation for this design is that it allows most glir commands to be\n    added directly to their final queue (the same one used by the context),\n    which reduces the effort required at draw time to determine the complete\n    set of GL commands to be issued.\n\n    At the same time, all GLObjects begin with their own local queue to allow\n    commands to be queued at any time, even if the GLObject has\n    not been associated yet. This works as expected even for complex topologies\n    of GL objects, when some queues may only be joined at the last possible\n    moment.\n    \"\"\"\n\n    def __init__(self, queue):\n        self._commands = []  # local commands\n        self._verbose = False\n        # queues that have been merged with this one\n        self._associations = weakref.WeakKeyDictionary({queue: None})\n\n    def command(self, *args):\n        \"\"\"Send a command. See the command spec at:\n        https://github.com/vispy/vispy/wiki/Spec.-Gloo-IR\n        \"\"\"\n        self._commands.append(args)\n\n    def set_verbose(self, verbose):\n        \"\"\"Set verbose or not. If True, the GLIR commands are printed right before they get parsed.\n        If a string is given, use it as a filter.\n        \"\"\"\n        self._verbose = verbose\n\n    def show(self, filter=None):\n        \"\"\"Print the list of commands currently in the queue. If filter is\n        given, print only commands that match the filter.\n        \"\"\"\n        for command in self._commands:\n            if command[0] is None:  # or command[1] in self._invalid_objects:\n                continue  # Skip nill commands\n            if filter and command[0] != filter:\n                continue\n            t = []\n            for e in command:\n                if isinstance(e, np.ndarray):\n                    t.append('array %s' % str(e.shape))\n                elif isinstance(e, str):\n                    s = e.strip()\n                    if len(s) > 20:\n                        s = s[:18] + '... %i lines' % (e.count('\\n')+1)\n                    t.append(s)\n                else:\n                    t.append(e)\n            print(tuple(t))\n\n    def clear(self):\n        \"\"\"Pop the whole queue (and associated queues) and return a\n        list of commands.\n        \"\"\"\n        commands = self._commands\n        self._commands = []\n        return commands\n\n    def flush(self, parser):\n        \"\"\"Flush all current commands to the GLIR interpreter.\"\"\"\n        if self._verbose:\n            show = self._verbose if isinstance(self._verbose, str) else None\n            self.show(show)\n        parser.parse(self._filter(self.clear(), parser))\n\n    def _filter(self, commands, parser):\n        \"\"\"Filter DATA/SIZE commands that are overridden by a\n        SIZE command.\n        \"\"\"\n        resized = set()\n        commands2 = []\n        for command in reversed(commands):\n            if command[1] in resized:\n                if command[0] in ('SIZE', 'DATA'):\n                    continue  # remove this command\n            elif command[0] == 'SIZE':\n                resized.add(command[1])\n            commands2.append(command)\n        return list(reversed(commands2))",
  "class GlirQueue(object):\n    \"\"\"Representation of a queue of GLIR commands\n\n    One instance of this class is attached to each context object, and\n    to each gloo object. Internally, commands are stored in a shared queue\n    object that may be swapped out and merged with other queues when\n    ``associate()`` is called.\n\n    Upon drawing (i.e. `Program.draw()`) and framebuffer switching, the\n    commands in the queue are pushed to a parser, which is stored at\n    context.shared. The parser can interpret the commands in Python,\n    send them to a browser, etc.\n    \"\"\"\n\n    def __init__(self):\n        # We do not actually queue any commands here, but on a shared queue\n        # object that may be joined with others as queues are associated.\n        self._shared = _GlirQueueShare(self)\n\n    def command(self, *args):\n        \"\"\"Send a command. See the command spec at:\n        https://github.com/vispy/vispy/wiki/Spec.-GLIR\n        \"\"\"\n        self._shared.command(*args)\n\n    def set_verbose(self, verbose):\n        \"\"\"Set verbose or not. If True, the GLIR commands are printed\n        right before they get parsed. If a string is given, use it as\n        a filter.\n        \"\"\"\n        self._shared.set_verbose(verbose)\n\n    def clear(self):\n        \"\"\"Pop the whole queue (and associated queues) and return a\n        list of commands.\n        \"\"\"\n        return self._shared.clear()\n\n    def associate(self, queue):\n        \"\"\"Merge this queue with another.\n\n        Both queues will use a shared command list and either one can be used\n        to fill or flush the shared queue.\n        \"\"\"\n        assert isinstance(queue, GlirQueue)\n        if queue._shared is self._shared:\n            return\n\n        # merge commands\n        self._shared._commands.extend(queue.clear())\n        self._shared._verbose |= queue._shared._verbose\n        self._shared._associations[queue] = None\n        # update queue and all related queues to use the same _shared object\n        for ch in queue._shared._associations:\n            ch._shared = self._shared\n            self._shared._associations[ch] = None\n        queue._shared = self._shared\n\n    def flush(self, parser):\n        \"\"\"Flush all current commands to the GLIR interpreter.\"\"\"\n        self._shared.flush(parser)",
  "def _convert_es2_shader(shader):\n    has_version = False\n    has_prec_float = False\n    has_prec_int = False\n    lines = []\n    extensions = []\n    # Iterate over lines\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        if line_strip.startswith('#version'):\n            # has_version = True\n            continue\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        if line_strip.startswith('precision '):\n            has_prec_float = has_prec_float or 'float' in line\n            has_prec_int = has_prec_int or 'int' in line\n        lines.append(line.rstrip())\n    # Write\n    # BUG: fails on WebGL (Chrome)\n    # if True:\n    #     lines.insert(has_version, '#line 0')\n    if not has_prec_float:\n        lines.insert(has_version, 'precision highp float;')\n    if not has_prec_int:\n        lines.insert(has_version, 'precision highp int;')\n    # Make sure extensions are at the top before precision\n    # but after version\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    # BUG: fails on WebGL (Chrome)\n    # if not has_version:\n    #     lines.insert(has_version, '#version 100')\n    return '\\n'.join(lines)",
  "def _convert_desktop_shader(shader):\n    has_version = False\n    lines = []\n    extensions = []\n    # Iterate over lines\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        has_version = has_version or line.startswith('#version')\n        if line_strip.startswith('precision '):\n            line = ''\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        for prec in (' highp ', ' mediump ', ' lowp '):\n            line = line.replace(prec, ' ')\n        lines.append(line.rstrip())\n    # Write\n    # Make sure extensions are at the top, but after version\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    if not has_version:\n        lines.insert(0, '#version 120\\n')\n    return '\\n'.join(lines)",
  "def convert_shader(backend_type, shader):\n    \"\"\"Modify shader code to be compatible with `backend_type` backend.\"\"\"\n    if backend_type == 'es2':\n        return _convert_es2_shader(shader)\n    elif backend_type == 'desktop':\n        return _convert_desktop_shader(shader)\n    else:\n        raise ValueError('Cannot backend_type shaders to %r.' % backend_type)",
  "def as_es2_command(command):\n    \"\"\"Modify a desktop command so it works on es2.\"\"\"\n    if command[0] == 'FUNC':\n        return (command[0], re.sub(r'^gl([A-Z])',\n                                   lambda m: m.group(1).lower(), command[1])) + command[2:]\n    elif command[0] == 'UNIFORM':\n        return command[:-1] + (command[-1].tolist(),)\n    return command",
  "class BaseGlirParser(object):\n    \"\"\"Base class for GLIR parsers that can be attached to a GLIR queue.\"\"\"\n\n    def __init__(self):\n        self.capabilities = dict(\n            gl_version='Unknown',\n            max_texture_size=None,\n        )\n\n    def is_remote(self):\n        \"\"\"Whether the code is executed remotely. i.e. gloo.gl cannot\n        be used.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def shader_compatibility(self):\n        \"\"\"Whether to convert shading code. Valid values are 'es2' and\n        'desktop'. If None, the shaders are not modified.\n        \"\"\"\n        raise NotImplementedError()\n\n    def parse(self, commands):\n        \"\"\"Parse the GLIR commands. Or sent them away.\"\"\"\n        raise NotImplementedError()",
  "class GlirParser(BaseGlirParser):\n    \"\"\"A class for interpreting GLIR commands using gloo.gl\n\n    We make use of relatively light GLIR objects that are instantiated\n    on CREATE commands. These objects are stored by their id in a\n    dictionary so that commands like ACTIVATE and DATA can easily\n    be executed on the corresponding objects.\n    \"\"\"\n\n    def __init__(self):\n        super(GlirParser, self).__init__()\n        self._objects = {}\n        self._invalid_objects = set()\n\n        self._classmap = {'VertexShader': GlirVertexShader,\n                          'FragmentShader': GlirFragmentShader,\n                          'GeometryShader': GlirGeometryShader,\n                          'Program': GlirProgram,\n                          'VertexBuffer': GlirVertexBuffer,\n                          'IndexBuffer': GlirIndexBuffer,\n                          'Texture1D': GlirTexture1D,\n                          'Texture2D': GlirTexture2D,\n                          'Texture3D': GlirTexture3D,\n                          'TextureCube': GlirTextureCube,\n                          'RenderBuffer': GlirRenderBuffer,\n                          'FrameBuffer': GlirFrameBuffer,\n                          }\n\n        # We keep a dict that the GLIR objects use for storing\n        # per-context information. This dict is cleared each time\n        # that the context is made current. This seems necessary for\n        # when two Canvases share a context.\n        self.env = {}\n\n    @property\n    def shader_compatibility(self):\n        \"\"\"Type of shader compatibility\"\"\"\n        if '.es' in gl.current_backend.__name__:\n            return 'es2'\n        else:\n            return 'desktop'\n\n    def is_remote(self):\n        return False\n\n    def _parse(self, command):\n        \"\"\"Parse a single command.\"\"\"\n        cmd, id_, args = command[0], command[1], command[2:]\n\n        if cmd == 'CURRENT':\n            # This context is made current\n            self.env.clear()\n            self._gl_initialize()\n            self.env['fbo'] = args[0]\n            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, args[0])\n        elif cmd == 'FUNC':\n            # GL function call\n            args = [as_enum(a) for a in args]\n            try:\n                getattr(gl, id_)(*args)\n            except AttributeError:\n                logger.warning('Invalid gl command: %r' % id_)\n        elif cmd == 'CREATE':\n            # Creating an object\n            if args[0] is not None:\n                klass = self._classmap[args[0]]\n                self._objects[id_] = klass(self, id_)\n            else:\n                self._invalid_objects.add(id_)\n        elif cmd == 'DELETE':\n            # Deleting an object\n            ob = self._objects.get(id_, None)\n            if ob is not None:\n                self._objects[id_] = JUST_DELETED\n                ob.delete()\n        else:\n            # Doing somthing to an object\n            ob = self._objects.get(id_, None)\n            if ob == JUST_DELETED:\n                return\n            if ob is None:\n                if id_ not in self._invalid_objects:\n                    raise RuntimeError('Cannot %s object %i because it '\n                                       'does not exist' % (cmd, id_))\n                return\n            # Triage over command. Order of commands is set so most\n            # common ones occur first.\n            if cmd == 'DRAW':  # Program\n                ob.draw(*args)\n            elif cmd == 'TEXTURE':  # Program\n                ob.set_texture(*args)\n            elif cmd == 'UNIFORM':  # Program\n                ob.set_uniform(*args)\n            elif cmd == 'ATTRIBUTE':  # Program\n                ob.set_attribute(*args)\n            elif cmd == 'DATA':  # VertexBuffer, IndexBuffer, Texture, Shader\n                ob.set_data(*args)\n            elif cmd == 'SIZE':  # VertexBuffer, IndexBuffer,\n                ob.set_size(*args)  # Texture[1D, 2D, 3D], RenderBuffer\n            elif cmd == 'ATTACH':  # FrameBuffer, Program\n                ob.attach(*args)\n            elif cmd == 'FRAMEBUFFER':  # FrameBuffer\n                ob.set_framebuffer(*args)\n            # elif cmd == 'SHADERS':  # Program\n            #     ob.set_shaders(*args)\n            elif cmd == 'LINK':  # Program\n                ob.link_program(*args)\n            elif cmd == 'WRAPPING':  # Texture1D, Texture2D, Texture3D\n                ob.set_wrapping(*args)\n            elif cmd == 'INTERPOLATION':  # Texture1D, Texture2D, Texture3D\n                ob.set_interpolation(*args)\n            else:\n                logger.warning('Invalid GLIR command %r' % cmd)\n\n    def parse(self, commands):\n        \"\"\"Parse a list of commands.\"\"\"\n        # Get rid of dummy objects that represented deleted objects in\n        # the last parsing round.\n        to_delete = []\n        for id_, val in self._objects.items():\n            if val == JUST_DELETED:\n                to_delete.append(id_)\n        for id_ in to_delete:\n            self._objects.pop(id_)\n\n        for command in commands:\n            self._parse(command)\n\n    def get_object(self, id_):\n        \"\"\"Get the object with the given id or None if it does not exist.\"\"\"\n        return self._objects.get(id_, None)\n\n    def _gl_initialize(self):\n        \"\"\"Deal with compatibility; desktop does not have sprites enabled by default. ES has.\"\"\"\n        if '.es' in gl.current_backend.__name__:\n            pass  # ES2: no action required\n        else:\n            # Desktop, enable sprites\n            GL_VERTEX_PROGRAM_POINT_SIZE = 34370\n            GL_POINT_SPRITE = 34913\n            gl.glEnable(GL_VERTEX_PROGRAM_POINT_SIZE)\n            gl.glEnable(GL_POINT_SPRITE)\n        if self.capabilities['max_texture_size'] is None:  # only do once\n            self.capabilities['gl_version'] = gl.glGetParameter(gl.GL_VERSION)\n            self.capabilities['max_texture_size'] = \\\n                gl.glGetParameter(gl.GL_MAX_TEXTURE_SIZE)\n            this_version = self.capabilities['gl_version'].split(' ')\n            if this_version[0] == \"OpenGL\":\n                # For OpenGL ES, the version string has the format:\n                # \"OpenGL ES <version number> <vendor-specific information>\"\n                this_version = this_version[2]\n            else:\n                this_version = this_version[0]\n\n            if not this_version:\n                logger.warning(\"OpenGL version could not be determined, which \"\n                               \"might be a sign that OpenGL is not loaded correctly.\")\n            elif LooseVersion(this_version) < '2.1':\n                if os.getenv('VISPY_IGNORE_OLD_VERSION', '').lower() != 'true':\n                    logger.warning('OpenGL version 2.1 or higher recommended, '\n                                   'got %s. Some functionality may fail.'\n                                   % self.capabilities['gl_version'])",
  "def glir_logger(parser_cls, file_or_filename):\n    from ..util.logs import NumPyJSONEncoder\n\n    class cls(parser_cls):\n        def __init__(self, *args, **kwargs):\n            parser_cls.__init__(self, *args, **kwargs)\n\n            if isinstance(file_or_filename, str):\n                self._file = open(file_or_filename, 'w')\n            else:\n                self._file = file_or_filename\n\n            self._file.write('[]')\n            self._empty = True\n\n        def _parse(self, command):\n            parser_cls._parse(self, command)\n\n            self._file.seek(self._file.tell() - 1)\n            if self._empty:\n                self._empty = False\n            else:\n                self._file.write(',\\n')\n            json.dump(as_es2_command(command),\n                      self._file, cls=NumPyJSONEncoder)\n            self._file.write(']')\n\n    return cls",
  "class GlirObject(object):\n    def __init__(self, parser, id_):\n        self._parser = parser\n        self._id = id_\n        self._handle = -1  # Must be set by subclass in create()\n        self.create()\n\n    @property\n    def handle(self):\n        return self._handle\n\n    @property\n    def id(self):\n        return self._id\n\n    def __repr__(self):\n        return '<%s %i at 0x%x>' % (self.__class__.__name__, self.id, id(self))",
  "class GlirShader(GlirObject):\n    _target = None\n\n    def create(self):\n        self._handle = gl.glCreateShader(self._target)\n\n    def set_data(self, offset, code):\n        # NOTE: offset will always be 0 to match other DATA commands\n\n        # convert shader to be compatible with backend\n        convert = self._parser.shader_compatibility\n        if convert:\n            code = convert_shader(convert, code)\n\n        gl.glShaderSource(self._handle, code)\n        gl.glCompileShader(self._handle)\n        status = gl.glGetShaderParameter(self._handle, gl.GL_COMPILE_STATUS)\n        if not status:\n            errors = gl.glGetShaderInfoLog(self._handle)\n            errormsg = self._get_error(code, errors, 4)\n            raise RuntimeError(\"Shader compilation error in %s:\\n%s\" %\n                               (self._target, errormsg))\n\n    def delete(self):\n        gl.glDeleteShader(self._handle)\n\n    def _get_error(self, code, errors, indentation=0):\n        \"\"\"Get error and show the faulty line + some context\n        Other GLIR implementations may omit this.\n        \"\"\"\n        # Init\n        results = []\n        lines = None\n        if code is not None:\n            lines = [line.strip() for line in code.split('\\n')]\n\n        for error in errors.split('\\n'):\n            # Strip; skip empy lines\n            error = error.strip()\n            if not error:\n                continue\n            # Separate line number from description (if we can)\n            linenr, error = self._parse_error(error)\n            if None in (linenr, lines):\n                results.append('%s' % error)\n            else:\n                results.append('on line %i: %s' % (linenr, error))\n                if linenr > 0 and linenr < len(lines):\n                    results.append('  %s' % lines[linenr - 1])\n\n        # Add indentation and return\n        results = [' ' * indentation + r for r in results]\n        return '\\n'.join(results)\n\n    def _parse_error(self, error):\n        \"\"\"Parses a single GLSL error and extracts the linenr and description\n        Other GLIR implementations may omit this.\n        \"\"\"\n        error = str(error)\n        # Nvidia\n        # 0(7): error C1008: undefined variable \"MV\"\n        m = re.match(r'(\\d+)\\((\\d+)\\)\\s*:\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # ATI / Intel\n        # ERROR: 0:131: '{' : syntax error parse error\n        m = re.match(r'ERROR:\\s(\\d+):(\\d+):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # Nouveau\n        # 0:28(16): error: syntax error, unexpected ')', expecting '('\n        m = re.match(r'(\\d+):(\\d+)\\((\\d+)\\):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(4)\n        # Other ...\n        return None, error",
  "class GlirVertexShader(GlirShader):\n    _target = gl.GL_VERTEX_SHADER",
  "class GlirFragmentShader(GlirShader):\n    _target = gl.GL_FRAGMENT_SHADER",
  "class GlirGeometryShader(GlirShader):\n    # _target assignment must be delayed because GL_GEOMETRY_SHADER does not\n    # exist until the user calls use_gl('gl+')\n    _target = None\n\n    def __init__(self, *args, **kwargs):\n        if not hasattr(gl, 'GL_GEOMETRY_SHADER'):\n            raise RuntimeError(gl.current_backend.__name__ +\n                               \" backend does not support geometry shaders.\"\n                               \" Try gloo.gl.use_gl('gl+').\")\n        GlirGeometryShader._target = gl.GL_GEOMETRY_SHADER\n        GlirShader.__init__(self, *args, **kwargs)",
  "class GlirProgram(GlirObject):\n\n    UTYPEMAP = {\n        'float': 'glUniform1fv',\n        'vec2': 'glUniform2fv',\n        'vec3': 'glUniform3fv',\n        'vec4': 'glUniform4fv',\n        'int': 'glUniform1iv',\n        'ivec2': 'glUniform2iv',\n        'ivec3': 'glUniform3iv',\n        'ivec4': 'glUniform4iv',\n        'bool': 'glUniform1iv',\n        'bvec2': 'glUniform2iv',\n        'bvec3': 'glUniform3iv',\n        'bvec4': 'glUniform4iv',\n        'mat2': 'glUniformMatrix2fv',\n        'mat3': 'glUniformMatrix3fv',\n        'mat4': 'glUniformMatrix4fv',\n        'sampler1D': 'glUniform1i',\n        'sampler2D': 'glUniform1i',\n        'sampler3D': 'glUniform1i',\n    }\n\n    ATYPEMAP = {\n        'float': 'glVertexAttrib1f',\n        'vec2': 'glVertexAttrib2f',\n        'vec3': 'glVertexAttrib3f',\n        'vec4': 'glVertexAttrib4f',\n    }\n\n    ATYPEINFO = {\n        'float': (1, gl.GL_FLOAT, np.float32),\n        'vec2': (2, gl.GL_FLOAT, np.float32),\n        'vec3': (3, gl.GL_FLOAT, np.float32),\n        'vec4': (4, gl.GL_FLOAT, np.float32),\n        'int': (1, gl.GL_INT, np.int32),\n        'bool': (1, gl.GL_BOOL, np.int32)\n    }\n\n    def create(self):\n        self._handle = gl.glCreateProgram()\n        self._attached_shaders = []\n        self._validated = False\n        self._linked = False\n        # Keeping track of uniforms/attributes\n        self._handles = {}  # cache with handles to attributes/uniforms\n        self._unset_variables = set()\n        # Store samplers in buffers that are bount to uniforms/attributes\n        self._samplers = {}  # name -> (tex-target, tex-handle, unit)\n        self._attributes = {}  # name -> (vbo-handle, attr-handle, func, args)\n        self._known_invalid = set()  # variables that we know are invalid\n\n    def delete(self):\n        gl.glDeleteProgram(self._handle)\n\n    def activate(self):\n        \"\"\"Avoid overhead in calling glUseProgram with same arg.\n        Warning: this will break if glUseProgram is used somewhere else.\n        Per context we keep track of one current program.\n        \"\"\"\n        if self._handle != self._parser.env.get('current_program', False):\n            self._parser.env['current_program'] = self._handle\n            gl.glUseProgram(self._handle)\n\n    def deactivate(self):\n        \"\"\"Avoid overhead in calling glUseProgram with same arg.\n        Warning: this will break if glUseProgram is used somewhere else.\n        Per context we keep track of one current program.\n        \"\"\"\n        if self._parser.env.get('current_program', 0) != 0:\n            self._parser.env['current_program'] = 0\n            gl.glUseProgram(0)\n\n    def set_shaders(self, vert, frag):\n        \"\"\"This function takes care of setting the shading code and\n        compiling+linking it into a working program object that is ready\n        to use.\n        \"\"\"\n        self._linked = False\n\n        # For both vertex and fragment shader: set source, compile, check\n        for code, type_ in [(vert, 'vertex'),\n                            (frag, 'fragment')]:\n            self.attach_shader(code, type_)\n\n        self.link_program()\n\n    def attach(self, id_):\n        \"\"\"Attach a shader to this program.\"\"\"\n        shader = self._parser.get_object(id_)\n        gl.glAttachShader(self._handle, shader.handle)\n        self._attached_shaders.append(shader)\n\n    def link_program(self):\n        \"\"\"Link the complete program and check.\n\n        All shaders are detached and deleted if the program was successfully\n        linked.\n        \"\"\"\n        gl.glLinkProgram(self._handle)\n        if not gl.glGetProgramParameter(self._handle, gl.GL_LINK_STATUS):\n            raise RuntimeError('Program linking error:\\n%s'\n                               % gl.glGetProgramInfoLog(self._handle))\n\n        # Detach all shaders to prepare them for deletion (they are no longer\n        # needed after linking is complete)\n        for shader in self._attached_shaders:\n            gl.glDetachShader(self._handle, shader.handle)\n        self._attached_shaders = []\n\n        # Now we know what variables will be used by the program\n        self._unset_variables = self._get_active_attributes_and_uniforms()\n        self._handles = {}\n        self._known_invalid = set()\n        self._linked = True\n\n    def _get_active_attributes_and_uniforms(self):\n        \"\"\"Retrieve active attributes and uniforms to be able to check that\n        all uniforms/attributes are set by the user.\n        Other GLIR implementations may omit this.\n        \"\"\"\n        # This match a name of the form \"name[size]\" (= array)\n        regex = re.compile(r\"\"\"(?P<name>\\w+)\\s*(\\[(?P<size>\\d+)\\])\\s*\"\"\")\n        # Get how many active attributes and uniforms there are\n        cu = gl.glGetProgramParameter(self._handle, gl.GL_ACTIVE_UNIFORMS)\n        ca = gl.glGetProgramParameter(self.handle, gl.GL_ACTIVE_ATTRIBUTES)\n        # Get info on each one\n        attributes = []\n        uniforms = []\n        for container, count, func in [(attributes, ca, gl.glGetActiveAttrib),\n                                       (uniforms, cu, gl.glGetActiveUniform)]:\n            for i in range(count):\n                name, size, gtype = func(self._handle, i)\n                m = regex.match(name)  # Check if xxx[0] instead of xx\n                if m:\n                    name = m.group('name')\n                    for i in range(size):\n                        container.append(('%s[%d]' % (name, i), gtype))\n                else:\n                    container.append((name, gtype))\n        # return attributes, uniforms\n        return set([v[0] for v in attributes] + [v[0] for v in uniforms])\n\n    def set_texture(self, name, value):\n        \"\"\"Set a texture sampler. Value is the id of the texture to link.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Not setting texture data for variable %s; '\n                            'uniform is not active.' % name)\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        if True:\n            # Sampler: the value is the id of the texture\n            tex = self._parser.get_object(value)\n            if tex == JUST_DELETED:\n                return\n            if tex is None:\n                raise RuntimeError('Could not find texture with id %i' % value)\n            unit = len(self._samplers)\n            if name in self._samplers:\n                unit = self._samplers[name][-1]  # Use existing unit\n            self._samplers[name] = tex._target, tex.handle, unit\n            gl.glUniform1i(handle, unit)\n\n    def set_uniform(self, name, type_, value):\n        \"\"\"Set a uniform value. Value is assumed to have been checked.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        count = 1\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            # if we set a uniform_array, mark all as set\n            if not type_.startswith('mat'):\n                count = value.nbytes // (4 * self.ATYPEINFO[type_][0])\n            if count > 1:\n                for ii in range(count):\n                    if '%s[%s]' % (name, ii) in self._unset_variables:\n                        self._unset_variables.discard('%s[%s]' % (name, ii))\n\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Not setting value for variable %s %s; '\n                            'uniform is not active.' % (type_, name))\n                return\n        # Look up function to call\n        funcname = self.UTYPEMAP[type_]\n        func = getattr(gl, funcname)\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on type\n        if type_.startswith('mat'):\n            # Value is matrix, these gl funcs have alternative signature\n            transpose = False  # OpenGL ES 2.0 does not support transpose\n            func(handle, 1, transpose, value)\n        else:\n            # Regular uniform\n            func(handle, count, value)\n\n    def set_attribute(self, name, type_, value):\n        \"\"\"Set an attribute value. Value is assumed to have been checked.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set attribute when program has no code')\n        # Get handle for the attribute, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetAttribLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                if value[0] != 0 and value[2] > 0:  # VBO with offset\n                    return  # Probably an unused element in a structured VBO\n                logger.info('Not setting data for variable %s %s; '\n                            'attribute is not active.' % (type_, name))\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on VBO or tuple data\n        if value[0] == 0:\n            # Look up function call\n            funcname = self.ATYPEMAP[type_]\n            func = getattr(gl, funcname)\n            # Set data\n            self._attributes[name] = 0, handle, func, value[1:]\n        else:\n            # Get meta data\n            vbo_id, stride, offset = value\n            size, gtype, dtype = self.ATYPEINFO[type_]\n            # Get associated VBO\n            vbo = self._parser.get_object(vbo_id)\n            if vbo == JUST_DELETED:\n                return\n            if vbo is None:\n                raise RuntimeError('Could not find VBO with id %i' % vbo_id)\n            # Set data\n            func = gl.glVertexAttribPointer\n            args = size, gtype, gl.GL_FALSE, stride, offset\n            self._attributes[name] = vbo.handle, handle, func, args\n\n    def _pre_draw(self):\n        self.activate()\n        # Activate textures\n        for tex_target, tex_handle, unit in self._samplers.values():\n            gl.glActiveTexture(gl.GL_TEXTURE0 + unit)\n            gl.glBindTexture(tex_target, tex_handle)\n        # Activate attributes\n        for vbo_handle, attr_handle, func, args in self._attributes.values():\n            if vbo_handle:\n                gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo_handle)\n                gl.glEnableVertexAttribArray(attr_handle)\n                func(attr_handle, *args)\n            else:\n                gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)\n                gl.glDisableVertexAttribArray(attr_handle)\n                func(attr_handle, *args)\n        # Validate. We need to validate after textures units get assigned\n        if not self._validated:\n            self._validated = True\n            self._validate()\n\n    def _validate(self):\n        # Validate ourselves\n        if self._unset_variables:\n            logger.warning('Program has unset variables: %r' %\n                           self._unset_variables)\n        # Validate via OpenGL\n        gl.glValidateProgram(self._handle)\n        if not gl.glGetProgramParameter(self._handle,\n                                        gl.GL_VALIDATE_STATUS):\n            raise RuntimeError('Program validation error:\\n%s'\n                               % gl.glGetProgramInfoLog(self._handle))\n\n    def _post_draw(self):\n        # No need to deactivate each texture/buffer, just set to 0\n        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)\n        gl.glBindTexture(gl.GL_TEXTURE_2D, 0)\n        if USE_TEX_3D:\n            gl.glBindTexture(GL_TEXTURE_3D, 0)\n            gl.glBindTexture(GL_TEXTURE_1D, 0)\n\n        # Deactivate program - should not be necessary. In single-program\n        # apps it would not even make sense.\n        # self.deactivate()\n\n    def draw(self, mode, selection):\n        \"\"\"Draw program in given mode, with given selection (IndexBuffer or\n        first, count).\n        \"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot draw program if code has not been set')\n        # Init\n        gl.check_error('Check before draw')\n        try:\n            mode = as_enum(mode)\n        except ValueError:\n            if mode == 'lines_adjacency' or mode == 'line_strip_adjacency':\n                raise RuntimeError(gl.current_backend.__name__ +\n                                   \" backend does not support lines_adjacency\"\n                                   \" and line_strip_adjacency primitives.\"\n                                   \" Try gloo.gl.use_gl('gl+').\")\n            raise\n\n        # Draw\n        if len(selection) == 3:\n            # Selection based on indices\n            id_, gtype, count = selection\n            if count:\n                self._pre_draw()\n                ibuf = self._parser.get_object(id_)\n                ibuf.activate()\n                gl.glDrawElements(mode, count, as_enum(gtype), None)\n                ibuf.deactivate()\n        else:\n            # Selection based on start and count\n            first, count = selection\n            if count:\n                self._pre_draw()\n                gl.glDrawArrays(mode, first, count)\n        # Wrap up\n        gl.check_error('Check after draw')\n        self._post_draw()",
  "class GlirBuffer(GlirObject):\n    _target = None\n    _usage = gl.GL_DYNAMIC_DRAW  # STATIC_DRAW, STREAM_DRAW or DYNAMIC_DRAW\n\n    def create(self):\n        self._handle = gl.glCreateBuffer()\n        self._buffer_size = 0\n        self._bufferSubDataOk = False\n\n    def delete(self):\n        gl.glDeleteBuffer(self._handle)\n\n    def activate(self):\n        gl.glBindBuffer(self._target, self._handle)\n\n    def deactivate(self):\n        gl.glBindBuffer(self._target, 0)\n\n    def set_size(self, nbytes):  # in bytes\n        if nbytes != self._buffer_size:\n            self.activate()\n            gl.glBufferData(self._target, nbytes, self._usage)\n            self._buffer_size = nbytes\n\n    def set_data(self, offset, data):\n        self.activate()\n        nbytes = data.nbytes\n\n        # Determine whether to check errors to try handling the ATI bug\n        check_ati_bug = ((not self._bufferSubDataOk) and\n                         (gl.current_backend.__name__.split(\".\")[-1] == \"gl2\") and\n                         sys.platform.startswith('win'))\n\n        # flush any pending errors\n        if check_ati_bug:\n            gl.check_error('periodic check')\n\n        try:\n            gl.glBufferSubData(self._target, offset, data)\n            if check_ati_bug:\n                gl.check_error('glBufferSubData')\n            self._bufferSubDataOk = True  # glBufferSubData seems to work\n        except Exception:\n            # This might be due to a driver error (seen on ATI), issue #64.\n            # We try to detect this, and if we can use glBufferData instead\n            if offset == 0 and nbytes == self._buffer_size:\n                gl.glBufferData(self._target, data, self._usage)\n                logger.debug(\"Using glBufferData instead of \" +\n                             \"glBufferSubData (known ATI bug).\")\n            else:\n                raise",
  "class GlirVertexBuffer(GlirBuffer):\n    _target = gl.GL_ARRAY_BUFFER",
  "class GlirIndexBuffer(GlirBuffer):\n    _target = gl.GL_ELEMENT_ARRAY_BUFFER",
  "class GlirTexture(GlirObject):\n    _target = None\n\n    _types = {\n        np.dtype(np.int8): gl.GL_BYTE,\n        np.dtype(np.uint8): gl.GL_UNSIGNED_BYTE,\n        np.dtype(np.int16): gl.GL_SHORT,\n        np.dtype(np.uint16): gl.GL_UNSIGNED_SHORT,\n        np.dtype(np.int32): gl.GL_INT,\n        np.dtype(np.uint32): gl.GL_UNSIGNED_INT,\n        # np.dtype(np.float16) : gl.GL_HALF_FLOAT,\n        np.dtype(np.float32): gl.GL_FLOAT,\n        # np.dtype(np.float64) : gl.GL_DOUBLE\n    }\n\n    def create(self):\n        self._handle = gl.glCreateTexture()\n        self._shape_formats = 0  # To make setting size cheap\n\n    def delete(self):\n        gl.glDeleteTexture(self._handle)\n\n    def activate(self):\n        gl.glBindTexture(self._target, self._handle)\n\n    def deactivate(self):\n        gl.glBindTexture(self._target, 0)\n\n    # Taken from pygly\n    def _get_alignment(self, width):\n        \"\"\"Determines a textures byte alignment.\n\n        If the width isn't a power of 2\n        we need to adjust the byte alignment of the image.\n        The image height is unimportant\n\n        www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n        \"\"\"\n        # we know the alignment is appropriate\n        # if we can divide the width by the\n        # alignment cleanly\n        # valid alignments are 1,2,4 and 8\n        # 4 is the default\n        alignments = [8, 4, 2, 1]\n        for alignment in alignments:\n            if width % alignment == 0:\n                return alignment\n\n    def set_wrapping(self, wrapping):\n        self.activate()\n        wrapping = [as_enum(w) for w in wrapping]\n        if len(wrapping) == 3:\n            GL_TEXTURE_WRAP_R = 32882\n            gl.glTexParameterf(self._target, GL_TEXTURE_WRAP_R, wrapping[0])\n        if len(wrapping) >= 2:\n            gl.glTexParameterf(self._target,\n                               gl.GL_TEXTURE_WRAP_S, wrapping[-2])\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_WRAP_T, wrapping[-1])\n\n    def set_interpolation(self, min, mag):\n        self.activate()\n        min, mag = as_enum(min), as_enum(mag)\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_MIN_FILTER, min)\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_MAG_FILTER, mag)",
  "class GlirTexture1D(GlirTexture):\n    _target = GL_TEXTURE_1D\n\n    def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        if internalformat is not None:\n            internalformat = as_enum(internalformat)\n        else:\n            internalformat = format\n        # Shape is width\n        if (shape, format, internalformat) != self._shape_formats:\n            self.activate()\n            self._shape_formats = shape, format, internalformat\n            glTexImage1D(self._target, 0, internalformat, format,\n                         gl.GL_BYTE, shape[:1])\n\n    def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        x = offset[0]\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        glTexSubImage1D(self._target, 0, x, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "class GlirTexture2D(GlirTexture):\n    _target = gl.GL_TEXTURE_2D\n\n    def set_size(self, shape, format, internalformat):\n        # Shape is height, width\n        format = as_enum(format)\n        internalformat = format if internalformat is None \\\n            else as_enum(internalformat)\n        if (shape, format, internalformat) != self._shape_formats:\n            self._shape_formats = shape, format, internalformat\n            self.activate()\n            gl.glTexImage2D(self._target, 0, internalformat, format,\n                            gl.GL_UNSIGNED_BYTE, shape[:2])\n\n    def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        y, x = offset\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        gl.glTexSubImage2D(self._target, 0, x, y, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "def _check_pyopengl_3D():\n    \"\"\"Helper to ensure users have OpenGL for 3D texture support (for now)\"\"\"\n    global USE_TEX_3D\n    USE_TEX_3D = True\n    try:\n        import OpenGL.GL as _gl\n    except ImportError:\n        raise ImportError('PyOpenGL is required for 3D texture support')\n    return _gl",
  "def glTexImage3D(target, level, internalformat, format, type, pixels):\n    # Import from PyOpenGL\n    _gl = _check_pyopengl_3D()\n    border = 0\n    assert isinstance(pixels, (tuple, list))  # the only way we use this now\n    depth, height, width = pixels\n    _gl.glTexImage3D(target, level, internalformat,\n                     width, height, depth, border, format, type, None)",
  "def glTexImage1D(target, level, internalformat, format, type, pixels):\n    # Import from PyOpenGL\n    _gl = _check_pyopengl_3D()\n    border = 0\n    assert isinstance(pixels, (tuple, list))  # the only way we use this now\n    # pixels will be a tuple of the form (width, )\n    # we only need the first argument\n    width = pixels[0]\n\n    _gl.glTexImage1D(target, level, internalformat,\n                     width, border, format, type, None)",
  "def glTexSubImage1D(target, level, xoffset,\n                    format, type, pixels):\n    # Import from PyOpenGL\n    _gl = _check_pyopengl_3D()\n    width = pixels.shape[:1]\n\n    # width will be a tuple of the form (w, )\n    # we need to take the first element (integer)\n    _gl.glTexSubImage1D(target, level, xoffset,\n                        width[0], format, type, pixels)",
  "def glTexSubImage3D(target, level, xoffset, yoffset, zoffset,\n                    format, type, pixels):\n    # Import from PyOpenGL\n    _gl = _check_pyopengl_3D()\n    depth, height, width = pixels.shape[:3]\n    _gl.glTexSubImage3D(target, level, xoffset, yoffset, zoffset,\n                        width, height, depth, format, type, pixels)",
  "class GlirTexture3D(GlirTexture):\n    _target = GL_TEXTURE_3D\n\n    def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        if internalformat is not None:\n            internalformat = as_enum(internalformat)\n        else:\n            internalformat = format\n        # Shape is depth, height, width\n        if (shape, format, internalformat) != self._shape_formats:\n            self.activate()\n            self._shape_formats = shape, format, internalformat\n            glTexImage3D(self._target, 0, internalformat, format,\n                         gl.GL_BYTE, shape[:3])\n\n    def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        z, y, x = offset\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type not allowed for texture\")\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        glTexSubImage3D(self._target, 0, x, y, z, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "class GlirTextureCube(GlirTexture):\n    _target = gl.GL_TEXTURE_CUBE_MAP\n    _cube_targets = [\n        gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n        gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n        gl.GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n        gl.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,\n    ]\n\n    def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        internalformat = format if internalformat is None \\\n            else as_enum(internalformat)\n        if (shape, format, internalformat) != self._shape_formats:\n            self._shape_formats = shape, format, internalformat\n            self.activate()\n            for target in self._cube_targets:\n                gl.glTexImage2D(target, 0, internalformat, format,\n                                gl.GL_UNSIGNED_BYTE, shape[1:3])\n\n    def set_data(self, offset, data):\n        shape, format, internalformat = self._shape_formats\n        y, x = offset[:2]\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        self.activate()\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        for i, target in enumerate(self._cube_targets):\n            gl.glTexSubImage2D(target, 0, x, y, format, gtype, data[i])\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "class GlirRenderBuffer(GlirObject):\n\n    def create(self):\n        self._handle = gl.glCreateRenderbuffer()\n        self._shape_format = 0  # To make setting size cheap\n\n    def delete(self):\n        gl.glDeleteRenderbuffer(self._handle)\n\n    def activate(self):\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, self._handle)\n\n    def deactivate(self):\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, 0)\n\n    def set_size(self, shape, format):\n        if isinstance(format, str):\n            format = GlirFrameBuffer._formats[format][1]\n        if (shape, format) != self._shape_format:\n            self._shape_format = shape, format\n            self.activate()\n            gl.glRenderbufferStorage(gl.GL_RENDERBUFFER, format,\n                                     shape[1], shape[0])",
  "class GlirFrameBuffer(GlirObject):\n\n    # todo: on ES 2.0 -> gl.gl_RGBA4\n    _formats = {'color': (gl.GL_COLOR_ATTACHMENT0, gl.GL_RGBA),\n                'depth': (gl.GL_DEPTH_ATTACHMENT, gl.GL_DEPTH_COMPONENT16),\n                'stencil': (gl.GL_STENCIL_ATTACHMENT, gl.GL_STENCIL_INDEX8)}\n\n    def create(self):\n        # self._parser._fb_stack = [0]  # To keep track of active FB\n        self._handle = gl.glCreateFramebuffer()\n        self._validated = False\n\n    def delete(self):\n        gl.glDeleteFramebuffer(self._handle)\n\n    def set_framebuffer(self, yes):\n        if yes:\n            self.activate()\n            if not self._validated:\n                self._validated = True\n                self._validate()\n        else:\n            self.deactivate()\n\n    def activate(self):\n        stack = self._parser.env.setdefault('fb_stack',\n                                            [self._parser.env['fbo']])\n        if stack[-1] != self._handle:\n            stack.append(self._handle)\n            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, self._handle)\n\n    def deactivate(self):\n        stack = self._parser.env.setdefault('fb_stack',\n                                            [self._parser.env['fbo']])\n        while self._handle in stack:\n            stack.remove(self._handle)\n        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, stack[-1])\n\n    def attach(self, attachment, buffer_id):\n        attachment = GlirFrameBuffer._formats[attachment][0]\n        self.activate()\n        if buffer_id == 0:\n            gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                         gl.GL_RENDERBUFFER, 0)\n        else:\n            buffer = self._parser.get_object(buffer_id)\n            if buffer == JUST_DELETED:\n                return\n            if buffer is None:\n                raise ValueError(\"Unknown buffer with id %i for attachement\" %\n                                 buffer_id)\n            elif isinstance(buffer, GlirRenderBuffer):\n                buffer.activate()\n                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                             gl.GL_RENDERBUFFER, buffer.handle)\n                buffer.deactivate()\n            elif isinstance(buffer, GlirTexture2D):\n                buffer.activate()\n                # INFO: 0 is for mipmap level 0 (default) of the texture\n                gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, attachment,\n                                          gl.GL_TEXTURE_2D, buffer.handle, 0)\n                buffer.deactivate()\n            else:\n                raise ValueError(\"Invalid attachment: %s\" % type(buffer))\n        self._validated = False\n        self.deactivate()\n\n    def _validate(self):\n        res = gl.glCheckFramebufferStatus(gl.GL_FRAMEBUFFER)\n        if res == gl.GL_FRAMEBUFFER_COMPLETE:\n            return\n        _bad_map = {\n            0: 'Target not equal to GL_FRAMEBUFFER',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n                'FrameBuffer attachments are incomplete.',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n                'No valid attachments in the FrameBuffer.',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n                'attachments do not have the same width and height.',\n            # gl.GL_FRAMEBUFFER_INCOMPLETE_FORMATS: \\  # not in es 2.0\n            #     'Internal format of attachment is not renderable.'\n            gl.GL_FRAMEBUFFER_UNSUPPORTED:\n                'Combination of internal formats used by attachments is '\n                'not supported.',\n        }\n        raise RuntimeError(_bad_map.get(res, 'Unknown framebuffer error: %r.'\n                                        % res))",
  "def __init__(self, queue):\n        self._commands = []  # local commands\n        self._verbose = False\n        # queues that have been merged with this one\n        self._associations = weakref.WeakKeyDictionary({queue: None})",
  "def command(self, *args):\n        \"\"\"Send a command. See the command spec at:\n        https://github.com/vispy/vispy/wiki/Spec.-Gloo-IR\n        \"\"\"\n        self._commands.append(args)",
  "def set_verbose(self, verbose):\n        \"\"\"Set verbose or not. If True, the GLIR commands are printed right before they get parsed.\n        If a string is given, use it as a filter.\n        \"\"\"\n        self._verbose = verbose",
  "def show(self, filter=None):\n        \"\"\"Print the list of commands currently in the queue. If filter is\n        given, print only commands that match the filter.\n        \"\"\"\n        for command in self._commands:\n            if command[0] is None:  # or command[1] in self._invalid_objects:\n                continue  # Skip nill commands\n            if filter and command[0] != filter:\n                continue\n            t = []\n            for e in command:\n                if isinstance(e, np.ndarray):\n                    t.append('array %s' % str(e.shape))\n                elif isinstance(e, str):\n                    s = e.strip()\n                    if len(s) > 20:\n                        s = s[:18] + '... %i lines' % (e.count('\\n')+1)\n                    t.append(s)\n                else:\n                    t.append(e)\n            print(tuple(t))",
  "def clear(self):\n        \"\"\"Pop the whole queue (and associated queues) and return a\n        list of commands.\n        \"\"\"\n        commands = self._commands\n        self._commands = []\n        return commands",
  "def flush(self, parser):\n        \"\"\"Flush all current commands to the GLIR interpreter.\"\"\"\n        if self._verbose:\n            show = self._verbose if isinstance(self._verbose, str) else None\n            self.show(show)\n        parser.parse(self._filter(self.clear(), parser))",
  "def _filter(self, commands, parser):\n        \"\"\"Filter DATA/SIZE commands that are overridden by a\n        SIZE command.\n        \"\"\"\n        resized = set()\n        commands2 = []\n        for command in reversed(commands):\n            if command[1] in resized:\n                if command[0] in ('SIZE', 'DATA'):\n                    continue  # remove this command\n            elif command[0] == 'SIZE':\n                resized.add(command[1])\n            commands2.append(command)\n        return list(reversed(commands2))",
  "def __init__(self):\n        # We do not actually queue any commands here, but on a shared queue\n        # object that may be joined with others as queues are associated.\n        self._shared = _GlirQueueShare(self)",
  "def command(self, *args):\n        \"\"\"Send a command. See the command spec at:\n        https://github.com/vispy/vispy/wiki/Spec.-GLIR\n        \"\"\"\n        self._shared.command(*args)",
  "def set_verbose(self, verbose):\n        \"\"\"Set verbose or not. If True, the GLIR commands are printed\n        right before they get parsed. If a string is given, use it as\n        a filter.\n        \"\"\"\n        self._shared.set_verbose(verbose)",
  "def clear(self):\n        \"\"\"Pop the whole queue (and associated queues) and return a\n        list of commands.\n        \"\"\"\n        return self._shared.clear()",
  "def associate(self, queue):\n        \"\"\"Merge this queue with another.\n\n        Both queues will use a shared command list and either one can be used\n        to fill or flush the shared queue.\n        \"\"\"\n        assert isinstance(queue, GlirQueue)\n        if queue._shared is self._shared:\n            return\n\n        # merge commands\n        self._shared._commands.extend(queue.clear())\n        self._shared._verbose |= queue._shared._verbose\n        self._shared._associations[queue] = None\n        # update queue and all related queues to use the same _shared object\n        for ch in queue._shared._associations:\n            ch._shared = self._shared\n            self._shared._associations[ch] = None\n        queue._shared = self._shared",
  "def flush(self, parser):\n        \"\"\"Flush all current commands to the GLIR interpreter.\"\"\"\n        self._shared.flush(parser)",
  "def __init__(self):\n        self.capabilities = dict(\n            gl_version='Unknown',\n            max_texture_size=None,\n        )",
  "def is_remote(self):\n        \"\"\"Whether the code is executed remotely. i.e. gloo.gl cannot\n        be used.\n        \"\"\"\n        raise NotImplementedError()",
  "def shader_compatibility(self):\n        \"\"\"Whether to convert shading code. Valid values are 'es2' and\n        'desktop'. If None, the shaders are not modified.\n        \"\"\"\n        raise NotImplementedError()",
  "def parse(self, commands):\n        \"\"\"Parse the GLIR commands. Or sent them away.\"\"\"\n        raise NotImplementedError()",
  "def __init__(self):\n        super(GlirParser, self).__init__()\n        self._objects = {}\n        self._invalid_objects = set()\n\n        self._classmap = {'VertexShader': GlirVertexShader,\n                          'FragmentShader': GlirFragmentShader,\n                          'GeometryShader': GlirGeometryShader,\n                          'Program': GlirProgram,\n                          'VertexBuffer': GlirVertexBuffer,\n                          'IndexBuffer': GlirIndexBuffer,\n                          'Texture1D': GlirTexture1D,\n                          'Texture2D': GlirTexture2D,\n                          'Texture3D': GlirTexture3D,\n                          'TextureCube': GlirTextureCube,\n                          'RenderBuffer': GlirRenderBuffer,\n                          'FrameBuffer': GlirFrameBuffer,\n                          }\n\n        # We keep a dict that the GLIR objects use for storing\n        # per-context information. This dict is cleared each time\n        # that the context is made current. This seems necessary for\n        # when two Canvases share a context.\n        self.env = {}",
  "def shader_compatibility(self):\n        \"\"\"Type of shader compatibility\"\"\"\n        if '.es' in gl.current_backend.__name__:\n            return 'es2'\n        else:\n            return 'desktop'",
  "def is_remote(self):\n        return False",
  "def _parse(self, command):\n        \"\"\"Parse a single command.\"\"\"\n        cmd, id_, args = command[0], command[1], command[2:]\n\n        if cmd == 'CURRENT':\n            # This context is made current\n            self.env.clear()\n            self._gl_initialize()\n            self.env['fbo'] = args[0]\n            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, args[0])\n        elif cmd == 'FUNC':\n            # GL function call\n            args = [as_enum(a) for a in args]\n            try:\n                getattr(gl, id_)(*args)\n            except AttributeError:\n                logger.warning('Invalid gl command: %r' % id_)\n        elif cmd == 'CREATE':\n            # Creating an object\n            if args[0] is not None:\n                klass = self._classmap[args[0]]\n                self._objects[id_] = klass(self, id_)\n            else:\n                self._invalid_objects.add(id_)\n        elif cmd == 'DELETE':\n            # Deleting an object\n            ob = self._objects.get(id_, None)\n            if ob is not None:\n                self._objects[id_] = JUST_DELETED\n                ob.delete()\n        else:\n            # Doing somthing to an object\n            ob = self._objects.get(id_, None)\n            if ob == JUST_DELETED:\n                return\n            if ob is None:\n                if id_ not in self._invalid_objects:\n                    raise RuntimeError('Cannot %s object %i because it '\n                                       'does not exist' % (cmd, id_))\n                return\n            # Triage over command. Order of commands is set so most\n            # common ones occur first.\n            if cmd == 'DRAW':  # Program\n                ob.draw(*args)\n            elif cmd == 'TEXTURE':  # Program\n                ob.set_texture(*args)\n            elif cmd == 'UNIFORM':  # Program\n                ob.set_uniform(*args)\n            elif cmd == 'ATTRIBUTE':  # Program\n                ob.set_attribute(*args)\n            elif cmd == 'DATA':  # VertexBuffer, IndexBuffer, Texture, Shader\n                ob.set_data(*args)\n            elif cmd == 'SIZE':  # VertexBuffer, IndexBuffer,\n                ob.set_size(*args)  # Texture[1D, 2D, 3D], RenderBuffer\n            elif cmd == 'ATTACH':  # FrameBuffer, Program\n                ob.attach(*args)\n            elif cmd == 'FRAMEBUFFER':  # FrameBuffer\n                ob.set_framebuffer(*args)\n            # elif cmd == 'SHADERS':  # Program\n            #     ob.set_shaders(*args)\n            elif cmd == 'LINK':  # Program\n                ob.link_program(*args)\n            elif cmd == 'WRAPPING':  # Texture1D, Texture2D, Texture3D\n                ob.set_wrapping(*args)\n            elif cmd == 'INTERPOLATION':  # Texture1D, Texture2D, Texture3D\n                ob.set_interpolation(*args)\n            else:\n                logger.warning('Invalid GLIR command %r' % cmd)",
  "def parse(self, commands):\n        \"\"\"Parse a list of commands.\"\"\"\n        # Get rid of dummy objects that represented deleted objects in\n        # the last parsing round.\n        to_delete = []\n        for id_, val in self._objects.items():\n            if val == JUST_DELETED:\n                to_delete.append(id_)\n        for id_ in to_delete:\n            self._objects.pop(id_)\n\n        for command in commands:\n            self._parse(command)",
  "def get_object(self, id_):\n        \"\"\"Get the object with the given id or None if it does not exist.\"\"\"\n        return self._objects.get(id_, None)",
  "def _gl_initialize(self):\n        \"\"\"Deal with compatibility; desktop does not have sprites enabled by default. ES has.\"\"\"\n        if '.es' in gl.current_backend.__name__:\n            pass  # ES2: no action required\n        else:\n            # Desktop, enable sprites\n            GL_VERTEX_PROGRAM_POINT_SIZE = 34370\n            GL_POINT_SPRITE = 34913\n            gl.glEnable(GL_VERTEX_PROGRAM_POINT_SIZE)\n            gl.glEnable(GL_POINT_SPRITE)\n        if self.capabilities['max_texture_size'] is None:  # only do once\n            self.capabilities['gl_version'] = gl.glGetParameter(gl.GL_VERSION)\n            self.capabilities['max_texture_size'] = \\\n                gl.glGetParameter(gl.GL_MAX_TEXTURE_SIZE)\n            this_version = self.capabilities['gl_version'].split(' ')\n            if this_version[0] == \"OpenGL\":\n                # For OpenGL ES, the version string has the format:\n                # \"OpenGL ES <version number> <vendor-specific information>\"\n                this_version = this_version[2]\n            else:\n                this_version = this_version[0]\n\n            if not this_version:\n                logger.warning(\"OpenGL version could not be determined, which \"\n                               \"might be a sign that OpenGL is not loaded correctly.\")\n            elif LooseVersion(this_version) < '2.1':\n                if os.getenv('VISPY_IGNORE_OLD_VERSION', '').lower() != 'true':\n                    logger.warning('OpenGL version 2.1 or higher recommended, '\n                                   'got %s. Some functionality may fail.'\n                                   % self.capabilities['gl_version'])",
  "class cls(parser_cls):\n        def __init__(self, *args, **kwargs):\n            parser_cls.__init__(self, *args, **kwargs)\n\n            if isinstance(file_or_filename, str):\n                self._file = open(file_or_filename, 'w')\n            else:\n                self._file = file_or_filename\n\n            self._file.write('[]')\n            self._empty = True\n\n        def _parse(self, command):\n            parser_cls._parse(self, command)\n\n            self._file.seek(self._file.tell() - 1)\n            if self._empty:\n                self._empty = False\n            else:\n                self._file.write(',\\n')\n            json.dump(as_es2_command(command),\n                      self._file, cls=NumPyJSONEncoder)\n            self._file.write(']')",
  "def __init__(self, parser, id_):\n        self._parser = parser\n        self._id = id_\n        self._handle = -1  # Must be set by subclass in create()\n        self.create()",
  "def handle(self):\n        return self._handle",
  "def id(self):\n        return self._id",
  "def __repr__(self):\n        return '<%s %i at 0x%x>' % (self.__class__.__name__, self.id, id(self))",
  "def create(self):\n        self._handle = gl.glCreateShader(self._target)",
  "def set_data(self, offset, code):\n        # NOTE: offset will always be 0 to match other DATA commands\n\n        # convert shader to be compatible with backend\n        convert = self._parser.shader_compatibility\n        if convert:\n            code = convert_shader(convert, code)\n\n        gl.glShaderSource(self._handle, code)\n        gl.glCompileShader(self._handle)\n        status = gl.glGetShaderParameter(self._handle, gl.GL_COMPILE_STATUS)\n        if not status:\n            errors = gl.glGetShaderInfoLog(self._handle)\n            errormsg = self._get_error(code, errors, 4)\n            raise RuntimeError(\"Shader compilation error in %s:\\n%s\" %\n                               (self._target, errormsg))",
  "def delete(self):\n        gl.glDeleteShader(self._handle)",
  "def _get_error(self, code, errors, indentation=0):\n        \"\"\"Get error and show the faulty line + some context\n        Other GLIR implementations may omit this.\n        \"\"\"\n        # Init\n        results = []\n        lines = None\n        if code is not None:\n            lines = [line.strip() for line in code.split('\\n')]\n\n        for error in errors.split('\\n'):\n            # Strip; skip empy lines\n            error = error.strip()\n            if not error:\n                continue\n            # Separate line number from description (if we can)\n            linenr, error = self._parse_error(error)\n            if None in (linenr, lines):\n                results.append('%s' % error)\n            else:\n                results.append('on line %i: %s' % (linenr, error))\n                if linenr > 0 and linenr < len(lines):\n                    results.append('  %s' % lines[linenr - 1])\n\n        # Add indentation and return\n        results = [' ' * indentation + r for r in results]\n        return '\\n'.join(results)",
  "def _parse_error(self, error):\n        \"\"\"Parses a single GLSL error and extracts the linenr and description\n        Other GLIR implementations may omit this.\n        \"\"\"\n        error = str(error)\n        # Nvidia\n        # 0(7): error C1008: undefined variable \"MV\"\n        m = re.match(r'(\\d+)\\((\\d+)\\)\\s*:\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # ATI / Intel\n        # ERROR: 0:131: '{' : syntax error parse error\n        m = re.match(r'ERROR:\\s(\\d+):(\\d+):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # Nouveau\n        # 0:28(16): error: syntax error, unexpected ')', expecting '('\n        m = re.match(r'(\\d+):(\\d+)\\((\\d+)\\):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(4)\n        # Other ...\n        return None, error",
  "def __init__(self, *args, **kwargs):\n        if not hasattr(gl, 'GL_GEOMETRY_SHADER'):\n            raise RuntimeError(gl.current_backend.__name__ +\n                               \" backend does not support geometry shaders.\"\n                               \" Try gloo.gl.use_gl('gl+').\")\n        GlirGeometryShader._target = gl.GL_GEOMETRY_SHADER\n        GlirShader.__init__(self, *args, **kwargs)",
  "def create(self):\n        self._handle = gl.glCreateProgram()\n        self._attached_shaders = []\n        self._validated = False\n        self._linked = False\n        # Keeping track of uniforms/attributes\n        self._handles = {}  # cache with handles to attributes/uniforms\n        self._unset_variables = set()\n        # Store samplers in buffers that are bount to uniforms/attributes\n        self._samplers = {}  # name -> (tex-target, tex-handle, unit)\n        self._attributes = {}  # name -> (vbo-handle, attr-handle, func, args)\n        self._known_invalid = set()",
  "def delete(self):\n        gl.glDeleteProgram(self._handle)",
  "def activate(self):\n        \"\"\"Avoid overhead in calling glUseProgram with same arg.\n        Warning: this will break if glUseProgram is used somewhere else.\n        Per context we keep track of one current program.\n        \"\"\"\n        if self._handle != self._parser.env.get('current_program', False):\n            self._parser.env['current_program'] = self._handle\n            gl.glUseProgram(self._handle)",
  "def deactivate(self):\n        \"\"\"Avoid overhead in calling glUseProgram with same arg.\n        Warning: this will break if glUseProgram is used somewhere else.\n        Per context we keep track of one current program.\n        \"\"\"\n        if self._parser.env.get('current_program', 0) != 0:\n            self._parser.env['current_program'] = 0\n            gl.glUseProgram(0)",
  "def set_shaders(self, vert, frag):\n        \"\"\"This function takes care of setting the shading code and\n        compiling+linking it into a working program object that is ready\n        to use.\n        \"\"\"\n        self._linked = False\n\n        # For both vertex and fragment shader: set source, compile, check\n        for code, type_ in [(vert, 'vertex'),\n                            (frag, 'fragment')]:\n            self.attach_shader(code, type_)\n\n        self.link_program()",
  "def attach(self, id_):\n        \"\"\"Attach a shader to this program.\"\"\"\n        shader = self._parser.get_object(id_)\n        gl.glAttachShader(self._handle, shader.handle)\n        self._attached_shaders.append(shader)",
  "def link_program(self):\n        \"\"\"Link the complete program and check.\n\n        All shaders are detached and deleted if the program was successfully\n        linked.\n        \"\"\"\n        gl.glLinkProgram(self._handle)\n        if not gl.glGetProgramParameter(self._handle, gl.GL_LINK_STATUS):\n            raise RuntimeError('Program linking error:\\n%s'\n                               % gl.glGetProgramInfoLog(self._handle))\n\n        # Detach all shaders to prepare them for deletion (they are no longer\n        # needed after linking is complete)\n        for shader in self._attached_shaders:\n            gl.glDetachShader(self._handle, shader.handle)\n        self._attached_shaders = []\n\n        # Now we know what variables will be used by the program\n        self._unset_variables = self._get_active_attributes_and_uniforms()\n        self._handles = {}\n        self._known_invalid = set()\n        self._linked = True",
  "def _get_active_attributes_and_uniforms(self):\n        \"\"\"Retrieve active attributes and uniforms to be able to check that\n        all uniforms/attributes are set by the user.\n        Other GLIR implementations may omit this.\n        \"\"\"\n        # This match a name of the form \"name[size]\" (= array)\n        regex = re.compile(r\"\"\"(?P<name>\\w+)\\s*(\\[(?P<size>\\d+)\\])\\s*\"\"\")\n        # Get how many active attributes and uniforms there are\n        cu = gl.glGetProgramParameter(self._handle, gl.GL_ACTIVE_UNIFORMS)\n        ca = gl.glGetProgramParameter(self.handle, gl.GL_ACTIVE_ATTRIBUTES)\n        # Get info on each one\n        attributes = []\n        uniforms = []\n        for container, count, func in [(attributes, ca, gl.glGetActiveAttrib),\n                                       (uniforms, cu, gl.glGetActiveUniform)]:\n            for i in range(count):\n                name, size, gtype = func(self._handle, i)\n                m = regex.match(name)  # Check if xxx[0] instead of xx\n                if m:\n                    name = m.group('name')\n                    for i in range(size):\n                        container.append(('%s[%d]' % (name, i), gtype))\n                else:\n                    container.append((name, gtype))\n        # return attributes, uniforms\n        return set([v[0] for v in attributes] + [v[0] for v in uniforms])",
  "def set_texture(self, name, value):\n        \"\"\"Set a texture sampler. Value is the id of the texture to link.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Not setting texture data for variable %s; '\n                            'uniform is not active.' % name)\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        if True:\n            # Sampler: the value is the id of the texture\n            tex = self._parser.get_object(value)\n            if tex == JUST_DELETED:\n                return\n            if tex is None:\n                raise RuntimeError('Could not find texture with id %i' % value)\n            unit = len(self._samplers)\n            if name in self._samplers:\n                unit = self._samplers[name][-1]  # Use existing unit\n            self._samplers[name] = tex._target, tex.handle, unit\n            gl.glUniform1i(handle, unit)",
  "def set_uniform(self, name, type_, value):\n        \"\"\"Set a uniform value. Value is assumed to have been checked.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        count = 1\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            # if we set a uniform_array, mark all as set\n            if not type_.startswith('mat'):\n                count = value.nbytes // (4 * self.ATYPEINFO[type_][0])\n            if count > 1:\n                for ii in range(count):\n                    if '%s[%s]' % (name, ii) in self._unset_variables:\n                        self._unset_variables.discard('%s[%s]' % (name, ii))\n\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Not setting value for variable %s %s; '\n                            'uniform is not active.' % (type_, name))\n                return\n        # Look up function to call\n        funcname = self.UTYPEMAP[type_]\n        func = getattr(gl, funcname)\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on type\n        if type_.startswith('mat'):\n            # Value is matrix, these gl funcs have alternative signature\n            transpose = False  # OpenGL ES 2.0 does not support transpose\n            func(handle, 1, transpose, value)\n        else:\n            # Regular uniform\n            func(handle, count, value)",
  "def set_attribute(self, name, type_, value):\n        \"\"\"Set an attribute value. Value is assumed to have been checked.\"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set attribute when program has no code')\n        # Get handle for the attribute, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetAttribLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                if value[0] != 0 and value[2] > 0:  # VBO with offset\n                    return  # Probably an unused element in a structured VBO\n                logger.info('Not setting data for variable %s %s; '\n                            'attribute is not active.' % (type_, name))\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on VBO or tuple data\n        if value[0] == 0:\n            # Look up function call\n            funcname = self.ATYPEMAP[type_]\n            func = getattr(gl, funcname)\n            # Set data\n            self._attributes[name] = 0, handle, func, value[1:]\n        else:\n            # Get meta data\n            vbo_id, stride, offset = value\n            size, gtype, dtype = self.ATYPEINFO[type_]\n            # Get associated VBO\n            vbo = self._parser.get_object(vbo_id)\n            if vbo == JUST_DELETED:\n                return\n            if vbo is None:\n                raise RuntimeError('Could not find VBO with id %i' % vbo_id)\n            # Set data\n            func = gl.glVertexAttribPointer\n            args = size, gtype, gl.GL_FALSE, stride, offset\n            self._attributes[name] = vbo.handle, handle, func, args",
  "def _pre_draw(self):\n        self.activate()\n        # Activate textures\n        for tex_target, tex_handle, unit in self._samplers.values():\n            gl.glActiveTexture(gl.GL_TEXTURE0 + unit)\n            gl.glBindTexture(tex_target, tex_handle)\n        # Activate attributes\n        for vbo_handle, attr_handle, func, args in self._attributes.values():\n            if vbo_handle:\n                gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo_handle)\n                gl.glEnableVertexAttribArray(attr_handle)\n                func(attr_handle, *args)\n            else:\n                gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)\n                gl.glDisableVertexAttribArray(attr_handle)\n                func(attr_handle, *args)\n        # Validate. We need to validate after textures units get assigned\n        if not self._validated:\n            self._validated = True\n            self._validate()",
  "def _validate(self):\n        # Validate ourselves\n        if self._unset_variables:\n            logger.warning('Program has unset variables: %r' %\n                           self._unset_variables)\n        # Validate via OpenGL\n        gl.glValidateProgram(self._handle)\n        if not gl.glGetProgramParameter(self._handle,\n                                        gl.GL_VALIDATE_STATUS):\n            raise RuntimeError('Program validation error:\\n%s'\n                               % gl.glGetProgramInfoLog(self._handle))",
  "def _post_draw(self):\n        # No need to deactivate each texture/buffer, just set to 0\n        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)\n        gl.glBindTexture(gl.GL_TEXTURE_2D, 0)\n        if USE_TEX_3D:\n            gl.glBindTexture(GL_TEXTURE_3D, 0)\n            gl.glBindTexture(GL_TEXTURE_1D, 0)",
  "def draw(self, mode, selection):\n        \"\"\"Draw program in given mode, with given selection (IndexBuffer or\n        first, count).\n        \"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot draw program if code has not been set')\n        # Init\n        gl.check_error('Check before draw')\n        try:\n            mode = as_enum(mode)\n        except ValueError:\n            if mode == 'lines_adjacency' or mode == 'line_strip_adjacency':\n                raise RuntimeError(gl.current_backend.__name__ +\n                                   \" backend does not support lines_adjacency\"\n                                   \" and line_strip_adjacency primitives.\"\n                                   \" Try gloo.gl.use_gl('gl+').\")\n            raise\n\n        # Draw\n        if len(selection) == 3:\n            # Selection based on indices\n            id_, gtype, count = selection\n            if count:\n                self._pre_draw()\n                ibuf = self._parser.get_object(id_)\n                ibuf.activate()\n                gl.glDrawElements(mode, count, as_enum(gtype), None)\n                ibuf.deactivate()\n        else:\n            # Selection based on start and count\n            first, count = selection\n            if count:\n                self._pre_draw()\n                gl.glDrawArrays(mode, first, count)\n        # Wrap up\n        gl.check_error('Check after draw')\n        self._post_draw()",
  "def create(self):\n        self._handle = gl.glCreateBuffer()\n        self._buffer_size = 0\n        self._bufferSubDataOk = False",
  "def delete(self):\n        gl.glDeleteBuffer(self._handle)",
  "def activate(self):\n        gl.glBindBuffer(self._target, self._handle)",
  "def deactivate(self):\n        gl.glBindBuffer(self._target, 0)",
  "def set_size(self, nbytes):  # in bytes\n        if nbytes != self._buffer_size:\n            self.activate()\n            gl.glBufferData(self._target, nbytes, self._usage)\n            self._buffer_size = nbytes",
  "def set_data(self, offset, data):\n        self.activate()\n        nbytes = data.nbytes\n\n        # Determine whether to check errors to try handling the ATI bug\n        check_ati_bug = ((not self._bufferSubDataOk) and\n                         (gl.current_backend.__name__.split(\".\")[-1] == \"gl2\") and\n                         sys.platform.startswith('win'))\n\n        # flush any pending errors\n        if check_ati_bug:\n            gl.check_error('periodic check')\n\n        try:\n            gl.glBufferSubData(self._target, offset, data)\n            if check_ati_bug:\n                gl.check_error('glBufferSubData')\n            self._bufferSubDataOk = True  # glBufferSubData seems to work\n        except Exception:\n            # This might be due to a driver error (seen on ATI), issue #64.\n            # We try to detect this, and if we can use glBufferData instead\n            if offset == 0 and nbytes == self._buffer_size:\n                gl.glBufferData(self._target, data, self._usage)\n                logger.debug(\"Using glBufferData instead of \" +\n                             \"glBufferSubData (known ATI bug).\")\n            else:\n                raise",
  "def create(self):\n        self._handle = gl.glCreateTexture()\n        self._shape_formats = 0",
  "def delete(self):\n        gl.glDeleteTexture(self._handle)",
  "def activate(self):\n        gl.glBindTexture(self._target, self._handle)",
  "def deactivate(self):\n        gl.glBindTexture(self._target, 0)",
  "def _get_alignment(self, width):\n        \"\"\"Determines a textures byte alignment.\n\n        If the width isn't a power of 2\n        we need to adjust the byte alignment of the image.\n        The image height is unimportant\n\n        www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n        \"\"\"\n        # we know the alignment is appropriate\n        # if we can divide the width by the\n        # alignment cleanly\n        # valid alignments are 1,2,4 and 8\n        # 4 is the default\n        alignments = [8, 4, 2, 1]\n        for alignment in alignments:\n            if width % alignment == 0:\n                return alignment",
  "def set_wrapping(self, wrapping):\n        self.activate()\n        wrapping = [as_enum(w) for w in wrapping]\n        if len(wrapping) == 3:\n            GL_TEXTURE_WRAP_R = 32882\n            gl.glTexParameterf(self._target, GL_TEXTURE_WRAP_R, wrapping[0])\n        if len(wrapping) >= 2:\n            gl.glTexParameterf(self._target,\n                               gl.GL_TEXTURE_WRAP_S, wrapping[-2])\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_WRAP_T, wrapping[-1])",
  "def set_interpolation(self, min, mag):\n        self.activate()\n        min, mag = as_enum(min), as_enum(mag)\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_MIN_FILTER, min)\n        gl.glTexParameterf(self._target, gl.GL_TEXTURE_MAG_FILTER, mag)",
  "def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        if internalformat is not None:\n            internalformat = as_enum(internalformat)\n        else:\n            internalformat = format\n        # Shape is width\n        if (shape, format, internalformat) != self._shape_formats:\n            self.activate()\n            self._shape_formats = shape, format, internalformat\n            glTexImage1D(self._target, 0, internalformat, format,\n                         gl.GL_BYTE, shape[:1])",
  "def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        x = offset[0]\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        glTexSubImage1D(self._target, 0, x, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "def set_size(self, shape, format, internalformat):\n        # Shape is height, width\n        format = as_enum(format)\n        internalformat = format if internalformat is None \\\n            else as_enum(internalformat)\n        if (shape, format, internalformat) != self._shape_formats:\n            self._shape_formats = shape, format, internalformat\n            self.activate()\n            gl.glTexImage2D(self._target, 0, internalformat, format,\n                            gl.GL_UNSIGNED_BYTE, shape[:2])",
  "def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        y, x = offset\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        gl.glTexSubImage2D(self._target, 0, x, y, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        if internalformat is not None:\n            internalformat = as_enum(internalformat)\n        else:\n            internalformat = format\n        # Shape is depth, height, width\n        if (shape, format, internalformat) != self._shape_formats:\n            self.activate()\n            self._shape_formats = shape, format, internalformat\n            glTexImage3D(self._target, 0, internalformat, format,\n                         gl.GL_BYTE, shape[:3])",
  "def set_data(self, offset, data):\n        self.activate()\n        shape, format, internalformat = self._shape_formats\n        z, y, x = offset\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type not allowed for texture\")\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        glTexSubImage3D(self._target, 0, x, y, z, format, gtype, data)\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "def set_size(self, shape, format, internalformat):\n        format = as_enum(format)\n        internalformat = format if internalformat is None \\\n            else as_enum(internalformat)\n        if (shape, format, internalformat) != self._shape_formats:\n            self._shape_formats = shape, format, internalformat\n            self.activate()\n            for target in self._cube_targets:\n                gl.glTexImage2D(target, 0, internalformat, format,\n                                gl.GL_UNSIGNED_BYTE, shape[1:3])",
  "def set_data(self, offset, data):\n        shape, format, internalformat = self._shape_formats\n        y, x = offset[:2]\n        # Get gtype\n        gtype = self._types.get(np.dtype(data.dtype), None)\n        if gtype is None:\n            raise ValueError(\"Type %r not allowed for texture\" % data.dtype)\n        self.activate()\n        # Set alignment (width is nbytes_per_pixel * npixels_per_line)\n        alignment = self._get_alignment(data.shape[-2] * data.shape[-1] * data.itemsize)\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, alignment)\n        # Upload\n        for i, target in enumerate(self._cube_targets):\n            gl.glTexSubImage2D(target, 0, x, y, format, gtype, data[i])\n        # Set alignment back\n        if alignment != 4:\n            gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)",
  "def create(self):\n        self._handle = gl.glCreateRenderbuffer()\n        self._shape_format = 0",
  "def delete(self):\n        gl.glDeleteRenderbuffer(self._handle)",
  "def activate(self):\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, self._handle)",
  "def deactivate(self):\n        gl.glBindRenderbuffer(gl.GL_RENDERBUFFER, 0)",
  "def set_size(self, shape, format):\n        if isinstance(format, str):\n            format = GlirFrameBuffer._formats[format][1]\n        if (shape, format) != self._shape_format:\n            self._shape_format = shape, format\n            self.activate()\n            gl.glRenderbufferStorage(gl.GL_RENDERBUFFER, format,\n                                     shape[1], shape[0])",
  "def create(self):\n        # self._parser._fb_stack = [0]  # To keep track of active FB\n        self._handle = gl.glCreateFramebuffer()\n        self._validated = False",
  "def delete(self):\n        gl.glDeleteFramebuffer(self._handle)",
  "def set_framebuffer(self, yes):\n        if yes:\n            self.activate()\n            if not self._validated:\n                self._validated = True\n                self._validate()\n        else:\n            self.deactivate()",
  "def activate(self):\n        stack = self._parser.env.setdefault('fb_stack',\n                                            [self._parser.env['fbo']])\n        if stack[-1] != self._handle:\n            stack.append(self._handle)\n            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, self._handle)",
  "def deactivate(self):\n        stack = self._parser.env.setdefault('fb_stack',\n                                            [self._parser.env['fbo']])\n        while self._handle in stack:\n            stack.remove(self._handle)\n        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, stack[-1])",
  "def attach(self, attachment, buffer_id):\n        attachment = GlirFrameBuffer._formats[attachment][0]\n        self.activate()\n        if buffer_id == 0:\n            gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                         gl.GL_RENDERBUFFER, 0)\n        else:\n            buffer = self._parser.get_object(buffer_id)\n            if buffer == JUST_DELETED:\n                return\n            if buffer is None:\n                raise ValueError(\"Unknown buffer with id %i for attachement\" %\n                                 buffer_id)\n            elif isinstance(buffer, GlirRenderBuffer):\n                buffer.activate()\n                gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER, attachment,\n                                             gl.GL_RENDERBUFFER, buffer.handle)\n                buffer.deactivate()\n            elif isinstance(buffer, GlirTexture2D):\n                buffer.activate()\n                # INFO: 0 is for mipmap level 0 (default) of the texture\n                gl.glFramebufferTexture2D(gl.GL_FRAMEBUFFER, attachment,\n                                          gl.GL_TEXTURE_2D, buffer.handle, 0)\n                buffer.deactivate()\n            else:\n                raise ValueError(\"Invalid attachment: %s\" % type(buffer))\n        self._validated = False\n        self.deactivate()",
  "def _validate(self):\n        res = gl.glCheckFramebufferStatus(gl.GL_FRAMEBUFFER)\n        if res == gl.GL_FRAMEBUFFER_COMPLETE:\n            return\n        _bad_map = {\n            0: 'Target not equal to GL_FRAMEBUFFER',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n                'FrameBuffer attachments are incomplete.',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n                'No valid attachments in the FrameBuffer.',\n            gl.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n                'attachments do not have the same width and height.',\n            # gl.GL_FRAMEBUFFER_INCOMPLETE_FORMATS: \\  # not in es 2.0\n            #     'Internal format of attachment is not renderable.'\n            gl.GL_FRAMEBUFFER_UNSUPPORTED:\n                'Combination of internal formats used by attachments is '\n                'not supported.',\n        }\n        raise RuntimeError(_bad_map.get(res, 'Unknown framebuffer error: %r.'\n                                        % res))",
  "def __init__(self, *args, **kwargs):\n            parser_cls.__init__(self, *args, **kwargs)\n\n            if isinstance(file_or_filename, str):\n                self._file = open(file_or_filename, 'w')\n            else:\n                self._file = file_or_filename\n\n            self._file.write('[]')\n            self._empty = True",
  "def _parse(self, command):\n            parser_cls._parse(self, command)\n\n            self._file.seek(self._file.tell() - 1)\n            if self._empty:\n                self._empty = False\n            else:\n                self._file.write(',\\n')\n            json.dump(as_es2_command(command),\n                      self._file, cls=NumPyJSONEncoder)\n            self._file.write(']')",
  "class Shader(GLObject):\n    def __init__(self, code=None):\n        GLObject.__init__(self)\n        if code is not None:\n            self.code = code\n\n    @property\n    def code(self):\n        return self._code\n\n    @code.setter\n    def code(self, code):\n        self._code = preprocess(code)\n        # use hardcoded offset of 0 to match other GLIR DATA commands\n        self._glir.command('DATA', self._id, 0, self._code)",
  "class VertexShader(Shader):\n    _GLIR_TYPE = 'VertexShader'",
  "class FragmentShader(Shader):\n    _GLIR_TYPE = 'FragmentShader'",
  "class GeometryShader(Shader):\n    _GLIR_TYPE = 'GeometryShader'",
  "class Program(GLObject):\n    \"\"\"Shader program object\n\n    A Program is an object to which shaders can be attached and linked to\n    create the final program.\n\n    Uniforms and attributes can be set using indexing: e.g.\n    ``program['a_pos'] = pos_data`` and ``program['u_color'] = (1, 0, 0)``.\n\n    Parameters\n    ----------\n    vert : str\n        The vertex shader to be used by this program\n    frag : str\n        The fragment shader to be used by this program\n    count : int (optional)\n        The program will prepare a structured vertex buffer of count\n        vertices. All attributes set using ``prog['attr'] = X`` will\n        be combined into a structured vbo with interleaved elements, which\n        is more efficient than having one vbo per attribute.\n\n    Notes\n    -----\n    If several shaders are specified, only one can contain the main\n    function. OpenGL ES 2.0 does not support a list of shaders.\n    \"\"\"\n\n    _GLIR_TYPE = 'Program'\n\n    _gtypes = {  # DTYPE, NUMEL\n        'float': (np.float32, 1),\n        'vec2': (np.float32, 2),\n        'vec3': (np.float32, 3),\n        'vec4': (np.float32, 4),\n        'int': (np.int32, 1),\n        'ivec2': (np.int32, 2),\n        'ivec3': (np.int32, 3),\n        'ivec4': (np.int32, 4),\n        'bool': (np.int32, 1),\n        'bvec2': (bool, 2),\n        'bvec3': (bool, 3),\n        'bvec4': (bool, 4),\n        'mat2': (np.float32, 4),\n        'mat3': (np.float32, 9), \n        'mat4': (np.float32, 16),\n        'sampler1D': (np.uint32, 1),\n        'sampler2D': (np.uint32, 1),\n        'sampler3D': (np.uint32, 1),\n        'samplerCube': (np.uint32, 1),\n    }\n\n    # ---------------------------------\n    def __init__(self, vert=None, frag=None, count=0):\n        GLObject.__init__(self)\n\n        # Init source code for vertex and fragment shader\n        self._shaders = None, None\n\n        # Init description of variables obtained from source code\n        self._code_variables = {}  # name -> (kind, type_, name)\n        # Init user-defined data for attributes and uniforms\n        self._user_variables = {}  # name -> data / buffer / texture\n        # Init pending user-defined data\n        self._pending_variables = {}  # name -> data\n\n        # NOTE: we *could* allow vert and frag to be a tuple/list of shaders,\n        # but that would complicate the GLIR implementation, and it seems\n        # unncessary\n\n        # Check and set shaders\n        if isinstance(vert, str) and isinstance(frag, str):\n            self.set_shaders(vert, frag)\n        elif not (vert is None and frag is None):\n            raise ValueError('Vert and frag must either both be str or None')\n\n        # Build associated structured vertex buffer if count is given.\n        # This makes it easy to create a structured vertex buffer\n        # without having to create a numpy array with structured dtype.\n        # All assignments must be done before the GLIR commands are\n        # sent away for parsing (in draw) though.\n        self._count = count\n        self._buffer = None  # Set to None in draw()\n        if self._count > 0:\n            dtype = []\n            for kind, type_, name, size in self._code_variables.values():\n                if kind == 'attribute':\n                    dt, numel = self._gtypes[type_]\n                    dtype.append((name, dt, numel) if numel != 1 else (name, dt))\n            self._buffer = np.zeros(self._count, dtype=dtype)\n            self.bind(VertexBuffer(self._buffer))\n\n    def set_shaders(self, vert, frag, geom=None, update_variables=True):\n        \"\"\"Set the vertex and fragment shaders.\n\n        Parameters\n        ----------\n        vert : str\n            Source code for vertex shader.\n        frag : str\n            Source code for fragment shaders.\n        geom : str (optional)\n            Source code for geometry shader.\n        update_variables : bool\n            If True, then process any pending variables immediately after\n            setting shader code. Default is True.\n        \"\"\"\n        if not vert or not frag:\n            raise ValueError('Vertex and fragment code must both be non-empty')\n\n        # pre-process shader code for #include directives\n        shaders = [VertexShader(vert), FragmentShader(frag)]\n        if geom is not None:\n            shaders.append(GeometryShader(geom))\n\n        for shader in shaders:\n            self.glir.associate(shader.glir)\n            self._glir.command('ATTACH', self._id, shader.id)\n\n        # Store source code, send it to glir, parse the code for variables\n        self._shaders = shaders\n\n        # Link all shaders into one program. All shaders are detached after\n        # linking is complete.\n        self._glir.command('LINK', self._id)\n\n        # Delete shaders. We no longer need them and it frees up precious GPU\n        # memory: http://gamedev.stackexchange.com/questions/47910\n        for shader in shaders:\n            shader.delete()\n\n        # All current variables become pending variables again\n        for key, val in self._user_variables.items():\n            self._pending_variables[key] = val\n        self._user_variables = {}\n        # Parse code (and process pending variables)\n        self._parse_variables_from_code(update_variables=update_variables)\n\n    @property\n    def shaders(self):\n        \"\"\"All currently attached shaders\"\"\"\n        return self._shaders\n\n    @property\n    def variables(self):\n        \"\"\"A list of the variables in use by the current program\n\n        The list is obtained by parsing the GLSL source code.\n\n        Returns\n        -------\n        variables : list\n            Each variable is represented as a tuple (kind, type, name),\n            where `kind` is 'attribute', 'uniform', 'uniform_array',\n            'varying' or 'const'.\n        \"\"\"\n        # Note that internally the variables are stored as a dict\n        # that maps names -> tuples, for easy looking up by name.\n        return [x[:3] for x in self._code_variables.values()]\n\n    def _parse_variables_from_code(self, update_variables=True):\n        \"\"\"Parse uniforms, attributes and varyings from the source code.\"\"\"\n        # Get one string of code with comments removed\n        code = '\\n\\n'.join([sh.code for sh in self._shaders])\n        code = re.sub(r'(.*)(//.*)', r'\\1', code, re.M)\n\n        # Parse uniforms, attributes and varyings\n        self._code_variables = {}\n        for kind in ('uniform', 'attribute', 'varying', 'const', 'in', 'out'):\n\n            # treat *in* like attribute, *out* like varying\n            if kind == 'in':\n                kind = 'attribute'\n            elif kind == 'out':\n                kind = 'varying'\n\n            for m in re.finditer(REGEX_VAR[kind], code):\n                gtype = m.group('type')\n                size = int(m.group('size')) if m.group('size') else -1\n                this_kind = kind\n                if size >= 1:\n                    # uniform arrays get added both as individuals and full\n                    for i in range(size):\n                        name = '%s[%d]' % (m.group('name'), i)\n                        self._code_variables[name] = kind, gtype, name, -1\n                    this_kind = 'uniform_array'\n                name = m.group('name')\n                self._code_variables[name] = this_kind, gtype, name, size\n\n        # Now that our code variables are up-to date, we can process\n        # the variables that were set but yet unknown.\n        if update_variables:\n            self._process_pending_variables()\n\n    def bind(self, data):\n        \"\"\"Bind a VertexBuffer that has structured data\n\n        Parameters\n        ----------\n        data : VertexBuffer\n            The vertex buffer to bind. The field names of the array\n            are mapped to attribute names in GLSL.\n        \"\"\"\n        # Check\n        if not isinstance(data, VertexBuffer):\n            raise ValueError('Program.bind() requires a VertexBuffer.')\n        # Apply\n        for name in data.dtype.names:\n            self[name] = data[name]\n\n    def _process_pending_variables(self):\n        \"\"\"Try to apply the variables that were set but not known yet.\"\"\"\n        # Clear our list of pending variables\n        self._pending_variables, pending = {}, self._pending_variables\n        # Try to apply it. On failure, it will be added again\n        for name, data in pending.items():\n            self[name] = data\n\n    def __setitem__(self, name, data):\n        \"\"\"Setting uniform or attribute data\n\n        This method requires the information about the variable that we\n        know from parsing the source code. If this information is not\n        yet available, the data is stored in a list of pending data,\n        and we attempt to set it once new shading code has been set.\n\n        For uniforms, the data can represent a plain uniform or a\n        sampler. In the latter case, this method accepts a Texture\n        object or a numpy array which is used to update the existing\n        texture. A new texture is created if necessary.\n\n        For attributes, the data can be a tuple/float which GLSL will\n        use for the value of all vertices. This method also acceps VBO\n        data as a VertexBuffer object or a numpy array which is used\n        to update the existing VertexBuffer. A new VertexBuffer is\n        created if necessary.\n\n        By passing None as data, the uniform or attribute can be\n        \"unregistered\". This can be useful to get rid of variables that\n        are no longer present or active in the new source code that is\n        about to be set.\n        \"\"\"\n        # Deal with local buffer storage (see count argument in __init__)\n        if (self._buffer is not None) and not isinstance(data, DataBuffer):\n            if name in self._buffer.dtype.names:\n                self._buffer[name] = data\n                return\n\n        # Forget any pending values for this variable\n        self._pending_variables.pop(name, None)\n\n        # Delete?\n        if data is None:\n            self._user_variables.pop(name, None)\n            return\n\n        if name in self._code_variables:\n            kind, type_, name, size = self._code_variables[name]\n\n            if kind == 'uniform':\n                if type_.startswith('sampler'):\n                    # Texture data; overwrite or update\n                    tex = self._user_variables.get(name, None)\n                    if isinstance(data, BaseTexture):\n                        pass\n                    elif tex and hasattr(tex, 'set_data'):\n                        tex.set_data(data)\n                        return\n                    elif type_ == 'sampler1D':\n                        data = Texture1D(data)\n                    elif type_ == 'sampler2D':\n                        data = Texture2D(data)\n                    elif type_ == 'sampler3D':\n                        data = Texture3D(data)\n                    elif type_ == 'samplerCube':\n                        data = TextureCube(data)\n                    else:\n                        # This should not happen\n                        raise RuntimeError('Unknown type %s' % type_)\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    self.glir.associate(data.glir)\n                    self._glir.command('TEXTURE', self._id, name, data.id)\n                else:\n                    # Normal uniform; convert to np array and check size\n                    dtype, numel = self._gtypes[type_]\n                    data = np.array(data, dtype=dtype).ravel()\n                    if data.size != numel:\n                        raise ValueError('Uniform %r needs %i elements, '\n                                         'not %i.' % (name, numel, data.size))\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    self._glir.command('UNIFORM', self._id, name, type_, data)\n\n            elif kind == 'uniform_array':\n                # Normal uniform; convert to np array and check size\n                dtype, numel = self._gtypes[type_]\n                data = np.atleast_2d(data).astype(dtype)\n                need_shape = (size, numel)\n                if data.shape != need_shape:\n                    raise ValueError('Uniform array %r needs shape %s not %s'\n                                     % (name, need_shape, data.shape))\n                data = data.ravel()\n                # Store and send GLIR command\n                self._user_variables[name] = data\n                self._glir.command('UNIFORM', self._id, name, type_, data)\n\n            elif kind == 'attribute':\n                # Is this a constant value per vertex\n                is_constant = False\n\n                def isscalar(x):\n                    return isinstance(x, (float, int))\n\n                if isscalar(data):\n                    is_constant = True\n                elif isinstance(data, (tuple, list)):\n                    is_constant = all([isscalar(e) for e in data])\n\n                if not is_constant:\n                    # VBO data; overwrite or update\n                    vbo = self._user_variables.get(name, None)\n                    if isinstance(data, DataBuffer):\n                        pass\n                    elif vbo is not None and hasattr(vbo, 'set_data'):\n                        vbo.set_data(data)\n                        return\n                    else:\n                        data = VertexBuffer(data)\n                    # Store and send GLIR command\n                    if data.dtype is not None:\n                        numel = self._gtypes[type_][1]\n                        if data._last_dim and data._last_dim != numel:\n                            raise ValueError('data.shape[-1] must be %s '\n                                             'not %s for %s'\n                                             % (numel, data._last_dim, name))\n                    self._user_variables[name] = data\n                    value = (data.id, data.stride, data.offset)\n                    self.glir.associate(data.glir)\n                    self._glir.command('ATTRIBUTE', self._id,\n                                       name, type_, value)\n                else:\n                    # Single-value attribute; convert to array and check size\n                    dtype, numel = self._gtypes[type_]\n                    data = np.array(data, dtype=dtype)\n                    if data.ndim == 0:\n                        data.shape = data.size\n                    if data.size != numel:\n                        raise ValueError('Attribute %r needs %i elements, '\n                                         'not %i.' % (name, numel, data.size))\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    value = tuple([0] + [i for i in data])\n                    self._glir.command('ATTRIBUTE', self._id,\n                                       name, type_, value)\n            else:\n                raise KeyError('Cannot set data for a %s.' % kind)\n        else:\n            # This variable is not defined in the current source code,\n            # so we cannot establish whether this is a uniform or\n            # attribute, nor check its type. Try again later.\n            self._pending_variables[name] = data\n\n    def __contains__(self, key):\n        return key in self._code_variables\n\n    def __getitem__(self, name):\n        \"\"\"Get user-defined data for attributes and uniforms.\"\"\"\n        if name in self._user_variables:\n            return self._user_variables[name]\n        elif name in self._pending_variables:\n            return self._pending_variables[name]\n        else:\n            raise KeyError(\"Unknown uniform or attribute %s\" % name)\n\n    def draw(self, mode='triangles', indices=None, check_error=True):\n        \"\"\"Draw the attribute arrays in the specified mode.\n\n        Parameters\n        ----------\n        mode : str | GL_ENUM\n            'points', 'lines', 'line_strip', 'line_loop', 'lines_adjacency',\n            'line_strip_adjacency', 'triangles', 'triangle_strip', or\n            'triangle_fan'.\n        indices : array\n            Array of indices to draw.\n        check_error:\n            Check error after draw.\n        \"\"\"\n        # Invalidate buffer (data has already been sent)\n        self._buffer = None\n\n        # Check if mode is valid\n        mode = check_enum(mode)\n        if mode not in ['points', 'lines', 'line_strip', 'line_loop',\n                        'lines_adjacency', 'line_strip_adjacency', 'triangles',\n                        'triangle_strip', 'triangle_fan']:\n            raise ValueError('Invalid draw mode: %r' % mode)\n\n        # Check leftover variables, warn, discard them\n        # In GLIR we check whether all attributes are indeed set\n        for name in self._pending_variables:\n            logger.warn('Value provided for %r, but this variable was not '\n                        'found in the shader program.' % name)\n        self._pending_variables = {}\n\n        # Check attribute sizes\n        attributes = [vbo for vbo in self._user_variables.values()\n                      if isinstance(vbo, DataBuffer)]\n        sizes = [a.size for a in attributes]\n        if len(attributes) < 1:\n            raise RuntimeError('Must have at least one attribute')\n        if not all(s == sizes[0] for s in sizes[1:]):\n            msg = '\\n'.join(['%s: %s' % (str(a), a.size) for a in attributes])\n            raise RuntimeError('All attributes must have the same size, got:\\n'\n                               '%s' % msg)\n\n        # Get the glir queue that we need now\n        canvas = get_current_canvas()\n        assert canvas is not None\n\n        # Associate canvas\n        canvas.context.glir.associate(self.glir)\n\n        # Indexbuffer\n        if isinstance(indices, IndexBuffer):\n            canvas.context.glir.associate(indices.glir)\n            logger.debug(\"Program drawing %r with index buffer\" % mode)\n            gltypes = {np.dtype(np.uint8): 'UNSIGNED_BYTE',\n                       np.dtype(np.uint16): 'UNSIGNED_SHORT',\n                       np.dtype(np.uint32): 'UNSIGNED_INT'}\n            selection = indices.id, gltypes[indices.dtype], indices.size\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        elif indices is None:\n            selection = 0, attributes[0].size\n            logger.debug(\"Program drawing %r with %r\" % (mode, selection))\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        else:\n            raise TypeError(\"Invalid index: %r (must be IndexBuffer)\" %\n                            indices)\n\n        # Process GLIR commands\n        canvas.context.flush_commands()",
  "def __init__(self, code=None):\n        GLObject.__init__(self)\n        if code is not None:\n            self.code = code",
  "def code(self):\n        return self._code",
  "def code(self, code):\n        self._code = preprocess(code)\n        # use hardcoded offset of 0 to match other GLIR DATA commands\n        self._glir.command('DATA', self._id, 0, self._code)",
  "def __init__(self, vert=None, frag=None, count=0):\n        GLObject.__init__(self)\n\n        # Init source code for vertex and fragment shader\n        self._shaders = None, None\n\n        # Init description of variables obtained from source code\n        self._code_variables = {}  # name -> (kind, type_, name)\n        # Init user-defined data for attributes and uniforms\n        self._user_variables = {}  # name -> data / buffer / texture\n        # Init pending user-defined data\n        self._pending_variables = {}  # name -> data\n\n        # NOTE: we *could* allow vert and frag to be a tuple/list of shaders,\n        # but that would complicate the GLIR implementation, and it seems\n        # unncessary\n\n        # Check and set shaders\n        if isinstance(vert, str) and isinstance(frag, str):\n            self.set_shaders(vert, frag)\n        elif not (vert is None and frag is None):\n            raise ValueError('Vert and frag must either both be str or None')\n\n        # Build associated structured vertex buffer if count is given.\n        # This makes it easy to create a structured vertex buffer\n        # without having to create a numpy array with structured dtype.\n        # All assignments must be done before the GLIR commands are\n        # sent away for parsing (in draw) though.\n        self._count = count\n        self._buffer = None  # Set to None in draw()\n        if self._count > 0:\n            dtype = []\n            for kind, type_, name, size in self._code_variables.values():\n                if kind == 'attribute':\n                    dt, numel = self._gtypes[type_]\n                    dtype.append((name, dt, numel) if numel != 1 else (name, dt))\n            self._buffer = np.zeros(self._count, dtype=dtype)\n            self.bind(VertexBuffer(self._buffer))",
  "def set_shaders(self, vert, frag, geom=None, update_variables=True):\n        \"\"\"Set the vertex and fragment shaders.\n\n        Parameters\n        ----------\n        vert : str\n            Source code for vertex shader.\n        frag : str\n            Source code for fragment shaders.\n        geom : str (optional)\n            Source code for geometry shader.\n        update_variables : bool\n            If True, then process any pending variables immediately after\n            setting shader code. Default is True.\n        \"\"\"\n        if not vert or not frag:\n            raise ValueError('Vertex and fragment code must both be non-empty')\n\n        # pre-process shader code for #include directives\n        shaders = [VertexShader(vert), FragmentShader(frag)]\n        if geom is not None:\n            shaders.append(GeometryShader(geom))\n\n        for shader in shaders:\n            self.glir.associate(shader.glir)\n            self._glir.command('ATTACH', self._id, shader.id)\n\n        # Store source code, send it to glir, parse the code for variables\n        self._shaders = shaders\n\n        # Link all shaders into one program. All shaders are detached after\n        # linking is complete.\n        self._glir.command('LINK', self._id)\n\n        # Delete shaders. We no longer need them and it frees up precious GPU\n        # memory: http://gamedev.stackexchange.com/questions/47910\n        for shader in shaders:\n            shader.delete()\n\n        # All current variables become pending variables again\n        for key, val in self._user_variables.items():\n            self._pending_variables[key] = val\n        self._user_variables = {}\n        # Parse code (and process pending variables)\n        self._parse_variables_from_code(update_variables=update_variables)",
  "def shaders(self):\n        \"\"\"All currently attached shaders\"\"\"\n        return self._shaders",
  "def variables(self):\n        \"\"\"A list of the variables in use by the current program\n\n        The list is obtained by parsing the GLSL source code.\n\n        Returns\n        -------\n        variables : list\n            Each variable is represented as a tuple (kind, type, name),\n            where `kind` is 'attribute', 'uniform', 'uniform_array',\n            'varying' or 'const'.\n        \"\"\"\n        # Note that internally the variables are stored as a dict\n        # that maps names -> tuples, for easy looking up by name.\n        return [x[:3] for x in self._code_variables.values()]",
  "def _parse_variables_from_code(self, update_variables=True):\n        \"\"\"Parse uniforms, attributes and varyings from the source code.\"\"\"\n        # Get one string of code with comments removed\n        code = '\\n\\n'.join([sh.code for sh in self._shaders])\n        code = re.sub(r'(.*)(//.*)', r'\\1', code, re.M)\n\n        # Parse uniforms, attributes and varyings\n        self._code_variables = {}\n        for kind in ('uniform', 'attribute', 'varying', 'const', 'in', 'out'):\n\n            # treat *in* like attribute, *out* like varying\n            if kind == 'in':\n                kind = 'attribute'\n            elif kind == 'out':\n                kind = 'varying'\n\n            for m in re.finditer(REGEX_VAR[kind], code):\n                gtype = m.group('type')\n                size = int(m.group('size')) if m.group('size') else -1\n                this_kind = kind\n                if size >= 1:\n                    # uniform arrays get added both as individuals and full\n                    for i in range(size):\n                        name = '%s[%d]' % (m.group('name'), i)\n                        self._code_variables[name] = kind, gtype, name, -1\n                    this_kind = 'uniform_array'\n                name = m.group('name')\n                self._code_variables[name] = this_kind, gtype, name, size\n\n        # Now that our code variables are up-to date, we can process\n        # the variables that were set but yet unknown.\n        if update_variables:\n            self._process_pending_variables()",
  "def bind(self, data):\n        \"\"\"Bind a VertexBuffer that has structured data\n\n        Parameters\n        ----------\n        data : VertexBuffer\n            The vertex buffer to bind. The field names of the array\n            are mapped to attribute names in GLSL.\n        \"\"\"\n        # Check\n        if not isinstance(data, VertexBuffer):\n            raise ValueError('Program.bind() requires a VertexBuffer.')\n        # Apply\n        for name in data.dtype.names:\n            self[name] = data[name]",
  "def _process_pending_variables(self):\n        \"\"\"Try to apply the variables that were set but not known yet.\"\"\"\n        # Clear our list of pending variables\n        self._pending_variables, pending = {}, self._pending_variables\n        # Try to apply it. On failure, it will be added again\n        for name, data in pending.items():\n            self[name] = data",
  "def __setitem__(self, name, data):\n        \"\"\"Setting uniform or attribute data\n\n        This method requires the information about the variable that we\n        know from parsing the source code. If this information is not\n        yet available, the data is stored in a list of pending data,\n        and we attempt to set it once new shading code has been set.\n\n        For uniforms, the data can represent a plain uniform or a\n        sampler. In the latter case, this method accepts a Texture\n        object or a numpy array which is used to update the existing\n        texture. A new texture is created if necessary.\n\n        For attributes, the data can be a tuple/float which GLSL will\n        use for the value of all vertices. This method also acceps VBO\n        data as a VertexBuffer object or a numpy array which is used\n        to update the existing VertexBuffer. A new VertexBuffer is\n        created if necessary.\n\n        By passing None as data, the uniform or attribute can be\n        \"unregistered\". This can be useful to get rid of variables that\n        are no longer present or active in the new source code that is\n        about to be set.\n        \"\"\"\n        # Deal with local buffer storage (see count argument in __init__)\n        if (self._buffer is not None) and not isinstance(data, DataBuffer):\n            if name in self._buffer.dtype.names:\n                self._buffer[name] = data\n                return\n\n        # Forget any pending values for this variable\n        self._pending_variables.pop(name, None)\n\n        # Delete?\n        if data is None:\n            self._user_variables.pop(name, None)\n            return\n\n        if name in self._code_variables:\n            kind, type_, name, size = self._code_variables[name]\n\n            if kind == 'uniform':\n                if type_.startswith('sampler'):\n                    # Texture data; overwrite or update\n                    tex = self._user_variables.get(name, None)\n                    if isinstance(data, BaseTexture):\n                        pass\n                    elif tex and hasattr(tex, 'set_data'):\n                        tex.set_data(data)\n                        return\n                    elif type_ == 'sampler1D':\n                        data = Texture1D(data)\n                    elif type_ == 'sampler2D':\n                        data = Texture2D(data)\n                    elif type_ == 'sampler3D':\n                        data = Texture3D(data)\n                    elif type_ == 'samplerCube':\n                        data = TextureCube(data)\n                    else:\n                        # This should not happen\n                        raise RuntimeError('Unknown type %s' % type_)\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    self.glir.associate(data.glir)\n                    self._glir.command('TEXTURE', self._id, name, data.id)\n                else:\n                    # Normal uniform; convert to np array and check size\n                    dtype, numel = self._gtypes[type_]\n                    data = np.array(data, dtype=dtype).ravel()\n                    if data.size != numel:\n                        raise ValueError('Uniform %r needs %i elements, '\n                                         'not %i.' % (name, numel, data.size))\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    self._glir.command('UNIFORM', self._id, name, type_, data)\n\n            elif kind == 'uniform_array':\n                # Normal uniform; convert to np array and check size\n                dtype, numel = self._gtypes[type_]\n                data = np.atleast_2d(data).astype(dtype)\n                need_shape = (size, numel)\n                if data.shape != need_shape:\n                    raise ValueError('Uniform array %r needs shape %s not %s'\n                                     % (name, need_shape, data.shape))\n                data = data.ravel()\n                # Store and send GLIR command\n                self._user_variables[name] = data\n                self._glir.command('UNIFORM', self._id, name, type_, data)\n\n            elif kind == 'attribute':\n                # Is this a constant value per vertex\n                is_constant = False\n\n                def isscalar(x):\n                    return isinstance(x, (float, int))\n\n                if isscalar(data):\n                    is_constant = True\n                elif isinstance(data, (tuple, list)):\n                    is_constant = all([isscalar(e) for e in data])\n\n                if not is_constant:\n                    # VBO data; overwrite or update\n                    vbo = self._user_variables.get(name, None)\n                    if isinstance(data, DataBuffer):\n                        pass\n                    elif vbo is not None and hasattr(vbo, 'set_data'):\n                        vbo.set_data(data)\n                        return\n                    else:\n                        data = VertexBuffer(data)\n                    # Store and send GLIR command\n                    if data.dtype is not None:\n                        numel = self._gtypes[type_][1]\n                        if data._last_dim and data._last_dim != numel:\n                            raise ValueError('data.shape[-1] must be %s '\n                                             'not %s for %s'\n                                             % (numel, data._last_dim, name))\n                    self._user_variables[name] = data\n                    value = (data.id, data.stride, data.offset)\n                    self.glir.associate(data.glir)\n                    self._glir.command('ATTRIBUTE', self._id,\n                                       name, type_, value)\n                else:\n                    # Single-value attribute; convert to array and check size\n                    dtype, numel = self._gtypes[type_]\n                    data = np.array(data, dtype=dtype)\n                    if data.ndim == 0:\n                        data.shape = data.size\n                    if data.size != numel:\n                        raise ValueError('Attribute %r needs %i elements, '\n                                         'not %i.' % (name, numel, data.size))\n                    # Store and send GLIR command\n                    self._user_variables[name] = data\n                    value = tuple([0] + [i for i in data])\n                    self._glir.command('ATTRIBUTE', self._id,\n                                       name, type_, value)\n            else:\n                raise KeyError('Cannot set data for a %s.' % kind)\n        else:\n            # This variable is not defined in the current source code,\n            # so we cannot establish whether this is a uniform or\n            # attribute, nor check its type. Try again later.\n            self._pending_variables[name] = data",
  "def __contains__(self, key):\n        return key in self._code_variables",
  "def __getitem__(self, name):\n        \"\"\"Get user-defined data for attributes and uniforms.\"\"\"\n        if name in self._user_variables:\n            return self._user_variables[name]\n        elif name in self._pending_variables:\n            return self._pending_variables[name]\n        else:\n            raise KeyError(\"Unknown uniform or attribute %s\" % name)",
  "def draw(self, mode='triangles', indices=None, check_error=True):\n        \"\"\"Draw the attribute arrays in the specified mode.\n\n        Parameters\n        ----------\n        mode : str | GL_ENUM\n            'points', 'lines', 'line_strip', 'line_loop', 'lines_adjacency',\n            'line_strip_adjacency', 'triangles', 'triangle_strip', or\n            'triangle_fan'.\n        indices : array\n            Array of indices to draw.\n        check_error:\n            Check error after draw.\n        \"\"\"\n        # Invalidate buffer (data has already been sent)\n        self._buffer = None\n\n        # Check if mode is valid\n        mode = check_enum(mode)\n        if mode not in ['points', 'lines', 'line_strip', 'line_loop',\n                        'lines_adjacency', 'line_strip_adjacency', 'triangles',\n                        'triangle_strip', 'triangle_fan']:\n            raise ValueError('Invalid draw mode: %r' % mode)\n\n        # Check leftover variables, warn, discard them\n        # In GLIR we check whether all attributes are indeed set\n        for name in self._pending_variables:\n            logger.warn('Value provided for %r, but this variable was not '\n                        'found in the shader program.' % name)\n        self._pending_variables = {}\n\n        # Check attribute sizes\n        attributes = [vbo for vbo in self._user_variables.values()\n                      if isinstance(vbo, DataBuffer)]\n        sizes = [a.size for a in attributes]\n        if len(attributes) < 1:\n            raise RuntimeError('Must have at least one attribute')\n        if not all(s == sizes[0] for s in sizes[1:]):\n            msg = '\\n'.join(['%s: %s' % (str(a), a.size) for a in attributes])\n            raise RuntimeError('All attributes must have the same size, got:\\n'\n                               '%s' % msg)\n\n        # Get the glir queue that we need now\n        canvas = get_current_canvas()\n        assert canvas is not None\n\n        # Associate canvas\n        canvas.context.glir.associate(self.glir)\n\n        # Indexbuffer\n        if isinstance(indices, IndexBuffer):\n            canvas.context.glir.associate(indices.glir)\n            logger.debug(\"Program drawing %r with index buffer\" % mode)\n            gltypes = {np.dtype(np.uint8): 'UNSIGNED_BYTE',\n                       np.dtype(np.uint16): 'UNSIGNED_SHORT',\n                       np.dtype(np.uint32): 'UNSIGNED_INT'}\n            selection = indices.id, gltypes[indices.dtype], indices.size\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        elif indices is None:\n            selection = 0, attributes[0].size\n            logger.debug(\"Program drawing %r with %r\" % (mode, selection))\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        else:\n            raise TypeError(\"Invalid index: %r (must be IndexBuffer)\" %\n                            indices)\n\n        # Process GLIR commands\n        canvas.context.flush_commands()",
  "def isscalar(x):\n                    return isinstance(x, (float, int))",
  "class GLObject(object):\n    \"\"\"Generic GL object that represents an object on the GPU.\n\n    When a GLObject is instantiated, it is associated with the currently\n    active Canvas, or with the next Canvas to be created if there is no current Canvas\n    \"\"\"\n\n    # Type of GLIR object, reset in subclasses\n    _GLIR_TYPE = 'DummyGlirType'\n\n    # Internal id counter to keep track of GPU objects\n    _idcount = 0\n\n    def __init__(self):\n        \"\"\"Initialize the object in the default state\"\"\"\n        # Give this object an id\n        GLObject._idcount += 1\n        self._id = GLObject._idcount\n\n        # Create the GLIR queue in which we queue our commands. \n        # See docs above for details.\n        self._glir = GlirQueue()\n\n        # Give glir command to create GL representation of this object\n        self._glir.command('CREATE', self._id, self._GLIR_TYPE)\n\n    def __del__(self):\n        # You never know when this is goint to happen. The window might\n        # already be closed and no OpenGL context might be available.\n        # However, since we are using GLIR queue, this does not matter!\n        # If the command gets transported to the canvas, that is great,\n        # if not, this probably means that the canvas no longer exists.\n        self.delete()\n\n    def delete(self):\n        \"\"\"Delete the object from GPU memory. \n\n        Note that the GPU object will also be deleted when this gloo\n        object is about to be deleted. However, sometimes you want to explicitly delete the GPU object explicitly.\n        \"\"\"\n        # We only allow the object from being deleted once, otherwise\n        # we might be deleting another GPU object that got our gl-id\n        # after our GPU object was deleted. Also note that e.g.\n        # DataBufferView does not have the _glir attribute.\n        if hasattr(self, '_glir'):\n            # Send our final command into the queue\n            self._glir.command('DELETE', self._id)\n            # Tell main glir queue that this queue is no longer being used\n            self._glir._deletable = True\n            # Detach the queue\n            del self._glir\n\n    @property\n    def id(self):\n        \"\"\"The id of this GL object used to reference the GL object in GLIR. id's are unique within a process.\"\"\"\n        return self._id\n\n    @property\n    def glir(self):\n        \"\"\"The glir queue for this object.\"\"\"\n        return self._glir",
  "def __init__(self):\n        \"\"\"Initialize the object in the default state\"\"\"\n        # Give this object an id\n        GLObject._idcount += 1\n        self._id = GLObject._idcount\n\n        # Create the GLIR queue in which we queue our commands. \n        # See docs above for details.\n        self._glir = GlirQueue()\n\n        # Give glir command to create GL representation of this object\n        self._glir.command('CREATE', self._id, self._GLIR_TYPE)",
  "def __del__(self):\n        # You never know when this is goint to happen. The window might\n        # already be closed and no OpenGL context might be available.\n        # However, since we are using GLIR queue, this does not matter!\n        # If the command gets transported to the canvas, that is great,\n        # if not, this probably means that the canvas no longer exists.\n        self.delete()",
  "def delete(self):\n        \"\"\"Delete the object from GPU memory. \n\n        Note that the GPU object will also be deleted when this gloo\n        object is about to be deleted. However, sometimes you want to explicitly delete the GPU object explicitly.\n        \"\"\"\n        # We only allow the object from being deleted once, otherwise\n        # we might be deleting another GPU object that got our gl-id\n        # after our GPU object was deleted. Also note that e.g.\n        # DataBufferView does not have the _glir attribute.\n        if hasattr(self, '_glir'):\n            # Send our final command into the queue\n            self._glir.command('DELETE', self._id)\n            # Tell main glir queue that this queue is no longer being used\n            self._glir._deletable = True\n            # Detach the queue\n            del self._glir",
  "def id(self):\n        \"\"\"The id of this GL object used to reference the GL object in GLIR. id's are unique within a process.\"\"\"\n        return self._id",
  "def glir(self):\n        \"\"\"The glir queue for this object.\"\"\"\n        return self._glir",
  "def should_cast_to_f32(data_dtype):\n    \"\"\"Check if data type is floating point with more than 32-bits.\"\"\"\n    data_dtype = np.dtype(data_dtype)\n    is_floating = np.issubdtype(data_dtype, np.floating)\n    gt_float32 = data_dtype.itemsize > 4\n    if is_floating and gt_float32:\n        # OpenGL can't support floating point numbers greater than 32-bits\n        warnings.warn(F64_PRECISION_WARNING)\n        return True\n    return False",
  "class BaseTexture(GLObject):\n    \"\"\"\n    A Texture is used to represent a topological set of scalar values.\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array (or something that\n        can be turned into one). A tuple with the shape of the texture\n        can also be given.\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str | None\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str | None\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple | None\n        Optional. A tuple with the shape of the texture. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    _ndim = 2\n\n    _formats = {\n        1: 'luminance',  # or alpha, or red\n        2: 'luminance_alpha',  # or rg\n        3: 'rgb',\n        4: 'rgba'\n    }\n\n    _inv_formats = {\n        'luminance': 1,\n        'alpha': 1,\n        'red': 1,\n        'luminance_alpha': 2,\n        'rg': 2,\n        'rgb': 3,\n        'rgba': 4,\n        'depth_component': 1,\n    }\n\n    # NOTE: non-normalized formats ending with 'i' and 'ui' are currently\n    #   disabled as they don't work with the current VisPy implementation.\n    #   Attempting to use them along with the additional enums defined in\n    #   vispy/gloo/glir.py produces an invalid operation from OpenGL.\n    _inv_internalformats = dict([\n        (base + suffix, channels)\n        for base, channels in [('r', 1), ('rg', 2), ('rgb', 3), ('rgba', 4)]\n        for suffix in ['8', '16', '16f', '32f']  # , '8i', '8ui', '32i', '32ui']\n    ] + [\n        ('luminance', 1),\n        ('alpha', 1),\n        ('red', 1),\n        ('luminance_alpha', 2),\n        ('rg', 2),\n        ('rgb', 3),\n        ('rgba', 4),\n        ('depth_component', 1),\n    ])\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        GLObject.__init__(self)\n        if resizeable is not None:\n            resizable = resizeable\n            warnings.warn(\n                \"resizeable has been deprecated in favor of \"\n                \"resizable and will be removed next release\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        # Init shape and format\n        self._resizable = True  # at least while we're in init\n        self._shape = tuple([0 for i in range(self._ndim+1)])\n        self._format = format\n        self._internalformat = internalformat\n\n        # Set texture parameters (before setting data)\n        self.interpolation = interpolation or 'nearest'\n        self.wrapping = wrapping or 'clamp_to_edge'\n\n        # Set data or shape (shape arg is for backward compat)\n        if isinstance(data, tuple):\n            shape, data = data, None\n        if data is not None:\n            if shape is not None:\n                raise ValueError('Texture needs data or shape, not both.')\n            data = np.array(data, copy=False)\n            # So we can test the combination\n            self._resize(data.shape, format, internalformat)\n            self._set_data(data)\n        elif shape is not None:\n            self._resize(shape, format, internalformat)\n        else:\n            raise ValueError(\"Either data or shape must be given\")\n\n        # Set resizable (at end of init)\n        self._resizable = bool(resizable)\n\n    def _normalize_shape(self, data_or_shape):\n        # Get data and shape from input\n        if isinstance(data_or_shape, np.ndarray):\n            data = data_or_shape\n            shape = data.shape\n        else:\n            assert isinstance(data_or_shape, tuple)\n            data = None\n            shape = data_or_shape\n        # Check and correct\n        if shape:\n            if len(shape) < self._ndim:\n                raise ValueError(\"Too few dimensions for texture\")\n            elif len(shape) > self._ndim + 1:\n                raise ValueError(\"Too many dimensions for texture\")\n            elif len(shape) == self._ndim:\n                shape = shape + (1,)\n            else:  # if len(shape) == self._ndim + 1:\n                if shape[-1] > 4:\n                    raise ValueError(\"Too many channels for texture\")\n        # Return\n        return data.reshape(shape) if data is not None else shape\n\n    @property\n    def shape(self):\n        \"\"\"Data shape (last dimension indicates number of color channels)\"\"\"\n        return self._shape\n\n    @property\n    def format(self):\n        \"\"\"The texture format (color channels).\"\"\"\n        return self._format\n\n    @property\n    def internalformat(self):\n        \"\"\"The texture internalformat.\"\"\"\n        return self._internalformat\n\n    @property\n    def wrapping(self):\n        \"\"\"Texture wrapping mode\"\"\"\n        value = self._wrapping\n        return value[0] if all([v == value[0] for v in value]) else value\n\n    @wrapping.setter\n    def wrapping(self, value):\n        # Convert\n        if isinstance(value, int) or isinstance(value, str):\n            value = (value,) * self._ndim\n        elif isinstance(value, (tuple, list)):\n            if len(value) != self._ndim:\n                raise ValueError('Texture wrapping needs 1 or %i values' %\n                                 self._ndim)\n        else:\n            raise ValueError('Invalid value for wrapping: %r' % value)\n        # Check and set\n        valid = 'repeat', 'clamp_to_edge', 'mirrored_repeat'\n        value = tuple([check_enum(value[i], 'tex wrapping', valid)\n                       for i in range(self._ndim)])\n        self._wrapping = value\n        self._glir.command('WRAPPING', self._id, value)\n\n    @property\n    def interpolation(self):\n        \"\"\"Texture interpolation for minification and magnification.\"\"\"\n        value = self._interpolation\n        return value[0] if value[0] == value[1] else value\n\n    @interpolation.setter\n    def interpolation(self, value):\n        # Convert\n        if isinstance(value, int) or isinstance(value, str):\n            value = (value,) * 2\n        elif isinstance(value, (tuple, list)):\n            if len(value) != 2:\n                raise ValueError('Texture interpolation needs 1 or 2 values')\n        else:\n            raise ValueError('Invalid value for interpolation: %r' % value)\n        # Check and set\n        valid = 'nearest', 'linear'\n        value = (check_enum(value[0], 'tex interpolation', valid),\n                 check_enum(value[1], 'tex interpolation', valid))\n        self._interpolation = value\n        self._glir.command('INTERPOLATION', self._id, *value)\n\n    def resize(self, shape, format=None, internalformat=None):\n        \"\"\"Set the texture size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New texture shape in zyx order. Optionally, an extra dimention\n            may be specified to indicate the number of color channels.\n        format : str | enum | None\n            The format of the texture: 'luminance', 'alpha',\n            'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n            is chosen automatically based on the number of channels.\n            When the data has one channel, 'luminance' is assumed.\n        internalformat : str | enum | None\n            The internal (storage) format of the texture: 'luminance',\n            'alpha', 'r8', 'r16', 'r16f', 'r32f'; 'luminance_alpha',\n            'rg8', 'rg16', 'rg16f', 'rg32f'; 'rgb', 'rgb8', 'rgb16',\n            'rgb16f', 'rgb32f'; 'rgba', 'rgba8', 'rgba16', 'rgba16f',\n            'rgba32f'.  If None, the internalformat is chosen\n            automatically based on the number of channels.  This is a\n            hint which may be ignored by the OpenGL implementation.\n        \"\"\"\n        return self._resize(shape, format, internalformat)\n\n    def _check_format_change(self, format, num_channels):\n        # Determine format\n        if format is None:\n            format = self._formats[num_channels]\n            # Keep current format if channels match\n            if self._format and \\\n                    self._inv_formats[self._format] == self._inv_formats[format]:\n                format = self._format\n        else:\n            format = check_enum(format)\n\n        if format not in self._inv_formats:\n            raise ValueError('Invalid texture format: %r.' % format)\n        elif num_channels != self._inv_formats[format]:\n            raise ValueError('Format does not match with given shape. '\n                             '(format expects %d elements, data has %d)' %\n                             (self._inv_formats[format], num_channels))\n        return format\n\n    def _check_internalformat_change(self, internalformat, num_channels):\n        if internalformat is None:\n            # Keep current internalformat if channels match\n            if self._internalformat and \\\n               self._inv_internalformats[self._internalformat] == num_channels:\n                internalformat = self._internalformat\n        else:\n            internalformat = check_enum(internalformat)\n\n        if internalformat is None:\n            pass\n        elif internalformat not in self._inv_internalformats:\n            raise ValueError(\n                'Invalid texture internalformat: %r. Allowed formats: %r'\n                % (internalformat, self._inv_internalformats)\n            )\n        elif num_channels != self._inv_internalformats[internalformat]:\n            raise ValueError('Internalformat does not match with given shape.')\n        return internalformat\n\n    def _resize(self, shape, format=None, internalformat=None):\n        \"\"\"Internal method for resize.\"\"\"\n        shape = self._normalize_shape(shape)\n\n        # Check\n        if not self._resizable:\n            raise RuntimeError(\"Texture is not resizable\")\n\n        format = self._check_format_change(format, shape[-1])\n        internalformat = self._check_internalformat_change(internalformat, shape[-1])\n\n        # Store and send GLIR command\n        self._shape = shape\n        self._format = format\n        self._internalformat = internalformat\n        self._glir.command('SIZE', self._id, self._shape, self._format,\n                           self._internalformat)\n\n    def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitly resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        return self._set_data(data, offset, copy)\n\n    def _set_data(self, data, offset=None, copy=False):\n        \"\"\"Internal method for set_data.\"\"\"\n        # Copy if needed, check/normalize shape\n        data = np.array(data, copy=copy)\n        data = self._normalize_shape(data)\n\n        # Maybe resize to purge DATA commands?\n        if offset is None:\n            self._resize(data.shape)\n        elif all([i == 0 for i in offset]) and data.shape == self._shape:\n            self._resize(data.shape)\n\n        # Convert offset to something usable\n        offset = offset or tuple([0 for i in range(self._ndim)])\n        assert len(offset) == self._ndim\n\n        # Check if data fits\n        for i in range(len(data.shape)-1):\n            if offset[i] + data.shape[i] > self._shape[i]:\n                raise ValueError(\"Data is too large\")\n\n        # Send GLIR command\n        self._glir.command('DATA', self._id, offset, data)\n\n    def __setitem__(self, key, data):\n        \"\"\"x.__getitem__(y) <==> x[y]\"\"\"\n        # Make sure key is a tuple\n        if isinstance(key, (int, slice)) or key == Ellipsis:\n            key = (key,)\n\n        # Default is to access the whole texture\n        shape = self._shape\n        slices = [slice(0, shape[i]) for i in range(len(shape))]\n\n        # Check last key/Ellipsis to decide on the order\n        keys = key[::+1]\n        dims = range(0, len(key))\n        if key[0] == Ellipsis:\n            keys = key[::-1]\n            dims = range(len(self._shape) - 1,\n                         len(self._shape) - 1 - len(keys), -1)\n\n        # Find exact range for each key\n        for k, dim in zip(keys, dims):\n            size = self._shape[dim]\n            if isinstance(k, int):\n                if k < 0:\n                    k += size\n                if k < 0 or k > size:\n                    raise IndexError(\"Texture assignment index out of range\")\n                start, stop = k, k + 1\n                slices[dim] = slice(start, stop, 1)\n            elif isinstance(k, slice):\n                start, stop, step = k.indices(size)\n                if step != 1:\n                    raise IndexError(\"Cannot access non-contiguous data\")\n                if stop < start:\n                    start, stop = stop, start\n                slices[dim] = slice(start, stop, step)\n            elif k == Ellipsis:\n                pass\n            else:\n                raise TypeError(\"Texture indices must be integers\")\n\n        offset = tuple([s.start for s in slices])[:self._ndim]\n        shape = tuple([s.stop - s.start for s in slices])\n        size = np.prod(shape) if len(shape) > 0 else 1\n\n        # Make sure data is an array\n        if not isinstance(data, np.ndarray):\n            data = np.array(data, copy=False)\n        # Make sure data is big enough\n        if data.shape != shape:\n            data = np.resize(data, shape)\n\n        # Set data (deferred)\n        self._set_data(data=data, offset=offset, copy=False)\n\n    def __repr__(self):\n        return \"<%s shape=%r format=%r at 0x%x>\" % (\n            self.__class__.__name__, self._shape, self._format, id(self))",
  "class Texture1D(BaseTexture):\n    \"\"\"One dimensional texture\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array (or something that\n        can be turned into one). A tuple with the shape of the texture\n        can also be given.\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str | None\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str | None\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple | None\n        Optional. A tuple with the shape of the texture. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    _ndim = 1\n    _GLIR_TYPE = 'Texture1D'\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)\n\n    @property\n    def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[0]\n\n    @property\n    def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler1D'\n\n    @property\n    def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler1D'\n\n    @property\n    def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture1D'",
  "class Texture2D(BaseTexture):\n    \"\"\"Two dimensional texture\n\n    Parameters\n    ----------\n    data : ndarray\n        Texture data shaped as W, or a tuple with the shape for\n        the texture (W).\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple\n        Optional. A tuple with the shape HxW. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    _ndim = 2\n    _GLIR_TYPE = 'Texture2D'\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)\n\n    @property\n    def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[0]\n\n    @property\n    def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[1]\n\n    @property\n    def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler2D'\n\n    @property\n    def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler2D'\n\n    @property\n    def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture2D'",
  "class Texture3D(BaseTexture):\n    \"\"\"Three dimensional texture\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array (or something that\n        can be turned into one). A tuple with the shape of the texture\n        can also be given.\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str | None\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str | None\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple | None\n        Optional. A tuple with the shape of the texture. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    _ndim = 3\n    _GLIR_TYPE = 'Texture3D'\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)\n\n    @property\n    def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[2]\n\n    @property\n    def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[1]\n\n    @property\n    def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._shape[0]\n\n    @property\n    def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler3D'\n\n    @property\n    def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler3D'\n\n    @property\n    def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture3D'",
  "class TextureCube(BaseTexture):\n    \"\"\"Texture Cube\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array (or something that\n        can be turned into one). A tuple with the shape of the texture\n        can also be given.\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str | None\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str | None\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple | None\n        Optional. A tuple with the shape of the texture. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    _ndim = 3\n    _GLIR_TYPE = 'TextureCube'\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)\n        if self._shape[0] != 6:\n            raise ValueError(\"Texture cube require arrays first dimension to be 6 :\"\n                             \" {} was given.\".format(self._shape[0]))\n\n    @property\n    def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[1]\n\n    @property\n    def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[2]\n\n    @property\n    def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._shape[0]\n\n    @property\n    def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'samplerCube'\n\n    @property\n    def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'samplerCube'\n\n    @property\n    def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'textureCube'",
  "class TextureEmulated3D(Texture2D):\n    \"\"\"Two dimensional texture that is emulating a three dimensional texture\n\n    Parameters\n    ----------\n    data : ndarray | tuple | None\n        Texture data in the form of a numpy array (or something that\n        can be turned into one). A tuple with the shape of the texture\n        can also be given.\n    format : str | enum | None\n        The format of the texture: 'luminance', 'alpha',\n        'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n        is chosen automatically based on the number of channels.\n        When the data has one channel, 'luminance' is assumed.\n    resizable : bool\n        Indicates whether texture can be resized. Default True.\n    interpolation : str | None\n        Interpolation mode, must be one of: 'nearest', 'linear'.\n        Default 'nearest'.\n    wrapping : str | None\n        Wrapping mode, must be one of: 'repeat', 'clamp_to_edge',\n        'mirrored_repeat'. Default 'clamp_to_edge'.\n    shape : tuple | None\n        Optional. A tuple with the shape of the texture. If ``data``\n        is also a tuple, it will override the value of ``shape``.\n    internalformat : str | None\n        Internal format to use.\n    resizeable : None\n        Deprecated version of `resizable`.\n    \"\"\"\n\n    # TODO: does GL's nearest use floor or round?\n    _glsl_sample_nearest = \"\"\"\n        vec4 sample(sampler2D tex, vec3 texcoord) {\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * $shape.x, $shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / $shape.x;\n            texcoord.y = min(texcoord.y * $shape.y, $shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / $shape.y;\n\n            float index = floor(texcoord.z * $shape.z);\n\n            // Do a lookup in the 2D texture\n            float u = (mod(index, $r) + texcoord.x) / $r;\n            float v = (floor(index / $r) + texcoord.y) / $c;\n\n            return texture2D(tex, vec2(u,v));\n        }\n    \"\"\"\n\n    _glsl_sample_linear = \"\"\"\n        vec4 sample(sampler2D tex, vec3 texcoord) {\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * $shape.x, $shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / $shape.x;\n            texcoord.y = min(texcoord.y * $shape.y, $shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / $shape.y;\n\n            float z = texcoord.z * $shape.z;\n            float zindex1 = floor(z);\n            float u1 = (mod(zindex1, $r) + texcoord.x) / $r;\n            float v1 = (floor(zindex1 / $r) + texcoord.y) / $c;\n\n            float zindex2 = zindex1 + 1.0;\n            float u2 = (mod(zindex2, $r) + texcoord.x) / $r;\n            float v2 = (floor(zindex2 / $r) + texcoord.y) / $c;\n\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\n\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\n        }\n    \"\"\"\n\n    _gl_max_texture_size = 1024  # For now, we just set this manually\n\n    def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        from ..visuals.shaders import Function\n\n        self._set_emulated_shape(data)\n        Texture2D.__init__(self, self._normalize_emulated_shape(data),\n                           format, resizable, interpolation, wrapping,\n                           shape, internalformat, resizeable)\n        if self.interpolation == 'nearest':\n            self._glsl_sample = Function(self.__class__._glsl_sample_nearest)\n        else:\n            self._glsl_sample = Function(self.__class__._glsl_sample_linear)\n        self._update_variables()\n\n    def _set_emulated_shape(self, data_or_shape):\n        if isinstance(data_or_shape, np.ndarray):\n            self._emulated_shape = data_or_shape.shape\n        else:\n            assert isinstance(data_or_shape, tuple)\n            self._emulated_shape = tuple(data_or_shape)\n\n        depth, width = self._emulated_shape[0], self._emulated_shape[1]\n        self._r = TextureEmulated3D._gl_max_texture_size // width\n        self._c = depth // self._r\n        if math.fmod(depth, self._r):\n            self._c += 1\n\n    def _normalize_emulated_shape(self, data_or_shape):\n        if isinstance(data_or_shape, np.ndarray):\n            new_shape = self._normalize_emulated_shape(data_or_shape.shape)\n            new_data = np.empty(new_shape, dtype=data_or_shape.dtype)\n            for j in range(self._c):\n                for i in range(self._r):\n                    i0, i1 = i * self.width, (i+1) * self.width\n                    j0, j1 = j * self.height, (j+1) * self.height\n                    k = j * self._r + i\n                    if k >= self.depth:\n                        break\n                    new_data[j0:j1, i0:i1] = data_or_shape[k]\n\n            return new_data\n\n        assert isinstance(data_or_shape, tuple)\n        return (self._c * self.height, self._r * self.width) + \\\n            data_or_shape[3:]\n\n    def _update_variables(self):\n        self._glsl_sample['shape'] = self.shape[:3][::-1]\n        # On Windows with Python 2.7, self._c can end up being a long\n        # integer because Numpy array shapes return long integers. This\n        # causes issues when setting the gloo variables since these are\n        # expected to be native ints, so we cast the integers to ints\n        # to avoid this.\n        # Newer GLSL compilers do not implicitly cast types so these integers\n        # must be converted to floats lastly\n        self._glsl_sample['c'] = float(int(self._c))\n        self._glsl_sample['r'] = float(int(self._r))\n\n    def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitely resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        self._set_emulated_shape(data)\n        Texture2D.set_data(self, self._normalize_emulated_shape(data),\n                           offset, copy)\n        self._update_variables()\n\n    def resize(self, shape, format=None, internalformat=None):\n        \"\"\"Set the texture size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New texture shape in zyx order. Optionally, an extra dimention\n            may be specified to indicate the number of color channels.\n        format : str | enum | None\n            The format of the texture: 'luminance', 'alpha',\n            'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n            is chosen automatically based on the number of channels.\n            When the data has one channel, 'luminance' is assumed.\n        internalformat : str | enum | None\n            The internal (storage) format of the texture: 'luminance',\n            'alpha', 'r8', 'r16', 'r16f', 'r32f'; 'luminance_alpha',\n            'rg8', 'rg16', 'rg16f', 'rg32f'; 'rgb', 'rgb8', 'rgb16',\n            'rgb16f', 'rgb32f'; 'rgba', 'rgba8', 'rgba16', 'rgba16f',\n            'rgba32f'.  If None, the internalformat is chosen\n            automatically based on the number of channels.  This is a\n            hint which may be ignored by the OpenGL implementation.\n        \"\"\"\n        self._set_emulated_shape(shape)\n        Texture2D.resize(self, self._normalize_emulated_shape(shape),\n                         format, internalformat)\n        self._update_variables()\n\n    @property\n    def shape(self):\n        \"\"\"Data shape (last dimension indicates number of color channels)\"\"\"\n        return self._emulated_shape\n\n    @property\n    def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._emulated_shape[2]\n\n    @property\n    def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._emulated_shape[1]\n\n    @property\n    def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._emulated_shape[0]\n\n    @property\n    def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return self._glsl_sample",
  "class TextureAtlas(Texture2D):\n    \"\"\"Group multiple small data regions into a larger texture.\n\n    The algorithm is based on the article by Jukka Jyla\u0308nki : \"A Thousand Ways\n    to Pack the Bin - A Practical Approach to Two-Dimensional Rectangle Bin\n    Packing\", February 27, 2010. More precisely, this is an implementation of\n    the Skyline Bottom-Left algorithm based on C++ sources provided by Jukka\n    Jyla\u0308nki at: http://clb.demon.fi/files/RectangleBinPack/.\n\n    Parameters\n    ----------\n    shape : tuple of int\n        Texture shape (optional).\n    dtype : numpy.dtype object\n        Texture starting data type (default: float32)\n\n    Notes\n    -----\n    This creates a 2D texture that holds 1D float32 data.\n    An example of simple access:\n\n        >>> atlas = TextureAtlas()\n        >>> bounds = atlas.get_free_region(20, 30)\n        >>> atlas.set_region(bounds, np.random.rand(20, 30).T)\n    \"\"\"\n\n    def __init__(self, shape=(1024, 1024), dtype=np.float32):\n        shape = np.array(shape, int)\n        assert shape.ndim == 1 and shape.size == 2\n        shape = tuple(2 ** (np.log2(shape) + 0.5).astype(int)) + (3,)\n        self._atlas_nodes = [(0, 0, shape[1])]\n        data = np.zeros(shape, dtype)\n        super(TextureAtlas, self).__init__(data, interpolation='linear',\n                                           wrapping='clamp_to_edge')\n\n    def get_free_region(self, width, height):\n        \"\"\"Get a free region of given size and allocate it\n\n        Parameters\n        ----------\n        width : int\n            Width of region to allocate\n        height : int\n            Height of region to allocate\n\n        Returns\n        -------\n        bounds : tuple | None\n            A newly allocated region as (x, y, w, h) or None\n            (if failed).\n        \"\"\"\n        best_height = best_width = np.inf\n        best_index = -1\n        for i in range(len(self._atlas_nodes)):\n            y = self._fit(i, width, height)\n            if y >= 0:\n                node = self._atlas_nodes[i]\n                if (y+height < best_height or\n                        (y+height == best_height and node[2] < best_width)):\n                    best_height = y+height\n                    best_index = i\n                    best_width = node[2]\n                    region = node[0], y, width, height\n        if best_index == -1:\n            return None\n\n        node = region[0], region[1] + height, width\n        self._atlas_nodes.insert(best_index, node)\n        i = best_index+1\n        while i < len(self._atlas_nodes):\n            node = self._atlas_nodes[i]\n            prev_node = self._atlas_nodes[i-1]\n            if node[0] < prev_node[0]+prev_node[2]:\n                shrink = prev_node[0]+prev_node[2] - node[0]\n                x, y, w = self._atlas_nodes[i]\n                self._atlas_nodes[i] = x+shrink, y, w-shrink\n                if self._atlas_nodes[i][2] <= 0:\n                    del self._atlas_nodes[i]\n                    i -= 1\n                else:\n                    break\n            else:\n                break\n            i += 1\n\n        # Merge nodes\n        i = 0\n        while i < len(self._atlas_nodes)-1:\n            node = self._atlas_nodes[i]\n            next_node = self._atlas_nodes[i+1]\n            if node[1] == next_node[1]:\n                self._atlas_nodes[i] = node[0], node[1], node[2]+next_node[2]\n                del self._atlas_nodes[i+1]\n            else:\n                i += 1\n\n        return region\n\n    def _fit(self, index, width, height):\n        \"\"\"Test if region (width, height) fit into self._atlas_nodes[index]\"\"\"\n        node = self._atlas_nodes[index]\n        x, y = node[0], node[1]\n        width_left = width\n        if x+width > self._shape[1]:\n            return -1\n        i = index\n        while width_left > 0:\n            node = self._atlas_nodes[i]\n            y = max(y, node[1])\n            if y+height > self._shape[0]:\n                return -1\n            width_left -= node[2]\n            i += 1\n        return y",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        GLObject.__init__(self)\n        if resizeable is not None:\n            resizable = resizeable\n            warnings.warn(\n                \"resizeable has been deprecated in favor of \"\n                \"resizable and will be removed next release\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        # Init shape and format\n        self._resizable = True  # at least while we're in init\n        self._shape = tuple([0 for i in range(self._ndim+1)])\n        self._format = format\n        self._internalformat = internalformat\n\n        # Set texture parameters (before setting data)\n        self.interpolation = interpolation or 'nearest'\n        self.wrapping = wrapping or 'clamp_to_edge'\n\n        # Set data or shape (shape arg is for backward compat)\n        if isinstance(data, tuple):\n            shape, data = data, None\n        if data is not None:\n            if shape is not None:\n                raise ValueError('Texture needs data or shape, not both.')\n            data = np.array(data, copy=False)\n            # So we can test the combination\n            self._resize(data.shape, format, internalformat)\n            self._set_data(data)\n        elif shape is not None:\n            self._resize(shape, format, internalformat)\n        else:\n            raise ValueError(\"Either data or shape must be given\")\n\n        # Set resizable (at end of init)\n        self._resizable = bool(resizable)",
  "def _normalize_shape(self, data_or_shape):\n        # Get data and shape from input\n        if isinstance(data_or_shape, np.ndarray):\n            data = data_or_shape\n            shape = data.shape\n        else:\n            assert isinstance(data_or_shape, tuple)\n            data = None\n            shape = data_or_shape\n        # Check and correct\n        if shape:\n            if len(shape) < self._ndim:\n                raise ValueError(\"Too few dimensions for texture\")\n            elif len(shape) > self._ndim + 1:\n                raise ValueError(\"Too many dimensions for texture\")\n            elif len(shape) == self._ndim:\n                shape = shape + (1,)\n            else:  # if len(shape) == self._ndim + 1:\n                if shape[-1] > 4:\n                    raise ValueError(\"Too many channels for texture\")\n        # Return\n        return data.reshape(shape) if data is not None else shape",
  "def shape(self):\n        \"\"\"Data shape (last dimension indicates number of color channels)\"\"\"\n        return self._shape",
  "def format(self):\n        \"\"\"The texture format (color channels).\"\"\"\n        return self._format",
  "def internalformat(self):\n        \"\"\"The texture internalformat.\"\"\"\n        return self._internalformat",
  "def wrapping(self):\n        \"\"\"Texture wrapping mode\"\"\"\n        value = self._wrapping\n        return value[0] if all([v == value[0] for v in value]) else value",
  "def wrapping(self, value):\n        # Convert\n        if isinstance(value, int) or isinstance(value, str):\n            value = (value,) * self._ndim\n        elif isinstance(value, (tuple, list)):\n            if len(value) != self._ndim:\n                raise ValueError('Texture wrapping needs 1 or %i values' %\n                                 self._ndim)\n        else:\n            raise ValueError('Invalid value for wrapping: %r' % value)\n        # Check and set\n        valid = 'repeat', 'clamp_to_edge', 'mirrored_repeat'\n        value = tuple([check_enum(value[i], 'tex wrapping', valid)\n                       for i in range(self._ndim)])\n        self._wrapping = value\n        self._glir.command('WRAPPING', self._id, value)",
  "def interpolation(self):\n        \"\"\"Texture interpolation for minification and magnification.\"\"\"\n        value = self._interpolation\n        return value[0] if value[0] == value[1] else value",
  "def interpolation(self, value):\n        # Convert\n        if isinstance(value, int) or isinstance(value, str):\n            value = (value,) * 2\n        elif isinstance(value, (tuple, list)):\n            if len(value) != 2:\n                raise ValueError('Texture interpolation needs 1 or 2 values')\n        else:\n            raise ValueError('Invalid value for interpolation: %r' % value)\n        # Check and set\n        valid = 'nearest', 'linear'\n        value = (check_enum(value[0], 'tex interpolation', valid),\n                 check_enum(value[1], 'tex interpolation', valid))\n        self._interpolation = value\n        self._glir.command('INTERPOLATION', self._id, *value)",
  "def resize(self, shape, format=None, internalformat=None):\n        \"\"\"Set the texture size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New texture shape in zyx order. Optionally, an extra dimention\n            may be specified to indicate the number of color channels.\n        format : str | enum | None\n            The format of the texture: 'luminance', 'alpha',\n            'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n            is chosen automatically based on the number of channels.\n            When the data has one channel, 'luminance' is assumed.\n        internalformat : str | enum | None\n            The internal (storage) format of the texture: 'luminance',\n            'alpha', 'r8', 'r16', 'r16f', 'r32f'; 'luminance_alpha',\n            'rg8', 'rg16', 'rg16f', 'rg32f'; 'rgb', 'rgb8', 'rgb16',\n            'rgb16f', 'rgb32f'; 'rgba', 'rgba8', 'rgba16', 'rgba16f',\n            'rgba32f'.  If None, the internalformat is chosen\n            automatically based on the number of channels.  This is a\n            hint which may be ignored by the OpenGL implementation.\n        \"\"\"\n        return self._resize(shape, format, internalformat)",
  "def _check_format_change(self, format, num_channels):\n        # Determine format\n        if format is None:\n            format = self._formats[num_channels]\n            # Keep current format if channels match\n            if self._format and \\\n                    self._inv_formats[self._format] == self._inv_formats[format]:\n                format = self._format\n        else:\n            format = check_enum(format)\n\n        if format not in self._inv_formats:\n            raise ValueError('Invalid texture format: %r.' % format)\n        elif num_channels != self._inv_formats[format]:\n            raise ValueError('Format does not match with given shape. '\n                             '(format expects %d elements, data has %d)' %\n                             (self._inv_formats[format], num_channels))\n        return format",
  "def _check_internalformat_change(self, internalformat, num_channels):\n        if internalformat is None:\n            # Keep current internalformat if channels match\n            if self._internalformat and \\\n               self._inv_internalformats[self._internalformat] == num_channels:\n                internalformat = self._internalformat\n        else:\n            internalformat = check_enum(internalformat)\n\n        if internalformat is None:\n            pass\n        elif internalformat not in self._inv_internalformats:\n            raise ValueError(\n                'Invalid texture internalformat: %r. Allowed formats: %r'\n                % (internalformat, self._inv_internalformats)\n            )\n        elif num_channels != self._inv_internalformats[internalformat]:\n            raise ValueError('Internalformat does not match with given shape.')\n        return internalformat",
  "def _resize(self, shape, format=None, internalformat=None):\n        \"\"\"Internal method for resize.\"\"\"\n        shape = self._normalize_shape(shape)\n\n        # Check\n        if not self._resizable:\n            raise RuntimeError(\"Texture is not resizable\")\n\n        format = self._check_format_change(format, shape[-1])\n        internalformat = self._check_internalformat_change(internalformat, shape[-1])\n\n        # Store and send GLIR command\n        self._shape = shape\n        self._format = format\n        self._internalformat = internalformat\n        self._glir.command('SIZE', self._id, self._shape, self._format,\n                           self._internalformat)",
  "def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitly resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        return self._set_data(data, offset, copy)",
  "def _set_data(self, data, offset=None, copy=False):\n        \"\"\"Internal method for set_data.\"\"\"\n        # Copy if needed, check/normalize shape\n        data = np.array(data, copy=copy)\n        data = self._normalize_shape(data)\n\n        # Maybe resize to purge DATA commands?\n        if offset is None:\n            self._resize(data.shape)\n        elif all([i == 0 for i in offset]) and data.shape == self._shape:\n            self._resize(data.shape)\n\n        # Convert offset to something usable\n        offset = offset or tuple([0 for i in range(self._ndim)])\n        assert len(offset) == self._ndim\n\n        # Check if data fits\n        for i in range(len(data.shape)-1):\n            if offset[i] + data.shape[i] > self._shape[i]:\n                raise ValueError(\"Data is too large\")\n\n        # Send GLIR command\n        self._glir.command('DATA', self._id, offset, data)",
  "def __setitem__(self, key, data):\n        \"\"\"x.__getitem__(y) <==> x[y]\"\"\"\n        # Make sure key is a tuple\n        if isinstance(key, (int, slice)) or key == Ellipsis:\n            key = (key,)\n\n        # Default is to access the whole texture\n        shape = self._shape\n        slices = [slice(0, shape[i]) for i in range(len(shape))]\n\n        # Check last key/Ellipsis to decide on the order\n        keys = key[::+1]\n        dims = range(0, len(key))\n        if key[0] == Ellipsis:\n            keys = key[::-1]\n            dims = range(len(self._shape) - 1,\n                         len(self._shape) - 1 - len(keys), -1)\n\n        # Find exact range for each key\n        for k, dim in zip(keys, dims):\n            size = self._shape[dim]\n            if isinstance(k, int):\n                if k < 0:\n                    k += size\n                if k < 0 or k > size:\n                    raise IndexError(\"Texture assignment index out of range\")\n                start, stop = k, k + 1\n                slices[dim] = slice(start, stop, 1)\n            elif isinstance(k, slice):\n                start, stop, step = k.indices(size)\n                if step != 1:\n                    raise IndexError(\"Cannot access non-contiguous data\")\n                if stop < start:\n                    start, stop = stop, start\n                slices[dim] = slice(start, stop, step)\n            elif k == Ellipsis:\n                pass\n            else:\n                raise TypeError(\"Texture indices must be integers\")\n\n        offset = tuple([s.start for s in slices])[:self._ndim]\n        shape = tuple([s.stop - s.start for s in slices])\n        size = np.prod(shape) if len(shape) > 0 else 1\n\n        # Make sure data is an array\n        if not isinstance(data, np.ndarray):\n            data = np.array(data, copy=False)\n        # Make sure data is big enough\n        if data.shape != shape:\n            data = np.resize(data, shape)\n\n        # Set data (deferred)\n        self._set_data(data=data, offset=offset, copy=False)",
  "def __repr__(self):\n        return \"<%s shape=%r format=%r at 0x%x>\" % (\n            self.__class__.__name__, self._shape, self._format, id(self))",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)",
  "def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[0]",
  "def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler1D'",
  "def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler1D'",
  "def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture1D'",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)",
  "def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[0]",
  "def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[1]",
  "def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler2D'",
  "def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler2D'",
  "def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture2D'",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)",
  "def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[2]",
  "def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[1]",
  "def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._shape[0]",
  "def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'sampler3D'",
  "def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'sampler3D'",
  "def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'texture3D'",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        BaseTexture.__init__(self, data, format, resizable, interpolation,\n                             wrapping, shape, internalformat, resizeable)\n        if self._shape[0] != 6:\n            raise ValueError(\"Texture cube require arrays first dimension to be 6 :\"\n                             \" {} was given.\".format(self._shape[0]))",
  "def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._shape[1]",
  "def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._shape[2]",
  "def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._shape[0]",
  "def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        return 'uniform', 'samplerCube'",
  "def glsl_sampler_type(self):\n        \"\"\"GLSL type of the sampler.\"\"\"\n        return 'samplerCube'",
  "def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return 'textureCube'",
  "def __init__(self, data=None, format=None, resizable=True,\n                 interpolation=None, wrapping=None, shape=None,\n                 internalformat=None, resizeable=None):\n        from ..visuals.shaders import Function\n\n        self._set_emulated_shape(data)\n        Texture2D.__init__(self, self._normalize_emulated_shape(data),\n                           format, resizable, interpolation, wrapping,\n                           shape, internalformat, resizeable)\n        if self.interpolation == 'nearest':\n            self._glsl_sample = Function(self.__class__._glsl_sample_nearest)\n        else:\n            self._glsl_sample = Function(self.__class__._glsl_sample_linear)\n        self._update_variables()",
  "def _set_emulated_shape(self, data_or_shape):\n        if isinstance(data_or_shape, np.ndarray):\n            self._emulated_shape = data_or_shape.shape\n        else:\n            assert isinstance(data_or_shape, tuple)\n            self._emulated_shape = tuple(data_or_shape)\n\n        depth, width = self._emulated_shape[0], self._emulated_shape[1]\n        self._r = TextureEmulated3D._gl_max_texture_size // width\n        self._c = depth // self._r\n        if math.fmod(depth, self._r):\n            self._c += 1",
  "def _normalize_emulated_shape(self, data_or_shape):\n        if isinstance(data_or_shape, np.ndarray):\n            new_shape = self._normalize_emulated_shape(data_or_shape.shape)\n            new_data = np.empty(new_shape, dtype=data_or_shape.dtype)\n            for j in range(self._c):\n                for i in range(self._r):\n                    i0, i1 = i * self.width, (i+1) * self.width\n                    j0, j1 = j * self.height, (j+1) * self.height\n                    k = j * self._r + i\n                    if k >= self.depth:\n                        break\n                    new_data[j0:j1, i0:i1] = data_or_shape[k]\n\n            return new_data\n\n        assert isinstance(data_or_shape, tuple)\n        return (self._c * self.height, self._r * self.width) + \\\n            data_or_shape[3:]",
  "def _update_variables(self):\n        self._glsl_sample['shape'] = self.shape[:3][::-1]\n        # On Windows with Python 2.7, self._c can end up being a long\n        # integer because Numpy array shapes return long integers. This\n        # causes issues when setting the gloo variables since these are\n        # expected to be native ints, so we cast the integers to ints\n        # to avoid this.\n        # Newer GLSL compilers do not implicitly cast types so these integers\n        # must be converted to floats lastly\n        self._glsl_sample['c'] = float(int(self._c))\n        self._glsl_sample['r'] = float(int(self._r))",
  "def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitely resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        self._set_emulated_shape(data)\n        Texture2D.set_data(self, self._normalize_emulated_shape(data),\n                           offset, copy)\n        self._update_variables()",
  "def resize(self, shape, format=None, internalformat=None):\n        \"\"\"Set the texture size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New texture shape in zyx order. Optionally, an extra dimention\n            may be specified to indicate the number of color channels.\n        format : str | enum | None\n            The format of the texture: 'luminance', 'alpha',\n            'luminance_alpha', 'rgb', or 'rgba'. If not given the format\n            is chosen automatically based on the number of channels.\n            When the data has one channel, 'luminance' is assumed.\n        internalformat : str | enum | None\n            The internal (storage) format of the texture: 'luminance',\n            'alpha', 'r8', 'r16', 'r16f', 'r32f'; 'luminance_alpha',\n            'rg8', 'rg16', 'rg16f', 'rg32f'; 'rgb', 'rgb8', 'rgb16',\n            'rgb16f', 'rgb32f'; 'rgba', 'rgba8', 'rgba16', 'rgba16f',\n            'rgba32f'.  If None, the internalformat is chosen\n            automatically based on the number of channels.  This is a\n            hint which may be ignored by the OpenGL implementation.\n        \"\"\"\n        self._set_emulated_shape(shape)\n        Texture2D.resize(self, self._normalize_emulated_shape(shape),\n                         format, internalformat)\n        self._update_variables()",
  "def shape(self):\n        \"\"\"Data shape (last dimension indicates number of color channels)\"\"\"\n        return self._emulated_shape",
  "def width(self):\n        \"\"\"Texture width\"\"\"\n        return self._emulated_shape[2]",
  "def height(self):\n        \"\"\"Texture height\"\"\"\n        return self._emulated_shape[1]",
  "def depth(self):\n        \"\"\"Texture depth\"\"\"\n        return self._emulated_shape[0]",
  "def glsl_sample(self):\n        \"\"\"GLSL function that samples the texture.\"\"\"\n        return self._glsl_sample",
  "def __init__(self, shape=(1024, 1024), dtype=np.float32):\n        shape = np.array(shape, int)\n        assert shape.ndim == 1 and shape.size == 2\n        shape = tuple(2 ** (np.log2(shape) + 0.5).astype(int)) + (3,)\n        self._atlas_nodes = [(0, 0, shape[1])]\n        data = np.zeros(shape, dtype)\n        super(TextureAtlas, self).__init__(data, interpolation='linear',\n                                           wrapping='clamp_to_edge')",
  "def get_free_region(self, width, height):\n        \"\"\"Get a free region of given size and allocate it\n\n        Parameters\n        ----------\n        width : int\n            Width of region to allocate\n        height : int\n            Height of region to allocate\n\n        Returns\n        -------\n        bounds : tuple | None\n            A newly allocated region as (x, y, w, h) or None\n            (if failed).\n        \"\"\"\n        best_height = best_width = np.inf\n        best_index = -1\n        for i in range(len(self._atlas_nodes)):\n            y = self._fit(i, width, height)\n            if y >= 0:\n                node = self._atlas_nodes[i]\n                if (y+height < best_height or\n                        (y+height == best_height and node[2] < best_width)):\n                    best_height = y+height\n                    best_index = i\n                    best_width = node[2]\n                    region = node[0], y, width, height\n        if best_index == -1:\n            return None\n\n        node = region[0], region[1] + height, width\n        self._atlas_nodes.insert(best_index, node)\n        i = best_index+1\n        while i < len(self._atlas_nodes):\n            node = self._atlas_nodes[i]\n            prev_node = self._atlas_nodes[i-1]\n            if node[0] < prev_node[0]+prev_node[2]:\n                shrink = prev_node[0]+prev_node[2] - node[0]\n                x, y, w = self._atlas_nodes[i]\n                self._atlas_nodes[i] = x+shrink, y, w-shrink\n                if self._atlas_nodes[i][2] <= 0:\n                    del self._atlas_nodes[i]\n                    i -= 1\n                else:\n                    break\n            else:\n                break\n            i += 1\n\n        # Merge nodes\n        i = 0\n        while i < len(self._atlas_nodes)-1:\n            node = self._atlas_nodes[i]\n            next_node = self._atlas_nodes[i+1]\n            if node[1] == next_node[1]:\n                self._atlas_nodes[i] = node[0], node[1], node[2]+next_node[2]\n                del self._atlas_nodes[i+1]\n            else:\n                i += 1\n\n        return region",
  "def _fit(self, index, width, height):\n        \"\"\"Test if region (width, height) fit into self._atlas_nodes[index]\"\"\"\n        node = self._atlas_nodes[index]\n        x, y = node[0], node[1]\n        width_left = width\n        if x+width > self._shape[1]:\n            return -1\n        i = index\n        while width_left > 0:\n            node = self._atlas_nodes[i]\n            y = max(y, node[1])\n            if y+height > self._shape[0]:\n                return -1\n            width_left -= node[2]\n            i += 1\n        return y",
  "class Buffer(GLObject):\n    \"\"\"Generic GPU buffer.\n\n    A generic buffer is an interface used to upload data to a GPU array buffer\n    (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER). It keeps track of\n    buffer size but does not have any CPU storage. You can consider it as\n    write-only.\n\n    The `set_data` is a deferred operation: you can call it even if an OpenGL\n    context is not available. The `update` function is responsible to upload\n    pending data to GPU memory and requires an active GL context.\n\n    The Buffer class only deals with data in terms of bytes; it is not\n    aware of data type or element size.\n\n    Parameters\n    ----------\n    data : ndarray | None\n        Buffer data.\n    nbytes : int | None\n        Buffer byte size.\n    \"\"\"\n\n    def __init__(self, data=None, nbytes=None):\n        GLObject.__init__(self)\n        self._views = weakref.WeakSet()  # Views on this buffer\n        self._valid = True  # To invalidate buffer views\n        self._nbytes = 0  # Bytesize in bytes, set in resize_bytes()\n\n        # Set data\n        if data is not None:\n            if nbytes is not None:\n                raise ValueError(\"Cannot specify both data and nbytes.\")\n            self.set_data(data, copy=False)\n        elif nbytes is not None:\n            self.resize_bytes(nbytes)\n\n    @property\n    def nbytes(self):\n        \"\"\"Buffer size in bytes\"\"\"\n        return self._nbytes\n\n    def set_subdata(self, data, offset=0, copy=False):\n        \"\"\"Set a sub-region of the buffer (deferred operation).\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int\n            Offset in buffer where to start copying data (in bytes)\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        \"\"\"\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if offset < 0:\n            raise ValueError(\"Offset must be positive\")\n        elif (offset + nbytes) > self._nbytes:\n            raise ValueError(\"Data does not fit into buffer\")\n\n        # If the whole buffer is to be written, we clear any pending data\n        # (because they will be overwritten anyway)\n        if nbytes == self._nbytes and offset == 0:\n            self._glir.command('SIZE', self._id, nbytes)\n        self._glir.command('DATA', self._id, offset, data)\n\n    def set_data(self, data, copy=False):\n        \"\"\"Set data in the buffer (deferred operation).\n\n        This completely resets the size and contents of the buffer.\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        \"\"\"\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if nbytes != self._nbytes:\n            self.resize_bytes(nbytes)\n        else:\n            # Use SIZE to discard any previous data setting\n            self._glir.command('SIZE', self._id, nbytes)\n\n        if nbytes:  # Only set data if there *is* data\n            self._glir.command('DATA', self._id, 0, data)\n\n    def resize_bytes(self, size):\n        \"\"\"Resize this buffer (deferred operation).\n\n        Parameters\n        ----------\n        size : int\n            New buffer size in bytes.\n        \"\"\"\n        self._nbytes = size\n        self._glir.command('SIZE', self._id, size)\n        # Invalidate any view on this buffer\n        for view in self._views:\n            view._valid = False\n        self._views = weakref.WeakSet()",
  "class DataBuffer(Buffer):\n    \"\"\"GPU data buffer that is aware of data type and elements size\n\n    Parameters\n    ----------\n    data : ndarray | None\n        Buffer data.\n    \"\"\"\n\n    def __init__(self, data=None):\n        self._size = 0  # number of elements in buffer, set in resize_bytes()\n        self._dtype = None\n        self._stride = 0\n        self._itemsize = 0\n        self._last_dim = None\n        Buffer.__init__(self, data)\n\n    def _prepare_data(self, data):\n        # Can be overrriden by subclasses\n        if not isinstance(data, np.ndarray):\n            raise TypeError(\"DataBuffer data must be numpy array.\")\n        return data\n\n    def set_subdata(self, data, offset=0, copy=False, **kwargs):\n        \"\"\"Set a sub-region of the buffer (deferred operation).\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int\n            Offset in buffer where to start copying data (i.e. index of\n            starting element).\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        **kwargs : dict\n            Additional keyword arguments.\n\n        \"\"\"\n        data = self._prepare_data(data, **kwargs)\n        offset = offset * self.itemsize\n        Buffer.set_subdata(self, data=data, offset=offset, copy=copy)\n\n    def set_data(self, data, copy=False, **kwargs):\n        \"\"\"Set data (deferred operation)\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        **kwargs : dict\n            Additional arguments.\n        \"\"\"\n        data = self._prepare_data(data, **kwargs)\n        self._dtype = data.dtype\n        # This works around some strange NumPy bug where a float32 array\n        # of shape (155407, 1) was said to have strides\n        # (4, 9223372036854775807), which is crazy\n        self._stride = data.strides[-1]\n        self._itemsize = self._dtype.itemsize\n        Buffer.set_data(self, data=data, copy=copy)\n\n    @property\n    def dtype(self):\n        \"\"\"Buffer dtype\"\"\"\n        return self._dtype\n\n    @property\n    def offset(self):\n        \"\"\"Buffer offset (in bytes) relative to base\"\"\"\n        return 0\n\n    @property\n    def stride(self):\n        \"\"\"Stride of data in memory\"\"\"\n        return self._stride\n\n    @property\n    def size(self):\n        \"\"\"Number of elements in the buffer\"\"\"\n        return self._size\n\n    @property\n    def itemsize(self):\n        \"\"\"The total number of bytes required to store the array data\"\"\"\n        return self._itemsize\n\n    @property\n    def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        if self.dtype is None:\n            return None\n        dtshape = self.dtype[0].shape\n        n = dtshape[0] if dtshape else 1\n        if n > 1:\n            dtype = 'vec%d' % n\n        else:\n            dtype = 'float' if 'f' in self.dtype[0].base.kind else 'int'\n        return 'attribute', dtype\n\n    def resize_bytes(self, size):\n        \"\"\"Resize the buffer (in-place, deferred operation)\n\n        Parameters\n        ----------\n        size : integer\n            New buffer size in bytes\n\n        Notes\n        -----\n        This clears any pending operations.\n        \"\"\"\n        Buffer.resize_bytes(self, size)\n        self._size = size // self.itemsize\n\n    def __getitem__(self, key):\n        \"\"\"Create a view on this buffer.\"\"\"\n        view = DataBufferView(self, key)\n        self._views.add(view)\n        return view\n\n    def __setitem__(self, key, data):\n        \"\"\"Set data (deferred operation)\"\"\"\n        # Setting a whole field of the buffer: only allowed if we have CPU\n        # storage. Note this case (key is string) only happen with base buffer\n        if isinstance(key, str):\n            raise ValueError(\"Cannot set non-contiguous data on buffer\")\n\n        # Setting one or several elements\n        elif isinstance(key, int):\n            if key < 0:\n                key += self.size\n            if key < 0 or key > self.size:\n                raise IndexError(\"Buffer assignment index out of range\")\n            start, stop, step = key, key + 1, 1\n        elif isinstance(key, slice):\n            start, stop, step = key.indices(self.size)\n            if stop < start:\n                start, stop = stop, start\n        elif key == Ellipsis:\n            start, stop, step = 0, self.size, 1\n        else:\n            raise TypeError(\"Buffer indices must be integers or strings\")\n\n        # Contiguous update?\n        if step != 1:\n            raise ValueError(\"Cannot set non-contiguous data on buffer\")\n\n        # Make sure data is an array\n        if not isinstance(data, np.ndarray):\n            data = np.array(data, dtype=self.dtype, copy=False)\n\n        # Make sure data is big enough\n        if data.size < stop - start:\n            data = np.resize(data, stop - start)\n        elif data.size > stop - start:\n            raise ValueError('Data too big to fit GPU data '\n                             '(%d > %d-%d).' % (data.size, stop, start))\n\n        # Set data\n        offset = start\n        self.set_subdata(data=data, offset=offset, copy=True)\n\n    def __repr__(self):\n        return (\"<%s size=%s last_dim=%s>\" %\n                (self.__class__.__name__, self.size, self._last_dim))",
  "class DataBufferView(DataBuffer):\n    \"\"\"View on a sub-region of a DataBuffer.\n\n    Parameters\n    ----------\n    base : DataBuffer\n        The buffer accessed by this view.\n    key : str, int, slice, or Ellpsis\n        The index into the base buffer that defines a sub-region of the buffer\n        to view. String arguments select a single field from multi-field\n        dtypes, and other allowed types select a subset of rows.\n\n    Notes\n    -----\n    It is generally not necessary to instantiate this class manually; use\n    ``base_buffer[key]`` instead.\n    \"\"\"\n\n    # Note that this class is a bit evil: it is a subclass of GLObject,\n    # Buffer and DataBuffer, but any of these __init__'s are not called ...\n\n    def __init__(self, base, key):\n        # Note how this never runs the super's __init__,\n        # all attributes must thus be set here ...\n\n        self._base = base\n        self._key = key\n        self._stride = base.stride\n\n        if isinstance(key, str):\n            self._dtype = base.dtype[key]\n            self._offset = base.dtype.fields[key][1]\n            self._nbytes = base.size * self._dtype.itemsize\n            self._size = base.size\n            self._itemsize = self._dtype.itemsize\n            return\n\n        if isinstance(key, int):\n            if key < 0:\n                key += base.size\n            if key < 0 or key > base.size:\n                raise IndexError(\"Buffer assignment index out of range\")\n            start, stop, step = key, key + 1, 1\n        elif isinstance(key, slice):\n            start, stop, step = key.indices(base.size)\n            if stop < start:\n                start, stop = stop, start\n        elif key == Ellipsis:\n            start, stop, step = 0, base.size, 1\n        else:\n            raise TypeError(\"Buffer indices must be integers or strings\")\n\n        if step != 1:\n            raise ValueError(\"Cannot access non-contiguous data\")\n\n        self._itemsize = base.itemsize\n        self._offset = start * self.itemsize\n        self._size = stop - start\n        self._dtype = base.dtype\n        self._nbytes = self.size * self.itemsize\n\n    @property\n    def glir(self):\n        return self._base.glir\n\n    @property\n    def id(self):\n        return self._base.id\n\n    @property\n    def _last_dim(self):\n        return self._base._last_dim\n\n    def set_subdata(self, data, offset=0, copy=False, **kwargs):\n        raise RuntimeError(\"Cannot set data on buffer view.\")\n\n    def set_data(self, data, copy=False, **kwargs):\n        raise RuntimeError(\"Cannot set data on buffer view.\")\n\n    @property\n    def offset(self):\n        \"\"\"Buffer offset (in bytes) relative to base\"\"\"\n        return self._offset\n\n    @property\n    def base(self):\n        \"\"\"Buffer base if this buffer is a view on another buffer.\"\"\"\n        return self._base\n\n    def resize_bytes(self, size):\n        raise RuntimeError(\"Cannot resize buffer view.\")\n\n    def __getitem__(self, key):\n        raise RuntimeError(\"Can only access data from a base buffer\")\n\n    def __setitem__(self, key, data):\n        raise RuntimeError(\"Cannot set data on Buffer view\")\n\n    def __repr__(self):\n        return (\"<DataBufferView on %r at offset=%d size=%d>\" %\n                (self.base, self.offset, self.size))",
  "class VertexBuffer(DataBuffer):\n    \"\"\"Buffer for vertex attribute data\n\n    Parameters\n    ----------\n    data : ndarray\n        Buffer data (optional)\n    \"\"\"\n\n    _GLIR_TYPE = 'VertexBuffer'\n\n    def _prepare_data(self, data, convert=False):\n        # Build a structured view of the data if:\n        #  -> it is not already a structured array\n        #  -> shape if 1-D or last dimension is 1,2,3 or 4\n        if isinstance(data, list):\n            data = np.array(data, dtype=np.float32)\n        if not isinstance(data, np.ndarray):\n            raise ValueError('Data must be a ndarray (got %s)' % type(data))\n        if data.dtype.isbuiltin:\n            if convert is True:\n                data = data.astype(np.float32)\n            if data.dtype in (np.float64, np.int64):\n                raise TypeError('data must be 32-bit not %s'\n                                % data.dtype)\n            c = data.shape[-1] if data.ndim > 1 else 1\n            if c in [2, 3, 4]:\n                if not data.flags['C_CONTIGUOUS']:\n                    logger.warning('Copying discontiguous data for struct '\n                                   'dtype:\\n%s' % _last_stack_str())\n                    data = data.copy()\n            else:\n                c = 1\n            if self._last_dim and c != self._last_dim:\n                raise ValueError('Last dimension should be %s not %s'\n                                 % (self._last_dim, c))\n            dtype_def = ('f0', data.dtype.base)\n            if c != 1:\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                dtype_def += (c,)\n            data = data.view(dtype=[dtype_def])\n            self._last_dim = c\n        return data",
  "def _last_stack_str():\n    \"\"\"Print stack trace from call that didn't originate from here\"\"\"\n    stack = extract_stack()\n    for s in stack[::-1]:\n        if op.join('vispy', 'gloo', 'buffer.py') not in __file__:\n            break\n    return format_list([s])[0]",
  "class IndexBuffer(DataBuffer):\n    \"\"\"Buffer for index data\n\n    Parameters\n    ----------\n    data : ndarray | None\n        Buffer data.\n    \"\"\"\n\n    _GLIR_TYPE = 'IndexBuffer'\n\n    def __init__(self, data=None):\n        DataBuffer.__init__(self, data)\n        self._last_dim = 1\n\n    def _prepare_data(self, data, convert=False):\n        if isinstance(data, list):\n            data = np.array(data, dtype=np.uint32)\n        if not isinstance(data, np.ndarray):\n            raise ValueError('Data must be a ndarray (got %s)' % type(data))\n        if not data.dtype.isbuiltin:\n            raise TypeError(\"Element buffer dtype cannot be structured\")\n        else:\n            if convert:\n                if data.dtype is not np.uint32:\n                    data = data.astype(np.uint32)\n            else:\n                if data.dtype not in [np.uint32, np.uint16, np.uint8]:\n                    raise TypeError(\"Invalid dtype for IndexBuffer: %r\" %\n                                    data.dtype)\n        return data",
  "def __init__(self, data=None, nbytes=None):\n        GLObject.__init__(self)\n        self._views = weakref.WeakSet()  # Views on this buffer\n        self._valid = True  # To invalidate buffer views\n        self._nbytes = 0  # Bytesize in bytes, set in resize_bytes()\n\n        # Set data\n        if data is not None:\n            if nbytes is not None:\n                raise ValueError(\"Cannot specify both data and nbytes.\")\n            self.set_data(data, copy=False)\n        elif nbytes is not None:\n            self.resize_bytes(nbytes)",
  "def nbytes(self):\n        \"\"\"Buffer size in bytes\"\"\"\n        return self._nbytes",
  "def set_subdata(self, data, offset=0, copy=False):\n        \"\"\"Set a sub-region of the buffer (deferred operation).\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int\n            Offset in buffer where to start copying data (in bytes)\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        \"\"\"\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if offset < 0:\n            raise ValueError(\"Offset must be positive\")\n        elif (offset + nbytes) > self._nbytes:\n            raise ValueError(\"Data does not fit into buffer\")\n\n        # If the whole buffer is to be written, we clear any pending data\n        # (because they will be overwritten anyway)\n        if nbytes == self._nbytes and offset == 0:\n            self._glir.command('SIZE', self._id, nbytes)\n        self._glir.command('DATA', self._id, offset, data)",
  "def set_data(self, data, copy=False):\n        \"\"\"Set data in the buffer (deferred operation).\n\n        This completely resets the size and contents of the buffer.\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        \"\"\"\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if nbytes != self._nbytes:\n            self.resize_bytes(nbytes)\n        else:\n            # Use SIZE to discard any previous data setting\n            self._glir.command('SIZE', self._id, nbytes)\n\n        if nbytes:  # Only set data if there *is* data\n            self._glir.command('DATA', self._id, 0, data)",
  "def resize_bytes(self, size):\n        \"\"\"Resize this buffer (deferred operation).\n\n        Parameters\n        ----------\n        size : int\n            New buffer size in bytes.\n        \"\"\"\n        self._nbytes = size\n        self._glir.command('SIZE', self._id, size)\n        # Invalidate any view on this buffer\n        for view in self._views:\n            view._valid = False\n        self._views = weakref.WeakSet()",
  "def __init__(self, data=None):\n        self._size = 0  # number of elements in buffer, set in resize_bytes()\n        self._dtype = None\n        self._stride = 0\n        self._itemsize = 0\n        self._last_dim = None\n        Buffer.__init__(self, data)",
  "def _prepare_data(self, data):\n        # Can be overrriden by subclasses\n        if not isinstance(data, np.ndarray):\n            raise TypeError(\"DataBuffer data must be numpy array.\")\n        return data",
  "def set_subdata(self, data, offset=0, copy=False, **kwargs):\n        \"\"\"Set a sub-region of the buffer (deferred operation).\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int\n            Offset in buffer where to start copying data (i.e. index of\n            starting element).\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        **kwargs : dict\n            Additional keyword arguments.\n\n        \"\"\"\n        data = self._prepare_data(data, **kwargs)\n        offset = offset * self.itemsize\n        Buffer.set_subdata(self, data=data, offset=offset, copy=copy)",
  "def set_data(self, data, copy=False, **kwargs):\n        \"\"\"Set data (deferred operation)\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory.\n            Asking explicitly for a copy will prevent this behavior.\n        **kwargs : dict\n            Additional arguments.\n        \"\"\"\n        data = self._prepare_data(data, **kwargs)\n        self._dtype = data.dtype\n        # This works around some strange NumPy bug where a float32 array\n        # of shape (155407, 1) was said to have strides\n        # (4, 9223372036854775807), which is crazy\n        self._stride = data.strides[-1]\n        self._itemsize = self._dtype.itemsize\n        Buffer.set_data(self, data=data, copy=copy)",
  "def dtype(self):\n        \"\"\"Buffer dtype\"\"\"\n        return self._dtype",
  "def offset(self):\n        \"\"\"Buffer offset (in bytes) relative to base\"\"\"\n        return 0",
  "def stride(self):\n        \"\"\"Stride of data in memory\"\"\"\n        return self._stride",
  "def size(self):\n        \"\"\"Number of elements in the buffer\"\"\"\n        return self._size",
  "def itemsize(self):\n        \"\"\"The total number of bytes required to store the array data\"\"\"\n        return self._itemsize",
  "def glsl_type(self):\n        \"\"\"GLSL declaration strings required for a variable to hold this data.\"\"\"\n        if self.dtype is None:\n            return None\n        dtshape = self.dtype[0].shape\n        n = dtshape[0] if dtshape else 1\n        if n > 1:\n            dtype = 'vec%d' % n\n        else:\n            dtype = 'float' if 'f' in self.dtype[0].base.kind else 'int'\n        return 'attribute', dtype",
  "def resize_bytes(self, size):\n        \"\"\"Resize the buffer (in-place, deferred operation)\n\n        Parameters\n        ----------\n        size : integer\n            New buffer size in bytes\n\n        Notes\n        -----\n        This clears any pending operations.\n        \"\"\"\n        Buffer.resize_bytes(self, size)\n        self._size = size // self.itemsize",
  "def __getitem__(self, key):\n        \"\"\"Create a view on this buffer.\"\"\"\n        view = DataBufferView(self, key)\n        self._views.add(view)\n        return view",
  "def __setitem__(self, key, data):\n        \"\"\"Set data (deferred operation)\"\"\"\n        # Setting a whole field of the buffer: only allowed if we have CPU\n        # storage. Note this case (key is string) only happen with base buffer\n        if isinstance(key, str):\n            raise ValueError(\"Cannot set non-contiguous data on buffer\")\n\n        # Setting one or several elements\n        elif isinstance(key, int):\n            if key < 0:\n                key += self.size\n            if key < 0 or key > self.size:\n                raise IndexError(\"Buffer assignment index out of range\")\n            start, stop, step = key, key + 1, 1\n        elif isinstance(key, slice):\n            start, stop, step = key.indices(self.size)\n            if stop < start:\n                start, stop = stop, start\n        elif key == Ellipsis:\n            start, stop, step = 0, self.size, 1\n        else:\n            raise TypeError(\"Buffer indices must be integers or strings\")\n\n        # Contiguous update?\n        if step != 1:\n            raise ValueError(\"Cannot set non-contiguous data on buffer\")\n\n        # Make sure data is an array\n        if not isinstance(data, np.ndarray):\n            data = np.array(data, dtype=self.dtype, copy=False)\n\n        # Make sure data is big enough\n        if data.size < stop - start:\n            data = np.resize(data, stop - start)\n        elif data.size > stop - start:\n            raise ValueError('Data too big to fit GPU data '\n                             '(%d > %d-%d).' % (data.size, stop, start))\n\n        # Set data\n        offset = start\n        self.set_subdata(data=data, offset=offset, copy=True)",
  "def __repr__(self):\n        return (\"<%s size=%s last_dim=%s>\" %\n                (self.__class__.__name__, self.size, self._last_dim))",
  "def __init__(self, base, key):\n        # Note how this never runs the super's __init__,\n        # all attributes must thus be set here ...\n\n        self._base = base\n        self._key = key\n        self._stride = base.stride\n\n        if isinstance(key, str):\n            self._dtype = base.dtype[key]\n            self._offset = base.dtype.fields[key][1]\n            self._nbytes = base.size * self._dtype.itemsize\n            self._size = base.size\n            self._itemsize = self._dtype.itemsize\n            return\n\n        if isinstance(key, int):\n            if key < 0:\n                key += base.size\n            if key < 0 or key > base.size:\n                raise IndexError(\"Buffer assignment index out of range\")\n            start, stop, step = key, key + 1, 1\n        elif isinstance(key, slice):\n            start, stop, step = key.indices(base.size)\n            if stop < start:\n                start, stop = stop, start\n        elif key == Ellipsis:\n            start, stop, step = 0, base.size, 1\n        else:\n            raise TypeError(\"Buffer indices must be integers or strings\")\n\n        if step != 1:\n            raise ValueError(\"Cannot access non-contiguous data\")\n\n        self._itemsize = base.itemsize\n        self._offset = start * self.itemsize\n        self._size = stop - start\n        self._dtype = base.dtype\n        self._nbytes = self.size * self.itemsize",
  "def glir(self):\n        return self._base.glir",
  "def id(self):\n        return self._base.id",
  "def _last_dim(self):\n        return self._base._last_dim",
  "def set_subdata(self, data, offset=0, copy=False, **kwargs):\n        raise RuntimeError(\"Cannot set data on buffer view.\")",
  "def set_data(self, data, copy=False, **kwargs):\n        raise RuntimeError(\"Cannot set data on buffer view.\")",
  "def offset(self):\n        \"\"\"Buffer offset (in bytes) relative to base\"\"\"\n        return self._offset",
  "def base(self):\n        \"\"\"Buffer base if this buffer is a view on another buffer.\"\"\"\n        return self._base",
  "def resize_bytes(self, size):\n        raise RuntimeError(\"Cannot resize buffer view.\")",
  "def __getitem__(self, key):\n        raise RuntimeError(\"Can only access data from a base buffer\")",
  "def __setitem__(self, key, data):\n        raise RuntimeError(\"Cannot set data on Buffer view\")",
  "def __repr__(self):\n        return (\"<DataBufferView on %r at offset=%d size=%d>\" %\n                (self.base, self.offset, self.size))",
  "def _prepare_data(self, data, convert=False):\n        # Build a structured view of the data if:\n        #  -> it is not already a structured array\n        #  -> shape if 1-D or last dimension is 1,2,3 or 4\n        if isinstance(data, list):\n            data = np.array(data, dtype=np.float32)\n        if not isinstance(data, np.ndarray):\n            raise ValueError('Data must be a ndarray (got %s)' % type(data))\n        if data.dtype.isbuiltin:\n            if convert is True:\n                data = data.astype(np.float32)\n            if data.dtype in (np.float64, np.int64):\n                raise TypeError('data must be 32-bit not %s'\n                                % data.dtype)\n            c = data.shape[-1] if data.ndim > 1 else 1\n            if c in [2, 3, 4]:\n                if not data.flags['C_CONTIGUOUS']:\n                    logger.warning('Copying discontiguous data for struct '\n                                   'dtype:\\n%s' % _last_stack_str())\n                    data = data.copy()\n            else:\n                c = 1\n            if self._last_dim and c != self._last_dim:\n                raise ValueError('Last dimension should be %s not %s'\n                                 % (self._last_dim, c))\n            dtype_def = ('f0', data.dtype.base)\n            if c != 1:\n                # numpy dtypes with size 1 are ambiguous, only add size if it is greater than 1\n                dtype_def += (c,)\n            data = data.view(dtype=[dtype_def])\n            self._last_dim = c\n        return data",
  "def __init__(self, data=None):\n        DataBuffer.__init__(self, data)\n        self._last_dim = 1",
  "def _prepare_data(self, data, convert=False):\n        if isinstance(data, list):\n            data = np.array(data, dtype=np.uint32)\n        if not isinstance(data, np.ndarray):\n            raise ValueError('Data must be a ndarray (got %s)' % type(data))\n        if not data.dtype.isbuiltin:\n            raise TypeError(\"Element buffer dtype cannot be structured\")\n        else:\n            if convert:\n                if data.dtype is not np.uint32:\n                    data = data.astype(np.uint32)\n            else:\n                if data.dtype not in [np.uint32, np.uint16, np.uint8]:\n                    raise TypeError(\"Invalid dtype for IndexBuffer: %r\" %\n                                    data.dtype)\n        return data",
  "def get_current_canvas():\n    \"\"\"Proxy for context.get_current_canvas to avoud circular import.\n    This function replaces itself with the real function the first\n    time it is called. (Bah)\n    \"\"\"\n    from .context import get_current_canvas\n    globals()['get_current_canvas'] = get_current_canvas\n    return get_current_canvas()",
  "def _check_valid(key, val, valid):\n    \"\"\"Helper to check valid options\"\"\"\n    if val not in valid:\n        raise ValueError('%s must be one of %s, not \"%s\"'\n                         % (key, valid, val))",
  "def _to_args(x):\n    \"\"\"Convert to args representation\"\"\"\n    if not isinstance(x, (list, tuple, np.ndarray)):\n        x = [x]\n    return x",
  "def _check_conversion(key, valid_dict):\n    \"\"\"Check for existence of key in dict, return value or raise error\"\"\"\n    if key not in valid_dict and key not in valid_dict.values():\n        # Only show users the nice string values\n        keys = [v for v in valid_dict.keys() if isinstance(v, str)]\n        raise ValueError('value must be one of %s, not %s' % (keys, key))\n    return valid_dict[key] if key in valid_dict else key",
  "class BaseGlooFunctions(object):\n    \"\"\"Class that provides a series of GL functions that do not fit\n    in the object oriented part of gloo. An instance of this class is\n    associated with each canvas.\n    \"\"\"\n\n    ##########################################################################\n    # PRIMITIVE/VERTEX\n\n    #\n    # Viewport, DepthRangef, CullFace, FrontFace, LineWidth, PolygonOffset\n    #\n\n    def set_viewport(self, *args):\n        \"\"\"Set the OpenGL viewport\n\n        This is a wrapper for gl.glViewport.\n\n        Parameters\n        ----------\n        *args : tuple\n            X and Y coordinates, plus width and height. Can be passed in as\n            individual components, or as a single tuple with four values.\n        \"\"\"\n        x, y, w, h = args[0] if len(args) == 1 else args\n        self.glir.command('FUNC', 'glViewport', int(x), int(y), int(w), int(h))\n\n    def set_depth_range(self, near=0., far=1.):\n        \"\"\"Set depth values\n\n        Parameters\n        ----------\n        near : float\n            Near clipping plane.\n        far : float\n            Far clipping plane.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthRange', float(near), float(far))\n\n    def set_front_face(self, mode='ccw'):\n        \"\"\"Set which faces are front-facing\n\n        Parameters\n        ----------\n        mode : str\n            Can be 'cw' for clockwise or 'ccw' for counter-clockwise.\n        \"\"\"\n        self.glir.command('FUNC', 'glFrontFace', mode)\n\n    def set_cull_face(self, mode='back'):\n        \"\"\"Set front, back, or both faces to be culled\n\n        Parameters\n        ----------\n        mode : str\n            Culling mode. Can be \"front\", \"back\", or \"front_and_back\".\n        \"\"\"\n        self.glir.command('FUNC', 'glCullFace', mode)\n\n    def set_line_width(self, width=1.):\n        \"\"\"Set line width\n\n        Parameters\n        ----------\n        width : float\n            The line width.\n        \"\"\"\n        width = float(width)\n        if width < 0:\n            raise RuntimeError('Cannot have width < 0')\n        self.glir.command('FUNC', 'glLineWidth', width)\n\n    def set_polygon_offset(self, factor=0., units=0.):\n        \"\"\"Set the scale and units used to calculate depth values\n\n        Parameters\n        ----------\n        factor : float\n            Scale factor used to create a variable depth offset for\n            each polygon.\n        units : float\n            Multiplied by an implementation-specific value to create a\n            constant depth offset.\n        \"\"\"\n        self.glir.command('FUNC', 'glPolygonOffset', float(factor),\n                          float(units))\n\n    ##########################################################################\n    # FRAGMENT/SCREEN\n\n    #\n    # glClear, glClearColor, glClearDepthf, glClearStencil\n    #\n\n    def clear(self, color=True, depth=True, stencil=True):\n        \"\"\"Clear the screen buffers\n\n        This is a wrapper for gl.glClear.\n\n        Parameters\n        ----------\n        color : bool | str | tuple | instance of Color\n            Clear the color buffer bit. If not bool, ``set_clear_color`` will\n            be used to set the color clear value.\n        depth : bool | float\n            Clear the depth buffer bit. If float, ``set_clear_depth`` will\n            be used to set the depth clear value.\n        stencil : bool | int\n            Clear the stencil buffer bit. If int, ``set_clear_stencil`` will\n            be used to set the stencil clear index.\n        \"\"\"\n        bits = 0\n        if isinstance(color, np.ndarray) or bool(color):\n            if not isinstance(color, bool):\n                self.set_clear_color(color)\n            bits |= gl.GL_COLOR_BUFFER_BIT\n        if depth:\n            if not isinstance(depth, bool):\n                self.set_clear_depth(depth)\n            bits |= gl.GL_DEPTH_BUFFER_BIT\n        if stencil:\n            if not isinstance(stencil, bool):\n                self.set_clear_stencil(stencil)\n            bits |= gl.GL_STENCIL_BUFFER_BIT\n        self.glir.command('FUNC', 'glClear', bits)\n\n    def set_clear_color(self, color='black', alpha=None):\n        \"\"\"Set the screen clear color\n\n        This is a wrapper for gl.glClearColor.\n\n        Parameters\n        ----------\n        color : str | tuple | instance of Color\n            Color to use. See vispy.color.Color for options.\n        alpha : float | None\n            Alpha to use.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearColor', *Color(color, alpha).rgba)\n\n    def set_clear_depth(self, depth=1.0):\n        \"\"\"Set the clear value for the depth buffer\n\n        This is a wrapper for gl.glClearDepth.\n\n        Parameters\n        ----------\n        depth : float\n            The depth to use.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearDepth', float(depth))\n\n    def set_clear_stencil(self, index=0):\n        \"\"\"Set the clear value for the stencil buffer\n\n        This is a wrapper for gl.glClearStencil.\n\n        Parameters\n        ----------\n        index : int\n            The index to use when the stencil buffer is cleared.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearStencil', int(index))\n\n    # glBlendFunc(Separate), glBlendColor, glBlendEquation(Separate)\n\n    def set_blend_func(self, srgb='one', drgb='zero',\n                       salpha=None, dalpha=None):\n        \"\"\"Specify pixel arithmetic for RGB and alpha\n\n        Parameters\n        ----------\n        srgb : str\n            Source RGB factor.\n        drgb : str\n            Destination RGB factor.\n        salpha : str | None\n            Source alpha factor. If None, ``srgb`` is used.\n        dalpha : str\n            Destination alpha factor. If None, ``drgb`` is used.\n        \"\"\"\n        salpha = srgb if salpha is None else salpha\n        dalpha = drgb if dalpha is None else dalpha\n        self.glir.command('FUNC', 'glBlendFuncSeparate',\n                          srgb, drgb, salpha, dalpha)\n\n    def set_blend_color(self, color):\n        \"\"\"Set the blend color\n\n        Parameters\n        ----------\n        color : str | tuple | instance of Color\n            Color to use. See vispy.color.Color for options.\n        \"\"\"\n        self.glir.command('FUNC', 'glBlendColor', *Color(color).rgba)\n\n    def set_blend_equation(self, mode_rgb, mode_alpha=None):\n        \"\"\"Specify the equation for RGB and alpha blending\n\n        Parameters\n        ----------\n        mode_rgb : str\n            Mode for RGB.\n        mode_alpha : str | None\n            Mode for Alpha. If None, ``mode_rgb`` is used.\n\n        Notes\n        -----\n        See ``set_blend_equation`` for valid modes.\n        \"\"\"\n        mode_alpha = mode_rgb if mode_alpha is None else mode_alpha\n        self.glir.command('FUNC', 'glBlendEquationSeparate',\n                          mode_rgb, mode_alpha)\n\n    # glScissor, glStencilFunc(Separate), glStencilMask(Separate),\n    # glStencilOp(Separate),\n\n    def set_scissor(self, x, y, w, h):\n        \"\"\"Define the scissor box\n\n        Parameters\n        ----------\n        x : int\n            Left corner of the box.\n        y : int\n            Lower corner of the box.\n        w : int\n            The width of the box.\n        h : int\n            The height of the box.\n        \"\"\"\n        self.glir.command('FUNC', 'glScissor', int(x), int(y), int(w), int(h))\n\n    def set_stencil_func(self, func='always', ref=0, mask=8,\n                         face='front_and_back'):\n        \"\"\"Set front or back function and reference value\n\n        Parameters\n        ----------\n        func : str\n            See set_stencil_func.\n        ref : int\n            Reference value for the stencil test.\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilFuncSeparate',\n                          face, func, int(ref), int(mask))\n\n    def set_stencil_mask(self, mask=8, face='front_and_back'):\n        \"\"\"Control the front or back writing of individual bits in the stencil\n\n        Parameters\n        ----------\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilMaskSeparate', face, int(mask))\n\n    def set_stencil_op(self, sfail='keep', dpfail='keep', dppass='keep',\n                       face='front_and_back'):\n        \"\"\"Set front or back stencil test actions\n\n        Parameters\n        ----------\n        sfail : str\n            Action to take when the stencil fails. Must be one of\n            'keep', 'zero', 'replace', 'incr', 'incr_wrap',\n            'decr', 'decr_wrap', or 'invert'.\n        dpfail : str\n            Action to take when the stencil passes.\n        dppass : str\n            Action to take when both the stencil and depth tests pass,\n            or when the stencil test passes and either there is no depth\n            buffer or depth testing is not enabled.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilOpSeparate',\n                          face, sfail, dpfail, dppass)\n\n    # glDepthFunc, glDepthMask, glColorMask, glSampleCoverage\n\n    def set_depth_func(self, func='less'):\n        \"\"\"Specify the value used for depth buffer comparisons\n\n        Parameters\n        ----------\n        func : str\n            The depth comparison function. Must be one of 'never', 'less',\n            'equal', 'lequal', 'greater', 'gequal', 'notequal', or 'always'.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthFunc', func)\n\n    def set_depth_mask(self, flag):\n        \"\"\"Toggle writing into the depth buffer\n\n        Parameters\n        ----------\n        flag : bool\n            Whether depth writing should be enabled.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthMask', bool(flag))\n\n    def set_color_mask(self, red, green, blue, alpha):\n        \"\"\"Toggle writing of frame buffer color components\n\n        Parameters\n        ----------\n        red : bool\n            Red toggle.\n        green : bool\n            Green toggle.\n        blue : bool\n            Blue toggle.\n        alpha : bool\n            Alpha toggle.\n        \"\"\"\n        self.glir.command('FUNC', 'glColorMask', bool(red), bool(green),\n                          bool(blue), bool(alpha))\n\n    def set_sample_coverage(self, value=1.0, invert=False):\n        \"\"\"Specify multisample coverage parameters\n\n        Parameters\n        ----------\n        value : float\n            Sample coverage value (will be clamped between 0. and 1.).\n        invert : bool\n            Specify if the coverage masks should be inverted.\n        \"\"\"\n        self.glir.command('FUNC', 'glSampleCoverage', float(value),\n                          bool(invert))\n\n    ##########################################################################\n    # STATE\n\n    #\n    # glEnable/Disable\n    #\n\n    def get_state_presets(self):\n        \"\"\"The available GL state :data:`presets <.GL_PRESETS>`.\n\n        Returns\n        -------\n        presets : dict\n            The dictionary of presets usable with :func:`.set_state`.\n        \"\"\"\n        return deepcopy(GL_PRESETS)\n\n    def set_state(self, preset=None, **kwargs):\n        \"\"\"Set the OpenGL rendering state, optionally using a preset.\n\n        Parameters\n        ----------\n        preset : {'opaque', 'translucent', 'additive'}, optional\n            A named state :data:`preset <.GL_PRESETS>` for typical use cases.\n\n        **kwargs : keyword arguments\n            Other supplied keyword arguments will override any preset defaults.\n            Options to be enabled or disabled should be supplied as booleans\n            (e.g., ``'depth_test=True'``, ``cull_face=False``), non-boolean\n            entries will be passed as arguments to ``set_*`` functions (e.g.,\n            ``blend_func=('src_alpha', 'one')`` will call :func:`.set_blend_func`).\n\n        Notes\n        -----\n        This serves three purposes:\n\n        1. Set GL state using reasonable presets.\n        2. Wrapping glEnable/glDisable functionality.\n        3. Convienence wrapping of other ``gloo.set_*`` functions.\n\n        For example, one could do the following:\n\n            >>> from vispy import gloo\n            >>> gloo.set_state('translucent', depth_test=False, clear_color=(1, 1, 1, 1))  # noqa, doctest:+SKIP\n\n        This would take the preset defaults for 'translucent', turn\n        depth testing off (which would normally be on for that preset),\n        and additionally set the glClearColor parameter to be white.\n\n        Another example to showcase glEnable/glDisable wrapping:\n\n            >>> gloo.set_state(blend=True, depth_test=True, polygon_offset_fill=False)  # noqa, doctest:+SKIP\n\n        This would be equivalent to calling\n\n            >>> from vispy.gloo import gl\n            >>> gl.glDisable(gl.GL_BLEND)\n            >>> gl.glEnable(gl.GL_DEPTH_TEST)\n            >>> gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n\n        Or here's another example:\n\n            >>> gloo.set_state(clear_color=(0, 0, 0, 1), blend=True, blend_func=('src_alpha', 'one'))  # noqa, doctest:+SKIP\n\n        Thus arbitrary GL state components can be set directly using\n        ``set_state``. Note that individual functions are exposed e.g.,\n        as ``set_clear_color``, with some more informative docstrings\n        about those particular functions.\n        \"\"\"\n        kwargs = deepcopy(kwargs)\n\n        # Load preset, if supplied\n        if preset is not None:\n            _check_valid('preset', preset, tuple(list(GL_PRESETS.keys())))\n            for key, val in GL_PRESETS[preset].items():\n                # only overwrite user input with preset if user's input is None\n                if key not in kwargs:\n                    kwargs[key] = val\n\n        # cull_face is an exception because GL_CULL_FACE, glCullFace both exist\n        if 'cull_face' in kwargs:\n            cull_face = kwargs.pop('cull_face')\n            if isinstance(cull_face, bool):\n                funcname = 'glEnable' if cull_face else 'glDisable'\n                self.glir.command('FUNC', funcname, 'cull_face')\n            else:\n                self.glir.command('FUNC', 'glEnable', 'cull_face')\n                self.set_cull_face(*_to_args(cull_face))\n\n        # Line width needs some special care ...\n        if 'line_width' in kwargs:\n            line_width = kwargs.pop('line_width')\n            self.glir.command('FUNC', 'glLineWidth', line_width)\n        if 'line_smooth' in kwargs:\n            line_smooth = kwargs.pop('line_smooth')\n            funcname = 'glEnable' if line_smooth else 'glDisable'\n            line_smooth_enum_value = 2848  # int(GL.GL_LINE_SMOOTH)\n            self.glir.command('FUNC', funcname, line_smooth_enum_value)\n\n        # Iterate over kwargs\n        for key, val in kwargs.items():\n            if key in _setters:\n                # Setter\n                args = _to_args(val)\n                # these actually need tuples\n                if key in ('blend_color', 'clear_color') and \\\n                        not isinstance(args[0], str):\n                    args = [args]\n                getattr(self, 'set_' + key)(*args)\n            else:\n                # Enable / disable\n                funcname = 'glEnable' if val else 'glDisable'\n                self.glir.command('FUNC', funcname, key)\n\n    #\n    # glFinish, glFlush, glReadPixels, glHint\n    #\n\n    def finish(self):\n        \"\"\"Wait for GL commands to to finish\n\n        This creates a GLIR command for glFinish and then processes the\n        GLIR commands. If the GLIR interpreter is remote (e.g. WebGL), this\n        function will return before GL has finished processing the commands.\n        \"\"\"\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFinish')\n        context.flush_commands()  # Process GLIR commands\n\n    def flush(self):\n        \"\"\"Flush GL commands\n\n        This is a wrapper for glFlush(). This also flushes the GLIR\n        command queue.\n        \"\"\"\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFlush')\n        context.flush_commands()  # Process GLIR commands\n\n    def set_hint(self, target, mode):\n        \"\"\"Set OpenGL drawing hint\n\n        Parameters\n        ----------\n        target : str\n            The target, e.g. 'fog_hint', 'line_smooth_hint',\n            'point_smooth_hint'.\n        mode : str\n            The mode to set (e.g., 'fastest', 'nicest', 'dont_care').\n        \"\"\"\n        if not all(isinstance(tm, str) for tm in (target, mode)):\n            raise TypeError('target and mode must both be strings')\n        self.glir.command('FUNC', 'glHint', target, mode)",
  "class GlooFunctions(BaseGlooFunctions):\n\n    @property\n    def glir(self):\n        \"\"\"The GLIR queue corresponding to the current canvas\"\"\"\n        canvas = get_current_canvas()\n        if canvas is None:\n            msg = (\"If you want to use gloo without vispy.app, \" +\n                   \"use a gloo.context.FakeCanvas.\")\n            raise RuntimeError('Gloo requires a Canvas to run.\\n' + msg)\n        return canvas.context.glir",
  "def read_pixels(viewport=None, alpha=True, mode='color', out_type='unsigned_byte'):\n    \"\"\"Read pixels from the currently selected buffer.\n\n    Under most circumstances, this function reads from the front buffer.\n    Unlike all other functions in vispy.gloo, this function directly executes\n    an OpenGL command.\n\n    Parameters\n    ----------\n    viewport : array-like | None\n        4-element list of x, y, w, h parameters. If None (default),\n        the current GL viewport will be queried and used.\n    alpha : bool\n        If True (default), the returned array has 4 elements (RGBA).\n        If False, it has 3 (RGB). This only effects the color mode.\n    mode : str\n        Type of buffer data to read. Can be one of 'colors', 'depth',\n        or 'stencil'. See returns for more information.\n    out_type : str | dtype\n        Can be 'unsigned_byte' or 'float'. Note that this does not\n        use casting, but instead determines how values are read from\n        the current buffer. Can also be numpy dtypes ``np.uint8``,\n        ``np.ubyte``, or ``np.float32``.\n\n    Returns\n    -------\n    pixels : array\n        3D array of pixels in np.uint8 or np.float32 format.\n        The array shape is (h, w, 3) or (h, w, 4) for colors mode,\n        with the top-left corner of the framebuffer at index [0, 0] in the\n        returned array. If 'mode' is depth or stencil then the last dimension\n        is 1.\n    \"\"\"\n    _check_valid('mode', mode, ['color', 'depth', 'stencil'])\n\n    # Check whether the GL context is direct or remote\n    context = get_current_canvas().context\n    if context.shared.parser.is_remote():\n        raise RuntimeError('Cannot use read_pixels() with remote GLIR parser')\n\n    finish()  # noqa - finish first, also flushes GLIR commands\n    type_dict = {'unsigned_byte': gl.GL_UNSIGNED_BYTE,\n                 np.uint8: gl.GL_UNSIGNED_BYTE,\n                 'float': gl.GL_FLOAT,\n                 np.float32: gl.GL_FLOAT}\n    type_ = _check_conversion(out_type, type_dict)\n    if viewport is None:\n        viewport = gl.glGetParameter(gl.GL_VIEWPORT)\n    viewport = np.array(viewport, int)\n    if viewport.ndim != 1 or viewport.size != 4:\n        raise ValueError('viewport should be 1D 4-element array-like, not %s'\n                         % (viewport,))\n    x, y, w, h = viewport\n    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 1)  # PACK, not UNPACK\n    if mode == 'depth':\n        fmt = gl.GL_DEPTH_COMPONENT\n        shape = (h, w, 1)\n    elif mode == 'stencil':\n        fmt = gl.GL_STENCIL_INDEX8\n        shape = (h, w, 1)\n    elif alpha:\n        fmt = gl.GL_RGBA\n        shape = (h, w, 4)\n    else:\n        fmt = gl.GL_RGB\n        shape = (h, w, 3)\n    im = gl.glReadPixels(x, y, w, h, fmt, type_)\n    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 4)\n    # reshape, flip, and return\n    if not isinstance(im, np.ndarray):\n        np_dtype = np.uint8 if type_ == gl.GL_UNSIGNED_BYTE else np.float32\n        im = np.frombuffer(im, np_dtype)\n\n    im.shape = shape\n    im = im[::-1, ...]  # flip the image\n    return im",
  "def get_gl_configuration():\n    \"\"\"Read the current gl configuration\n\n    This function uses constants that are not in the OpenGL ES 2.1\n    namespace, so only use this on desktop systems.\n\n    Returns\n    -------\n    config : dict\n        The currently active OpenGL configuration.\n    \"\"\"\n    # XXX eventually maybe we can ask `gl` whether or not we can access these\n    gl.check_error('pre-config check')\n    config = dict()\n    canvas = get_current_canvas()\n    fbo = 0 if canvas is None else canvas._backend._vispy_get_fb_bind_location()\n    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, fbo)\n    fb_param = gl.glGetFramebufferAttachmentParameter\n    # copied since they aren't in ES:\n    GL_FRONT_LEFT = 1024\n    GL_DEPTH = 6145\n    GL_STENCIL = 6146\n    GL_SRGB = 35904\n    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296\n    GL_STEREO = 3123\n    GL_DOUBLEBUFFER = 3122\n    sizes = dict(red=(GL_FRONT_LEFT, 33298),\n                 green=(GL_FRONT_LEFT, 33299),\n                 blue=(GL_FRONT_LEFT, 33300),\n                 alpha=(GL_FRONT_LEFT, 33301),\n                 depth=(GL_DEPTH, 33302),\n                 stencil=(GL_STENCIL, 33303))\n    for key, val in sizes.items():\n        try:\n            param = fb_param(gl.GL_FRAMEBUFFER, val[0], val[1])\n            gl.check_error('post-config check')\n        except RuntimeError as exp:\n            logger.warning('Failed to get size %s: %s' % (key, exp))\n        else:\n            config[key + '_size'] = param\n\n    try:\n        val = fb_param(gl.GL_FRAMEBUFFER, GL_FRONT_LEFT,\n                       GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING)\n        gl.check_error('post-config check')\n    except RuntimeError as exp:\n        logger.warning('Failed to get sRGB: %s' % (exp,))\n    else:\n        if val not in (gl.GL_LINEAR, GL_SRGB):\n            logger.warning('unknown value for SRGB: %s' % val)\n        else:\n            config['srgb'] = (val == GL_SRGB)\n\n    for key, enum in (('stereo', GL_STEREO),\n                      ('double_buffer', GL_DOUBLEBUFFER)):\n        val = gl.glGetParameter(enum)\n        try:\n            gl.check_error('post-config check')\n        except RuntimeError as exp:\n            logger.warning('Failed to get %s: %s' % (key, exp))\n        else:\n            config[key] = bool(val)\n    config['samples'] = gl.glGetParameter(gl.GL_SAMPLES)\n    gl.check_error('post-config check')\n    return config",
  "def set_viewport(self, *args):\n        \"\"\"Set the OpenGL viewport\n\n        This is a wrapper for gl.glViewport.\n\n        Parameters\n        ----------\n        *args : tuple\n            X and Y coordinates, plus width and height. Can be passed in as\n            individual components, or as a single tuple with four values.\n        \"\"\"\n        x, y, w, h = args[0] if len(args) == 1 else args\n        self.glir.command('FUNC', 'glViewport', int(x), int(y), int(w), int(h))",
  "def set_depth_range(self, near=0., far=1.):\n        \"\"\"Set depth values\n\n        Parameters\n        ----------\n        near : float\n            Near clipping plane.\n        far : float\n            Far clipping plane.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthRange', float(near), float(far))",
  "def set_front_face(self, mode='ccw'):\n        \"\"\"Set which faces are front-facing\n\n        Parameters\n        ----------\n        mode : str\n            Can be 'cw' for clockwise or 'ccw' for counter-clockwise.\n        \"\"\"\n        self.glir.command('FUNC', 'glFrontFace', mode)",
  "def set_cull_face(self, mode='back'):\n        \"\"\"Set front, back, or both faces to be culled\n\n        Parameters\n        ----------\n        mode : str\n            Culling mode. Can be \"front\", \"back\", or \"front_and_back\".\n        \"\"\"\n        self.glir.command('FUNC', 'glCullFace', mode)",
  "def set_line_width(self, width=1.):\n        \"\"\"Set line width\n\n        Parameters\n        ----------\n        width : float\n            The line width.\n        \"\"\"\n        width = float(width)\n        if width < 0:\n            raise RuntimeError('Cannot have width < 0')\n        self.glir.command('FUNC', 'glLineWidth', width)",
  "def set_polygon_offset(self, factor=0., units=0.):\n        \"\"\"Set the scale and units used to calculate depth values\n\n        Parameters\n        ----------\n        factor : float\n            Scale factor used to create a variable depth offset for\n            each polygon.\n        units : float\n            Multiplied by an implementation-specific value to create a\n            constant depth offset.\n        \"\"\"\n        self.glir.command('FUNC', 'glPolygonOffset', float(factor),\n                          float(units))",
  "def clear(self, color=True, depth=True, stencil=True):\n        \"\"\"Clear the screen buffers\n\n        This is a wrapper for gl.glClear.\n\n        Parameters\n        ----------\n        color : bool | str | tuple | instance of Color\n            Clear the color buffer bit. If not bool, ``set_clear_color`` will\n            be used to set the color clear value.\n        depth : bool | float\n            Clear the depth buffer bit. If float, ``set_clear_depth`` will\n            be used to set the depth clear value.\n        stencil : bool | int\n            Clear the stencil buffer bit. If int, ``set_clear_stencil`` will\n            be used to set the stencil clear index.\n        \"\"\"\n        bits = 0\n        if isinstance(color, np.ndarray) or bool(color):\n            if not isinstance(color, bool):\n                self.set_clear_color(color)\n            bits |= gl.GL_COLOR_BUFFER_BIT\n        if depth:\n            if not isinstance(depth, bool):\n                self.set_clear_depth(depth)\n            bits |= gl.GL_DEPTH_BUFFER_BIT\n        if stencil:\n            if not isinstance(stencil, bool):\n                self.set_clear_stencil(stencil)\n            bits |= gl.GL_STENCIL_BUFFER_BIT\n        self.glir.command('FUNC', 'glClear', bits)",
  "def set_clear_color(self, color='black', alpha=None):\n        \"\"\"Set the screen clear color\n\n        This is a wrapper for gl.glClearColor.\n\n        Parameters\n        ----------\n        color : str | tuple | instance of Color\n            Color to use. See vispy.color.Color for options.\n        alpha : float | None\n            Alpha to use.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearColor', *Color(color, alpha).rgba)",
  "def set_clear_depth(self, depth=1.0):\n        \"\"\"Set the clear value for the depth buffer\n\n        This is a wrapper for gl.glClearDepth.\n\n        Parameters\n        ----------\n        depth : float\n            The depth to use.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearDepth', float(depth))",
  "def set_clear_stencil(self, index=0):\n        \"\"\"Set the clear value for the stencil buffer\n\n        This is a wrapper for gl.glClearStencil.\n\n        Parameters\n        ----------\n        index : int\n            The index to use when the stencil buffer is cleared.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearStencil', int(index))",
  "def set_blend_func(self, srgb='one', drgb='zero',\n                       salpha=None, dalpha=None):\n        \"\"\"Specify pixel arithmetic for RGB and alpha\n\n        Parameters\n        ----------\n        srgb : str\n            Source RGB factor.\n        drgb : str\n            Destination RGB factor.\n        salpha : str | None\n            Source alpha factor. If None, ``srgb`` is used.\n        dalpha : str\n            Destination alpha factor. If None, ``drgb`` is used.\n        \"\"\"\n        salpha = srgb if salpha is None else salpha\n        dalpha = drgb if dalpha is None else dalpha\n        self.glir.command('FUNC', 'glBlendFuncSeparate',\n                          srgb, drgb, salpha, dalpha)",
  "def set_blend_color(self, color):\n        \"\"\"Set the blend color\n\n        Parameters\n        ----------\n        color : str | tuple | instance of Color\n            Color to use. See vispy.color.Color for options.\n        \"\"\"\n        self.glir.command('FUNC', 'glBlendColor', *Color(color).rgba)",
  "def set_blend_equation(self, mode_rgb, mode_alpha=None):\n        \"\"\"Specify the equation for RGB and alpha blending\n\n        Parameters\n        ----------\n        mode_rgb : str\n            Mode for RGB.\n        mode_alpha : str | None\n            Mode for Alpha. If None, ``mode_rgb`` is used.\n\n        Notes\n        -----\n        See ``set_blend_equation`` for valid modes.\n        \"\"\"\n        mode_alpha = mode_rgb if mode_alpha is None else mode_alpha\n        self.glir.command('FUNC', 'glBlendEquationSeparate',\n                          mode_rgb, mode_alpha)",
  "def set_scissor(self, x, y, w, h):\n        \"\"\"Define the scissor box\n\n        Parameters\n        ----------\n        x : int\n            Left corner of the box.\n        y : int\n            Lower corner of the box.\n        w : int\n            The width of the box.\n        h : int\n            The height of the box.\n        \"\"\"\n        self.glir.command('FUNC', 'glScissor', int(x), int(y), int(w), int(h))",
  "def set_stencil_func(self, func='always', ref=0, mask=8,\n                         face='front_and_back'):\n        \"\"\"Set front or back function and reference value\n\n        Parameters\n        ----------\n        func : str\n            See set_stencil_func.\n        ref : int\n            Reference value for the stencil test.\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilFuncSeparate',\n                          face, func, int(ref), int(mask))",
  "def set_stencil_mask(self, mask=8, face='front_and_back'):\n        \"\"\"Control the front or back writing of individual bits in the stencil\n\n        Parameters\n        ----------\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilMaskSeparate', face, int(mask))",
  "def set_stencil_op(self, sfail='keep', dpfail='keep', dppass='keep',\n                       face='front_and_back'):\n        \"\"\"Set front or back stencil test actions\n\n        Parameters\n        ----------\n        sfail : str\n            Action to take when the stencil fails. Must be one of\n            'keep', 'zero', 'replace', 'incr', 'incr_wrap',\n            'decr', 'decr_wrap', or 'invert'.\n        dpfail : str\n            Action to take when the stencil passes.\n        dppass : str\n            Action to take when both the stencil and depth tests pass,\n            or when the stencil test passes and either there is no depth\n            buffer or depth testing is not enabled.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilOpSeparate',\n                          face, sfail, dpfail, dppass)",
  "def set_depth_func(self, func='less'):\n        \"\"\"Specify the value used for depth buffer comparisons\n\n        Parameters\n        ----------\n        func : str\n            The depth comparison function. Must be one of 'never', 'less',\n            'equal', 'lequal', 'greater', 'gequal', 'notequal', or 'always'.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthFunc', func)",
  "def set_depth_mask(self, flag):\n        \"\"\"Toggle writing into the depth buffer\n\n        Parameters\n        ----------\n        flag : bool\n            Whether depth writing should be enabled.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthMask', bool(flag))",
  "def set_color_mask(self, red, green, blue, alpha):\n        \"\"\"Toggle writing of frame buffer color components\n\n        Parameters\n        ----------\n        red : bool\n            Red toggle.\n        green : bool\n            Green toggle.\n        blue : bool\n            Blue toggle.\n        alpha : bool\n            Alpha toggle.\n        \"\"\"\n        self.glir.command('FUNC', 'glColorMask', bool(red), bool(green),\n                          bool(blue), bool(alpha))",
  "def set_sample_coverage(self, value=1.0, invert=False):\n        \"\"\"Specify multisample coverage parameters\n\n        Parameters\n        ----------\n        value : float\n            Sample coverage value (will be clamped between 0. and 1.).\n        invert : bool\n            Specify if the coverage masks should be inverted.\n        \"\"\"\n        self.glir.command('FUNC', 'glSampleCoverage', float(value),\n                          bool(invert))",
  "def get_state_presets(self):\n        \"\"\"The available GL state :data:`presets <.GL_PRESETS>`.\n\n        Returns\n        -------\n        presets : dict\n            The dictionary of presets usable with :func:`.set_state`.\n        \"\"\"\n        return deepcopy(GL_PRESETS)",
  "def set_state(self, preset=None, **kwargs):\n        \"\"\"Set the OpenGL rendering state, optionally using a preset.\n\n        Parameters\n        ----------\n        preset : {'opaque', 'translucent', 'additive'}, optional\n            A named state :data:`preset <.GL_PRESETS>` for typical use cases.\n\n        **kwargs : keyword arguments\n            Other supplied keyword arguments will override any preset defaults.\n            Options to be enabled or disabled should be supplied as booleans\n            (e.g., ``'depth_test=True'``, ``cull_face=False``), non-boolean\n            entries will be passed as arguments to ``set_*`` functions (e.g.,\n            ``blend_func=('src_alpha', 'one')`` will call :func:`.set_blend_func`).\n\n        Notes\n        -----\n        This serves three purposes:\n\n        1. Set GL state using reasonable presets.\n        2. Wrapping glEnable/glDisable functionality.\n        3. Convienence wrapping of other ``gloo.set_*`` functions.\n\n        For example, one could do the following:\n\n            >>> from vispy import gloo\n            >>> gloo.set_state('translucent', depth_test=False, clear_color=(1, 1, 1, 1))  # noqa, doctest:+SKIP\n\n        This would take the preset defaults for 'translucent', turn\n        depth testing off (which would normally be on for that preset),\n        and additionally set the glClearColor parameter to be white.\n\n        Another example to showcase glEnable/glDisable wrapping:\n\n            >>> gloo.set_state(blend=True, depth_test=True, polygon_offset_fill=False)  # noqa, doctest:+SKIP\n\n        This would be equivalent to calling\n\n            >>> from vispy.gloo import gl\n            >>> gl.glDisable(gl.GL_BLEND)\n            >>> gl.glEnable(gl.GL_DEPTH_TEST)\n            >>> gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n\n        Or here's another example:\n\n            >>> gloo.set_state(clear_color=(0, 0, 0, 1), blend=True, blend_func=('src_alpha', 'one'))  # noqa, doctest:+SKIP\n\n        Thus arbitrary GL state components can be set directly using\n        ``set_state``. Note that individual functions are exposed e.g.,\n        as ``set_clear_color``, with some more informative docstrings\n        about those particular functions.\n        \"\"\"\n        kwargs = deepcopy(kwargs)\n\n        # Load preset, if supplied\n        if preset is not None:\n            _check_valid('preset', preset, tuple(list(GL_PRESETS.keys())))\n            for key, val in GL_PRESETS[preset].items():\n                # only overwrite user input with preset if user's input is None\n                if key not in kwargs:\n                    kwargs[key] = val\n\n        # cull_face is an exception because GL_CULL_FACE, glCullFace both exist\n        if 'cull_face' in kwargs:\n            cull_face = kwargs.pop('cull_face')\n            if isinstance(cull_face, bool):\n                funcname = 'glEnable' if cull_face else 'glDisable'\n                self.glir.command('FUNC', funcname, 'cull_face')\n            else:\n                self.glir.command('FUNC', 'glEnable', 'cull_face')\n                self.set_cull_face(*_to_args(cull_face))\n\n        # Line width needs some special care ...\n        if 'line_width' in kwargs:\n            line_width = kwargs.pop('line_width')\n            self.glir.command('FUNC', 'glLineWidth', line_width)\n        if 'line_smooth' in kwargs:\n            line_smooth = kwargs.pop('line_smooth')\n            funcname = 'glEnable' if line_smooth else 'glDisable'\n            line_smooth_enum_value = 2848  # int(GL.GL_LINE_SMOOTH)\n            self.glir.command('FUNC', funcname, line_smooth_enum_value)\n\n        # Iterate over kwargs\n        for key, val in kwargs.items():\n            if key in _setters:\n                # Setter\n                args = _to_args(val)\n                # these actually need tuples\n                if key in ('blend_color', 'clear_color') and \\\n                        not isinstance(args[0], str):\n                    args = [args]\n                getattr(self, 'set_' + key)(*args)\n            else:\n                # Enable / disable\n                funcname = 'glEnable' if val else 'glDisable'\n                self.glir.command('FUNC', funcname, key)",
  "def finish(self):\n        \"\"\"Wait for GL commands to to finish\n\n        This creates a GLIR command for glFinish and then processes the\n        GLIR commands. If the GLIR interpreter is remote (e.g. WebGL), this\n        function will return before GL has finished processing the commands.\n        \"\"\"\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFinish')\n        context.flush_commands()",
  "def flush(self):\n        \"\"\"Flush GL commands\n\n        This is a wrapper for glFlush(). This also flushes the GLIR\n        command queue.\n        \"\"\"\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFlush')\n        context.flush_commands()",
  "def set_hint(self, target, mode):\n        \"\"\"Set OpenGL drawing hint\n\n        Parameters\n        ----------\n        target : str\n            The target, e.g. 'fog_hint', 'line_smooth_hint',\n            'point_smooth_hint'.\n        mode : str\n            The mode to set (e.g., 'fastest', 'nicest', 'dont_care').\n        \"\"\"\n        if not all(isinstance(tm, str) for tm in (target, mode)):\n            raise TypeError('target and mode must both be strings')\n        self.glir.command('FUNC', 'glHint', target, mode)",
  "def glir(self):\n        \"\"\"The GLIR queue corresponding to the current canvas\"\"\"\n        canvas = get_current_canvas()\n        if canvas is None:\n            msg = (\"If you want to use gloo without vispy.app, \" +\n                   \"use a gloo.context.FakeCanvas.\")\n            raise RuntimeError('Gloo requires a Canvas to run.\\n' + msg)\n        return canvas.context.glir",
  "def _patch():\n    \"\"\"Monkey-patch pyopengl to fix a bug in glBufferSubData.\"\"\"\n    import sys\n    from OpenGL import GL\n    if sys.version_info > (3,):\n        buffersubdatafunc = GL.glBufferSubData\n        if hasattr(buffersubdatafunc, 'wrapperFunction'):\n            buffersubdatafunc = buffersubdatafunc.wrapperFunction\n        _m = sys.modules[buffersubdatafunc.__module__]\n        _m.long = int\n\n    # Fix missing enum\n    try:\n        from OpenGL.GL.VERSION import GL_2_0\n        GL_2_0.GL_OBJECT_SHADER_SOURCE_LENGTH = GL_2_0.GL_SHADER_SOURCE_LENGTH\n    except Exception:\n        pass",
  "def _make_unavailable_func(funcname):\n    def cb(*args, **kwargs):\n        raise RuntimeError('OpenGL API call \"%s\" is not available.' % funcname)\n    return cb",
  "def _get_function_from_pyopengl(funcname):\n    \"\"\"Try getting the given function from PyOpenGL, return\n    a dummy function (that shows a warning when called) if it\n    could not be found.\n    \"\"\"\n    func = None\n\n    # Get function from GL\n    try:\n        func = getattr(_GL, funcname)\n    except AttributeError:\n        # Get function from FBO\n        try:\n            func = getattr(_FBO, funcname)\n        except AttributeError:\n            func = None\n\n    # Try using \"alias\"\n    if not bool(func):\n        # Some functions are known by a slightly different name\n        # e.g. glDepthRangef, glClearDepthf\n        if funcname.endswith('f'):\n            try:\n                func = getattr(_GL, funcname[:-1])\n            except AttributeError:\n                pass\n\n    # Set dummy function if we could not find it\n    if func is None:\n        func = _make_unavailable_func(funcname)\n        logger.warning('warning: %s not available' % funcname)\n    return func",
  "def _inject():\n    \"\"\"Copy functions from OpenGL.GL into _pyopengl namespace.\"\"\"\n    NS = _pyopengl2.__dict__\n    for glname, ourname in _pyopengl2._functions_to_import:\n        func = _get_function_from_pyopengl(glname)\n        NS[ourname] = func",
  "def cb(*args, **kwargs):\n        raise RuntimeError('OpenGL API call \"%s\" is not available.' % funcname)",
  "class BaseGLProxy(object):\n    \"\"\" Base proxy class for the GL ES 2.0 API. Subclasses should\n    implement __call__ to process the API calls.\n    \"\"\"\n   \n    def __call__(self, funcname, returns, *args):\n        raise NotImplementedError()\n\n\n    def glActiveTexture(self, texture):\n        self(\"glActiveTexture\", False, texture)\n\n\n    def glAttachShader(self, program, shader):\n        self(\"glAttachShader\", False, program, shader)\n\n\n    def glBindAttribLocation(self, program, index, name):\n        self(\"glBindAttribLocation\", False, program, index, name)\n\n\n    def glBindBuffer(self, target, buffer):\n        self(\"glBindBuffer\", False, target, buffer)\n\n\n    def glBindFramebuffer(self, target, framebuffer):\n        self(\"glBindFramebuffer\", False, target, framebuffer)\n\n\n    def glBindRenderbuffer(self, target, renderbuffer):\n        self(\"glBindRenderbuffer\", False, target, renderbuffer)\n\n\n    def glBindTexture(self, target, texture):\n        self(\"glBindTexture\", False, target, texture)\n\n\n    def glBlendColor(self, red, green, blue, alpha):\n        self(\"glBlendColor\", False, red, green, blue, alpha)\n\n\n    def glBlendEquation(self, mode):\n        self(\"glBlendEquation\", False, mode)\n\n\n    def glBlendEquationSeparate(self, modeRGB, modeAlpha):\n        self(\"glBlendEquationSeparate\", False, modeRGB, modeAlpha)\n\n\n    def glBlendFunc(self, sfactor, dfactor):\n        self(\"glBlendFunc\", False, sfactor, dfactor)\n\n\n    def glBlendFuncSeparate(self, srcRGB, dstRGB, srcAlpha, dstAlpha):\n        self(\"glBlendFuncSeparate\", False, srcRGB, dstRGB, srcAlpha, dstAlpha)\n\n\n    def glBufferData(self, target, data, usage):\n        self(\"glBufferData\", False, target, data, usage)\n\n\n    def glBufferSubData(self, target, offset, data):\n        self(\"glBufferSubData\", False, target, offset, data)\n\n\n    def glCheckFramebufferStatus(self, target):\n        return self(\"glCheckFramebufferStatus\", True, target)\n\n\n    def glClear(self, mask):\n        self(\"glClear\", False, mask)\n\n\n    def glClearColor(self, red, green, blue, alpha):\n        self(\"glClearColor\", False, red, green, blue, alpha)\n\n\n    def glClearDepth(self, depth):\n        self(\"glClearDepth\", False, depth)\n\n\n    def glClearStencil(self, s):\n        self(\"glClearStencil\", False, s)\n\n\n    def glColorMask(self, red, green, blue, alpha):\n        self(\"glColorMask\", False, red, green, blue, alpha)\n\n\n    def glCompileShader(self, shader):\n        self(\"glCompileShader\", False, shader)\n\n\n    def glCompressedTexImage2D(self, target, level, internalformat, width, height, border, data):\n        self(\"glCompressedTexImage2D\", False, target, level, internalformat, width, height, border, data)\n\n\n    def glCompressedTexSubImage2D(self, target, level, xoffset, yoffset, width, height, format, data):\n        self(\"glCompressedTexSubImage2D\", False, target, level, xoffset, yoffset, width, height, format, data)\n\n\n    def glCopyTexImage2D(self, target, level, internalformat, x, y, width, height, border):\n        self(\"glCopyTexImage2D\", False, target, level, internalformat, x, y, width, height, border)\n\n\n    def glCopyTexSubImage2D(self, target, level, xoffset, yoffset, x, y, width, height):\n        self(\"glCopyTexSubImage2D\", False, target, level, xoffset, yoffset, x, y, width, height)\n\n\n    def glCreateProgram(self, ):\n        return self(\"glCreateProgram\", True, )\n\n\n    def glCreateShader(self, type):\n        return self(\"glCreateShader\", True, type)\n\n\n    def glCullFace(self, mode):\n        self(\"glCullFace\", False, mode)\n\n\n    def glDeleteBuffer(self, buffer):\n        self(\"glDeleteBuffer\", False, buffer)\n\n\n    def glDeleteFramebuffer(self, framebuffer):\n        self(\"glDeleteFramebuffer\", False, framebuffer)\n\n\n    def glDeleteProgram(self, program):\n        self(\"glDeleteProgram\", False, program)\n\n\n    def glDeleteRenderbuffer(self, renderbuffer):\n        self(\"glDeleteRenderbuffer\", False, renderbuffer)\n\n\n    def glDeleteShader(self, shader):\n        self(\"glDeleteShader\", False, shader)\n\n\n    def glDeleteTexture(self, texture):\n        self(\"glDeleteTexture\", False, texture)\n\n\n    def glDepthFunc(self, func):\n        self(\"glDepthFunc\", False, func)\n\n\n    def glDepthMask(self, flag):\n        self(\"glDepthMask\", False, flag)\n\n\n    def glDepthRange(self, zNear, zFar):\n        self(\"glDepthRange\", False, zNear, zFar)\n\n\n    def glDetachShader(self, program, shader):\n        self(\"glDetachShader\", False, program, shader)\n\n\n    def glDisable(self, cap):\n        self(\"glDisable\", False, cap)\n\n\n    def glDisableVertexAttribArray(self, index):\n        self(\"glDisableVertexAttribArray\", False, index)\n\n\n    def glDrawArrays(self, mode, first, count):\n        self(\"glDrawArrays\", False, mode, first, count)\n\n\n    def glDrawElements(self, mode, count, type, offset):\n        self(\"glDrawElements\", False, mode, count, type, offset)\n\n\n    def glEnable(self, cap):\n        self(\"glEnable\", False, cap)\n\n\n    def glEnableVertexAttribArray(self, index):\n        self(\"glEnableVertexAttribArray\", False, index)\n\n\n    def glFinish(self, ):\n        self(\"glFinish\", False, )\n\n\n    def glFlush(self, ):\n        self(\"glFlush\", False, )\n\n\n    def glFramebufferRenderbuffer(self, target, attachment, renderbuffertarget, renderbuffer):\n        self(\"glFramebufferRenderbuffer\", False, target, attachment, renderbuffertarget, renderbuffer)\n\n\n    def glFramebufferTexture2D(self, target, attachment, textarget, texture, level):\n        self(\"glFramebufferTexture2D\", False, target, attachment, textarget, texture, level)\n\n\n    def glFrontFace(self, mode):\n        self(\"glFrontFace\", False, mode)\n\n\n    def glCreateBuffer(self, ):\n        return self(\"glCreateBuffer\", True, )\n\n\n    def glCreateFramebuffer(self, ):\n        return self(\"glCreateFramebuffer\", True, )\n\n\n    def glCreateRenderbuffer(self, ):\n        return self(\"glCreateRenderbuffer\", True, )\n\n\n    def glCreateTexture(self, ):\n        return self(\"glCreateTexture\", True, )\n\n\n    def glGenerateMipmap(self, target):\n        self(\"glGenerateMipmap\", False, target)\n\n\n    def glGetActiveAttrib(self, program, index):\n        return self(\"glGetActiveAttrib\", True, program, index)\n\n\n    def glGetActiveUniform(self, program, index):\n        return self(\"glGetActiveUniform\", True, program, index)\n\n\n    def glGetAttachedShaders(self, program):\n        return self(\"glGetAttachedShaders\", True, program)\n\n\n    def glGetAttribLocation(self, program, name):\n        return self(\"glGetAttribLocation\", True, program, name)\n\n\n    def _glGetBooleanv(self, pname):\n        self(\"_glGetBooleanv\", False, pname)\n\n\n    def glGetBufferParameter(self, target, pname):\n        return self(\"glGetBufferParameter\", True, target, pname)\n\n\n    def glGetError(self, ):\n        return self(\"glGetError\", True, )\n\n\n    def _glGetFloatv(self, pname):\n        self(\"_glGetFloatv\", False, pname)\n\n\n    def glGetFramebufferAttachmentParameter(self, target, attachment, pname):\n        return self(\"glGetFramebufferAttachmentParameter\", True, target, attachment, pname)\n\n\n    def _glGetIntegerv(self, pname):\n        self(\"_glGetIntegerv\", False, pname)\n\n\n    def glGetProgramInfoLog(self, program):\n        return self(\"glGetProgramInfoLog\", True, program)\n\n\n    def glGetProgramParameter(self, program, pname):\n        return self(\"glGetProgramParameter\", True, program, pname)\n\n\n    def glGetRenderbufferParameter(self, target, pname):\n        return self(\"glGetRenderbufferParameter\", True, target, pname)\n\n\n    def glGetShaderInfoLog(self, shader):\n        return self(\"glGetShaderInfoLog\", True, shader)\n\n\n    def glGetShaderPrecisionFormat(self, shadertype, precisiontype):\n        return self(\"glGetShaderPrecisionFormat\", True, shadertype, precisiontype)\n\n\n    def glGetShaderSource(self, shader):\n        return self(\"glGetShaderSource\", True, shader)\n\n\n    def glGetShaderParameter(self, shader, pname):\n        return self(\"glGetShaderParameter\", True, shader, pname)\n\n\n    def glGetParameter(self, pname):\n        return self(\"glGetParameter\", True, pname)\n\n\n    def glGetTexParameter(self, target, pname):\n        return self(\"glGetTexParameter\", True, target, pname)\n\n\n    def glGetUniform(self, program, location):\n        return self(\"glGetUniform\", True, program, location)\n\n\n    def glGetUniformLocation(self, program, name):\n        return self(\"glGetUniformLocation\", True, program, name)\n\n\n    def glGetVertexAttrib(self, index, pname):\n        return self(\"glGetVertexAttrib\", True, index, pname)\n\n\n    def glGetVertexAttribOffset(self, index, pname):\n        return self(\"glGetVertexAttribOffset\", True, index, pname)\n\n\n    def glHint(self, target, mode):\n        self(\"glHint\", False, target, mode)\n\n\n    def glIsBuffer(self, buffer):\n        return self(\"glIsBuffer\", True, buffer)\n\n\n    def glIsEnabled(self, cap):\n        return self(\"glIsEnabled\", True, cap)\n\n\n    def glIsFramebuffer(self, framebuffer):\n        return self(\"glIsFramebuffer\", True, framebuffer)\n\n\n    def glIsProgram(self, program):\n        return self(\"glIsProgram\", True, program)\n\n\n    def glIsRenderbuffer(self, renderbuffer):\n        return self(\"glIsRenderbuffer\", True, renderbuffer)\n\n\n    def glIsShader(self, shader):\n        return self(\"glIsShader\", True, shader)\n\n\n    def glIsTexture(self, texture):\n        return self(\"glIsTexture\", True, texture)\n\n\n    def glLineWidth(self, width):\n        self(\"glLineWidth\", False, width)\n\n\n    def glLinkProgram(self, program):\n        self(\"glLinkProgram\", False, program)\n\n\n    def glPixelStorei(self, pname, param):\n        self(\"glPixelStorei\", False, pname, param)\n\n\n    def glPolygonOffset(self, factor, units):\n        self(\"glPolygonOffset\", False, factor, units)\n\n\n    def glReadPixels(self, x, y, width, height, format, type):\n        return self(\"glReadPixels\", True, x, y, width, height, format, type)\n\n\n    def glRenderbufferStorage(self, target, internalformat, width, height):\n        self(\"glRenderbufferStorage\", False, target, internalformat, width, height)\n\n\n    def glSampleCoverage(self, value, invert):\n        self(\"glSampleCoverage\", False, value, invert)\n\n\n    def glScissor(self, x, y, width, height):\n        self(\"glScissor\", False, x, y, width, height)\n\n\n    def glShaderSource(self, shader, source):\n        self(\"glShaderSource\", False, shader, source)\n\n\n    def glStencilFunc(self, func, ref, mask):\n        self(\"glStencilFunc\", False, func, ref, mask)\n\n\n    def glStencilFuncSeparate(self, face, func, ref, mask):\n        self(\"glStencilFuncSeparate\", False, face, func, ref, mask)\n\n\n    def glStencilMask(self, mask):\n        self(\"glStencilMask\", False, mask)\n\n\n    def glStencilMaskSeparate(self, face, mask):\n        self(\"glStencilMaskSeparate\", False, face, mask)\n\n\n    def glStencilOp(self, fail, zfail, zpass):\n        self(\"glStencilOp\", False, fail, zfail, zpass)\n\n\n    def glStencilOpSeparate(self, face, fail, zfail, zpass):\n        self(\"glStencilOpSeparate\", False, face, fail, zfail, zpass)\n\n\n    def glTexImage2D(self, target, level, internalformat, format, type, pixels):\n        self(\"glTexImage2D\", False, target, level, internalformat, format, type, pixels)\n\n\n    def glTexParameterf(self, target, pname, param):\n        self(\"glTexParameterf\", False, target, pname, param)\n    def glTexParameteri(self, target, pname, param):\n        self(\"glTexParameteri\", False, target, pname, param)\n\n\n    def glTexSubImage2D(self, target, level, xoffset, yoffset, format, type, pixels):\n        self(\"glTexSubImage2D\", False, target, level, xoffset, yoffset, format, type, pixels)\n\n\n    def glUniform1f(self, location, v1):\n        self(\"glUniform1f\", False, location, v1)\n    def glUniform2f(self, location, v1, v2):\n        self(\"glUniform2f\", False, location, v1, v2)\n    def glUniform3f(self, location, v1, v2, v3):\n        self(\"glUniform3f\", False, location, v1, v2, v3)\n    def glUniform4f(self, location, v1, v2, v3, v4):\n        self(\"glUniform4f\", False, location, v1, v2, v3, v4)\n    def glUniform1i(self, location, v1):\n        self(\"glUniform1i\", False, location, v1)\n    def glUniform2i(self, location, v1, v2):\n        self(\"glUniform2i\", False, location, v1, v2)\n    def glUniform3i(self, location, v1, v2, v3):\n        self(\"glUniform3i\", False, location, v1, v2, v3)\n    def glUniform4i(self, location, v1, v2, v3, v4):\n        self(\"glUniform4i\", False, location, v1, v2, v3, v4)\n    def glUniform1fv(self, location, count, values):\n        self(\"glUniform1fv\", False, location, count, values)\n    def glUniform2fv(self, location, count, values):\n        self(\"glUniform2fv\", False, location, count, values)\n    def glUniform3fv(self, location, count, values):\n        self(\"glUniform3fv\", False, location, count, values)\n    def glUniform4fv(self, location, count, values):\n        self(\"glUniform4fv\", False, location, count, values)\n    def glUniform1iv(self, location, count, values):\n        self(\"glUniform1iv\", False, location, count, values)\n    def glUniform2iv(self, location, count, values):\n        self(\"glUniform2iv\", False, location, count, values)\n    def glUniform3iv(self, location, count, values):\n        self(\"glUniform3iv\", False, location, count, values)\n    def glUniform4iv(self, location, count, values):\n        self(\"glUniform4iv\", False, location, count, values)\n\n\n    def glUniformMatrix2fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix2fv\", False, location, count, transpose, values)\n    def glUniformMatrix3fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix3fv\", False, location, count, transpose, values)\n    def glUniformMatrix4fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix4fv\", False, location, count, transpose, values)\n\n\n    def glUseProgram(self, program):\n        self(\"glUseProgram\", False, program)\n\n\n    def glValidateProgram(self, program):\n        self(\"glValidateProgram\", False, program)\n\n\n    def glVertexAttrib1f(self, index, v1):\n        self(\"glVertexAttrib1f\", False, index, v1)\n    def glVertexAttrib2f(self, index, v1, v2):\n        self(\"glVertexAttrib2f\", False, index, v1, v2)\n    def glVertexAttrib3f(self, index, v1, v2, v3):\n        self(\"glVertexAttrib3f\", False, index, v1, v2, v3)\n    def glVertexAttrib4f(self, index, v1, v2, v3, v4):\n        self(\"glVertexAttrib4f\", False, index, v1, v2, v3, v4)\n\n\n    def glVertexAttribPointer(self, indx, size, type, normalized, stride, offset):\n        self(\"glVertexAttribPointer\", False, indx, size, type, normalized, stride, offset)\n\n\n    def glViewport(self, x, y, width, height):\n        self(\"glViewport\", False, x, y, width, height)",
  "def __call__(self, funcname, returns, *args):\n        raise NotImplementedError()",
  "def glActiveTexture(self, texture):\n        self(\"glActiveTexture\", False, texture)",
  "def glAttachShader(self, program, shader):\n        self(\"glAttachShader\", False, program, shader)",
  "def glBindAttribLocation(self, program, index, name):\n        self(\"glBindAttribLocation\", False, program, index, name)",
  "def glBindBuffer(self, target, buffer):\n        self(\"glBindBuffer\", False, target, buffer)",
  "def glBindFramebuffer(self, target, framebuffer):\n        self(\"glBindFramebuffer\", False, target, framebuffer)",
  "def glBindRenderbuffer(self, target, renderbuffer):\n        self(\"glBindRenderbuffer\", False, target, renderbuffer)",
  "def glBindTexture(self, target, texture):\n        self(\"glBindTexture\", False, target, texture)",
  "def glBlendColor(self, red, green, blue, alpha):\n        self(\"glBlendColor\", False, red, green, blue, alpha)",
  "def glBlendEquation(self, mode):\n        self(\"glBlendEquation\", False, mode)",
  "def glBlendEquationSeparate(self, modeRGB, modeAlpha):\n        self(\"glBlendEquationSeparate\", False, modeRGB, modeAlpha)",
  "def glBlendFunc(self, sfactor, dfactor):\n        self(\"glBlendFunc\", False, sfactor, dfactor)",
  "def glBlendFuncSeparate(self, srcRGB, dstRGB, srcAlpha, dstAlpha):\n        self(\"glBlendFuncSeparate\", False, srcRGB, dstRGB, srcAlpha, dstAlpha)",
  "def glBufferData(self, target, data, usage):\n        self(\"glBufferData\", False, target, data, usage)",
  "def glBufferSubData(self, target, offset, data):\n        self(\"glBufferSubData\", False, target, offset, data)",
  "def glCheckFramebufferStatus(self, target):\n        return self(\"glCheckFramebufferStatus\", True, target)",
  "def glClear(self, mask):\n        self(\"glClear\", False, mask)",
  "def glClearColor(self, red, green, blue, alpha):\n        self(\"glClearColor\", False, red, green, blue, alpha)",
  "def glClearDepth(self, depth):\n        self(\"glClearDepth\", False, depth)",
  "def glClearStencil(self, s):\n        self(\"glClearStencil\", False, s)",
  "def glColorMask(self, red, green, blue, alpha):\n        self(\"glColorMask\", False, red, green, blue, alpha)",
  "def glCompileShader(self, shader):\n        self(\"glCompileShader\", False, shader)",
  "def glCompressedTexImage2D(self, target, level, internalformat, width, height, border, data):\n        self(\"glCompressedTexImage2D\", False, target, level, internalformat, width, height, border, data)",
  "def glCompressedTexSubImage2D(self, target, level, xoffset, yoffset, width, height, format, data):\n        self(\"glCompressedTexSubImage2D\", False, target, level, xoffset, yoffset, width, height, format, data)",
  "def glCopyTexImage2D(self, target, level, internalformat, x, y, width, height, border):\n        self(\"glCopyTexImage2D\", False, target, level, internalformat, x, y, width, height, border)",
  "def glCopyTexSubImage2D(self, target, level, xoffset, yoffset, x, y, width, height):\n        self(\"glCopyTexSubImage2D\", False, target, level, xoffset, yoffset, x, y, width, height)",
  "def glCreateProgram(self, ):\n        return self(\"glCreateProgram\", True, )",
  "def glCreateShader(self, type):\n        return self(\"glCreateShader\", True, type)",
  "def glCullFace(self, mode):\n        self(\"glCullFace\", False, mode)",
  "def glDeleteBuffer(self, buffer):\n        self(\"glDeleteBuffer\", False, buffer)",
  "def glDeleteFramebuffer(self, framebuffer):\n        self(\"glDeleteFramebuffer\", False, framebuffer)",
  "def glDeleteProgram(self, program):\n        self(\"glDeleteProgram\", False, program)",
  "def glDeleteRenderbuffer(self, renderbuffer):\n        self(\"glDeleteRenderbuffer\", False, renderbuffer)",
  "def glDeleteShader(self, shader):\n        self(\"glDeleteShader\", False, shader)",
  "def glDeleteTexture(self, texture):\n        self(\"glDeleteTexture\", False, texture)",
  "def glDepthFunc(self, func):\n        self(\"glDepthFunc\", False, func)",
  "def glDepthMask(self, flag):\n        self(\"glDepthMask\", False, flag)",
  "def glDepthRange(self, zNear, zFar):\n        self(\"glDepthRange\", False, zNear, zFar)",
  "def glDetachShader(self, program, shader):\n        self(\"glDetachShader\", False, program, shader)",
  "def glDisable(self, cap):\n        self(\"glDisable\", False, cap)",
  "def glDisableVertexAttribArray(self, index):\n        self(\"glDisableVertexAttribArray\", False, index)",
  "def glDrawArrays(self, mode, first, count):\n        self(\"glDrawArrays\", False, mode, first, count)",
  "def glDrawElements(self, mode, count, type, offset):\n        self(\"glDrawElements\", False, mode, count, type, offset)",
  "def glEnable(self, cap):\n        self(\"glEnable\", False, cap)",
  "def glEnableVertexAttribArray(self, index):\n        self(\"glEnableVertexAttribArray\", False, index)",
  "def glFinish(self, ):\n        self(\"glFinish\", False, )",
  "def glFlush(self, ):\n        self(\"glFlush\", False, )",
  "def glFramebufferRenderbuffer(self, target, attachment, renderbuffertarget, renderbuffer):\n        self(\"glFramebufferRenderbuffer\", False, target, attachment, renderbuffertarget, renderbuffer)",
  "def glFramebufferTexture2D(self, target, attachment, textarget, texture, level):\n        self(\"glFramebufferTexture2D\", False, target, attachment, textarget, texture, level)",
  "def glFrontFace(self, mode):\n        self(\"glFrontFace\", False, mode)",
  "def glCreateBuffer(self, ):\n        return self(\"glCreateBuffer\", True, )",
  "def glCreateFramebuffer(self, ):\n        return self(\"glCreateFramebuffer\", True, )",
  "def glCreateRenderbuffer(self, ):\n        return self(\"glCreateRenderbuffer\", True, )",
  "def glCreateTexture(self, ):\n        return self(\"glCreateTexture\", True, )",
  "def glGenerateMipmap(self, target):\n        self(\"glGenerateMipmap\", False, target)",
  "def glGetActiveAttrib(self, program, index):\n        return self(\"glGetActiveAttrib\", True, program, index)",
  "def glGetActiveUniform(self, program, index):\n        return self(\"glGetActiveUniform\", True, program, index)",
  "def glGetAttachedShaders(self, program):\n        return self(\"glGetAttachedShaders\", True, program)",
  "def glGetAttribLocation(self, program, name):\n        return self(\"glGetAttribLocation\", True, program, name)",
  "def _glGetBooleanv(self, pname):\n        self(\"_glGetBooleanv\", False, pname)",
  "def glGetBufferParameter(self, target, pname):\n        return self(\"glGetBufferParameter\", True, target, pname)",
  "def glGetError(self, ):\n        return self(\"glGetError\", True, )",
  "def _glGetFloatv(self, pname):\n        self(\"_glGetFloatv\", False, pname)",
  "def glGetFramebufferAttachmentParameter(self, target, attachment, pname):\n        return self(\"glGetFramebufferAttachmentParameter\", True, target, attachment, pname)",
  "def _glGetIntegerv(self, pname):\n        self(\"_glGetIntegerv\", False, pname)",
  "def glGetProgramInfoLog(self, program):\n        return self(\"glGetProgramInfoLog\", True, program)",
  "def glGetProgramParameter(self, program, pname):\n        return self(\"glGetProgramParameter\", True, program, pname)",
  "def glGetRenderbufferParameter(self, target, pname):\n        return self(\"glGetRenderbufferParameter\", True, target, pname)",
  "def glGetShaderInfoLog(self, shader):\n        return self(\"glGetShaderInfoLog\", True, shader)",
  "def glGetShaderPrecisionFormat(self, shadertype, precisiontype):\n        return self(\"glGetShaderPrecisionFormat\", True, shadertype, precisiontype)",
  "def glGetShaderSource(self, shader):\n        return self(\"glGetShaderSource\", True, shader)",
  "def glGetShaderParameter(self, shader, pname):\n        return self(\"glGetShaderParameter\", True, shader, pname)",
  "def glGetParameter(self, pname):\n        return self(\"glGetParameter\", True, pname)",
  "def glGetTexParameter(self, target, pname):\n        return self(\"glGetTexParameter\", True, target, pname)",
  "def glGetUniform(self, program, location):\n        return self(\"glGetUniform\", True, program, location)",
  "def glGetUniformLocation(self, program, name):\n        return self(\"glGetUniformLocation\", True, program, name)",
  "def glGetVertexAttrib(self, index, pname):\n        return self(\"glGetVertexAttrib\", True, index, pname)",
  "def glGetVertexAttribOffset(self, index, pname):\n        return self(\"glGetVertexAttribOffset\", True, index, pname)",
  "def glHint(self, target, mode):\n        self(\"glHint\", False, target, mode)",
  "def glIsBuffer(self, buffer):\n        return self(\"glIsBuffer\", True, buffer)",
  "def glIsEnabled(self, cap):\n        return self(\"glIsEnabled\", True, cap)",
  "def glIsFramebuffer(self, framebuffer):\n        return self(\"glIsFramebuffer\", True, framebuffer)",
  "def glIsProgram(self, program):\n        return self(\"glIsProgram\", True, program)",
  "def glIsRenderbuffer(self, renderbuffer):\n        return self(\"glIsRenderbuffer\", True, renderbuffer)",
  "def glIsShader(self, shader):\n        return self(\"glIsShader\", True, shader)",
  "def glIsTexture(self, texture):\n        return self(\"glIsTexture\", True, texture)",
  "def glLineWidth(self, width):\n        self(\"glLineWidth\", False, width)",
  "def glLinkProgram(self, program):\n        self(\"glLinkProgram\", False, program)",
  "def glPixelStorei(self, pname, param):\n        self(\"glPixelStorei\", False, pname, param)",
  "def glPolygonOffset(self, factor, units):\n        self(\"glPolygonOffset\", False, factor, units)",
  "def glReadPixels(self, x, y, width, height, format, type):\n        return self(\"glReadPixels\", True, x, y, width, height, format, type)",
  "def glRenderbufferStorage(self, target, internalformat, width, height):\n        self(\"glRenderbufferStorage\", False, target, internalformat, width, height)",
  "def glSampleCoverage(self, value, invert):\n        self(\"glSampleCoverage\", False, value, invert)",
  "def glScissor(self, x, y, width, height):\n        self(\"glScissor\", False, x, y, width, height)",
  "def glShaderSource(self, shader, source):\n        self(\"glShaderSource\", False, shader, source)",
  "def glStencilFunc(self, func, ref, mask):\n        self(\"glStencilFunc\", False, func, ref, mask)",
  "def glStencilFuncSeparate(self, face, func, ref, mask):\n        self(\"glStencilFuncSeparate\", False, face, func, ref, mask)",
  "def glStencilMask(self, mask):\n        self(\"glStencilMask\", False, mask)",
  "def glStencilMaskSeparate(self, face, mask):\n        self(\"glStencilMaskSeparate\", False, face, mask)",
  "def glStencilOp(self, fail, zfail, zpass):\n        self(\"glStencilOp\", False, fail, zfail, zpass)",
  "def glStencilOpSeparate(self, face, fail, zfail, zpass):\n        self(\"glStencilOpSeparate\", False, face, fail, zfail, zpass)",
  "def glTexImage2D(self, target, level, internalformat, format, type, pixels):\n        self(\"glTexImage2D\", False, target, level, internalformat, format, type, pixels)",
  "def glTexParameterf(self, target, pname, param):\n        self(\"glTexParameterf\", False, target, pname, param)",
  "def glTexParameteri(self, target, pname, param):\n        self(\"glTexParameteri\", False, target, pname, param)",
  "def glTexSubImage2D(self, target, level, xoffset, yoffset, format, type, pixels):\n        self(\"glTexSubImage2D\", False, target, level, xoffset, yoffset, format, type, pixels)",
  "def glUniform1f(self, location, v1):\n        self(\"glUniform1f\", False, location, v1)",
  "def glUniform2f(self, location, v1, v2):\n        self(\"glUniform2f\", False, location, v1, v2)",
  "def glUniform3f(self, location, v1, v2, v3):\n        self(\"glUniform3f\", False, location, v1, v2, v3)",
  "def glUniform4f(self, location, v1, v2, v3, v4):\n        self(\"glUniform4f\", False, location, v1, v2, v3, v4)",
  "def glUniform1i(self, location, v1):\n        self(\"glUniform1i\", False, location, v1)",
  "def glUniform2i(self, location, v1, v2):\n        self(\"glUniform2i\", False, location, v1, v2)",
  "def glUniform3i(self, location, v1, v2, v3):\n        self(\"glUniform3i\", False, location, v1, v2, v3)",
  "def glUniform4i(self, location, v1, v2, v3, v4):\n        self(\"glUniform4i\", False, location, v1, v2, v3, v4)",
  "def glUniform1fv(self, location, count, values):\n        self(\"glUniform1fv\", False, location, count, values)",
  "def glUniform2fv(self, location, count, values):\n        self(\"glUniform2fv\", False, location, count, values)",
  "def glUniform3fv(self, location, count, values):\n        self(\"glUniform3fv\", False, location, count, values)",
  "def glUniform4fv(self, location, count, values):\n        self(\"glUniform4fv\", False, location, count, values)",
  "def glUniform1iv(self, location, count, values):\n        self(\"glUniform1iv\", False, location, count, values)",
  "def glUniform2iv(self, location, count, values):\n        self(\"glUniform2iv\", False, location, count, values)",
  "def glUniform3iv(self, location, count, values):\n        self(\"glUniform3iv\", False, location, count, values)",
  "def glUniform4iv(self, location, count, values):\n        self(\"glUniform4iv\", False, location, count, values)",
  "def glUniformMatrix2fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix2fv\", False, location, count, transpose, values)",
  "def glUniformMatrix3fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix3fv\", False, location, count, transpose, values)",
  "def glUniformMatrix4fv(self, location, count, transpose, values):\n        self(\"glUniformMatrix4fv\", False, location, count, transpose, values)",
  "def glUseProgram(self, program):\n        self(\"glUseProgram\", False, program)",
  "def glValidateProgram(self, program):\n        self(\"glValidateProgram\", False, program)",
  "def glVertexAttrib1f(self, index, v1):\n        self(\"glVertexAttrib1f\", False, index, v1)",
  "def glVertexAttrib2f(self, index, v1, v2):\n        self(\"glVertexAttrib2f\", False, index, v1, v2)",
  "def glVertexAttrib3f(self, index, v1, v2, v3):\n        self(\"glVertexAttrib3f\", False, index, v1, v2, v3)",
  "def glVertexAttrib4f(self, index, v1, v2, v3, v4):\n        self(\"glVertexAttrib4f\", False, index, v1, v2, v3, v4)",
  "def glVertexAttribPointer(self, indx, size, type, normalized, stride, offset):\n        self(\"glVertexAttribPointer\", False, indx, size, type, normalized, stride, offset)",
  "def glViewport(self, x, y, width, height):\n        self(\"glViewport\", False, x, y, width, height)",
  "def glActiveTexture(texture):\n    _lib.glActiveTexture(texture)",
  "def glAttachShader(program, shader):\n    _lib.glAttachShader(program, shader)",
  "def glBindAttribLocation(program, index, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    res = _lib.glBindAttribLocation(program, index, name)",
  "def glBindBuffer(target, buffer):\n    _lib.glBindBuffer(target, buffer)",
  "def glBindFramebuffer(target, framebuffer):\n    _lib.glBindFramebuffer(target, framebuffer)",
  "def glBindRenderbuffer(target, renderbuffer):\n    _lib.glBindRenderbuffer(target, renderbuffer)",
  "def glBindTexture(target, texture):\n    _lib.glBindTexture(target, texture)",
  "def glBlendColor(red, green, blue, alpha):\n    _lib.glBlendColor(red, green, blue, alpha)",
  "def glBlendEquation(mode):\n    _lib.glBlendEquation(mode)",
  "def glBlendEquationSeparate(modeRGB, modeAlpha):\n    _lib.glBlendEquationSeparate(modeRGB, modeAlpha)",
  "def glBlendFunc(sfactor, dfactor):\n    _lib.glBlendFunc(sfactor, dfactor)",
  "def glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha):\n    _lib.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)",
  "def glBufferData(target, data, usage):\n    \"\"\"Data can be numpy array or the size of data to allocate.\"\"\"\n    if isinstance(data, int):\n        size = data\n        data = ctypes.c_voidp(0)\n    else:\n        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:\n            data = data.copy('C')\n        data_ = data\n        size = data_.nbytes\n        data = data_.ctypes.data\n    res = _lib.glBufferData(target, size, data, usage)",
  "def glBufferSubData(target, offset, data):\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.nbytes\n    data = data_.ctypes.data\n    res = _lib.glBufferSubData(target, offset, size, data)",
  "def glCheckFramebufferStatus(target):\n    return _lib.glCheckFramebufferStatus(target)",
  "def glClear(mask):\n    _lib.glClear(mask)",
  "def glClearColor(red, green, blue, alpha):\n    _lib.glClearColor(red, green, blue, alpha)",
  "def glClearDepth(depth):\n    _lib.glClearDepthf(depth)",
  "def glClearStencil(s):\n    _lib.glClearStencil(s)",
  "def glColorMask(red, green, blue, alpha):\n    _lib.glColorMask(red, green, blue, alpha)",
  "def glCompileShader(shader):\n    _lib.glCompileShader(shader)",
  "def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):\n    # border = 0  # set in args\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    res = _lib.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data)",
  "def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    res = _lib.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data)",
  "def glCopyTexImage2D(target, level, internalformat, x, y, width, height, border):\n    _lib.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border)",
  "def glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height):\n    _lib.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height)",
  "def glCreateProgram():\n    return _lib.glCreateProgram()",
  "def glCreateShader(type):\n    return _lib.glCreateShader(type)",
  "def glCullFace(mode):\n    _lib.glCullFace(mode)",
  "def glDeleteBuffer(buffer):\n    n = 1\n    buffers = (ctypes.c_uint*n)(buffer)\n    res = _lib.glDeleteBuffers(n, buffers)",
  "def glDeleteFramebuffer(framebuffer):\n    n = 1\n    framebuffers = (ctypes.c_uint*n)(framebuffer)\n    res = _lib.glDeleteFramebuffers(n, framebuffers)",
  "def glDeleteProgram(program):\n    _lib.glDeleteProgram(program)",
  "def glDeleteRenderbuffer(renderbuffer):\n    n = 1\n    renderbuffers = (ctypes.c_uint*n)(renderbuffer)\n    res = _lib.glDeleteRenderbuffers(n, renderbuffers)",
  "def glDeleteShader(shader):\n    _lib.glDeleteShader(shader)",
  "def glDeleteTexture(texture):\n    n = 1\n    textures = (ctypes.c_uint*n)(texture)\n    res = _lib.glDeleteTextures(n, textures)",
  "def glDepthFunc(func):\n    _lib.glDepthFunc(func)",
  "def glDepthMask(flag):\n    _lib.glDepthMask(flag)",
  "def glDepthRange(zNear, zFar):\n    _lib.glDepthRangef(zNear, zFar)",
  "def glDetachShader(program, shader):\n    _lib.glDetachShader(program, shader)",
  "def glDisable(cap):\n    _lib.glDisable(cap)",
  "def glDisableVertexAttribArray(index):\n    _lib.glDisableVertexAttribArray(index)",
  "def glDrawArrays(mode, first, count):\n    _lib.glDrawArrays(mode, first, count)",
  "def glDrawElements(mode, count, type, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n    indices = offset\n    res = _lib.glDrawElements(mode, count, type, indices)",
  "def glEnable(cap):\n    _lib.glEnable(cap)",
  "def glEnableVertexAttribArray(index):\n    _lib.glEnableVertexAttribArray(index)",
  "def glFinish():\n    _lib.glFinish()",
  "def glFlush():\n    _lib.glFlush()",
  "def glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer):\n    _lib.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)",
  "def glFramebufferTexture2D(target, attachment, textarget, texture, level):\n    _lib.glFramebufferTexture2D(target, attachment, textarget, texture, level)",
  "def glFrontFace(mode):\n    _lib.glFrontFace(mode)",
  "def glCreateBuffer():\n    n = 1\n    buffers = (ctypes.c_uint*n)()\n    res = _lib.glGenBuffers(n, buffers)\n    return buffers[0]",
  "def glCreateFramebuffer():\n    n = 1\n    framebuffers = (ctypes.c_uint*n)()\n    res = _lib.glGenFramebuffers(n, framebuffers)\n    return framebuffers[0]",
  "def glCreateRenderbuffer():\n    n = 1\n    renderbuffers = (ctypes.c_uint*n)()\n    res = _lib.glGenRenderbuffers(n, renderbuffers)\n    return renderbuffers[0]",
  "def glCreateTexture():\n    n = 1\n    textures = (ctypes.c_uint*n)()\n    res = _lib.glGenTextures(n, textures)\n    return textures[0]",
  "def glGenerateMipmap(target):\n    _lib.glGenerateMipmap(target)",
  "def glGetActiveAttrib(program, index):\n    bufsize = 256\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    res = _lib.glGetActiveAttrib(program, index, bufsize, length, size, type, name)\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]",
  "def glGetActiveUniform(program, index):\n    bufsize = 256\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    res = _lib.glGetActiveUniform(program, index, bufsize, length, size, type, name)\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]",
  "def glGetAttachedShaders(program):\n    maxcount = 256\n    count = (ctypes.c_int*1)()\n    shaders = (ctypes.c_uint*maxcount)()\n    res = _lib.glGetAttachedShaders(program, maxcount, count, shaders)\n    return tuple(shaders[:count[0]])",
  "def glGetAttribLocation(program, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    res = _lib.glGetAttribLocation(program, name)\n    return res",
  "def _glGetBooleanv(pname):\n    params = (ctypes.c_bool*1)()\n    res = _lib.glGetBooleanv(pname, params)\n    return params[0]",
  "def glGetBufferParameter(target, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    res = _lib.glGetBufferParameteriv(target, pname, params)\n    return params[0]",
  "def glGetError():\n    return _lib.glGetError()",
  "def _glGetFloatv(pname):\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    res = _lib.glGetFloatv(pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetFramebufferAttachmentParameter(target, attachment, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    res = _lib.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)\n    return params[0]",
  "def _glGetIntegerv(pname):\n    n = 16\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*n)(*[d for i in range(n)])\n    res = _lib.glGetIntegerv(pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetProgramInfoLog(program):\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    res = _lib.glGetProgramInfoLog(program, bufsize, length, infolog)\n    return infolog[:length[0]].decode('utf-8')",
  "def glGetProgramParameter(program, pname):\n    params = (ctypes.c_int*1)()\n    res = _lib.glGetProgramiv(program, pname, params)\n    return params[0]",
  "def glGetRenderbufferParameter(target, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    res = _lib.glGetRenderbufferParameteriv(target, pname, params)\n    return params[0]",
  "def glGetShaderInfoLog(shader):\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    res = _lib.glGetShaderInfoLog(shader, bufsize, length, infolog)\n    return infolog[:length[0]].decode('utf-8')",
  "def glGetShaderPrecisionFormat(shadertype, precisiontype):\n    range = (ctypes.c_int*1)()\n    precision = (ctypes.c_int*1)()\n    res = _lib.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision)\n    return range[0], precision[0]",
  "def glGetShaderSource(shader):\n    bufsize = 1024*1024\n    length = (ctypes.c_int*1)()\n    source = (ctypes.c_char*bufsize)()\n    res = _lib.glGetShaderSource(shader, bufsize, length, source)\n    return source.value[:length[0]].decode('utf-8')",
  "def glGetShaderParameter(shader, pname):\n    params = (ctypes.c_int*1)()\n    res = _lib.glGetShaderiv(shader, pname, params)\n    return params[0]",
  "def glGetParameter(pname):\n    if pname in [33902, 33901, 32773, 3106, 2931, 2928,\n                 2849, 32824, 10752, 32938]:\n        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE\n        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE\n        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR\n        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE\n        return _glGetFloatv(pname)\n    elif pname in [7936, 7937, 7938, 35724, 7939]:\n        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,\n        # GL_EXTENSIONS are strings\n        pass  # string handled below\n    else:\n        return _glGetIntegerv(pname)\n    name = pname\n    res = _lib.glGetString(name)\n    return ctypes.string_at(res).decode('utf-8') if res else ''",
  "def glGetTexParameter(target, pname):\n    d = float('Inf')\n    params = (ctypes.c_float*1)(d)\n    res = _lib.glGetTexParameterfv(target, pname, params)\n    return params[0]",
  "def glGetUniform(program, location):\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    res = _lib.glGetUniformfv(program, location, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetUniformLocation(program, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    res = _lib.glGetUniformLocation(program, name)\n    return res",
  "def glGetVertexAttrib(index, pname):\n    n = 4\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    res = _lib.glGetVertexAttribfv(index, pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetVertexAttribOffset(index, pname):\n    pointer = (ctypes.c_void_p*1)()\n    res = _lib.glGetVertexAttribPointerv(index, pname, pointer)\n    return pointer[0] or 0",
  "def glHint(target, mode):\n    _lib.glHint(target, mode)",
  "def glIsBuffer(buffer):\n    return _lib.glIsBuffer(buffer)",
  "def glIsEnabled(cap):\n    return _lib.glIsEnabled(cap)",
  "def glIsFramebuffer(framebuffer):\n    return _lib.glIsFramebuffer(framebuffer)",
  "def glIsProgram(program):\n    return _lib.glIsProgram(program)",
  "def glIsRenderbuffer(renderbuffer):\n    return _lib.glIsRenderbuffer(renderbuffer)",
  "def glIsShader(shader):\n    return _lib.glIsShader(shader)",
  "def glIsTexture(texture):\n    return _lib.glIsTexture(texture)",
  "def glLineWidth(width):\n    _lib.glLineWidth(width)",
  "def glLinkProgram(program):\n    _lib.glLinkProgram(program)",
  "def glPixelStorei(pname, param):\n    _lib.glPixelStorei(pname, param)",
  "def glPolygonOffset(factor, units):\n    _lib.glPolygonOffset(factor, units)",
  "def glReadPixels(x, y, width, height, format, type):\n    # GL_ALPHA, GL_RGB, GL_RGBA\n    t = {6406:1, 6407:3, 6408:4}[format]\n    # GL_UNSIGNED_BYTE, GL_FLOAT\n    nb = {5121:1, 5126:4}[type]\n    size = int(width*height*t*nb)\n    pixels = ctypes.create_string_buffer(size)\n    res = _lib.glReadPixels(x, y, width, height, format, type, pixels)\n    return pixels[:]",
  "def glRenderbufferStorage(target, internalformat, width, height):\n    _lib.glRenderbufferStorage(target, internalformat, width, height)",
  "def glSampleCoverage(value, invert):\n    _lib.glSampleCoverage(value, invert)",
  "def glScissor(x, y, width, height):\n    _lib.glScissor(x, y, width, height)",
  "def glShaderSource(shader, source):\n    # Some implementation do not like getting a list of single chars\n    if isinstance(source, (tuple, list)):\n        strings = [s for s in source]\n    else:\n        strings = [source]\n    count = len(strings)\n    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])\n    length = (ctypes.c_int*count)(*[len(s) for s in strings])\n    res = _lib.glShaderSource(shader, count, string, length)",
  "def glStencilFunc(func, ref, mask):\n    _lib.glStencilFunc(func, ref, mask)",
  "def glStencilFuncSeparate(face, func, ref, mask):\n    _lib.glStencilFuncSeparate(face, func, ref, mask)",
  "def glStencilMask(mask):\n    _lib.glStencilMask(mask)",
  "def glStencilMaskSeparate(face, mask):\n    _lib.glStencilMaskSeparate(face, mask)",
  "def glStencilOp(fail, zfail, zpass):\n    _lib.glStencilOp(fail, zfail, zpass)",
  "def glStencilOpSeparate(face, fail, zfail, zpass):\n    _lib.glStencilOpSeparate(face, fail, zfail, zpass)",
  "def glTexImage2D(target, level, internalformat, format, type, pixels):\n    border = 0\n    if isinstance(pixels, (tuple, list)):\n        height, width = pixels\n        pixels = ctypes.c_void_p(0)\n        pixels = None\n    else:\n        if not pixels.flags['C_CONTIGUOUS']:\n            pixels = pixels.copy('C')\n        pixels_ = pixels\n        pixels = pixels_.ctypes.data\n        height, width = pixels_.shape[:2]\n    res = _lib.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)",
  "def glTexParameterf(target, pname, param):\n    _lib.glTexParameterf(target, pname, param)",
  "def glTexParameteri(target, pname, param):\n    _lib.glTexParameteri(target, pname, param)",
  "def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):\n    if not pixels.flags['C_CONTIGUOUS']:\n        pixels = pixels.copy('C')\n    pixels_ = pixels\n    pixels = pixels_.ctypes.data\n    height, width = pixels_.shape[:2]\n    res = _lib.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)",
  "def glUniform1f(location, v1):\n    _lib.glUniform1f(location, v1)",
  "def glUniform2f(location, v1, v2):\n    _lib.glUniform2f(location, v1, v2)",
  "def glUniform3f(location, v1, v2, v3):\n    _lib.glUniform3f(location, v1, v2, v3)",
  "def glUniform4f(location, v1, v2, v3, v4):\n    _lib.glUniform4f(location, v1, v2, v3, v4)",
  "def glUniform1i(location, v1):\n    _lib.glUniform1i(location, v1)",
  "def glUniform2i(location, v1, v2):\n    _lib.glUniform2i(location, v1, v2)",
  "def glUniform3i(location, v1, v2, v3):\n    _lib.glUniform3i(location, v1, v2, v3)",
  "def glUniform4i(location, v1, v2, v3, v4):\n    _lib.glUniform4i(location, v1, v2, v3, v4)",
  "def glUniform1fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    _lib.glUniform1fv(location, count, values)",
  "def glUniform2fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    _lib.glUniform2fv(location, count, values)",
  "def glUniform3fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    _lib.glUniform3fv(location, count, values)",
  "def glUniform4fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    _lib.glUniform4fv(location, count, values)",
  "def glUniform1iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    _lib.glUniform1iv(location, count, values)",
  "def glUniform2iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    _lib.glUniform2iv(location, count, values)",
  "def glUniform3iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    _lib.glUniform3iv(location, count, values)",
  "def glUniform4iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    _lib.glUniform4iv(location, count, values)",
  "def glUniformMatrix2fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    _lib.glUniformMatrix2fv(location, count, transpose, values)",
  "def glUniformMatrix3fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    _lib.glUniformMatrix3fv(location, count, transpose, values)",
  "def glUniformMatrix4fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    _lib.glUniformMatrix4fv(location, count, transpose, values)",
  "def glUseProgram(program):\n    _lib.glUseProgram(program)",
  "def glValidateProgram(program):\n    _lib.glValidateProgram(program)",
  "def glVertexAttrib1f(index, v1):\n    _lib.glVertexAttrib1f(index, v1)",
  "def glVertexAttrib2f(index, v1, v2):\n    _lib.glVertexAttrib2f(index, v1, v2)",
  "def glVertexAttrib3f(index, v1, v2, v3):\n    _lib.glVertexAttrib3f(index, v1, v2, v3)",
  "def glVertexAttrib4f(index, v1, v2, v3, v4):\n    _lib.glVertexAttrib4f(index, v1, v2, v3, v4)",
  "def glVertexAttribPointer(indx, size, type, normalized, stride, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n        # We need to ensure that the data exists at draw time :(\n        # PyOpenGL does this too\n        key = '_vert_attr_'+str(indx)\n        setattr(glVertexAttribPointer, key, offset_)\n    ptr = offset\n    res = _lib.glVertexAttribPointer(indx, size, type, normalized, stride, ptr)",
  "def glViewport(x, y, width, height):\n    _lib.glViewport(x, y, width, height)",
  "def _have_context():\n    return _lib.glGetError() != 1282",
  "def _get_gl_version(_lib):\n    \"\"\"Helper to get the GL version string\"\"\"\n    try:\n        return _lib.glGetString(7938).decode('utf-8')\n    except Exception:\n        return 'unknown'",
  "def _get_gl_func(name, restype, argtypes):\n    # Based on a function in Pyglet\n    if _lib is None:\n        raise RuntimeError('Could not load OpenGL library, gl cannot be used')\n    try:\n        # Try using normal ctypes stuff\n        func = getattr(_lib, name)\n        func.restype = restype\n        func.argtypes = argtypes\n        return func\n    except AttributeError:\n        if sys.platform.startswith('win'):\n            # Ask for a pointer to the function, this is the approach\n            # for OpenGL extensions on Windows\n            fargs = (restype,) + argtypes\n            ftype = ctypes.WINFUNCTYPE(*fargs)\n            if not _have_get_proc_address:\n                raise RuntimeError('Function %s not available '\n                                   '(OpenGL version is %s).'\n                                   % (name, _get_gl_version(_lib)))\n            if not _have_context():\n                raise RuntimeError('Using %s with no OpenGL context.' % name)\n            address = wglGetProcAddress(name.encode('utf-8'))\n            if address:\n                return ctypes.cast(address, ftype)\n        # If not Windows or if we did not return function object on Windows:\n        raise RuntimeError('Function %s not present in context '\n                           '(OpenGL version is %s).'\n                           % (name, _get_gl_version(_lib)))",
  "def glActiveTexture(texture):\n    try:\n        nativefunc = glActiveTexture._native\n    except AttributeError:\n        nativefunc = glActiveTexture._native = _get_gl_func(\"glActiveTexture\", None, (ctypes.c_uint,))\n    nativefunc(texture)",
  "def glAttachShader(program, shader):\n    try:\n        nativefunc = glAttachShader._native\n    except AttributeError:\n        nativefunc = glAttachShader._native = _get_gl_func(\"glAttachShader\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(program, shader)",
  "def glBindAttribLocation(program, index, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    try:\n        nativefunc = glBindAttribLocation._native\n    except AttributeError:\n        nativefunc = glBindAttribLocation._native = _get_gl_func(\"glBindAttribLocation\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_char_p,))\n    res = nativefunc(program, index, name)",
  "def glBindBuffer(target, buffer):\n    try:\n        nativefunc = glBindBuffer._native\n    except AttributeError:\n        nativefunc = glBindBuffer._native = _get_gl_func(\"glBindBuffer\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, buffer)",
  "def glBindFramebuffer(target, framebuffer):\n    try:\n        nativefunc = glBindFramebuffer._native\n    except AttributeError:\n        nativefunc = glBindFramebuffer._native = _get_gl_func(\"glBindFramebuffer\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, framebuffer)",
  "def glBindRenderbuffer(target, renderbuffer):\n    try:\n        nativefunc = glBindRenderbuffer._native\n    except AttributeError:\n        nativefunc = glBindRenderbuffer._native = _get_gl_func(\"glBindRenderbuffer\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, renderbuffer)",
  "def glBindTexture(target, texture):\n    try:\n        nativefunc = glBindTexture._native\n    except AttributeError:\n        nativefunc = glBindTexture._native = _get_gl_func(\"glBindTexture\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, texture)",
  "def glBlendColor(red, green, blue, alpha):\n    try:\n        nativefunc = glBlendColor._native\n    except AttributeError:\n        nativefunc = glBlendColor._native = _get_gl_func(\"glBlendColor\", None, (ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(red, green, blue, alpha)",
  "def glBlendEquation(mode):\n    try:\n        nativefunc = glBlendEquation._native\n    except AttributeError:\n        nativefunc = glBlendEquation._native = _get_gl_func(\"glBlendEquation\", None, (ctypes.c_uint,))\n    nativefunc(mode)",
  "def glBlendEquationSeparate(modeRGB, modeAlpha):\n    try:\n        nativefunc = glBlendEquationSeparate._native\n    except AttributeError:\n        nativefunc = glBlendEquationSeparate._native = _get_gl_func(\"glBlendEquationSeparate\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(modeRGB, modeAlpha)",
  "def glBlendFunc(sfactor, dfactor):\n    try:\n        nativefunc = glBlendFunc._native\n    except AttributeError:\n        nativefunc = glBlendFunc._native = _get_gl_func(\"glBlendFunc\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(sfactor, dfactor)",
  "def glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha):\n    try:\n        nativefunc = glBlendFuncSeparate._native\n    except AttributeError:\n        nativefunc = glBlendFuncSeparate._native = _get_gl_func(\"glBlendFuncSeparate\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(srcRGB, dstRGB, srcAlpha, dstAlpha)",
  "def glBufferData(target, data, usage):\n    \"\"\"Data can be numpy array or the size of data to allocate.\"\"\"\n    if isinstance(data, int):\n        size = data\n        data = ctypes.c_voidp(0)\n    else:\n        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:\n            data = data.copy('C')\n        data_ = data\n        size = data_.nbytes\n        data = data_.ctypes.data\n    try:\n        nativefunc = glBufferData._native\n    except AttributeError:\n        nativefunc = glBufferData._native = _get_gl_func(\"glBufferData\", None, (ctypes.c_uint, ctypes.c_ssize_t, ctypes.c_void_p, ctypes.c_uint,))\n    res = nativefunc(target, size, data, usage)",
  "def glBufferSubData(target, offset, data):\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.nbytes\n    data = data_.ctypes.data\n    try:\n        nativefunc = glBufferSubData._native\n    except AttributeError:\n        nativefunc = glBufferSubData._native = _get_gl_func(\"glBufferSubData\", None, (ctypes.c_uint, ctypes.c_ssize_t, ctypes.c_ssize_t, ctypes.c_void_p,))\n    res = nativefunc(target, offset, size, data)",
  "def glCheckFramebufferStatus(target):\n    try:\n        nativefunc = glCheckFramebufferStatus._native\n    except AttributeError:\n        nativefunc = glCheckFramebufferStatus._native = _get_gl_func(\"glCheckFramebufferStatus\", ctypes.c_uint, (ctypes.c_uint,))\n    return nativefunc(target)",
  "def glClear(mask):\n    try:\n        nativefunc = glClear._native\n    except AttributeError:\n        nativefunc = glClear._native = _get_gl_func(\"glClear\", None, (ctypes.c_uint,))\n    nativefunc(mask)",
  "def glClearColor(red, green, blue, alpha):\n    try:\n        nativefunc = glClearColor._native\n    except AttributeError:\n        nativefunc = glClearColor._native = _get_gl_func(\"glClearColor\", None, (ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(red, green, blue, alpha)",
  "def glClearDepth(depth):\n    try:\n        nativefunc = glClearDepth._native\n    except AttributeError:\n        nativefunc = glClearDepth._native = _get_gl_func(\"glClearDepth\", None, (ctypes.c_double,))\n    nativefunc(depth)",
  "def glClearStencil(s):\n    try:\n        nativefunc = glClearStencil._native\n    except AttributeError:\n        nativefunc = glClearStencil._native = _get_gl_func(\"glClearStencil\", None, (ctypes.c_int,))\n    nativefunc(s)",
  "def glColorMask(red, green, blue, alpha):\n    try:\n        nativefunc = glColorMask._native\n    except AttributeError:\n        nativefunc = glColorMask._native = _get_gl_func(\"glColorMask\", None, (ctypes.c_bool, ctypes.c_bool, ctypes.c_bool, ctypes.c_bool,))\n    nativefunc(red, green, blue, alpha)",
  "def glCompileShader(shader):\n    try:\n        nativefunc = glCompileShader._native\n    except AttributeError:\n        nativefunc = glCompileShader._native = _get_gl_func(\"glCompileShader\", None, (ctypes.c_uint,))\n    nativefunc(shader)",
  "def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):\n    # border = 0  # set in args\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    try:\n        nativefunc = glCompressedTexImage2D._native\n    except AttributeError:\n        nativefunc = glCompressedTexImage2D._native = _get_gl_func(\"glCompressedTexImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_void_p,))\n    res = nativefunc(target, level, internalformat, width, height, border, imageSize, data)",
  "def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    try:\n        nativefunc = glCompressedTexSubImage2D._native\n    except AttributeError:\n        nativefunc = glCompressedTexSubImage2D._native = _get_gl_func(\"glCompressedTexSubImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_void_p,))\n    res = nativefunc(target, level, xoffset, yoffset, width, height, format, imageSize, data)",
  "def glCopyTexImage2D(target, level, internalformat, x, y, width, height, border):\n    try:\n        nativefunc = glCopyTexImage2D._native\n    except AttributeError:\n        nativefunc = glCopyTexImage2D._native = _get_gl_func(\"glCopyTexImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(target, level, internalformat, x, y, width, height, border)",
  "def glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height):\n    try:\n        nativefunc = glCopyTexSubImage2D._native\n    except AttributeError:\n        nativefunc = glCopyTexSubImage2D._native = _get_gl_func(\"glCopyTexSubImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(target, level, xoffset, yoffset, x, y, width, height)",
  "def glCreateProgram():\n    try:\n        nativefunc = glCreateProgram._native\n    except AttributeError:\n        nativefunc = glCreateProgram._native = _get_gl_func(\"glCreateProgram\", ctypes.c_uint, ())\n    return nativefunc()",
  "def glCreateShader(type):\n    try:\n        nativefunc = glCreateShader._native\n    except AttributeError:\n        nativefunc = glCreateShader._native = _get_gl_func(\"glCreateShader\", ctypes.c_uint, (ctypes.c_uint,))\n    return nativefunc(type)",
  "def glCullFace(mode):\n    try:\n        nativefunc = glCullFace._native\n    except AttributeError:\n        nativefunc = glCullFace._native = _get_gl_func(\"glCullFace\", None, (ctypes.c_uint,))\n    nativefunc(mode)",
  "def glDeleteBuffer(buffer):\n    n = 1\n    buffers = (ctypes.c_uint*n)(buffer)\n    try:\n        nativefunc = glDeleteBuffer._native\n    except AttributeError:\n        nativefunc = glDeleteBuffer._native = _get_gl_func(\"glDeleteBuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, buffers)",
  "def glDeleteFramebuffer(framebuffer):\n    n = 1\n    framebuffers = (ctypes.c_uint*n)(framebuffer)\n    try:\n        nativefunc = glDeleteFramebuffer._native\n    except AttributeError:\n        nativefunc = glDeleteFramebuffer._native = _get_gl_func(\"glDeleteFramebuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, framebuffers)",
  "def glDeleteProgram(program):\n    try:\n        nativefunc = glDeleteProgram._native\n    except AttributeError:\n        nativefunc = glDeleteProgram._native = _get_gl_func(\"glDeleteProgram\", None, (ctypes.c_uint,))\n    nativefunc(program)",
  "def glDeleteRenderbuffer(renderbuffer):\n    n = 1\n    renderbuffers = (ctypes.c_uint*n)(renderbuffer)\n    try:\n        nativefunc = glDeleteRenderbuffer._native\n    except AttributeError:\n        nativefunc = glDeleteRenderbuffer._native = _get_gl_func(\"glDeleteRenderbuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, renderbuffers)",
  "def glDeleteShader(shader):\n    try:\n        nativefunc = glDeleteShader._native\n    except AttributeError:\n        nativefunc = glDeleteShader._native = _get_gl_func(\"glDeleteShader\", None, (ctypes.c_uint,))\n    nativefunc(shader)",
  "def glDeleteTexture(texture):\n    n = 1\n    textures = (ctypes.c_uint*n)(texture)\n    try:\n        nativefunc = glDeleteTexture._native\n    except AttributeError:\n        nativefunc = glDeleteTexture._native = _get_gl_func(\"glDeleteTextures\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, textures)",
  "def glDepthFunc(func):\n    try:\n        nativefunc = glDepthFunc._native\n    except AttributeError:\n        nativefunc = glDepthFunc._native = _get_gl_func(\"glDepthFunc\", None, (ctypes.c_uint,))\n    nativefunc(func)",
  "def glDepthMask(flag):\n    try:\n        nativefunc = glDepthMask._native\n    except AttributeError:\n        nativefunc = glDepthMask._native = _get_gl_func(\"glDepthMask\", None, (ctypes.c_bool,))\n    nativefunc(flag)",
  "def glDepthRange(zNear, zFar):\n    try:\n        nativefunc = glDepthRange._native\n    except AttributeError:\n        nativefunc = glDepthRange._native = _get_gl_func(\"glDepthRange\", None, (ctypes.c_double, ctypes.c_double,))\n    nativefunc(zNear, zFar)",
  "def glDetachShader(program, shader):\n    try:\n        nativefunc = glDetachShader._native\n    except AttributeError:\n        nativefunc = glDetachShader._native = _get_gl_func(\"glDetachShader\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(program, shader)",
  "def glDisable(cap):\n    try:\n        nativefunc = glDisable._native\n    except AttributeError:\n        nativefunc = glDisable._native = _get_gl_func(\"glDisable\", None, (ctypes.c_uint,))\n    nativefunc(cap)",
  "def glDisableVertexAttribArray(index):\n    try:\n        nativefunc = glDisableVertexAttribArray._native\n    except AttributeError:\n        nativefunc = glDisableVertexAttribArray._native = _get_gl_func(\"glDisableVertexAttribArray\", None, (ctypes.c_uint,))\n    nativefunc(index)",
  "def glDrawArrays(mode, first, count):\n    try:\n        nativefunc = glDrawArrays._native\n    except AttributeError:\n        nativefunc = glDrawArrays._native = _get_gl_func(\"glDrawArrays\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int,))\n    nativefunc(mode, first, count)",
  "def glDrawElements(mode, count, type, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n    indices = offset\n    try:\n        nativefunc = glDrawElements._native\n    except AttributeError:\n        nativefunc = glDrawElements._native = _get_gl_func(\"glDrawElements\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_void_p,))\n    res = nativefunc(mode, count, type, indices)",
  "def glEnable(cap):\n    try:\n        nativefunc = glEnable._native\n    except AttributeError:\n        nativefunc = glEnable._native = _get_gl_func(\"glEnable\", None, (ctypes.c_uint,))\n    nativefunc(cap)",
  "def glEnableVertexAttribArray(index):\n    try:\n        nativefunc = glEnableVertexAttribArray._native\n    except AttributeError:\n        nativefunc = glEnableVertexAttribArray._native = _get_gl_func(\"glEnableVertexAttribArray\", None, (ctypes.c_uint,))\n    nativefunc(index)",
  "def glFinish():\n    try:\n        nativefunc = glFinish._native\n    except AttributeError:\n        nativefunc = glFinish._native = _get_gl_func(\"glFinish\", None, ())\n    nativefunc()",
  "def glFlush():\n    try:\n        nativefunc = glFlush._native\n    except AttributeError:\n        nativefunc = glFlush._native = _get_gl_func(\"glFlush\", None, ())\n    nativefunc()",
  "def glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer):\n    try:\n        nativefunc = glFramebufferRenderbuffer._native\n    except AttributeError:\n        nativefunc = glFramebufferRenderbuffer._native = _get_gl_func(\"glFramebufferRenderbuffer\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, attachment, renderbuffertarget, renderbuffer)",
  "def glFramebufferTexture2D(target, attachment, textarget, texture, level):\n    try:\n        nativefunc = glFramebufferTexture2D._native\n    except AttributeError:\n        nativefunc = glFramebufferTexture2D._native = _get_gl_func(\"glFramebufferTexture2D\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_int,))\n    nativefunc(target, attachment, textarget, texture, level)",
  "def glFrontFace(mode):\n    try:\n        nativefunc = glFrontFace._native\n    except AttributeError:\n        nativefunc = glFrontFace._native = _get_gl_func(\"glFrontFace\", None, (ctypes.c_uint,))\n    nativefunc(mode)",
  "def glCreateBuffer():\n    n = 1\n    buffers = (ctypes.c_uint*n)()\n    try:\n        nativefunc = glCreateBuffer._native\n    except AttributeError:\n        nativefunc = glCreateBuffer._native = _get_gl_func(\"glGenBuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, buffers)\n    return buffers[0]",
  "def glCreateFramebuffer():\n    n = 1\n    framebuffers = (ctypes.c_uint*n)()\n    try:\n        nativefunc = glCreateFramebuffer._native\n    except AttributeError:\n        nativefunc = glCreateFramebuffer._native = _get_gl_func(\"glGenFramebuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, framebuffers)\n    return framebuffers[0]",
  "def glCreateRenderbuffer():\n    n = 1\n    renderbuffers = (ctypes.c_uint*n)()\n    try:\n        nativefunc = glCreateRenderbuffer._native\n    except AttributeError:\n        nativefunc = glCreateRenderbuffer._native = _get_gl_func(\"glGenRenderbuffers\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, renderbuffers)\n    return renderbuffers[0]",
  "def glCreateTexture():\n    n = 1\n    textures = (ctypes.c_uint*n)()\n    try:\n        nativefunc = glCreateTexture._native\n    except AttributeError:\n        nativefunc = glCreateTexture._native = _get_gl_func(\"glGenTextures\", None, (ctypes.c_int, ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(n, textures)\n    return textures[0]",
  "def glGenerateMipmap(target):\n    try:\n        nativefunc = glGenerateMipmap._native\n    except AttributeError:\n        nativefunc = glGenerateMipmap._native = _get_gl_func(\"glGenerateMipmap\", None, (ctypes.c_uint,))\n    nativefunc(target)",
  "def glGetActiveAttrib(program, index):\n    bufsize = 256\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    try:\n        nativefunc = glGetActiveAttrib._native\n    except AttributeError:\n        nativefunc = glGetActiveAttrib._native = _get_gl_func(\"glGetActiveAttrib\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,))\n    res = nativefunc(program, index, bufsize, length, size, type, name)\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]",
  "def glGetActiveUniform(program, index):\n    bufsize = 256\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    try:\n        nativefunc = glGetActiveUniform._native\n    except AttributeError:\n        nativefunc = glGetActiveUniform._native = _get_gl_func(\"glGetActiveUniform\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint), ctypes.c_char_p,))\n    res = nativefunc(program, index, bufsize, length, size, type, name)\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]",
  "def glGetAttachedShaders(program):\n    maxcount = 256\n    count = (ctypes.c_int*1)()\n    shaders = (ctypes.c_uint*maxcount)()\n    try:\n        nativefunc = glGetAttachedShaders._native\n    except AttributeError:\n        nativefunc = glGetAttachedShaders._native = _get_gl_func(\"glGetAttachedShaders\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_uint),))\n    res = nativefunc(program, maxcount, count, shaders)\n    return tuple(shaders[:count[0]])",
  "def glGetAttribLocation(program, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    try:\n        nativefunc = glGetAttribLocation._native\n    except AttributeError:\n        nativefunc = glGetAttribLocation._native = _get_gl_func(\"glGetAttribLocation\", ctypes.c_int, (ctypes.c_uint, ctypes.c_char_p,))\n    res = nativefunc(program, name)\n    return res",
  "def _glGetBooleanv(pname):\n    params = (ctypes.c_bool*1)()\n    try:\n        nativefunc = _glGetBooleanv._native\n    except AttributeError:\n        nativefunc = _glGetBooleanv._native = _get_gl_func(\"glGetBooleanv\", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_bool),))\n    res = nativefunc(pname, params)\n    return params[0]",
  "def glGetBufferParameter(target, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    try:\n        nativefunc = glGetBufferParameter._native\n    except AttributeError:\n        nativefunc = glGetBufferParameter._native = _get_gl_func(\"glGetBufferParameteriv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(target, pname, params)\n    return params[0]",
  "def glGetError():\n    try:\n        nativefunc = glGetError._native\n    except AttributeError:\n        nativefunc = glGetError._native = _get_gl_func(\"glGetError\", ctypes.c_uint, ())\n    return nativefunc()",
  "def _glGetFloatv(pname):\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    try:\n        nativefunc = _glGetFloatv._native\n    except AttributeError:\n        nativefunc = _glGetFloatv._native = _get_gl_func(\"glGetFloatv\", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))\n    res = nativefunc(pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetFramebufferAttachmentParameter(target, attachment, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    try:\n        nativefunc = glGetFramebufferAttachmentParameter._native\n    except AttributeError:\n        nativefunc = glGetFramebufferAttachmentParameter._native = _get_gl_func(\"glGetFramebufferAttachmentParameteriv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(target, attachment, pname, params)\n    return params[0]",
  "def _glGetIntegerv(pname):\n    n = 16\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*n)(*[d for i in range(n)])\n    try:\n        nativefunc = _glGetIntegerv._native\n    except AttributeError:\n        nativefunc = _glGetIntegerv._native = _get_gl_func(\"glGetIntegerv\", None, (ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetProgramInfoLog(program):\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    try:\n        nativefunc = glGetProgramInfoLog._native\n    except AttributeError:\n        nativefunc = glGetProgramInfoLog._native = _get_gl_func(\"glGetProgramInfoLog\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))\n    res = nativefunc(program, bufsize, length, infolog)\n    return infolog[:length[0]].decode('utf-8')",
  "def glGetProgramParameter(program, pname):\n    params = (ctypes.c_int*1)()\n    try:\n        nativefunc = glGetProgramParameter._native\n    except AttributeError:\n        nativefunc = glGetProgramParameter._native = _get_gl_func(\"glGetProgramiv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(program, pname, params)\n    return params[0]",
  "def glGetRenderbufferParameter(target, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    try:\n        nativefunc = glGetRenderbufferParameter._native\n    except AttributeError:\n        nativefunc = glGetRenderbufferParameter._native = _get_gl_func(\"glGetRenderbufferParameteriv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(target, pname, params)\n    return params[0]",
  "def glGetShaderInfoLog(shader):\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    try:\n        nativefunc = glGetShaderInfoLog._native\n    except AttributeError:\n        nativefunc = glGetShaderInfoLog._native = _get_gl_func(\"glGetShaderInfoLog\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))\n    res = nativefunc(shader, bufsize, length, infolog)\n    return infolog[:length[0]].decode('utf-8')",
  "def glGetShaderPrecisionFormat(shadertype, precisiontype):\n    range = (ctypes.c_int*1)()\n    precision = (ctypes.c_int*1)()\n    try:\n        nativefunc = glGetShaderPrecisionFormat._native\n    except AttributeError:\n        nativefunc = glGetShaderPrecisionFormat._native = _get_gl_func(\"glGetShaderPrecisionFormat\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(shadertype, precisiontype, range, precision)\n    return range[0], precision[0]",
  "def glGetShaderSource(shader):\n    bufsize = 1024*1024\n    length = (ctypes.c_int*1)()\n    source = (ctypes.c_char*bufsize)()\n    try:\n        nativefunc = glGetShaderSource._native\n    except AttributeError:\n        nativefunc = glGetShaderSource._native = _get_gl_func(\"glGetShaderSource\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_int), ctypes.c_char_p,))\n    res = nativefunc(shader, bufsize, length, source)\n    return source.value[:length[0]].decode('utf-8')",
  "def glGetShaderParameter(shader, pname):\n    params = (ctypes.c_int*1)()\n    try:\n        nativefunc = glGetShaderParameter._native\n    except AttributeError:\n        nativefunc = glGetShaderParameter._native = _get_gl_func(\"glGetShaderiv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(shader, pname, params)\n    return params[0]",
  "def glGetParameter(pname):\n    if pname in [33902, 33901, 32773, 3106, 2931, 2928,\n                 2849, 32824, 10752, 32938]:\n        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE\n        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE\n        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR\n        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE\n        return _glGetFloatv(pname)\n    elif pname in [7936, 7937, 7938, 35724, 7939]:\n        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,\n        # GL_EXTENSIONS are strings\n        pass  # string handled below\n    else:\n        return _glGetIntegerv(pname)\n    name = pname\n    try:\n        nativefunc = glGetParameter._native\n    except AttributeError:\n        nativefunc = glGetParameter._native = _get_gl_func(\"glGetString\", ctypes.c_char_p, (ctypes.c_uint,))\n    res = nativefunc(name)\n    return ctypes.string_at(res).decode('utf-8') if res else ''",
  "def glGetTexParameter(target, pname):\n    d = float('Inf')\n    params = (ctypes.c_float*1)(d)\n    try:\n        nativefunc = glGetTexParameter._native\n    except AttributeError:\n        nativefunc = glGetTexParameter._native = _get_gl_func(\"glGetTexParameterfv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))\n    res = nativefunc(target, pname, params)\n    return params[0]",
  "def glGetUniform(program, location):\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    try:\n        nativefunc = glGetUniform._native\n    except AttributeError:\n        nativefunc = glGetUniform._native = _get_gl_func(\"glGetUniformfv\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))\n    res = nativefunc(program, location, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetUniformLocation(program, name):\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    try:\n        nativefunc = glGetUniformLocation._native\n    except AttributeError:\n        nativefunc = glGetUniformLocation._native = _get_gl_func(\"glGetUniformLocation\", ctypes.c_int, (ctypes.c_uint, ctypes.c_char_p,))\n    res = nativefunc(program, name)\n    return res",
  "def glGetVertexAttrib(index, pname):\n    n = 4\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    try:\n        nativefunc = glGetVertexAttrib._native\n    except AttributeError:\n        nativefunc = glGetVertexAttrib._native = _get_gl_func(\"glGetVertexAttribfv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_float),))\n    res = nativefunc(index, pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetVertexAttribOffset(index, pname):\n    pointer = (ctypes.c_void_p*1)()\n    try:\n        nativefunc = glGetVertexAttribOffset._native\n    except AttributeError:\n        nativefunc = glGetVertexAttribOffset._native = _get_gl_func(\"glGetVertexAttribPointerv\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.POINTER(ctypes.c_void_p),))\n    res = nativefunc(index, pname, pointer)\n    return pointer[0] or 0",
  "def glHint(target, mode):\n    try:\n        nativefunc = glHint._native\n    except AttributeError:\n        nativefunc = glHint._native = _get_gl_func(\"glHint\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(target, mode)",
  "def glIsBuffer(buffer):\n    try:\n        nativefunc = glIsBuffer._native\n    except AttributeError:\n        nativefunc = glIsBuffer._native = _get_gl_func(\"glIsBuffer\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(buffer)",
  "def glIsEnabled(cap):\n    try:\n        nativefunc = glIsEnabled._native\n    except AttributeError:\n        nativefunc = glIsEnabled._native = _get_gl_func(\"glIsEnabled\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(cap)",
  "def glIsFramebuffer(framebuffer):\n    try:\n        nativefunc = glIsFramebuffer._native\n    except AttributeError:\n        nativefunc = glIsFramebuffer._native = _get_gl_func(\"glIsFramebuffer\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(framebuffer)",
  "def glIsProgram(program):\n    try:\n        nativefunc = glIsProgram._native\n    except AttributeError:\n        nativefunc = glIsProgram._native = _get_gl_func(\"glIsProgram\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(program)",
  "def glIsRenderbuffer(renderbuffer):\n    try:\n        nativefunc = glIsRenderbuffer._native\n    except AttributeError:\n        nativefunc = glIsRenderbuffer._native = _get_gl_func(\"glIsRenderbuffer\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(renderbuffer)",
  "def glIsShader(shader):\n    try:\n        nativefunc = glIsShader._native\n    except AttributeError:\n        nativefunc = glIsShader._native = _get_gl_func(\"glIsShader\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(shader)",
  "def glIsTexture(texture):\n    try:\n        nativefunc = glIsTexture._native\n    except AttributeError:\n        nativefunc = glIsTexture._native = _get_gl_func(\"glIsTexture\", ctypes.c_bool, (ctypes.c_uint,))\n    return nativefunc(texture)",
  "def glLineWidth(width):\n    try:\n        nativefunc = glLineWidth._native\n    except AttributeError:\n        nativefunc = glLineWidth._native = _get_gl_func(\"glLineWidth\", None, (ctypes.c_float,))\n    nativefunc(width)",
  "def glLinkProgram(program):\n    try:\n        nativefunc = glLinkProgram._native\n    except AttributeError:\n        nativefunc = glLinkProgram._native = _get_gl_func(\"glLinkProgram\", None, (ctypes.c_uint,))\n    nativefunc(program)",
  "def glPixelStorei(pname, param):\n    try:\n        nativefunc = glPixelStorei._native\n    except AttributeError:\n        nativefunc = glPixelStorei._native = _get_gl_func(\"glPixelStorei\", None, (ctypes.c_uint, ctypes.c_int,))\n    nativefunc(pname, param)",
  "def glPolygonOffset(factor, units):\n    try:\n        nativefunc = glPolygonOffset._native\n    except AttributeError:\n        nativefunc = glPolygonOffset._native = _get_gl_func(\"glPolygonOffset\", None, (ctypes.c_float, ctypes.c_float,))\n    nativefunc(factor, units)",
  "def glReadPixels(x, y, width, height, format, type):\n    # GL_ALPHA, GL_RGB, GL_RGBA, GL_DEPTH_COMPONENT\n    t = {6406:1, 6407:3, 6408:4, 6402:1}[format]\n    # GL_UNSIGNED_BYTE, GL_FLOAT\n    nb = {5121:1, 5126:4}[type]\n    size = int(width*height*t*nb)\n    pixels = ctypes.create_string_buffer(size)\n    try:\n        nativefunc = glReadPixels._native\n    except AttributeError:\n        nativefunc = glReadPixels._native = _get_gl_func(\"glReadPixels\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))\n    res = nativefunc(x, y, width, height, format, type, pixels)\n    return pixels[:]",
  "def glRenderbufferStorage(target, internalformat, width, height):\n    try:\n        nativefunc = glRenderbufferStorage._native\n    except AttributeError:\n        nativefunc = glRenderbufferStorage._native = _get_gl_func(\"glRenderbufferStorage\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_int,))\n    nativefunc(target, internalformat, width, height)",
  "def glSampleCoverage(value, invert):\n    try:\n        nativefunc = glSampleCoverage._native\n    except AttributeError:\n        nativefunc = glSampleCoverage._native = _get_gl_func(\"glSampleCoverage\", None, (ctypes.c_float, ctypes.c_bool,))\n    nativefunc(value, invert)",
  "def glScissor(x, y, width, height):\n    try:\n        nativefunc = glScissor._native\n    except AttributeError:\n        nativefunc = glScissor._native = _get_gl_func(\"glScissor\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(x, y, width, height)",
  "def glShaderSource(shader, source):\n    # Some implementation do not like getting a list of single chars\n    if isinstance(source, (tuple, list)):\n        strings = [s for s in source]\n    else:\n        strings = [source]\n    count = len(strings)\n    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])\n    length = (ctypes.c_int*count)(*[len(s) for s in strings])\n    try:\n        nativefunc = glShaderSource._native\n    except AttributeError:\n        nativefunc = glShaderSource._native = _get_gl_func(\"glShaderSource\", None, (ctypes.c_uint, ctypes.c_int, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_int),))\n    res = nativefunc(shader, count, string, length)",
  "def glStencilFunc(func, ref, mask):\n    try:\n        nativefunc = glStencilFunc._native\n    except AttributeError:\n        nativefunc = glStencilFunc._native = _get_gl_func(\"glStencilFunc\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint,))\n    nativefunc(func, ref, mask)",
  "def glStencilFuncSeparate(face, func, ref, mask):\n    try:\n        nativefunc = glStencilFuncSeparate._native\n    except AttributeError:\n        nativefunc = glStencilFuncSeparate._native = _get_gl_func(\"glStencilFuncSeparate\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int, ctypes.c_uint,))\n    nativefunc(face, func, ref, mask)",
  "def glStencilMask(mask):\n    try:\n        nativefunc = glStencilMask._native\n    except AttributeError:\n        nativefunc = glStencilMask._native = _get_gl_func(\"glStencilMask\", None, (ctypes.c_uint,))\n    nativefunc(mask)",
  "def glStencilMaskSeparate(face, mask):\n    try:\n        nativefunc = glStencilMaskSeparate._native\n    except AttributeError:\n        nativefunc = glStencilMaskSeparate._native = _get_gl_func(\"glStencilMaskSeparate\", None, (ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(face, mask)",
  "def glStencilOp(fail, zfail, zpass):\n    try:\n        nativefunc = glStencilOp._native\n    except AttributeError:\n        nativefunc = glStencilOp._native = _get_gl_func(\"glStencilOp\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(fail, zfail, zpass)",
  "def glStencilOpSeparate(face, fail, zfail, zpass):\n    try:\n        nativefunc = glStencilOpSeparate._native\n    except AttributeError:\n        nativefunc = glStencilOpSeparate._native = _get_gl_func(\"glStencilOpSeparate\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint,))\n    nativefunc(face, fail, zfail, zpass)",
  "def glTexImage2D(target, level, internalformat, format, type, pixels):\n    border = 0\n    if isinstance(pixels, (tuple, list)):\n        height, width = pixels\n        pixels = ctypes.c_void_p(0)\n        pixels = None\n    else:\n        if not pixels.flags['C_CONTIGUOUS']:\n            pixels = pixels.copy('C')\n        pixels_ = pixels\n        pixels = pixels_.ctypes.data\n        height, width = pixels_.shape[:2]\n    try:\n        nativefunc = glTexImage2D._native\n    except AttributeError:\n        nativefunc = glTexImage2D._native = _get_gl_func(\"glTexImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))\n    res = nativefunc(target, level, internalformat, width, height, border, format, type, pixels)",
  "def glTexParameterf(target, pname, param):\n    try:\n        nativefunc = glTexParameterf._native\n    except AttributeError:\n        nativefunc = glTexParameterf._native = _get_gl_func(\"glTexParameterf\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_float,))\n    nativefunc(target, pname, param)",
  "def glTexParameteri(target, pname, param):\n    try:\n        nativefunc = glTexParameteri._native\n    except AttributeError:\n        nativefunc = glTexParameteri._native = _get_gl_func(\"glTexParameteri\", None, (ctypes.c_uint, ctypes.c_uint, ctypes.c_int,))\n    nativefunc(target, pname, param)",
  "def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):\n    if not pixels.flags['C_CONTIGUOUS']:\n        pixels = pixels.copy('C')\n    pixels_ = pixels\n    pixels = pixels_.ctypes.data\n    height, width = pixels_.shape[:2]\n    try:\n        nativefunc = glTexSubImage2D._native\n    except AttributeError:\n        nativefunc = glTexSubImage2D._native = _get_gl_func(\"glTexSubImage2D\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint, ctypes.c_uint, ctypes.c_void_p,))\n    res = nativefunc(target, level, xoffset, yoffset, width, height, format, type, pixels)",
  "def glUniform1f(location, v1):\n    try:\n        nativefunc = glUniform1f._native\n    except AttributeError:\n        nativefunc = glUniform1f._native = _get_gl_func(\"glUniform1f\", None, (ctypes.c_int, ctypes.c_float,))\n    nativefunc(location, v1)",
  "def glUniform2f(location, v1, v2):\n    try:\n        nativefunc = glUniform2f._native\n    except AttributeError:\n        nativefunc = glUniform2f._native = _get_gl_func(\"glUniform2f\", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float,))\n    nativefunc(location, v1, v2)",
  "def glUniform3f(location, v1, v2, v3):\n    try:\n        nativefunc = glUniform3f._native\n    except AttributeError:\n        nativefunc = glUniform3f._native = _get_gl_func(\"glUniform3f\", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(location, v1, v2, v3)",
  "def glUniform4f(location, v1, v2, v3, v4):\n    try:\n        nativefunc = glUniform4f._native\n    except AttributeError:\n        nativefunc = glUniform4f._native = _get_gl_func(\"glUniform4f\", None, (ctypes.c_int, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(location, v1, v2, v3, v4)",
  "def glUniform1i(location, v1):\n    try:\n        nativefunc = glUniform1i._native\n    except AttributeError:\n        nativefunc = glUniform1i._native = _get_gl_func(\"glUniform1i\", None, (ctypes.c_int, ctypes.c_int,))\n    nativefunc(location, v1)",
  "def glUniform2i(location, v1, v2):\n    try:\n        nativefunc = glUniform2i._native\n    except AttributeError:\n        nativefunc = glUniform2i._native = _get_gl_func(\"glUniform2i\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(location, v1, v2)",
  "def glUniform3i(location, v1, v2, v3):\n    try:\n        nativefunc = glUniform3i._native\n    except AttributeError:\n        nativefunc = glUniform3i._native = _get_gl_func(\"glUniform3i\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(location, v1, v2, v3)",
  "def glUniform4i(location, v1, v2, v3, v4):\n    try:\n        nativefunc = glUniform4i._native\n    except AttributeError:\n        nativefunc = glUniform4i._native = _get_gl_func(\"glUniform4i\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(location, v1, v2, v3, v4)",
  "def glUniform1fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    try:\n        nativefunc = glUniform1fv._native\n    except AttributeError:\n        nativefunc = glUniform1fv._native = _get_gl_func(\"glUniform1fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, values)",
  "def glUniform2fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    try:\n        nativefunc = glUniform2fv._native\n    except AttributeError:\n        nativefunc = glUniform2fv._native = _get_gl_func(\"glUniform2fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, values)",
  "def glUniform3fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    try:\n        nativefunc = glUniform3fv._native\n    except AttributeError:\n        nativefunc = glUniform3fv._native = _get_gl_func(\"glUniform3fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, values)",
  "def glUniform4fv(location, count, values):\n    values = [float(val) for val in values]\n    values = (ctypes.c_float*len(values))(*values)\n    try:\n        nativefunc = glUniform4fv._native\n    except AttributeError:\n        nativefunc = glUniform4fv._native = _get_gl_func(\"glUniform4fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, values)",
  "def glUniform1iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    try:\n        nativefunc = glUniform1iv._native\n    except AttributeError:\n        nativefunc = glUniform1iv._native = _get_gl_func(\"glUniform1iv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))\n    nativefunc(location, count, values)",
  "def glUniform2iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    try:\n        nativefunc = glUniform2iv._native\n    except AttributeError:\n        nativefunc = glUniform2iv._native = _get_gl_func(\"glUniform2iv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))\n    nativefunc(location, count, values)",
  "def glUniform3iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    try:\n        nativefunc = glUniform3iv._native\n    except AttributeError:\n        nativefunc = glUniform3iv._native = _get_gl_func(\"glUniform3iv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))\n    nativefunc(location, count, values)",
  "def glUniform4iv(location, count, values):\n    values = [int(val) for val in values]\n    values = (ctypes.c_int*len(values))(*values)\n    try:\n        nativefunc = glUniform4iv._native\n    except AttributeError:\n        nativefunc = glUniform4iv._native = _get_gl_func(\"glUniform4iv\", None, (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int),))\n    nativefunc(location, count, values)",
  "def glUniformMatrix2fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    try:\n        nativefunc = glUniformMatrix2fv._native\n    except AttributeError:\n        nativefunc = glUniformMatrix2fv._native = _get_gl_func(\"glUniformMatrix2fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, transpose, values)",
  "def glUniformMatrix3fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    try:\n        nativefunc = glUniformMatrix3fv._native\n    except AttributeError:\n        nativefunc = glUniformMatrix3fv._native = _get_gl_func(\"glUniformMatrix3fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, transpose, values)",
  "def glUniformMatrix4fv(location, count, transpose, values):\n    if not values.flags[\"C_CONTIGUOUS\"]:\n        values = values.copy()\n    assert values.dtype.name == \"float32\"\n    values_ = values\n    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\n    try:\n        nativefunc = glUniformMatrix4fv._native\n    except AttributeError:\n        nativefunc = glUniformMatrix4fv._native = _get_gl_func(\"glUniformMatrix4fv\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_bool, ctypes.POINTER(ctypes.c_float),))\n    nativefunc(location, count, transpose, values)",
  "def glUseProgram(program):\n    try:\n        nativefunc = glUseProgram._native\n    except AttributeError:\n        nativefunc = glUseProgram._native = _get_gl_func(\"glUseProgram\", None, (ctypes.c_uint,))\n    nativefunc(program)",
  "def glValidateProgram(program):\n    try:\n        nativefunc = glValidateProgram._native\n    except AttributeError:\n        nativefunc = glValidateProgram._native = _get_gl_func(\"glValidateProgram\", None, (ctypes.c_uint,))\n    nativefunc(program)",
  "def glVertexAttrib1f(index, v1):\n    try:\n        nativefunc = glVertexAttrib1f._native\n    except AttributeError:\n        nativefunc = glVertexAttrib1f._native = _get_gl_func(\"glVertexAttrib1f\", None, (ctypes.c_uint, ctypes.c_float,))\n    nativefunc(index, v1)",
  "def glVertexAttrib2f(index, v1, v2):\n    try:\n        nativefunc = glVertexAttrib2f._native\n    except AttributeError:\n        nativefunc = glVertexAttrib2f._native = _get_gl_func(\"glVertexAttrib2f\", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float,))\n    nativefunc(index, v1, v2)",
  "def glVertexAttrib3f(index, v1, v2, v3):\n    try:\n        nativefunc = glVertexAttrib3f._native\n    except AttributeError:\n        nativefunc = glVertexAttrib3f._native = _get_gl_func(\"glVertexAttrib3f\", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(index, v1, v2, v3)",
  "def glVertexAttrib4f(index, v1, v2, v3, v4):\n    try:\n        nativefunc = glVertexAttrib4f._native\n    except AttributeError:\n        nativefunc = glVertexAttrib4f._native = _get_gl_func(\"glVertexAttrib4f\", None, (ctypes.c_uint, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float,))\n    nativefunc(index, v1, v2, v3, v4)",
  "def glVertexAttribPointer(indx, size, type, normalized, stride, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n        # We need to ensure that the data exists at draw time :(\n        # PyOpenGL does this too\n        key = '_vert_attr_'+str(indx)\n        setattr(glVertexAttribPointer, key, offset_)\n    ptr = offset\n    try:\n        nativefunc = glVertexAttribPointer._native\n    except AttributeError:\n        nativefunc = glVertexAttribPointer._native = _get_gl_func(\"glVertexAttribPointer\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_uint, ctypes.c_bool, ctypes.c_int, ctypes.c_void_p,))\n    res = nativefunc(indx, size, type, normalized, stride, ptr)",
  "def glViewport(x, y, width, height):\n    try:\n        nativefunc = glViewport._native\n    except AttributeError:\n        nativefunc = glViewport._native = _get_gl_func(\"glViewport\", None, (ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int,))\n    nativefunc(x, y, width, height)",
  "class DummyProxy(BaseGLProxy):\n    \"\"\"A dummy backend that can be activated when the GL is not\n    processed in this process. Each GL function call will raise an\n    error.\n    \"\"\"\n\n    def __call__(self, funcname, returns, *args):\n        raise RuntimeError('Cannot call %r (or any other GL function), '\n                           'since GL is disabled.' % funcname)",
  "def __call__(self, funcname, returns, *args):\n        raise RuntimeError('Cannot call %r (or any other GL function), '\n                           'since GL is disabled.' % funcname)",
  "def glBindAttribLocation(program, index, name):\n    name = name.encode('utf-8')\n    return GL.glBindAttribLocation(program, index, name)",
  "def glBufferData(target, data, usage):\n    \"\"\"Data can be numpy array or the size of data to allocate.\"\"\"\n    if isinstance(data, int):\n        size = data\n        data = None\n    else:\n        size = data.nbytes\n    GL.glBufferData(target, size, data, usage)",
  "def glBufferSubData(target, offset, data):\n    size = data.nbytes\n    GL.glBufferSubData(target, offset, size, data)",
  "def glCompressedTexImage2D(target, level, internalformat, width, height, border, data):\n    # border = 0  # set in args\n    size = data.size\n    GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, size, data)",
  "def glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):\n    size = data.size\n    GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, size, data)",
  "def glDeleteBuffer(buffer):\n    GL.glDeleteBuffers(1, [buffer])",
  "def glDeleteFramebuffer(framebuffer):\n    FBO.glDeleteFramebuffers(1, [framebuffer])",
  "def glDeleteRenderbuffer(renderbuffer):\n    FBO.glDeleteRenderbuffers(1, [renderbuffer])",
  "def glDeleteTexture(texture):\n    GL.glDeleteTextures([texture])",
  "def glDrawElements(mode, count, type, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    return GL.glDrawElements(mode, count, type, offset)",
  "def glCreateBuffer():\n    return GL.glGenBuffers(1)",
  "def glCreateFramebuffer():\n    return FBO.glGenFramebuffers(1)",
  "def glCreateRenderbuffer():\n    return FBO.glGenRenderbuffers(1)",
  "def glCreateTexture():\n    return GL.glGenTextures(1)",
  "def glGetActiveAttrib(program, index):\n    bufsize = 256\n    name, size, type = GL.glGetActiveAttrib(program, index, bufSize=bufsize)\n    return name.decode('utf-8'), size, type",
  "def glGetActiveUniform(program, index):\n    name, size, type = GL.glGetActiveUniform(program, index)\n    return name.decode('utf-8'), size, type",
  "def glGetAttribLocation(program, name):\n    name = name.encode('utf-8')\n    return GL.glGetAttribLocation(program, name)",
  "def glGetFramebufferAttachmentParameter(target, attachment, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    FBO.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)\n    return params[0]",
  "def glGetProgramInfoLog(program):\n    res = GL.glGetProgramInfoLog(program)\n    return res.decode('utf-8') if isinstance(res, bytes) else res",
  "def glGetRenderbufferParameter(target, pname):\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    FBO.glGetRenderbufferParameteriv(target, pname, params)\n    return params[0]",
  "def glGetShaderInfoLog(shader):\n    res = GL.glGetShaderInfoLog(shader)\n    return res.decode('utf-8') if isinstance(res, bytes) else res",
  "def glGetShaderSource(shader):\n    res = GL.glGetShaderSource(shader)\n    return res.decode('utf-8')",
  "def glGetParameter(pname):\n    if pname in [33902, 33901, 32773, 3106, 2931, 2928,\n                 2849, 32824, 10752, 32938]:\n        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE\n        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE\n        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR\n        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE\n        return GL.glGetFloatv(pname)\n    elif pname in [7936, 7937, 7938, 35724, 7939]:\n        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION,\n        # GL_EXTENSIONS are strings\n        pass  # string handled below\n    else:\n        return GL.glGetIntegerv(pname)\n    res = GL.glGetString(pname)\n    return res.decode('utf-8')",
  "def glGetUniform(program, location):\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    GL.glGetUniformfv(program, location, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetUniformLocation(program, name):\n    name = name.encode('utf-8')\n    return GL.glGetUniformLocation(program, name)",
  "def glGetVertexAttrib(index, pname):\n    # From PyOpenGL v3.1.0 the glGetVertexAttribfv(index, pname) does\n    # work, but it always returns 4 values, with zeros in the empty\n    # spaces. We have no way to tell whether they are empty or genuine\n    # zeros. Fortunately, pyopengl also supports the old syntax.\n    n = 4\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    GL.glGetVertexAttribfv(index, pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def glGetVertexAttribOffset(index, pname):\n    try:  # maybe the fixed it\n        return GL.glGetVertexAttribPointerv(index, pname)\n    except TypeError:\n        pointer = (ctypes.c_void_p*1)()\n        GL.glGetVertexAttribPointerv(index, pname, pointer)\n        return pointer[0] or 0",
  "def glShaderSource(shader, source):\n    # Some implementation do not like getting a list of single chars\n    if isinstance(source, (tuple, list)):\n        strings = [s for s in source]\n    else:\n        strings = [source]\n    GL.glShaderSource(shader, strings)",
  "def glTexImage2D(target, level, internalformat, format, type, pixels):\n    border = 0\n    if isinstance(pixels, (tuple, list)):\n        height, width = pixels\n        pixels = None\n    else:\n        height, width = pixels.shape[:2]\n    GL.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)",
  "def glTexSubImage2D(target, level, xoffset, yoffset, format, type, pixels):\n    height, width = pixels.shape[:2]\n    GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)",
  "def glVertexAttribPointer(indx, size, type, normalized, stride, offset):\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    return GL.glVertexAttribPointer(indx, size, type, normalized, stride, offset)",
  "class MainProxy(BaseGLProxy):\n    \"\"\"Main proxy for the GL ES 2.0 API.\n\n    The functions in this namespace always call into the correct GL\n    backend. Therefore these function objects can be safely stored for\n    reuse. However, for efficienty it would probably be better to store the\n    function name and then do ``func = getattr(gloo.gl, funcname)``.\n    \"\"\"\n\n    def __call__(self, funcname, returns, *args):\n        func = getattr(current_backend, funcname)\n        return func(*args)",
  "def use_gl(target=None):\n    \"\"\"Let Vispy use the target OpenGL ES 2.0 implementation\n\n    Also see ``vispy.use()``.\n\n    Parameters\n    ----------\n    target : str\n        The target GL backend to use. Default gl2 or es2, depending on the platform.\n\n    Available backends:\n    * gl2 - Use ES 2.0 subset of desktop (i.e. normal) OpenGL\n    * gl+ - Use the desktop ES 2.0 subset plus all non-deprecated GL\n      functions on your system (requires PyOpenGL)\n    * es2 - Use the ES2 library (Angle/DirectX on Windows)\n    * pyopengl2 - Use ES 2.0 subset of pyopengl (for fallback and testing)\n    * dummy - Prevent usage of gloo.gl (for when rendering occurs elsewhere)\n\n    You can use vispy's config option \"gl_debug\" to check for errors\n    on each API call. Or, one can specify it as the target, e.g. \"gl2\n    debug\". (Debug does not apply to 'gl+', since PyOpenGL has its own\n    debug mechanism)\n    \"\"\"\n    target = target or default_backend.__name__.split(\".\")[-1]\n    target = target.replace('+', 'plus')\n\n    # Get options\n    target, _, options = target.partition(' ')\n    debug = config['gl_debug'] or 'debug' in options\n\n    # Select modules to import names from\n    try:\n        mod = __import__(target, globals(), level=1)\n    except ImportError as err:\n        msg = 'Could not import gl target \"%s\":\\n%s' % (target, str(err))\n        raise RuntimeError(msg)\n\n    # Apply\n    global current_backend\n    current_backend = mod\n    _clear_namespace()\n    if 'plus' in target:\n        # Copy PyOpenGL funcs, extra funcs, constants, no debug\n        _copy_gl_functions(mod._pyopengl2, globals(), debug=debug)\n        _copy_gl_functions(mod, globals(), True, debug=debug)\n    else:\n        _copy_gl_functions(mod, globals(), debug=debug)",
  "def _clear_namespace():\n    \"\"\"Clear names that are not part of the strict ES API\"\"\"\n    ok_names = set(default_backend.__dict__)\n    ok_names.update(['gl2', 'glplus'])  # don't remove the module\n    NS = globals()\n    for name in list(NS.keys()):\n        if name.lower().startswith('gl'):\n            if name not in ok_names:\n                del NS[name]",
  "def _copy_gl_functions(source, dest, constants=False, debug=False):\n    \"\"\"Inject all objects that start with 'gl' from the source\n    into the dest. source and dest can be dicts, modules or BaseGLProxy's.\n    \"\"\"\n    # Get dicts\n    if isinstance(source, BaseGLProxy):\n        s = {}\n        for key in dir(source):\n            s[key] = getattr(source, key)\n        source = s\n    elif not isinstance(source, dict):\n        source = source.__dict__\n    if not isinstance(dest, dict):\n        dest = dest.__dict__\n    # Copy names\n    funcnames = [name for name in source.keys() if name.startswith('gl')]\n    for name in funcnames:\n        if debug and name != 'glGetError':\n            dest[name] = make_debug_wrapper(source[name])\n        else:\n            dest[name] = source[name]\n    # Copy constants\n    if constants:\n        constnames = [name for name in source.keys() if name.startswith('GL_')]\n        for name in constnames:\n            dest[name] = source[name]",
  "def _arg_repr(arg):\n    \"\"\"Get a useful (and not too large) represetation of an argument.\"\"\"\n    r = repr(arg)\n    max = 40\n    if len(r) > max:\n        if hasattr(arg, 'shape'):\n            r = 'array:' + 'x'.join([repr(s) for s in arg.shape])\n        else:\n            r = r[:max-3] + '...'\n    return r",
  "def make_debug_wrapper(fn):\n    def gl_debug_wrapper(*args):\n        # Log function call\n        argstr = ', '.join(map(_arg_repr, args))\n        logger.debug(\"%s(%s)\" % (fn.__name__, argstr))\n        # Call function\n        ret = fn(*args)\n        # Log return value\n        if ret is not None:\n            if fn.__name__ == 'glReadPixels':\n                logger.debug(\" <= %s[%s]\" % (type(ret), len(ret)))\n            else:\n                logger.debug(\" <= %s\" % repr(ret))\n        # Check for errors (raises if an error occured)\n        check_error(fn.__name__)\n        # Return\n        return ret\n    gl_debug_wrapper.__name__ = fn.__name__ + '_debug_wrapper'\n    # Store reference to wrapped function just for introspection\n    gl_debug_wrapper._wrapped_function = fn\n    return gl_debug_wrapper",
  "def check_error(when='periodic check'):\n    \"\"\"Check this from time to time to detect GL errors.\n\n    Parameters\n    ----------\n    when : str\n        Shown in the exception to help the developer determine when\n        this check was done.\n    \"\"\"\n    errors = []\n    while True:\n        err = glGetError()\n        if err == GL_NO_ERROR or (errors and err == errors[-1]):\n            break\n        errors.append(err)\n    if errors:\n        msg = ', '.join([repr(ENUM_MAP.get(e, e)) for e in errors])\n        err = RuntimeError('OpenGL got errors (%s): %s' % (when, msg))\n        err.errors = errors\n        err.err = errors[-1]  # pyopengl compat\n        raise err",
  "def _fix_osmesa_gl_lib_if_testing():\n    \"\"\"\n    This functions checks if we a running test with the osmesa backends and\n    fix the GL library if needed.\n\n    Since we have to fix the VISPY_GL_LIB *before* any import from the gl\n    module, we have to run this here.\n    Test discovery utilities (like pytest) will try to import modules\n    before running tests, so we have to modify the GL lib really early.\n    The other solution would be to setup pre-run hooks for the test utility,\n    but there doesn't seem to be a standard way to do that (e.g. conftest.py\n    for py.test)\n    \"\"\"\n    test_name = os.getenv('_VISPY_TESTING_APP', None)\n    if test_name == 'osmesa':\n        from ...util.osmesa_gl import fix_osmesa_gl_lib\n        fix_osmesa_gl_lib()",
  "def __call__(self, funcname, returns, *args):\n        func = getattr(current_backend, funcname)\n        return func(*args)",
  "def gl_debug_wrapper(*args):\n        # Log function call\n        argstr = ', '.join(map(_arg_repr, args))\n        logger.debug(\"%s(%s)\" % (fn.__name__, argstr))\n        # Call function\n        ret = fn(*args)\n        # Log return value\n        if ret is not None:\n            if fn.__name__ == 'glReadPixels':\n                logger.debug(\" <= %s[%s]\" % (type(ret), len(ret)))\n            else:\n                logger.debug(\" <= %s\" % repr(ret))\n        # Check for errors (raises if an error occured)\n        check_error(fn.__name__)\n        # Return\n        return ret",
  "class Enum(int):\n    \"\"\"Enum (integer) with a meaningfull repr.\"\"\"\n    \n    def __new__(cls, name, value):\n        base = int.__new__(cls, value)\n        base.name = name\n        return base\n        \n    def __repr__(self):\n        return self.name",
  "def __new__(cls, name, value):\n        base = int.__new__(cls, value)\n        base.name = name\n        return base",
  "def __repr__(self):\n        return self.name",
  "def _inject():\n    \"\"\"Inject functions and constants from PyOpenGL but leave out the\n    names that are deprecated or that we provide in our API.\n    \"\"\"\n    # Get namespaces\n    NS = globals()\n    GLNS = _GL.__dict__\n\n    # Get names that we use in our API\n    used_names = []\n    used_names.extend([names[0] for names in _pyopengl2._functions_to_import])\n    used_names.extend([name for name in _pyopengl2._used_functions])\n    NS['_used_names'] = used_names\n    #\n    used_constants = set(_constants.__dict__)\n    # Count\n    injected_constants = 0\n    injected_functions = 0\n\n    for name in dir(_GL):\n\n        if name.startswith('GL_'):\n            # todo: find list of deprecated constants\n            if name not in used_constants:\n                NS[name] = GLNS[name]\n                injected_constants += 1\n\n        elif name.startswith('gl'):\n            # Functions\n            if (name + ',') in _deprecated_functions:\n                pass  # Function is deprecated\n            elif name in used_names:\n                pass  # Function is in our GL ES 2.0 API\n            else:\n                NS[name] = GLNS[name]\n                injected_functions += 1",
  "class PlotWidget(scene.Widget):\n    \"\"\"Widget to facilitate plotting\n\n    Parameters\n    ----------\n    *args : arguments\n        Arguments passed to the `ViewBox` super class.\n    **kwargs : keywoard arguments\n        Keyword arguments passed to the `ViewBox` super class.\n\n    Notes\n    -----\n    This class is typically instantiated implicitly by a `Figure`\n    instance, e.g., by doing ``fig[0, 0]``.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._fg = kwargs.pop('fg_color', 'k')\n        self.grid = None\n        self.camera = None\n        self.title = None\n        self.title_widget = None\n        self.yaxis = None\n        self.xaxis = None\n        self.xlabel = None\n        self.ylabel = None\n        self._configured = False\n        self.visuals = []\n        self.section_y_x = None\n\n        self.cbar_top = None\n        self.cbar_bottom = None\n        self.cbar_left = None\n        self.cbar_right = None\n\n        super(PlotWidget, self).__init__(*args, **kwargs)\n        self.grid = self.add_grid(spacing=0, margin=10)\n\n        self.title = scene.Label(\"\", font_size=16, color=\"#ff0000\")\n\n    def _configure_2d(self, fg_color=None):\n        if self._configured:\n            return\n\n        if fg_color is None:\n            fg = self._fg\n        else:\n            fg = fg_color\n\n        #     c0        c1      c2      c3      c4      c5         c6\n        #  r0 +---------+-------+-------+-------+-------+---------+---------+\n        #     |         |                       | title |         |         |\n        #  r1 |         +-----------------------+-------+---------+         |\n        #     |         |                       | cbar  |         |         |\n        #  r2 |         +-------+-------+-------+-------+---------+         |\n        #     |         | cbar  | ylabel| yaxis |  view | cbar    | padding |\n        #  r3 | padding +-------+-------+-------+-------+---------+         |\n        #     |         |                       | xaxis |         |         |\n        #  r4 |         +-----------------------+-------+---------+         |\n        #     |         |                       | xlabel|         |         |\n        #  r5 |         +-----------------------+-------+---------+         |\n        #     |         |                       | cbar  |         |         |\n        #  r6 |---------+-----------------------+-------+---------+---------|\n        #     |                           padding                           |\n        #     +---------+-----------------------+-------+---------+---------+\n\n        # padding left\n        padding_left = self.grid.add_widget(None, row=0, row_span=5, col=0)\n        padding_left.width_min = 30\n        padding_left.width_max = 60\n\n        # padding right\n        padding_right = self.grid.add_widget(None, row=0, row_span=5, col=6)\n        padding_right.width_min = 30\n        padding_right.width_max = 60\n\n        # padding right\n        padding_bottom = self.grid.add_widget(None, row=6, col=0, col_span=6)\n        padding_bottom.height_min = 20\n        padding_bottom.height_max = 40\n\n        # row 0\n        # title - column 4 to 5\n        self.title_widget = self.grid.add_widget(self.title, row=0, col=4)\n        self.title_widget.height_min = self.title_widget.height_max = 40\n\n        # row 1\n        # colorbar - column 4 to 5\n        self.cbar_top = self.grid.add_widget(None, row=1, col=4)\n        self.cbar_top.height_max = 1\n\n        # row 2\n        # colorbar_left - column 1\n        # ylabel - column 2\n        # yaxis - column 3\n        # view - column 4\n        # colorbar_right - column 5\n        self.cbar_left = self.grid.add_widget(None, row=2, col=1)\n        self.cbar_left.width_max = 1\n\n        self.ylabel = scene.Label(\"\", rotation=-90)\n        ylabel_widget = self.grid.add_widget(self.ylabel, row=2, col=2)\n        ylabel_widget.width_max = 1\n\n        self.yaxis = scene.AxisWidget(orientation='left',\n                                      text_color=fg,\n                                      axis_color=fg, tick_color=fg)\n\n        yaxis_widget = self.grid.add_widget(self.yaxis, row=2, col=3)\n        yaxis_widget.width_max = 40\n\n        # row 3\n        # xaxis - column 4\n        self.xaxis = scene.AxisWidget(orientation='bottom', text_color=fg,\n                                      axis_color=fg, tick_color=fg)\n        xaxis_widget = self.grid.add_widget(self.xaxis, row=3, col=4)\n        xaxis_widget.height_max = 40\n\n        self.cbar_right = self.grid.add_widget(None, row=2, col=5)\n        self.cbar_right.width_max = 1\n\n        # row 4\n        # xlabel - column 4\n        self.xlabel = scene.Label(\"\")\n        xlabel_widget = self.grid.add_widget(self.xlabel, row=4, col=4)\n        xlabel_widget.height_max = 40\n\n        # row 5\n        self.cbar_bottom = self.grid.add_widget(None, row=5, col=4)\n        self.cbar_bottom.height_max = 1\n\n        # This needs to be added to the grid last (to fix #1742)\n        self.view = self.grid.add_view(row=2, col=4,\n                                       border_color='grey', bgcolor=\"#efefef\")\n        self.view.camera = 'panzoom'\n        self.camera = self.view.camera\n\n        self._configured = True\n        self.xaxis.link_view(self.view)\n        self.yaxis.link_view(self.view)\n\n    def _configure_3d(self):\n        if self._configured:\n            return\n\n        self.view = self.grid.add_view(row=0, col=0,\n                                       border_color='grey', bgcolor=\"#efefef\")\n\n        self.view.camera = 'turntable'\n        self.camera = self.view.camera\n\n        self._configured = True\n\n    def histogram(self, data, bins=10, color='w', orientation='h'):\n        \"\"\"Calculate and show a histogram of data\n\n        Parameters\n        ----------\n        data : array-like\n            Data to histogram. Currently only 1D data is supported.\n        bins : int | array-like\n            Number of bins, or bin edges.\n        color : instance of Color\n            Color of the histogram.\n        orientation : {'h', 'v'}\n            Orientation of the histogram.\n\n        Returns\n        -------\n        hist : instance of Polygon\n            The histogram polygon.\n        \"\"\"\n        self._configure_2d()\n        hist = scene.Histogram(data, bins, color, orientation)\n        self.view.add(hist)\n        self.view.camera.set_range()\n        return hist\n\n    def image(self, data, cmap='cubehelix', clim='auto', fg_color=None, **kwargs):\n        \"\"\"Show an image\n\n        Parameters\n        ----------\n        data : ndarray\n            Should have shape (N, M), (N, M, 3) or (N, M, 4).\n        cmap : str\n            Colormap name.\n        clim : str | tuple\n            Colormap limits. Should be ``'auto'`` or a two-element tuple of\n            min and max values.\n        fg_color : Color or None\n            Sets the plot foreground color if specified.\n        kwargs : keyword arguments.\n            More args to pass to :class:`~vispy.visuals.image.Image`.\n\n        Returns\n        -------\n        image : instance of Image\n            The image.\n\n        Notes\n        -----\n        The colormap is only used if the image pixels are scalars.\n        \"\"\"\n        self._configure_2d(fg_color)\n        image = scene.Image(data, cmap=cmap, clim=clim, **kwargs)\n        self.view.add(image)\n        self.view.camera.aspect = 1\n        self.view.camera.set_range()\n\n        return image\n\n    def mesh(self, vertices=None, faces=None, vertex_colors=None,\n             face_colors=None, color=(0.5, 0.5, 1.), fname=None,\n             meshdata=None, shading='auto'):\n        \"\"\"Show a 3D mesh\n\n        Parameters\n        ----------\n        vertices : array\n            Vertices.\n        faces : array | None\n            Face definitions.\n        vertex_colors : array | None\n            Vertex colors.\n        face_colors : array | None\n            Face colors.\n        color : instance of Color\n            Color to use.\n        fname : str | None\n            Filename to load. If not None, then vertices, faces, and meshdata\n            must be None.\n        meshdata : MeshData | None\n            Meshdata to use. If not None, then vertices, faces, and fname\n            must be None.\n        shading : str\n            Shading to use, can be None, 'smooth', 'flat', or 'auto'.\n            Default ('auto') will use None if face_colors is set, and\n            'smooth' otherwise.\n\n        Returns\n        -------\n        mesh : instance of Mesh\n            The mesh.\n        \"\"\"\n        self._configure_3d()\n        if shading == 'auto':\n            shading = 'smooth'\n            if face_colors is not None:\n                shading = None\n        if fname is not None:\n            if not all(x is None for x in (vertices, faces, meshdata)):\n                raise ValueError('vertices, faces, and meshdata must be None '\n                                 'if fname is not None')\n            vertices, faces = read_mesh(fname)[:2]\n        if meshdata is not None:\n            if not all(x is None for x in (vertices, faces, fname)):\n                raise ValueError('vertices, faces, and fname must be None if '\n                                 'fname is not None')\n        else:\n            meshdata = MeshData(vertices, faces, vertex_colors=vertex_colors,\n                                face_colors=face_colors)\n        mesh = scene.Mesh(meshdata=meshdata, vertex_colors=vertex_colors,\n                          face_colors=face_colors, color=color,\n                          shading=shading)\n        self.view.add(mesh)\n        self.view.camera.set_range()\n        return mesh\n\n    def plot(self, data, color='k', symbol=None, line_kind='-', width=1.,\n             marker_size=10., edge_color='k', face_color='b', edge_width=1.,\n             title=None, xlabel=None, ylabel=None, connect='strip'):\n        \"\"\"Plot a series of data using lines and markers\n\n        Parameters\n        ----------\n        data : array | two arrays\n            Arguments can be passed as ``(Y,)``, ``(X, Y)`` or\n            ``np.array((X, Y))``.\n        color : instance of Color\n            Color of the line.\n        symbol : str\n            Marker symbol to use.\n        line_kind : str\n            Kind of line to draw. For now, only solid lines (``'-'``)\n            are supported.\n        width : float\n            Line width.\n        marker_size : float\n            Marker size. If `size == 0` markers will not be shown.\n        edge_color : instance of Color\n            Color of the marker edge.\n        face_color : instance of Color\n            Color of the marker face.\n        edge_width : float\n            Edge width of the marker.\n        title : str | None\n            The title string to be displayed above the plot\n        xlabel : str | None\n            The label to display along the bottom axis\n        ylabel : str | None\n            The label to display along the left axis.\n        connect : str | array\n            Determines which vertices are connected by lines.\n\n        Returns\n        -------\n        line : instance of LinePlot\n            The line plot.\n\n        See also\n        --------\n        LinePlot\n        \"\"\"\n        self._configure_2d()\n        line = scene.LinePlot(data, connect=connect, color=color,\n                              symbol=symbol, line_kind=line_kind,\n                              width=width, marker_size=marker_size,\n                              edge_color=edge_color,\n                              face_color=face_color,\n                              edge_width=edge_width)\n        self.view.add(line)\n        self.view.camera.set_range()\n        self.visuals.append(line)\n\n        if title is not None:\n            self.title.text = title\n        if xlabel is not None:\n            self.xlabel.text = xlabel\n        if ylabel is not None:\n            self.ylabel.text = ylabel\n\n        return line\n\n    def spectrogram(self, x, n_fft=256, step=None, fs=1., window='hann',\n                    normalize=False, color_scale='log', cmap='cubehelix',\n                    clim='auto'):\n        \"\"\"Calculate and show a spectrogram\n\n        Parameters\n        ----------\n        x : array-like\n            1D signal to operate on. ``If len(x) < n_fft``, x will be\n            zero-padded to length ``n_fft``.\n        n_fft : int\n            Number of FFT points. Much faster for powers of two.\n        step : int | None\n            Step size between calculations. If None, ``n_fft // 2``\n            will be used.\n        fs : float\n            The sample rate of the data.\n        window : str | None\n            Window function to use. Can be ``'hann'`` for Hann window, or None\n            for no windowing.\n        normalize : bool\n            Normalization of spectrogram values across frequencies.\n        color_scale : {'linear', 'log'}\n            Scale to apply to the result of the STFT.\n            ``'log'`` will use ``10 * log10(power)``.\n        cmap : str\n            Colormap name.\n        clim : str | tuple\n            Colormap limits. Should be ``'auto'`` or a two-element tuple of\n            min and max values.\n\n        Returns\n        -------\n        spec : instance of Spectrogram\n            The spectrogram.\n\n        See also\n        --------\n        Image\n        \"\"\"\n        self._configure_2d()\n        # XXX once we have axes, we should use \"fft_freqs\", too\n        spec = scene.Spectrogram(x, n_fft, step, fs, window,\n                                 normalize, color_scale, cmap, clim)\n        self.view.add(spec)\n        self.view.camera.set_range()\n        return spec\n\n    def volume(self, vol, clim=None, method='mip', threshold=None,\n               cmap='grays', **kwargs):\n        \"\"\"Show a 3D volume\n\n        Parameters\n        ----------\n        vol : ndarray\n            Volume to render.\n        clim : tuple of two floats | None\n            The contrast limits. The values in the volume are mapped to\n            black and white corresponding to these values. Default maps\n            between min and max.\n        method : {'mip', 'iso', 'translucent', 'additive'}\n            The render style to use. See corresponding docs for details.\n            Default 'mip'.\n        threshold : float\n            The threshold to use for the isosurafce render style. By default\n            the mean of the given volume is used.\n        cmap : str\n            The colormap to use.\n        kwargs : keyword arguments.\n            More args to pass to :class:`~vispy.visuals.volume.Volume`.\n\n        Returns\n        -------\n        volume : instance of Volume\n            The volume visualization.\n\n        See also\n        --------\n        Volume\n        \"\"\"\n        self._configure_3d()\n        volume = scene.Volume(vol, clim, method, threshold, cmap=cmap, **kwargs)\n        self.view.add(volume)\n        self.view.camera.set_range()\n        return volume\n\n    def surface(self, zdata, **kwargs):\n        \"\"\"Show a 3D surface plot.\n\n        Extra keyword arguments are passed to `SurfacePlot()`.\n\n        Parameters\n        ----------\n        zdata : array-like\n            A 2D array of the surface Z values.\n\n        \"\"\"\n        self._configure_3d()\n        surf = scene.SurfacePlot(z=zdata, **kwargs)\n        self.view.add(surf)\n        self.view.camera.set_range()\n        return surf\n\n    def colorbar(self, cmap, position=\"right\",\n                 label=\"\", clim=(\"\", \"\"),\n                 border_width=0.0, border_color=\"black\",\n                 **kwargs):\n        \"\"\"Show a ColorBar\n\n        Parameters\n        ----------\n        cmap : str | vispy.color.ColorMap\n            Either the name of the ColorMap to be used from the standard\n            set of names (refer to `vispy.color.get_colormap`),\n            or a custom ColorMap object.\n            The ColorMap is used to apply a gradient on the colorbar.\n        position : {'left', 'right', 'top', 'bottom'}\n            The position of the colorbar with respect to the plot.\n            'top' and 'bottom' are placed horizontally, while\n            'left' and 'right' are placed vertically\n        label : str\n            The label that is to be drawn with the colorbar\n            that provides information about the colorbar.\n        clim : tuple (min, max)\n            the minimum and maximum values of the data that\n            is given to the colorbar. This is used to draw the scale\n            on the side of the colorbar.\n        border_width : float (in px)\n            The width of the border the colormap should have. This measurement\n            is given in pixels\n        border_color : str | vispy.color.Color\n            The color of the border of the colormap. This can either be a\n            str as the color's name or an actual instace of a vipy.color.Color\n\n        Returns\n        -------\n        colorbar : instance of ColorBarWidget\n\n        See also\n        --------\n        ColorBarWidget\n        \"\"\"\n        self._configure_2d()\n\n        cbar = scene.ColorBarWidget(orientation=position,\n                                    label=label,\n                                    cmap=cmap,\n                                    clim=clim,\n                                    border_width=border_width,\n                                    border_color=border_color,\n                                    **kwargs)\n\n        CBAR_LONG_DIM = 50\n\n        if cbar.orientation == \"bottom\":\n            self.grid.remove_widget(self.cbar_bottom)\n            self.cbar_bottom = self.grid.add_widget(cbar, row=5, col=4)\n            self.cbar_bottom.height_max = \\\n                self.cbar_bottom.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"top\":\n            self.grid.remove_widget(self.cbar_top)\n            self.cbar_top = self.grid.add_widget(cbar, row=1, col=4)\n            self.cbar_top.height_max = self.cbar_top.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"left\":\n            self.grid.remove_widget(self.cbar_left)\n            self.cbar_left = self.grid.add_widget(cbar, row=2, col=1)\n            self.cbar_left.width_max = self.cbar_left.width_min = CBAR_LONG_DIM\n\n        else:  # cbar.orientation == \"right\"\n            self.grid.remove_widget(self.cbar_right)\n            self.cbar_right = self.grid.add_widget(cbar, row=2, col=5)\n            self.cbar_right.width_max = \\\n                self.cbar_right.width_min = CBAR_LONG_DIM\n\n        return cbar",
  "def __init__(self, *args, **kwargs):\n        self._fg = kwargs.pop('fg_color', 'k')\n        self.grid = None\n        self.camera = None\n        self.title = None\n        self.title_widget = None\n        self.yaxis = None\n        self.xaxis = None\n        self.xlabel = None\n        self.ylabel = None\n        self._configured = False\n        self.visuals = []\n        self.section_y_x = None\n\n        self.cbar_top = None\n        self.cbar_bottom = None\n        self.cbar_left = None\n        self.cbar_right = None\n\n        super(PlotWidget, self).__init__(*args, **kwargs)\n        self.grid = self.add_grid(spacing=0, margin=10)\n\n        self.title = scene.Label(\"\", font_size=16, color=\"#ff0000\")",
  "def _configure_2d(self, fg_color=None):\n        if self._configured:\n            return\n\n        if fg_color is None:\n            fg = self._fg\n        else:\n            fg = fg_color\n\n        #     c0        c1      c2      c3      c4      c5         c6\n        #  r0 +---------+-------+-------+-------+-------+---------+---------+\n        #     |         |                       | title |         |         |\n        #  r1 |         +-----------------------+-------+---------+         |\n        #     |         |                       | cbar  |         |         |\n        #  r2 |         +-------+-------+-------+-------+---------+         |\n        #     |         | cbar  | ylabel| yaxis |  view | cbar    | padding |\n        #  r3 | padding +-------+-------+-------+-------+---------+         |\n        #     |         |                       | xaxis |         |         |\n        #  r4 |         +-----------------------+-------+---------+         |\n        #     |         |                       | xlabel|         |         |\n        #  r5 |         +-----------------------+-------+---------+         |\n        #     |         |                       | cbar  |         |         |\n        #  r6 |---------+-----------------------+-------+---------+---------|\n        #     |                           padding                           |\n        #     +---------+-----------------------+-------+---------+---------+\n\n        # padding left\n        padding_left = self.grid.add_widget(None, row=0, row_span=5, col=0)\n        padding_left.width_min = 30\n        padding_left.width_max = 60\n\n        # padding right\n        padding_right = self.grid.add_widget(None, row=0, row_span=5, col=6)\n        padding_right.width_min = 30\n        padding_right.width_max = 60\n\n        # padding right\n        padding_bottom = self.grid.add_widget(None, row=6, col=0, col_span=6)\n        padding_bottom.height_min = 20\n        padding_bottom.height_max = 40\n\n        # row 0\n        # title - column 4 to 5\n        self.title_widget = self.grid.add_widget(self.title, row=0, col=4)\n        self.title_widget.height_min = self.title_widget.height_max = 40\n\n        # row 1\n        # colorbar - column 4 to 5\n        self.cbar_top = self.grid.add_widget(None, row=1, col=4)\n        self.cbar_top.height_max = 1\n\n        # row 2\n        # colorbar_left - column 1\n        # ylabel - column 2\n        # yaxis - column 3\n        # view - column 4\n        # colorbar_right - column 5\n        self.cbar_left = self.grid.add_widget(None, row=2, col=1)\n        self.cbar_left.width_max = 1\n\n        self.ylabel = scene.Label(\"\", rotation=-90)\n        ylabel_widget = self.grid.add_widget(self.ylabel, row=2, col=2)\n        ylabel_widget.width_max = 1\n\n        self.yaxis = scene.AxisWidget(orientation='left',\n                                      text_color=fg,\n                                      axis_color=fg, tick_color=fg)\n\n        yaxis_widget = self.grid.add_widget(self.yaxis, row=2, col=3)\n        yaxis_widget.width_max = 40\n\n        # row 3\n        # xaxis - column 4\n        self.xaxis = scene.AxisWidget(orientation='bottom', text_color=fg,\n                                      axis_color=fg, tick_color=fg)\n        xaxis_widget = self.grid.add_widget(self.xaxis, row=3, col=4)\n        xaxis_widget.height_max = 40\n\n        self.cbar_right = self.grid.add_widget(None, row=2, col=5)\n        self.cbar_right.width_max = 1\n\n        # row 4\n        # xlabel - column 4\n        self.xlabel = scene.Label(\"\")\n        xlabel_widget = self.grid.add_widget(self.xlabel, row=4, col=4)\n        xlabel_widget.height_max = 40\n\n        # row 5\n        self.cbar_bottom = self.grid.add_widget(None, row=5, col=4)\n        self.cbar_bottom.height_max = 1\n\n        # This needs to be added to the grid last (to fix #1742)\n        self.view = self.grid.add_view(row=2, col=4,\n                                       border_color='grey', bgcolor=\"#efefef\")\n        self.view.camera = 'panzoom'\n        self.camera = self.view.camera\n\n        self._configured = True\n        self.xaxis.link_view(self.view)\n        self.yaxis.link_view(self.view)",
  "def _configure_3d(self):\n        if self._configured:\n            return\n\n        self.view = self.grid.add_view(row=0, col=0,\n                                       border_color='grey', bgcolor=\"#efefef\")\n\n        self.view.camera = 'turntable'\n        self.camera = self.view.camera\n\n        self._configured = True",
  "def histogram(self, data, bins=10, color='w', orientation='h'):\n        \"\"\"Calculate and show a histogram of data\n\n        Parameters\n        ----------\n        data : array-like\n            Data to histogram. Currently only 1D data is supported.\n        bins : int | array-like\n            Number of bins, or bin edges.\n        color : instance of Color\n            Color of the histogram.\n        orientation : {'h', 'v'}\n            Orientation of the histogram.\n\n        Returns\n        -------\n        hist : instance of Polygon\n            The histogram polygon.\n        \"\"\"\n        self._configure_2d()\n        hist = scene.Histogram(data, bins, color, orientation)\n        self.view.add(hist)\n        self.view.camera.set_range()\n        return hist",
  "def image(self, data, cmap='cubehelix', clim='auto', fg_color=None, **kwargs):\n        \"\"\"Show an image\n\n        Parameters\n        ----------\n        data : ndarray\n            Should have shape (N, M), (N, M, 3) or (N, M, 4).\n        cmap : str\n            Colormap name.\n        clim : str | tuple\n            Colormap limits. Should be ``'auto'`` or a two-element tuple of\n            min and max values.\n        fg_color : Color or None\n            Sets the plot foreground color if specified.\n        kwargs : keyword arguments.\n            More args to pass to :class:`~vispy.visuals.image.Image`.\n\n        Returns\n        -------\n        image : instance of Image\n            The image.\n\n        Notes\n        -----\n        The colormap is only used if the image pixels are scalars.\n        \"\"\"\n        self._configure_2d(fg_color)\n        image = scene.Image(data, cmap=cmap, clim=clim, **kwargs)\n        self.view.add(image)\n        self.view.camera.aspect = 1\n        self.view.camera.set_range()\n\n        return image",
  "def mesh(self, vertices=None, faces=None, vertex_colors=None,\n             face_colors=None, color=(0.5, 0.5, 1.), fname=None,\n             meshdata=None, shading='auto'):\n        \"\"\"Show a 3D mesh\n\n        Parameters\n        ----------\n        vertices : array\n            Vertices.\n        faces : array | None\n            Face definitions.\n        vertex_colors : array | None\n            Vertex colors.\n        face_colors : array | None\n            Face colors.\n        color : instance of Color\n            Color to use.\n        fname : str | None\n            Filename to load. If not None, then vertices, faces, and meshdata\n            must be None.\n        meshdata : MeshData | None\n            Meshdata to use. If not None, then vertices, faces, and fname\n            must be None.\n        shading : str\n            Shading to use, can be None, 'smooth', 'flat', or 'auto'.\n            Default ('auto') will use None if face_colors is set, and\n            'smooth' otherwise.\n\n        Returns\n        -------\n        mesh : instance of Mesh\n            The mesh.\n        \"\"\"\n        self._configure_3d()\n        if shading == 'auto':\n            shading = 'smooth'\n            if face_colors is not None:\n                shading = None\n        if fname is not None:\n            if not all(x is None for x in (vertices, faces, meshdata)):\n                raise ValueError('vertices, faces, and meshdata must be None '\n                                 'if fname is not None')\n            vertices, faces = read_mesh(fname)[:2]\n        if meshdata is not None:\n            if not all(x is None for x in (vertices, faces, fname)):\n                raise ValueError('vertices, faces, and fname must be None if '\n                                 'fname is not None')\n        else:\n            meshdata = MeshData(vertices, faces, vertex_colors=vertex_colors,\n                                face_colors=face_colors)\n        mesh = scene.Mesh(meshdata=meshdata, vertex_colors=vertex_colors,\n                          face_colors=face_colors, color=color,\n                          shading=shading)\n        self.view.add(mesh)\n        self.view.camera.set_range()\n        return mesh",
  "def plot(self, data, color='k', symbol=None, line_kind='-', width=1.,\n             marker_size=10., edge_color='k', face_color='b', edge_width=1.,\n             title=None, xlabel=None, ylabel=None, connect='strip'):\n        \"\"\"Plot a series of data using lines and markers\n\n        Parameters\n        ----------\n        data : array | two arrays\n            Arguments can be passed as ``(Y,)``, ``(X, Y)`` or\n            ``np.array((X, Y))``.\n        color : instance of Color\n            Color of the line.\n        symbol : str\n            Marker symbol to use.\n        line_kind : str\n            Kind of line to draw. For now, only solid lines (``'-'``)\n            are supported.\n        width : float\n            Line width.\n        marker_size : float\n            Marker size. If `size == 0` markers will not be shown.\n        edge_color : instance of Color\n            Color of the marker edge.\n        face_color : instance of Color\n            Color of the marker face.\n        edge_width : float\n            Edge width of the marker.\n        title : str | None\n            The title string to be displayed above the plot\n        xlabel : str | None\n            The label to display along the bottom axis\n        ylabel : str | None\n            The label to display along the left axis.\n        connect : str | array\n            Determines which vertices are connected by lines.\n\n        Returns\n        -------\n        line : instance of LinePlot\n            The line plot.\n\n        See also\n        --------\n        LinePlot\n        \"\"\"\n        self._configure_2d()\n        line = scene.LinePlot(data, connect=connect, color=color,\n                              symbol=symbol, line_kind=line_kind,\n                              width=width, marker_size=marker_size,\n                              edge_color=edge_color,\n                              face_color=face_color,\n                              edge_width=edge_width)\n        self.view.add(line)\n        self.view.camera.set_range()\n        self.visuals.append(line)\n\n        if title is not None:\n            self.title.text = title\n        if xlabel is not None:\n            self.xlabel.text = xlabel\n        if ylabel is not None:\n            self.ylabel.text = ylabel\n\n        return line",
  "def spectrogram(self, x, n_fft=256, step=None, fs=1., window='hann',\n                    normalize=False, color_scale='log', cmap='cubehelix',\n                    clim='auto'):\n        \"\"\"Calculate and show a spectrogram\n\n        Parameters\n        ----------\n        x : array-like\n            1D signal to operate on. ``If len(x) < n_fft``, x will be\n            zero-padded to length ``n_fft``.\n        n_fft : int\n            Number of FFT points. Much faster for powers of two.\n        step : int | None\n            Step size between calculations. If None, ``n_fft // 2``\n            will be used.\n        fs : float\n            The sample rate of the data.\n        window : str | None\n            Window function to use. Can be ``'hann'`` for Hann window, or None\n            for no windowing.\n        normalize : bool\n            Normalization of spectrogram values across frequencies.\n        color_scale : {'linear', 'log'}\n            Scale to apply to the result of the STFT.\n            ``'log'`` will use ``10 * log10(power)``.\n        cmap : str\n            Colormap name.\n        clim : str | tuple\n            Colormap limits. Should be ``'auto'`` or a two-element tuple of\n            min and max values.\n\n        Returns\n        -------\n        spec : instance of Spectrogram\n            The spectrogram.\n\n        See also\n        --------\n        Image\n        \"\"\"\n        self._configure_2d()\n        # XXX once we have axes, we should use \"fft_freqs\", too\n        spec = scene.Spectrogram(x, n_fft, step, fs, window,\n                                 normalize, color_scale, cmap, clim)\n        self.view.add(spec)\n        self.view.camera.set_range()\n        return spec",
  "def volume(self, vol, clim=None, method='mip', threshold=None,\n               cmap='grays', **kwargs):\n        \"\"\"Show a 3D volume\n\n        Parameters\n        ----------\n        vol : ndarray\n            Volume to render.\n        clim : tuple of two floats | None\n            The contrast limits. The values in the volume are mapped to\n            black and white corresponding to these values. Default maps\n            between min and max.\n        method : {'mip', 'iso', 'translucent', 'additive'}\n            The render style to use. See corresponding docs for details.\n            Default 'mip'.\n        threshold : float\n            The threshold to use for the isosurafce render style. By default\n            the mean of the given volume is used.\n        cmap : str\n            The colormap to use.\n        kwargs : keyword arguments.\n            More args to pass to :class:`~vispy.visuals.volume.Volume`.\n\n        Returns\n        -------\n        volume : instance of Volume\n            The volume visualization.\n\n        See also\n        --------\n        Volume\n        \"\"\"\n        self._configure_3d()\n        volume = scene.Volume(vol, clim, method, threshold, cmap=cmap, **kwargs)\n        self.view.add(volume)\n        self.view.camera.set_range()\n        return volume",
  "def surface(self, zdata, **kwargs):\n        \"\"\"Show a 3D surface plot.\n\n        Extra keyword arguments are passed to `SurfacePlot()`.\n\n        Parameters\n        ----------\n        zdata : array-like\n            A 2D array of the surface Z values.\n\n        \"\"\"\n        self._configure_3d()\n        surf = scene.SurfacePlot(z=zdata, **kwargs)\n        self.view.add(surf)\n        self.view.camera.set_range()\n        return surf",
  "def colorbar(self, cmap, position=\"right\",\n                 label=\"\", clim=(\"\", \"\"),\n                 border_width=0.0, border_color=\"black\",\n                 **kwargs):\n        \"\"\"Show a ColorBar\n\n        Parameters\n        ----------\n        cmap : str | vispy.color.ColorMap\n            Either the name of the ColorMap to be used from the standard\n            set of names (refer to `vispy.color.get_colormap`),\n            or a custom ColorMap object.\n            The ColorMap is used to apply a gradient on the colorbar.\n        position : {'left', 'right', 'top', 'bottom'}\n            The position of the colorbar with respect to the plot.\n            'top' and 'bottom' are placed horizontally, while\n            'left' and 'right' are placed vertically\n        label : str\n            The label that is to be drawn with the colorbar\n            that provides information about the colorbar.\n        clim : tuple (min, max)\n            the minimum and maximum values of the data that\n            is given to the colorbar. This is used to draw the scale\n            on the side of the colorbar.\n        border_width : float (in px)\n            The width of the border the colormap should have. This measurement\n            is given in pixels\n        border_color : str | vispy.color.Color\n            The color of the border of the colormap. This can either be a\n            str as the color's name or an actual instace of a vipy.color.Color\n\n        Returns\n        -------\n        colorbar : instance of ColorBarWidget\n\n        See also\n        --------\n        ColorBarWidget\n        \"\"\"\n        self._configure_2d()\n\n        cbar = scene.ColorBarWidget(orientation=position,\n                                    label=label,\n                                    cmap=cmap,\n                                    clim=clim,\n                                    border_width=border_width,\n                                    border_color=border_color,\n                                    **kwargs)\n\n        CBAR_LONG_DIM = 50\n\n        if cbar.orientation == \"bottom\":\n            self.grid.remove_widget(self.cbar_bottom)\n            self.cbar_bottom = self.grid.add_widget(cbar, row=5, col=4)\n            self.cbar_bottom.height_max = \\\n                self.cbar_bottom.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"top\":\n            self.grid.remove_widget(self.cbar_top)\n            self.cbar_top = self.grid.add_widget(cbar, row=1, col=4)\n            self.cbar_top.height_max = self.cbar_top.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"left\":\n            self.grid.remove_widget(self.cbar_left)\n            self.cbar_left = self.grid.add_widget(cbar, row=2, col=1)\n            self.cbar_left.width_max = self.cbar_left.width_min = CBAR_LONG_DIM\n\n        else:  # cbar.orientation == \"right\"\n            self.grid.remove_widget(self.cbar_right)\n            self.cbar_right = self.grid.add_widget(cbar, row=2, col=5)\n            self.cbar_right.width_max = \\\n                self.cbar_right.width_min = CBAR_LONG_DIM\n\n        return cbar",
  "class Fig(SceneCanvas):\n    \"\"\"Create a figure window\n\n    Parameters\n    ----------\n    bgcolor : instance of Color\n        Color to use for the background.\n    size : tuple\n        Size of the figure window in pixels.\n    show : bool\n        If True, show the window.\n    **kwargs : dict\n        Keywoard arguments to pass to `SceneCanvas` base class.\n\n    Notes\n    -----\n    You can create a Figure, PlotWidget, and diagonal line plot like this::\n\n        >>> from vispy.plot import Fig\n        >>> fig = Fig()\n        >>> ax = fig[0, 0]  # this creates a PlotWidget\n        >>> ax.plot([[0, 1], [1, 0]])\n\n    See the gallery for many other examples.\n\n    See Also\n    --------\n    PlotWidget : the axis widget for plotting\n    SceneCanvas : the super class\n    \"\"\"\n\n    def __init__(self, bgcolor='w', size=(800, 600), show=True,\n                 keys='interactive', **kwargs):\n        self._plot_widgets = []\n        self._grid = None  # initialize before the freeze occurs\n        super(Fig, self).__init__(bgcolor=bgcolor, keys=keys,\n                                  show=show, size=size, **kwargs)\n        self._grid = self.central_widget.add_grid()\n        self._grid._default_class = PlotWidget\n\n    @property\n    def plot_widgets(self):\n        \"\"\"List of the associated PlotWidget instances\"\"\"\n        return tuple(self._plot_widgets)\n\n    def __getitem__(self, idxs):\n        \"\"\"Get an axis\"\"\"\n        pw = self._grid.__getitem__(idxs)\n        self._plot_widgets += [pw]\n        return pw",
  "def __init__(self, bgcolor='w', size=(800, 600), show=True,\n                 keys='interactive', **kwargs):\n        self._plot_widgets = []\n        self._grid = None  # initialize before the freeze occurs\n        super(Fig, self).__init__(bgcolor=bgcolor, keys=keys,\n                                  show=show, size=size, **kwargs)\n        self._grid = self.central_widget.add_grid()\n        self._grid._default_class = PlotWidget",
  "def plot_widgets(self):\n        \"\"\"List of the associated PlotWidget instances\"\"\"\n        return tuple(self._plot_widgets)",
  "def __getitem__(self, idxs):\n        \"\"\"Get an axis\"\"\"\n        pw = self._grid.__getitem__(idxs)\n        self._plot_widgets += [pw]\n        return pw",
  "def _fast_cross_3d(x, y):\n    \"\"\"Compute cross product between list of 3D vectors\n\n    Much faster than np.cross() when the number of cross products\n    becomes large (>500). This is because np.cross() methods become\n    less memory efficient at this stage.\n\n    Parameters\n    ----------\n    x : array\n        Input array 1.\n    y : array\n        Input array 2.\n\n    Returns\n    -------\n    z : array\n        Cross product of x and y.\n\n    Notes\n    -----\n    x and y must both be 2D row vectors. One must have length 1, or both\n    lengths must match.\n    \"\"\"\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1],\n                     x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2],\n                     x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)",
  "def _calculate_normals(rr, tris):\n    \"\"\"Efficiently compute vertex normals for triangulated surface\"\"\"\n    # ensure highest precision for our summation/vectorization \"trick\"\n    rr = rr.astype(np.float64)\n    # first, compute triangle normals\n    r1 = rr[tris[:, 0], :]\n    r2 = rr[tris[:, 1], :]\n    r3 = rr[tris[:, 2], :]\n    tri_nn = _fast_cross_3d((r2 - r1), (r3 - r1))\n\n    #   Triangle normals and areas\n    size = np.sqrt(np.sum(tri_nn * tri_nn, axis=1))\n    size[size == 0] = 1.0  # prevent ugly divide-by-zero\n    tri_nn /= size[:, np.newaxis]\n\n    npts = len(rr)\n\n    # the following code replaces this, but is faster (vectorized):\n    #\n    # for p, verts in enumerate(tris):\n    #     nn[verts, :] += tri_nn[p, :]\n    #\n    nn = np.zeros((npts, 3))\n    for verts in tris.T:  # note this only loops 3x (number of verts per tri)\n        for idx in range(3):  # x, y, z\n            nn[:, idx] += np.bincount(verts.astype(np.int32),\n                                      tri_nn[:, idx], minlength=npts)\n    size = np.sqrt(np.sum(nn * nn, axis=1))\n    size[size == 0] = 1.0  # prevent ugly divide-by-zero\n    nn /= size[:, np.newaxis]\n    return nn",
  "def resize(image, shape, kind='linear'):\n    \"\"\"Resize an image\n\n    Parameters\n    ----------\n    image : ndarray\n        Array of shape (N, M, ...).\n    shape : tuple\n        2-element shape.\n    kind : str\n        Interpolation, either \"linear\" or \"nearest\".\n\n    Returns\n    -------\n    scaled_image : ndarray\n        New image, will have dtype np.float64.\n    \"\"\"\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:  # kind == 'nearest'\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out",
  "def compact(vertices, indices, tolerance=1e-3):\n    \"\"\"Compact vertices and indices within given tolerance\"\"\"\n    # Transform vertices into a structured array for np.unique to work\n    n = len(vertices)\n    V = np.zeros(n, dtype=[(\"pos\", np.float32, 3)])\n    V[\"pos\"][:, 0] = vertices[:, 0]\n    V[\"pos\"][:, 1] = vertices[:, 1]\n    V[\"pos\"][:, 2] = vertices[:, 2]\n\n    epsilon = 1e-3\n    decimals = int(np.log(epsilon)/np.log(1/10.))\n\n    # Round all vertices within given decimals\n    V_ = np.zeros_like(V)\n    X = V[\"pos\"][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n\n    V_[\"pos\"][:, 0] = X\n    Y = V[\"pos\"][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_[\"pos\"][:, 1] = Y\n\n    Z = V[\"pos\"][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_[\"pos\"][:, 2] = Z\n\n    # Find the unique vertices AND the mapping\n    U, RI = np.unique(V_, return_inverse=True)\n\n    # Translate indices from original vertices into the reduced set (U)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices)//3, 3)\n\n    # Return reduced vertices set, transalted indices and mapping that allows\n    # to go from U to V\n    return U.view(np.float32).reshape(len(U), 3), I_, RI",
  "def normals(vertices, indices):\n    \"\"\"Compute normals over a triangulated surface\n\n    Parameters\n    ----------\n    vertices : ndarray (n,3)\n        triangles vertices\n\n    indices : ndarray (p,3)\n        triangles indices\n    \"\"\"\n    # Compact similar vertices\n    vertices, indices, mapping = compact(vertices, indices)\n\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2]-T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0  # prevent divide-by-zero\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals*normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n\n    return normals[mapping]",
  "def create_cube():\n    \"\"\"Generate vertices & indices for a filled and outlined cube\n\n    Returns\n    -------\n    vertices : array\n        Array of vertices suitable for use as a VertexBuffer.\n    filled : array\n        Indices to use to produce a filled cube.\n    outline : array\n        Indices to use to produce an outline of the cube.\n    \"\"\"\n    vtype = [('position', np.float32, 3),\n             ('texcoord', np.float32, 2),\n             ('normal', np.float32, 3),\n             ('color', np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]])\n\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 0], [0, -1, 0], [0, 0, -1]])\n\n    # Vertice colors\n    c = np.array([[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [1, 0, 1, 1],\n                  [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1]])\n\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,\n               1, 1, 1, 1,\n               2, 2, 2, 2,\n               3, 3, 3, 3,\n               4, 4, 4, 4,\n               5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,\n               0, 1, 2, 3,\n               0, 1, 2, 3,\n               3, 2, 1, 0,\n               0, 1, 2, 3,\n               0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices['position'] = p[faces_p]\n    vertices['normal'] = n[faces_n]\n    vertices['color'] = c[faces_c]\n    vertices['texcoord'] = t[faces_t]\n\n    filled = np.resize(\n        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n    filled = filled.reshape((len(filled) // 3, 3))\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    return vertices, filled, outline",
  "def create_plane(width=1, height=1, width_segments=1, height_segments=1,\n                 direction='+z'):\n    \"\"\"Generate vertices & indices for a filled and outlined plane.\n\n    Parameters\n    ----------\n    width : float\n        Plane width.\n    height : float\n        Plane height.\n    width_segments : int\n        Plane segments count along the width.\n    height_segments : float\n        Plane segments count along the height.\n    direction: unicode\n        ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Direction the plane will be facing.\n\n    Returns\n    -------\n    vertices : array\n        Array of vertices suitable for use as a VertexBuffer.\n    faces : array\n        Indices to use to produce a filled plane.\n    outline : array\n        Indices to use to produce an outline of the plane.\n\n    References\n    ----------\n    .. [1] Cabello, R. (n.d.). PlaneBufferGeometry.js. Retrieved May 12, 2015,\n        from http://git.io/vU1Fh\n    \"\"\"\n    x_grid = width_segments\n    y_grid = height_segments\n\n    x_grid1 = x_grid + 1\n    y_grid1 = y_grid + 1\n\n    # Positions, normals and texcoords.\n    positions = np.zeros(x_grid1 * y_grid1 * 3)\n    normals = np.zeros(x_grid1 * y_grid1 * 3)\n    texcoords = np.zeros(x_grid1 * y_grid1 * 2)\n\n    y = np.arange(y_grid1) * height / y_grid - height / 2\n    x = np.arange(x_grid1) * width / x_grid - width / 2\n\n    positions[::3] = np.tile(x, y_grid1)\n    positions[1::3] = -np.repeat(y, x_grid1)\n\n    normals[2::3] = 1\n\n    texcoords[::2] = np.tile(np.arange(x_grid1) / x_grid, y_grid1)\n    texcoords[1::2] = np.repeat(1 - np.arange(y_grid1) / y_grid, x_grid1)\n\n    # Faces and outline.\n    faces, outline = [], []\n    for i_y in range(y_grid):\n        for i_x in range(x_grid):\n            a = i_x + x_grid1 * i_y\n            b = i_x + x_grid1 * (i_y + 1)\n            c = (i_x + 1) + x_grid1 * (i_y + 1)\n            d = (i_x + 1) + x_grid1 * i_y\n\n            faces.extend(((a, b, d), (b, c, d)))\n            outline.extend(((a, b), (b, c), (c, d), (d, a)))\n\n    positions = np.reshape(positions, (-1, 3))\n    texcoords = np.reshape(texcoords, (-1, 2))\n    normals = np.reshape(normals, (-1, 3))\n\n    faces = np.reshape(faces, (-1, 3)).astype(np.uint32)\n    outline = np.reshape(outline, (-1, 2)).astype(np.uint32)\n\n    direction = direction.lower()\n    if direction in ('-x', '+x'):\n        shift, neutral_axis = 1, 0\n    elif direction in ('-y', '+y'):\n        shift, neutral_axis = -1, 1\n    elif direction in ('-z', '+z'):\n        shift, neutral_axis = 0, 2\n\n    sign = -1 if '-' in direction else 1\n\n    positions = np.roll(positions, shift, -1)\n    normals = np.roll(normals, shift, -1) * sign\n    colors = np.ravel(positions)\n    colors = np.hstack((np.reshape(np.interp(colors,\n                                             (np.min(colors),\n                                              np.max(colors)),\n                                             (0, 1)),\n                                   positions.shape),\n                        np.ones((positions.shape[0], 1))))\n    colors[..., neutral_axis] = 0\n\n    vertices = np.zeros(positions.shape[0],\n                        [('position', np.float32, 3),\n                         ('texcoord', np.float32, 2),\n                         ('normal', np.float32, 3),\n                         ('color', np.float32, 4)])\n\n    vertices['position'] = positions\n    vertices['texcoord'] = texcoords\n    vertices['normal'] = normals\n    vertices['color'] = colors\n\n    return vertices, faces, outline",
  "def create_box(width=1, height=1, depth=1, width_segments=1, height_segments=1,\n               depth_segments=1, planes=None):\n    \"\"\"Generate vertices & indices for a filled and outlined box.\n\n    Parameters\n    ----------\n    width : float\n        Box width.\n    height : float\n        Box height.\n    depth : float\n        Box depth.\n    width_segments : int\n        Box segments count along the width.\n    height_segments : float\n        Box segments count along the height.\n    depth_segments : float\n        Box segments count along the depth.\n    planes: array_like\n        Any combination of ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Included planes in the box construction.\n\n    Returns\n    -------\n    vertices : array\n        Array of vertices suitable for use as a VertexBuffer.\n    faces : array\n        Indices to use to produce a filled box.\n    outline : array\n        Indices to use to produce an outline of the box.\n    \"\"\"\n    planes = (('+x', '-x', '+y', '-y', '+z', '-z')\n              if planes is None else\n              [d.lower() for d in planes])\n\n    w_s, h_s, d_s = width_segments, height_segments, depth_segments\n\n    planes_m = []\n    if '-z' in planes:\n        planes_m.append(create_plane(width, depth, w_s, d_s, '-z'))\n        planes_m[-1][0]['position'][..., 2] -= height / 2\n    if '+z' in planes:\n        planes_m.append(create_plane(width, depth, w_s, d_s, '+z'))\n        planes_m[-1][0]['position'][..., 2] += height / 2\n\n    if '-y' in planes:\n        planes_m.append(create_plane(height, width, h_s, w_s, '-y'))\n        planes_m[-1][0]['position'][..., 1] -= depth / 2\n    if '+y' in planes:\n        planes_m.append(create_plane(height, width, h_s, w_s, '+y'))\n        planes_m[-1][0]['position'][..., 1] += depth / 2\n\n    if '-x' in planes:\n        planes_m.append(create_plane(depth, height, d_s, h_s, '-x'))\n        planes_m[-1][0]['position'][..., 0] -= width / 2\n    if '+x' in planes:\n        planes_m.append(create_plane(depth, height, d_s, h_s, '+x'))\n        planes_m[-1][0]['position'][..., 0] += width / 2\n\n    positions = np.zeros((0, 3), dtype=np.float32)\n    texcoords = np.zeros((0, 2), dtype=np.float32)\n    normals = np.zeros((0, 3), dtype=np.float32)\n\n    faces = np.zeros((0, 3), dtype=np.uint32)\n    outline = np.zeros((0, 2), dtype=np.uint32)\n\n    offset = 0\n    for vertices_p, faces_p, outline_p in planes_m:\n        positions = np.vstack((positions, vertices_p['position']))\n        texcoords = np.vstack((texcoords, vertices_p['texcoord']))\n        normals = np.vstack((normals, vertices_p['normal']))\n\n        faces = np.vstack((faces, faces_p + offset))\n        outline = np.vstack((outline, outline_p + offset))\n        offset += vertices_p['position'].shape[0]\n\n    vertices = np.zeros(positions.shape[0],\n                        [('position', np.float32, 3),\n                         ('texcoord', np.float32, 2),\n                         ('normal', np.float32, 3),\n                         ('color', np.float32, 4)])\n\n    colors = np.ravel(positions)\n    colors = np.hstack((np.reshape(np.interp(colors,\n                                             (np.min(colors),\n                                              np.max(colors)),\n                                             (0, 1)),\n                                   positions.shape),\n                        np.ones((positions.shape[0], 1))))\n\n    vertices['position'] = positions\n    vertices['texcoord'] = texcoords\n    vertices['normal'] = normals\n    vertices['color'] = colors\n\n    return vertices, faces, outline",
  "def _latitude(rows, cols, radius, offset):\n    verts = np.empty((rows+1, cols, 3), dtype=np.float32)\n\n    # compute vertices\n    phi = (np.arange(rows+1) * np.pi / rows).reshape(rows+1, 1)\n    s = radius * np.sin(phi)\n    verts[..., 2] = radius * np.cos(phi)\n    th = ((np.arange(cols) * 2 * np.pi / cols).reshape(1, cols))\n    if offset:\n        # rotate each row by 1/2 column\n        th = th + ((np.pi / cols) * np.arange(rows+1).reshape(rows+1, 1))\n    verts[..., 0] = s * np.cos(th)\n    verts[..., 1] = s * np.sin(th)\n    # remove redundant vertices from top and bottom\n    verts = verts.reshape((rows+1)*cols, 3)[cols-1:-(cols-1)]\n\n    # compute faces\n    faces = np.empty((rows*cols*2, 3), dtype=np.uint32)\n    rowtemplate1 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[1, 0, 0]])) % cols) +\n                    np.array([[0, 0, cols]]))\n    rowtemplate2 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[1, 0, 1]])) % cols) +\n                    np.array([[0, cols, cols]]))\n    for row in range(rows):\n        start = row * cols * 2\n        faces[start:start+cols] = rowtemplate1 + row * cols\n        faces[start+cols:start+(cols*2)] = rowtemplate2 + row * cols\n    # cut off zero-area triangles at top and bottom\n    faces = faces[cols:-cols]\n\n    # adjust for redundant vertices that were removed from top and bottom\n    vmin = cols-1\n    faces[faces < vmin] = vmin\n    faces -= vmin\n    vmax = verts.shape[0]-1\n    faces[faces > vmax] = vmax\n    return MeshData(vertices=verts, faces=faces)",
  "def _ico(radius, subdivisions):\n    # golden ratio\n    t = (1.0 + np.sqrt(5.0))/2.0\n\n    # vertices of a icosahedron\n    verts = [(-1, t, 0),\n             (1, t, 0),\n             (-1, -t, 0),\n             (1, -t, 0),\n             (0, -1, t),\n             (0, 1, t),\n             (0, -1, -t),\n             (0, 1, -t),\n             (t, 0, -1),\n             (t, 0, 1),\n             (-t, 0, -1),\n             (-t, 0, 1)]\n\n    # faces of the icosahedron\n    faces = [(0, 11, 5),\n             (0, 5, 1),\n             (0, 1, 7),\n             (0, 7, 10),\n             (0, 10, 11),\n             (1, 5, 9),\n             (5, 11, 4),\n             (11, 10, 2),\n             (10, 7, 6),\n             (7, 1, 8),\n             (3, 9, 4),\n             (3, 4, 2),\n             (3, 2, 6),\n             (3, 6, 8),\n             (3, 8, 9),\n             (4, 9, 5),\n             (2, 4, 11),\n             (6, 2, 10),\n             (8, 6, 7),\n             (9, 8, 1)]\n\n    def midpoint(v1, v2):\n        return ((v1[0]+v2[0])/2, (v1[1]+v2[1])/2, (v1[2]+v2[2])/2)\n\n    # subdivision\n    for _ in range(subdivisions):\n        for idx in range(len(faces)):\n            i, j, k = faces[idx]\n            a, b, c = verts[i], verts[j], verts[k]\n            ab, bc, ca = midpoint(a, b), midpoint(b, c), midpoint(c, a)\n            verts += [ab, bc, ca]\n            ij, jk, ki = len(verts)-3, len(verts)-2, len(verts)-1\n            faces.append([i, ij, ki])\n            faces.append([ij, j, jk])\n            faces.append([ki, jk, k])\n            faces[idx] = [jk, ki, ij]\n    verts = np.array(verts, dtype=np.float32)\n    faces = np.array(faces, dtype=np.uint32)\n\n    # make each vertex to lie on the sphere\n    lengths = np.sqrt((verts*verts).sum(axis=1))\n    verts /= lengths[:, np.newaxis]/radius\n    return MeshData(vertices=verts, faces=faces)",
  "def _cube(rows, cols, depth, radius):\n    # vertices and faces of tessellated cube\n    verts, faces, _ = create_box(1, 1, 1, cols, rows, depth)\n    verts = verts['position']\n\n    # make each vertex to lie on the sphere\n    lengths = np.sqrt((verts*verts).sum(axis=1))\n    verts /= lengths[:, np.newaxis]/radius\n    return MeshData(vertices=verts, faces=faces)",
  "def create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n                  subdivisions=3, method='latitude'):\n    \"\"\"Create a sphere\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows (for method='latitude' and 'cube').\n    cols : int\n        Number of columns (for method='latitude' and 'cube').\n    depth : int\n        Number of depth segments (for method='cube').\n    radius : float\n        Sphere radius.\n    offset : bool\n        Rotate each row by half a column (for method='latitude').\n    subdivisions : int\n        Number of subdivisions to perform (for method='ico')\n    method : str\n        Method for generating sphere. Accepts 'latitude' for latitude-\n        longitude, 'ico' for icosahedron, and 'cube' for cube based\n        tessellation.\n\n    Returns\n    -------\n    sphere : MeshData\n        Vertices and faces computed for a spherical surface.\n    \"\"\"\n    if method == 'latitude':\n        return _latitude(rows, cols, radius, offset)\n    elif method == 'ico':\n        return _ico(radius, subdivisions)\n    elif method == 'cube':\n        return _cube(rows, cols, depth, radius)\n    else:\n        raise Exception(\"Invalid method. Accepts: 'latitude', 'ico', 'cube'\")",
  "def create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False):\n    \"\"\"Create a cylinder\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows.\n    cols : int\n        Number of columns.\n    radius : tuple of float\n        Cylinder radii.\n    length : float\n        Length of the cylinder.\n    offset : bool\n        Rotate each row by half a column.\n\n    Returns\n    -------\n    cylinder : MeshData\n        Vertices and faces computed for a cylindrical surface.\n    \"\"\"\n    verts = np.empty((rows+1, cols, 3), dtype=np.float32)\n    if isinstance(radius, int):\n        radius = [radius, radius]  # convert to list\n    # compute vertices\n    th = np.linspace(2 * np.pi, 0, cols).reshape(1, cols)\n    # radius as a function of z\n    r = np.linspace(radius[0], radius[1], num=rows+1,\n                    endpoint=True).reshape(rows+1, 1)\n    verts[..., 2] = np.linspace(0, length, num=rows+1,\n                                endpoint=True).reshape(rows+1, 1)  # z\n    if offset:\n        # rotate each row by 1/2 column\n        th = th + ((np.pi / cols) * np.arange(rows+1).reshape(rows+1, 1))\n    verts[..., 0] = r * np.cos(th)  # x = r cos(th)\n    verts[..., 1] = r * np.sin(th)  # y = r sin(th)\n    # just reshape: no redundant vertices...\n    verts = verts.reshape((rows+1)*cols, 3)\n    # compute faces\n    faces = np.empty((rows*cols*2, 3), dtype=np.uint32)\n    rowtemplate1 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[0, 1, 0]])) % cols) +\n                    np.array([[0, 0, cols]]))\n    rowtemplate2 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[0, 1, 1]])) % cols) +\n                    np.array([[cols, 0, cols]]))\n    for row in range(rows):\n        start = row * cols * 2\n        faces[start:start+cols] = rowtemplate1 + row * cols\n        faces[start+cols:start+(cols*2)] = rowtemplate2 + row * cols\n\n    return MeshData(vertices=verts, faces=faces)",
  "def create_cone(cols, radius=1.0, length=1.0):\n    \"\"\"Create a cone\n\n    Parameters\n    ----------\n    cols : int\n        Number of faces.\n    radius : float\n        Base cone radius.\n    length : float\n        Length of the cone.\n\n    Returns\n    -------\n    cone : MeshData\n        Vertices and faces computed for a cone surface.\n    \"\"\"\n    verts = np.empty((cols+1, 3), dtype=np.float32)\n    # compute vertexes\n    th = np.linspace(2 * np.pi, 0, cols+1).reshape(1, cols+1)\n    verts[:-1, 2] = 0.0\n    verts[:-1, 0] = radius * np.cos(th[0, :-1])  # x = r cos(th)\n    verts[:-1, 1] = radius * np.sin(th[0, :-1])  # y = r sin(th)\n    # Add the extremity\n    verts[-1, 0] = 0.0\n    verts[-1, 1] = 0.0\n    verts[-1, 2] = length\n    verts = verts.reshape((cols+1), 3)  # just reshape: no redundant vertices\n    # compute faces\n    faces = np.empty((cols, 3), dtype=np.uint32)\n    template = np.array([[0, 1]])\n    for pos in range(cols):\n        faces[pos, :-1] = template + pos\n    faces[:, 2] = cols\n    faces[-1, 1] = 0\n\n    return MeshData(vertices=verts, faces=faces)",
  "def create_arrow(rows, cols, radius=0.1, length=1.0,\n                 cone_radius=None, cone_length=None):\n    \"\"\"Create a 3D arrow using a cylinder plus cone\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows.\n    cols : int\n        Number of columns.\n    radius : float\n        Base cylinder radius.\n    length : float\n        Length of the arrow.\n    cone_radius : float\n        Radius of the cone base.\n           If None, then this defaults to 2x the cylinder radius.\n    cone_length : float\n        Length of the cone.\n           If None, then this defaults to 1/3 of the arrow length.\n\n    Returns\n    -------\n    arrow : MeshData\n        Vertices and faces computed for a cone surface.\n    \"\"\"\n    # create the cylinder\n    md_cyl = None\n    if cone_radius is None:\n        cone_radius = radius*2.0\n    if cone_length is None:\n        con_L = length/3.0\n        cyl_L = length*2.0/3.0\n    else:\n        cyl_L = max(0, length - cone_length)\n        con_L = min(cone_length, length)\n    if cyl_L != 0:\n        md_cyl = create_cylinder(rows, cols, radius=[radius, radius],\n                                 length=cyl_L)\n    # create the cone\n    md_con = create_cone(cols, radius=cone_radius, length=con_L)\n    verts = md_con.get_vertices()\n    nbr_verts_con = verts.size//3\n    faces = md_con.get_faces()\n    if md_cyl is not None:\n        trans = np.array([[0.0, 0.0, cyl_L]])\n        verts = np.vstack((verts+trans, md_cyl.get_vertices()))\n        faces = np.vstack((faces, md_cyl.get_faces()+nbr_verts_con))\n\n    return MeshData(vertices=verts, faces=faces)",
  "def create_grid_mesh(xs, ys, zs):\n    \"\"\"Generate vertices and indices for an implicitly connected mesh.\n\n    The intention is that this makes it simple to generate a mesh\n    from meshgrid data.\n\n    Parameters\n    ----------\n    xs : ndarray\n        A 2d array of x coordinates for the vertices of the mesh. Must\n        have the same dimensions as ys and zs.\n    ys : ndarray\n        A 2d array of y coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and zs.\n    zs : ndarray\n        A 2d array of z coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and ys.\n\n    Returns\n    -------\n    vertices : ndarray\n        The array of vertices in the mesh.\n    indices : ndarray\n        The array of indices for the mesh.\n    \"\"\"\n    shape = xs.shape\n    length = shape[0] * shape[1]\n\n    vertices = np.zeros((length, 3))\n\n    vertices[:, 0] = xs.reshape(length)\n    vertices[:, 1] = ys.reshape(length)\n    vertices[:, 2] = zs.reshape(length)\n\n    basic_indices = np.array([0, 1, 1 + shape[1], 0,\n                              0 + shape[1], 1 + shape[1]],\n                             dtype=np.uint32)\n\n    inner_grid_length = (shape[0] - 1) * (shape[1] - 1)\n\n    offsets = np.arange(inner_grid_length)\n    offsets += np.repeat(np.arange(shape[0] - 1), shape[1] - 1)\n    offsets = np.repeat(offsets, 6)\n    indices = np.resize(basic_indices, len(offsets)) + offsets\n\n    indices = indices.reshape((len(indices) // 3, 3))\n\n    return vertices, indices",
  "def midpoint(v1, v2):\n        return ((v1[0]+v2[0])/2, (v1[1]+v2[1])/2, (v1[2]+v2[2])/2)",
  "def isosurface(data, level):\n    \"\"\"\n    Generate isosurface from volumetric data using marching cubes algorithm.\n    See Paul Bourke, \"Polygonising a Scalar Field\"  \n    (http://paulbourke.net/geometry/polygonise/)\n\n    *data*   3D numpy array of scalar values\n    *level*  The level at which to generate an isosurface\n\n    Returns an array of vertex coordinates (Nv, 3) and an array of \n    per-face vertex indexes (Nf, 3)    \n    \"\"\"\n    # For improvement, see:\n    # \n    # Efficient implementation of Marching Cubes' cases with topological \n    # guarantees.\n    # Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares.\n    # Journal of Graphics Tools 8(2): pp. 1-15 (december 2003)\n\n    (face_shift_tables, edge_shifts, \n     edge_table, n_table_faces) = _get_data_cache()\n\n    # mark everything below the isosurface level\n    mask = data < level\n\n    # Because we make use of the strides data attribute below, we have to make \n    # sure that the data is contiguous (which it won't be if the user did \n    # data.transpose() for example). Note that this doesn't copy the data if it \n    # is already contiguous.\n    data = np.ascontiguousarray(data)\n\n    # make eight sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2, 2, 2), dtype=object)\n    slices = [slice(0, -1), slice(1, None)]\n    for i in [0, 1]:\n        for j in [0, 1]:\n            for k in [0, 1]:\n                fields[i, j, k] = mask[slices[i], slices[j], slices[k]]\n                # this is just to match Bourk's vertex numbering scheme:\n                vertIndex = i - 2*j*i + 3*j + 4*k\n                index += (fields[i, j, k] * 2**vertIndex).astype(np.ubyte)\n\n    # Generate table of edges that have been cut\n    cut_edges = np.zeros([x+1 for x in index.shape]+[3], dtype=np.uint32)\n    edges = edge_table[index]\n    for i, shift in enumerate(edge_shifts[:12]):        \n        slices = [slice(shift[j], cut_edges.shape[j]+(shift[j]-1)) \n                  for j in range(3)]\n        cut_edges[slices[0], slices[1], slices[2], shift[3]] += edges & 2**i\n\n    # for each cut edge, interpolate to see where exactly the edge is cut and \n    # generate vertex positions\n    m = cut_edges > 0\n    vertex_inds = np.argwhere(m)  # argwhere is slow!\n    vertexes = vertex_inds[:, :3].astype(np.float32).copy()\n    dataFlat = data.reshape(data.shape[0]*data.shape[1]*data.shape[2])\n\n    # re-use the cut_edges array as a lookup table for vertex IDs\n    cut_edges[vertex_inds[:, 0], \n              vertex_inds[:, 1], \n              vertex_inds[:, 2], \n              vertex_inds[:, 3]] = np.arange(vertex_inds.shape[0])\n\n    for i in [0, 1, 2]:\n        vim = vertex_inds[:, 3] == i\n        vi = vertex_inds[vim, :3]\n        vi_flat = (vi * (np.array(data.strides[:3]) // \n                         data.itemsize)[np.newaxis, :]).sum(axis=1)\n        v1 = dataFlat[vi_flat]\n        v2 = dataFlat[vi_flat + data.strides[i]//data.itemsize]\n        vertexes[vim, i] += (level-v1) / (v2-v1)\n\n    # compute the set of vertex indexes for each face. \n\n    # This works, but runs a bit slower.\n    # all cells with at least one face:\n    # cells = np.argwhere((index != 0) & (index != 255))  \n    # cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]\n    # verts = faceTable[cellInds]\n    # mask = verts[..., 0, 0] != 9\n    # we now have indexes into cut_edges:\n    # verts[...,:3] += cells[:, np.newaxis, np.newaxis,:]\n    # verts = verts[mask]\n    # and these are the vertex indexes we want:\n    # faces = cut_edges[verts[..., 0], verts[..., 1], verts[..., 2], \n    #                  verts[..., 3]]  \n\n    # To allow this to be vectorized efficiently, we count the number of faces \n    # in each grid cell and handle each group of cells with the same number \n    # together.\n\n    # determine how many faces to assign to each grid cell\n    n_faces = n_table_faces[index]\n    tot_faces = n_faces.sum()\n    faces = np.empty((tot_faces, 3), dtype=np.uint32)\n    ptr = 0\n\n    # this helps speed up an indexing operation later on\n    cs = np.array(cut_edges.strides)//cut_edges.itemsize\n    cut_edges = cut_edges.flatten()\n\n    # this, strangely, does not seem to help.\n    # ins = np.array(index.strides)/index.itemsize\n    # index = index.flatten()\n\n    for i in range(1, 6):\n        # expensive:\n        # all cells which require i faces  (argwhere is expensive)\n        cells = np.argwhere(n_faces == i)  \n        if cells.shape[0] == 0:\n            continue\n        # index values of cells to process for this round:\n        cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]\n\n        # expensive:\n        verts = face_shift_tables[i][cellInds]\n        # we now have indexes into cut_edges:\n        verts[..., :3] += (cells[:, np.newaxis,\n                                 np.newaxis, :]).astype(np.uint16)\n        verts = verts.reshape((verts.shape[0]*i,)+verts.shape[2:])\n\n        # expensive:\n        verts = (verts * cs[np.newaxis, np.newaxis, :]).sum(axis=2)\n        vert_inds = cut_edges[verts]\n        nv = vert_inds.shape[0]\n        faces[ptr:ptr+nv] = vert_inds  # .reshape((nv, 3))\n        ptr += nv\n\n    return vertexes, faces",
  "def _get_data_cache():\n    # Precompute lookup tables on the first run\n\n    global _data_cache\n\n    if _data_cache is None:\n        # map from grid cell index to edge index.\n        # grid cell index tells us which corners are below the isosurface,\n        # edge index tells us which edges are cut by the isosurface.\n        # (Data stolen from Bourk; see above.)\n        edge_table = np.array([\n            0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a,\n            0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, \n            0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, \n            0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, \n            0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, \n            0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, \n            0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, \n            0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, \n            0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, \n            0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, \n            0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, \n            0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, \n            0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, \n            0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, \n            0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, \n            0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, \n            0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, \n            0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, \n            0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, \n            0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0], dtype=np.uint16)\n\n        # Table of triangles to use for filling each grid cell.\n        # Each set of three integers tells us which three edges to\n        # draw a triangle between.\n        # (Data stolen from Bourk; see above.)\n        triTable = [\n            [],\n            [0, 8, 3],\n            [0, 1, 9],\n            [1, 8, 3, 9, 8, 1],\n            [1, 2, 10],\n            [0, 8, 3, 1, 2, 10],\n            [9, 2, 10, 0, 2, 9],\n            [2, 8, 3, 2, 10, 8, 10, 9, 8],\n            [3, 11, 2],\n            [0, 11, 2, 8, 11, 0],\n            [1, 9, 0, 2, 3, 11],\n            [1, 11, 2, 1, 9, 11, 9, 8, 11],\n            [3, 10, 1, 11, 10, 3],\n            [0, 10, 1, 0, 8, 10, 8, 11, 10],\n            [3, 9, 0, 3, 11, 9, 11, 10, 9],\n            [9, 8, 10, 10, 8, 11],\n            [4, 7, 8],\n            [4, 3, 0, 7, 3, 4],\n            [0, 1, 9, 8, 4, 7],\n            [4, 1, 9, 4, 7, 1, 7, 3, 1],\n            [1, 2, 10, 8, 4, 7],\n            [3, 4, 7, 3, 0, 4, 1, 2, 10],\n            [9, 2, 10, 9, 0, 2, 8, 4, 7],\n            [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],\n            [8, 4, 7, 3, 11, 2],\n            [11, 4, 7, 11, 2, 4, 2, 0, 4],\n            [9, 0, 1, 8, 4, 7, 2, 3, 11],\n            [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],\n            [3, 10, 1, 3, 11, 10, 7, 8, 4],\n            [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],\n            [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],\n            [4, 7, 11, 4, 11, 9, 9, 11, 10],\n            [9, 5, 4],\n            [9, 5, 4, 0, 8, 3],\n            [0, 5, 4, 1, 5, 0],\n            [8, 5, 4, 8, 3, 5, 3, 1, 5],\n            [1, 2, 10, 9, 5, 4],\n            [3, 0, 8, 1, 2, 10, 4, 9, 5],\n            [5, 2, 10, 5, 4, 2, 4, 0, 2],\n            [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],\n            [9, 5, 4, 2, 3, 11],\n            [0, 11, 2, 0, 8, 11, 4, 9, 5],\n            [0, 5, 4, 0, 1, 5, 2, 3, 11],\n            [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],\n            [10, 3, 11, 10, 1, 3, 9, 5, 4],\n            [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],\n            [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],\n            [5, 4, 8, 5, 8, 10, 10, 8, 11],\n            [9, 7, 8, 5, 7, 9],\n            [9, 3, 0, 9, 5, 3, 5, 7, 3],\n            [0, 7, 8, 0, 1, 7, 1, 5, 7],\n            [1, 5, 3, 3, 5, 7],\n            [9, 7, 8, 9, 5, 7, 10, 1, 2],\n            [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],\n            [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],\n            [2, 10, 5, 2, 5, 3, 3, 5, 7],\n            [7, 9, 5, 7, 8, 9, 3, 11, 2],\n            [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],\n            [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],\n            [11, 2, 1, 11, 1, 7, 7, 1, 5],\n            [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],\n            [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],\n            [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],\n            [11, 10, 5, 7, 11, 5],\n            [10, 6, 5],\n            [0, 8, 3, 5, 10, 6],\n            [9, 0, 1, 5, 10, 6],\n            [1, 8, 3, 1, 9, 8, 5, 10, 6],\n            [1, 6, 5, 2, 6, 1],\n            [1, 6, 5, 1, 2, 6, 3, 0, 8],\n            [9, 6, 5, 9, 0, 6, 0, 2, 6],\n            [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],\n            [2, 3, 11, 10, 6, 5],\n            [11, 0, 8, 11, 2, 0, 10, 6, 5],\n            [0, 1, 9, 2, 3, 11, 5, 10, 6],\n            [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],\n            [6, 3, 11, 6, 5, 3, 5, 1, 3],\n            [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],\n            [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],\n            [6, 5, 9, 6, 9, 11, 11, 9, 8],\n            [5, 10, 6, 4, 7, 8],\n            [4, 3, 0, 4, 7, 3, 6, 5, 10],\n            [1, 9, 0, 5, 10, 6, 8, 4, 7],\n            [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],\n            [6, 1, 2, 6, 5, 1, 4, 7, 8],\n            [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],\n            [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],\n            [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],\n            [3, 11, 2, 7, 8, 4, 10, 6, 5],\n            [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],\n            [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],\n            [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],\n            [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],\n            [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],\n            [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],\n            [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],\n            [10, 4, 9, 6, 4, 10],\n            [4, 10, 6, 4, 9, 10, 0, 8, 3],\n            [10, 0, 1, 10, 6, 0, 6, 4, 0],\n            [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],\n            [1, 4, 9, 1, 2, 4, 2, 6, 4],\n            [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],\n            [0, 2, 4, 4, 2, 6],\n            [8, 3, 2, 8, 2, 4, 4, 2, 6],\n            [10, 4, 9, 10, 6, 4, 11, 2, 3],\n            [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],\n            [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],\n            [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],\n            [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],\n            [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],\n            [3, 11, 6, 3, 6, 0, 0, 6, 4],\n            [6, 4, 8, 11, 6, 8],\n            [7, 10, 6, 7, 8, 10, 8, 9, 10],\n            [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],\n            [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],\n            [10, 6, 7, 10, 7, 1, 1, 7, 3],\n            [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],\n            [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],\n            [7, 8, 0, 7, 0, 6, 6, 0, 2],\n            [7, 3, 2, 6, 7, 2],\n            [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],\n            [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],\n            [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],\n            [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],\n            [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],\n            [0, 9, 1, 11, 6, 7],\n            [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],\n            [7, 11, 6],\n            [7, 6, 11],\n            [3, 0, 8, 11, 7, 6],\n            [0, 1, 9, 11, 7, 6],\n            [8, 1, 9, 8, 3, 1, 11, 7, 6],\n            [10, 1, 2, 6, 11, 7],\n            [1, 2, 10, 3, 0, 8, 6, 11, 7],\n            [2, 9, 0, 2, 10, 9, 6, 11, 7],\n            [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],\n            [7, 2, 3, 6, 2, 7],\n            [7, 0, 8, 7, 6, 0, 6, 2, 0],\n            [2, 7, 6, 2, 3, 7, 0, 1, 9],\n            [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],\n            [10, 7, 6, 10, 1, 7, 1, 3, 7],\n            [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],\n            [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],\n            [7, 6, 10, 7, 10, 8, 8, 10, 9],\n            [6, 8, 4, 11, 8, 6],\n            [3, 6, 11, 3, 0, 6, 0, 4, 6],\n            [8, 6, 11, 8, 4, 6, 9, 0, 1],\n            [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],\n            [6, 8, 4, 6, 11, 8, 2, 10, 1],\n            [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],\n            [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],\n            [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],\n            [8, 2, 3, 8, 4, 2, 4, 6, 2],\n            [0, 4, 2, 4, 6, 2],\n            [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],\n            [1, 9, 4, 1, 4, 2, 2, 4, 6],\n            [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],\n            [10, 1, 0, 10, 0, 6, 6, 0, 4],\n            [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],\n            [10, 9, 4, 6, 10, 4],\n            [4, 9, 5, 7, 6, 11],\n            [0, 8, 3, 4, 9, 5, 11, 7, 6],\n            [5, 0, 1, 5, 4, 0, 7, 6, 11],\n            [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],\n            [9, 5, 4, 10, 1, 2, 7, 6, 11],\n            [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],\n            [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],\n            [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],\n            [7, 2, 3, 7, 6, 2, 5, 4, 9],\n            [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],\n            [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],\n            [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],\n            [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],\n            [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],\n            [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],\n            [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],\n            [6, 9, 5, 6, 11, 9, 11, 8, 9],\n            [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],\n            [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],\n            [6, 11, 3, 6, 3, 5, 5, 3, 1],\n            [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],\n            [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],\n            [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],\n            [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],\n            [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],\n            [9, 5, 6, 9, 6, 0, 0, 6, 2],\n            [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],\n            [1, 5, 6, 2, 1, 6],\n            [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],\n            [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],\n            [0, 3, 8, 5, 6, 10],\n            [10, 5, 6],\n            [11, 5, 10, 7, 5, 11],\n            [11, 5, 10, 11, 7, 5, 8, 3, 0],\n            [5, 11, 7, 5, 10, 11, 1, 9, 0],\n            [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],\n            [11, 1, 2, 11, 7, 1, 7, 5, 1],\n            [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],\n            [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],\n            [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],\n            [2, 5, 10, 2, 3, 5, 3, 7, 5],\n            [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],\n            [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],\n            [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],\n            [1, 3, 5, 3, 7, 5],\n            [0, 8, 7, 0, 7, 1, 1, 7, 5],\n            [9, 0, 3, 9, 3, 5, 5, 3, 7],\n            [9, 8, 7, 5, 9, 7],\n            [5, 8, 4, 5, 10, 8, 10, 11, 8],\n            [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],\n            [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],\n            [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],\n            [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],\n            [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],\n            [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],\n            [9, 4, 5, 2, 11, 3],\n            [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],\n            [5, 10, 2, 5, 2, 4, 4, 2, 0],\n            [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],\n            [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],\n            [8, 4, 5, 8, 5, 3, 3, 5, 1],\n            [0, 4, 5, 1, 0, 5],\n            [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],\n            [9, 4, 5],\n            [4, 11, 7, 4, 9, 11, 9, 10, 11],\n            [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],\n            [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],\n            [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],\n            [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],\n            [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],\n            [11, 7, 4, 11, 4, 2, 2, 4, 0],\n            [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],\n            [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],\n            [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],\n            [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],\n            [1, 10, 2, 8, 7, 4],\n            [4, 9, 1, 4, 1, 7, 7, 1, 3],\n            [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],\n            [4, 0, 3, 7, 4, 3],\n            [4, 8, 7],\n            [9, 10, 8, 10, 11, 8],\n            [3, 0, 9, 3, 9, 11, 11, 9, 10],\n            [0, 1, 10, 0, 10, 8, 8, 10, 11],\n            [3, 1, 10, 11, 3, 10],\n            [1, 2, 11, 1, 11, 9, 9, 11, 8],\n            [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],\n            [0, 2, 11, 8, 0, 11],\n            [3, 2, 11],\n            [2, 3, 8, 2, 8, 10, 10, 8, 9],\n            [9, 10, 2, 0, 9, 2],\n            [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],\n            [1, 10, 2],\n            [1, 3, 8, 9, 1, 8],\n            [0, 9, 1],\n            [0, 3, 8],\n            []\n        ]\n\n        # maps edge ID (0-11) to (x, y, z) cell offset and edge ID (0-2)\n        edge_shifts = np.array([\n            [0, 0, 0, 0],   \n            [1, 0, 0, 1],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 1],\n            [0, 1, 1, 0],\n            [0, 0, 1, 1],\n            [0, 0, 0, 2],\n            [1, 0, 0, 2],\n            [1, 1, 0, 2],\n            [0, 1, 0, 2],\n            # [9, 9, 9, 9] fake\n            # don't use ubyte here! This value gets added to cell index later; \n            # will need the extra precision.\n        ], dtype=np.uint16) \n        n_table_faces = np.array([len(f)/3 for f in triTable], dtype=np.ubyte)\n        face_shift_tables = [None]\n        for i in range(1, 6):\n            # compute lookup table of index: vertexes mapping\n            faceTableI = np.zeros((len(triTable), i*3), dtype=np.ubyte)\n            faceTableInds = np.argwhere(n_table_faces == i)[:, 0]\n            faceTableI[faceTableInds] = np.array([triTable[j] for j in\n                                                  faceTableInds])\n            faceTableI = faceTableI.reshape((len(triTable), i, 3))\n            face_shift_tables.append(edge_shifts[faceTableI])\n\n        _data_cache = (face_shift_tables, edge_shifts, edge_table, \n                       n_table_faces)\n\n    return _data_cache",
  "class PolygonData(object):\n    \"\"\"Polygon class for data handling\n\n    Parameters\n    ----------\n    vertices : (Nv, 3) array\n        Vertex coordinates. If faces is not specified, then this will instead\n        be interpreted as (Nf, 3, 3) array of coordinates.\n    edges : (Nv, 2) array\n        Constraining edges specified by vertex indices.\n    faces : (Nf, 3) array\n        Indexes into the vertex array.\n\n    Notes\n    -----\n    All arguments are optional.\n    \"\"\"\n\n    def __init__(self, vertices=None, edges=None, faces=None):\n        self._vertices = vertices\n        self._edges = edges\n        self._faces = faces\n        self._convex_hull = None\n\n    @property\n    def faces(self):\n        \"\"\"Return an array (Nf, 3) of vertex indexes, three per triangular\n        face in the mesh.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._faces\n\n    @faces.setter\n    def faces(self, f):\n        \"\"\"If vertices and faces are incompatible, this will generate vertices\n        from these faces and set them.\n        \"\"\"\n        self._faces = f\n\n    @property\n    def vertices(self):\n        \"\"\"Return an array (Nf, 3) of vertices.\n\n        If only faces exist, the function computes the vertices and\n        returns them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._vertices\n\n    @vertices.setter\n    def vertices(self, v):\n        \"\"\"If vertices and faces are incompatible, this will generate faces\n        from these vertices and set them.\n        \"\"\"\n        self._vertices = v\n\n    @property\n    def edges(self):\n        \"\"\"Return an array (Nv, 2) of vertex indices.\n\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        return self._edges\n\n    @edges.setter\n    def edges(self, e):\n        \"\"\"Ensures that all edges are valid.\"\"\"\n        self._edges = e\n\n    @property\n    def convex_hull(self):\n        \"\"\"Return an array of vertex indexes representing the convex hull.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._convex_hull\n\n    def triangulate(self):\n        \"\"\"\n        Triangulates the set of vertices and stores the triangles in faces and\n        the convex hull in convex_hull.\n        \"\"\"\n        npts = self._vertices.shape[0]\n        if np.any(self._vertices[0] != self._vertices[1]):\n            # start != end, so edges must wrap around to beginning.\n            edges = np.empty((npts, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n            edges[-1, 1] = 0\n        else:\n            # start == end; no wrapping required.\n            edges = np.empty((npts-1, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n\n        tri = Triangulation(self._vertices, edges)\n        tri.triangulate()\n        return tri.pts, tri.tris\n\n    def add_vertex(self, vertex):\n        \"\"\"\n        Adds given vertex and retriangulates to generate new faces.\n\n        Parameters\n        ----------\n        vertex : array-like\n            The vertex to add.\n        \"\"\"\n        raise NotImplementedError",
  "def __init__(self, vertices=None, edges=None, faces=None):\n        self._vertices = vertices\n        self._edges = edges\n        self._faces = faces\n        self._convex_hull = None",
  "def faces(self):\n        \"\"\"Return an array (Nf, 3) of vertex indexes, three per triangular\n        face in the mesh.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._faces",
  "def faces(self, f):\n        \"\"\"If vertices and faces are incompatible, this will generate vertices\n        from these faces and set them.\n        \"\"\"\n        self._faces = f",
  "def vertices(self):\n        \"\"\"Return an array (Nf, 3) of vertices.\n\n        If only faces exist, the function computes the vertices and\n        returns them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._vertices",
  "def vertices(self, v):\n        \"\"\"If vertices and faces are incompatible, this will generate faces\n        from these vertices and set them.\n        \"\"\"\n        self._vertices = v",
  "def edges(self):\n        \"\"\"Return an array (Nv, 2) of vertex indices.\n\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        return self._edges",
  "def edges(self, e):\n        \"\"\"Ensures that all edges are valid.\"\"\"\n        self._edges = e",
  "def convex_hull(self):\n        \"\"\"Return an array of vertex indexes representing the convex hull.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._convex_hull",
  "def triangulate(self):\n        \"\"\"\n        Triangulates the set of vertices and stores the triangles in faces and\n        the convex hull in convex_hull.\n        \"\"\"\n        npts = self._vertices.shape[0]\n        if np.any(self._vertices[0] != self._vertices[1]):\n            # start != end, so edges must wrap around to beginning.\n            edges = np.empty((npts, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n            edges[-1, 1] = 0\n        else:\n            # start == end; no wrapping required.\n            edges = np.empty((npts-1, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n\n        tri = Triangulation(self._vertices, edges)\n        tri.triangulate()\n        return tri.pts, tri.tris",
  "def add_vertex(self, vertex):\n        \"\"\"\n        Adds given vertex and retriangulates to generate new faces.\n\n        Parameters\n        ----------\n        vertex : array-like\n            The vertex to add.\n        \"\"\"\n        raise NotImplementedError",
  "def surface(func, umin=0, umax=2 * np.pi, ucount=64, urepeat=1.0,\n            vmin=0, vmax=2 * np.pi, vcount=64, vrepeat=1.0):\n    \"\"\"\n    Computes the parameterization of a parametric surface\n\n    func: function(u,v)\n        Parametric function used to build the surface\n    \"\"\"\n    vtype = [('position', np.float32, 3),\n             ('texcoord', np.float32, 2),\n             ('normal', np.float32, 3)]\n    itype = np.uint32\n\n    # umin, umax, ucount = 0, 2*np.pi, 64\n    # vmin, vmax, vcount = 0, 2*np.pi, 64\n\n    vcount += 1\n    ucount += 1\n    n = vcount * ucount\n\n    Un = np.repeat(np.linspace(0, 1, ucount, endpoint=True), vcount)\n    Vn = np.tile(np.linspace(0, 1, vcount, endpoint=True), ucount)\n    U = umin + Un * (umax - umin)\n    V = vmin + Vn * (vmax - vmin)\n\n    vertices = np.zeros(n, dtype=vtype)\n    for i, (u, v) in enumerate(zip(U, V)):\n        vertices[\"position\"][i] = func(u, v)\n\n    vertices[\"texcoord\"][:, 0] = Un * urepeat\n    vertices[\"texcoord\"][:, 1] = Vn * vrepeat\n\n    indices = []\n    for i in range(ucount - 1):\n        for j in range(vcount - 1):\n            indices.append(i * (vcount) + j)\n            indices.append(i * (vcount) + j + 1)\n            indices.append(i * (vcount) + j + vcount + 1)\n            indices.append(i * (vcount) + j + vcount)\n            indices.append(i * (vcount) + j + vcount + 1)\n            indices.append(i * (vcount) + j)\n    indices = np.array(indices, dtype=itype)\n    vertices[\"normal\"] = normals(vertices[\"position\"],\n                                 indices.reshape(len(indices)//3, 3))\n\n    return vertices, indices",
  "class Triangulation(object):\n    \"\"\"Constrained delaunay triangulation\n\n    Implementation based on [1]_.\n\n    Parameters\n    ----------\n    pts : array\n        Nx2 array of points.\n    edges : array\n        Nx2 array of edges (dtype=int).\n\n    Notes\n    -----\n    * Delaunay legalization is not yet implemented. This produces a proper\n      triangulation, but adding legalisation would produce fewer thin\n      triangles.\n    * The pts and edges arrays may be modified.\n\n    References\n    ----------\n    .. [1] Domiter, V. and \u017dalik, B. Sweep\u2010line algorithm for constrained\n       Delaunay triangulation\n    \"\"\"\n\n    def __init__(self, pts, edges):\n        self.pts = pts[:, :2].astype(np.float32)\n        self.edges = edges\n        if self.pts.ndim != 2 or self.pts.shape[1] != 2:\n            raise TypeError('pts argument must be ndarray of shape (N, 2).')\n        if self.edges.ndim != 2 or self.edges.shape[1] != 2:\n            raise TypeError('edges argument must be ndarray of shape (N, 2).')\n\n        # described in initialize()\n        self._front = None\n        self.tris = OrderedDict()\n        self._edges_lookup = {}\n\n    def _normalize(self):\n        # Clean up data   (not discussed in original publication)\n\n        # (i) Split intersecting edges. Every edge that intersects another\n        #     edge or point is split. This extends self.pts and self.edges.\n        self._split_intersecting_edges()\n\n        # (ii) Merge identical points. If any two points are found to be equal,\n        #      the second is removed and the edge table is updated accordingly.\n        self._merge_duplicate_points()\n\n        # (iii) Remove duplicate edges\n        # TODO\n\n    def _initialize(self):\n        self._normalize()\n        # Initialization (sec. 3.3)\n\n        # sort points by y, then x\n        flat_shape = self.pts.shape[0] * self.pts.shape[1]\n        pts = self.pts.reshape(flat_shape).view([('x', np.float32),\n                                                 ('y', np.float32)])\n        order = np.argsort(pts, order=('y', 'x'))\n        pts = pts[order]\n        # update edges to match new point order\n        invorder = np.argsort(order)\n        self.edges = invorder[self.edges]\n        self.pts = pts.view(np.float32).reshape(len(pts), 2)\n\n        # make artificial points P-1 and P-2\n        xmax = self.pts[:, 0].max()\n        xmin = self.pts[:, 0].min()\n        ymax = self.pts[:, 1].max()\n        ymin = self.pts[:, 1].min()\n        xa = (xmax-xmin) * 0.3\n        ya = (ymax-ymin) * 0.3\n        p1 = (xmin - xa, ymin - ya)\n        p2 = (xmax + xa, ymin - ya)\n\n        # prepend artificial points to point list\n        newpts = np.empty((self.pts.shape[0]+2, 2), dtype=float)\n        newpts[0] = p1\n        newpts[1] = p2\n        newpts[2:] = self.pts\n        self.pts = newpts\n        self.edges += 2\n\n        # find topmost point in each edge\n        self._tops = self.edges.max(axis=1)\n        self._bottoms = self.edges.min(axis=1)\n\n        # inintialize sweep front\n        # values in this list are indexes into self.pts\n        self._front = [0, 2, 1]\n\n        # empty triangle list.\n        # This will contain [(a, b, c), ...] where a,b,c are indexes into\n        # self.pts\n        self.tris = OrderedDict()\n\n        # For each triangle, maps (a, b): c\n        # This is used to look up the thrid point in a triangle, given any\n        # edge. Since each edge has two triangles, they are independently\n        # stored as (a, b): c and (b, a): d\n        self._edges_lookup = {}\n\n    def triangulate(self):\n        \"\"\"Do the triangulation.\"\"\"\n        self._initialize()\n\n        pts = self.pts\n        front = self._front\n\n        # Begin sweep (sec. 3.4)\n        for i in range(3, pts.shape[0]):\n            pi = pts[i]\n\n            # First, triangulate from front to new point\n            # This applies to both \"point events\" (3.4.1)\n            # and \"edge events\" (3.4.2).\n\n            # get index along front that intersects pts[i]\n            idx = 0\n            while pts[front[idx+1], 0] <= pi[0]:\n                idx += 1\n            pl = pts[front[idx]]\n\n            # \"(i) middle case\"\n            if pi[0] > pl[0]:\n                # Add a single triangle connecting pi,pl,pr\n                self._add_tri(front[idx], front[idx+1], i)\n                front.insert(idx+1, i)\n            # \"(ii) left case\"\n            else:\n                # Add triangles connecting pi,pl,ps and pi,pl,pr\n                self._add_tri(front[idx], front[idx+1], i)\n                self._add_tri(front[idx-1], front[idx], i)\n                front[idx] = i\n\n            # Continue adding triangles to smooth out front\n            # (heuristics shown in figs. 9, 10)\n            for direction in -1, 1:\n                while True:\n                    # Find point connected to pi\n                    ind0 = front.index(i)\n                    ind1 = ind0 + direction\n                    ind2 = ind1 + direction\n                    if ind2 < 0 or ind2 >= len(front):\n                        break\n\n                    # measure angle made with front\n                    p1 = pts[front[ind1]]\n                    p2 = pts[front[ind2]]\n                    err = np.geterr()\n                    np.seterr(invalid='ignore')\n                    try:\n                        angle = np.arccos(self._cosine(pi, p1, p2))\n                    finally:\n                        np.seterr(**err)\n\n                    # if angle is < pi/2, make new triangle\n                    if angle > np.pi/2. or np.isnan(angle):\n                        break\n\n                    assert (i != front[ind1] and\n                            front[ind1] != front[ind2] and\n                            front[ind2] != i)\n                    self._add_tri(i, front[ind1], front[ind2])\n                    front.pop(ind1)\n\n            # \"edge event\" (sec. 3.4.2)\n            # remove any triangles cut by completed edges and re-fill\n            # the holes.\n            if i in self._tops:\n                for j in self._bottoms[self._tops == i]:\n                    # Make sure edge (j, i) is present in mesh\n                    # because edge event may have created a new front list\n                    self._edge_event(i, j)\n                    front = self._front\n\n        self._finalize()\n\n        self.tris = np.array(list(self.tris.keys()), dtype=int)\n\n    def _finalize(self):\n        # Finalize (sec. 3.5)\n\n        # (i) Add bordering triangles to fill hull\n        front = list(OrderedDict.fromkeys(self._front))\n\n        idx = len(front) - 2\n        k = 1\n        while k < idx-1:\n            # if edges lie in counterclockwise direction, then signed area\n            # is positive\n            if self._iscounterclockwise(front[k], front[k+1], front[k+2]):\n                self._add_tri(front[k], front[k+1], front[k+2])\n                front.pop(k+1)\n                idx -= 1\n                continue\n            k += 1\n\n        # (ii) Remove all triangles not inside the hull\n        #      (not described in article)\n\n        tris = []  # triangles to check\n        tri_state = {}  # 0 for outside, 1 for inside\n\n        # find a starting triangle\n        for t in self.tris:\n            if 0 in t or 1 in t:\n                tri_state[t] = 0\n                tris.append(t)\n                break\n\n        while tris:\n            next_tris = []\n            for t in tris:\n                v = tri_state[t]\n                for i in (0, 1, 2):\n                    edge = (t[i], t[(i + 1) % 3])\n                    pt = t[(i + 2) % 3]\n                    t2 = self._adjacent_tri(edge, pt)\n                    if t2 is None:\n                        continue\n                    t2a = t2[1:3] + t2[0:1]\n                    t2b = t2[2:3] + t2[0:2]\n                    if t2 in tri_state or t2a in tri_state or t2b in tri_state:\n                        continue\n                    if self._is_constraining_edge(edge):\n                        tri_state[t2] = 1 - v\n                    else:\n                        tri_state[t2] = v\n                    next_tris.append(t2)\n            tris = next_tris\n\n        for t, v in tri_state.items():\n            if v == 0:\n                self._remove_tri(*t)\n\n    def _edge_event(self, i, j):\n        \"\"\"Force edge (i, j) to be present in mesh.\n\n        This works by removing intersected triangles and filling holes up to\n        the cutting edge.\n        \"\"\"\n        front_index = self._front.index(i)\n\n        front = self._front\n\n        # First just see whether this edge is already present\n        # (this is not in the published algorithm)\n        if (i, j) in self._edges_lookup or (j, i) in self._edges_lookup:\n            return\n\n        # traverse in two different modes:\n        #  1. If cutting edge is below front, traverse through triangles. These\n        #     must be removed and the resulting hole re-filled. (fig. 12)\n        #  2. If cutting edge is above the front, then follow the front until\n        #     crossing under again. (fig. 13)\n        # We must be able to switch back and forth between these\n        # modes (fig. 14)\n\n        # Collect points that draw the open polygons on either side of the\n        # cutting edge. Note that our use of 'upper' and 'lower' is not strict;\n        # in some cases the two may be swapped.\n        upper_polygon = [i]\n        lower_polygon = [i]\n\n        # Keep track of which section of the front must be replaced\n        # and with what it should be replaced\n        front_holes = []  # contains indexes for sections of front to remove\n\n        next_tri = None   # next triangle to cut (already set if in mode 1)\n        last_edge = None  # or last triangle edge crossed (if in mode 1)\n\n        # Which direction to traverse front\n        front_dir = 1 if self.pts[j][0] > self.pts[i][0] else -1\n\n        # Initialize search state\n        if self._edge_below_front((i, j), front_index):\n            mode = 1  # follow triangles\n            tri = self._find_cut_triangle((i, j))\n            last_edge = self._edge_opposite_point(tri, i)\n            next_tri = self._adjacent_tri(last_edge, i)\n            assert next_tri is not None\n            self._remove_tri(*tri)\n            # todo: does this work? can we count on last_edge to be clockwise\n            # around point i?\n            lower_polygon.append(last_edge[1])\n            upper_polygon.append(last_edge[0])\n        else:\n            mode = 2  # follow front\n\n        # Loop until we reach point j\n        while True:\n            if mode == 1:\n                # crossing from one triangle into another\n                if j in next_tri:\n                    # reached endpoint!\n                    # update front / polygons\n                    upper_polygon.append(j)\n                    lower_polygon.append(j)\n                    self._remove_tri(*next_tri)\n                    break\n                else:\n                    # next triangle does not contain the end point; we will\n                    # cut one of the two far edges.\n                    tri_edges = self._edges_in_tri_except(next_tri, last_edge)\n\n                    # select the edge that is cut\n                    last_edge = self._intersected_edge(tri_edges, (i, j))\n                    last_tri = next_tri\n                    next_tri = self._adjacent_tri(last_edge, last_tri)\n                    self._remove_tri(*last_tri)\n\n                    # Crossing an edge adds one point to one of the polygons\n                    if lower_polygon[-1] == last_edge[0]:\n                        upper_polygon.append(last_edge[1])\n                    elif lower_polygon[-1] == last_edge[1]:\n                        upper_polygon.append(last_edge[0])\n                    elif upper_polygon[-1] == last_edge[0]:\n                        lower_polygon.append(last_edge[1])\n                    elif upper_polygon[-1] == last_edge[1]:\n                        lower_polygon.append(last_edge[0])\n                    else:\n                        raise RuntimeError(\"Something went wrong..\")\n\n                    # If we crossed the front, go to mode 2\n                    x = self._edge_in_front(last_edge)\n                    if x >= 0:  # crossing over front\n                        mode = 2\n                        next_tri = None\n\n                        # where did we cross the front?\n                        # nearest to new point\n                        front_index = x + (1 if front_dir == -1 else 0)\n\n                        # Select the correct polygon to be lower_polygon\n                        # (because mode 2 requires this).\n                        # We know that last_edge is in the front, and\n                        # front[front_index] is the point _above_ the front.\n                        # So if this point is currently the last element in\n                        # lower_polygon, then the polys must be swapped.\n                        if lower_polygon[-1] == front[front_index]:\n                            tmp = lower_polygon, upper_polygon\n                            upper_polygon, lower_polygon = tmp\n                        else:\n                            assert upper_polygon[-1] == front[front_index]\n\n                    else:\n                        assert next_tri is not None\n\n            else:  # mode == 2\n                # At each iteration, we require:\n                #   * front_index is the starting index of the edge _preceding_\n                #     the edge that will be handled in this iteration\n                #   * lower_polygon is the polygon to which points should be\n                #     added while traversing the front\n\n                front_index += front_dir\n                next_edge = (front[front_index], front[front_index+front_dir])\n\n                assert front_index >= 0\n                if front[front_index] == j:\n                    # found endpoint!\n                    lower_polygon.append(j)\n                    upper_polygon.append(j)\n                    break\n\n                # Add point to lower_polygon.\n                # The conditional is because there are cases where the\n                # point was already added if we just crossed from mode 1.\n                if lower_polygon[-1] != front[front_index]:\n                    lower_polygon.append(front[front_index])\n\n                front_holes.append(front_index)\n\n                if self._edges_intersect((i, j), next_edge):\n                    # crossing over front into triangle\n                    mode = 1\n\n                    last_edge = next_edge\n\n                    # we are crossing the front, so this edge only has one\n                    # triangle.\n                    next_tri = self._tri_from_edge(last_edge)\n\n                    upper_polygon.append(front[front_index+front_dir])\n\n        # (iii) triangluate empty areas\n\n        for polygon in [lower_polygon, upper_polygon]:\n            dist = self._distances_from_line((i, j), polygon)\n            while len(polygon) > 2:\n                ind = np.argmax(dist)\n                self._add_tri(polygon[ind], polygon[ind-1],\n                              polygon[ind+1])\n                polygon.pop(ind)\n                dist.pop(ind)\n\n        # update front by removing points in the holes (places where front\n        # passes below the cut edge)\n        front_holes.sort(reverse=True)\n        for i in front_holes:\n            front.pop(i)\n\n    def _find_cut_triangle(self, edge):\n        \"\"\"\n        Return the triangle that has edge[0] as one of its vertices and is\n        bisected by edge.\n\n        Return None if no triangle is found.\n        \"\"\"\n        edges = []  # opposite edge for each triangle attached to edge[0]\n        for tri in self.tris:\n            if edge[0] in tri:\n                edges.append(self._edge_opposite_point(tri, edge[0]))\n\n        for oedge in edges:\n            o1 = self._orientation(edge, oedge[0])\n            o2 = self._orientation(edge, oedge[1])\n            if o1 != o2:\n                return (edge[0], oedge[0], oedge[1])\n\n        return None\n\n    def _edge_in_front(self, edge):\n        \"\"\"Return the index where *edge* appears in the current front.\n\n        If the edge is not in the front, return -1\n        \"\"\"\n        e = (list(edge), list(edge)[::-1])\n        for i in range(len(self._front)-1):\n            if self._front[i:i+2] in e:\n                return i\n        return -1\n\n    def _edge_opposite_point(self, tri, i):\n        \"\"\"Given a triangle, return the edge that is opposite point i.\n\n        Vertexes are returned in the same orientation as in tri.\n        \"\"\"\n        ind = tri.index(i)\n        return (tri[(ind+1) % 3], tri[(ind+2) % 3])\n\n    def _adjacent_tri(self, edge, i):\n        \"\"\"Given a triangle formed by edge and i, return the triangle that shares\n        edge. *i* may be either a point or the entire triangle.\n        \"\"\"\n        if not np.isscalar(i):\n            i = [x for x in i if x not in edge][0]\n\n        try:\n            pt1 = self._edges_lookup[edge]\n            pt2 = self._edges_lookup[(edge[1], edge[0])]\n        except KeyError:\n            return None\n\n        if pt1 == i:\n            return (edge[1], edge[0], pt2)\n        elif pt2 == i:\n            return (edge[1], edge[0], pt1)\n        else:\n            raise RuntimeError(\"Edge %s and point %d do not form a triangle \"\n                               \"in this mesh.\" % (edge, i))\n\n    def _tri_from_edge(self, edge):\n        \"\"\"Return the only tri that contains *edge*.\n\n        If two tris share this edge, raise an exception.\n        \"\"\"\n        edge = tuple(edge)\n        p1 = self._edges_lookup.get(edge, None)\n        p2 = self._edges_lookup.get(edge[::-1], None)\n        if p1 is None:\n            if p2 is None:\n                raise RuntimeError(\"No tris connected to edge %r\" % (edge,))\n            return edge + (p2,)\n        elif p2 is None:\n            return edge + (p1,)\n        else:\n            raise RuntimeError(\"Two triangles connected to edge %r\" % (edge,))\n\n    def _edges_in_tri_except(self, tri, edge):\n        \"\"\"Return the edges in *tri*, excluding *edge*.\"\"\"\n        edges = [(tri[i], tri[(i+1) % 3]) for i in range(3)]\n        try:\n            edges.remove(tuple(edge))\n        except ValueError:\n            edges.remove(tuple(edge[::-1]))\n        return edges\n\n    def _edge_below_front(self, edge, front_index):\n        \"\"\"Return True if *edge* is below the current front.\n\n        One of the points in *edge* must be _on_ the front, at *front_index*.\n        \"\"\"\n        f0 = self._front[front_index-1]\n        f1 = self._front[front_index+1]\n        return (self._orientation(edge, f0) > 0 and\n                self._orientation(edge, f1) < 0)\n\n    def _is_constraining_edge(self, edge):\n        mask1 = self.edges == edge[0]\n        mask2 = self.edges == edge[1]\n        return (np.any(mask1[:, 0] & mask2[:, 1]) or\n                np.any(mask2[:, 0] & mask1[:, 1]))\n\n    def _intersected_edge(self, edges, cut_edge):\n        \"\"\"Given a list of *edges*, return the first that is intersected by\n        *cut_edge*.\n        \"\"\"\n        for edge in edges:\n            if self._edges_intersect(edge, cut_edge):\n                return edge\n\n    def _find_edge_intersections(self):\n        \"\"\"Return a dictionary containing, for each edge in self.edges, a list\n        of the positions at which the edge should be split.\n        \"\"\"\n        edges = self.pts[self.edges]\n        cuts = {}  # { edge: [(intercept, point), ...], ... }\n        for i in range(edges.shape[0]-1):\n            # intersection of edge i onto all others\n            int1 = self._intersect_edge_arrays(edges[i:i+1], edges[i+1:])\n            # intersection of all edges onto edge i\n            int2 = self._intersect_edge_arrays(edges[i+1:], edges[i:i+1])\n\n            # select for pairs that intersect\n            err = np.geterr()\n            np.seterr(divide='ignore', invalid='ignore')\n            try:\n                mask1 = (int1 >= 0) & (int1 <= 1)\n                mask2 = (int2 >= 0) & (int2 <= 1)\n                mask3 = mask1 & mask2  # all intersections\n            finally:\n                np.seterr(**err)\n\n            # compute points of intersection\n            inds = np.argwhere(mask3)[:, 0]\n            if len(inds) == 0:\n                continue\n            h = int2[inds][:, np.newaxis]\n            pts = (edges[i, 0][np.newaxis, :] * (1.0 - h) +\n                   edges[i, 1][np.newaxis, :] * h)\n\n            # record for all edges the location of cut points\n            edge_cuts = cuts.setdefault(i, [])\n            for j, ind in enumerate(inds):\n                if 0 < int2[ind] < 1:\n                    edge_cuts.append((int2[ind], pts[j]))\n                if 0 < int1[ind] < 1:\n                    other_cuts = cuts.setdefault(ind+i+1, [])\n                    other_cuts.append((int1[ind], pts[j]))\n\n        # sort all cut lists by intercept, remove duplicates\n        for k, v in cuts.items():\n            v.sort(key=lambda x: x[0])\n            for i in range(len(v)-2, -1, -1):\n                if v[i][0] == v[i+1][0]:\n                    v.pop(i+1)\n        return cuts\n\n    def _split_intersecting_edges(self):\n        # we can do all intersections at once, but this has excessive memory\n        # overhead.\n\n        # measure intersection point between all pairs of edges\n        all_cuts = self._find_edge_intersections()\n\n        # cut edges at each intersection\n        add_pts = []\n        add_edges = []\n        for edge, cuts in all_cuts.items():\n            if len(cuts) == 0:\n                continue\n\n            # add new points\n            pt_offset = self.pts.shape[0] + len(add_pts)\n            new_pts = [x[1] for x in cuts]\n            add_pts.extend(new_pts)\n\n            # list of point indexes for all new edges\n            pt_indexes = list(range(pt_offset, pt_offset + len(cuts)))\n            pt_indexes.append(self.edges[edge, 1])\n\n            # modify original edge\n            self.edges[edge, 1] = pt_indexes[0]\n\n            # add new edges\n            new_edges = [[pt_indexes[i-1], pt_indexes[i]]\n                         for i in range(1, len(pt_indexes))]\n            add_edges.extend(new_edges)\n\n        if add_pts:\n            add_pts = np.array(add_pts, dtype=self.pts.dtype)\n            self.pts = np.append(self.pts, add_pts, axis=0)\n        if add_edges:\n            add_edges = np.array(add_edges, dtype=self.edges.dtype)\n            self.edges = np.append(self.edges, add_edges, axis=0)\n\n    def _merge_duplicate_points(self):\n        # generate a list of all pairs (i,j) of identical points\n        dups = []\n        for i in range(self.pts.shape[0]-1):\n            test_pt = self.pts[i:i+1]\n            comp_pts = self.pts[i+1:]\n            eq = test_pt == comp_pts\n            eq = eq[:, 0] & eq[:, 1]\n            for j in np.argwhere(eq)[:, 0]:\n                dups.append((i, i+1+j))\n\n        dups_arr = np.array(dups)\n        # remove duplicate points\n        pt_mask = np.ones(self.pts.shape[0], dtype=bool)\n        for i, inds in enumerate(dups_arr):\n            # remove j from points\n            # (note we pull the index from the original dups instead of\n            # dups_arr because the indexes in pt_mask do not change)\n            pt_mask[dups[i][1]] = False\n\n            i, j = inds\n\n            # rewrite edges to use i instead of j\n            self.edges[self.edges == j] = i\n\n            # decrement all point indexes > j\n            self.edges[self.edges > j] -= 1\n            dups_arr[dups_arr > j] -= 1\n\n        self.pts = self.pts[pt_mask]\n\n        # remove zero-length edges\n        mask = self.edges[:, 0] != self.edges[:, 1]\n        self.edges = self.edges[mask]\n\n    def _distances_from_line(self, edge, points):\n        # Distance of a set of points from a given line\n        e1 = self.pts[edge[0]]\n        e2 = self.pts[edge[1]]\n        distances = []\n        for i in points:\n            p = self.pts[i]\n            proj = self._projection(e1, p, e2)\n            distances.append(((p - proj)**2).sum()**0.5)\n        assert distances[0] == 0 and distances[-1] == 0\n        return distances\n\n    def _projection(self, a, b, c):\n        \"\"\"Return projection of (a,b) onto (a,c)\n        Arguments are point locations, not indexes.\n        \"\"\"\n        ab = b - a\n        ac = c - a\n        return a + ((ab*ac).sum() / (ac*ac).sum()) * ac\n\n    def _cosine(self, A, B, C):\n        # Cosine of angle ABC\n        a = ((C - B)**2).sum()\n        b = ((C - A)**2).sum()\n        c = ((B - A)**2).sum()\n        d = (a + c - b) / ((4 * a * c)**0.5)\n        return d\n\n    def _iscounterclockwise(self, a, b, c):\n        # Check if the points lie in counter-clockwise order or not\n        A = self.pts[a]\n        B = self.pts[b]\n        C = self.pts[c]\n        return np.cross(B-A, C-B) > 0\n\n    def _edges_intersect(self, edge1, edge2):\n        \"\"\"Return 1 if edges intersect completely (endpoints excluded)\"\"\"\n        h12 = self._intersect_edge_arrays(self.pts[np.array(edge1)],\n                                          self.pts[np.array(edge2)])\n        h21 = self._intersect_edge_arrays(self.pts[np.array(edge2)],\n                                          self.pts[np.array(edge1)])\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            out = (0 < h12 < 1) and (0 < h21 < 1)\n        finally:\n            np.seterr(**err)\n        return out\n\n    def _intersect_edge_arrays(self, lines1, lines2):\n        \"\"\"Return the intercepts of all lines defined in *lines1* as they\n        intersect all lines in *lines2*.\n\n        Arguments are of shape (..., 2, 2), where axes are:\n\n        0: number of lines\n        1: two points per line\n        2: x,y pair per point\n\n        Lines are compared elementwise across the arrays (lines1[i] is compared\n        against lines2[i]). If one of the arrays has N=1, then that line is\n        compared against all lines in the other array.\n\n        Returns an array of shape (N,) where each value indicates the intercept\n        relative to the defined line segment. A value of 0 indicates\n        intersection at the first endpoint, and a value of 1 indicates\n        intersection at the second endpoint. Values between 1 and 0 are on the\n        segment, whereas values outside 1 and 0 are off of the segment.\n        \"\"\"\n        # vector for each line in lines1\n        l1 = lines1[..., 1, :] - lines1[..., 0, :]\n        # vector for each line in lines2\n        l2 = lines2[..., 1, :] - lines2[..., 0, :]\n        # vector between first point of each line\n        diff = lines1[..., 0, :] - lines2[..., 0, :]\n\n        p = l1.copy()[..., ::-1]  # vectors perpendicular to l1\n        p[..., 0] *= -1\n\n        f = (l2 * p).sum(axis=-1)  # l2 dot p\n        # tempting, but bad idea!\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            h = (diff * p).sum(axis=-1) / f  # diff dot p / f\n        finally:\n            np.seterr(**err)\n\n        return h\n\n    def _orientation(self, edge, point):\n        \"\"\"Returns +1 if edge[0]->point is clockwise from edge[0]->edge[1],\n        -1 if counterclockwise, and 0 if parallel.\n        \"\"\"\n        v1 = self.pts[point] - self.pts[edge[0]]\n        v2 = self.pts[edge[1]] - self.pts[edge[0]]\n        c = np.cross(v1, v2)  # positive if v1 is CW from v2\n        return 1 if c > 0 else (-1 if c < 0 else 0)\n\n    def _add_tri(self, a, b, c):\n        # sanity check\n        assert a != b and b != c and c != a\n\n        # ignore flat tris\n        pa = self.pts[a]\n        pb = self.pts[b]\n        pc = self.pts[c]\n        if np.all(pa == pb) or np.all(pb == pc) or np.all(pc == pa):\n            return\n\n        # check this tri is unique\n        for t in permutations((a, b, c)):\n            if t in self.tris:\n                raise Exception(\"Cannot add %s; already have %s\" %\n                                ((a, b, c), t))\n\n        # TODO: should add to edges_lookup after legalization??\n        if self._iscounterclockwise(a, b, c):\n            assert (a, b) not in self._edges_lookup\n            assert (b, c) not in self._edges_lookup\n            assert (c, a) not in self._edges_lookup\n            self._edges_lookup[(a, b)] = c\n            self._edges_lookup[(b, c)] = a\n            self._edges_lookup[(c, a)] = b\n        else:\n            assert (b, a) not in self._edges_lookup\n            assert (c, b) not in self._edges_lookup\n            assert (a, c) not in self._edges_lookup\n            self._edges_lookup[(b, a)] = c\n            self._edges_lookup[(c, b)] = a\n            self._edges_lookup[(a, c)] = b\n\n        tri = (a, b, c)\n\n        self.tris[tri] = None\n\n    def _remove_tri(self, a, b, c):\n        for k in permutations((a, b, c)):\n            if k in self.tris:\n                break\n        del self.tris[k]\n        (a, b, c) = k\n\n        if self._edges_lookup.get((a, b), -1) == c:\n            del self._edges_lookup[(a, b)]\n            del self._edges_lookup[(b, c)]\n            del self._edges_lookup[(c, a)]\n        elif self._edges_lookup.get((b, a), -1) == c:\n            del self._edges_lookup[(b, a)]\n            del self._edges_lookup[(a, c)]\n            del self._edges_lookup[(c, b)]\n        else:\n            raise RuntimeError(\"Lost edges_lookup for tri (%d, %d, %d)\" %\n                               (a, b, c))\n\n        return k",
  "def _triangulate_python(vertices_2d, segments):\n    segments = segments.reshape(len(segments) // 2, 2)\n    T = Triangulation(vertices_2d, segments)\n    T.triangulate()\n    vertices_2d = T.pts\n    triangles = T.tris.ravel()\n    return vertices_2d, triangles",
  "def _triangulate_cpp(vertices_2d, segments):\n    import triangle\n    T = triangle.triangulate({'vertices': vertices_2d,\n                              'segments': segments}, \"p\")\n    vertices_2d = T[\"vertices\"]\n    triangles = T[\"triangles\"]\n    return vertices_2d, triangles",
  "def triangulate(vertices):\n    \"\"\"Triangulate a set of vertices.\n\n    This uses a pure Python implementation based on [1]_.\n\n    If `Triangle` by Jonathan R. Shewchuk [2]_ and the Python bindings `triangle` [3]_\n    are installed, this will be used instead. Users need to acknowledge and adhere to\n    the licensing terms of these packages.\n\n    In the VisPy `PolygonCollection Example` [4]_ a speedup of 97% using\n    `Triangle`/`triangle` can be achieved compared to the pure Python implementation.\n\n    Parameters\n    ----------\n    vertices : array-like\n        The vertices.\n\n    Returns\n    -------\n    vertices : array-like\n        The vertices.\n    triangles : array-like\n        The triangles.\n\n    References\n    ----------\n    .. [1] Domiter, V. and \u017dalik, B. Sweep\u2010line algorithm for constrained\n       Delaunay triangulation\n    .. [2] Shewchuk J.R. (1996) Triangle: Engineering a 2D quality mesh generator and\n       Delaunay triangulator. In: Lin M.C., Manocha D. (eds) Applied Computational\n       Geometry Towards Geometric Engineering. WACG 1996. Lecture Notes in Computer\n       Science, vol 1148. Springer, Berlin, Heidelberg.\n       https://doi.org/10.1007/BFb0014497\n    .. [3] https://rufat.be/triangle/\n    .. [4] https://github.com/vispy/vispy/blob/main/examples/collections/polygon_collection.py\n    \"\"\"\n    n = len(vertices)\n    vertices = np.asarray(vertices)\n    zmean = vertices[:, 2].mean()\n    vertices_2d = vertices[:, :2]\n    segments = np.repeat(np.arange(n + 1), 2)[1:-1]\n    segments[-2:] = n - 1, 0\n\n    try:\n        import triangle  # noqa: F401\n    except (ImportError, AssertionError):\n        vertices_2d, triangles = _triangulate_python(vertices_2d, segments)\n    else:\n        segments_2d = segments.reshape((-1, 2))\n        vertices_2d, triangles = _triangulate_cpp(vertices_2d, segments_2d)\n\n    vertices = np.empty((len(vertices_2d), 3))\n    vertices[:, :2] = vertices_2d\n    vertices[:, 2] = zmean\n    return vertices, triangles",
  "def __init__(self, pts, edges):\n        self.pts = pts[:, :2].astype(np.float32)\n        self.edges = edges\n        if self.pts.ndim != 2 or self.pts.shape[1] != 2:\n            raise TypeError('pts argument must be ndarray of shape (N, 2).')\n        if self.edges.ndim != 2 or self.edges.shape[1] != 2:\n            raise TypeError('edges argument must be ndarray of shape (N, 2).')\n\n        # described in initialize()\n        self._front = None\n        self.tris = OrderedDict()\n        self._edges_lookup = {}",
  "def _normalize(self):\n        # Clean up data   (not discussed in original publication)\n\n        # (i) Split intersecting edges. Every edge that intersects another\n        #     edge or point is split. This extends self.pts and self.edges.\n        self._split_intersecting_edges()\n\n        # (ii) Merge identical points. If any two points are found to be equal,\n        #      the second is removed and the edge table is updated accordingly.\n        self._merge_duplicate_points()",
  "def _initialize(self):\n        self._normalize()\n        # Initialization (sec. 3.3)\n\n        # sort points by y, then x\n        flat_shape = self.pts.shape[0] * self.pts.shape[1]\n        pts = self.pts.reshape(flat_shape).view([('x', np.float32),\n                                                 ('y', np.float32)])\n        order = np.argsort(pts, order=('y', 'x'))\n        pts = pts[order]\n        # update edges to match new point order\n        invorder = np.argsort(order)\n        self.edges = invorder[self.edges]\n        self.pts = pts.view(np.float32).reshape(len(pts), 2)\n\n        # make artificial points P-1 and P-2\n        xmax = self.pts[:, 0].max()\n        xmin = self.pts[:, 0].min()\n        ymax = self.pts[:, 1].max()\n        ymin = self.pts[:, 1].min()\n        xa = (xmax-xmin) * 0.3\n        ya = (ymax-ymin) * 0.3\n        p1 = (xmin - xa, ymin - ya)\n        p2 = (xmax + xa, ymin - ya)\n\n        # prepend artificial points to point list\n        newpts = np.empty((self.pts.shape[0]+2, 2), dtype=float)\n        newpts[0] = p1\n        newpts[1] = p2\n        newpts[2:] = self.pts\n        self.pts = newpts\n        self.edges += 2\n\n        # find topmost point in each edge\n        self._tops = self.edges.max(axis=1)\n        self._bottoms = self.edges.min(axis=1)\n\n        # inintialize sweep front\n        # values in this list are indexes into self.pts\n        self._front = [0, 2, 1]\n\n        # empty triangle list.\n        # This will contain [(a, b, c), ...] where a,b,c are indexes into\n        # self.pts\n        self.tris = OrderedDict()\n\n        # For each triangle, maps (a, b): c\n        # This is used to look up the thrid point in a triangle, given any\n        # edge. Since each edge has two triangles, they are independently\n        # stored as (a, b): c and (b, a): d\n        self._edges_lookup = {}",
  "def triangulate(self):\n        \"\"\"Do the triangulation.\"\"\"\n        self._initialize()\n\n        pts = self.pts\n        front = self._front\n\n        # Begin sweep (sec. 3.4)\n        for i in range(3, pts.shape[0]):\n            pi = pts[i]\n\n            # First, triangulate from front to new point\n            # This applies to both \"point events\" (3.4.1)\n            # and \"edge events\" (3.4.2).\n\n            # get index along front that intersects pts[i]\n            idx = 0\n            while pts[front[idx+1], 0] <= pi[0]:\n                idx += 1\n            pl = pts[front[idx]]\n\n            # \"(i) middle case\"\n            if pi[0] > pl[0]:\n                # Add a single triangle connecting pi,pl,pr\n                self._add_tri(front[idx], front[idx+1], i)\n                front.insert(idx+1, i)\n            # \"(ii) left case\"\n            else:\n                # Add triangles connecting pi,pl,ps and pi,pl,pr\n                self._add_tri(front[idx], front[idx+1], i)\n                self._add_tri(front[idx-1], front[idx], i)\n                front[idx] = i\n\n            # Continue adding triangles to smooth out front\n            # (heuristics shown in figs. 9, 10)\n            for direction in -1, 1:\n                while True:\n                    # Find point connected to pi\n                    ind0 = front.index(i)\n                    ind1 = ind0 + direction\n                    ind2 = ind1 + direction\n                    if ind2 < 0 or ind2 >= len(front):\n                        break\n\n                    # measure angle made with front\n                    p1 = pts[front[ind1]]\n                    p2 = pts[front[ind2]]\n                    err = np.geterr()\n                    np.seterr(invalid='ignore')\n                    try:\n                        angle = np.arccos(self._cosine(pi, p1, p2))\n                    finally:\n                        np.seterr(**err)\n\n                    # if angle is < pi/2, make new triangle\n                    if angle > np.pi/2. or np.isnan(angle):\n                        break\n\n                    assert (i != front[ind1] and\n                            front[ind1] != front[ind2] and\n                            front[ind2] != i)\n                    self._add_tri(i, front[ind1], front[ind2])\n                    front.pop(ind1)\n\n            # \"edge event\" (sec. 3.4.2)\n            # remove any triangles cut by completed edges and re-fill\n            # the holes.\n            if i in self._tops:\n                for j in self._bottoms[self._tops == i]:\n                    # Make sure edge (j, i) is present in mesh\n                    # because edge event may have created a new front list\n                    self._edge_event(i, j)\n                    front = self._front\n\n        self._finalize()\n\n        self.tris = np.array(list(self.tris.keys()), dtype=int)",
  "def _finalize(self):\n        # Finalize (sec. 3.5)\n\n        # (i) Add bordering triangles to fill hull\n        front = list(OrderedDict.fromkeys(self._front))\n\n        idx = len(front) - 2\n        k = 1\n        while k < idx-1:\n            # if edges lie in counterclockwise direction, then signed area\n            # is positive\n            if self._iscounterclockwise(front[k], front[k+1], front[k+2]):\n                self._add_tri(front[k], front[k+1], front[k+2])\n                front.pop(k+1)\n                idx -= 1\n                continue\n            k += 1\n\n        # (ii) Remove all triangles not inside the hull\n        #      (not described in article)\n\n        tris = []  # triangles to check\n        tri_state = {}  # 0 for outside, 1 for inside\n\n        # find a starting triangle\n        for t in self.tris:\n            if 0 in t or 1 in t:\n                tri_state[t] = 0\n                tris.append(t)\n                break\n\n        while tris:\n            next_tris = []\n            for t in tris:\n                v = tri_state[t]\n                for i in (0, 1, 2):\n                    edge = (t[i], t[(i + 1) % 3])\n                    pt = t[(i + 2) % 3]\n                    t2 = self._adjacent_tri(edge, pt)\n                    if t2 is None:\n                        continue\n                    t2a = t2[1:3] + t2[0:1]\n                    t2b = t2[2:3] + t2[0:2]\n                    if t2 in tri_state or t2a in tri_state or t2b in tri_state:\n                        continue\n                    if self._is_constraining_edge(edge):\n                        tri_state[t2] = 1 - v\n                    else:\n                        tri_state[t2] = v\n                    next_tris.append(t2)\n            tris = next_tris\n\n        for t, v in tri_state.items():\n            if v == 0:\n                self._remove_tri(*t)",
  "def _edge_event(self, i, j):\n        \"\"\"Force edge (i, j) to be present in mesh.\n\n        This works by removing intersected triangles and filling holes up to\n        the cutting edge.\n        \"\"\"\n        front_index = self._front.index(i)\n\n        front = self._front\n\n        # First just see whether this edge is already present\n        # (this is not in the published algorithm)\n        if (i, j) in self._edges_lookup or (j, i) in self._edges_lookup:\n            return\n\n        # traverse in two different modes:\n        #  1. If cutting edge is below front, traverse through triangles. These\n        #     must be removed and the resulting hole re-filled. (fig. 12)\n        #  2. If cutting edge is above the front, then follow the front until\n        #     crossing under again. (fig. 13)\n        # We must be able to switch back and forth between these\n        # modes (fig. 14)\n\n        # Collect points that draw the open polygons on either side of the\n        # cutting edge. Note that our use of 'upper' and 'lower' is not strict;\n        # in some cases the two may be swapped.\n        upper_polygon = [i]\n        lower_polygon = [i]\n\n        # Keep track of which section of the front must be replaced\n        # and with what it should be replaced\n        front_holes = []  # contains indexes for sections of front to remove\n\n        next_tri = None   # next triangle to cut (already set if in mode 1)\n        last_edge = None  # or last triangle edge crossed (if in mode 1)\n\n        # Which direction to traverse front\n        front_dir = 1 if self.pts[j][0] > self.pts[i][0] else -1\n\n        # Initialize search state\n        if self._edge_below_front((i, j), front_index):\n            mode = 1  # follow triangles\n            tri = self._find_cut_triangle((i, j))\n            last_edge = self._edge_opposite_point(tri, i)\n            next_tri = self._adjacent_tri(last_edge, i)\n            assert next_tri is not None\n            self._remove_tri(*tri)\n            # todo: does this work? can we count on last_edge to be clockwise\n            # around point i?\n            lower_polygon.append(last_edge[1])\n            upper_polygon.append(last_edge[0])\n        else:\n            mode = 2  # follow front\n\n        # Loop until we reach point j\n        while True:\n            if mode == 1:\n                # crossing from one triangle into another\n                if j in next_tri:\n                    # reached endpoint!\n                    # update front / polygons\n                    upper_polygon.append(j)\n                    lower_polygon.append(j)\n                    self._remove_tri(*next_tri)\n                    break\n                else:\n                    # next triangle does not contain the end point; we will\n                    # cut one of the two far edges.\n                    tri_edges = self._edges_in_tri_except(next_tri, last_edge)\n\n                    # select the edge that is cut\n                    last_edge = self._intersected_edge(tri_edges, (i, j))\n                    last_tri = next_tri\n                    next_tri = self._adjacent_tri(last_edge, last_tri)\n                    self._remove_tri(*last_tri)\n\n                    # Crossing an edge adds one point to one of the polygons\n                    if lower_polygon[-1] == last_edge[0]:\n                        upper_polygon.append(last_edge[1])\n                    elif lower_polygon[-1] == last_edge[1]:\n                        upper_polygon.append(last_edge[0])\n                    elif upper_polygon[-1] == last_edge[0]:\n                        lower_polygon.append(last_edge[1])\n                    elif upper_polygon[-1] == last_edge[1]:\n                        lower_polygon.append(last_edge[0])\n                    else:\n                        raise RuntimeError(\"Something went wrong..\")\n\n                    # If we crossed the front, go to mode 2\n                    x = self._edge_in_front(last_edge)\n                    if x >= 0:  # crossing over front\n                        mode = 2\n                        next_tri = None\n\n                        # where did we cross the front?\n                        # nearest to new point\n                        front_index = x + (1 if front_dir == -1 else 0)\n\n                        # Select the correct polygon to be lower_polygon\n                        # (because mode 2 requires this).\n                        # We know that last_edge is in the front, and\n                        # front[front_index] is the point _above_ the front.\n                        # So if this point is currently the last element in\n                        # lower_polygon, then the polys must be swapped.\n                        if lower_polygon[-1] == front[front_index]:\n                            tmp = lower_polygon, upper_polygon\n                            upper_polygon, lower_polygon = tmp\n                        else:\n                            assert upper_polygon[-1] == front[front_index]\n\n                    else:\n                        assert next_tri is not None\n\n            else:  # mode == 2\n                # At each iteration, we require:\n                #   * front_index is the starting index of the edge _preceding_\n                #     the edge that will be handled in this iteration\n                #   * lower_polygon is the polygon to which points should be\n                #     added while traversing the front\n\n                front_index += front_dir\n                next_edge = (front[front_index], front[front_index+front_dir])\n\n                assert front_index >= 0\n                if front[front_index] == j:\n                    # found endpoint!\n                    lower_polygon.append(j)\n                    upper_polygon.append(j)\n                    break\n\n                # Add point to lower_polygon.\n                # The conditional is because there are cases where the\n                # point was already added if we just crossed from mode 1.\n                if lower_polygon[-1] != front[front_index]:\n                    lower_polygon.append(front[front_index])\n\n                front_holes.append(front_index)\n\n                if self._edges_intersect((i, j), next_edge):\n                    # crossing over front into triangle\n                    mode = 1\n\n                    last_edge = next_edge\n\n                    # we are crossing the front, so this edge only has one\n                    # triangle.\n                    next_tri = self._tri_from_edge(last_edge)\n\n                    upper_polygon.append(front[front_index+front_dir])\n\n        # (iii) triangluate empty areas\n\n        for polygon in [lower_polygon, upper_polygon]:\n            dist = self._distances_from_line((i, j), polygon)\n            while len(polygon) > 2:\n                ind = np.argmax(dist)\n                self._add_tri(polygon[ind], polygon[ind-1],\n                              polygon[ind+1])\n                polygon.pop(ind)\n                dist.pop(ind)\n\n        # update front by removing points in the holes (places where front\n        # passes below the cut edge)\n        front_holes.sort(reverse=True)\n        for i in front_holes:\n            front.pop(i)",
  "def _find_cut_triangle(self, edge):\n        \"\"\"\n        Return the triangle that has edge[0] as one of its vertices and is\n        bisected by edge.\n\n        Return None if no triangle is found.\n        \"\"\"\n        edges = []  # opposite edge for each triangle attached to edge[0]\n        for tri in self.tris:\n            if edge[0] in tri:\n                edges.append(self._edge_opposite_point(tri, edge[0]))\n\n        for oedge in edges:\n            o1 = self._orientation(edge, oedge[0])\n            o2 = self._orientation(edge, oedge[1])\n            if o1 != o2:\n                return (edge[0], oedge[0], oedge[1])\n\n        return None",
  "def _edge_in_front(self, edge):\n        \"\"\"Return the index where *edge* appears in the current front.\n\n        If the edge is not in the front, return -1\n        \"\"\"\n        e = (list(edge), list(edge)[::-1])\n        for i in range(len(self._front)-1):\n            if self._front[i:i+2] in e:\n                return i\n        return -1",
  "def _edge_opposite_point(self, tri, i):\n        \"\"\"Given a triangle, return the edge that is opposite point i.\n\n        Vertexes are returned in the same orientation as in tri.\n        \"\"\"\n        ind = tri.index(i)\n        return (tri[(ind+1) % 3], tri[(ind+2) % 3])",
  "def _adjacent_tri(self, edge, i):\n        \"\"\"Given a triangle formed by edge and i, return the triangle that shares\n        edge. *i* may be either a point or the entire triangle.\n        \"\"\"\n        if not np.isscalar(i):\n            i = [x for x in i if x not in edge][0]\n\n        try:\n            pt1 = self._edges_lookup[edge]\n            pt2 = self._edges_lookup[(edge[1], edge[0])]\n        except KeyError:\n            return None\n\n        if pt1 == i:\n            return (edge[1], edge[0], pt2)\n        elif pt2 == i:\n            return (edge[1], edge[0], pt1)\n        else:\n            raise RuntimeError(\"Edge %s and point %d do not form a triangle \"\n                               \"in this mesh.\" % (edge, i))",
  "def _tri_from_edge(self, edge):\n        \"\"\"Return the only tri that contains *edge*.\n\n        If two tris share this edge, raise an exception.\n        \"\"\"\n        edge = tuple(edge)\n        p1 = self._edges_lookup.get(edge, None)\n        p2 = self._edges_lookup.get(edge[::-1], None)\n        if p1 is None:\n            if p2 is None:\n                raise RuntimeError(\"No tris connected to edge %r\" % (edge,))\n            return edge + (p2,)\n        elif p2 is None:\n            return edge + (p1,)\n        else:\n            raise RuntimeError(\"Two triangles connected to edge %r\" % (edge,))",
  "def _edges_in_tri_except(self, tri, edge):\n        \"\"\"Return the edges in *tri*, excluding *edge*.\"\"\"\n        edges = [(tri[i], tri[(i+1) % 3]) for i in range(3)]\n        try:\n            edges.remove(tuple(edge))\n        except ValueError:\n            edges.remove(tuple(edge[::-1]))\n        return edges",
  "def _edge_below_front(self, edge, front_index):\n        \"\"\"Return True if *edge* is below the current front.\n\n        One of the points in *edge* must be _on_ the front, at *front_index*.\n        \"\"\"\n        f0 = self._front[front_index-1]\n        f1 = self._front[front_index+1]\n        return (self._orientation(edge, f0) > 0 and\n                self._orientation(edge, f1) < 0)",
  "def _is_constraining_edge(self, edge):\n        mask1 = self.edges == edge[0]\n        mask2 = self.edges == edge[1]\n        return (np.any(mask1[:, 0] & mask2[:, 1]) or\n                np.any(mask2[:, 0] & mask1[:, 1]))",
  "def _intersected_edge(self, edges, cut_edge):\n        \"\"\"Given a list of *edges*, return the first that is intersected by\n        *cut_edge*.\n        \"\"\"\n        for edge in edges:\n            if self._edges_intersect(edge, cut_edge):\n                return edge",
  "def _find_edge_intersections(self):\n        \"\"\"Return a dictionary containing, for each edge in self.edges, a list\n        of the positions at which the edge should be split.\n        \"\"\"\n        edges = self.pts[self.edges]\n        cuts = {}  # { edge: [(intercept, point), ...], ... }\n        for i in range(edges.shape[0]-1):\n            # intersection of edge i onto all others\n            int1 = self._intersect_edge_arrays(edges[i:i+1], edges[i+1:])\n            # intersection of all edges onto edge i\n            int2 = self._intersect_edge_arrays(edges[i+1:], edges[i:i+1])\n\n            # select for pairs that intersect\n            err = np.geterr()\n            np.seterr(divide='ignore', invalid='ignore')\n            try:\n                mask1 = (int1 >= 0) & (int1 <= 1)\n                mask2 = (int2 >= 0) & (int2 <= 1)\n                mask3 = mask1 & mask2  # all intersections\n            finally:\n                np.seterr(**err)\n\n            # compute points of intersection\n            inds = np.argwhere(mask3)[:, 0]\n            if len(inds) == 0:\n                continue\n            h = int2[inds][:, np.newaxis]\n            pts = (edges[i, 0][np.newaxis, :] * (1.0 - h) +\n                   edges[i, 1][np.newaxis, :] * h)\n\n            # record for all edges the location of cut points\n            edge_cuts = cuts.setdefault(i, [])\n            for j, ind in enumerate(inds):\n                if 0 < int2[ind] < 1:\n                    edge_cuts.append((int2[ind], pts[j]))\n                if 0 < int1[ind] < 1:\n                    other_cuts = cuts.setdefault(ind+i+1, [])\n                    other_cuts.append((int1[ind], pts[j]))\n\n        # sort all cut lists by intercept, remove duplicates\n        for k, v in cuts.items():\n            v.sort(key=lambda x: x[0])\n            for i in range(len(v)-2, -1, -1):\n                if v[i][0] == v[i+1][0]:\n                    v.pop(i+1)\n        return cuts",
  "def _split_intersecting_edges(self):\n        # we can do all intersections at once, but this has excessive memory\n        # overhead.\n\n        # measure intersection point between all pairs of edges\n        all_cuts = self._find_edge_intersections()\n\n        # cut edges at each intersection\n        add_pts = []\n        add_edges = []\n        for edge, cuts in all_cuts.items():\n            if len(cuts) == 0:\n                continue\n\n            # add new points\n            pt_offset = self.pts.shape[0] + len(add_pts)\n            new_pts = [x[1] for x in cuts]\n            add_pts.extend(new_pts)\n\n            # list of point indexes for all new edges\n            pt_indexes = list(range(pt_offset, pt_offset + len(cuts)))\n            pt_indexes.append(self.edges[edge, 1])\n\n            # modify original edge\n            self.edges[edge, 1] = pt_indexes[0]\n\n            # add new edges\n            new_edges = [[pt_indexes[i-1], pt_indexes[i]]\n                         for i in range(1, len(pt_indexes))]\n            add_edges.extend(new_edges)\n\n        if add_pts:\n            add_pts = np.array(add_pts, dtype=self.pts.dtype)\n            self.pts = np.append(self.pts, add_pts, axis=0)\n        if add_edges:\n            add_edges = np.array(add_edges, dtype=self.edges.dtype)\n            self.edges = np.append(self.edges, add_edges, axis=0)",
  "def _merge_duplicate_points(self):\n        # generate a list of all pairs (i,j) of identical points\n        dups = []\n        for i in range(self.pts.shape[0]-1):\n            test_pt = self.pts[i:i+1]\n            comp_pts = self.pts[i+1:]\n            eq = test_pt == comp_pts\n            eq = eq[:, 0] & eq[:, 1]\n            for j in np.argwhere(eq)[:, 0]:\n                dups.append((i, i+1+j))\n\n        dups_arr = np.array(dups)\n        # remove duplicate points\n        pt_mask = np.ones(self.pts.shape[0], dtype=bool)\n        for i, inds in enumerate(dups_arr):\n            # remove j from points\n            # (note we pull the index from the original dups instead of\n            # dups_arr because the indexes in pt_mask do not change)\n            pt_mask[dups[i][1]] = False\n\n            i, j = inds\n\n            # rewrite edges to use i instead of j\n            self.edges[self.edges == j] = i\n\n            # decrement all point indexes > j\n            self.edges[self.edges > j] -= 1\n            dups_arr[dups_arr > j] -= 1\n\n        self.pts = self.pts[pt_mask]\n\n        # remove zero-length edges\n        mask = self.edges[:, 0] != self.edges[:, 1]\n        self.edges = self.edges[mask]",
  "def _distances_from_line(self, edge, points):\n        # Distance of a set of points from a given line\n        e1 = self.pts[edge[0]]\n        e2 = self.pts[edge[1]]\n        distances = []\n        for i in points:\n            p = self.pts[i]\n            proj = self._projection(e1, p, e2)\n            distances.append(((p - proj)**2).sum()**0.5)\n        assert distances[0] == 0 and distances[-1] == 0\n        return distances",
  "def _projection(self, a, b, c):\n        \"\"\"Return projection of (a,b) onto (a,c)\n        Arguments are point locations, not indexes.\n        \"\"\"\n        ab = b - a\n        ac = c - a\n        return a + ((ab*ac).sum() / (ac*ac).sum()) * ac",
  "def _cosine(self, A, B, C):\n        # Cosine of angle ABC\n        a = ((C - B)**2).sum()\n        b = ((C - A)**2).sum()\n        c = ((B - A)**2).sum()\n        d = (a + c - b) / ((4 * a * c)**0.5)\n        return d",
  "def _iscounterclockwise(self, a, b, c):\n        # Check if the points lie in counter-clockwise order or not\n        A = self.pts[a]\n        B = self.pts[b]\n        C = self.pts[c]\n        return np.cross(B-A, C-B) > 0",
  "def _edges_intersect(self, edge1, edge2):\n        \"\"\"Return 1 if edges intersect completely (endpoints excluded)\"\"\"\n        h12 = self._intersect_edge_arrays(self.pts[np.array(edge1)],\n                                          self.pts[np.array(edge2)])\n        h21 = self._intersect_edge_arrays(self.pts[np.array(edge2)],\n                                          self.pts[np.array(edge1)])\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            out = (0 < h12 < 1) and (0 < h21 < 1)\n        finally:\n            np.seterr(**err)\n        return out",
  "def _intersect_edge_arrays(self, lines1, lines2):\n        \"\"\"Return the intercepts of all lines defined in *lines1* as they\n        intersect all lines in *lines2*.\n\n        Arguments are of shape (..., 2, 2), where axes are:\n\n        0: number of lines\n        1: two points per line\n        2: x,y pair per point\n\n        Lines are compared elementwise across the arrays (lines1[i] is compared\n        against lines2[i]). If one of the arrays has N=1, then that line is\n        compared against all lines in the other array.\n\n        Returns an array of shape (N,) where each value indicates the intercept\n        relative to the defined line segment. A value of 0 indicates\n        intersection at the first endpoint, and a value of 1 indicates\n        intersection at the second endpoint. Values between 1 and 0 are on the\n        segment, whereas values outside 1 and 0 are off of the segment.\n        \"\"\"\n        # vector for each line in lines1\n        l1 = lines1[..., 1, :] - lines1[..., 0, :]\n        # vector for each line in lines2\n        l2 = lines2[..., 1, :] - lines2[..., 0, :]\n        # vector between first point of each line\n        diff = lines1[..., 0, :] - lines2[..., 0, :]\n\n        p = l1.copy()[..., ::-1]  # vectors perpendicular to l1\n        p[..., 0] *= -1\n\n        f = (l2 * p).sum(axis=-1)  # l2 dot p\n        # tempting, but bad idea!\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            h = (diff * p).sum(axis=-1) / f  # diff dot p / f\n        finally:\n            np.seterr(**err)\n\n        return h",
  "def _orientation(self, edge, point):\n        \"\"\"Returns +1 if edge[0]->point is clockwise from edge[0]->edge[1],\n        -1 if counterclockwise, and 0 if parallel.\n        \"\"\"\n        v1 = self.pts[point] - self.pts[edge[0]]\n        v2 = self.pts[edge[1]] - self.pts[edge[0]]\n        c = np.cross(v1, v2)  # positive if v1 is CW from v2\n        return 1 if c > 0 else (-1 if c < 0 else 0)",
  "def _add_tri(self, a, b, c):\n        # sanity check\n        assert a != b and b != c and c != a\n\n        # ignore flat tris\n        pa = self.pts[a]\n        pb = self.pts[b]\n        pc = self.pts[c]\n        if np.all(pa == pb) or np.all(pb == pc) or np.all(pc == pa):\n            return\n\n        # check this tri is unique\n        for t in permutations((a, b, c)):\n            if t in self.tris:\n                raise Exception(\"Cannot add %s; already have %s\" %\n                                ((a, b, c), t))\n\n        # TODO: should add to edges_lookup after legalization??\n        if self._iscounterclockwise(a, b, c):\n            assert (a, b) not in self._edges_lookup\n            assert (b, c) not in self._edges_lookup\n            assert (c, a) not in self._edges_lookup\n            self._edges_lookup[(a, b)] = c\n            self._edges_lookup[(b, c)] = a\n            self._edges_lookup[(c, a)] = b\n        else:\n            assert (b, a) not in self._edges_lookup\n            assert (c, b) not in self._edges_lookup\n            assert (a, c) not in self._edges_lookup\n            self._edges_lookup[(b, a)] = c\n            self._edges_lookup[(c, b)] = a\n            self._edges_lookup[(a, c)] = b\n\n        tri = (a, b, c)\n\n        self.tris[tri] = None",
  "def _remove_tri(self, a, b, c):\n        for k in permutations((a, b, c)):\n            if k in self.tris:\n                break\n        del self.tris[k]\n        (a, b, c) = k\n\n        if self._edges_lookup.get((a, b), -1) == c:\n            del self._edges_lookup[(a, b)]\n            del self._edges_lookup[(b, c)]\n            del self._edges_lookup[(c, a)]\n        elif self._edges_lookup.get((b, a), -1) == c:\n            del self._edges_lookup[(b, a)]\n            del self._edges_lookup[(a, c)]\n            del self._edges_lookup[(c, b)]\n        else:\n            raise RuntimeError(\"Lost edges_lookup for tri (%d, %d, %d)\" %\n                               (a, b, c))\n\n        return k",
  "class TorusKnot(object):\n    \"\"\"Representation of a torus knot or link.\n\n    A torus knot is one that can be drawn on the surface of a\n    torus. It is parameterised by two integers p and q as below; in\n    fact this returns a single knot (a single curve) only if p and q\n    are coprime, otherwise it describes multiple linked curves.\n\n    Parameters\n    ----------\n    p : int\n        The number of times the knot winds around the outside of the\n        torus. Defaults to 2.\n    q : int\n        The number of times the knot passes through the hole in the\n        centre of the torus. Defaults to 3.\n    num_points : int\n        The number of points in the returned piecewise linear\n        curve. If there are multiple curves (i.e. a torus link), this\n        is the number of points in *each* curve.  Defaults to 100.\n    major_radius : float\n        Distance from the center of the torus tube to the center of the torus.\n        Defaults to 10.\n    minor_radius : float\n        The radius of the torus tube. Defaults to 5.\n\n    \"\"\"\n\n    def __init__(self, p=3, q=2, num_points=100, major_radius=10.,\n                 minor_radius=5.):\n        self._p = p\n        self._q = q\n        self._num_points = num_points\n        self._major_radius = major_radius\n        self._minor_radius = minor_radius\n\n        self._calculate_vertices()\n\n    def _calculate_vertices(self):\n        angles = np.linspace(0, 2*np.pi, self._num_points)\n\n        num_components = self.num_components\n\n        divisions = (np.max([self._q, self._p]) *\n                     np.min([self._q, self._p]) // self.num_components)\n        starting_angles = np.linspace(\n            0, 2*np.pi, divisions + 1)[\n            :num_components]\n        q = self._q / num_components\n        p = self._p / num_components\n\n        components = []\n        for starting_angle in starting_angles:\n            vertices = np.zeros((self._num_points, 3))\n            local_angles = angles + starting_angle\n            radii = (self._minor_radius * np.cos(q * angles) +\n                     self._major_radius)\n            vertices[:, 0] = radii * np.cos(p * local_angles)\n            vertices[:, 1] = radii * np.sin(p * local_angles)\n            vertices[:, 2] = (self._minor_radius * -1 *\n                              np.sin(q * angles))\n            components.append(vertices)\n\n        self._components = components\n\n    @property\n    def first_component(self):\n        \"\"\"The vertices of the first component line of the torus knot or link.\"\"\"\n        return self._components[0]\n\n    @property\n    def components(self):\n        \"\"\"A list of the vertices in each line of the torus knot or link.\n        Even if p and q are coprime, this is a list with just one\n        entry.\n        \"\"\"\n        return self._components\n\n    @property\n    def num_components(self):\n        \"\"\"The number of component lines in the torus link. This is equal\n        to the greatest common divisor of p and q.\n        \"\"\"\n        return gcd(self._p, self._q)\n\n    @property\n    def q(self):\n        \"\"\"The q parameter of the torus knot or link.\"\"\"\n        return self._q\n\n    @q.setter\n    def q(self, q):\n        self._q = q\n        self._calculate_vertices()\n\n    @property\n    def p(self):\n        \"\"\"The p parameter of the torus knot or link.\"\"\"\n        return self._p\n\n    @p.setter\n    def p(self, p):\n        self._p = p\n        self._calculate_vertices()\n\n    @property\n    def minor_radius(self):\n        \"\"\"The minor radius of the torus.\"\"\"\n        return self._minor_radius\n\n    @minor_radius.setter\n    def minor_radius(self, r):\n        self._minor_radius = r\n        self._calculate_vertices()\n\n    @property\n    def major_radius(self):\n        \"\"\"The major radius of the torus.\"\"\"\n        return self._major_radius\n\n    @major_radius.setter\n    def major_radius(self, r):\n        self._major_radius = r\n        self._calculate_vertices()\n\n    @property\n    def num_points(self):\n        \"\"\"The number of points in the vertices returned for each knot/link\n        component\n        \"\"\"\n        return self._num_points\n\n    @num_points.setter\n    def num_points(self, r):\n        self._num_points = r\n        self._calculate_vertices()",
  "def __init__(self, p=3, q=2, num_points=100, major_radius=10.,\n                 minor_radius=5.):\n        self._p = p\n        self._q = q\n        self._num_points = num_points\n        self._major_radius = major_radius\n        self._minor_radius = minor_radius\n\n        self._calculate_vertices()",
  "def _calculate_vertices(self):\n        angles = np.linspace(0, 2*np.pi, self._num_points)\n\n        num_components = self.num_components\n\n        divisions = (np.max([self._q, self._p]) *\n                     np.min([self._q, self._p]) // self.num_components)\n        starting_angles = np.linspace(\n            0, 2*np.pi, divisions + 1)[\n            :num_components]\n        q = self._q / num_components\n        p = self._p / num_components\n\n        components = []\n        for starting_angle in starting_angles:\n            vertices = np.zeros((self._num_points, 3))\n            local_angles = angles + starting_angle\n            radii = (self._minor_radius * np.cos(q * angles) +\n                     self._major_radius)\n            vertices[:, 0] = radii * np.cos(p * local_angles)\n            vertices[:, 1] = radii * np.sin(p * local_angles)\n            vertices[:, 2] = (self._minor_radius * -1 *\n                              np.sin(q * angles))\n            components.append(vertices)\n\n        self._components = components",
  "def first_component(self):\n        \"\"\"The vertices of the first component line of the torus knot or link.\"\"\"\n        return self._components[0]",
  "def components(self):\n        \"\"\"A list of the vertices in each line of the torus knot or link.\n        Even if p and q are coprime, this is a list with just one\n        entry.\n        \"\"\"\n        return self._components",
  "def num_components(self):\n        \"\"\"The number of component lines in the torus link. This is equal\n        to the greatest common divisor of p and q.\n        \"\"\"\n        return gcd(self._p, self._q)",
  "def q(self):\n        \"\"\"The q parameter of the torus knot or link.\"\"\"\n        return self._q",
  "def q(self, q):\n        self._q = q\n        self._calculate_vertices()",
  "def p(self):\n        \"\"\"The p parameter of the torus knot or link.\"\"\"\n        return self._p",
  "def p(self, p):\n        self._p = p\n        self._calculate_vertices()",
  "def minor_radius(self):\n        \"\"\"The minor radius of the torus.\"\"\"\n        return self._minor_radius",
  "def minor_radius(self, r):\n        self._minor_radius = r\n        self._calculate_vertices()",
  "def major_radius(self):\n        \"\"\"The major radius of the torus.\"\"\"\n        return self._major_radius",
  "def major_radius(self, r):\n        self._major_radius = r\n        self._calculate_vertices()",
  "def num_points(self):\n        \"\"\"The number of points in the vertices returned for each knot/link\n        component\n        \"\"\"\n        return self._num_points",
  "def num_points(self, r):\n        self._num_points = r\n        self._calculate_vertices()",
  "def _fix_colors(colors):\n    colors = np.asarray(colors)\n    if colors.ndim not in (2, 3):\n        raise ValueError('colors must have 2 or 3 dimensions')\n    if colors.shape[-1] not in (3, 4):\n        raise ValueError('colors must have 3 or 4 elements')\n    if colors.shape[-1] == 3:\n        pad = np.ones((len(colors), 1), colors.dtype)\n        if colors.ndim == 3:\n            pad = pad[:, :, np.newaxis]\n        colors = np.concatenate((colors, pad), axis=-1)\n    return colors",
  "class MeshData(object):\n    \"\"\"\n    Class for storing and operating on 3D mesh data.\n\n    Parameters\n    ----------\n    vertices : ndarray, shape (Nv, 3)\n        Vertex coordinates. If faces is not specified, then this will\n        instead be interpreted as (Nf, 3, 3) array of coordinates.\n    faces : ndarray, shape (Nf, 3)\n        Indices into the vertex array.\n    edges : None\n        [not available yet]\n    vertex_colors : ndarray, shape (Nv, 4)\n        Vertex colors. If faces is not specified, this will be\n        interpreted as (Nf, 3, 4) array of colors.\n    face_colors : ndarray, shape (Nf, 4)\n        Face colors.\n    vertex_values : ndarray, shape (Nv,)\n        Vertex values.\n\n    Notes\n    -----\n    All arguments are optional.\n\n    The object may contain:\n\n    - list of vertex locations\n    - list of edges\n    - list of triangles\n    - colors per vertex, edge, or tri\n    - normals per vertex or tri\n\n    This class handles conversion between the standard\n    [list of vertices, list of faces] format (suitable for use with\n    glDrawElements) and 'indexed' [list of vertices] format (suitable\n    for use with glDrawArrays). It will automatically compute face normal\n    vectors as well as averaged vertex normal vectors.\n\n    The class attempts to be as efficient as possible in caching conversion\n    results and avoiding unnecessary conversions.\n    \"\"\"\n\n    def __init__(self, vertices=None, faces=None, edges=None,\n                 vertex_colors=None, face_colors=None, vertex_values=None):\n        self._vertices = None  # (Nv,3) array of vertex coordinates\n        self._vertices_indexed_by_faces = None  # (Nf, 3, 3) vertex coordinates\n        self._vertices_indexed_by_edges = None  # (Ne, 2, 3) vertex coordinates\n\n        # mappings between vertices, faces, and edges\n        self._faces = None  # Nx3 indices into self._vertices, 3 verts/face\n        self._edges = None  # Nx2 indices into self._vertices, 2 verts/edge\n        self._edges_indexed_by_faces = None  # (Ne, 3, 2) indices into\n        # self._vertices, 3 edge / face and 2 verts/edge\n        # inverse mappings\n        self._vertex_faces = None  # maps vertex ID to a list of face IDs\n        self._vertex_edges = None  # maps vertex ID to a list of edge IDs\n\n        # Per-vertex data\n        self._vertex_normals = None                   # (Nv, 3) normals\n        self._vertex_normals_indexed_by_faces = None  # (Nf, 3, 3) normals\n        self._vertex_colors = None                    # (Nv, 4) colors\n        self._vertex_colors_indexed_by_faces = None   # (Nf, 3, 4) colors\n        self._vertex_colors_indexed_by_edges = None   # (Nf, 2, 4) colors\n        self._vertex_values = None                    # (Nv,) values\n        self._vertex_values_indexed_by_faces = None   # (Nv, 3) values\n        self._vertex_values_indexed_by_edges = None   # (Nv, 2) values\n\n        # Per-face data\n        self._face_normals = None                # (Nf, 3) face normals\n        self._face_normals_indexed_by_faces = None  # (Nf, 3, 3) face normals\n        self._face_colors = None                 # (Nf, 4) face colors\n        self._face_colors_indexed_by_faces = None   # (Nf, 3, 4) face colors\n        self._face_colors_indexed_by_edges = None   # (Ne, 2, 4) face colors\n\n        # Per-edge data\n        self._edge_colors = None                # (Ne, 4) edge colors\n        self._edge_colors_indexed_by_edges = None  # (Ne, 2, 4) edge colors\n        if vertices is not None:\n            indexed = 'faces' if faces is None else None\n            self.set_vertices(vertices, indexed=indexed)\n            if faces is not None:\n                self.set_faces(faces)\n            if vertex_colors is not None:\n                self.set_vertex_colors(vertex_colors, indexed=indexed)\n            if face_colors is not None:\n                self.set_face_colors(face_colors, indexed=indexed)\n            if vertex_values is not None:\n                self.set_vertex_values(vertex_values, indexed=indexed)\n\n    def get_faces(self):\n        \"\"\"Array (Nf, 3) of vertex indices, three per triangular face.\n\n        If faces have not been computed for this mesh, returns None.\n        \"\"\"\n        return self._faces\n\n    def get_edges(self, indexed=None):\n        \"\"\"Edges of the mesh\n\n        Parameters\n        ----------\n        indexed : str | None\n           If indexed is None, return (Nf, 3) array of vertex indices,\n           two per edge in the mesh.\n           If indexed is 'faces', then return (Nf, 3, 2) array of vertex\n           indices with 3 edges per face, and two vertices per edge.\n\n        Returns\n        -------\n        edges : ndarray\n            The edges.\n        \"\"\"\n        if indexed is None:\n            if self._edges is None:\n                self._compute_edges(indexed=None)\n            return self._edges\n        elif indexed == 'faces':\n            if self._edges_indexed_by_faces is None:\n                self._compute_edges(indexed='faces')\n            return self._edges_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def set_faces(self, faces):\n        \"\"\"Set the faces\n\n        Parameters\n        ----------\n        faces : ndarray\n            (Nf, 3) array of faces. Each row in the array contains\n            three indices into the vertex array, specifying the three corners\n            of a triangular face.\n        \"\"\"\n        self._faces = faces\n        self._edges = None\n        self._edges_indexed_by_faces = None\n        self._vertex_faces = None\n        self._vertices_indexed_by_faces = None\n        self.reset_normals()\n        self._vertex_colors_indexed_by_faces = None\n        self._face_colors_indexed_by_faces = None\n\n    def get_vertices(self, indexed=None):\n        \"\"\"Get the vertices\n\n        Parameters\n        ----------\n        indexed : str | None\n            If Note, return an array (N,3) of the positions of vertices in\n            the mesh. By default, each unique vertex appears only once.\n            If indexed is 'faces', then the array will instead contain three\n            vertices per face in the mesh (and a single vertex may appear more\n            than once in the array).\n\n        Returns\n        -------\n        vertices : ndarray\n            The vertices.\n        \"\"\"\n        if indexed is None:\n            if (self._vertices is None and\n                    self._vertices_indexed_by_faces is not None):\n                self._compute_unindexed_vertices()\n            return self._vertices\n        elif indexed == 'faces':\n            if (self._vertices_indexed_by_faces is None and\n                    self._vertices is not None):\n                self._vertices_indexed_by_faces = \\\n                    self._vertices[self.get_faces()]\n            return self._vertices_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def get_bounds(self):\n        \"\"\"Get the mesh bounds\n\n        Returns\n        -------\n        bounds : list\n            A list of tuples of mesh bounds.\n        \"\"\"\n        if self._vertices_indexed_by_faces is not None:\n            v = self._vertices_indexed_by_faces\n        elif self._vertices is not None:\n            v = self._vertices\n        else:\n            return None\n        bounds = [(v[:, ax].min(), v[:, ax].max()) for ax in range(v.shape[1])]\n        return bounds\n\n    def set_vertices(self, verts=None, indexed=None, reset_normals=True):\n        \"\"\"Set the mesh vertices\n\n        Parameters\n        ----------\n        verts : ndarray | None\n            The array (Nv, 3) of vertex coordinates.\n        indexed : str | None\n            If indexed=='faces', then the data must have shape (Nf, 3, 3) and\n            is assumed to be already indexed as a list of faces. This will\n            cause any pre-existing normal vectors to be cleared unless\n            reset_normals=False.\n        reset_normals : bool\n            If True, reset the normals.\n        \"\"\"\n        if indexed is None:\n            if verts is not None:\n                self._vertices = verts\n            self._vertices_indexed_by_faces = None\n        elif indexed == 'faces':\n            self._vertices = None\n            if verts is not None:\n                self._vertices_indexed_by_faces = verts\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n        if reset_normals:\n            self.reset_normals()\n\n    def reset_normals(self):\n        self._vertex_normals = None\n        self._vertex_normals_indexed_by_faces = None\n        self._face_normals = None\n        self._face_normals_indexed_by_faces = None\n\n    def has_face_indexed_data(self):\n        \"\"\"Return True if this object already has vertex positions indexed\n        by face\n        \"\"\"\n        return self._vertices_indexed_by_faces is not None\n\n    def has_edge_indexed_data(self):\n        return self._vertices_indexed_by_edges is not None\n\n    def has_vertex_color(self):\n        \"\"\"Return True if this data set has vertex color information\"\"\"\n        for v in (self._vertex_colors, self._vertex_colors_indexed_by_faces,\n                  self._vertex_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False\n\n    def has_vertex_value(self):\n        \"\"\"Return True if this data set has vertex value information\"\"\"\n        for v in (self._vertex_values, self._vertex_values_indexed_by_faces,\n                  self._vertex_values_indexed_by_edges):\n            if v is not None:\n                return True\n        return False\n\n    def has_face_color(self):\n        \"\"\"Return True if this data set has face color information\"\"\"\n        for v in (self._face_colors, self._face_colors_indexed_by_faces,\n                  self._face_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False\n\n    def get_face_normals(self, indexed=None):\n        \"\"\"Get face normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nf, 3) of normal vectors for each face.\n            If 'faces', then instead return an indexed array (Nf, 3, 3)\n            (this is just the same array with each vector copied three times).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._face_normals is None:\n            v = self.get_vertices(indexed='faces')\n            self._face_normals = np.cross(v[:, 1] - v[:, 0],\n                                          v[:, 2] - v[:, 0])\n\n        if indexed is None:\n            return self._face_normals\n        elif indexed == 'faces':\n            if self._face_normals_indexed_by_faces is None:\n                norms = np.empty((self._face_normals.shape[0], 3, 3),\n                                 dtype=np.float32)\n                norms[:] = self._face_normals[:, np.newaxis, :]\n                self._face_normals_indexed_by_faces = norms\n            return self._face_normals_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def get_vertex_normals(self, indexed=None):\n        \"\"\"Get vertex normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an (N, 3) array of normal vectors with one entry\n            per unique vertex in the mesh. If indexed is 'faces', then the\n            array will contain three normal vectors per face (and some\n            vertices may be repeated).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._vertex_normals is None:\n            faceNorms = self.get_face_normals()\n            vertFaces = self.get_vertex_faces()\n            self._vertex_normals = np.empty(self._vertices.shape,\n                                            dtype=np.float32)\n            for vindex in range(self._vertices.shape[0]):\n                faces = vertFaces[vindex]\n                if len(faces) == 0:\n                    self._vertex_normals[vindex] = (0, 0, 0)\n                    continue\n                norms = faceNorms[faces]  # get all face normals\n                norm = norms.sum(axis=0)  # sum normals\n                renorm = (norm**2).sum()**0.5\n                if renorm > 0:\n                    norm /= renorm\n                self._vertex_normals[vindex] = norm\n\n        if indexed is None:\n            return self._vertex_normals\n        elif indexed == 'faces':\n            return self._vertex_normals[self.get_faces()]\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def get_vertex_colors(self, indexed=None):\n        \"\"\"Get vertex colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nv, 4) of vertex colors.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3, 4).\n\n        Returns\n        -------\n        colors : ndarray\n            The vertex colors.\n        \"\"\"\n        if indexed is None:\n            return self._vertex_colors\n        elif indexed == 'faces':\n            if self._vertex_colors_indexed_by_faces is None:\n                self._vertex_colors_indexed_by_faces = \\\n                    self._vertex_colors[self.get_faces()]\n            return self._vertex_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def get_vertex_values(self, indexed=None):\n        \"\"\"Get vertex colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nv,) of vertex values.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3).\n\n        Returns\n        -------\n        values : ndarray\n            The vertex values.\n        \"\"\"\n        if indexed is None:\n            return self._vertex_values\n        elif indexed == 'faces':\n            if self._vertex_values_indexed_by_faces is None:\n                self._vertex_values_indexed_by_faces = \\\n                    self._vertex_values[self.get_faces()]\n            return self._vertex_values_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def set_vertex_colors(self, colors, indexed=None):\n        \"\"\"Set the vertex color array\n\n        Parameters\n        ----------\n        colors : array\n            Array of colors. Must have shape (Nv, 4) (indexing by vertex)\n            or shape (Nf, 3, 4) (vertices indexed by face).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        colors = _fix_colors(colors)\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            if colors.shape[0] != self.n_vertices:\n                raise ValueError('incorrect number of colors %s, expected %s'\n                                 % (colors.shape[0], self.n_vertices))\n            self._vertex_colors = colors\n            self._vertex_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            if colors.shape[0] != self.n_faces:\n                raise ValueError('incorrect number of faces')\n            self._vertex_colors = None\n            self._vertex_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')\n\n    def set_vertex_values(self, values, indexed=None):\n        \"\"\"Set the vertex value array\n\n        Parameters\n        ----------\n        values : array\n            Array of values. Must have shape (Nv,) (indexing by vertex)\n            or shape (Nf, 3) (vertices indexed by face).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        values = np.asarray(values)\n        if indexed is None:\n            if values.ndim != 1:\n                raise ValueError('values must be 1D if indexed is None')\n            if values.shape[0] != self.n_vertices:\n                raise ValueError('incorrect number of colors %s, expected %s'\n                                 % (values.shape[0], self.n_vertices))\n            self._vertex_values = values\n            self._vertex_values_indexed_by_faces = None\n        elif indexed == 'faces':\n            if values.ndim != 2:\n                raise ValueError('values must be 3D if indexed is \"faces\"')\n            if values.shape[0] != self.n_faces:\n                raise ValueError('incorrect number of faces')\n            self._vertex_values = None\n            self._vertex_values_indexed_by_faces = values\n        else:\n            raise ValueError('indexed must be None or \"faces\"')\n\n    def get_face_colors(self, indexed=None):\n        \"\"\"Get the face colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If indexed is None, return (Nf, 4) array of face colors.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3, 4)  (note this is just the same array with each color\n            repeated three times).\n\n        Returns\n        -------\n        colors : ndarray\n            The colors.\n        \"\"\"\n        if indexed is None:\n            return self._face_colors\n        elif indexed == 'faces':\n            if (self._face_colors_indexed_by_faces is None and\n                    self._face_colors is not None):\n                Nf = self._face_colors.shape[0]\n                self._face_colors_indexed_by_faces = \\\n                    np.empty((Nf, 3, 4), dtype=self._face_colors.dtype)\n                self._face_colors_indexed_by_faces[:] = \\\n                    self._face_colors.reshape(Nf, 1, 4)\n            return self._face_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def set_face_colors(self, colors, indexed=None):\n        \"\"\"Set the face color array\n\n        Parameters\n        ----------\n        colors : array\n            Array of colors. Must have shape (Nf, 4) (indexed by face),\n            or shape (Nf, 3, 4) (face colors indexed by faces).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        colors = _fix_colors(colors)\n        if colors.shape[0] != self.n_faces:\n            raise ValueError('incorrect number of colors %s, expected %s'\n                             % (colors.shape[0], self.n_faces))\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            self._face_colors = colors\n            self._face_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            self._face_colors = None\n            self._face_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')\n\n    @property\n    def n_faces(self):\n        \"\"\"The number of faces in the mesh\"\"\"\n        if self._faces is not None:\n            return self._faces.shape[0]\n        elif self._vertices_indexed_by_faces is not None:\n            return self._vertices_indexed_by_faces.shape[0]\n\n    @property\n    def n_vertices(self):\n        \"\"\"The number of vertices in the mesh\"\"\"\n        if self._vertices is None:\n            self._compute_unindexed_vertices()\n        return len(self._vertices)\n\n    def get_edge_colors(self):\n        return self._edge_colors\n\n    def _compute_unindexed_vertices(self):\n        # Given (Nv, 3, 3) array of vertices-indexed-by-face, convert\n        # backward to unindexed vertices\n        # This is done by collapsing into a list of 'unique' vertices\n        # (difference < 1e-14)\n\n        # I think generally this should be discouraged..\n        faces = self._vertices_indexed_by_faces\n        verts = {}  # used to remember the index of each vertex position\n        self._faces = np.empty(faces.shape[:2], dtype=np.uint32)\n        self._vertices = []\n        self._vertex_faces = []\n        self._face_normals = None\n        self._vertex_normals = None\n        for i in range(faces.shape[0]):\n            face = faces[i]\n            for j in range(face.shape[0]):\n                pt = face[j]\n                # quantize to ensure nearly-identical points will be merged\n                pt2 = tuple([round(x*1e14) for x in pt])\n                index = verts.get(pt2, None)\n                if index is None:\n                    self._vertices.append(pt)\n                    self._vertex_faces.append([])\n                    index = len(self._vertices)-1\n                    verts[pt2] = index\n                # track which vertices belong to which faces\n                self._vertex_faces[index].append(i)\n                self._faces[i, j] = index\n        self._vertices = np.array(self._vertices, dtype=np.float32)\n\n    def get_vertex_faces(self):\n        \"\"\"List mapping each vertex index to a list of face indices that use it.\"\"\"\n        if self._vertex_faces is None:\n            self._vertex_faces = [[] for i in range(len(self.get_vertices()))]\n            for i in range(self._faces.shape[0]):\n                face = self._faces[i]\n                for ind in face:\n                    self._vertex_faces[ind].append(i)\n        return self._vertex_faces\n\n    def _compute_edges(self, indexed=None):\n        if indexed is None:\n            if self._faces is not None:\n                # generate self._edges from self._faces\n                nf = len(self._faces)\n                edges = np.empty(nf*3, dtype=[('i', np.uint32, 2)])\n                edges['i'][0:nf] = self._faces[:, :2]\n                edges['i'][nf:2*nf] = self._faces[:, 1:3]\n                edges['i'][-nf:, 0] = self._faces[:, 2]\n                edges['i'][-nf:, 1] = self._faces[:, 0]\n                # sort per-edge\n                mask = edges['i'][:, 0] > edges['i'][:, 1]\n                edges['i'][mask] = edges['i'][mask][:, ::-1]\n                # remove duplicate entries\n                self._edges = np.unique(edges)['i']\n            else:\n                raise Exception(\"MeshData cannot generate edges--no faces in \"\n                                \"this data.\")\n        elif indexed == 'faces':\n            if self._vertices_indexed_by_faces is not None:\n                verts = self._vertices_indexed_by_faces\n                edges = np.empty((verts.shape[0], 3, 2), dtype=np.uint32)\n                nf = verts.shape[0]\n                edges[:, 0, 0] = np.arange(nf) * 3\n                edges[:, 0, 1] = edges[:, 0, 0] + 1\n                edges[:, 1, 0] = edges[:, 0, 1]\n                edges[:, 1, 1] = edges[:, 1, 0] + 1\n                edges[:, 2, 0] = edges[:, 1, 1]\n                edges[:, 2, 1] = edges[:, 0, 0]\n                self._edges_indexed_by_faces = edges\n            else:\n                raise Exception(\"MeshData cannot generate edges--no faces in \"\n                                \"this data.\")\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n    def save(self):\n        \"\"\"Serialize this mesh to a string appropriate for disk storage\n\n        Returns\n        -------\n        state : dict\n            The state.\n        \"\"\"\n        import pickle\n        if self._faces is not None:\n            names = ['_vertices', '_faces']\n        else:\n            names = ['_vertices_indexed_by_faces']\n\n        if self._vertex_colors is not None:\n            names.append('_vertex_colors')\n        elif self._vertex_colors_indexed_by_faces is not None:\n            names.append('_vertex_colors_indexed_by_faces')\n\n        if self._face_colors is not None:\n            names.append('_face_colors')\n        elif self._face_colors_indexed_by_faces is not None:\n            names.append('_face_colors_indexed_by_faces')\n\n        state = dict([(n, getattr(self, n)) for n in names])\n        return pickle.dumps(state)\n\n    def restore(self, state):\n        \"\"\"Restore the state of a mesh previously saved using save()\n\n        Parameters\n        ----------\n        state : dict\n            The previous state.\n        \"\"\"\n        import pickle\n        state = pickle.loads(state)\n        for k in state:\n            if isinstance(state[k], list):\n                state[k] = np.array(state[k])\n            setattr(self, k, state[k])\n\n    def is_empty(self):\n        \"\"\"Check if any vertices or faces are defined.\"\"\"\n        return self._faces is None",
  "def __init__(self, vertices=None, faces=None, edges=None,\n                 vertex_colors=None, face_colors=None, vertex_values=None):\n        self._vertices = None  # (Nv,3) array of vertex coordinates\n        self._vertices_indexed_by_faces = None  # (Nf, 3, 3) vertex coordinates\n        self._vertices_indexed_by_edges = None  # (Ne, 2, 3) vertex coordinates\n\n        # mappings between vertices, faces, and edges\n        self._faces = None  # Nx3 indices into self._vertices, 3 verts/face\n        self._edges = None  # Nx2 indices into self._vertices, 2 verts/edge\n        self._edges_indexed_by_faces = None  # (Ne, 3, 2) indices into\n        # self._vertices, 3 edge / face and 2 verts/edge\n        # inverse mappings\n        self._vertex_faces = None  # maps vertex ID to a list of face IDs\n        self._vertex_edges = None  # maps vertex ID to a list of edge IDs\n\n        # Per-vertex data\n        self._vertex_normals = None                   # (Nv, 3) normals\n        self._vertex_normals_indexed_by_faces = None  # (Nf, 3, 3) normals\n        self._vertex_colors = None                    # (Nv, 4) colors\n        self._vertex_colors_indexed_by_faces = None   # (Nf, 3, 4) colors\n        self._vertex_colors_indexed_by_edges = None   # (Nf, 2, 4) colors\n        self._vertex_values = None                    # (Nv,) values\n        self._vertex_values_indexed_by_faces = None   # (Nv, 3) values\n        self._vertex_values_indexed_by_edges = None   # (Nv, 2) values\n\n        # Per-face data\n        self._face_normals = None                # (Nf, 3) face normals\n        self._face_normals_indexed_by_faces = None  # (Nf, 3, 3) face normals\n        self._face_colors = None                 # (Nf, 4) face colors\n        self._face_colors_indexed_by_faces = None   # (Nf, 3, 4) face colors\n        self._face_colors_indexed_by_edges = None   # (Ne, 2, 4) face colors\n\n        # Per-edge data\n        self._edge_colors = None                # (Ne, 4) edge colors\n        self._edge_colors_indexed_by_edges = None  # (Ne, 2, 4) edge colors\n        if vertices is not None:\n            indexed = 'faces' if faces is None else None\n            self.set_vertices(vertices, indexed=indexed)\n            if faces is not None:\n                self.set_faces(faces)\n            if vertex_colors is not None:\n                self.set_vertex_colors(vertex_colors, indexed=indexed)\n            if face_colors is not None:\n                self.set_face_colors(face_colors, indexed=indexed)\n            if vertex_values is not None:\n                self.set_vertex_values(vertex_values, indexed=indexed)",
  "def get_faces(self):\n        \"\"\"Array (Nf, 3) of vertex indices, three per triangular face.\n\n        If faces have not been computed for this mesh, returns None.\n        \"\"\"\n        return self._faces",
  "def get_edges(self, indexed=None):\n        \"\"\"Edges of the mesh\n\n        Parameters\n        ----------\n        indexed : str | None\n           If indexed is None, return (Nf, 3) array of vertex indices,\n           two per edge in the mesh.\n           If indexed is 'faces', then return (Nf, 3, 2) array of vertex\n           indices with 3 edges per face, and two vertices per edge.\n\n        Returns\n        -------\n        edges : ndarray\n            The edges.\n        \"\"\"\n        if indexed is None:\n            if self._edges is None:\n                self._compute_edges(indexed=None)\n            return self._edges\n        elif indexed == 'faces':\n            if self._edges_indexed_by_faces is None:\n                self._compute_edges(indexed='faces')\n            return self._edges_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def set_faces(self, faces):\n        \"\"\"Set the faces\n\n        Parameters\n        ----------\n        faces : ndarray\n            (Nf, 3) array of faces. Each row in the array contains\n            three indices into the vertex array, specifying the three corners\n            of a triangular face.\n        \"\"\"\n        self._faces = faces\n        self._edges = None\n        self._edges_indexed_by_faces = None\n        self._vertex_faces = None\n        self._vertices_indexed_by_faces = None\n        self.reset_normals()\n        self._vertex_colors_indexed_by_faces = None\n        self._face_colors_indexed_by_faces = None",
  "def get_vertices(self, indexed=None):\n        \"\"\"Get the vertices\n\n        Parameters\n        ----------\n        indexed : str | None\n            If Note, return an array (N,3) of the positions of vertices in\n            the mesh. By default, each unique vertex appears only once.\n            If indexed is 'faces', then the array will instead contain three\n            vertices per face in the mesh (and a single vertex may appear more\n            than once in the array).\n\n        Returns\n        -------\n        vertices : ndarray\n            The vertices.\n        \"\"\"\n        if indexed is None:\n            if (self._vertices is None and\n                    self._vertices_indexed_by_faces is not None):\n                self._compute_unindexed_vertices()\n            return self._vertices\n        elif indexed == 'faces':\n            if (self._vertices_indexed_by_faces is None and\n                    self._vertices is not None):\n                self._vertices_indexed_by_faces = \\\n                    self._vertices[self.get_faces()]\n            return self._vertices_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def get_bounds(self):\n        \"\"\"Get the mesh bounds\n\n        Returns\n        -------\n        bounds : list\n            A list of tuples of mesh bounds.\n        \"\"\"\n        if self._vertices_indexed_by_faces is not None:\n            v = self._vertices_indexed_by_faces\n        elif self._vertices is not None:\n            v = self._vertices\n        else:\n            return None\n        bounds = [(v[:, ax].min(), v[:, ax].max()) for ax in range(v.shape[1])]\n        return bounds",
  "def set_vertices(self, verts=None, indexed=None, reset_normals=True):\n        \"\"\"Set the mesh vertices\n\n        Parameters\n        ----------\n        verts : ndarray | None\n            The array (Nv, 3) of vertex coordinates.\n        indexed : str | None\n            If indexed=='faces', then the data must have shape (Nf, 3, 3) and\n            is assumed to be already indexed as a list of faces. This will\n            cause any pre-existing normal vectors to be cleared unless\n            reset_normals=False.\n        reset_normals : bool\n            If True, reset the normals.\n        \"\"\"\n        if indexed is None:\n            if verts is not None:\n                self._vertices = verts\n            self._vertices_indexed_by_faces = None\n        elif indexed == 'faces':\n            self._vertices = None\n            if verts is not None:\n                self._vertices_indexed_by_faces = verts\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n        if reset_normals:\n            self.reset_normals()",
  "def reset_normals(self):\n        self._vertex_normals = None\n        self._vertex_normals_indexed_by_faces = None\n        self._face_normals = None\n        self._face_normals_indexed_by_faces = None",
  "def has_face_indexed_data(self):\n        \"\"\"Return True if this object already has vertex positions indexed\n        by face\n        \"\"\"\n        return self._vertices_indexed_by_faces is not None",
  "def has_edge_indexed_data(self):\n        return self._vertices_indexed_by_edges is not None",
  "def has_vertex_color(self):\n        \"\"\"Return True if this data set has vertex color information\"\"\"\n        for v in (self._vertex_colors, self._vertex_colors_indexed_by_faces,\n                  self._vertex_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False",
  "def has_vertex_value(self):\n        \"\"\"Return True if this data set has vertex value information\"\"\"\n        for v in (self._vertex_values, self._vertex_values_indexed_by_faces,\n                  self._vertex_values_indexed_by_edges):\n            if v is not None:\n                return True\n        return False",
  "def has_face_color(self):\n        \"\"\"Return True if this data set has face color information\"\"\"\n        for v in (self._face_colors, self._face_colors_indexed_by_faces,\n                  self._face_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False",
  "def get_face_normals(self, indexed=None):\n        \"\"\"Get face normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nf, 3) of normal vectors for each face.\n            If 'faces', then instead return an indexed array (Nf, 3, 3)\n            (this is just the same array with each vector copied three times).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._face_normals is None:\n            v = self.get_vertices(indexed='faces')\n            self._face_normals = np.cross(v[:, 1] - v[:, 0],\n                                          v[:, 2] - v[:, 0])\n\n        if indexed is None:\n            return self._face_normals\n        elif indexed == 'faces':\n            if self._face_normals_indexed_by_faces is None:\n                norms = np.empty((self._face_normals.shape[0], 3, 3),\n                                 dtype=np.float32)\n                norms[:] = self._face_normals[:, np.newaxis, :]\n                self._face_normals_indexed_by_faces = norms\n            return self._face_normals_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def get_vertex_normals(self, indexed=None):\n        \"\"\"Get vertex normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an (N, 3) array of normal vectors with one entry\n            per unique vertex in the mesh. If indexed is 'faces', then the\n            array will contain three normal vectors per face (and some\n            vertices may be repeated).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._vertex_normals is None:\n            faceNorms = self.get_face_normals()\n            vertFaces = self.get_vertex_faces()\n            self._vertex_normals = np.empty(self._vertices.shape,\n                                            dtype=np.float32)\n            for vindex in range(self._vertices.shape[0]):\n                faces = vertFaces[vindex]\n                if len(faces) == 0:\n                    self._vertex_normals[vindex] = (0, 0, 0)\n                    continue\n                norms = faceNorms[faces]  # get all face normals\n                norm = norms.sum(axis=0)  # sum normals\n                renorm = (norm**2).sum()**0.5\n                if renorm > 0:\n                    norm /= renorm\n                self._vertex_normals[vindex] = norm\n\n        if indexed is None:\n            return self._vertex_normals\n        elif indexed == 'faces':\n            return self._vertex_normals[self.get_faces()]\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def get_vertex_colors(self, indexed=None):\n        \"\"\"Get vertex colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nv, 4) of vertex colors.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3, 4).\n\n        Returns\n        -------\n        colors : ndarray\n            The vertex colors.\n        \"\"\"\n        if indexed is None:\n            return self._vertex_colors\n        elif indexed == 'faces':\n            if self._vertex_colors_indexed_by_faces is None:\n                self._vertex_colors_indexed_by_faces = \\\n                    self._vertex_colors[self.get_faces()]\n            return self._vertex_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def get_vertex_values(self, indexed=None):\n        \"\"\"Get vertex colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nv,) of vertex values.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3).\n\n        Returns\n        -------\n        values : ndarray\n            The vertex values.\n        \"\"\"\n        if indexed is None:\n            return self._vertex_values\n        elif indexed == 'faces':\n            if self._vertex_values_indexed_by_faces is None:\n                self._vertex_values_indexed_by_faces = \\\n                    self._vertex_values[self.get_faces()]\n            return self._vertex_values_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def set_vertex_colors(self, colors, indexed=None):\n        \"\"\"Set the vertex color array\n\n        Parameters\n        ----------\n        colors : array\n            Array of colors. Must have shape (Nv, 4) (indexing by vertex)\n            or shape (Nf, 3, 4) (vertices indexed by face).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        colors = _fix_colors(colors)\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            if colors.shape[0] != self.n_vertices:\n                raise ValueError('incorrect number of colors %s, expected %s'\n                                 % (colors.shape[0], self.n_vertices))\n            self._vertex_colors = colors\n            self._vertex_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            if colors.shape[0] != self.n_faces:\n                raise ValueError('incorrect number of faces')\n            self._vertex_colors = None\n            self._vertex_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')",
  "def set_vertex_values(self, values, indexed=None):\n        \"\"\"Set the vertex value array\n\n        Parameters\n        ----------\n        values : array\n            Array of values. Must have shape (Nv,) (indexing by vertex)\n            or shape (Nf, 3) (vertices indexed by face).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        values = np.asarray(values)\n        if indexed is None:\n            if values.ndim != 1:\n                raise ValueError('values must be 1D if indexed is None')\n            if values.shape[0] != self.n_vertices:\n                raise ValueError('incorrect number of colors %s, expected %s'\n                                 % (values.shape[0], self.n_vertices))\n            self._vertex_values = values\n            self._vertex_values_indexed_by_faces = None\n        elif indexed == 'faces':\n            if values.ndim != 2:\n                raise ValueError('values must be 3D if indexed is \"faces\"')\n            if values.shape[0] != self.n_faces:\n                raise ValueError('incorrect number of faces')\n            self._vertex_values = None\n            self._vertex_values_indexed_by_faces = values\n        else:\n            raise ValueError('indexed must be None or \"faces\"')",
  "def get_face_colors(self, indexed=None):\n        \"\"\"Get the face colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If indexed is None, return (Nf, 4) array of face colors.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3, 4)  (note this is just the same array with each color\n            repeated three times).\n\n        Returns\n        -------\n        colors : ndarray\n            The colors.\n        \"\"\"\n        if indexed is None:\n            return self._face_colors\n        elif indexed == 'faces':\n            if (self._face_colors_indexed_by_faces is None and\n                    self._face_colors is not None):\n                Nf = self._face_colors.shape[0]\n                self._face_colors_indexed_by_faces = \\\n                    np.empty((Nf, 3, 4), dtype=self._face_colors.dtype)\n                self._face_colors_indexed_by_faces[:] = \\\n                    self._face_colors.reshape(Nf, 1, 4)\n            return self._face_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def set_face_colors(self, colors, indexed=None):\n        \"\"\"Set the face color array\n\n        Parameters\n        ----------\n        colors : array\n            Array of colors. Must have shape (Nf, 4) (indexed by face),\n            or shape (Nf, 3, 4) (face colors indexed by faces).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        colors = _fix_colors(colors)\n        if colors.shape[0] != self.n_faces:\n            raise ValueError('incorrect number of colors %s, expected %s'\n                             % (colors.shape[0], self.n_faces))\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            self._face_colors = colors\n            self._face_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            self._face_colors = None\n            self._face_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')",
  "def n_faces(self):\n        \"\"\"The number of faces in the mesh\"\"\"\n        if self._faces is not None:\n            return self._faces.shape[0]\n        elif self._vertices_indexed_by_faces is not None:\n            return self._vertices_indexed_by_faces.shape[0]",
  "def n_vertices(self):\n        \"\"\"The number of vertices in the mesh\"\"\"\n        if self._vertices is None:\n            self._compute_unindexed_vertices()\n        return len(self._vertices)",
  "def get_edge_colors(self):\n        return self._edge_colors",
  "def _compute_unindexed_vertices(self):\n        # Given (Nv, 3, 3) array of vertices-indexed-by-face, convert\n        # backward to unindexed vertices\n        # This is done by collapsing into a list of 'unique' vertices\n        # (difference < 1e-14)\n\n        # I think generally this should be discouraged..\n        faces = self._vertices_indexed_by_faces\n        verts = {}  # used to remember the index of each vertex position\n        self._faces = np.empty(faces.shape[:2], dtype=np.uint32)\n        self._vertices = []\n        self._vertex_faces = []\n        self._face_normals = None\n        self._vertex_normals = None\n        for i in range(faces.shape[0]):\n            face = faces[i]\n            for j in range(face.shape[0]):\n                pt = face[j]\n                # quantize to ensure nearly-identical points will be merged\n                pt2 = tuple([round(x*1e14) for x in pt])\n                index = verts.get(pt2, None)\n                if index is None:\n                    self._vertices.append(pt)\n                    self._vertex_faces.append([])\n                    index = len(self._vertices)-1\n                    verts[pt2] = index\n                # track which vertices belong to which faces\n                self._vertex_faces[index].append(i)\n                self._faces[i, j] = index\n        self._vertices = np.array(self._vertices, dtype=np.float32)",
  "def get_vertex_faces(self):\n        \"\"\"List mapping each vertex index to a list of face indices that use it.\"\"\"\n        if self._vertex_faces is None:\n            self._vertex_faces = [[] for i in range(len(self.get_vertices()))]\n            for i in range(self._faces.shape[0]):\n                face = self._faces[i]\n                for ind in face:\n                    self._vertex_faces[ind].append(i)\n        return self._vertex_faces",
  "def _compute_edges(self, indexed=None):\n        if indexed is None:\n            if self._faces is not None:\n                # generate self._edges from self._faces\n                nf = len(self._faces)\n                edges = np.empty(nf*3, dtype=[('i', np.uint32, 2)])\n                edges['i'][0:nf] = self._faces[:, :2]\n                edges['i'][nf:2*nf] = self._faces[:, 1:3]\n                edges['i'][-nf:, 0] = self._faces[:, 2]\n                edges['i'][-nf:, 1] = self._faces[:, 0]\n                # sort per-edge\n                mask = edges['i'][:, 0] > edges['i'][:, 1]\n                edges['i'][mask] = edges['i'][mask][:, ::-1]\n                # remove duplicate entries\n                self._edges = np.unique(edges)['i']\n            else:\n                raise Exception(\"MeshData cannot generate edges--no faces in \"\n                                \"this data.\")\n        elif indexed == 'faces':\n            if self._vertices_indexed_by_faces is not None:\n                verts = self._vertices_indexed_by_faces\n                edges = np.empty((verts.shape[0], 3, 2), dtype=np.uint32)\n                nf = verts.shape[0]\n                edges[:, 0, 0] = np.arange(nf) * 3\n                edges[:, 0, 1] = edges[:, 0, 0] + 1\n                edges[:, 1, 0] = edges[:, 0, 1]\n                edges[:, 1, 1] = edges[:, 1, 0] + 1\n                edges[:, 2, 0] = edges[:, 1, 1]\n                edges[:, 2, 1] = edges[:, 0, 0]\n                self._edges_indexed_by_faces = edges\n            else:\n                raise Exception(\"MeshData cannot generate edges--no faces in \"\n                                \"this data.\")\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")",
  "def save(self):\n        \"\"\"Serialize this mesh to a string appropriate for disk storage\n\n        Returns\n        -------\n        state : dict\n            The state.\n        \"\"\"\n        import pickle\n        if self._faces is not None:\n            names = ['_vertices', '_faces']\n        else:\n            names = ['_vertices_indexed_by_faces']\n\n        if self._vertex_colors is not None:\n            names.append('_vertex_colors')\n        elif self._vertex_colors_indexed_by_faces is not None:\n            names.append('_vertex_colors_indexed_by_faces')\n\n        if self._face_colors is not None:\n            names.append('_face_colors')\n        elif self._face_colors_indexed_by_faces is not None:\n            names.append('_face_colors_indexed_by_faces')\n\n        state = dict([(n, getattr(self, n)) for n in names])\n        return pickle.dumps(state)",
  "def restore(self, state):\n        \"\"\"Restore the state of a mesh previously saved using save()\n\n        Parameters\n        ----------\n        state : dict\n            The previous state.\n        \"\"\"\n        import pickle\n        state = pickle.loads(state)\n        for k in state:\n            if isinstance(state[k], list):\n                state[k] = np.array(state[k])\n            setattr(self, k, state[k])",
  "def is_empty(self):\n        \"\"\"Check if any vertices or faces are defined.\"\"\"\n        return self._faces is None",
  "def isocurve(data, level, connected=False, extend_to_edge=False):\n    \"\"\"\n    Generate isocurve from 2D data using marching squares algorithm.\n\n    Parameters\n    ----------\n    data : ndarray\n        2D numpy array of scalar values\n    level : float\n        The level at which to generate an isosurface\n    connected : bool\n        If False, return a single long list of point pairs\n        If True, return multiple long lists of connected point \n        locations. (This is slower but better for drawing \n        continuous lines)\n    extend_to_edge : bool\n        If True, extend the curves to reach the exact edges of \n        the data. \n    \"\"\"    \n    # This function is SLOW; plenty of room for optimization here.\n\n    if extend_to_edge:\n        d2 = np.empty((data.shape[0]+2, data.shape[1]+2), dtype=data.dtype)\n        d2[1:-1, 1:-1] = data\n        d2[0, 1:-1] = data[0]\n        d2[-1, 1:-1] = data[-1]\n        d2[1:-1, 0] = data[:, 0]\n        d2[1:-1, -1] = data[:, -1]\n        d2[0, 0] = d2[0, 1]\n        d2[0, -1] = d2[1, -1]\n        d2[-1, 0] = d2[-1, 1]\n        d2[-1, -1] = d2[-1, -2]\n        data = d2\n\n    side_table = [\n        [],\n        [0, 1],\n        [1, 2],\n        [0, 2],\n        [0, 3],\n        [1, 3],\n        [0, 1, 2, 3],\n        [2, 3],\n        [2, 3],\n        [0, 1, 2, 3],\n        [1, 3],\n        [0, 3],\n        [0, 2],\n        [1, 2],\n        [0, 1],\n        []\n    ]\n\n    edge_key = [\n        [(0, 1), (0, 0)],\n        [(0, 0), (1, 0)],\n        [(1, 0), (1, 1)],\n        [(1, 1), (0, 1)]\n    ]\n\n    level = float(level)\n    lines = []\n\n    # mark everything below the isosurface level\n    mask = data < level\n\n    # make four sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2, 2), dtype=object)\n    slices = [slice(0, -1), slice(1, None)]\n    for i in [0, 1]:\n        for j in [0, 1]:\n            fields[i, j] = mask[slices[i], slices[j]]\n            vertIndex = i+2*j\n            index += (fields[i, j] * 2**vertIndex).astype(np.ubyte)\n\n    # add lines\n    for i in range(index.shape[0]):                 # data x-axis\n        for j in range(index.shape[1]):             # data y-axis     \n            sides = side_table[index[i, j]]\n            for side_idx in range(0, len(sides), 2):  # faces for this grid cell\n                edges = sides[side_idx:side_idx+2]\n                pts = []\n                for m in [0, 1]:      # points in this face\n                    # p1, p2 are points at either side of an edge\n                    p1 = edge_key[edges[m]][0] \n                    p2 = edge_key[edges[m]][1]\n                    # v1 and v2 are the values at p1 and p2\n                    v1 = data[i+p1[0], j+p1[1]] \n                    v2 = data[i+p2[0], j+p2[1]]\n                    f = (level-v1) / (v2-v1)\n                    fi = 1.0 - f\n                    # interpolate between corners\n                    p = (p1[0]*fi + p2[0]*f + i + 0.5, \n                         p1[1]*fi + p2[1]*f + j + 0.5)\n                    if extend_to_edge:\n                        # check bounds\n                        p = (min(data.shape[0]-2, max(0, p[0]-1)),\n                             min(data.shape[1]-2, max(0, p[1]-1)))\n                    if connected:\n                        gridKey = (i + (1 if edges[m] == 2 else 0), \n                                   j + (1 if edges[m] == 3 else 0), \n                                   edges[m] % 2)\n                        # give the actual position and a key identifying the \n                        # grid location (for connecting segments)\n                        pts.append((p, gridKey))\n                    else:\n                        pts.append(p)\n\n                lines.append(pts)\n\n    if not connected:\n        return lines\n\n    # turn disjoint list of segments into continuous lines\n\n    points = {}  # maps each point to its connections\n    for a, b in lines:\n        if a[1] not in points:\n            points[a[1]] = []\n        points[a[1]].append([a, b])\n        if b[1] not in points:\n            points[b[1]] = []\n        points[b[1]].append([b, a])\n\n    # rearrange into chains\n    for k in list(points.keys()):\n        try:\n            chains = points[k]\n        except KeyError:  # already used this point elsewhere\n            continue\n        for chain in chains:\n            x = None\n            while True:\n                if x == chain[-1][1]:\n                    break  # nothing left to do on this chain\n\n                x = chain[-1][1]\n                if x == k:\n                    # chain has looped; we're done and can ignore the opposite\n                    # chain\n                    break\n                y = chain[-2][1]\n                connects = points[x]\n                for conn in connects[:]:\n                    if conn[1][1] != y:\n                        chain.extend(conn[1:])\n                del points[x]\n            if chain[0][1] == chain[-1][1]:\n                # looped chain; no need to continue the other direction\n                chains.pop()\n                break\n\n    # extract point locations \n    lines = []\n    for chain in points.values():\n        if len(chain) == 2:\n            # join together ends of chain\n            chain = chain[1][1:][::-1] + chain[0]\n        else:\n            chain = chain[0]\n        lines.append([pt[0] for pt in chain])\n\n    return lines",
  "def calc_sq_distance(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    return dx * dx + dy * dy",
  "def _curve3_recursive_bezier(points, x1, y1, x2, y2, x3, y3, level=0):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    x12 = (x1 + x2) / 2.\n    y12 = (y1 + y2) / 2.\n    x23 = (x2 + x3) / 2.\n    y23 = (y2 + y3) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n\n    dx = x3 - x1\n    dy = y3 - y1\n    d = math.fabs((x2 - x3) * dy - (y2 - y3) * dx)\n\n    if d > curve_collinearity_epsilon:\n        # Regular case\n        if d * d <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x123, y123))\n                return\n\n            # Angle & Cusp Condition\n            da = math.fabs(\n                math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da >= math.pi:\n                da = 2 * math.pi - da\n\n            if da < m_angle_tolerance:\n                # Finally we can stop the recursion\n                points.append((x123, y123))\n                return\n    else:\n        # Collinear case\n        da = dx * dx + dy * dy\n        if da == 0:\n            d = calc_sq_distance(x1, y1, x2, y2)\n        else:\n            d = ((x2 - x1) * dx + (y2 - y1) * dy) / da\n            if d > 0 and d < 1:\n                # Simple collinear case, 1---2---3, we can leave just two\n                # endpoints\n                return\n            if(d <= 0):\n                d = calc_sq_distance(x2, y2, x1, y1)\n            elif d >= 1:\n                d = calc_sq_distance(x2, y2, x3, y3)\n            else:\n                d = calc_sq_distance(x2, y2, x1 + d * dx, y1 + d * dy)\n\n        if d < m_distance_tolerance_square:\n            points.append((x2, y2))\n            return\n\n    # Continue subdivision\n    _curve3_recursive_bezier(points, x1, y1, x12, y12, x123, y123, level + 1)\n    _curve3_recursive_bezier(points, x123, y123, x23, y23, x3, y3, level + 1)",
  "def _curve4_recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4, level=0):\n    if level > curve_recursion_limit:\n        return\n\n    # Calculate all the mid-points of the line segments\n    x12 = (x1 + x2) / 2.\n    y12 = (y1 + y2) / 2.\n    x23 = (x2 + x3) / 2.\n    y23 = (y2 + y3) / 2.\n    x34 = (x3 + x4) / 2.\n    y34 = (y3 + y4) / 2.\n    x123 = (x12 + x23) / 2.\n    y123 = (y12 + y23) / 2.\n    x234 = (x23 + x34) / 2.\n    y234 = (y23 + y34) / 2.\n    x1234 = (x123 + x234) / 2.\n    y1234 = (y123 + y234) / 2.\n\n    # Try to approximate the full cubic curve by a single straight line\n    dx = x4 - x1\n    dy = y4 - y1\n    d2 = math.fabs(((x2 - x4) * dy - (y2 - y4) * dx))\n    d3 = math.fabs(((x3 - x4) * dy - (y3 - y4) * dx))\n\n    s = int((d2 > curve_collinearity_epsilon) << 1) + \\\n        int(d3 > curve_collinearity_epsilon)\n\n    if s == 0:\n        # All collinear OR p1==p4\n        k = dx * dx + dy * dy\n        if k == 0:\n            d2 = calc_sq_distance(x1, y1, x2, y2)\n            d3 = calc_sq_distance(x4, y4, x3, y3)\n\n        else:\n            k = 1. / k\n            da1 = x2 - x1\n            da2 = y2 - y1\n            d2 = k * (da1 * dx + da2 * dy)\n            da1 = x3 - x1\n            da2 = y3 - y1\n            d3 = k * (da1 * dx + da2 * dy)\n            if d2 > 0 and d2 < 1 and d3 > 0 and d3 < 1:\n                # Simple collinear case, 1---2---3---4\n                # We can leave just two endpoints\n                return\n\n            if d2 <= 0:\n                d2 = calc_sq_distance(x2, y2, x1, y1)\n            elif d2 >= 1:\n                d2 = calc_sq_distance(x2, y2, x4, y4)\n            else:\n                d2 = calc_sq_distance(x2, y2, x1 + d2 * dx, y1 + d2 * dy)\n\n            if d3 <= 0:\n                d3 = calc_sq_distance(x3, y3, x1, y1)\n            elif d3 >= 1:\n                d3 = calc_sq_distance(x3, y3, x4, y4)\n            else:\n                d3 = calc_sq_distance(x3, y3, x1 + d3 * dx, y1 + d3 * dy)\n\n        if d2 > d3:\n            if d2 < m_distance_tolerance_square:\n                points.append((x2, y2))\n                return\n        else:\n            if d3 < m_distance_tolerance_square:\n                points.append((x3, y3))\n                return\n\n    elif s == 1:\n        # p1,p2,p4 are collinear, p3 is significant\n        if d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle Condition\n            da1 = math.fabs(\n                math.atan2(y4 - y3, x4 - x3) - math.atan2(y3 - y2, x3 - x2))\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend([(x2, y2), (x3, y3)])\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x3, y3))\n                    return\n\n    elif s == 2:\n        # p1,p3,p4 are collinear, p2 is significant\n        if d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy):\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle Condition\n            # ---------------\n            da1 = math.fabs(\n                math.atan2(y3 - y2, x3 - x2) - math.atan2(y2 - y1, x2 - x1))\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n\n            if da1 < m_angle_tolerance:\n                points.extend([(x2, y2), (x3, y3)])\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x2, y2))\n                    return\n\n    elif s == 3:\n        # Regular case\n        if (d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (\n                dx * dx + dy * dy):\n            # If the curvature doesn't exceed the distance_tolerance value\n            # we tend to finish subdivisions.\n\n            if m_angle_tolerance < curve_angle_tolerance_epsilon:\n                points.append((x23, y23))\n                return\n\n            # Angle & Cusp Condition\n            k = math.atan2(y3 - y2, x3 - x2)\n            da1 = math.fabs(k - math.atan2(y2 - y1, x2 - x1))\n            da2 = math.fabs(math.atan2(y4 - y3, x4 - x3) - k)\n            if da1 >= math.pi:\n                da1 = 2 * math.pi - da1\n            if da2 >= math.pi:\n                da2 = 2 * math.pi - da2\n\n            if da1 + da2 < m_angle_tolerance:\n                # Finally we can stop the recursion\n                points.append((x23, y23))\n                return\n\n            if m_cusp_limit != 0.0:\n                if da1 > m_cusp_limit:\n                    points.append((x2, y2))\n                    return\n\n                if da2 > m_cusp_limit:\n                    points.append((x3, y3))\n                    return\n\n    # Continue subdivision\n    _curve4_recursive_bezier(\n        points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1)\n    _curve4_recursive_bezier(\n        points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1)",
  "def curve3_bezier(p1, p2, p3):\n    \"\"\"\n    Generate the vertices for a quadratic Bezier curve.\n\n    The vertices returned by this function can be passed to a LineVisual or\n    ArrowVisual.\n\n    Parameters\n    ----------\n    p1 : array\n        2D coordinates of the start point\n    p2 : array\n        2D coordinates of the first curve point\n    p3 : array\n        2D coordinates of the end point\n\n    Returns\n    -------\n    coords : list\n        Vertices for the Bezier curve.\n\n    See Also\n    --------\n    curve4_bezier\n\n    Notes\n    -----\n    For more information about Bezier curves please refer to the `Wikipedia`_\n    page.\n\n    .. _Wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    points = []\n    _curve3_recursive_bezier(points, x1, y1, x2, y2, x3, y3)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > 1e-10:\n        points.insert(0, (x1, y1))\n\n    dx, dy = points[-1][0] - x3, points[-1][1] - y3\n    if (dx * dx + dy * dy) > 1e-10:\n        points.append((x3, y3))\n\n    return np.array(points).reshape(len(points), 2)",
  "def curve4_bezier(p1, p2, p3, p4):\n    \"\"\"\n    Generate the vertices for a third order Bezier curve.\n\n    The vertices returned by this function can be passed to a LineVisual or\n    ArrowVisual.\n\n    Parameters\n    ----------\n    p1 : array\n        2D coordinates of the start point\n    p2 : array\n        2D coordinates of the first curve point\n    p3 : array\n        2D coordinates of the second curve point\n    p4 : array\n        2D coordinates of the end point\n\n    Returns\n    -------\n    coords : list\n        Vertices for the Bezier curve.\n\n    See Also\n    --------\n    curve3_bezier\n\n    Notes\n    -----\n    For more information about Bezier curves please refer to the `Wikipedia`_\n    page.\n\n    .. _Wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    points = []\n    _curve4_recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > 1e-10:\n        points.insert(0, (x1, y1))\n    dx, dy = points[-1][0] - x4, points[-1][1] - y4\n    if (dx * dx + dy * dy) > 1e-10:\n        points.append((x4, y4))\n\n    return np.array(points).reshape(len(points), 2)",
  "class Rect(object):\n    \"\"\"\n    Representation of a rectangular area in a 2D coordinate system.\n\n    Parameters\n    ----------\n    *args : arguments\n        Can be in the form `Rect(x, y, w, h)`, `Rect(pos, size)`, or\n        `Rect(Rect)`.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._pos = (0, 0)\n        self._size = (0, 0)\n\n        if len(args) == 1 and isinstance(args[0], Rect):\n            self._pos = args[0]._pos[:]\n            self._size = args[0]._size[:]\n        elif (len(args) == 1 and isinstance(args[0], (list, tuple)) and\n              len(args[0]) == 4):\n            self._pos = args[0][:2]\n            self._size = args[0][2:]\n        elif len(args) == 2:\n            self._pos = tuple(args[0])\n            self._size = tuple(args[1])\n        elif len(args) == 4:\n            self._pos = tuple(args[:2])\n            self._size = tuple(args[2:])\n        elif len(args) != 0:\n            raise TypeError(\"Rect must be instantiated with 0, 1, 2, or 4 \"\n                            \"non-keyword arguments.\")\n\n        self._pos = kwargs.get('pos', self._pos)\n        self._size = kwargs.get('size', self._size)\n\n        if len(self._pos) != 2 or len(self._size) != 2:\n            raise ValueError(\"Rect pos and size arguments must have 2 \"\n                             \"elements.\")\n\n    @property\n    def pos(self):\n        return tuple(self._pos)\n\n    @pos.setter\n    def pos(self, p):\n        assert len(p) == 2\n        self._pos = p\n\n    @property\n    def size(self):\n        return tuple(self._size)\n\n    @size.setter\n    def size(self, s):\n        assert len(s) == 2\n        self._size = s\n\n    @property\n    def width(self):\n        return self.size[0]\n\n    @width.setter\n    def width(self, w):\n        self.size = (w, self.size[1])\n\n    @property\n    def height(self):\n        return self.size[1]\n\n    @height.setter\n    def height(self, h):\n        self.size = (self.size[0], h)\n\n    @property\n    def left(self):\n        return self.pos[0]\n\n    @left.setter\n    def left(self, x):\n        self.size = (self.size[0] + (self.pos[0] - x), self.size[1])\n        self.pos = (x, self.pos[1])\n\n    @property\n    def right(self):\n        return self.pos[0] + self.size[0]\n\n    @right.setter\n    def right(self, x):\n        self.size = (x - self.pos[0], self.size[1])\n\n    @property\n    def bottom(self):\n        return self.pos[1]\n\n    @bottom.setter\n    def bottom(self, y):\n        self.size = (self.size[0], self.size[1] + (self.pos[1] - y))\n        self.pos = (self.pos[0], y)\n\n    @property\n    def top(self):\n        return self.pos[1] + self.size[1]\n\n    @top.setter\n    def top(self, y):\n        self.size = (self.size[0], y - self.pos[1])\n\n    @property\n    def center(self):\n        return (self.pos[0] + self.size[0] * 0.5,\n                self.pos[1] + self.size[1] * 0.5)\n\n    @center.setter\n    def center(self, value):\n        delta_x = value[0] - self.center[0]\n        delta_y = value[1] - self.center[1]\n        self.pos = (self.pos[0] + delta_x, self.pos[1] + delta_y)\n\n    def padded(self, padding):\n        \"\"\"Return a new Rect padded (smaller) by padding on all sides\n\n        Parameters\n        ----------\n        padding : float\n            The padding.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The padded rectangle.\n        \"\"\"\n        return Rect(pos=(self.pos[0]+padding, self.pos[1]+padding),\n                    size=(self.size[0]-2*padding, self.size[1]-2*padding))\n\n    def normalized(self):\n        \"\"\"Return a Rect covering the same area, but with height and width\n        guaranteed to be positive.\n        \"\"\"\n        return Rect(pos=(min(self.left, self.right),\n                         min(self.top, self.bottom)),\n                    size=(abs(self.width), abs(self.height)))\n\n    def flipped(self, x=False, y=True):\n        \"\"\"Return a Rect with the same bounds but with axes inverted\n\n        Parameters\n        ----------\n        x : bool\n            Flip the X axis.\n        y : bool\n            Flip the Y axis.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The flipped rectangle.\n        \"\"\"\n        pos = list(self.pos)\n        size = list(self.size)\n        for i, flip in enumerate((x, y)):\n            if flip:\n                pos[i] += size[i]\n                size[i] *= -1\n        return Rect(pos, size)\n\n    def __eq__(self, r):\n        if not isinstance(r, Rect):\n            return False\n        return (np.all(np.equal(r.pos, self.pos)) and\n                np.all(np.equal(r.size, self.size)))\n\n    def __add__(self, a):\n        \"\"\"Return this Rect translated by *a*.\"\"\"\n        return self._transform_out(self._transform_in()[:, :2] + a[:2])\n\n    def contains(self, x, y):\n        \"\"\"Query if the rectangle contains points\n\n        Parameters\n        ----------\n        x : float\n            X coordinate.\n        y : float\n            Y coordinate.\n\n        Returns\n        -------\n        contains : bool\n            True if the point is within the rectangle.\n        \"\"\"\n        return (x >= self.left and x <= self.right and\n                y >= self.bottom and y <= self.top)\n\n    def __repr__(self):\n        return \"<Rect (%g, %g) (%g, %g)>\" % (self.pos + self.size)\n\n    def _transform_in(self):\n        \"\"\"Return array of coordinates that can be mapped by Transform\n        classes.\n        \"\"\"\n        return np.array([\n            [self.left, self.bottom, 0, 1],\n            [self.right, self.top, 0, 1]])\n\n    def _transform_out(self, coords):\n        \"\"\"Return a new Rect from coordinates mapped after _transform_in().\"\"\"\n        return Rect(pos=coords[0, :2], size=coords[1, :2]-coords[0, :2])",
  "def __init__(self, *args, **kwargs):\n        self._pos = (0, 0)\n        self._size = (0, 0)\n\n        if len(args) == 1 and isinstance(args[0], Rect):\n            self._pos = args[0]._pos[:]\n            self._size = args[0]._size[:]\n        elif (len(args) == 1 and isinstance(args[0], (list, tuple)) and\n              len(args[0]) == 4):\n            self._pos = args[0][:2]\n            self._size = args[0][2:]\n        elif len(args) == 2:\n            self._pos = tuple(args[0])\n            self._size = tuple(args[1])\n        elif len(args) == 4:\n            self._pos = tuple(args[:2])\n            self._size = tuple(args[2:])\n        elif len(args) != 0:\n            raise TypeError(\"Rect must be instantiated with 0, 1, 2, or 4 \"\n                            \"non-keyword arguments.\")\n\n        self._pos = kwargs.get('pos', self._pos)\n        self._size = kwargs.get('size', self._size)\n\n        if len(self._pos) != 2 or len(self._size) != 2:\n            raise ValueError(\"Rect pos and size arguments must have 2 \"\n                             \"elements.\")",
  "def pos(self):\n        return tuple(self._pos)",
  "def pos(self, p):\n        assert len(p) == 2\n        self._pos = p",
  "def size(self):\n        return tuple(self._size)",
  "def size(self, s):\n        assert len(s) == 2\n        self._size = s",
  "def width(self):\n        return self.size[0]",
  "def width(self, w):\n        self.size = (w, self.size[1])",
  "def height(self):\n        return self.size[1]",
  "def height(self, h):\n        self.size = (self.size[0], h)",
  "def left(self):\n        return self.pos[0]",
  "def left(self, x):\n        self.size = (self.size[0] + (self.pos[0] - x), self.size[1])\n        self.pos = (x, self.pos[1])",
  "def right(self):\n        return self.pos[0] + self.size[0]",
  "def right(self, x):\n        self.size = (x - self.pos[0], self.size[1])",
  "def bottom(self):\n        return self.pos[1]",
  "def bottom(self, y):\n        self.size = (self.size[0], self.size[1] + (self.pos[1] - y))\n        self.pos = (self.pos[0], y)",
  "def top(self):\n        return self.pos[1] + self.size[1]",
  "def top(self, y):\n        self.size = (self.size[0], y - self.pos[1])",
  "def center(self):\n        return (self.pos[0] + self.size[0] * 0.5,\n                self.pos[1] + self.size[1] * 0.5)",
  "def center(self, value):\n        delta_x = value[0] - self.center[0]\n        delta_y = value[1] - self.center[1]\n        self.pos = (self.pos[0] + delta_x, self.pos[1] + delta_y)",
  "def padded(self, padding):\n        \"\"\"Return a new Rect padded (smaller) by padding on all sides\n\n        Parameters\n        ----------\n        padding : float\n            The padding.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The padded rectangle.\n        \"\"\"\n        return Rect(pos=(self.pos[0]+padding, self.pos[1]+padding),\n                    size=(self.size[0]-2*padding, self.size[1]-2*padding))",
  "def normalized(self):\n        \"\"\"Return a Rect covering the same area, but with height and width\n        guaranteed to be positive.\n        \"\"\"\n        return Rect(pos=(min(self.left, self.right),\n                         min(self.top, self.bottom)),\n                    size=(abs(self.width), abs(self.height)))",
  "def flipped(self, x=False, y=True):\n        \"\"\"Return a Rect with the same bounds but with axes inverted\n\n        Parameters\n        ----------\n        x : bool\n            Flip the X axis.\n        y : bool\n            Flip the Y axis.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The flipped rectangle.\n        \"\"\"\n        pos = list(self.pos)\n        size = list(self.size)\n        for i, flip in enumerate((x, y)):\n            if flip:\n                pos[i] += size[i]\n                size[i] *= -1\n        return Rect(pos, size)",
  "def __eq__(self, r):\n        if not isinstance(r, Rect):\n            return False\n        return (np.all(np.equal(r.pos, self.pos)) and\n                np.all(np.equal(r.size, self.size)))",
  "def __add__(self, a):\n        \"\"\"Return this Rect translated by *a*.\"\"\"\n        return self._transform_out(self._transform_in()[:, :2] + a[:2])",
  "def contains(self, x, y):\n        \"\"\"Query if the rectangle contains points\n\n        Parameters\n        ----------\n        x : float\n            X coordinate.\n        y : float\n            Y coordinate.\n\n        Returns\n        -------\n        contains : bool\n            True if the point is within the rectangle.\n        \"\"\"\n        return (x >= self.left and x <= self.right and\n                y >= self.bottom and y <= self.top)",
  "def __repr__(self):\n        return \"<Rect (%g, %g) (%g, %g)>\" % (self.pos + self.size)",
  "def _transform_in(self):\n        \"\"\"Return array of coordinates that can be mapped by Transform\n        classes.\n        \"\"\"\n        return np.array([\n            [self.left, self.bottom, 0, 1],\n            [self.right, self.top, 0, 1]])",
  "def _transform_out(self, coords):\n        \"\"\"Return a new Rect from coordinates mapped after _transform_in().\"\"\"\n        return Rect(pos=coords[0, :2], size=coords[1, :2]-coords[0, :2])",
  "class DebugTriangulation(Triangulation):\n    \"\"\"Visualize triangulation process stepwise to aid in debugging.\n\n    *interval* specifies the diration to wait before drawing each update in\n    the triangulation procedure. Negative values cause the display to wait\n    until the user clicks on the window for each update.\n\n    *skip* causes the display to immediately process the first N events\n    before pausing.\n    \"\"\"\n\n    def __init__(self, pts, edges, interval=0.01, skip=0):\n        self.interval = interval\n        self.iteration = 0\n        self.skip = skip \n\n        Triangulation.__init__(self, pts, edges)\n\n        # visual #debugging: draw edges, front, triangles\n        self.win = pg.plot()\n        self.graph = pg.GraphItem(pos=pts.copy(), adj=edges.copy(), \n                                  pen={'width': 3, 'color': (0, 100, 0)})\n        self.win.addItem(self.graph)\n        self.front_line = pg.PlotCurveItem(pen={'width': 2, \n                                                'dash': [5, 5], \n                                                'color': 'y'})\n        self.win.addItem(self.front_line)\n        self.tri_shapes = {}\n\n        self.nextStep = False\n        self.win.scene().sigMouseClicked.connect(self.mouseClicked)\n\n    def mouseClicked(self):\n        self.nextStep = True\n\n    def draw_state(self):\n        global app\n        print(\"State %s\" % self.iteration)\n        self.iteration += 1\n        if self.iteration <= self.skip:\n            return\n\n        front_pts = self.pts[np.array(self.front)]\n        self.front_line.setData(front_pts[:, 0], front_pts[:, 1])\n        self.graph.setData(pos=self.pts, adj=self.edges) \n\n        # Auto-advance on timer\n        if self.interval < 0:\n            # Advance once per click\n            while True:\n                app.processEvents()\n                time.sleep(0.01)\n                if self.nextStep:\n                    self.nextStep = False\n                    break\n        else:\n            # sleep, but keep ui responsive\n            for i in range(int(self.interval / 0.01)):\n                app.processEvents()\n                time.sleep(0.01)\n\n    def draw_tri(self, tri, source=None):\n        # assign triangle color based on the source that generated it\n        color = {\n            None: (0, 255, 255, 50),\n            'smooth1': (0, 255, 0, 50),\n            'fill_hull': (255, 255, 0, 50),\n            'edge_event': (100, 100, 255, 100),\n        }[source]\n\n        tpts = self.pts[np.array(tri)]\n        path = pg.arrayToQPath(tpts[:, 0], tpts[:, 1])\n        shape = pg.QtGui.QGraphicsPathItem(path)\n        shape.setPen(pg.mkPen(255, 255, 255, 100))\n        brush = pg.mkBrush(color)\n        shape.setBrush(brush)\n        self.win.addItem(shape)\n        self.tri_shapes[tri] = shape\n        self.draw_state()\n\n    def undraw_tri(self, tri):\n        shape = self.tri_shapes.pop(tri)\n        self.win.removeItem(shape)\n        self.draw_state()\n\n    def add_tri(self, *args, **kwargs):\n        Triangulation._add_tri(self, *args, **kwargs)\n        self.draw_tri(list(self.tris.keys())[-1], \n                      source=kwargs.get('source', None))\n\n    def remove_tri(self, *args, **kwargs):\n        k = Triangulation._remove_tri(self, *args, **kwargs)\n        self.undraw_tri(k)\n\n    def edge_event(self, *args, **kwargs):\n        self.draw_state()\n        Triangulation._edge_event(self, *args, **kwargs)\n        self.draw_state()",
  "def __init__(self, pts, edges, interval=0.01, skip=0):\n        self.interval = interval\n        self.iteration = 0\n        self.skip = skip \n\n        Triangulation.__init__(self, pts, edges)\n\n        # visual #debugging: draw edges, front, triangles\n        self.win = pg.plot()\n        self.graph = pg.GraphItem(pos=pts.copy(), adj=edges.copy(), \n                                  pen={'width': 3, 'color': (0, 100, 0)})\n        self.win.addItem(self.graph)\n        self.front_line = pg.PlotCurveItem(pen={'width': 2, \n                                                'dash': [5, 5], \n                                                'color': 'y'})\n        self.win.addItem(self.front_line)\n        self.tri_shapes = {}\n\n        self.nextStep = False\n        self.win.scene().sigMouseClicked.connect(self.mouseClicked)",
  "def mouseClicked(self):\n        self.nextStep = True",
  "def draw_state(self):\n        global app\n        print(\"State %s\" % self.iteration)\n        self.iteration += 1\n        if self.iteration <= self.skip:\n            return\n\n        front_pts = self.pts[np.array(self.front)]\n        self.front_line.setData(front_pts[:, 0], front_pts[:, 1])\n        self.graph.setData(pos=self.pts, adj=self.edges) \n\n        # Auto-advance on timer\n        if self.interval < 0:\n            # Advance once per click\n            while True:\n                app.processEvents()\n                time.sleep(0.01)\n                if self.nextStep:\n                    self.nextStep = False\n                    break\n        else:\n            # sleep, but keep ui responsive\n            for i in range(int(self.interval / 0.01)):\n                app.processEvents()\n                time.sleep(0.01)",
  "def draw_tri(self, tri, source=None):\n        # assign triangle color based on the source that generated it\n        color = {\n            None: (0, 255, 255, 50),\n            'smooth1': (0, 255, 0, 50),\n            'fill_hull': (255, 255, 0, 50),\n            'edge_event': (100, 100, 255, 100),\n        }[source]\n\n        tpts = self.pts[np.array(tri)]\n        path = pg.arrayToQPath(tpts[:, 0], tpts[:, 1])\n        shape = pg.QtGui.QGraphicsPathItem(path)\n        shape.setPen(pg.mkPen(255, 255, 255, 100))\n        brush = pg.mkBrush(color)\n        shape.setBrush(brush)\n        self.win.addItem(shape)\n        self.tri_shapes[tri] = shape\n        self.draw_state()",
  "def undraw_tri(self, tri):\n        shape = self.tri_shapes.pop(tri)\n        self.win.removeItem(shape)\n        self.draw_state()",
  "def add_tri(self, *args, **kwargs):\n        Triangulation._add_tri(self, *args, **kwargs)\n        self.draw_tri(list(self.tris.keys())[-1], \n                      source=kwargs.get('source', None))",
  "def remove_tri(self, *args, **kwargs):\n        k = Triangulation._remove_tri(self, *args, **kwargs)\n        self.undraw_tri(k)",
  "def edge_event(self, *args, **kwargs):\n        self.draw_state()\n        Triangulation._edge_event(self, *args, **kwargs)\n        self.draw_state()",
  "def deleteBuffer(buffer):\n    # --- gl es\n    n = 1  \n    buffers = (ctypes.c_uint*n)(buffer)  \n    ()  \n    # --- pyopengl\n    GL.glDeleteBuffers(1, [buffer])",
  "def deleteFramebuffer(framebuffer):\n    # --- gl es\n    n = 1  \n    framebuffers = (ctypes.c_uint*n)(framebuffer)  \n    ()\n    # --- pyopengl\n    FBO.glDeleteFramebuffers(1, [framebuffer])",
  "def deleteRenderbuffer(renderbuffer):\n    # --- gl es\n    n = 1  \n    renderbuffers = (ctypes.c_uint*n)(renderbuffer)  \n    ()\n    # --- pyopengl\n    FBO.glDeleteRenderbuffers(1, [renderbuffer])",
  "def deleteTexture(texture):\n    # --- gl es\n    n = 1  \n    textures = (ctypes.c_uint*n)(texture)  \n    ()\n    # --- pyopengl\n    GL.glDeleteTextures([texture])",
  "def createBuffer():\n    # --- gl es\n    n = 1\n    buffers = (ctypes.c_uint*n)()\n    ()  \n    return buffers[0]\n    # --- pyopengl\n    return GL.glGenBuffers(1)\n    # --- mock\n    return 1",
  "def createFramebuffer():\n    # --- gl es\n    n = 1\n    framebuffers = (ctypes.c_uint*n)()\n    ()\n    return framebuffers[0]\n    # --- pyopengl\n    return FBO.glGenFramebuffers(1)\n    # --- mock\n    return 1",
  "def createRenderbuffer():\n    # --- gl es\n    n = 1\n    renderbuffers = (ctypes.c_uint*n)()\n    ()\n    return renderbuffers[0]\n    # --- pyopengl\n    return FBO.glGenRenderbuffers(1)\n    # --- mock\n    return 1",
  "def createTexture():\n    # --- gl es\n    n = 1\n    textures = (ctypes.c_uint*n)()\n    ()\n    return textures[0]\n    # --- pyopengl\n    return GL.glGenTextures(1)\n    # --- mock\n    return 1",
  "def texImage2D(target, level, internalformat, format, type, pixels):\n    border = 0\n    # --- gl es\n    if isinstance(pixels, (tuple, list)):\n        height, width = pixels\n        pixels = ctypes.c_void_p(0)\n        pixels = None\n    else:\n        if not pixels.flags['C_CONTIGUOUS']:\n            pixels = pixels.copy('C')\n        pixels_ = pixels\n        pixels = pixels_.ctypes.data\n        height, width = pixels_.shape[:2]\n    ()\n    # --- pyopengl\n    if isinstance(pixels, (tuple, list)):\n        height, width = pixels\n        pixels = None\n    else:\n        height, width = pixels.shape[:2]\n    GL.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)",
  "def texSubImage2D(target, level, xoffset, yoffset, format, type, pixels):\n    # --- gl es\n    if not pixels.flags['C_CONTIGUOUS']:\n        pixels = pixels.copy('C')\n    pixels_ = pixels\n    pixels = pixels_.ctypes.data\n    height, width = pixels_.shape[:2]\n    ()\n    # --- pyopengl\n    height, width = pixels.shape[:2]\n    GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)",
  "def readPixels(x, y, width, height, format, type):\n    # --- es\n    # GL_ALPHA, GL_RGB, GL_RGBA\n    t = {6406:1, 6407:3, 6408:4}[format]\n    # --- gl mock\n    # GL_ALPHA, GL_RGB, GL_RGBA, GL_DEPTH_COMPONENT\n    t = {6406:1, 6407:3, 6408:4, 6402:1}[format]\n    # --- gl es mock\n    # GL_UNSIGNED_BYTE, GL_FLOAT\n    nb = {5121:1, 5126:4}[type]\n    size = int(width*height*t*nb)\n    # --- gl es\n    pixels = ctypes.create_string_buffer(size)\n    ()\n    return pixels[:]\n    # --- mock\n    return size * b'\\x00'",
  "def compressedTexImage2D(target, level, internalformat, width, height, border=0, data=None):\n    # border = 0  # set in args\n    # --- gl es\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    ()\n    # --- pyopengl\n    size = data.size\n    GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, size, data)",
  "def compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data):\n    # --- gl es\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.size\n    data = data_.ctypes.data\n    ()\n    # --- pyopengl\n    size = data.size\n    GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, size, data)",
  "def bufferData(target, data, usage):\n    \"\"\"Data can be numpy array or the size of data to allocate.\"\"\"\n    # --- gl es\n    if isinstance(data, int):\n        size = data\n        data = ctypes.c_voidp(0)\n    else:\n        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:\n            data = data.copy('C')\n        data_ = data\n        size = data_.nbytes\n        data = data_.ctypes.data\n    ()\n    # --- pyopengl\n    if isinstance(data, int):\n        size = data\n        data = None\n    else:\n        size = data.nbytes\n    GL.glBufferData(target, size, data, usage)",
  "def bufferSubData(target, offset, data):\n    # --- gl es\n    if not data.flags['C_CONTIGUOUS']:\n        data = data.copy('C')\n    data_ = data\n    size = data_.nbytes\n    data = data_.ctypes.data\n    ()\n    # --- pyopengl\n    size = data.nbytes\n    GL.glBufferSubData(target, offset, size, data)",
  "def drawElements(mode, count, type, offset):\n    # --- gl es\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n    indices = offset\n    ()\n    # --- pyopengl\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    ()",
  "def vertexAttribPointer(indx, size, type, normalized, stride, offset):\n    # --- gl es\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, ctypes.c_void_p):\n        pass\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    else:\n        if not offset.flags['C_CONTIGUOUS']:\n            offset = offset.copy('C')\n        offset_ = offset\n        offset = offset.ctypes.data\n        # We need to ensure that the data exists at draw time :(\n        # PyOpenGL does this too\n        key = '_vert_attr_'+str(indx)\n        setattr(glVertexAttribPointer, key, offset_)\n    ptr = offset\n    ()\n    # --- pyopengl\n    if offset is None:\n        offset = ctypes.c_void_p(0)\n    elif isinstance(offset, (int, ctypes.c_int)):\n        offset = ctypes.c_void_p(int(offset))\n    ()",
  "def bindAttribLocation(program, index, name):\n    # --- gl es\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    ()\n    # --- pyopengl\n    name = name.encode('utf-8')\n    ()",
  "def shaderSource(shader, source):\n    # Some implementation do not like getting a list of single chars\n    if isinstance(source, (tuple, list)):\n        strings = [s for s in source]\n    else:\n        strings = [source]\n    # --- gl es\n    count = len(strings)  \n    string = (ctypes.c_char_p*count)(*[s.encode('utf-8') for s in strings])  \n    length = (ctypes.c_int*count)(*[len(s) for s in strings])  \n    ()\n    # --- pyopengl\n    GL.glShaderSource(shader, strings)",
  "def _getBooleanv(pname):\n    # --- gl es\n    params = (ctypes.c_bool*1)()\n    ()\n    return params[0]",
  "def _getIntegerv(pname):\n    # --- gl es\n    n = 16\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*n)(*[d for i in range(n)])\n    ()\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def _getFloatv(pname):\n    # --- gl es\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    ()\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def getParameter(pname):\n    if pname in [33902, 33901, 32773, 3106, 2931, 2928, \n                 2849, 32824, 10752, 32938]:\n        # GL_ALIASED_LINE_WIDTH_RANGE GL_ALIASED_POINT_SIZE_RANGE\n        # GL_BLEND_COLOR GL_COLOR_CLEAR_VALUE GL_DEPTH_CLEAR_VALUE\n        # GL_DEPTH_RANGE GL_LINE_WIDTH GL_POLYGON_OFFSET_FACTOR\n        # GL_POLYGON_OFFSET_UNITS GL_SAMPLE_COVERAGE_VALUE\n        # --- gl es\n        return _glGetFloatv(pname)\n        # --- pyopengl\n        return GL.glGetFloatv(pname)\n        # /---\n    elif pname in [7936, 7937, 7938, 35724, 7939]:\n        # GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, \n        # GL_EXTENSIONS are strings\n        pass  # string handled below\n    else:\n        # --- gl es\n        return _glGetIntegerv(pname)\n        # --- pyopengl\n        return GL.glGetIntegerv(pname)\n        # /---\n    # --- gl es\n    name = pname\n    ()\n    return ctypes.string_at(res).decode('utf-8') if res else ''\n    # --- pyopengl\n    res = GL.glGetString(pname)\n    return res.decode('utf-8')",
  "def getUniform(program, location):\n    # --- gl es\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    ()\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)\n    # --- pyopengl\n    n = 16\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    GL.glGetUniformfv(program, location, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def getVertexAttrib(index, pname):\n    # --- gl es\n    n = 4\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    ()\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)\n    # --- pyopengl\n    # From PyOpenGL v3.1.0 the glGetVertexAttribfv(index, pname) does\n    # work, but it always returns 4 values, with zeros in the empty\n    # spaces. We have no way to tell whether they are empty or genuine\n    # zeros. Fortunately, pyopengl also supports the old syntax.\n    n = 4\n    d = float('Inf')\n    params = (ctypes.c_float*n)(*[d for i in range(n)])\n    GL.glGetVertexAttribfv(index, pname, params)\n    params = [p for p in params if p!=d]\n    if len(params) == 1:\n        return params[0]\n    else:\n        return tuple(params)",
  "def getTexParameter(target, pname):\n    # --- gl es\n    d = float('Inf')\n    params = (ctypes.c_float*1)(d)\n    ()\n    return params[0]",
  "def getActiveAttrib(program, index):\n    # --- gl es pyopengl\n    bufsize = 256\n    # --- gl es\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    # --- gl es\n    ()\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]\n    # --- pyopengl\n    name, size, type = GL.glGetActiveAttrib(program, index, bufSize=bufsize)\n    return name.decode('utf-8'), size, type\n    # --- mock\n    return 'mock_val', 1, 5126",
  "def getVertexAttribOffset(index, pname):\n    # --- gl es\n    pointer = (ctypes.c_void_p*1)()\n    ()\n    return pointer[0] or 0\n    # --- pyopengl\n    try:  # maybe the fixed it\n        ()\n    except TypeError:\n        pointer = (ctypes.c_void_p*1)()\n        GL.glGetVertexAttribPointerv(index, pname, pointer)\n        return pointer[0] or 0\n    # --- mock\n    return 0",
  "def getActiveUniform(program, index):\n    # --- gl es\n    bufsize = 256\n    length = (ctypes.c_int*1)()\n    size = (ctypes.c_int*1)()\n    type = (ctypes.c_uint*1)()\n    name = ctypes.create_string_buffer(bufsize)\n    ()\n    name = name[:length[0]].decode('utf-8')\n    return name, size[0], type[0]\n    # --- pyopengl\n    name, size, type = GL.glGetActiveUniform(program, index)\n    return name.decode('utf-8'), size, type",
  "def getAttachedShaders(program):\n    # --- gl es\n    maxcount = 256\n    count = (ctypes.c_int*1)()\n    shaders = (ctypes.c_uint*maxcount)()\n    ()\n    return tuple(shaders[:count[0]])",
  "def getAttribLocation(program, name):\n    # --- gl es\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    ()\n    return res\n    # --- pyopengl\n    name = name.encode('utf-8')\n    ()",
  "def getUniformLocation(program, name):\n    # --- gl es\n    name = ctypes.c_char_p(name.encode('utf-8'))\n    ()\n    return res\n    # --- pyopengl\n    name = name.encode('utf-8')\n    ()",
  "def getProgramInfoLog(program):\n    # --- gl es\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    ()\n    return infolog[:length[0]].decode('utf-8')\n    # --- pyopengl\n    res = GL.glGetProgramInfoLog(program)\n    return res.decode('utf-8') if isinstance(res, bytes) else res",
  "def getShaderInfoLog(shader):\n    # --- gl es\n    bufsize = 1024\n    length = (ctypes.c_int*1)()\n    infolog = ctypes.create_string_buffer(bufsize)\n    ()\n    return infolog[:length[0]].decode('utf-8')\n    # --- pyopengl\n    res = GL.glGetShaderInfoLog(shader)\n    return res.decode('utf-8') if isinstance(res, bytes) else res",
  "def getProgramParameter(program, pname):\n    # --- gl es\n    params = (ctypes.c_int*1)()\n    ()\n    return params[0]",
  "def getShaderParameter(shader, pname):\n    # --- gl es\n    params = (ctypes.c_int*1)()\n    ()\n    return params[0]",
  "def getShaderPrecisionFormat(shadertype, precisiontype):\n    # --- gl es\n    range = (ctypes.c_int*1)()\n    precision = (ctypes.c_int*1)()\n    ()\n    return range[0], precision[0]",
  "def getShaderSource(shader):\n    # --- gl es\n    bufsize = 1024*1024\n    length = (ctypes.c_int*1)()\n    source = (ctypes.c_char*bufsize)()\n    ()\n    return source.value[:length[0]].decode('utf-8')\n    # --- pyopengl\n    res = GL.glGetShaderSource(shader)\n    return res.decode('utf-8')",
  "def getBufferParameter(target, pname):\n    # --- gl es\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    ()\n    return params[0]",
  "def getFramebufferAttachmentParameter(target, attachment, pname):\n    # --- gl es\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    ()\n    return params[0]\n    # --- pyopengl\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    FBO.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)\n    return params[0]",
  "def getRenderbufferParameter(target, pname):\n    # --- gl es\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    ()\n    return params[0]\n    # --- pyopengl\n    d = -2**31  # smallest 32bit integer\n    params = (ctypes.c_int*1)(d)\n    FBO.glGetRenderbufferParameteriv(target, pname, params)\n    return params[0]",
  "class FunctionAnnotation:\n    def __init__(self, name, args, output):\n        self.name = name\n        self.args = args\n        self.output = output\n        self.lines = []  # (line, comment) tuples\n    \n    def __repr__(self):\n        return '<FunctionAnnotation for %s>' % self.name\n        \n    def get_lines(self, call, backend):\n        \"\"\" Get the lines for this function based on the given backend. \n        The given API call is inserted at the correct location.\n        \"\"\"\n        if backend is None:\n            raise RuntimeError(\"Backend must be specified!\")\n        backend_selector = (backend, )  # first lines are for all backends\n        lines = []\n        for line in self.lines:\n            if line.lstrip().startswith('# ---'):\n                backend_selector = line.strip().split(' ')\n                continue\n            if line.lstrip().startswith('# /---'):\n                backend_selector = backend\n                continue\n            if backend in backend_selector:\n                if line.strip() == '()':\n                    indent = line.split('(')[0][4:]\n                    line = indent + call\n                lines.append(line)\n        return lines\n    \n    def is_arg_set(self, name):\n        \"\"\"Get whether a given variable name is set.\n\n        This allows checking whether a variable that is an input to the C\n        function is not an input for the Python function, and may be an output.\n\n        \"\"\"\n        needle = '%s =' % name\n        for line, comment in self.lines:\n            if line.startswith(needle):\n                return True\n        else:\n            return False",
  "def parse_anotations():\n    \"\"\"Parse this annotations file and produce a dictionary of FunctionAnnotation objects.\"\"\"\n    functions = {}\n    function = None\n    \n    for line in open(__file__, 'rt').readlines():\n        # Stop?\n        if '='*40 in line:\n            break\n        \n        if line.startswith('def '):\n            name = line.split(' ')[1].split('(')[0]\n            args = line.split('(')[1].split(')')[0].split(', ')\n            args = [arg for arg in args if arg]\n            out = line.partition('->')[2].strip()\n            function = FunctionAnnotation(name, args, out)\n            functions[name] = function\n            continue\n        elif not function:\n            continue\n        \n        # Add line\n        line = line.rstrip()\n        indent = len(line) - len(line.strip())\n        if line.strip() and indent >= 4:\n            function.lines.append(line)\n\n    return functions",
  "def __init__(self, name, args, output):\n        self.name = name\n        self.args = args\n        self.output = output\n        self.lines = []",
  "def __repr__(self):\n        return '<FunctionAnnotation for %s>' % self.name",
  "def get_lines(self, call, backend):\n        \"\"\" Get the lines for this function based on the given backend. \n        The given API call is inserted at the correct location.\n        \"\"\"\n        if backend is None:\n            raise RuntimeError(\"Backend must be specified!\")\n        backend_selector = (backend, )  # first lines are for all backends\n        lines = []\n        for line in self.lines:\n            if line.lstrip().startswith('# ---'):\n                backend_selector = line.strip().split(' ')\n                continue\n            if line.lstrip().startswith('# /---'):\n                backend_selector = backend\n                continue\n            if backend in backend_selector:\n                if line.strip() == '()':\n                    indent = line.split('(')[0][4:]\n                    line = indent + call\n                lines.append(line)\n        return lines",
  "def is_arg_set(self, name):\n        \"\"\"Get whether a given variable name is set.\n\n        This allows checking whether a variable that is an input to the C\n        function is not an input for the Python function, and may be an output.\n\n        \"\"\"\n        needle = '%s =' % name\n        for line, comment in self.lines:\n            if line.startswith(needle):\n                return True\n        else:\n            return False",
  "def getwords(line):\n    \"\"\"Get words on a line.\"\"\"\n    line = line.replace(\"\\t\", \" \").strip()\n    return [w for w in line.split(\" \") if w]",
  "class Parser:\n    \"\"\"Class to parse header files.\n\n    It can deal with gl2.h and webgl.idl,\n    as well as some desktop OpenGL header files. It produces a list of\n    ConstantDefinition objects and FunctionDefinition objects, which can\n    be accessed via a dict.\n\n    \"\"\"\n\n    def __init__(self, header_file, parse_now=True):\n        # Get filenames for C and Py\n        self._c_fname = os.path.split(header_file)[1]\n\n        # Get absolute filenames\n        self._c_filename = header_file\n\n        # Init intermediate results\n        self._functionDefs = []\n        self._constantDefs = []\n\n        # Init output\n        self._functions = {}\n        self._constants = {}\n        # cache of constant values for constant aliases\n        self._constant_values = {}\n\n        # We are aware of the line number\n        self._linenr = 0\n\n        # Some stats\n        self.stat_types = set()\n\n        if parse_now:\n            self.parse()\n\n    def parse(self):\n        \"\"\"Parse the header file!\"\"\"\n        self._parse_constants_and_functions_from_file()\n\n        # Remove invalid defs\n        self._functionDefs = [d for d in self._functionDefs if d.isvalid]\n        self._constantDefs = [d for d in self._constantDefs if d.isvalid]\n\n        # Collect multipe similar functions in groups\n        self._functionDefs.sort(key=lambda x: x.glname)\n        keyDef = None\n        keyDefs = []\n        for funcDef in [f for f in self._functionDefs]:\n            # Check if we need a new keydef\n            if funcDef.extrachars:\n                # Create new keydef or use old one?\n                if keyDef and keyDef.glname == funcDef.keyname:\n                    pass  # Keep same keydef\n                else:\n                    keyDef = FunctionGroup.from_function_def(funcDef)\n                    keyDefs.append(keyDef)\n                # Add to group\n                keyDef.group.append(funcDef)\n        # Process function groups\n        for keyDef in keyDefs:\n            if len(keyDef.group) > 1:\n                self._functionDefs.append(keyDef)\n                for d in keyDef.group:\n                    self._functionDefs.remove(d)\n\n        # Sort constants and functions\n        self._functionDefs.sort(key=lambda x: x.glname)\n        self._constantDefs.sort(key=lambda x: x.glname)\n\n        # Get dicts\n        for definition in self._functionDefs:\n            self._functions[definition.shortname] = definition\n        for definition in self._constantDefs:\n            self._constants[definition.shortname] = definition\n\n        # Get some stats\n        for funcDef in self._functionDefs:\n            for arg in funcDef.args:\n                self.stat_types.add(arg.ctype)\n\n        # Show stats\n        # TODO: Remove iteration\n        n1 = len([d for d in self._constantDefs])\n        n2 = len([d for d in self._functionDefs])\n        n3 = len([d for d in self._functionDefs if d.group])\n        n4 = sum([len(d.group) for d in self._functionDefs if d.group])\n        print(\n            'Found %i constants and %i unique functions (%i groups contain %i functions)\").'\n            % (n1, n2, n3, n4)\n        )\n\n        print(\"C-types found in args:\", self.stat_types)\n\n    def _parse_constants_and_functions_from_file(self):\n        line_gen = self._get_nonblank_lines()\n        for line in line_gen:\n            if line.startswith((\"#define\", \"const GLenum\")):\n                const_def = ConstantDefinition(line)\n                const_def.parse_line(self._constant_values)\n                self._append_definition(const_def)\n            elif \"(\" in line:\n                while \")\" not in line:\n                    line += next(line_gen)\n                if line.endswith(\");\"):\n                    func_def = FunctionDefinition(line)\n                    func_def.parse_line()\n                    self._append_definition(func_def)\n\n    def _get_nonblank_lines(self):\n        with open(self._c_filename, \"rt\", encoding=\"utf-8\") as header_file:\n            for line in header_file:\n                line = line.strip()\n                if line:\n                    yield line\n                self._linenr += 1\n\n    def _append_definition(self, definition):\n        \"\"\"Add an output line. Can be multiple lines.\"\"\"\n        # Create comment\n        definition.comment = \"line %i of %s\" % (self._linenr, self._c_fname)\n        # Add to lists\n        if isinstance(definition, FunctionDefinition):\n            self._functionDefs.append(definition)\n        elif isinstance(definition, ConstantDefinition):\n            self._constantDefs.append(definition)\n\n    @property\n    def constant_names(self):\n        \"\"\"Sorted list of constant names.\"\"\"\n        return [d.shortname for d in self._constantDefs]\n\n    @property\n    def function_names(self):\n        \"\"\"Sorted list of function names.\"\"\"\n        return [d.shortname for d in self._functionDefs]\n\n    @property\n    def constants(self):\n        \"\"\"Dict with all the constants.\"\"\"\n        return self._constants\n\n    @property\n    def functions(self):\n        \"\"\"Dict witj all the functions.\"\"\"\n        return self._functions\n\n    def show_groups(self):\n        for d in self._functionDefs:\n            if isinstance(d.group, list):\n                print(d.keyname)\n                for d2 in d.group:\n                    print(\"  \", d2.glname)",
  "class Definition:\n    \"\"\"Abstract class to represent a constant or function definition.\"\"\"\n\n    def __init__(self, line):\n        self.line = line\n        self.isvalid = True\n        self.comment = \"\"\n        self.oname = \"\"  # original name\n        self.shortname = self.glname = \"\"  # short and long name\n\n    def parse_line(self):\n        # Do initial parsing of the incoming line (which may be multiline, actually)\n        raise NotImplementedError()\n\n    def _set_name(self, name):\n        # Store original name\n        self.oname = name\n        # Store plain name\n        if name.startswith(\"GL_\"):\n            name = name[3:]\n        elif name.startswith(\"gl\"):\n            name = name[2].lower() + name[3:]\n        self.shortname = name\n        # Store gl name\n        if name.upper() == name:\n            name = \"GL_\" + name\n        else:\n            name = \"gl\" + name[0].upper() + name[1:]\n        self.glname = name",
  "class ConstantDefinition(Definition):\n    def __init__(self, line):\n        self.value = None\n        super().__init__(line)\n\n    def parse_line(self, existing_constants):\n        \"\"\"Set cname and value attributes.\"\"\"\n        value = None\n        line = self.line.split(\"/*\", 1)[0]\n        args = getwords(line)[1:]\n        self.isvalid = False\n        if len(args) == 1:\n            pass\n        elif len(args) == 2:\n            # Set name\n            name, val = args\n            self.isvalid = bool(name)\n            self._set_name(name)\n            value = self._set_value_from_string(val, existing_constants)\n        elif \"=\" in args:\n            name, val = args[-3], args[-1]\n            self.isvalid = bool(name)\n            self._set_name(name)\n            value = self._set_value_from_string(val, existing_constants)\n        else:\n            print('Dont know what to do with \"%s\"' % line)\n\n        # For when this constant is reused to set another constant\n        if value is not None:\n            existing_constants[self.oname] = value\n        self.value = value\n\n    def _set_value_from_string(self, val, existing_constants):\n        # Set value\n        val = val.strip(\";\")\n        if val.startswith(\"0x\"):\n            value = int(val[2:].rstrip(\"ul\"), 16)\n        elif val[0] in \"0123456789\":\n            value = int(val)\n        elif val.startswith(\"'\"):\n            value = val\n        elif val in existing_constants:\n            value = existing_constants[val]\n        else:\n            print('Warning: Dont know what to do with \"%s\"' % val)\n            value = None\n        return value",
  "class FunctionDefinition(Definition):\n\n    SKIPTYPECHARS = \"if\"  # 'bsifd'\n    ALLSKIPCHARS = SKIPTYPECHARS + \"v1234\"\n\n    def __init__(self, line):\n        self.keyname = None\n        self.extrachars = None\n        self.group = None\n        self.cargs = []\n        self.args = []\n        super().__init__(line)\n\n    def parse_line(self):\n        \"\"\"Set cname, keyname, cargs attributes.\n        The list of args always has one entry and the first entry is always\n        the output (can be void).\n        \"\"\"\n        # Parse components\n        beforeBrace, args = self.line.split(\"(\", 1)\n        betweenBraces, _ = args.split(\")\", 1)\n        outs = getwords(beforeBrace)\n        prefix, name = outs[:-1], outs[-1]\n\n        # Store name\n        self._set_name(name)\n\n        # Possibly, this function belongs to a collection of similar functions,\n        # which we are going to replace with one function in Python.\n        self.keyname = self.glname.rstrip(\"v\").rstrip(self.SKIPTYPECHARS).rstrip(\"1234\")\n        self.extrachars = self.matchKeyName(self.keyname)\n\n        # If this is a list, this instance represents the group\n        # If this is True, this instance is in a group (but not the\n        # representative)\n        self.group = None\n\n        # Create list of Argument instances\n        self.cargs = [arg.strip() for arg in betweenBraces.split(\",\")]\n        self.args = []\n        # Set output arg\n        self.args.append(Argument(\" \".join(prefix), False))\n        # Parse input arguments,\n        for arg in self.cargs:\n            if arg and arg != \"void\":\n                self.args.append(Argument(arg))\n\n    def matchKeyName(self, keyname):\n        if self.glname.startswith(keyname):\n            extrachars = self.glname[len(keyname) :]\n            if all([(c in self.ALLSKIPCHARS) for c in extrachars]):\n                return extrachars",
  "class FunctionGroup(FunctionDefinition):\n    @classmethod\n    def from_function_def(cls, func_def):\n        keyDef = cls(func_def.line)\n        keyDef.parse_line()\n        keyDef._set_name(func_def.keyname)\n        return keyDef\n\n    def parse_line(self):\n        super().parse_line()\n        self.group = []",
  "class Argument:\n    def __init__(self, argAsString, cinput=True):\n        # Parse string\n        components = [c for c in argAsString.split(\" \") if c]\n        if len(components) == 1:\n            name = \"unknown_name\"\n            type = components[0]\n        else:\n            name = components[-1]\n            type = components[-2]\n            if \"const\" in type:\n                type = components[\n                    -3\n                ]  # glShaderSource has \"const GLchar* const* string\"\n        # Store stuff\n        self.orig = tuple(components)\n        self.name = name.lstrip(\"*\")\n        self.isptr = argAsString.count(\"*\")  # Number of stars\n        self.ctype = type.strip(\"*\") + \"*\" * self.isptr\n        # Status flags\n        self.cinput = cinput",
  "def __init__(self, header_file, parse_now=True):\n        # Get filenames for C and Py\n        self._c_fname = os.path.split(header_file)[1]\n\n        # Get absolute filenames\n        self._c_filename = header_file\n\n        # Init intermediate results\n        self._functionDefs = []\n        self._constantDefs = []\n\n        # Init output\n        self._functions = {}\n        self._constants = {}\n        # cache of constant values for constant aliases\n        self._constant_values = {}\n\n        # We are aware of the line number\n        self._linenr = 0\n\n        # Some stats\n        self.stat_types = set()\n\n        if parse_now:\n            self.parse()",
  "def parse(self):\n        \"\"\"Parse the header file!\"\"\"\n        self._parse_constants_and_functions_from_file()\n\n        # Remove invalid defs\n        self._functionDefs = [d for d in self._functionDefs if d.isvalid]\n        self._constantDefs = [d for d in self._constantDefs if d.isvalid]\n\n        # Collect multipe similar functions in groups\n        self._functionDefs.sort(key=lambda x: x.glname)\n        keyDef = None\n        keyDefs = []\n        for funcDef in [f for f in self._functionDefs]:\n            # Check if we need a new keydef\n            if funcDef.extrachars:\n                # Create new keydef or use old one?\n                if keyDef and keyDef.glname == funcDef.keyname:\n                    pass  # Keep same keydef\n                else:\n                    keyDef = FunctionGroup.from_function_def(funcDef)\n                    keyDefs.append(keyDef)\n                # Add to group\n                keyDef.group.append(funcDef)\n        # Process function groups\n        for keyDef in keyDefs:\n            if len(keyDef.group) > 1:\n                self._functionDefs.append(keyDef)\n                for d in keyDef.group:\n                    self._functionDefs.remove(d)\n\n        # Sort constants and functions\n        self._functionDefs.sort(key=lambda x: x.glname)\n        self._constantDefs.sort(key=lambda x: x.glname)\n\n        # Get dicts\n        for definition in self._functionDefs:\n            self._functions[definition.shortname] = definition\n        for definition in self._constantDefs:\n            self._constants[definition.shortname] = definition\n\n        # Get some stats\n        for funcDef in self._functionDefs:\n            for arg in funcDef.args:\n                self.stat_types.add(arg.ctype)\n\n        # Show stats\n        # TODO: Remove iteration\n        n1 = len([d for d in self._constantDefs])\n        n2 = len([d for d in self._functionDefs])\n        n3 = len([d for d in self._functionDefs if d.group])\n        n4 = sum([len(d.group) for d in self._functionDefs if d.group])\n        print(\n            'Found %i constants and %i unique functions (%i groups contain %i functions)\").'\n            % (n1, n2, n3, n4)\n        )\n\n        print(\"C-types found in args:\", self.stat_types)",
  "def _parse_constants_and_functions_from_file(self):\n        line_gen = self._get_nonblank_lines()\n        for line in line_gen:\n            if line.startswith((\"#define\", \"const GLenum\")):\n                const_def = ConstantDefinition(line)\n                const_def.parse_line(self._constant_values)\n                self._append_definition(const_def)\n            elif \"(\" in line:\n                while \")\" not in line:\n                    line += next(line_gen)\n                if line.endswith(\");\"):\n                    func_def = FunctionDefinition(line)\n                    func_def.parse_line()\n                    self._append_definition(func_def)",
  "def _get_nonblank_lines(self):\n        with open(self._c_filename, \"rt\", encoding=\"utf-8\") as header_file:\n            for line in header_file:\n                line = line.strip()\n                if line:\n                    yield line\n                self._linenr += 1",
  "def _append_definition(self, definition):\n        \"\"\"Add an output line. Can be multiple lines.\"\"\"\n        # Create comment\n        definition.comment = \"line %i of %s\" % (self._linenr, self._c_fname)\n        # Add to lists\n        if isinstance(definition, FunctionDefinition):\n            self._functionDefs.append(definition)\n        elif isinstance(definition, ConstantDefinition):\n            self._constantDefs.append(definition)",
  "def constant_names(self):\n        \"\"\"Sorted list of constant names.\"\"\"\n        return [d.shortname for d in self._constantDefs]",
  "def function_names(self):\n        \"\"\"Sorted list of function names.\"\"\"\n        return [d.shortname for d in self._functionDefs]",
  "def constants(self):\n        \"\"\"Dict with all the constants.\"\"\"\n        return self._constants",
  "def functions(self):\n        \"\"\"Dict witj all the functions.\"\"\"\n        return self._functions",
  "def show_groups(self):\n        for d in self._functionDefs:\n            if isinstance(d.group, list):\n                print(d.keyname)\n                for d2 in d.group:\n                    print(\"  \", d2.glname)",
  "def __init__(self, line):\n        self.line = line\n        self.isvalid = True\n        self.comment = \"\"\n        self.oname = \"\"  # original name\n        self.shortname = self.glname = \"\"",
  "def parse_line(self):\n        # Do initial parsing of the incoming line (which may be multiline, actually)\n        raise NotImplementedError()",
  "def _set_name(self, name):\n        # Store original name\n        self.oname = name\n        # Store plain name\n        if name.startswith(\"GL_\"):\n            name = name[3:]\n        elif name.startswith(\"gl\"):\n            name = name[2].lower() + name[3:]\n        self.shortname = name\n        # Store gl name\n        if name.upper() == name:\n            name = \"GL_\" + name\n        else:\n            name = \"gl\" + name[0].upper() + name[1:]\n        self.glname = name",
  "def __init__(self, line):\n        self.value = None\n        super().__init__(line)",
  "def parse_line(self, existing_constants):\n        \"\"\"Set cname and value attributes.\"\"\"\n        value = None\n        line = self.line.split(\"/*\", 1)[0]\n        args = getwords(line)[1:]\n        self.isvalid = False\n        if len(args) == 1:\n            pass\n        elif len(args) == 2:\n            # Set name\n            name, val = args\n            self.isvalid = bool(name)\n            self._set_name(name)\n            value = self._set_value_from_string(val, existing_constants)\n        elif \"=\" in args:\n            name, val = args[-3], args[-1]\n            self.isvalid = bool(name)\n            self._set_name(name)\n            value = self._set_value_from_string(val, existing_constants)\n        else:\n            print('Dont know what to do with \"%s\"' % line)\n\n        # For when this constant is reused to set another constant\n        if value is not None:\n            existing_constants[self.oname] = value\n        self.value = value",
  "def _set_value_from_string(self, val, existing_constants):\n        # Set value\n        val = val.strip(\";\")\n        if val.startswith(\"0x\"):\n            value = int(val[2:].rstrip(\"ul\"), 16)\n        elif val[0] in \"0123456789\":\n            value = int(val)\n        elif val.startswith(\"'\"):\n            value = val\n        elif val in existing_constants:\n            value = existing_constants[val]\n        else:\n            print('Warning: Dont know what to do with \"%s\"' % val)\n            value = None\n        return value",
  "def __init__(self, line):\n        self.keyname = None\n        self.extrachars = None\n        self.group = None\n        self.cargs = []\n        self.args = []\n        super().__init__(line)",
  "def parse_line(self):\n        \"\"\"Set cname, keyname, cargs attributes.\n        The list of args always has one entry and the first entry is always\n        the output (can be void).\n        \"\"\"\n        # Parse components\n        beforeBrace, args = self.line.split(\"(\", 1)\n        betweenBraces, _ = args.split(\")\", 1)\n        outs = getwords(beforeBrace)\n        prefix, name = outs[:-1], outs[-1]\n\n        # Store name\n        self._set_name(name)\n\n        # Possibly, this function belongs to a collection of similar functions,\n        # which we are going to replace with one function in Python.\n        self.keyname = self.glname.rstrip(\"v\").rstrip(self.SKIPTYPECHARS).rstrip(\"1234\")\n        self.extrachars = self.matchKeyName(self.keyname)\n\n        # If this is a list, this instance represents the group\n        # If this is True, this instance is in a group (but not the\n        # representative)\n        self.group = None\n\n        # Create list of Argument instances\n        self.cargs = [arg.strip() for arg in betweenBraces.split(\",\")]\n        self.args = []\n        # Set output arg\n        self.args.append(Argument(\" \".join(prefix), False))\n        # Parse input arguments,\n        for arg in self.cargs:\n            if arg and arg != \"void\":\n                self.args.append(Argument(arg))",
  "def matchKeyName(self, keyname):\n        if self.glname.startswith(keyname):\n            extrachars = self.glname[len(keyname) :]\n            if all([(c in self.ALLSKIPCHARS) for c in extrachars]):\n                return extrachars",
  "def from_function_def(cls, func_def):\n        keyDef = cls(func_def.line)\n        keyDef.parse_line()\n        keyDef._set_name(func_def.keyname)\n        return keyDef",
  "def parse_line(self):\n        super().parse_line()\n        self.group = []",
  "def __init__(self, argAsString, cinput=True):\n        # Parse string\n        components = [c for c in argAsString.split(\" \") if c]\n        if len(components) == 1:\n            name = \"unknown_name\"\n            type = components[0]\n        else:\n            name = components[-1]\n            type = components[-2]\n            if \"const\" in type:\n                type = components[\n                    -3\n                ]  # glShaderSource has \"const GLchar* const* string\"\n        # Store stuff\n        self.orig = tuple(components)\n        self.name = name.lstrip(\"*\")\n        self.isptr = argAsString.count(\"*\")  # Number of stars\n        self.ctype = type.strip(\"*\") + \"*\" * self.isptr\n        # Status flags\n        self.cinput = cinput",
  "def create_parsers():\n    # Create a parser for gl2 and es2\n    parser1 = headerparser.Parser(os.path.join(THISDIR, \"headers\", \"gl2.h\"))\n    parser2 = headerparser.Parser(os.path.join(THISDIR, \"headers\", \"webgl.idl\"))\n\n    ## Check constants and generate API module\n\n    # Get names\n    names1 = set(parser1.constant_names)\n    names2 = set(parser2.constant_names)\n\n    # Check names correspondence\n    if names1 == names2:\n        print(\"Constants in gl2 and webgl are equal\")\n    else:\n        print(\"===== Extra names in gl2 =====\")\n        print(\", \".join(names1.difference(names2)))\n        print(\"===== Extra names in webgl =====\")\n        print(\", \".join(names2.difference(names1)))\n        print(\"===========\")\n\n    # Test value correspondence\n    superset = names1.intersection(names2)\n    #\n    constants = {}\n    for c1 in parser1.constants.values():\n        if c1.shortname in superset:\n            constants[c1.shortname] = c1.value\n    #\n    assert len(constants) == len(superset)\n    #\n    for c2 in parser2.constants.values():\n        if c2.shortname in constants:\n            assert c2.value == constants[c2.shortname]\n    print(\"Hooray! All constants that occur in both namespaces have equal values.\")\n\n    return parser1, parser2",
  "def create_constants_module(constant_definitions: list[headerparser.ConstantDefinition],\n                            extension: bool = False) -> None:\n    lines = [PREAMBLE % \"Constants for OpenGL ES 2.0.\", DEFINE_ENUM, \"\"]\n\n    # For extensions, we only take the OES ones, and remove the OES\n    if extension:\n        renamed_defs = []\n        for c in constant_definitions:\n            if \"OES\" in c.oname:\n                c.oname = c.oname.replace(\"OES\", \"\")\n                c.oname = c.oname.replace(\"__\", \"_\").strip(\"_\")\n                renamed_defs.append(c)\n        constant_definitions = renamed_defs\n\n    # Insert constants\n    for c in sorted(constant_definitions, key=lambda x: x.oname):\n        if isinstance(c.value, int):\n            lines.append(\"%s = Enum(%r, %r)\" % (c.oname, c.oname, c.value))\n        else:\n            lines.append(\"%s = %r\" % (c.oname, c.value))\n    lines.append(\"\")\n\n    lines.append(DEFINE_CONST_MAP)\n\n    # Write the file\n    fname = \"_constants_ext.py\" if extension else \"_constants.py\"\n    with open(os.path.join(GLDIR, fname), \"wb\") as f:\n        f.write((\"\\n\".join(lines)).encode(\"utf-8\"))\n    print(\"wrote %s\" % fname)",
  "def apiname(funcname):\n    \"\"\"Define what name the API uses, the short or the gl version.\"\"\"\n    if funcname.startswith(\"gl\"):\n        return funcname\n    else:\n        if funcname.startswith(\"_\"):\n            return \"_gl\" + funcname[1].upper() + funcname[2:]\n        else:\n            return \"gl\" + funcname[0].upper() + funcname[1:]",
  "class FunctionDescription:\n    def __init__(self, name, es2func, wglfunc, annfunc):\n        self.name = name\n        self.apiname = apiname(name)\n        self.es2 = es2func\n        self.wgl = wglfunc\n        self.ann = annfunc\n        self.args = []",
  "class ApiGenerator:\n    \"\"\"Base API generator class. We derive several subclasses to implement\n    the different backends.\n    \"\"\"\n\n    backend_name = None\n\n    DESCRIPTION = \"GL API X\"\n    PREAMBLE = \"\"\n\n    def __init__(self):\n        self.lines = []\n        self.functions_auto = set()\n        self.functions_anno = set()\n        self.functions_todo = set()\n\n    def save(self):\n        # Remove too many whitespace\n        text = \"\\n\".join(self.lines) + \"\\n\"\n        for i in range(10):\n            text = text.replace(\"\\n\\n\\n\\n\", \"\\n\\n\\n\")\n        # Write\n        with open(self.filename, \"wb\") as f:\n            f.write((PREAMBLE % self.DESCRIPTION).encode(\"utf-8\"))\n            for line in self.PREAMBLE.splitlines():\n                f.write(line[4:].encode(\"utf-8\") + b\"\\n\")\n            f.write(b\"\\n\")\n            f.write(text.encode(\"utf-8\"))\n\n    def add_functions(self, all_functions):\n        for func_description in all_functions:\n            self.add_function(func_description)\n\n    def add_function(self, des: FunctionDescription):\n        if des.es2.group:\n            if des.name.startswith(\"get\"):\n                assert len(des.es2.group) == 2  # vi and fv\n                des.es2 = des.es2.group[0]  # f comes before 1\n                self._add_function(des)\n            else:\n                self._add_function_group(des)\n        else:\n            self._add_function(des)\n        self.lines.append(\"\\n\")  # two lines between each function\n\n    def _add_function_group(self, des: FunctionDescription) -> tuple[set, set, set]:\n        lines = self.lines\n        handled = True\n\n        # Create map to es2 function objects\n        es2funcs = {}\n        for f in des.es2.group:\n            cname = f.shortname\n            es2funcs[cname] = f\n\n        if des.name == \"uniform\":\n            for t in (\"float\", \"int\"):\n                for i in (1, 2, 3, 4):\n                    args = \", \".join([\"v%i\" % j for j in range(1, i + 1)])\n                    cname = \"uniform%i%s\" % (i, t[0])\n                    sig = \"%s(location, %s)\" % (apiname(cname), args)\n                    self._add_group_function(des, sig, es2funcs[cname])\n            for t in (\"float\", \"int\"):\n                for i in (1, 2, 3, 4):\n                    cname = \"uniform%i%sv\" % (i, t[0])\n                    sig = \"%s(location, count, values)\" % apiname(cname)\n                    self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"uniformMatrix\":\n            for i in (2, 3, 4):\n                cname = \"uniformMatrix%ifv\" % i\n                sig = \"%s(location, count, transpose, values)\" % apiname(cname)\n                self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"vertexAttrib\":\n            for i in (1, 2, 3, 4):\n                args = \", \".join([\"v%i\" % j for j in range(1, i + 1)])\n                cname = \"vertexAttrib%if\" % i\n                sig = \"%s(index, %s)\" % (apiname(cname), args)\n                self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"texParameter\":\n            for t in (\"float\", \"int\"):\n                cname = \"texParameter%s\" % t[0]\n                sig = \"%s(target, pname, param)\" % apiname(cname)\n                self._add_group_function(des, sig, es2funcs[cname])\n        else:\n            handled = False\n\n        if handled:\n            self.functions_auto.add(des.name)\n        else:\n            self.functions_todo.add(des.name)\n            lines.append(\"# todo: Dont know group %s\" % des.name)\n\n    def _add_function(self, des):\n        # Need to be overloaded in subclass\n        raise NotImplementedError()\n\n    def _add_group_function(self, des, sig, es2func):\n        # Need to be overloaded in subclass\n        raise NotImplementedError()",
  "class ProxyApiGenerator(ApiGenerator):\n    \"\"\"Generator for the general proxy class that will be loaded into gloo.gl.\"\"\"\n\n    filename = os.path.join(GLDIR, \"_proxy.py\")\n    DESCRIPTION = \"Base proxy API for GL ES 2.0.\"\n    PREAMBLE = '''\n    class BaseGLProxy(object):\n        \"\"\" Base proxy class for the GL ES 2.0 API. Subclasses should\n        implement __call__ to process the API calls.\n        \"\"\"\n       \n        def __call__(self, funcname, returns, *args):\n            raise NotImplementedError()\n    '''\n\n    def _returns(self, des):\n        shortame = des.name\n        for prefix in (\"get\", \"is\", \"check\", \"create\", \"read\"):\n            if shortame.startswith(prefix):\n                return True\n        else:\n            return False\n\n    def _add_function(self, des):\n        ret = self._returns(des)\n        prefix = \"return \" if ret else \"\"\n        argstr = \", \".join(des.args)\n        self.lines.append(\"    def %s(self, %s):\" % (des.apiname, argstr))\n        self.lines.append(\n            '        %sself(\"%s\", %r, %s)' % (prefix, apiname(des.name), ret, argstr)\n        )\n\n    def _add_group_function(self, des, sig, es2func):\n        ret = self._returns(des)\n        prefix = \"return \" if ret else \"\"\n        funcname = apiname(sig.split(\"(\")[0])\n        args = sig.split(\"(\", 1)[1].split(\")\")[0]\n        self.lines.append(\"    def %s(self, %s):\" % (funcname, args))\n        self.lines.append(\n            '        %sself(\"%s\", %r, %s)' % (prefix, funcname, ret, args)\n        )",
  "class Gl2ApiGenerator(ApiGenerator):\n    \"\"\"Generator for the gl2 (desktop) backend.\"\"\"\n\n    filename = os.path.join(GLDIR, \"_gl2.py\")\n    write_c_sig = True\n    define_argtypes_in_module = False\n    backend_name = \"gl\"\n\n    DESCRIPTION = \"Subset of desktop GL API compatible with GL ES 2.0\"\n    PREAMBLE = \"\"\"\n    import ctypes\n    from .gl2 import _lib, _get_gl_func\n    \"\"\"\n\n    def _get_argtype_str(self, es2func):\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        # Set argument types on ctypes function\n        if None in ct_arg_types:\n            argstr = \"UNKNOWN_ARGTYPES\"\n        elif es2func.group:\n            argstr = \"UNKNOWN_ARGTYPES\"\n        else:\n            argstr = \", \".join([\"ctypes.%s\" % t[1] for t in ct_arg_types[1:]])\n            argstr = \"()\" if not argstr else \"(%s,)\" % argstr\n        # Set output arg (if available)\n        if ct_arg_types[0][0] != type(None):\n            resstr = \"ctypes.%s\" % ct_arg_types[0][1]\n        else:\n            resstr = \"None\"\n        return resstr, argstr\n\n    def _write_argtypes(self, es2func):\n        lines = self.lines\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        # Set argument types on ctypes function\n        if None in ct_arg_types:\n            lines.append(\"# todo: unknown argtypes\")\n        elif es2func.group:\n            lines.append(\"# todo: oops, dont set argtypes for group!\")\n        else:\n            if ct_arg_types[1:]:\n                argstr = \", \".join([\"ctypes.%s\" % t[1] for t in ct_arg_types[1:]])\n                lines.append(\"_lib.%s.argtypes = %s,\" % (es2func.glname, argstr))\n            else:\n                lines.append(\"_lib.%s.argtypes = ()\" % es2func.glname)\n        # Set output arg (if available)\n        if ct_arg_types[0][0] != type(None):\n            lines.append(\n                \"_lib.%s.restype = ctypes.%s\" % (es2func.glname, ct_arg_types[0][1])\n            )\n\n    def _native_call_line(self, name, es2func, cargstr=None, prefix=\"\", indent=4):\n        resstr, argstr = self._get_argtype_str(es2func)\n        if cargstr is None:\n            cargs = [arg.name for arg in es2func.args[1:]]\n            cargstr = \", \".join(cargs)\n\n        lines = \"try:\\n\"\n        lines += \"    nativefunc = %s._native\\n\" % apiname(name)\n        lines += \"except AttributeError:\\n\"\n        lines += '    nativefunc = %s._native = _get_gl_func(\"%s\", %s, %s)\\n' % (\n            apiname(name),\n            es2func.glname,\n            resstr,\n            argstr,\n        )\n        lines += \"%snativefunc(%s)\\n\" % (prefix, cargstr)\n        lines = [\" \" * indent + line for line in lines.splitlines()]\n        return \"\\n\".join(lines)\n\n    def _add_function(self, des):\n        lines = self.lines\n        es2func = des.es2\n\n        # Write arg types\n        if self.define_argtypes_in_module:\n            self._write_argtypes(es2func)\n\n        # Get names and types of C-API\n        ce_arg_types = [arg.ctype for arg in es2func.args[1:]]\n        ce_arg_names = [arg.name for arg in es2func.args[1:]]\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        ct_arg_types_easy = [EASY_TYPES.get(arg.ctype, None) for arg in es2func.args]\n\n        # Write C function signature, for debugging and development\n        if self.write_c_sig:\n            argnamesstr = \", \".join(\n                [\n                    c_type + \" \" + c_name\n                    for c_type, c_name in zip(ce_arg_types, ce_arg_names)\n                ]\n            )\n            lines.append(\n                \"# %s = %s(%s)\" % (es2func.args[0].ctype, es2func.oname, argnamesstr)\n            )\n\n        # Write Python function def\n        lines.append(\"def %s(%s):\" % (des.apiname, \", \".join(des.args)))\n\n        # Construct C function call\n        cargs = [arg.name for arg in des.es2.args[1:]]\n\n        # Now write the body of the function ...\n        if des.ann:\n            prefix = \"res = \"\n            # Annotation available\n            self.functions_anno.add(des.name)\n            callline = self._native_call_line(des.name, es2func, prefix=prefix)\n            lines.extend(des.ann.get_lines(callline, self.backend_name))\n\n        elif es2func.group:\n            # Group?\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: Oops. this is a group!\")\n        elif None in ct_arg_types_easy:\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: Not all easy types!\")\n        elif des.args != [arg.name for arg in des.wgl.args[1:]]:\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: ES 2.0 and WebGL args do not match!\")\n        else:\n            # This one is easy!\n            self.functions_auto.add(des.name)\n            # Get prefix\n            prefix = \"\"\n            if ct_arg_types[0][0] != type(None):\n                prefix = \"return \"\n            elif des.es2.shortname.startswith(\"get\"):\n                raise RuntimeError(\"Get func returns void?\")\n            # Set string\n            callline = self._native_call_line(des.name, des.es2, prefix=prefix)\n            lines.append(callline)\n\n        if \"gl2\" in self.__class__.__name__.lower():\n            # Post-fix special cases for gl2. See discussion in #201\n            # glDepthRangef and glClearDepthf are not always available,\n            # and sometimes they do not work if they are\n            if es2func.oname in (\"glDepthRangef\", \"glClearDepthf\"):\n                for i in range(1, 10):\n                    line = lines[-i]\n                    if not line.strip() or line.startswith(\"#\"):\n                        break\n                    line = line.replace(\"c_float\", \"c_double\")\n                    line = line.replace(\"glDepthRangef\", \"glDepthRange\")\n                    line = line.replace(\"glClearDepthf\", \"glClearDepth\")\n                    lines[-i] = line\n\n    def _add_group_function(self, des, sig, es2func):\n        lines = self.lines\n\n        call_line = self._native_call_line\n\n        if self.define_argtypes_in_module:\n            self._write_argtypes(es2func)\n\n        funcname = sig.split(\"(\", 1)[0]\n        args = sig.split(\"(\", 1)[1].split(\")\")[0]\n\n        if des.name == \"uniform\":\n            if funcname[-1] != \"v\":\n                lines.append(\"def %s:\" % sig)\n                lines.append(call_line(funcname, es2func, args))\n            else:\n                t = {\"f\": \"float\", \"i\": \"int\"}[funcname[-2]]\n                lines.append(\"def %s:\" % sig)\n                lines.append(\"    values = [%s(val) for val in values]\" % t)\n                lines.append(\"    values = (ctypes.c_%s*len(values))(*values)\" % t)\n                lines.append(call_line(funcname, es2func, \"location, count, values\"))\n        elif des.name == \"uniformMatrix\":\n            lines.append(\"def %s:\" % sig)\n            lines.append('    if not values.flags[\"C_CONTIGUOUS\"]:')\n            lines.append(\"        values = values.copy()\")\n            lines.append('    assert values.dtype.name == \"float32\"')\n            lines.append(\"    values_ = values\")\n            lines.append(\n                \"    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\"\n            )\n            lines.append(\n                call_line(funcname, es2func, \"location, count, transpose, values\")\n            )\n        elif des.name == \"vertexAttrib\":\n            lines.append(\"def %s:\" % sig)\n            lines.append(call_line(funcname, es2func, args))\n        elif des.name == \"texParameter\":\n            lines.append(\"def %s:\" % sig)\n            lines.append(call_line(funcname, es2func, args))\n\n        else:\n            raise ValueError(\"unknown group func\")",
  "class Es2ApiGenerator(Gl2ApiGenerator):\n    \"\"\"Generator for the es2 backend (i.e. Angle on Windows). Very\n    similar to the gl2 API, but we do not need that deferred loading\n    of GL functions here.\n    \"\"\"\n\n    filename = os.path.join(GLDIR, \"_es2.py\")\n    write_c_sig = True\n    define_argtypes_in_module = True\n    backend_name = \"es\"\n\n    DESCRIPTION = \"GL ES 2.0 API (via Angle/DirectX on Windows)\"\n    PREAMBLE = \"\"\"\n    import ctypes\n    from .es2 import _lib\n    \"\"\"\n\n    def _native_call_line(self, name, es2func, cargstr=None, prefix=\"\", indent=4):\n        resstr, argstr = self._get_argtype_str(es2func)\n        if cargstr is None:\n            cargs = [arg.name for arg in es2func.args[1:]]\n            cargstr = \", \".join(cargs)\n        return \" \" * indent + \"%s_lib.%s(%s)\" % (prefix, es2func.glname, cargstr)",
  "class PyOpenGL2ApiGenerator(ApiGenerator):\n    \"\"\"Generator for a fallback pyopengl backend.\"\"\"\n\n    filename = os.path.join(GLDIR, \"_pyopengl2.py\")\n    backend_name = \"pyopengl\"\n\n    DESCRIPTION = \"Proxy API for GL ES 2.0 subset, via the PyOpenGL library.\"\n    PREAMBLE = \"\"\"\n    import ctypes\n    from OpenGL import GL\n    import OpenGL.GL.framebufferobjects as FBO\n    \"\"\"\n\n    def __init__(self):\n        ApiGenerator.__init__(self)\n        self._functions_to_import = []\n        self._used_functions = []\n\n    def _add_function(self, des):\n        # Fix for FBO?\n        mod = \"GL\"\n        if \"renderbuffer\" in des.name.lower() or \"framebuffer\" in des.name.lower():\n            mod = \"FBO\"\n        # Get call line\n        argstr = \", \".join(des.args)\n        call_line = \"    return %s.%s(%s)\" % (mod, des.es2.glname, argstr)\n        # Get annotation lines\n        ann_lines = []\n        if des.ann is not None:\n            ann_lines = des.ann.get_lines(call_line, self.backend_name)\n        # Use annotation or not\n        if ann_lines:\n            self.lines.append(\"def %s(%s):\" % (des.apiname, argstr))\n            self.lines.extend(ann_lines)\n            self._used_functions.append(des.es2.glname)\n        else:\n            # To be imported from OpenGL.GL\n            self._functions_to_import.append((des.es2.glname, des.apiname))\n\n    def _add_group_function(self, des, sig, es2func):\n        # All group functions can be directly imported from OpenGL\n        funcname = apiname(sig.split(\"(\")[0])\n        self._functions_to_import.append((funcname, funcname))\n\n    def save(self):\n        # Write remaining functions\n        self.lines.append(\"# List of functions that we should import from OpenGL.GL\")\n        self.lines.append(\"_functions_to_import = [\")\n        for name1, name2 in self._functions_to_import:\n            self.lines.append('    (\"%s\", \"%s\"),' % (name1, name2))\n        self.lines.append(\"    ]\")\n\n        self.lines.append(\"\")\n\n        # Write used functions\n        self.lines.append(\"# List of functions in OpenGL.GL that we use\")\n        self.lines.append(\"_used_functions = [\")\n        for name in self._used_functions:\n            self.lines.append('    \"%s\",' % name)\n        self.lines.append(\"    ]\")\n\n        # Really save\n        ApiGenerator.save(self)",
  "class FunctionCollector:\n    def __init__(self, annotations, parser1, parser2):\n        self.annotations = annotations\n        self.parser1 = parser1\n        self.parser2 = parser2\n        # Keep track of what webGL names we \"used\"\n        self.used_webgl_names = set()\n\n        # Also keep track of what functions we could handle automatically,\n        # and which not. Just for reporting.\n        self.functions_auto = set()\n        self.functions_anno = set()\n        self.functions_todo = set()\n\n        self.all_functions = []\n\n    def collect_function_definitions(self):\n        \"\"\"Process function definitions of ES 2.0, WebGL and annotations.\n\n        We try to combine information from these three sources to find the\n        arguments for the Python API. In this \"merging\" process we also\n        check for inconsistencies between the API definitions.\n\n        \"\"\"\n        for name in self.parser1.function_names:\n            if name in IGNORE_FUNCTIONS:\n                continue\n\n            # Get es2 function\n            es2func = self.parser1.functions[name]\n\n            # Get webgl version\n            lookupname = WEBGL_EQUIVALENTS.get(es2func.shortname, es2func.shortname)\n            wglfunc = self.parser2.functions.get(lookupname, None)\n            if wglfunc:\n                self.used_webgl_names.add(lookupname)\n            else:\n                print(\"WARNING: %s not available in WebGL\" % es2func.shortname)\n\n            # Convert name\n            name = WEBGL_EQUIVALENTS.get(name, name)\n\n            # Avoid duplicates for getParameter\n            if name == \"getParameter\":\n                if es2func.shortname != \"getString\":\n                    name = \"_\" + es2func.shortname\n\n            # Get annotated version\n            annfunc = self.annotations.get(name, None)\n\n            # Create description instance\n            des = FunctionDescription(name, es2func, wglfunc, annfunc)\n            self.all_functions.append(des)\n\n            # Get information about arguments\n            argnames_es2 = [arg.name for arg in es2func.args[1:]]\n            if wglfunc:\n                argnames_wgl = [arg.name for arg in wglfunc.args[1:]]\n            if annfunc:\n                argnames_ann = annfunc.args  # Can contain 'argname=default'\n                argnames_ann = [arg.split(\"=\")[0] for arg in argnames_ann]\n\n            # Set argumenets specification of our GL API\n            # Also check and report when we deviate from the WebGL API\n            if wglfunc and argnames_es2 == argnames_wgl:\n                if annfunc and argnames_ann != argnames_es2:\n                    des.args = argnames_ann\n                    print(\n                        \"WARNING: %s: Annotation overload even though webgl and es2 match.\"\n                        % name\n                    )\n                else:\n                    des.args = argnames_es2\n            elif wglfunc:\n                if annfunc and argnames_ann != argnames_wgl:\n                    des.args = argnames_ann\n                    print(\"WARNING: %s: Annotation overload webgl args.\" % name)\n                else:\n                    # print('WARNING: %s: assuming wgl args.'%name)\n                    des.args = argnames_wgl\n            else:\n                print(\"WARNING: %s: Could not determine args!!\" % name)\n\n            # Go over all functions to test if they are in OpenGL\n            for func in [es2func, wglfunc]:\n                if func is None:\n                    continue\n                group = func.group or [func]\n                for f in group:\n                    # Check opengl\n                    if f.oname.startswith(\"gl\") and not hasattr(GL, f.glname):\n                        print(\"WARNING: %s seems not available in PyOpenGL\" % f.glname)\n\n    def check_unused_webgl_funcs(self):\n        \"\"\"Check which WebGL functions we did not find/use.\"\"\"\n        for name in set(self.parser2.function_names).difference(self.used_webgl_names):\n            print(\"WARNING: WebGL function %s not in Desktop\" % name)\n\n    def report_status(self):\n        print(\n            \"Could generate %i functions automatically, and %i with annotations\"\n            % (len(self.functions_auto), len(self.functions_anno))\n        )\n        print(\"Need more info for %i functions.\" % len(self.functions_todo))\n        if not self.functions_todo:\n            print(\"Hooray! All %i functions are covered!\" % len(self.all_functions))",
  "def main():\n    annotations = parse_anotations()\n    gl2es2_parser, webgl_parser = create_parsers()\n    vispy_ext_parser = headerparser.Parser(os.path.join(THISDIR, \"headers\", \"vispy_ext.h\"))\n    constant_definitions = list(gl2es2_parser.constants.values()) + list(vispy_ext_parser.constants.values())\n    create_constants_module(constant_definitions)\n\n    # Get full function definitions and report\n    func_collector = FunctionCollector(annotations, gl2es2_parser, webgl_parser)\n    func_collector.collect_function_definitions()\n\n    for Gen in [\n        ProxyApiGenerator,\n        Gl2ApiGenerator,\n        Es2ApiGenerator,\n        PyOpenGL2ApiGenerator,\n    ]:\n        gen = Gen()\n        gen.add_functions(func_collector.all_functions)\n        func_collector.functions_auto.update(gen.functions_auto)\n        func_collector.functions_anno.update(gen.functions_anno)\n        func_collector.functions_todo.update(gen.functions_todo)\n        gen.save()\n\n    func_collector.check_unused_webgl_funcs()\n    func_collector.report_status()",
  "def __init__(self, name, es2func, wglfunc, annfunc):\n        self.name = name\n        self.apiname = apiname(name)\n        self.es2 = es2func\n        self.wgl = wglfunc\n        self.ann = annfunc\n        self.args = []",
  "def __init__(self):\n        self.lines = []\n        self.functions_auto = set()\n        self.functions_anno = set()\n        self.functions_todo = set()",
  "def save(self):\n        # Remove too many whitespace\n        text = \"\\n\".join(self.lines) + \"\\n\"\n        for i in range(10):\n            text = text.replace(\"\\n\\n\\n\\n\", \"\\n\\n\\n\")\n        # Write\n        with open(self.filename, \"wb\") as f:\n            f.write((PREAMBLE % self.DESCRIPTION).encode(\"utf-8\"))\n            for line in self.PREAMBLE.splitlines():\n                f.write(line[4:].encode(\"utf-8\") + b\"\\n\")\n            f.write(b\"\\n\")\n            f.write(text.encode(\"utf-8\"))",
  "def add_functions(self, all_functions):\n        for func_description in all_functions:\n            self.add_function(func_description)",
  "def add_function(self, des: FunctionDescription):\n        if des.es2.group:\n            if des.name.startswith(\"get\"):\n                assert len(des.es2.group) == 2  # vi and fv\n                des.es2 = des.es2.group[0]  # f comes before 1\n                self._add_function(des)\n            else:\n                self._add_function_group(des)\n        else:\n            self._add_function(des)\n        self.lines.append(\"\\n\")",
  "def _add_function_group(self, des: FunctionDescription) -> tuple[set, set, set]:\n        lines = self.lines\n        handled = True\n\n        # Create map to es2 function objects\n        es2funcs = {}\n        for f in des.es2.group:\n            cname = f.shortname\n            es2funcs[cname] = f\n\n        if des.name == \"uniform\":\n            for t in (\"float\", \"int\"):\n                for i in (1, 2, 3, 4):\n                    args = \", \".join([\"v%i\" % j for j in range(1, i + 1)])\n                    cname = \"uniform%i%s\" % (i, t[0])\n                    sig = \"%s(location, %s)\" % (apiname(cname), args)\n                    self._add_group_function(des, sig, es2funcs[cname])\n            for t in (\"float\", \"int\"):\n                for i in (1, 2, 3, 4):\n                    cname = \"uniform%i%sv\" % (i, t[0])\n                    sig = \"%s(location, count, values)\" % apiname(cname)\n                    self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"uniformMatrix\":\n            for i in (2, 3, 4):\n                cname = \"uniformMatrix%ifv\" % i\n                sig = \"%s(location, count, transpose, values)\" % apiname(cname)\n                self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"vertexAttrib\":\n            for i in (1, 2, 3, 4):\n                args = \", \".join([\"v%i\" % j for j in range(1, i + 1)])\n                cname = \"vertexAttrib%if\" % i\n                sig = \"%s(index, %s)\" % (apiname(cname), args)\n                self._add_group_function(des, sig, es2funcs[cname])\n        elif des.name == \"texParameter\":\n            for t in (\"float\", \"int\"):\n                cname = \"texParameter%s\" % t[0]\n                sig = \"%s(target, pname, param)\" % apiname(cname)\n                self._add_group_function(des, sig, es2funcs[cname])\n        else:\n            handled = False\n\n        if handled:\n            self.functions_auto.add(des.name)\n        else:\n            self.functions_todo.add(des.name)\n            lines.append(\"# todo: Dont know group %s\" % des.name)",
  "def _add_function(self, des):\n        # Need to be overloaded in subclass\n        raise NotImplementedError()",
  "def _add_group_function(self, des, sig, es2func):\n        # Need to be overloaded in subclass\n        raise NotImplementedError()",
  "def _returns(self, des):\n        shortame = des.name\n        for prefix in (\"get\", \"is\", \"check\", \"create\", \"read\"):\n            if shortame.startswith(prefix):\n                return True\n        else:\n            return False",
  "def _add_function(self, des):\n        ret = self._returns(des)\n        prefix = \"return \" if ret else \"\"\n        argstr = \", \".join(des.args)\n        self.lines.append(\"    def %s(self, %s):\" % (des.apiname, argstr))\n        self.lines.append(\n            '        %sself(\"%s\", %r, %s)' % (prefix, apiname(des.name), ret, argstr)\n        )",
  "def _add_group_function(self, des, sig, es2func):\n        ret = self._returns(des)\n        prefix = \"return \" if ret else \"\"\n        funcname = apiname(sig.split(\"(\")[0])\n        args = sig.split(\"(\", 1)[1].split(\")\")[0]\n        self.lines.append(\"    def %s(self, %s):\" % (funcname, args))\n        self.lines.append(\n            '        %sself(\"%s\", %r, %s)' % (prefix, funcname, ret, args)\n        )",
  "def _get_argtype_str(self, es2func):\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        # Set argument types on ctypes function\n        if None in ct_arg_types:\n            argstr = \"UNKNOWN_ARGTYPES\"\n        elif es2func.group:\n            argstr = \"UNKNOWN_ARGTYPES\"\n        else:\n            argstr = \", \".join([\"ctypes.%s\" % t[1] for t in ct_arg_types[1:]])\n            argstr = \"()\" if not argstr else \"(%s,)\" % argstr\n        # Set output arg (if available)\n        if ct_arg_types[0][0] != type(None):\n            resstr = \"ctypes.%s\" % ct_arg_types[0][1]\n        else:\n            resstr = \"None\"\n        return resstr, argstr",
  "def _write_argtypes(self, es2func):\n        lines = self.lines\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        # Set argument types on ctypes function\n        if None in ct_arg_types:\n            lines.append(\"# todo: unknown argtypes\")\n        elif es2func.group:\n            lines.append(\"# todo: oops, dont set argtypes for group!\")\n        else:\n            if ct_arg_types[1:]:\n                argstr = \", \".join([\"ctypes.%s\" % t[1] for t in ct_arg_types[1:]])\n                lines.append(\"_lib.%s.argtypes = %s,\" % (es2func.glname, argstr))\n            else:\n                lines.append(\"_lib.%s.argtypes = ()\" % es2func.glname)\n        # Set output arg (if available)\n        if ct_arg_types[0][0] != type(None):\n            lines.append(\n                \"_lib.%s.restype = ctypes.%s\" % (es2func.glname, ct_arg_types[0][1])\n            )",
  "def _native_call_line(self, name, es2func, cargstr=None, prefix=\"\", indent=4):\n        resstr, argstr = self._get_argtype_str(es2func)\n        if cargstr is None:\n            cargs = [arg.name for arg in es2func.args[1:]]\n            cargstr = \", \".join(cargs)\n\n        lines = \"try:\\n\"\n        lines += \"    nativefunc = %s._native\\n\" % apiname(name)\n        lines += \"except AttributeError:\\n\"\n        lines += '    nativefunc = %s._native = _get_gl_func(\"%s\", %s, %s)\\n' % (\n            apiname(name),\n            es2func.glname,\n            resstr,\n            argstr,\n        )\n        lines += \"%snativefunc(%s)\\n\" % (prefix, cargstr)\n        lines = [\" \" * indent + line for line in lines.splitlines()]\n        return \"\\n\".join(lines)",
  "def _add_function(self, des):\n        lines = self.lines\n        es2func = des.es2\n\n        # Write arg types\n        if self.define_argtypes_in_module:\n            self._write_argtypes(es2func)\n\n        # Get names and types of C-API\n        ce_arg_types = [arg.ctype for arg in es2func.args[1:]]\n        ce_arg_names = [arg.name for arg in es2func.args[1:]]\n        ct_arg_types = [KNOWN_TYPES.get(arg.ctype, None) for arg in es2func.args]\n        ct_arg_types_easy = [EASY_TYPES.get(arg.ctype, None) for arg in es2func.args]\n\n        # Write C function signature, for debugging and development\n        if self.write_c_sig:\n            argnamesstr = \", \".join(\n                [\n                    c_type + \" \" + c_name\n                    for c_type, c_name in zip(ce_arg_types, ce_arg_names)\n                ]\n            )\n            lines.append(\n                \"# %s = %s(%s)\" % (es2func.args[0].ctype, es2func.oname, argnamesstr)\n            )\n\n        # Write Python function def\n        lines.append(\"def %s(%s):\" % (des.apiname, \", \".join(des.args)))\n\n        # Construct C function call\n        cargs = [arg.name for arg in des.es2.args[1:]]\n\n        # Now write the body of the function ...\n        if des.ann:\n            prefix = \"res = \"\n            # Annotation available\n            self.functions_anno.add(des.name)\n            callline = self._native_call_line(des.name, es2func, prefix=prefix)\n            lines.extend(des.ann.get_lines(callline, self.backend_name))\n\n        elif es2func.group:\n            # Group?\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: Oops. this is a group!\")\n        elif None in ct_arg_types_easy:\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: Not all easy types!\")\n        elif des.args != [arg.name for arg in des.wgl.args[1:]]:\n            self.functions_todo.add(des.name)\n            lines.append(\"    pass  # todo: ES 2.0 and WebGL args do not match!\")\n        else:\n            # This one is easy!\n            self.functions_auto.add(des.name)\n            # Get prefix\n            prefix = \"\"\n            if ct_arg_types[0][0] != type(None):\n                prefix = \"return \"\n            elif des.es2.shortname.startswith(\"get\"):\n                raise RuntimeError(\"Get func returns void?\")\n            # Set string\n            callline = self._native_call_line(des.name, des.es2, prefix=prefix)\n            lines.append(callline)\n\n        if \"gl2\" in self.__class__.__name__.lower():\n            # Post-fix special cases for gl2. See discussion in #201\n            # glDepthRangef and glClearDepthf are not always available,\n            # and sometimes they do not work if they are\n            if es2func.oname in (\"glDepthRangef\", \"glClearDepthf\"):\n                for i in range(1, 10):\n                    line = lines[-i]\n                    if not line.strip() or line.startswith(\"#\"):\n                        break\n                    line = line.replace(\"c_float\", \"c_double\")\n                    line = line.replace(\"glDepthRangef\", \"glDepthRange\")\n                    line = line.replace(\"glClearDepthf\", \"glClearDepth\")\n                    lines[-i] = line",
  "def _add_group_function(self, des, sig, es2func):\n        lines = self.lines\n\n        call_line = self._native_call_line\n\n        if self.define_argtypes_in_module:\n            self._write_argtypes(es2func)\n\n        funcname = sig.split(\"(\", 1)[0]\n        args = sig.split(\"(\", 1)[1].split(\")\")[0]\n\n        if des.name == \"uniform\":\n            if funcname[-1] != \"v\":\n                lines.append(\"def %s:\" % sig)\n                lines.append(call_line(funcname, es2func, args))\n            else:\n                t = {\"f\": \"float\", \"i\": \"int\"}[funcname[-2]]\n                lines.append(\"def %s:\" % sig)\n                lines.append(\"    values = [%s(val) for val in values]\" % t)\n                lines.append(\"    values = (ctypes.c_%s*len(values))(*values)\" % t)\n                lines.append(call_line(funcname, es2func, \"location, count, values\"))\n        elif des.name == \"uniformMatrix\":\n            lines.append(\"def %s:\" % sig)\n            lines.append('    if not values.flags[\"C_CONTIGUOUS\"]:')\n            lines.append(\"        values = values.copy()\")\n            lines.append('    assert values.dtype.name == \"float32\"')\n            lines.append(\"    values_ = values\")\n            lines.append(\n                \"    values = values_.ctypes.data_as(ctypes.POINTER(ctypes.c_float))\"\n            )\n            lines.append(\n                call_line(funcname, es2func, \"location, count, transpose, values\")\n            )\n        elif des.name == \"vertexAttrib\":\n            lines.append(\"def %s:\" % sig)\n            lines.append(call_line(funcname, es2func, args))\n        elif des.name == \"texParameter\":\n            lines.append(\"def %s:\" % sig)\n            lines.append(call_line(funcname, es2func, args))\n\n        else:\n            raise ValueError(\"unknown group func\")",
  "def _native_call_line(self, name, es2func, cargstr=None, prefix=\"\", indent=4):\n        resstr, argstr = self._get_argtype_str(es2func)\n        if cargstr is None:\n            cargs = [arg.name for arg in es2func.args[1:]]\n            cargstr = \", \".join(cargs)\n        return \" \" * indent + \"%s_lib.%s(%s)\" % (prefix, es2func.glname, cargstr)",
  "def __init__(self):\n        ApiGenerator.__init__(self)\n        self._functions_to_import = []\n        self._used_functions = []",
  "def _add_function(self, des):\n        # Fix for FBO?\n        mod = \"GL\"\n        if \"renderbuffer\" in des.name.lower() or \"framebuffer\" in des.name.lower():\n            mod = \"FBO\"\n        # Get call line\n        argstr = \", \".join(des.args)\n        call_line = \"    return %s.%s(%s)\" % (mod, des.es2.glname, argstr)\n        # Get annotation lines\n        ann_lines = []\n        if des.ann is not None:\n            ann_lines = des.ann.get_lines(call_line, self.backend_name)\n        # Use annotation or not\n        if ann_lines:\n            self.lines.append(\"def %s(%s):\" % (des.apiname, argstr))\n            self.lines.extend(ann_lines)\n            self._used_functions.append(des.es2.glname)\n        else:\n            # To be imported from OpenGL.GL\n            self._functions_to_import.append((des.es2.glname, des.apiname))",
  "def _add_group_function(self, des, sig, es2func):\n        # All group functions can be directly imported from OpenGL\n        funcname = apiname(sig.split(\"(\")[0])\n        self._functions_to_import.append((funcname, funcname))",
  "def save(self):\n        # Write remaining functions\n        self.lines.append(\"# List of functions that we should import from OpenGL.GL\")\n        self.lines.append(\"_functions_to_import = [\")\n        for name1, name2 in self._functions_to_import:\n            self.lines.append('    (\"%s\", \"%s\"),' % (name1, name2))\n        self.lines.append(\"    ]\")\n\n        self.lines.append(\"\")\n\n        # Write used functions\n        self.lines.append(\"# List of functions in OpenGL.GL that we use\")\n        self.lines.append(\"_used_functions = [\")\n        for name in self._used_functions:\n            self.lines.append('    \"%s\",' % name)\n        self.lines.append(\"    ]\")\n\n        # Really save\n        ApiGenerator.save(self)",
  "def __init__(self, annotations, parser1, parser2):\n        self.annotations = annotations\n        self.parser1 = parser1\n        self.parser2 = parser2\n        # Keep track of what webGL names we \"used\"\n        self.used_webgl_names = set()\n\n        # Also keep track of what functions we could handle automatically,\n        # and which not. Just for reporting.\n        self.functions_auto = set()\n        self.functions_anno = set()\n        self.functions_todo = set()\n\n        self.all_functions = []",
  "def collect_function_definitions(self):\n        \"\"\"Process function definitions of ES 2.0, WebGL and annotations.\n\n        We try to combine information from these three sources to find the\n        arguments for the Python API. In this \"merging\" process we also\n        check for inconsistencies between the API definitions.\n\n        \"\"\"\n        for name in self.parser1.function_names:\n            if name in IGNORE_FUNCTIONS:\n                continue\n\n            # Get es2 function\n            es2func = self.parser1.functions[name]\n\n            # Get webgl version\n            lookupname = WEBGL_EQUIVALENTS.get(es2func.shortname, es2func.shortname)\n            wglfunc = self.parser2.functions.get(lookupname, None)\n            if wglfunc:\n                self.used_webgl_names.add(lookupname)\n            else:\n                print(\"WARNING: %s not available in WebGL\" % es2func.shortname)\n\n            # Convert name\n            name = WEBGL_EQUIVALENTS.get(name, name)\n\n            # Avoid duplicates for getParameter\n            if name == \"getParameter\":\n                if es2func.shortname != \"getString\":\n                    name = \"_\" + es2func.shortname\n\n            # Get annotated version\n            annfunc = self.annotations.get(name, None)\n\n            # Create description instance\n            des = FunctionDescription(name, es2func, wglfunc, annfunc)\n            self.all_functions.append(des)\n\n            # Get information about arguments\n            argnames_es2 = [arg.name for arg in es2func.args[1:]]\n            if wglfunc:\n                argnames_wgl = [arg.name for arg in wglfunc.args[1:]]\n            if annfunc:\n                argnames_ann = annfunc.args  # Can contain 'argname=default'\n                argnames_ann = [arg.split(\"=\")[0] for arg in argnames_ann]\n\n            # Set argumenets specification of our GL API\n            # Also check and report when we deviate from the WebGL API\n            if wglfunc and argnames_es2 == argnames_wgl:\n                if annfunc and argnames_ann != argnames_es2:\n                    des.args = argnames_ann\n                    print(\n                        \"WARNING: %s: Annotation overload even though webgl and es2 match.\"\n                        % name\n                    )\n                else:\n                    des.args = argnames_es2\n            elif wglfunc:\n                if annfunc and argnames_ann != argnames_wgl:\n                    des.args = argnames_ann\n                    print(\"WARNING: %s: Annotation overload webgl args.\" % name)\n                else:\n                    # print('WARNING: %s: assuming wgl args.'%name)\n                    des.args = argnames_wgl\n            else:\n                print(\"WARNING: %s: Could not determine args!!\" % name)\n\n            # Go over all functions to test if they are in OpenGL\n            for func in [es2func, wglfunc]:\n                if func is None:\n                    continue\n                group = func.group or [func]\n                for f in group:\n                    # Check opengl\n                    if f.oname.startswith(\"gl\") and not hasattr(GL, f.glname):\n                        print(\"WARNING: %s seems not available in PyOpenGL\" % f.glname)",
  "def check_unused_webgl_funcs(self):\n        \"\"\"Check which WebGL functions we did not find/use.\"\"\"\n        for name in set(self.parser2.function_names).difference(self.used_webgl_names):\n            print(\"WARNING: WebGL function %s not in Desktop\" % name)",
  "def report_status(self):\n        print(\n            \"Could generate %i functions automatically, and %i with annotations\"\n            % (len(self.functions_auto), len(self.functions_anno))\n        )\n        print(\"Need more info for %i functions.\" % len(self.functions_todo))\n        if not self.functions_todo:\n            print(\"Hooray! All %i functions are covered!\" % len(self.all_functions))"
]