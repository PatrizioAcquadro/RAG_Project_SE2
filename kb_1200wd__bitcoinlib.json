[
  "def parse_args():\n    parser = argparse.ArgumentParser(description='BitcoinLib Database update script')\n    parser.add_argument('--database', '-d', default='sqlite:///' + DEFAULT_DATABASE,\n                        help=\"Name of specific database file to use\",)\n    pa = parser.parse_args()\n    return pa",
  "class Mnemonic(object):\n    \"\"\"\n    Class to convert, generate and parse Mnemonic sentences\n    \n    Implementation of BIP0039 for Mnemonics passphrases \n\n    Took some parts from Pavol Rusnak Trezors implementation, see https://github.com/trezor/python-mnemonic\n    \"\"\"\n\n    def __init__(self, language=DEFAULT_LANGUAGE):\n        \"\"\"\n        Init Mnemonic class and read wordlist of specified language\n        \n        :param language: use specific wordlist, i.e. chinese, dutch (in development), english, french, italian, japanese or spanish. Leave empty for default 'english'\n        :type language: str\n        \n        \"\"\"\n        self._wordlist = []\n        with Path(BCL_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:\n            self._wordlist = [w.strip() for w in f.readlines()]\n\n    @staticmethod\n    def checksum(data):\n        \"\"\"\n        Calculates checksum for given data key\n\n        :param data: key string\n        :type data: bytes, hexstring\n        \n        :return str: Checksum of key in bits\n        \"\"\"\n        data = to_bytes(data)\n        if len(data) % 4 > 0:\n            raise ValueError('Data length in bits should be divisible by 32, but it is not (%d bytes = %d bits).' %\n                             (len(data), len(data) * 8))\n        key_hash = hashlib.sha256(data).digest()\n        return change_base(key_hash, 256, 2, 256)[:len(data) * 8 // 32]\n\n    def to_seed(self, words, password='', validate=True):\n        \"\"\"\n        Use Mnemonic words and optionally a password to create a PBKDF2 seed (Password-Based Key Derivation Function 2)\n        \n        First use 'sanitize_mnemonic' to determine language and validate and check words\n\n        >>> Mnemonic().to_seed('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()\n        '6969ed4666db67fc74fae7869e2acf3c766b5ef95f5e31eb2fcebd93d76069c6de971225f700042b0b513f0ad6c8562277fc4b5ee1344b720f1686dc2dccc220'\n\n        :param words: Mnemonic passphrase as string with space separated words\n        :type words: str\n        :param password: A password to protect key, leave empty to disable\n        :type password: str\n        :param validate: Validate checksum for given word phrase, default is True\n        :type validate: bool\n        \n        :return bytes: PBKDF2 seed\n        \"\"\"\n        words = self.sanitize_mnemonic(words)\n        # Check if passphrase is valid\n        if validate:\n            self.to_entropy(words)\n        mnemonic = to_bytes(words)\n        password = to_bytes(password)\n        return hashlib.pbkdf2_hmac(hash_name='sha512', password=mnemonic, salt=b'mnemonic' + password,\n                                   iterations=2048)\n\n    def word(self, index):\n        \"\"\"\n        Get word from wordlist\n        \n        :param index: word index ID\n        :type index: int\n        \n        :return str: A word from the dictionary \n        \"\"\"\n        return self._wordlist[index]\n\n    def wordlist(self):\n        \"\"\"\n        Get full selected wordlist. A wordlist is selected when initializing Mnemonic class\n        \n        :return list: Full list with 2048 words \n        \"\"\"\n        return self._wordlist\n\n    def generate(self, strength=128, add_checksum=True):\n        \"\"\"\n        Generate a random Mnemonic key\n        \n        Uses cryptographically secure os.urandom() function to generate data. Then creates a Mnemonic sentence with\n        the 'to_mnemonic' method.\n\n        :param strength: Key strength in number of bits as multiply of 32, default is 128 bits. It advised to specify 128 bits or more, i.e.: 128, 256, 512 or 1024\n        :type strength: int\n        :param add_checksum: Included a checksum? Default is True\n        :type add_checksum: bool\n        \n        :return str: Mnemonic passphrase consisting of a space seperated list of words\n        \"\"\"\n        if strength % 32 > 0:\n            raise ValueError(\"Strength should be divisible by 32\")\n        data = os.urandom(strength // 8)\n        return self.to_mnemonic(data, add_checksum=add_checksum)\n\n    def to_mnemonic(self, data, add_checksum=True, check_on_curve=True):\n        \"\"\"\n        Convert key data entropy to Mnemonic sentence\n\n        >>> Mnemonic().to_mnemonic('28acfc94465fd2f6774759d6897ec122')\n        'chunk gun celery million wood kite tackle twenty story episode raccoon dutch'\n\n        :param data: Key data entropy\n        :type data: bytes, hexstring\n        :param add_checksum: Included a checksum? Default is True\n        :type add_checksum: bool\n        :param check_on_curve: Check if data integer value is on secp256k1 curve. Should be enabled when not testing and working with crypto\n        :type check_on_curve: bool\n        \n        :return str: Mnemonic passphrase consisting of a space seperated list of words\n        \"\"\"\n        data = to_bytes(data)\n        data_int = int.from_bytes(data, 'big')\n        if check_on_curve and not 0 < data_int < secp256k1_n:\n            raise ValueError(\"Integer value of data should be in secp256k1 domain between 1 and secp256k1_n-1\")\n        if add_checksum:\n            binresult = change_base(data_int, 10, 2, len(data) * 8) + self.checksum(data)\n            wi = change_base(binresult, 2, 2048)\n        else:\n            wi = change_base(data_int, 10, 2048, len(data) // 1.375 + len(data) % 1.375 > 0)\n        return normalize_string(' '.join([self._wordlist[i] for i in wi]))\n\n    def to_entropy(self, words, includes_checksum=True):\n        \"\"\"\n        Convert Mnemonic words back to key data entropy\n\n        >>> Mnemonic().to_entropy('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()\n        '28acfc94465fd2f6774759d6897ec122'\n\n\n        :param words: Mnemonic words as string of list of words\n        :type words: str\n        :param includes_checksum: Boolean to specify if checksum is used. Default is True\n        :type includes_checksum: bool\n        \n        :return bytes: Entropy seed\n        \"\"\"\n        words = self.sanitize_mnemonic(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n        wi = []\n        for word in words:\n            wi.append(self._wordlist.index(word))\n        ent_length = int(len(words) * 4/3)\n        ent = change_base(wi, 2048, 256, ent_length, output_even=False)\n        if includes_checksum:\n            binresult = change_base(ent, 256, 2, len(ent) * 4)\n            ent = change_base(binresult[:-len(binresult) // 33], 2, 256, ent_length)\n\n            # Check checksum\n            checksum = binresult[-len(binresult) // 33:]\n            if checksum != self.checksum(ent):\n                raise ValueError(\"Invalid checksum %s for entropy %s\" % (checksum, ent))\n\n        return ent\n\n    @staticmethod\n    def detect_language(words):\n        \"\"\"\n        Detect language of given phrase\n\n        >>> Mnemonic().detect_language('chunk gun celery million wood kite tackle twenty story episode raccoon dutch')\n        'english'\n        \n        :param words: List of space separated words\n        :type words: str\n        \n        :return str: Language \n        \"\"\"\n        words = normalize_string(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n\n        wlcount = {}\n        for fn in Path(BCL_INSTALL_DIR, 'wordlist').iterdir():\n            if fn.suffix == \".txt\":\n                with open(os.path.join(str(BCL_INSTALL_DIR), 'wordlist', fn), encoding='utf-8') as f:\n                    wordlist = [w.strip() for w in f.readlines()]\n                    language = fn.name.split('.')[0]\n                    wlcount[language] = 0\n                    for word in words:\n                        if word in wordlist:\n                            wlcount[language] += 1\n        detlang = max(wlcount.keys(), key=(lambda key: wlcount[key]))\n        if not wlcount[detlang]:\n            raise Warning(\"Could not detect language of Mnemonic sentence %s\" % words)\n        return detlang\n\n    def sanitize_mnemonic(self, words):\n        \"\"\"\n        Check and convert list of words to utf-8 encoding.\n        \n        Raises an error if unrecognised word is found\n        \n        :param words: List of space separated words\n        :type words: str\n        \n        :return str: Sanitized list of words\n        \"\"\"\n        words = normalize_string(words)\n        language = self.detect_language(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n        with Path(BCL_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:\n            wordlist = [w.strip() for w in f.readlines()]\n            for word in words:\n                if word not in wordlist:\n                    raise Warning(\"Unrecognised word %s in mnemonic sentence\" % word.encode('utf8'))\n        return ' '.join(words)",
  "def __init__(self, language=DEFAULT_LANGUAGE):\n        \"\"\"\n        Init Mnemonic class and read wordlist of specified language\n        \n        :param language: use specific wordlist, i.e. chinese, dutch (in development), english, french, italian, japanese or spanish. Leave empty for default 'english'\n        :type language: str\n        \n        \"\"\"\n        self._wordlist = []\n        with Path(BCL_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:\n            self._wordlist = [w.strip() for w in f.readlines()]",
  "def checksum(data):\n        \"\"\"\n        Calculates checksum for given data key\n\n        :param data: key string\n        :type data: bytes, hexstring\n        \n        :return str: Checksum of key in bits\n        \"\"\"\n        data = to_bytes(data)\n        if len(data) % 4 > 0:\n            raise ValueError('Data length in bits should be divisible by 32, but it is not (%d bytes = %d bits).' %\n                             (len(data), len(data) * 8))\n        key_hash = hashlib.sha256(data).digest()\n        return change_base(key_hash, 256, 2, 256)[:len(data) * 8 // 32]",
  "def to_seed(self, words, password='', validate=True):\n        \"\"\"\n        Use Mnemonic words and optionally a password to create a PBKDF2 seed (Password-Based Key Derivation Function 2)\n        \n        First use 'sanitize_mnemonic' to determine language and validate and check words\n\n        >>> Mnemonic().to_seed('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()\n        '6969ed4666db67fc74fae7869e2acf3c766b5ef95f5e31eb2fcebd93d76069c6de971225f700042b0b513f0ad6c8562277fc4b5ee1344b720f1686dc2dccc220'\n\n        :param words: Mnemonic passphrase as string with space separated words\n        :type words: str\n        :param password: A password to protect key, leave empty to disable\n        :type password: str\n        :param validate: Validate checksum for given word phrase, default is True\n        :type validate: bool\n        \n        :return bytes: PBKDF2 seed\n        \"\"\"\n        words = self.sanitize_mnemonic(words)\n        # Check if passphrase is valid\n        if validate:\n            self.to_entropy(words)\n        mnemonic = to_bytes(words)\n        password = to_bytes(password)\n        return hashlib.pbkdf2_hmac(hash_name='sha512', password=mnemonic, salt=b'mnemonic' + password,\n                                   iterations=2048)",
  "def word(self, index):\n        \"\"\"\n        Get word from wordlist\n        \n        :param index: word index ID\n        :type index: int\n        \n        :return str: A word from the dictionary \n        \"\"\"\n        return self._wordlist[index]",
  "def wordlist(self):\n        \"\"\"\n        Get full selected wordlist. A wordlist is selected when initializing Mnemonic class\n        \n        :return list: Full list with 2048 words \n        \"\"\"\n        return self._wordlist",
  "def generate(self, strength=128, add_checksum=True):\n        \"\"\"\n        Generate a random Mnemonic key\n        \n        Uses cryptographically secure os.urandom() function to generate data. Then creates a Mnemonic sentence with\n        the 'to_mnemonic' method.\n\n        :param strength: Key strength in number of bits as multiply of 32, default is 128 bits. It advised to specify 128 bits or more, i.e.: 128, 256, 512 or 1024\n        :type strength: int\n        :param add_checksum: Included a checksum? Default is True\n        :type add_checksum: bool\n        \n        :return str: Mnemonic passphrase consisting of a space seperated list of words\n        \"\"\"\n        if strength % 32 > 0:\n            raise ValueError(\"Strength should be divisible by 32\")\n        data = os.urandom(strength // 8)\n        return self.to_mnemonic(data, add_checksum=add_checksum)",
  "def to_mnemonic(self, data, add_checksum=True, check_on_curve=True):\n        \"\"\"\n        Convert key data entropy to Mnemonic sentence\n\n        >>> Mnemonic().to_mnemonic('28acfc94465fd2f6774759d6897ec122')\n        'chunk gun celery million wood kite tackle twenty story episode raccoon dutch'\n\n        :param data: Key data entropy\n        :type data: bytes, hexstring\n        :param add_checksum: Included a checksum? Default is True\n        :type add_checksum: bool\n        :param check_on_curve: Check if data integer value is on secp256k1 curve. Should be enabled when not testing and working with crypto\n        :type check_on_curve: bool\n        \n        :return str: Mnemonic passphrase consisting of a space seperated list of words\n        \"\"\"\n        data = to_bytes(data)\n        data_int = int.from_bytes(data, 'big')\n        if check_on_curve and not 0 < data_int < secp256k1_n:\n            raise ValueError(\"Integer value of data should be in secp256k1 domain between 1 and secp256k1_n-1\")\n        if add_checksum:\n            binresult = change_base(data_int, 10, 2, len(data) * 8) + self.checksum(data)\n            wi = change_base(binresult, 2, 2048)\n        else:\n            wi = change_base(data_int, 10, 2048, len(data) // 1.375 + len(data) % 1.375 > 0)\n        return normalize_string(' '.join([self._wordlist[i] for i in wi]))",
  "def to_entropy(self, words, includes_checksum=True):\n        \"\"\"\n        Convert Mnemonic words back to key data entropy\n\n        >>> Mnemonic().to_entropy('chunk gun celery million wood kite tackle twenty story episode raccoon dutch').hex()\n        '28acfc94465fd2f6774759d6897ec122'\n\n\n        :param words: Mnemonic words as string of list of words\n        :type words: str\n        :param includes_checksum: Boolean to specify if checksum is used. Default is True\n        :type includes_checksum: bool\n        \n        :return bytes: Entropy seed\n        \"\"\"\n        words = self.sanitize_mnemonic(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n        wi = []\n        for word in words:\n            wi.append(self._wordlist.index(word))\n        ent_length = int(len(words) * 4/3)\n        ent = change_base(wi, 2048, 256, ent_length, output_even=False)\n        if includes_checksum:\n            binresult = change_base(ent, 256, 2, len(ent) * 4)\n            ent = change_base(binresult[:-len(binresult) // 33], 2, 256, ent_length)\n\n            # Check checksum\n            checksum = binresult[-len(binresult) // 33:]\n            if checksum != self.checksum(ent):\n                raise ValueError(\"Invalid checksum %s for entropy %s\" % (checksum, ent))\n\n        return ent",
  "def detect_language(words):\n        \"\"\"\n        Detect language of given phrase\n\n        >>> Mnemonic().detect_language('chunk gun celery million wood kite tackle twenty story episode raccoon dutch')\n        'english'\n        \n        :param words: List of space separated words\n        :type words: str\n        \n        :return str: Language \n        \"\"\"\n        words = normalize_string(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n\n        wlcount = {}\n        for fn in Path(BCL_INSTALL_DIR, 'wordlist').iterdir():\n            if fn.suffix == \".txt\":\n                with open(os.path.join(str(BCL_INSTALL_DIR), 'wordlist', fn), encoding='utf-8') as f:\n                    wordlist = [w.strip() for w in f.readlines()]\n                    language = fn.name.split('.')[0]\n                    wlcount[language] = 0\n                    for word in words:\n                        if word in wordlist:\n                            wlcount[language] += 1\n        detlang = max(wlcount.keys(), key=(lambda key: wlcount[key]))\n        if not wlcount[detlang]:\n            raise Warning(\"Could not detect language of Mnemonic sentence %s\" % words)\n        return detlang",
  "def sanitize_mnemonic(self, words):\n        \"\"\"\n        Check and convert list of words to utf-8 encoding.\n        \n        Raises an error if unrecognised word is found\n        \n        :param words: List of space separated words\n        :type words: str\n        \n        :return str: Sanitized list of words\n        \"\"\"\n        words = normalize_string(words)\n        language = self.detect_language(words)\n        if isinstance(words, TYPE_TEXT):\n            words = words.split(' ')\n        with Path(BCL_INSTALL_DIR, 'wordlist', '%s.txt' % language).open() as f:\n            wordlist = [w.strip() for w in f.readlines()]\n            for word in words:\n                if word not in wordlist:\n                    raise Warning(\"Unrecognised word %s in mnemonic sentence\" % word.encode('utf8'))\n        return ' '.join(words)",
  "def value_to_satoshi(value, network=None):\n    \"\"\"\n    Convert Value object or value string to the smallest denominator amount as integer\n\n    :param value: Value object, value string as accepted by Value class or numeric value amount\n    :type value: str, int, float, Value\n    :param network: Specify network to validate value string\n    :type network: str, Network\n\n    :return int:\n    \"\"\"\n    if isinstance(value, str):\n        value = Value(value)\n    if isinstance(value, Value):\n        if network and value.network != network:\n            raise ValueError(\"Value uses different network (%s) then supplied network: %s\" % (value.network.name, network))\n        value = value.value_sat\n    return value",
  "class Value:\n    \"\"\"\n    Class to represent and convert cryptocurrency values\n    \"\"\"\n\n    @classmethod\n    def from_satoshi(cls, value, denominator=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Initialize Value class with the smallest denominator as input. Such as represented in script and transactions\n        cryptocurrency values.\n\n        :param value: Amount of Satoshi's / smallest denominator for this network\n        :type value: int\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols.\n        :type denominator: int, float, str\n        :param network: Specify network if not supplied already in the value string\n        :type network: str, Network\n\n        :return Value:\n        \"\"\"\n        if not isinstance(network, Network):\n            network = Network(network)\n        if denominator is None:\n            denominator = network.denominator\n        else:\n            if isinstance(denominator, str):\n                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n                if dens:\n                    denominator = dens[0]\n            value = value * (network.denominator / denominator)\n        return cls(value or 0, denominator, network)\n\n    def __init__(self, value, denominator=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new Value class. Specify value as integer, float or string. If a string is provided\n        the amount, denominator and currency will be extracted if provided\n\n        Examples: Initialize value class\n        >>> Value(10)\n        Value(value=10.00000000000000, denominator=1.00000000, network='bitcoin')\n\n        >>> Value('15 mBTC')\n        Value(value=0.01500000000000, denominator=0.00100000, network='bitcoin')\n\n        >>> Value('10 sat')\n        Value(value=0.00000010000000, denominator=0.00000001, network='bitcoin')\n\n        >>> Value('1 doge')\n        Value(value=1.00000000000000, denominator=1.00000000, network='dogecoin')\n\n        >>> Value(500, 'm')\n        Value(value=0.50000000000000, denominator=0.00100000, network='bitcoin')\n\n        >>> Value(500, 0.001)\n        Value(value=0.50000000000000, denominator=0.00100000, network='bitcoin')\n\n        All frequently used arithmetic, comparision and logical operators can be used on the Value object. So you can compare Value object, add them together, divide or multiply them, etc.\n\n        Values need to use the same network / currency if you work with multiple Value objects. I.e. Value('1 BTC') + Value('1 LTC') raises an error.\n\n        # Examples: Value operators\n        >>> Value('50000 sat') == Value('5000 fin')  # 1 Satoshi equals 10 Finney, see https://en.bitcoin.it/wiki/Units\n        True\n\n        >>> Value('1 btc') > Value('2 btc')\n        False\n\n        >>> Value('1000 LTC') / 5\n        Value(value=200.00000000000000, denominator=1.00000000, network='litecoin')\n\n        >>> Value('0.002 BTC') + 0.02\n        Value(value=0.02200000000000, denominator=1.00000000, network='bitcoin')\n\n        The Value class can be represented in several formats.\n\n        # Examples: Format Value class\n        >>> int(Value(\"10.1 BTC\"))\n        10\n\n        >>> float(Value(\"10.1 BTC\"))\n        10.1\n\n        >>> round(Value(\"10.123 BTC\"), 2).str()\n        '10.12000000 BTC'\n\n        >>> hex(Value(\"10.1 BTC\"))\n        '0x3c336080'\n\n        :param value: Value as integer, float or string. Numeric values must be supllied in smallest denominator such as Satoshi's. String values must be in the format: <value> [<denominator>][<currency_symbol>]\n        :type value: int, float, str\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols.\n        :type denominator: int, float, str\n        :param network: Specify network if not supplied already in the value string\n        :type network: str, Network\n\n        \"\"\"\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        if isinstance(denominator, str):\n            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n            if dens:\n                denominator = dens[0]\n        den_arg = denominator\n\n        if isinstance(value, str):\n            value_items = value.split()\n            value = value_items[0]\n            cur_code = self.network.currency_code\n            den_input = 1\n            if len(value_items) > 1:\n                cur_code = value_items[1]\n            network_names = [n for n in NETWORK_DEFINITIONS if\n                             NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]\n            if network_names:\n                self.network = Network(network_names[0])\n                self.currency = cur_code\n            else:\n                for den, symb in NETWORK_DENOMINATORS.items():\n                    if len(symb) and cur_code[:len(symb)] == symb:\n                        cur_code = cur_code[len(symb):]\n                        network_names = [n for n in NETWORK_DEFINITIONS if\n                                         NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]\n                        if network_names:\n                            self.network = Network(network_names[0])\n                            self.currency = cur_code\n                        elif len(cur_code):\n                            raise ValueError(\"Currency symbol not recognised\")\n                        den_input = den\n                        break\n            self.value = float(value) * den_input\n            self.denominator = den_input if den_arg is None else den_arg\n        else:\n            self.denominator = den_arg or 1.0\n            self.value = float(value) * self.denominator\n\n    def __str__(self):\n        return self.str()\n\n    def __repr__(self):\n        return \"Value(value=%.14f, denominator=%.8f, network='%s')\" % \\\n               (self.value, self.denominator, self.network.name)\n\n    def __int__(self):\n        return int(self.value)\n\n    def __float__(self):\n        if self.value > self.network.denominator:\n            return round(self.value, -int(math.log10(self.network.denominator)))\n        else:\n            return self.value\n\n    def __lt__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value < other.value\n\n    def __le__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value <= other.value\n\n    def __eq__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot compare values from different networks\")\n            return self.value == other.value\n        else:\n            other = Value(other)\n            return self.value == other.value and self.network == other.network\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __ge__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value >= other.value\n\n    def __gt__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value > other.value\n\n    def __add__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value + other) / self.denominator, self.denominator, self.network)\n\n    def __iadd__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value + other) / self.denominator, self.denominator, self.network)\n\n    def __isub__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value - other) / self.denominator, self.denominator, self.network)\n\n    def __sub__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value - other) / self.denominator, self.denominator, self.network)\n\n    def __mul__(self, other):\n        return Value((self.value * other) / self.denominator, self.denominator, self.network)\n\n    def __truediv__(self, other):\n        return Value((self.value / other) / self.denominator, self.denominator, self.network)\n\n    def __floordiv__(self, other):\n        return Value(((self.value / self.denominator) // other), self.denominator, self.network)\n\n    def __round__(self, n=0):\n        val = round(self.value / self.denominator, n) * self.denominator\n        return Value(val, self.denominator, self.network)\n\n    def __index__(self):\n        return self.value_sat\n\n    def str(self, denominator=None, decimals=None, currency_repr='code'):\n        \"\"\"\n        Get string representation of Value with requested denominator and number of decimals.\n\n        >>> Value(1200000, 'sat').str('m')  # milli Bitcoin\n        '12.00000 mBTC'\n\n        >>> Value(12000.3, 'sat').str(1)  # Use denominator = 1 for Bitcoin\n        '0.00012000 BTC'\n\n        >>> Value(12000, 'sat').str('auto')\n        '120.00 \u00b5BTC'\n\n        >>> Value(0.005).str('m')\n        '5.00000 mBTC'\n\n        >>> Value(12000, 'sat').str('auto', decimals=0)\n        '120 \u00b5BTC'\n\n        >>> Value('13000000 Doge').str('auto')  # Yeah, mega Dogecoins...\n        '13.00000000 MDOGE'\n\n        >>> Value('2100000000').str('auto')\n        '2.10000000 GBTC'\n\n        >>> Value('1.5 BTC').str(currency_repr='symbol')\n        '1.50000000 \u20bf'\n\n        >>> Value('1.5 BTC').str(currency_repr='name')\n        '1.50000000 bitcoins'\n\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols. If not provided the default self.denominator value is used. Use value 'auto' to automatically determine the best denominator for human readability.\n        :type denominator: int, float, str\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: bitcoins, symbol: \u20bf\n        :type currency_repr: str\n\n        :return str:\n        \"\"\"\n        if denominator is None:\n            denominator = self.denominator\n        elif denominator == 'auto':\n            # First try denominator=1 and smallest denominator (satoshi)\n            if 0.001 <= self.value < 1000:\n                denominator = 1\n            elif 1 <= self.value / self.network.denominator < 1000:\n                denominator = self.network.denominator\n            else:  # Try other frequently used denominators\n                for den, symb in NETWORK_DENOMINATORS.items():\n                    if symb in ['n', 'fin', 'da', 'c', 'd', 'h']:\n                        continue\n                    if 1 <= self.value / den < 1000:\n                        denominator = den\n        elif isinstance(denominator, str):\n            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator[:len(symb)] and len(symb)]\n            if len(dens) > 1:\n                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n            if dens:\n                denominator = dens[0]\n        if denominator in NETWORK_DENOMINATORS:\n            den_symb = NETWORK_DENOMINATORS[denominator]\n        else:\n            raise ValueError(\"Denominator not found in NETWORK_DENOMINATORS definition\")\n\n        if decimals is None:\n            decimals = -int(math.log10(self.network.denominator / denominator))\n            if decimals > 8:\n                decimals = 8\n        if decimals < 0:\n            decimals = 0\n        balance = round(self.value / denominator, decimals)\n        cur_code = self.network.currency_code\n        if currency_repr == 'symbol':\n            cur_code = self.network.currency_symbol\n        if currency_repr == 'name':\n            cur_code = self.network.currency_name_plural\n        if 'sat' in den_symb and self.network.name == 'bitcoin':\n            cur_code = ''\n        return (\"%%.%df %%s%%s\" % decimals) % (balance, den_symb, cur_code)\n\n    def str_unit(self, decimals=None, currency_repr='code'):\n        \"\"\"\n        String representation of this Value. Wrapper for the :func:`str` method, but always uses 1 as denominator, meaning main denominator such as BTC, LTC.\n\n        >>> Value('12000 sat').str_unit()\n        '0.00012000 BTC'\n\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: \u20bf\n        :type currency_repr: str\n        :return str:\n        \"\"\"\n        return self.str(1, decimals, currency_repr)\n\n    def str_auto(self, decimals=None, currency_repr='code'):\n        \"\"\"\n        String representation of this Value. Wrapper for the :func:`str` method, but automatically determines the denominator depending on the value.\n\n        >>> Value('0.0000012 BTC').str_auto()\n        '120 sat'\n\n        >>> Value('0.0005 BTC').str_auto()\n        '500.00 \u00b5BTC'\n\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: \u20bf\n        :type currency_repr: str\n        :return str:\n        \"\"\"\n\n        return self.str('auto', decimals, currency_repr)\n\n    @property\n    def value_sat(self):\n        \"\"\"\n        Value in the smallest denominator, i.e. Satoshi for the Bitcoin network\n\n        :return int:\n        \"\"\"\n        return round(self.value / self.network.denominator)\n\n    def to_bytes(self, length=8, byteorder='little'):\n        \"\"\"\n        Representation of value_sat (value in the smallest denominator: satoshi's) as bytes string. Used for script or transaction serialization.\n\n        >>> Value('1 sat').to_bytes()\n        b'\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00'\n\n        :param length: Length of bytes string to return, default is 8 bytes\n        :type length: int\n        :param byteorder: Order of bytes: little or big endian. Default is 'little'\n        :type byteorder: str\n\n        :return bytes:\n        \"\"\"\n        return self.value_sat.to_bytes(length, byteorder)\n\n    def to_hex(self, length=16, byteorder='little'):\n        \"\"\"\n        Representation of value_sat (value in the smallest denominator: satoshi's) as hexadecimal string.\n\n        >>> Value('15 sat').to_hex()\n        '0f00000000000000'\n\n        :param length: Length of hexadecimal string to return, default is 16 characters\n        :type length: int\n        :param byteorder: Order of bytes: little or big endian. Default is 'little'\n        :type byteorder: str\n        :return:\n        \"\"\"\n        return self.value_sat.to_bytes(length // 2, byteorder).hex()",
  "def from_satoshi(cls, value, denominator=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Initialize Value class with the smallest denominator as input. Such as represented in script and transactions\n        cryptocurrency values.\n\n        :param value: Amount of Satoshi's / smallest denominator for this network\n        :type value: int\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols.\n        :type denominator: int, float, str\n        :param network: Specify network if not supplied already in the value string\n        :type network: str, Network\n\n        :return Value:\n        \"\"\"\n        if not isinstance(network, Network):\n            network = Network(network)\n        if denominator is None:\n            denominator = network.denominator\n        else:\n            if isinstance(denominator, str):\n                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n                if dens:\n                    denominator = dens[0]\n            value = value * (network.denominator / denominator)\n        return cls(value or 0, denominator, network)",
  "def __init__(self, value, denominator=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new Value class. Specify value as integer, float or string. If a string is provided\n        the amount, denominator and currency will be extracted if provided\n\n        Examples: Initialize value class\n        >>> Value(10)\n        Value(value=10.00000000000000, denominator=1.00000000, network='bitcoin')\n\n        >>> Value('15 mBTC')\n        Value(value=0.01500000000000, denominator=0.00100000, network='bitcoin')\n\n        >>> Value('10 sat')\n        Value(value=0.00000010000000, denominator=0.00000001, network='bitcoin')\n\n        >>> Value('1 doge')\n        Value(value=1.00000000000000, denominator=1.00000000, network='dogecoin')\n\n        >>> Value(500, 'm')\n        Value(value=0.50000000000000, denominator=0.00100000, network='bitcoin')\n\n        >>> Value(500, 0.001)\n        Value(value=0.50000000000000, denominator=0.00100000, network='bitcoin')\n\n        All frequently used arithmetic, comparision and logical operators can be used on the Value object. So you can compare Value object, add them together, divide or multiply them, etc.\n\n        Values need to use the same network / currency if you work with multiple Value objects. I.e. Value('1 BTC') + Value('1 LTC') raises an error.\n\n        # Examples: Value operators\n        >>> Value('50000 sat') == Value('5000 fin')  # 1 Satoshi equals 10 Finney, see https://en.bitcoin.it/wiki/Units\n        True\n\n        >>> Value('1 btc') > Value('2 btc')\n        False\n\n        >>> Value('1000 LTC') / 5\n        Value(value=200.00000000000000, denominator=1.00000000, network='litecoin')\n\n        >>> Value('0.002 BTC') + 0.02\n        Value(value=0.02200000000000, denominator=1.00000000, network='bitcoin')\n\n        The Value class can be represented in several formats.\n\n        # Examples: Format Value class\n        >>> int(Value(\"10.1 BTC\"))\n        10\n\n        >>> float(Value(\"10.1 BTC\"))\n        10.1\n\n        >>> round(Value(\"10.123 BTC\"), 2).str()\n        '10.12000000 BTC'\n\n        >>> hex(Value(\"10.1 BTC\"))\n        '0x3c336080'\n\n        :param value: Value as integer, float or string. Numeric values must be supllied in smallest denominator such as Satoshi's. String values must be in the format: <value> [<denominator>][<currency_symbol>]\n        :type value: int, float, str\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols.\n        :type denominator: int, float, str\n        :param network: Specify network if not supplied already in the value string\n        :type network: str, Network\n\n        \"\"\"\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        if isinstance(denominator, str):\n            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n            if dens:\n                denominator = dens[0]\n        den_arg = denominator\n\n        if isinstance(value, str):\n            value_items = value.split()\n            value = value_items[0]\n            cur_code = self.network.currency_code\n            den_input = 1\n            if len(value_items) > 1:\n                cur_code = value_items[1]\n            network_names = [n for n in NETWORK_DEFINITIONS if\n                             NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]\n            if network_names:\n                self.network = Network(network_names[0])\n                self.currency = cur_code\n            else:\n                for den, symb in NETWORK_DENOMINATORS.items():\n                    if len(symb) and cur_code[:len(symb)] == symb:\n                        cur_code = cur_code[len(symb):]\n                        network_names = [n for n in NETWORK_DEFINITIONS if\n                                         NETWORK_DEFINITIONS[n]['currency_code'].upper() == cur_code.upper()]\n                        if network_names:\n                            self.network = Network(network_names[0])\n                            self.currency = cur_code\n                        elif len(cur_code):\n                            raise ValueError(\"Currency symbol not recognised\")\n                        den_input = den\n                        break\n            self.value = float(value) * den_input\n            self.denominator = den_input if den_arg is None else den_arg\n        else:\n            self.denominator = den_arg or 1.0\n            self.value = float(value) * self.denominator",
  "def __str__(self):\n        return self.str()",
  "def __repr__(self):\n        return \"Value(value=%.14f, denominator=%.8f, network='%s')\" % \\\n               (self.value, self.denominator, self.network.name)",
  "def __int__(self):\n        return int(self.value)",
  "def __float__(self):\n        if self.value > self.network.denominator:\n            return round(self.value, -int(math.log10(self.network.denominator)))\n        else:\n            return self.value",
  "def __lt__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value < other.value",
  "def __le__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value <= other.value",
  "def __eq__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot compare values from different networks\")\n            return self.value == other.value\n        else:\n            other = Value(other)\n            return self.value == other.value and self.network == other.network",
  "def __ne__(self, other):\n        return not self.__eq__(other)",
  "def __ge__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value >= other.value",
  "def __gt__(self, other):\n        if self.network != other.network:\n            raise ValueError(\"Cannot compare values from different networks\")\n        return self.value > other.value",
  "def __add__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value + other) / self.denominator, self.denominator, self.network)",
  "def __iadd__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value + other) / self.denominator, self.denominator, self.network)",
  "def __isub__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value - other) / self.denominator, self.denominator, self.network)",
  "def __sub__(self, other):\n        if isinstance(other, Value):\n            if self.network != other.network:\n                raise ValueError(\"Cannot calculate with values from different networks\")\n            other = other.value\n        return Value((self.value - other) / self.denominator, self.denominator, self.network)",
  "def __mul__(self, other):\n        return Value((self.value * other) / self.denominator, self.denominator, self.network)",
  "def __truediv__(self, other):\n        return Value((self.value / other) / self.denominator, self.denominator, self.network)",
  "def __floordiv__(self, other):\n        return Value(((self.value / self.denominator) // other), self.denominator, self.network)",
  "def __round__(self, n=0):\n        val = round(self.value / self.denominator, n) * self.denominator\n        return Value(val, self.denominator, self.network)",
  "def __index__(self):\n        return self.value_sat",
  "def str(self, denominator=None, decimals=None, currency_repr='code'):\n        \"\"\"\n        Get string representation of Value with requested denominator and number of decimals.\n\n        >>> Value(1200000, 'sat').str('m')  # milli Bitcoin\n        '12.00000 mBTC'\n\n        >>> Value(12000.3, 'sat').str(1)  # Use denominator = 1 for Bitcoin\n        '0.00012000 BTC'\n\n        >>> Value(12000, 'sat').str('auto')\n        '120.00 \u00b5BTC'\n\n        >>> Value(0.005).str('m')\n        '5.00000 mBTC'\n\n        >>> Value(12000, 'sat').str('auto', decimals=0)\n        '120 \u00b5BTC'\n\n        >>> Value('13000000 Doge').str('auto')  # Yeah, mega Dogecoins...\n        '13.00000000 MDOGE'\n\n        >>> Value('2100000000').str('auto')\n        '2.10000000 GBTC'\n\n        >>> Value('1.5 BTC').str(currency_repr='symbol')\n        '1.50000000 \u20bf'\n\n        >>> Value('1.5 BTC').str(currency_repr='name')\n        '1.50000000 bitcoins'\n\n        :param denominator: Denominator as integer or string. Such as 0.001 or m for milli, 1000 or k for kilo, etc. See NETWORK_DENOMINATORS for list of available denominator symbols. If not provided the default self.denominator value is used. Use value 'auto' to automatically determine the best denominator for human readability.\n        :type denominator: int, float, str\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: bitcoins, symbol: \u20bf\n        :type currency_repr: str\n\n        :return str:\n        \"\"\"\n        if denominator is None:\n            denominator = self.denominator\n        elif denominator == 'auto':\n            # First try denominator=1 and smallest denominator (satoshi)\n            if 0.001 <= self.value < 1000:\n                denominator = 1\n            elif 1 <= self.value / self.network.denominator < 1000:\n                denominator = self.network.denominator\n            else:  # Try other frequently used denominators\n                for den, symb in NETWORK_DENOMINATORS.items():\n                    if symb in ['n', 'fin', 'da', 'c', 'd', 'h']:\n                        continue\n                    if 1 <= self.value / den < 1000:\n                        denominator = den\n        elif isinstance(denominator, str):\n            dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator[:len(symb)] and len(symb)]\n            if len(dens) > 1:\n                dens = [den for den, symb in NETWORK_DENOMINATORS.items() if symb == denominator]\n            if dens:\n                denominator = dens[0]\n        if denominator in NETWORK_DENOMINATORS:\n            den_symb = NETWORK_DENOMINATORS[denominator]\n        else:\n            raise ValueError(\"Denominator not found in NETWORK_DENOMINATORS definition\")\n\n        if decimals is None:\n            decimals = -int(math.log10(self.network.denominator / denominator))\n            if decimals > 8:\n                decimals = 8\n        if decimals < 0:\n            decimals = 0\n        balance = round(self.value / denominator, decimals)\n        cur_code = self.network.currency_code\n        if currency_repr == 'symbol':\n            cur_code = self.network.currency_symbol\n        if currency_repr == 'name':\n            cur_code = self.network.currency_name_plural\n        if 'sat' in den_symb and self.network.name == 'bitcoin':\n            cur_code = ''\n        return (\"%%.%df %%s%%s\" % decimals) % (balance, den_symb, cur_code)",
  "def str_unit(self, decimals=None, currency_repr='code'):\n        \"\"\"\n        String representation of this Value. Wrapper for the :func:`str` method, but always uses 1 as denominator, meaning main denominator such as BTC, LTC.\n\n        >>> Value('12000 sat').str_unit()\n        '0.00012000 BTC'\n\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: \u20bf\n        :type currency_repr: str\n        :return str:\n        \"\"\"\n        return self.str(1, decimals, currency_repr)",
  "def str_auto(self, decimals=None, currency_repr='code'):\n        \"\"\"\n        String representation of this Value. Wrapper for the :func:`str` method, but automatically determines the denominator depending on the value.\n\n        >>> Value('0.0000012 BTC').str_auto()\n        '120 sat'\n\n        >>> Value('0.0005 BTC').str_auto()\n        '500.00 \u00b5BTC'\n\n        :param decimals: Number of decimals to use\n        :type decimals: float\n        :param currency_repr: Representation of currency. I.e. code: BTC, name: Bitcoin, symbol: \u20bf\n        :type currency_repr: str\n        :return str:\n        \"\"\"\n\n        return self.str('auto', decimals, currency_repr)",
  "def value_sat(self):\n        \"\"\"\n        Value in the smallest denominator, i.e. Satoshi for the Bitcoin network\n\n        :return int:\n        \"\"\"\n        return round(self.value / self.network.denominator)",
  "def to_bytes(self, length=8, byteorder='little'):\n        \"\"\"\n        Representation of value_sat (value in the smallest denominator: satoshi's) as bytes string. Used for script or transaction serialization.\n\n        >>> Value('1 sat').to_bytes()\n        b'\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00'\n\n        :param length: Length of bytes string to return, default is 8 bytes\n        :type length: int\n        :param byteorder: Order of bytes: little or big endian. Default is 'little'\n        :type byteorder: str\n\n        :return bytes:\n        \"\"\"\n        return self.value_sat.to_bytes(length, byteorder)",
  "def to_hex(self, length=16, byteorder='little'):\n        \"\"\"\n        Representation of value_sat (value in the smallest denominator: satoshi's) as hexadecimal string.\n\n        >>> Value('15 sat').to_hex()\n        '0f00000000000000'\n\n        :param length: Length of hexadecimal string to return, default is 16 characters\n        :type length: int\n        :param byteorder: Order of bytes: little or big endian. Default is 'little'\n        :type byteorder: str\n        :return:\n        \"\"\"\n        return self.value_sat.to_bytes(length // 2, byteorder).hex()",
  "class Block:\n\n    def __init__(self, block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions=None,\n                 height=None, confirmations=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new Block object with provided parameters.\n\n        >>> b = Block('0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709', version=0x20000000, prev_block='0000000000000000000f9578cda278ae7a2002e50d8e6079d11e2ea1f672b483', merkle_root='20e86f03c24c53c12014264d0e405e014e15a02ad02c174f017ee040750f8d9d', time=1592848036, bits=387044594, nonce=791719079)\n        >>> b\n        <Block(0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709, None, transactions: 0)>\n\n        :param block_hash: Hash value of serialized block\n        :type block_hash: bytes, str\n        :param version: Block version to indicate which software / BIPs are used to create block\n        :type version: bytes, str, in\n        :param prev_block: Hash of previous block in blockchain\n        :type prev_block: bytes, str\n        :param merkle_root: Merkle root. Top item merkle chain tree to validate transactions.\n        :type merkle_root: bytes, str\n        :param time: Timestamp of time when block was included in blockchain\n        :type time: int, bytes\n        :param bits: Bits are used to indicate target / difficulty\n        :type bits: bytes, str, int\n        :param nonce: Number used once, n-once is used to create randomness for miners to find a suitable block hash\n        :type nonce: bytes, str, int\n        :param transactions: List of transaction included in this block. As list of transaction objects or list of transaction IDs strings\n        :type transactions: list of Transaction, list of str\n        :param height: Height of this block in the Blockchain\n        :type height: int\n        :param confirmations: Number of confirmations for this block, or depth. Increased when new blocks are found\n        :type confirmations: int\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n        \"\"\"\n\n        self.block_hash = to_bytes(block_hash)\n        if isinstance(version, int):\n            self.version = version.to_bytes(4, byteorder='big')\n            self.version_int = version\n        else:\n            self.version = to_bytes(version)\n            self.version_int = 0 if not self.version else int.from_bytes(self.version, 'big')\n        self.prev_block = to_bytes(prev_block)\n        self.merkle_root = to_bytes(merkle_root)\n        self.time = time\n        if not isinstance(time, int):\n            self.time = int.from_bytes(time, 'big')\n        if isinstance(bits, int):\n            self.bits = bits.to_bytes(4, 'big')\n            self.bits_int = bits\n        else:\n            self.bits = to_bytes(bits)\n            self.bits_int = 0 if not self.bits else int.from_bytes(self.bits, 'big')\n        if isinstance(nonce, int):\n            self.nonce = nonce.to_bytes(4, 'big')\n            self.nonce_int = nonce\n        else:\n            self.nonce = to_bytes(nonce)\n            self.nonce_int = 0 if not self.nonce else int.from_bytes(self.nonce, 'big')\n        self.transactions = transactions\n        self.transactions_dict = []\n        if self.transactions is None:\n            self.transactions = []\n        self.txs_data = None\n        self.confirmations = confirmations\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.tx_count = 0\n        self.page = 1\n        self.limit = 0\n        self.height = height\n        self.total_in = 0\n        self.total_out = 0\n        self.size = 0\n        if self.transactions and len(self.transactions) and isinstance(self.transactions[0], Transaction) \\\n                and self.version_int > 1:\n            # first bytes of unlocking script of coinbase transaction contains block height (BIP0034)\n            if self.transactions[0].coinbase and self.transactions[0].inputs[0].unlocking_script:\n                calc_height = int.from_bytes(self.transactions[0].inputs[0].unlocking_script[1:4] + b'\\x00', 'little')\n                if height and calc_height != height and height > 227835:\n                    raise ValueError(\"Specified block height %d is different than calculated block height according to \"\n                                     \"BIP0034\" % height)\n                self.height = calc_height\n\n    def check_proof_of_work(self):\n        \"\"\"\n        Check proof of work for this block. Block hash must be below target.\n\n        This library is not optimised for mining, but you can use this for testing or learning purposes.\n\n        >>> b = Block('0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709', version=0x20000000, prev_block='0000000000000000000f9578cda278ae7a2002e50d8e6079d11e2ea1f672b483', merkle_root='20e86f03c24c53c12014264d0e405e014e15a02ad02c174f017ee040750f8d9d', time=1592848036, bits=387044594, nonce=791719079)\n        >>> b.check_proof_of_work()\n        True\n\n        :return bool:\n        \"\"\"\n        if not self.block_hash or not self.bits:\n            return False\n        if int.from_bytes(self.block_hash, 'big') < self.target:\n            return True\n        return False\n\n    def __repr__(self):\n        return \"<Block(%s, %s, transactions: %s)>\" % (self.block_hash.hex(), self.height, self.tx_count)\n\n    @classmethod\n    def parse(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw: Raw serialize block\n        :type raw: BytesIO, bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n\n        if isinstance(raw, bytes):\n            b = cls.parse_bytesio(BytesIO(raw), block_hash, height, parse_transactions, limit, network)\n            b.size = len(raw)\n            return b\n        else:\n            return cls.parse_bytesio(raw, block_hash, height, parse_transactions, limit, network)\n\n    @classmethod\n    def parse_bytes(cls, raw_bytes, block_hash=None, height=None, parse_transactions=False, limit=0,\n                    network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw_bytes: Raw serialize block\n        :type raw_bytes: bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n\n        raw_bytesio = BytesIO(raw_bytes)\n        b = cls.parse_bytesio(raw_bytesio, block_hash, height, parse_transactions, limit, network)\n        b.size = len(raw_bytes)\n        return b\n\n    @classmethod\n    def parse_bytesio(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0,\n                      network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in BytesIO format\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw: Raw serialize block\n        :type raw: BytesIO\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n        block_header = raw.read(80)\n        block_hash_calc = double_sha256(block_header)[::-1]\n        if not block_hash:\n            block_hash = block_hash_calc\n        elif block_hash != block_hash_calc:\n            raise ValueError(\"Provided block hash does not correspond to calculated block hash %s\" %\n                             block_hash_calc.hex())\n\n        raw.seek(0)\n        version = raw.read(4)[::-1]\n        prev_block = raw.read(32)[::-1]\n        merkle_root = raw.read(32)[::-1]\n        time = raw.read(4)[::-1]\n        bits = raw.read(4)[::-1]\n        nonce = raw.read(4)[::-1]\n        tx_count = read_varbyteint(raw)\n        tx_start_pos = raw.tell()\n        txs_data_size = raw.seek(0, 2)\n        raw.seek(tx_start_pos)\n        transactions = []\n\n        while parse_transactions and raw.tell() < txs_data_size:\n            if limit != 0 and len(transactions) >= limit:\n                break\n            t = Transaction.parse_bytesio(raw, strict=False)\n            transactions.append(t)\n            # TODO: verify transactions, need input value from previous txs\n            # if verify and not t.verify():\n            #     raise ValueError(\"Could not verify transaction %s in block %s\" % (t.txid, block_hash))\n\n        if parse_transactions and limit == 0 and tx_count != len(transactions):\n            raise ValueError(\"Number of found transactions %d is not equal to expected number %d\" %\n                             (len(transactions), tx_count))\n\n        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,\n                    network=network)\n        block.txs_data = raw\n        block.tx_count = tx_count\n        return block\n\n    @classmethod\n    @deprecated\n    def from_raw(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):  # pragma: no cover\n        \"\"\"\n        Create Block object from raw serialized block in bytes.\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n        \n        :param raw: Raw serialize block\n        :type raw: bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n        block_hash_calc = double_sha256(raw[:80])[::-1]\n        if not block_hash:\n            block_hash = block_hash_calc\n        elif block_hash != block_hash_calc:\n            raise ValueError(\"Provided block hash does not correspond to calculated block hash %s\" %\n                             block_hash_calc.hex())\n\n        version = raw[0:4][::-1]\n        prev_block = raw[4:36][::-1]\n        merkle_root = raw[36:68][::-1]\n        time = raw[68:72][::-1]\n        bits = raw[72:76][::-1]\n        nonce = raw[76:80][::-1]\n        tx_count, size = varbyteint_to_int(raw[80:89])\n        txs_data = BytesIO(raw[80+size:])\n\n        # Parse coinbase transaction so we can extract extra information\n        # transactions = [Transaction.parse(txs_data, network=network)]\n        # txs_data = BytesIO(txs_data[transactions[0].size:])\n        # block_txs_data = txs_data.read()\n        txs_data_size = txs_data.seek(0, 2)\n        txs_data.seek(0)\n        transactions = []\n\n        while parse_transactions and txs_data and txs_data.tell() < txs_data_size:\n            if limit != 0 and len(transactions) >= limit:\n                break\n            t = Transaction.parse_bytesio(txs_data, strict=False)\n            transactions.append(t)\n            # t = transaction_deserialize(txs_data, network=network, check_size=False)\n            # transactions.append(t)\n            # txs_data = txs_data[t.size:]\n            # TODO: verify transactions, need input value from previous txs\n            # if verify and not t.verify():\n            #     raise ValueError(\"Could not verify transaction %s in block %s\" % (t.txid, block_hash))\n\n        if parse_transactions and limit == 0 and tx_count != len(transactions):\n            raise ValueError(\"Number of found transactions %d is not equal to expected number %d\" %\n                             (len(transactions), tx_count))\n\n        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,\n                    network=network)\n        block.txs_data = txs_data\n        block.tx_count = tx_count\n        return block\n\n    def parse_transactions(self, limit=0):\n        \"\"\"\n        Parse raw transactions from Block, if transaction data is available in txs_data attribute. Creates\n        Transaction objects in Block.\n\n        :param limit: Maximum number of transactions to parse\n        :type limit: int\n\n        :return:\n        \"\"\"\n        n = 0\n        while self.txs_data and (limit == 0 or n < limit) and len(self.transactions) < self.tx_count:\n            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False\n            self.transactions.append(t)\n            n += 1\n\n    def parse_transactions_dict(self):\n        \"\"\"\n        Parse raw transactions from Block, if transaction data is available in txs_data attribute. Returns a list of\n        transactions dictionaries.\n\n        Only works if transactions are not parsed yet with :func:`parse_transactions` or parse_transactions=True when\n        creating a new block object.\n\n        :return:\n        \"\"\"\n        transactions_dict = []\n        txs_data_orig = deepcopy(self.txs_data)\n        while self.txs_data and len(self.transactions) < self.tx_count:\n            tx = self.parse_transaction_dict()\n            if not tx:\n                break\n            transactions_dict.append(tx)\n        self.txs_data = txs_data_orig\n        return transactions_dict\n            \n    def parse_transaction(self):\n        \"\"\"\n        Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add\n        Transaction object in Block and return the transaction\n\n        :return Tranasaction:\n        \"\"\"\n        if self.txs_data and len(self.transactions) < self.tx_count:\n            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False\n            self.transactions.append(t)\n            return t\n        return False\n\n    def parse_transaction_dict(self):\n        \"\"\"\n        Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add\n        Transaction object in Block and return the transaction\n\n        :return Transaction:\n        \"\"\"\n        if self.txs_data and len(self.transactions) < self.tx_count:\n            tx = {'height': self.height, 'coinbase': False, 'flag': None, 'witness_type': 'legacy',\n                  'version': self.txs_data.read(4)[::-1]}\n            if not tx['version']:\n                return False\n            raw_flag = b''\n            if self.txs_data.read(1) == b'\\0':\n                flag = self.txs_data.read(1)\n                if flag == b'\\1':\n                    tx['witness_type'] = 'segwit'\n                raw_flag += b'\\0\\1'\n            else:\n                self.txs_data.seek(-1, 1)\n\n            n_inputs, raw_n_inputs = read_varbyteint_return(self.txs_data)\n\n            inputs = []\n            inputs_raw = b''\n            for n in range(0, n_inputs):\n                inp = {'prev_txid': self.txs_data.read(32)[::-1]}\n                if len(inp['prev_txid']) != 32:\n                    raise Exception(\"Input transaction hash not found. Probably malformed self.txs_data transaction\")\n                inp['output_n'] = self.txs_data.read(4)[::-1]\n                unlocking_script_size, unlocking_script_size_raw = read_varbyteint_return(self.txs_data)\n                inp['unlocking_script'] = self.txs_data.read(unlocking_script_size)\n                inp['inp_type'] = 'legacy'\n                if tx['witness_type'] == 'segwit' and not unlocking_script_size:\n                    inp['inp_type'] = 'segwit'\n                inp['sequence_number'] = self.txs_data.read(4)\n                tx['coinbase'] = False\n                if inp['prev_txid'] == 32 * b'\\0':\n                    tx['coinbase'] = True\n                inputs.append(inp)\n                inputs_raw += \\\n                    inp['prev_txid'][::-1] + inp['output_n'][::-1] + unlocking_script_size_raw + \\\n                    inp['unlocking_script'] + inp['sequence_number']\n            tx['inputs'] = inputs\n\n            outputs = []\n            outputs_raw = b''\n            n_outputs, raw_n_outputs = read_varbyteint_return(self.txs_data)\n            tx['output_total'] = 0\n            for n in range(0, n_outputs):\n                outp = {}\n                outp_value = self.txs_data.read(8)\n                outp['value'] = int.from_bytes(outp_value[::-1], 'big')\n                lock_script_size, lock_script_size_raw = read_varbyteint_return(self.txs_data)\n                outp['lock_script'] = self.txs_data.read(lock_script_size)\n                outputs.append(outp)\n                outp['output_n'] = n\n                tx['output_total'] += outp['value']\n                outputs_raw += outp_value + lock_script_size_raw + outp['lock_script']\n            if not outputs:\n                raise Exception(\"Error no outputs found in this transaction\")\n            tx['outputs'] = outputs\n\n            witnesses_raw = b''\n            if tx['witness_type'] == 'segwit':\n                for n in range(0, len(inputs)):\n                    n_items, raw_n_items = read_varbyteint_return(self.txs_data)\n                    witnesses_raw += raw_n_items\n                    if not n_items:\n                        continue\n                    # script = Script()\n                    inputs[n]['witnesses'] = []\n                    for m in range(0, n_items):\n                        item_size, raw_item_size = read_varbyteint_return(self.txs_data)\n                        witnesses_raw += raw_item_size\n                        witness = self.txs_data.read(item_size)\n                        witnesses_raw += witness\n                        inputs[n]['witnesses'].append(witness)\n\n            tx_locktime = self.txs_data.read(4)\n            tx['locktime'] = int.from_bytes(tx_locktime[::-1], 'big')\n            tx['rawtx'] = tx['version'][::-1] + raw_flag + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw + \\\n                          witnesses_raw + tx_locktime\n            tx['txid'] = double_sha256(tx['version'][::-1] + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw\n                                       + tx_locktime)[::-1]\n            tx['size'] = len(tx['rawtx'])\n            # TODO: tx['vsize'] = len(tx['rawtx'])\n            return tx\n        return False\n\n    def as_dict(self):\n        \"\"\"\n        Get representation of current Block as dictionary.\n\n        :return dict:\n        \"\"\"\n        return {\n            'block_hash': self.block_hash.hex(),\n            'height': self.height,\n            'version': self.version_int,\n            'prev_block': None if not self.prev_block else self.prev_block.hex(),\n            'merkle_root': self.merkle_root.hex(),\n            'timestamp': self.time,\n            'bits': self.bits_int,\n            'nonce': self.nonce_int,\n            'target': self.target_hex,\n            'difficulty': self.difficulty,\n            'tx_count': self.tx_count,\n            'transactions': self.transactions,\n            'confirmations': self.confirmations\n        }\n\n    @property\n    def target(self):\n        \"\"\"\n        Block target calculated from block's bits. Block hash must be below this target. Used to calculate\n        block difficulty.\n\n        :return int:\n        \"\"\"\n        if not self.bits:\n            return 0\n        exponent = self.bits[0]\n        coefficient = int.from_bytes(b'\\x00' + self.bits[1:], 'big')\n        return coefficient * 256 ** (exponent - 3)\n\n    @property\n    def target_hex(self):\n        \"\"\"\n        Block target in hexadecimal string of 64 characters.\n\n        :return str:\n        \"\"\"\n        if not self.bits:\n            return ''\n        return hex(int(self.target))[2:].zfill(64)\n\n    @property\n    def difficulty(self):\n        \"\"\"\n        Block difficulty calculated from bits / target. Human readable representation of block's target.\n\n        Genesis block has difficulty of 1.0\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.difficulty\n        1.0\n\n        :return float:\n        \"\"\"\n        if not self.bits:\n            return 0\n        return 0xffff * 256 ** (0x1d - 3) / self.target\n\n    def serialize(self):\n        \"\"\"\n        Serialize raw block in bytes.\n\n        A block consists of a 80 bytes header:\n        * version - 4 bytes\n        * previous block - 32 bytes\n        * merkle root - 32 bytes\n        * timestamp - 4 bytes\n        * bits - 4 bytes\n        * nonce - 4 bytes\n\n        Followed by a list of raw serialized transactions.\n\n        Method will raise an error if one of the header fields is missing or has an incorrect size.\n\n        :return bytes:\n        \"\"\"\n        if len(self.transactions) != self.tx_count or len(self.transactions) < 1:\n            raise ValueError(\"Block contains incorrect number of transactions, can not serialize\")\n        rb = self.version[::-1]\n        rb += self.prev_block[::-1]\n        rb += self.merkle_root[::-1]\n        rb += self.time.to_bytes(4, 'little')\n        rb += self.bits[::-1]\n        rb += self.nonce[::-1]\n        if len(rb) != 80:\n            raise ValueError(\"Missing or incorrect length of 1 of the block header variables: version, prev_block, \"\n                             \"merkle_root, time, bits or nonce.\")\n        rb += int_to_varbyteint(len(self.transactions))\n        for t in self.transactions:\n            rb += t.raw()\n        return rb\n\n    @property\n    def version_bin(self):\n        \"\"\"\n        Get the block version as binary string. Since BIP9 protocol changes are signaled by changing one of the 29\n        last bits of the version number.\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(450001)\n        >>> print(b.version_bin)\n        00100000000000000000000000000010\n\n        :return str:\n        \"\"\"\n        return bin(self.version_int)[2:].zfill(32)\n\n    def version_bips(self):\n        \"\"\"\n        Extract version signaling information from the block's version number.\n\n        The block version shows which software the miner used to create the block. Changes to the bitcoin\n        protocol are described in Bitcoin Improvement Proposals (BIPs) and a miner shows which BIPs it supports\n        in the block version number.\n\n        This method returns a list of BIP version number as string.\n\n        Example: This block uses the BIP9 versioning system and signals BIP141 (segwit)\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(450001)\n        >>> print(b.version_bips())\n        ['BIP9', 'BIP141']\n\n        :return list of str:\n        \"\"\"\n        bips = []\n        if self.version_int >> 29 == 0b001 and self.height >= 407021:\n            bips.append('BIP9')\n            if self.version_int >> 0 & 1 == 1:\n                bips.append('BIP68')   # BIP112 (CHECKSEQUENCEVERIFY), BIP113 - Relative lock-time using consensus-enforced sequence numbers\n            if self.version_int >> 1 & 1 == 1:\n                bips.append('BIP141')  # BIP143, BIP147 (Segwit)\n            if self.version_int >> 4 & 1 == 1:\n                bips.append('BIP91')   # Segwit?\n            if self.version_int == 0x30000000:\n                bips.append('BIP109')  # Increase block size 2MB (rejected)\n            mask = 0x1fffe000\n            if self.version_int & mask and self.height >= 500000:\n                bips.append('BIP310')   # version-rolling\n        elif self.height < 500000:\n            if self.version_int == 2:\n                bips.append('BIP34')    # Version 2: Block Height in Coinbase\n            if self.version_int == 3:\n                bips.append('BIP66')    # Version 3: Strict DER signatures\n            if self.version_int == 4:\n                bips.append('BIP65')    # Version 4: Introduce CHECKLOCKTIMEVERIFY\n            if self.version_int == 0x30000000:\n                bips.append('BIP109')   # Increase block size 2MB (rejected)\n            if self.version_int == 0x20000007:\n                bips.append('BIP101')   # Increase block size 8MB (rejected)\n\n        return bips\n\n    def update_totals(self):\n        self.total_in = 0\n        self.total_out = 0\n        for t in self.transactions:\n            self.total_in += sum([i.value for i in t.inputs])\n            self.total_out += sum([o.value for o in t.outputs])",
  "def __init__(self, block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions=None,\n                 height=None, confirmations=None, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new Block object with provided parameters.\n\n        >>> b = Block('0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709', version=0x20000000, prev_block='0000000000000000000f9578cda278ae7a2002e50d8e6079d11e2ea1f672b483', merkle_root='20e86f03c24c53c12014264d0e405e014e15a02ad02c174f017ee040750f8d9d', time=1592848036, bits=387044594, nonce=791719079)\n        >>> b\n        <Block(0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709, None, transactions: 0)>\n\n        :param block_hash: Hash value of serialized block\n        :type block_hash: bytes, str\n        :param version: Block version to indicate which software / BIPs are used to create block\n        :type version: bytes, str, in\n        :param prev_block: Hash of previous block in blockchain\n        :type prev_block: bytes, str\n        :param merkle_root: Merkle root. Top item merkle chain tree to validate transactions.\n        :type merkle_root: bytes, str\n        :param time: Timestamp of time when block was included in blockchain\n        :type time: int, bytes\n        :param bits: Bits are used to indicate target / difficulty\n        :type bits: bytes, str, int\n        :param nonce: Number used once, n-once is used to create randomness for miners to find a suitable block hash\n        :type nonce: bytes, str, int\n        :param transactions: List of transaction included in this block. As list of transaction objects or list of transaction IDs strings\n        :type transactions: list of Transaction, list of str\n        :param height: Height of this block in the Blockchain\n        :type height: int\n        :param confirmations: Number of confirmations for this block, or depth. Increased when new blocks are found\n        :type confirmations: int\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n        \"\"\"\n\n        self.block_hash = to_bytes(block_hash)\n        if isinstance(version, int):\n            self.version = version.to_bytes(4, byteorder='big')\n            self.version_int = version\n        else:\n            self.version = to_bytes(version)\n            self.version_int = 0 if not self.version else int.from_bytes(self.version, 'big')\n        self.prev_block = to_bytes(prev_block)\n        self.merkle_root = to_bytes(merkle_root)\n        self.time = time\n        if not isinstance(time, int):\n            self.time = int.from_bytes(time, 'big')\n        if isinstance(bits, int):\n            self.bits = bits.to_bytes(4, 'big')\n            self.bits_int = bits\n        else:\n            self.bits = to_bytes(bits)\n            self.bits_int = 0 if not self.bits else int.from_bytes(self.bits, 'big')\n        if isinstance(nonce, int):\n            self.nonce = nonce.to_bytes(4, 'big')\n            self.nonce_int = nonce\n        else:\n            self.nonce = to_bytes(nonce)\n            self.nonce_int = 0 if not self.nonce else int.from_bytes(self.nonce, 'big')\n        self.transactions = transactions\n        self.transactions_dict = []\n        if self.transactions is None:\n            self.transactions = []\n        self.txs_data = None\n        self.confirmations = confirmations\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.tx_count = 0\n        self.page = 1\n        self.limit = 0\n        self.height = height\n        self.total_in = 0\n        self.total_out = 0\n        self.size = 0\n        if self.transactions and len(self.transactions) and isinstance(self.transactions[0], Transaction) \\\n                and self.version_int > 1:\n            # first bytes of unlocking script of coinbase transaction contains block height (BIP0034)\n            if self.transactions[0].coinbase and self.transactions[0].inputs[0].unlocking_script:\n                calc_height = int.from_bytes(self.transactions[0].inputs[0].unlocking_script[1:4] + b'\\x00', 'little')\n                if height and calc_height != height and height > 227835:\n                    raise ValueError(\"Specified block height %d is different than calculated block height according to \"\n                                     \"BIP0034\" % height)\n                self.height = calc_height",
  "def check_proof_of_work(self):\n        \"\"\"\n        Check proof of work for this block. Block hash must be below target.\n\n        This library is not optimised for mining, but you can use this for testing or learning purposes.\n\n        >>> b = Block('0000000000000000000154ba9d02ddd6cee0d71d1ea232753e02c9ac6affd709', version=0x20000000, prev_block='0000000000000000000f9578cda278ae7a2002e50d8e6079d11e2ea1f672b483', merkle_root='20e86f03c24c53c12014264d0e405e014e15a02ad02c174f017ee040750f8d9d', time=1592848036, bits=387044594, nonce=791719079)\n        >>> b.check_proof_of_work()\n        True\n\n        :return bool:\n        \"\"\"\n        if not self.block_hash or not self.bits:\n            return False\n        if int.from_bytes(self.block_hash, 'big') < self.target:\n            return True\n        return False",
  "def __repr__(self):\n        return \"<Block(%s, %s, transactions: %s)>\" % (self.block_hash.hex(), self.height, self.tx_count)",
  "def parse(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw: Raw serialize block\n        :type raw: BytesIO, bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n\n        if isinstance(raw, bytes):\n            b = cls.parse_bytesio(BytesIO(raw), block_hash, height, parse_transactions, limit, network)\n            b.size = len(raw)\n            return b\n        else:\n            return cls.parse_bytesio(raw, block_hash, height, parse_transactions, limit, network)",
  "def parse_bytes(cls, raw_bytes, block_hash=None, height=None, parse_transactions=False, limit=0,\n                    network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in bytes or BytesIO format. Wrapper for :func:`parse_bytesio`\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw_bytes: Raw serialize block\n        :type raw_bytes: bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n\n        raw_bytesio = BytesIO(raw_bytes)\n        b = cls.parse_bytesio(raw_bytesio, block_hash, height, parse_transactions, limit, network)\n        b.size = len(raw_bytes)\n        return b",
  "def parse_bytesio(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0,\n                      network=DEFAULT_NETWORK):\n        \"\"\"\n        Create Block object from raw serialized block in BytesIO format\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n\n        :param raw: Raw serialize block\n        :type raw: BytesIO\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n        block_header = raw.read(80)\n        block_hash_calc = double_sha256(block_header)[::-1]\n        if not block_hash:\n            block_hash = block_hash_calc\n        elif block_hash != block_hash_calc:\n            raise ValueError(\"Provided block hash does not correspond to calculated block hash %s\" %\n                             block_hash_calc.hex())\n\n        raw.seek(0)\n        version = raw.read(4)[::-1]\n        prev_block = raw.read(32)[::-1]\n        merkle_root = raw.read(32)[::-1]\n        time = raw.read(4)[::-1]\n        bits = raw.read(4)[::-1]\n        nonce = raw.read(4)[::-1]\n        tx_count = read_varbyteint(raw)\n        tx_start_pos = raw.tell()\n        txs_data_size = raw.seek(0, 2)\n        raw.seek(tx_start_pos)\n        transactions = []\n\n        while parse_transactions and raw.tell() < txs_data_size:\n            if limit != 0 and len(transactions) >= limit:\n                break\n            t = Transaction.parse_bytesio(raw, strict=False)\n            transactions.append(t)\n            # TODO: verify transactions, need input value from previous txs\n            # if verify and not t.verify():\n            #     raise ValueError(\"Could not verify transaction %s in block %s\" % (t.txid, block_hash))\n\n        if parse_transactions and limit == 0 and tx_count != len(transactions):\n            raise ValueError(\"Number of found transactions %d is not equal to expected number %d\" %\n                             (len(transactions), tx_count))\n\n        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,\n                    network=network)\n        block.txs_data = raw\n        block.tx_count = tx_count\n        return block",
  "def from_raw(cls, raw, block_hash=None, height=None, parse_transactions=False, limit=0, network=DEFAULT_NETWORK):  # pragma: no cover\n        \"\"\"\n        Create Block object from raw serialized block in bytes.\n\n        Get genesis block:\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.block_hash.hex()\n        '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n        \n        :param raw: Raw serialize block\n        :type raw: bytes\n        :param block_hash: Specify block hash if known to verify raw block. Value error will be raised if calculated block hash is different than specified.\n        :type block_hash: bytes\n        :param height: Specify height if known. Will be derived from coinbase transaction if not provided.\n        :type height: int\n        :param parse_transactions: Indicate if transactions in raw block need to be parsed and converted to Transaction objects. Default is False\n        :type parse_transactions: bool\n        :param limit: Maximum number of transactions to parse. Default is 0: parse all transactions. Only used if parse_transaction is set to True\n        :type limit: int\n        :param network: Name of network\n        :type network: str\n\n        :return Block:\n        \"\"\"\n        block_hash_calc = double_sha256(raw[:80])[::-1]\n        if not block_hash:\n            block_hash = block_hash_calc\n        elif block_hash != block_hash_calc:\n            raise ValueError(\"Provided block hash does not correspond to calculated block hash %s\" %\n                             block_hash_calc.hex())\n\n        version = raw[0:4][::-1]\n        prev_block = raw[4:36][::-1]\n        merkle_root = raw[36:68][::-1]\n        time = raw[68:72][::-1]\n        bits = raw[72:76][::-1]\n        nonce = raw[76:80][::-1]\n        tx_count, size = varbyteint_to_int(raw[80:89])\n        txs_data = BytesIO(raw[80+size:])\n\n        # Parse coinbase transaction so we can extract extra information\n        # transactions = [Transaction.parse(txs_data, network=network)]\n        # txs_data = BytesIO(txs_data[transactions[0].size:])\n        # block_txs_data = txs_data.read()\n        txs_data_size = txs_data.seek(0, 2)\n        txs_data.seek(0)\n        transactions = []\n\n        while parse_transactions and txs_data and txs_data.tell() < txs_data_size:\n            if limit != 0 and len(transactions) >= limit:\n                break\n            t = Transaction.parse_bytesio(txs_data, strict=False)\n            transactions.append(t)\n            # t = transaction_deserialize(txs_data, network=network, check_size=False)\n            # transactions.append(t)\n            # txs_data = txs_data[t.size:]\n            # TODO: verify transactions, need input value from previous txs\n            # if verify and not t.verify():\n            #     raise ValueError(\"Could not verify transaction %s in block %s\" % (t.txid, block_hash))\n\n        if parse_transactions and limit == 0 and tx_count != len(transactions):\n            raise ValueError(\"Number of found transactions %d is not equal to expected number %d\" %\n                             (len(transactions), tx_count))\n\n        block = cls(block_hash, version, prev_block, merkle_root, time, bits, nonce, transactions, height,\n                    network=network)\n        block.txs_data = txs_data\n        block.tx_count = tx_count\n        return block",
  "def parse_transactions(self, limit=0):\n        \"\"\"\n        Parse raw transactions from Block, if transaction data is available in txs_data attribute. Creates\n        Transaction objects in Block.\n\n        :param limit: Maximum number of transactions to parse\n        :type limit: int\n\n        :return:\n        \"\"\"\n        n = 0\n        while self.txs_data and (limit == 0 or n < limit) and len(self.transactions) < self.tx_count:\n            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False\n            self.transactions.append(t)\n            n += 1",
  "def parse_transactions_dict(self):\n        \"\"\"\n        Parse raw transactions from Block, if transaction data is available in txs_data attribute. Returns a list of\n        transactions dictionaries.\n\n        Only works if transactions are not parsed yet with :func:`parse_transactions` or parse_transactions=True when\n        creating a new block object.\n\n        :return:\n        \"\"\"\n        transactions_dict = []\n        txs_data_orig = deepcopy(self.txs_data)\n        while self.txs_data and len(self.transactions) < self.tx_count:\n            tx = self.parse_transaction_dict()\n            if not tx:\n                break\n            transactions_dict.append(tx)\n        self.txs_data = txs_data_orig\n        return transactions_dict",
  "def parse_transaction(self):\n        \"\"\"\n        Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add\n        Transaction object in Block and return the transaction\n\n        :return Tranasaction:\n        \"\"\"\n        if self.txs_data and len(self.transactions) < self.tx_count:\n            t = Transaction.parse_bytesio(self.txs_data, strict=False, network=self.network)  # , check_size=False\n            self.transactions.append(t)\n            return t\n        return False",
  "def parse_transaction_dict(self):\n        \"\"\"\n        Parse a single transaction from Block, if transaction data is available in txs_data attribute. Add\n        Transaction object in Block and return the transaction\n\n        :return Transaction:\n        \"\"\"\n        if self.txs_data and len(self.transactions) < self.tx_count:\n            tx = {'height': self.height, 'coinbase': False, 'flag': None, 'witness_type': 'legacy',\n                  'version': self.txs_data.read(4)[::-1]}\n            if not tx['version']:\n                return False\n            raw_flag = b''\n            if self.txs_data.read(1) == b'\\0':\n                flag = self.txs_data.read(1)\n                if flag == b'\\1':\n                    tx['witness_type'] = 'segwit'\n                raw_flag += b'\\0\\1'\n            else:\n                self.txs_data.seek(-1, 1)\n\n            n_inputs, raw_n_inputs = read_varbyteint_return(self.txs_data)\n\n            inputs = []\n            inputs_raw = b''\n            for n in range(0, n_inputs):\n                inp = {'prev_txid': self.txs_data.read(32)[::-1]}\n                if len(inp['prev_txid']) != 32:\n                    raise Exception(\"Input transaction hash not found. Probably malformed self.txs_data transaction\")\n                inp['output_n'] = self.txs_data.read(4)[::-1]\n                unlocking_script_size, unlocking_script_size_raw = read_varbyteint_return(self.txs_data)\n                inp['unlocking_script'] = self.txs_data.read(unlocking_script_size)\n                inp['inp_type'] = 'legacy'\n                if tx['witness_type'] == 'segwit' and not unlocking_script_size:\n                    inp['inp_type'] = 'segwit'\n                inp['sequence_number'] = self.txs_data.read(4)\n                tx['coinbase'] = False\n                if inp['prev_txid'] == 32 * b'\\0':\n                    tx['coinbase'] = True\n                inputs.append(inp)\n                inputs_raw += \\\n                    inp['prev_txid'][::-1] + inp['output_n'][::-1] + unlocking_script_size_raw + \\\n                    inp['unlocking_script'] + inp['sequence_number']\n            tx['inputs'] = inputs\n\n            outputs = []\n            outputs_raw = b''\n            n_outputs, raw_n_outputs = read_varbyteint_return(self.txs_data)\n            tx['output_total'] = 0\n            for n in range(0, n_outputs):\n                outp = {}\n                outp_value = self.txs_data.read(8)\n                outp['value'] = int.from_bytes(outp_value[::-1], 'big')\n                lock_script_size, lock_script_size_raw = read_varbyteint_return(self.txs_data)\n                outp['lock_script'] = self.txs_data.read(lock_script_size)\n                outputs.append(outp)\n                outp['output_n'] = n\n                tx['output_total'] += outp['value']\n                outputs_raw += outp_value + lock_script_size_raw + outp['lock_script']\n            if not outputs:\n                raise Exception(\"Error no outputs found in this transaction\")\n            tx['outputs'] = outputs\n\n            witnesses_raw = b''\n            if tx['witness_type'] == 'segwit':\n                for n in range(0, len(inputs)):\n                    n_items, raw_n_items = read_varbyteint_return(self.txs_data)\n                    witnesses_raw += raw_n_items\n                    if not n_items:\n                        continue\n                    # script = Script()\n                    inputs[n]['witnesses'] = []\n                    for m in range(0, n_items):\n                        item_size, raw_item_size = read_varbyteint_return(self.txs_data)\n                        witnesses_raw += raw_item_size\n                        witness = self.txs_data.read(item_size)\n                        witnesses_raw += witness\n                        inputs[n]['witnesses'].append(witness)\n\n            tx_locktime = self.txs_data.read(4)\n            tx['locktime'] = int.from_bytes(tx_locktime[::-1], 'big')\n            tx['rawtx'] = tx['version'][::-1] + raw_flag + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw + \\\n                          witnesses_raw + tx_locktime\n            tx['txid'] = double_sha256(tx['version'][::-1] + raw_n_inputs + inputs_raw + raw_n_outputs + outputs_raw\n                                       + tx_locktime)[::-1]\n            tx['size'] = len(tx['rawtx'])\n            # TODO: tx['vsize'] = len(tx['rawtx'])\n            return tx\n        return False",
  "def as_dict(self):\n        \"\"\"\n        Get representation of current Block as dictionary.\n\n        :return dict:\n        \"\"\"\n        return {\n            'block_hash': self.block_hash.hex(),\n            'height': self.height,\n            'version': self.version_int,\n            'prev_block': None if not self.prev_block else self.prev_block.hex(),\n            'merkle_root': self.merkle_root.hex(),\n            'timestamp': self.time,\n            'bits': self.bits_int,\n            'nonce': self.nonce_int,\n            'target': self.target_hex,\n            'difficulty': self.difficulty,\n            'tx_count': self.tx_count,\n            'transactions': self.transactions,\n            'confirmations': self.confirmations\n        }",
  "def target(self):\n        \"\"\"\n        Block target calculated from block's bits. Block hash must be below this target. Used to calculate\n        block difficulty.\n\n        :return int:\n        \"\"\"\n        if not self.bits:\n            return 0\n        exponent = self.bits[0]\n        coefficient = int.from_bytes(b'\\x00' + self.bits[1:], 'big')\n        return coefficient * 256 ** (exponent - 3)",
  "def target_hex(self):\n        \"\"\"\n        Block target in hexadecimal string of 64 characters.\n\n        :return str:\n        \"\"\"\n        if not self.bits:\n            return ''\n        return hex(int(self.target))[2:].zfill(64)",
  "def difficulty(self):\n        \"\"\"\n        Block difficulty calculated from bits / target. Human readable representation of block's target.\n\n        Genesis block has difficulty of 1.0\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b.difficulty\n        1.0\n\n        :return float:\n        \"\"\"\n        if not self.bits:\n            return 0\n        return 0xffff * 256 ** (0x1d - 3) / self.target",
  "def serialize(self):\n        \"\"\"\n        Serialize raw block in bytes.\n\n        A block consists of a 80 bytes header:\n        * version - 4 bytes\n        * previous block - 32 bytes\n        * merkle root - 32 bytes\n        * timestamp - 4 bytes\n        * bits - 4 bytes\n        * nonce - 4 bytes\n\n        Followed by a list of raw serialized transactions.\n\n        Method will raise an error if one of the header fields is missing or has an incorrect size.\n\n        :return bytes:\n        \"\"\"\n        if len(self.transactions) != self.tx_count or len(self.transactions) < 1:\n            raise ValueError(\"Block contains incorrect number of transactions, can not serialize\")\n        rb = self.version[::-1]\n        rb += self.prev_block[::-1]\n        rb += self.merkle_root[::-1]\n        rb += self.time.to_bytes(4, 'little')\n        rb += self.bits[::-1]\n        rb += self.nonce[::-1]\n        if len(rb) != 80:\n            raise ValueError(\"Missing or incorrect length of 1 of the block header variables: version, prev_block, \"\n                             \"merkle_root, time, bits or nonce.\")\n        rb += int_to_varbyteint(len(self.transactions))\n        for t in self.transactions:\n            rb += t.raw()\n        return rb",
  "def version_bin(self):\n        \"\"\"\n        Get the block version as binary string. Since BIP9 protocol changes are signaled by changing one of the 29\n        last bits of the version number.\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(450001)\n        >>> print(b.version_bin)\n        00100000000000000000000000000010\n\n        :return str:\n        \"\"\"\n        return bin(self.version_int)[2:].zfill(32)",
  "def version_bips(self):\n        \"\"\"\n        Extract version signaling information from the block's version number.\n\n        The block version shows which software the miner used to create the block. Changes to the bitcoin\n        protocol are described in Bitcoin Improvement Proposals (BIPs) and a miner shows which BIPs it supports\n        in the block version number.\n\n        This method returns a list of BIP version number as string.\n\n        Example: This block uses the BIP9 versioning system and signals BIP141 (segwit)\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(450001)\n        >>> print(b.version_bips())\n        ['BIP9', 'BIP141']\n\n        :return list of str:\n        \"\"\"\n        bips = []\n        if self.version_int >> 29 == 0b001 and self.height >= 407021:\n            bips.append('BIP9')\n            if self.version_int >> 0 & 1 == 1:\n                bips.append('BIP68')   # BIP112 (CHECKSEQUENCEVERIFY), BIP113 - Relative lock-time using consensus-enforced sequence numbers\n            if self.version_int >> 1 & 1 == 1:\n                bips.append('BIP141')  # BIP143, BIP147 (Segwit)\n            if self.version_int >> 4 & 1 == 1:\n                bips.append('BIP91')   # Segwit?\n            if self.version_int == 0x30000000:\n                bips.append('BIP109')  # Increase block size 2MB (rejected)\n            mask = 0x1fffe000\n            if self.version_int & mask and self.height >= 500000:\n                bips.append('BIP310')   # version-rolling\n        elif self.height < 500000:\n            if self.version_int == 2:\n                bips.append('BIP34')    # Version 2: Block Height in Coinbase\n            if self.version_int == 3:\n                bips.append('BIP66')    # Version 3: Strict DER signatures\n            if self.version_int == 4:\n                bips.append('BIP65')    # Version 4: Introduce CHECKLOCKTIMEVERIFY\n            if self.version_int == 0x30000000:\n                bips.append('BIP109')   # Increase block size 2MB (rejected)\n            if self.version_int == 0x20000007:\n                bips.append('BIP101')   # Increase block size 8MB (rejected)\n\n        return bips",
  "def update_totals(self):\n        self.total_in = 0\n        self.total_out = 0\n        for t in self.transactions:\n            self.total_in += sum([i.value for i in t.inputs])\n            self.total_out += sum([o.value for o in t.outputs])",
  "class NetworkError(Exception):\n    \"\"\"\n    Network Exception class\n    \"\"\"\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "def _read_network_definitions():\n    \"\"\"\n    Returns network definitions from json file in settings dir\n\n    :return dict: Network definitions\n    \"\"\"\n\n    fn = Path(BCL_DATA_DIR, 'networks.json')\n    f = fn.open('rb')\n\n    try:\n        network_definitions = json.loads(f.read())\n    except json.decoder.JSONDecodeError as e:\n        raise NetworkError(\"Error reading provider definitions from %s: %s\" % (fn, e))\n    f.close()\n    return network_definitions",
  "def _format_value(field, value):\n    if field[:6] == 'prefix':\n        return bytes.fromhex(value)\n    elif field == 'denominator':\n        return float(value)\n    else:\n        return value",
  "def network_values_for(field):\n    \"\"\"\n    Return all prefixes for field, i.e.: prefix_wif, prefix_address_p2sh, etc\n\n    >>> network_values_for('prefix_wif')\n    [b'\\\\x99', b'\\\\x80', b'\\\\xef', b'\\\\xb0', b'\\\\xcc', b'\\\\x9e', b'\\\\xf1']\n    >>> network_values_for('prefix_address_p2sh')\n    [b'\\\\x95', b'\\\\x05', b'\\\\xc4', b'2', b':', b'\\\\x10', b'\\\\x13', b'\\\\x16']\n\n    :param field: Prefix name from networks definitions (networks.json)\n    :type field: str\n\n    :return str: \n    \"\"\"\n    return list(dict.fromkeys([_format_value(field, nv[field]) for nv in NETWORK_DEFINITIONS.values()]))",
  "def network_by_value(field, value):\n    \"\"\"\n    Return all networks for field and (prefix) value.\n    \n    Example, get available networks for WIF or address prefix\n\n    >>> network_by_value('prefix_wif', 'B0')\n    ['litecoin', 'litecoin_legacy']\n    >>> network_by_value('prefix_address', '6f')\n    ['testnet', 'litecoin_testnet']\n\n    This method does not work for HD prefixes, use 'wif_prefix_search' instead\n\n    >>> network_by_value('prefix_address', '043587CF')\n    []\n    \n    :param field: Prefix name from networks definitions (networks.json)\n    :type field: str\n    :param value: Value of network prefix\n    :type value: str\n\n    :return list: Of network name strings \n    \"\"\"\n    nws = [(nv, NETWORK_DEFINITIONS[nv]['priority'])\n           for nv in NETWORK_DEFINITIONS if NETWORK_DEFINITIONS[nv][field] == value]\n    if not nws:\n        try:\n            value = value.upper()\n        except TypeError:\n            pass\n        nws = [(nv, NETWORK_DEFINITIONS[nv]['priority'])\n               for nv in NETWORK_DEFINITIONS if NETWORK_DEFINITIONS[nv][field] == value]\n    return [nw[0] for nw in sorted(nws, key=lambda x: x[1], reverse=True)]",
  "def network_defined(network):\n    \"\"\"\n    Is network defined?\n    \n    Networks of this library are defined in networks.json in the operating systems user path.\n\n    >>> network_defined('bitcoin')\n    True\n    >>> network_defined('ethereum')\n    False\n    \n    :param network: Network name\n    :type network: str\n    \n    :return bool: \n    \"\"\"\n    if network not in list(NETWORK_DEFINITIONS.keys()):\n        return False\n    return True",
  "def wif_prefix_search(wif, witness_type=None, multisig=None, network=None):\n    \"\"\"\n    Extract network, script type and public/private information from HDKey WIF or WIF prefix.\n\n    Example, get bitcoin 'xprv' info:\n\n    >>> wif_prefix_search('0488ADE4', network='bitcoin', multisig=False)\n    [{'prefix': '0488ADE4', 'is_private': True, 'prefix_str': 'xprv', 'network': 'bitcoin', 'witness_type': 'legacy', 'multisig': False, 'script_type': 'p2pkh'}]\n\n    Or retreive info with full WIF string:\n\n    >>> wif_prefix_search('xprv9wTYmMFdV23N21MM6dLNavSQV7Sj7meSPXx6AV5eTdqqGLjycVjb115Ec5LgRAXscPZgy5G4jQ9csyyZLN3PZLxoM1h3BoPuEJzsgeypdKj', network='bitcoin', multisig=False)\n    [{'prefix': '0488ADE4', 'is_private': True, 'prefix_str': 'xprv', 'network': 'bitcoin', 'witness_type': 'legacy', 'multisig': False, 'script_type': 'p2pkh'}]\n\n    Can return multiple items if no network is specified:\n\n    >>> [nw['network'] for nw in wif_prefix_search('0488ADE4', multisig=True)]\n    ['bitcoin', 'regtest', 'dash', 'dogecoin']\n\n    :param wif: WIF string or prefix as hexadecimal string\n    :type wif: str\n    :param witness_type: Limit search to specific witness type\n    :type witness_type: str\n    :param multisig: Limit search to multisig: false, true or None for both. Default is both\n    :type multisig: bool\n    :param network: Limit search to specified network\n    :type network: str\n\n    :return dict:\n    \"\"\"\n\n    key_hex = wif\n    if len(wif) > 8:\n        try:\n            key_hex = change_base(wif, 58, 16)\n        except Exception:\n            pass\n    prefix = key_hex[:8].upper()\n    matches = []\n    for nw in NETWORK_DEFINITIONS:\n        if network is not None and nw != network:\n            continue\n        data = NETWORK_DEFINITIONS[nw]\n        for pf in data['prefixes_wif']:\n            if pf[0] == prefix and (multisig is None or pf[3] is None or pf[3] == multisig) and \\\n                    (witness_type is None or pf[4] is None or pf[4] == witness_type):\n                matches.append({\n                    'prefix': prefix,\n                    'is_private': True if pf[2] == 'private' else False,\n                    'prefix_str': pf[1],\n                    'network': nw,\n                    'witness_type': pf[4],\n                    'multisig': pf[3],\n                    'script_type': pf[5]\n                })\n    return matches",
  "def print_value(value, network=DEFAULT_NETWORK, rep='string', denominator=1, decimals=None):\n    \"\"\"\n    Return the value as string with currency symbol\n\n    Wrapper for the Network().print_value method.\n\n    :param value: Value in the smallest denominator such as Satoshi\n    :type value: int, float\n    :param network: Network name as string, default is 'bitcoin'\n    :type network: str\n    :param rep: Currency representation: 'string', 'symbol', 'none' or your own custom name\n    :type rep: str\n    :param denominator: Unit to use in representation. Default is 1. I.e. 1 = 1 BTC, 0.001 = milli BTC / mBTC, 1e-8 = Satoshi's\n    :type denominator: float\n    :param decimals: Number of digits after the decimal point, leave empty for automatic determination based on value. Use integer value between 0 and 8\n    :type decimals: int\n\n    :return str:\n    \"\"\"\n    return Network(network_name=network).print_value(value, rep, denominator, decimals)",
  "class Network(object):\n    \"\"\"\n    Network class with all network definitions. \n    \n    Prefixes for WIF, P2SH keys, HD public and private keys, addresses. A currency symbol and type, the \n    denominator (such as satoshi) and a BIP0044 cointype.\n    \n    \"\"\"\n\n    def __init__(self, network_name=DEFAULT_NETWORK):\n        if network_name not in NETWORK_DEFINITIONS:\n            raise NetworkError(\"Network %s not found in network definitions\" % network_name)\n        self.name = network_name\n\n        self.currency_name = NETWORK_DEFINITIONS[network_name]['currency_name']\n        self.currency_name_plural = NETWORK_DEFINITIONS[network_name]['currency_name_plural']\n        self.currency_code = NETWORK_DEFINITIONS[network_name]['currency_code']\n        self.currency_symbol = NETWORK_DEFINITIONS[network_name]['currency_symbol']\n        self.description = NETWORK_DEFINITIONS[network_name]['description']\n        self.prefix_address_p2sh = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_address_p2sh'])\n        self.prefix_address = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_address'])\n        self.prefix_bech32 = NETWORK_DEFINITIONS[network_name]['prefix_bech32']\n        self.prefix_wif = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_wif'])\n        self.denominator = NETWORK_DEFINITIONS[network_name]['denominator']\n        self.bip44_cointype = NETWORK_DEFINITIONS[network_name]['bip44_cointype']\n        self.dust_amount = NETWORK_DEFINITIONS[network_name]['dust_amount']  # Dust amount in satoshi\n        self.fee_default = NETWORK_DEFINITIONS[network_name]['fee_default']  # Default fee in satoshi per kilobyte\n        self.fee_min = NETWORK_DEFINITIONS[network_name]['fee_min']  # Minimum transaction fee in satoshi per kilobyte\n        self.fee_max = NETWORK_DEFINITIONS[network_name]['fee_max']  # Maximum transaction fee in satoshi per kilobyte\n        self.priority = NETWORK_DEFINITIONS[network_name]['priority']\n        self.prefixes_wif = NETWORK_DEFINITIONS[network_name]['prefixes_wif']\n\n        # This could be shorter and more flexible with the code below, but this gives 'Unresolved attributes' warnings\n        # for f in list(NETWORK_DEFINITIONS[network_name].keys()):\n        #     exec(\"self.%s = NETWORK_DEFINITIONS[network_name]['%s']\" % (f, f))\n\n    def __repr__(self):\n        return \"<Network: %s>\" % self.name\n\n    def __eq__(self, other):\n        if isinstance(other, str):\n            return self.name == other\n        return self.name == other.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    # Replaced by Value class\n    @deprecated\n    def print_value(self, value, rep='string', denominator=1, decimals=None):\n        \"\"\"\n        Return the value as string with currency symbol\n\n        Print value for 100000 satoshi as string in human-readable format\n\n        >>> Network('bitcoin').print_value(100000)\n        '0.00100000 BTC'\n\n        :param value: Value in the smallest denominator such as Satoshi\n        :type value: int, float\n        :param rep: Currency representation: 'string', 'symbol', 'none' or your own custom name\n        :type rep: str\n        :param denominator: Unit to use in representation. Default is 1. I.e. 1 = 1 BTC, 0.001 = milli BTC / mBTC\n        :type denominator: float\n        :param decimals: Number of digits after the decimal point, leave empty for automatic determination based on value. Use integer value between 0 and 8\n        :type decimals: int\n\n        :return str: \n        \"\"\"\n        if denominator not in NETWORK_DENOMINATORS:\n            raise NetworkError(\"Denominator not found in definitions, use one of the following values: %s\" %\n                               NETWORK_DENOMINATORS.keys())\n        if value is None:\n            return \"\"\n        symb = rep\n        if rep == 'string':\n            symb = NETWORK_DENOMINATORS[denominator] + self.currency_code\n        elif rep == 'symbol':\n            symb = NETWORK_DENOMINATORS[denominator] + self.currency_symbol\n        elif rep == 'none':\n            symb = ''\n        decimals = decimals if decimals is not None else -int(math.log10(self.denominator / denominator))\n        decimals = 0 if decimals < 0 else decimals\n        decimals = 8 if decimals > 8 else decimals\n        balance = round(float(value) * self.denominator / denominator, decimals)\n        format_str = \"%%.%df %%s\" % decimals\n        return (format_str % (balance, symb)).rstrip()\n\n    def wif_prefix(self, is_private=False, witness_type='legacy', multisig=False):\n        \"\"\"\n        Get WIF prefix for this network and specifications in arguments\n\n        >>> Network('bitcoin').wif_prefix()  # xpub\n        b'\\\\x04\\\\x88\\\\xb2\\\\x1e'\n        >>> Network('bitcoin').wif_prefix(is_private=True, witness_type='segwit', multisig=True)  # Zprv\n        b'\\\\x02\\\\xaaz\\\\x99'\n\n        :param is_private: Private or public key, default is True\n        :type is_private: bool\n        :param witness_type: Legacy, segwit or p2sh-segwit\n        :type witness_type: str\n        :param multisig: Multisignature or single signature wallet. Default is False: no multisig\n        :type multisig: bool\n\n        :return bytes:\n        \"\"\"\n        script_type = script_type_default(witness_type, multisig, locking_script=True)\n        if script_type == 'p2sh' and witness_type in ['p2sh-segwit', 'segwit']:\n            script_type = 'p2sh_p2wsh' if multisig else 'p2sh_p2wpkh'\n        if is_private:\n            ip = 'private'\n        else:\n            ip = 'public'\n        found_prefixes = [bytes.fromhex(pf[0]) for pf in self.prefixes_wif if pf[2] == ip and script_type == pf[5]]\n        if found_prefixes:\n            return found_prefixes[0]\n        else:\n            raise NetworkError(\"WIF Prefix for script type %s not found\" % script_type)",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def __init__(self, network_name=DEFAULT_NETWORK):\n        if network_name not in NETWORK_DEFINITIONS:\n            raise NetworkError(\"Network %s not found in network definitions\" % network_name)\n        self.name = network_name\n\n        self.currency_name = NETWORK_DEFINITIONS[network_name]['currency_name']\n        self.currency_name_plural = NETWORK_DEFINITIONS[network_name]['currency_name_plural']\n        self.currency_code = NETWORK_DEFINITIONS[network_name]['currency_code']\n        self.currency_symbol = NETWORK_DEFINITIONS[network_name]['currency_symbol']\n        self.description = NETWORK_DEFINITIONS[network_name]['description']\n        self.prefix_address_p2sh = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_address_p2sh'])\n        self.prefix_address = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_address'])\n        self.prefix_bech32 = NETWORK_DEFINITIONS[network_name]['prefix_bech32']\n        self.prefix_wif = bytes.fromhex(NETWORK_DEFINITIONS[network_name]['prefix_wif'])\n        self.denominator = NETWORK_DEFINITIONS[network_name]['denominator']\n        self.bip44_cointype = NETWORK_DEFINITIONS[network_name]['bip44_cointype']\n        self.dust_amount = NETWORK_DEFINITIONS[network_name]['dust_amount']  # Dust amount in satoshi\n        self.fee_default = NETWORK_DEFINITIONS[network_name]['fee_default']  # Default fee in satoshi per kilobyte\n        self.fee_min = NETWORK_DEFINITIONS[network_name]['fee_min']  # Minimum transaction fee in satoshi per kilobyte\n        self.fee_max = NETWORK_DEFINITIONS[network_name]['fee_max']  # Maximum transaction fee in satoshi per kilobyte\n        self.priority = NETWORK_DEFINITIONS[network_name]['priority']\n        self.prefixes_wif = NETWORK_DEFINITIONS[network_name]['prefixes_wif']",
  "def __repr__(self):\n        return \"<Network: %s>\" % self.name",
  "def __eq__(self, other):\n        if isinstance(other, str):\n            return self.name == other\n        return self.name == other.name",
  "def __hash__(self):\n        return hash(self.name)",
  "def print_value(self, value, rep='string', denominator=1, decimals=None):\n        \"\"\"\n        Return the value as string with currency symbol\n\n        Print value for 100000 satoshi as string in human-readable format\n\n        >>> Network('bitcoin').print_value(100000)\n        '0.00100000 BTC'\n\n        :param value: Value in the smallest denominator such as Satoshi\n        :type value: int, float\n        :param rep: Currency representation: 'string', 'symbol', 'none' or your own custom name\n        :type rep: str\n        :param denominator: Unit to use in representation. Default is 1. I.e. 1 = 1 BTC, 0.001 = milli BTC / mBTC\n        :type denominator: float\n        :param decimals: Number of digits after the decimal point, leave empty for automatic determination based on value. Use integer value between 0 and 8\n        :type decimals: int\n\n        :return str: \n        \"\"\"\n        if denominator not in NETWORK_DENOMINATORS:\n            raise NetworkError(\"Denominator not found in definitions, use one of the following values: %s\" %\n                               NETWORK_DENOMINATORS.keys())\n        if value is None:\n            return \"\"\n        symb = rep\n        if rep == 'string':\n            symb = NETWORK_DENOMINATORS[denominator] + self.currency_code\n        elif rep == 'symbol':\n            symb = NETWORK_DENOMINATORS[denominator] + self.currency_symbol\n        elif rep == 'none':\n            symb = ''\n        decimals = decimals if decimals is not None else -int(math.log10(self.denominator / denominator))\n        decimals = 0 if decimals < 0 else decimals\n        decimals = 8 if decimals > 8 else decimals\n        balance = round(float(value) * self.denominator / denominator, decimals)\n        format_str = \"%%.%df %%s\" % decimals\n        return (format_str % (balance, symb)).rstrip()",
  "def wif_prefix(self, is_private=False, witness_type='legacy', multisig=False):\n        \"\"\"\n        Get WIF prefix for this network and specifications in arguments\n\n        >>> Network('bitcoin').wif_prefix()  # xpub\n        b'\\\\x04\\\\x88\\\\xb2\\\\x1e'\n        >>> Network('bitcoin').wif_prefix(is_private=True, witness_type='segwit', multisig=True)  # Zprv\n        b'\\\\x02\\\\xaaz\\\\x99'\n\n        :param is_private: Private or public key, default is True\n        :type is_private: bool\n        :param witness_type: Legacy, segwit or p2sh-segwit\n        :type witness_type: str\n        :param multisig: Multisignature or single signature wallet. Default is False: no multisig\n        :type multisig: bool\n\n        :return bytes:\n        \"\"\"\n        script_type = script_type_default(witness_type, multisig, locking_script=True)\n        if script_type == 'p2sh' and witness_type in ['p2sh-segwit', 'segwit']:\n            script_type = 'p2sh_p2wsh' if multisig else 'p2sh_p2wpkh'\n        if is_private:\n            ip = 'private'\n        else:\n            ip = 'public'\n        found_prefixes = [bytes.fromhex(pf[0]) for pf in self.prefixes_wif if pf[2] == ip and script_type == pf[5]]\n        if found_prefixes:\n            return found_prefixes[0]\n        else:\n            raise NetworkError(\"WIF Prefix for script type %s not found\" % script_type)",
  "class ScriptError(Exception):\n    \"\"\"\n    Handle Key class Exceptions\n\n    \"\"\"\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "def _get_script_types(blueprint):\n    # Convert blueprint to more generic format\n    bp = []\n    for item in blueprint:\n        if isinstance(item, str) and item[:4] == 'data':\n            bp.append('data')\n        elif isinstance(item, int) and op.op_1 <= item <= op.op_16:\n            bp.append('op_n')\n        elif item == 'key' and len(bp) and bp[-1] == 'key':\n            bp[-1] = 'key'\n        elif item == 'signature' and len(bp) and bp[-1] == 'signature':\n            bp[-1] = 'signature'\n        else:\n            bp.append(item)\n\n    script_types = [key for key, values in SCRIPT_TYPES.items() if values[1] == bp]\n    if script_types:\n        return script_types\n\n    bp_len = [int(c.split('-')[1]) for c in blueprint if isinstance(c, str) and c[:4] == 'data']\n    script_types = []\n    while len(bp):\n        # Find all possible matches with blueprint\n        matches = [(key, len(values[1]), values[2]) for key, values in SCRIPT_TYPES.items() if\n                   values[1] == bp[:len(values[1])]]\n        if not matches:\n            script_types.append('unknown')\n            break\n\n        # Select match with correct data length if more than 1 match is found\n        match_id = 0\n        for match in matches:\n            data_lens = match[2]\n            for i, data_len in enumerate(data_lens):\n                bl = bp_len[i]\n                if data_len == bl or data_len == 0:\n                    match_id = matches.index(match)\n                    break\n\n        # Add script type to list\n        script_type = matches[match_id][0]\n        if script_type == 'multisig' and script_types[-1:] == ['signature_multisig']:\n            script_types.pop()\n            script_type = 'p2sh_multisig'\n        script_types.append(script_type)\n        bp = bp[matches[match_id][1]:]\n\n    return script_types",
  "def data_pack(data):\n    \"\"\"\n    Add data length prefix to data string to include data in a script\n\n    :param data: Data to be packed\n    :type data: bytes\n\n    :return bytes:\n    \"\"\"\n    if len(data) <= 75:\n        return len(data).to_bytes(1, 'big') + data\n    elif 75 < len(data) <= 255:\n        return b'L' + len(data).to_bytes(1, 'little') + data\n    else:\n        return b'M' + len(data).to_bytes(2, 'little') + data",
  "def get_data_type(data):\n    \"\"\"\n    Get type of data in script. Recognises signatures, keys, hashes or sequence data. Return 'other' if data is not\n    recognised.\n\n    :param data: Data part of script\n    :type data: bytes\n\n    :return str:\n    \"\"\"\n    if isinstance(data, Key):\n        return 'key_object'\n    elif isinstance(data, Signature):\n        return 'signature_object'\n    elif data.startswith(b'\\x30') and 69 <= len(data) <= 74:\n        return 'signature'\n    elif ((data.startswith(b'\\x02') or data.startswith(b'\\x03')) and len(data) == 33) or \\\n            (data.startswith(b'\\x04') and len(data) == 65):\n        return 'key'\n    elif len(data) == 20 or len(data) == 32 or len(data) == 64 or 1 < len(data) <= 4:\n        return 'data-%d' % len(data)\n    else:\n        return 'other'",
  "class Script(object):\n\n    def __init__(self, commands=None, message=None, script_types='', is_locking=True, keys=None, signatures=None,\n                 blueprint=None, tx_data=None, public_hash=b'', sigs_required=None, redeemscript=b'',\n                 hash_type=SIGHASH_ALL):\n        \"\"\"\n        Create a Script object with specified parameters. Use parse() method to create a Script from raw hex\n\n        >>> s = Script([op.op_2, op.op_4, op.op_add])\n        >>> s\n        <Script([op.op_2, op.op_4, op.op_add])>\n        >>> s.blueprint\n        [82, 84, 147]\n        >>> s.evaluate()\n        True\n\n        Stack is empty now, because evaluate pops last item from stack and check if is non-zero\n        >>> s.stack\n        []\n\n        :param commands: List of script language commands\n        :type commands: list\n        :param message: Signed message to verify, normally a transaction hash. Used to validate script\n        :type message: bytes\n        :param script_types: List of script_types as defined in SCRIPT_TYPES\n        :type script_types: list of str\n        :param is_locking: Is this a locking script (Output), otherwise unlocking (Input)\n        :type is_locking: bool\n        :param keys: Provide list of keys to create script\n        :type keys: list of Key\n        :param signatures: Provide list of signatures to create script\n        :type signatures: list of Signature\n        :param blueprint: Simplified version of script, normally generated by Script object\n        :type blueprint: list of str\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param public_hash: Public hash of key or redeemscript used to create scripts\n        :type public_hash: bytes\n        :param sigs_required: Nubmer of signatures required to create multisig script\n        :type sigs_required: int\n        :param redeemscript: Provide redeemscript to create a new (multisig) script\n        :type redeemscript: bytes\n        :param hash_type: Specific script hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        \"\"\"\n        self.commands = commands if commands else []\n        self._raw = b''\n        self.stack = []\n        self.message = message\n        self.script_types = script_types if script_types else []\n        self.is_locking = is_locking\n        self.keys = keys if keys else []\n        self.signatures = signatures if signatures else []\n        self._blueprint = blueprint if blueprint else []\n        self.tx_data = {} if not tx_data else tx_data\n        self.sigs_required = sigs_required if sigs_required else len(self.keys) if len(self.keys) else 1\n        self.redeemscript = redeemscript\n        self.public_hash = public_hash\n        self.hash_type = hash_type\n\n        if not self.commands and self.script_types and (self.keys or self.signatures or self.public_hash):\n            for st in self.script_types:\n                st_values = SCRIPT_TYPES[st]\n                script_template = st_values[1]\n                self.is_locking = True if st_values[0] == 'locking' else False\n                sig_n_and_m = [len(self.keys), self.sigs_required]\n                for tc in script_template:\n                    command = [tc]\n                    if tc == 'data':\n                        command = [self.public_hash] if self.public_hash else []\n                    elif tc == 'signature':\n                        command = self.signatures\n                    elif tc == 'key':\n                        command = self.keys\n                    elif tc == 'op_n':\n                        command = [sig_n_and_m.pop() + 80]\n                    elif tc == 'redeemscript':\n                        command = [self.redeemscript]\n                    if not command or command == [b'']:\n                        raise ScriptError(\"Cannot create script, please supply %s\" % (tc if tc != 'data' else\n                                          'public key hash'))\n                    self.commands += command\n        if not (self.keys and self.signatures and self.blueprint):\n            self._blueprint = []\n            for c in self.commands:\n                if isinstance(c, int):\n                    self._blueprint.append(c)\n                else:\n                    data_type = get_data_type(c)\n                    if data_type in ['key', 'signature', 'key_object', 'signature_object']:\n                        if data_type == 'key_object':\n                            data_type = 'key'\n                        elif data_type == 'signature_object':\n                            data_type = 'signature'\n                        self._blueprint.append(data_type)\n                    else:\n                        self._blueprint.append('data-%d' % len(c))\n\n    @classmethod\n    def parse(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert hexadecimal string or bytes script to BytesIO.\n\n        >>> Script.parse('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        <Script([op.op_dup, op.op_hash160, data-20, op.op_equalverify, op.op_checksig])>\n\n        :param script: Raw script to parse in bytes, BytesIO or hexadecimal string format\n        :type script: BytesIO, bytes, str\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = None\n        if isinstance(script, bytes):\n            data_length = len(script) // 2\n            script = BytesIO(script)\n        elif isinstance(script, str):\n            data_length = len(script)\n            script = BytesIO(bytes.fromhex(script))\n        return cls.parse_bytesio(script, message, tx_data, data_length, strict, _level)\n\n    @classmethod\n    def parse_bytesio(cls, script, message=None, tx_data=None, data_length=0, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        :param script: Raw script to parse in bytes, BytesIO or hexadecimal string format\n        :type script: BytesIO\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param data_length: Length of script data if known. Supply if you can to increase efficiency and lower change of incorrect parsing\n        :type data_length: int\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        commands = []\n        signatures = []\n        keys = []\n        blueprint = []\n        redeemscript = b''\n        sigs_required = None\n        # hash_type = SIGHASH_ALL  # todo: check\n        hash_type = None\n        if not tx_data:\n            tx_data = {}\n\n        chb = script.read(1)\n        ch = int.from_bytes(chb, 'big')\n        data = None\n        if chb == b'\\x30' and 69 <= data_length <= 74:\n            data = chb + script.read(data_length - 1)\n        elif ((chb == b'\\x02' or chb == b'\\x03') and data_length == 33) or \\\n                (chb == b'\\x04' and data_length == 65):\n            data = chb + script.read(data_length - 1)\n        elif data_length == 64:\n            data = chb + script.read(data_length - 1)\n        else:\n            data_length = 0\n\n        while chb and script:\n            if data:\n                data_type = get_data_type(data)\n                commands.append(data)\n                if data_type == 'signature':\n                    try:\n                        sig = Signature.parse_bytes(data)\n                        signatures.append(sig)\n                        hash_type = sig.hash_type\n                        blueprint.append('signature')\n                    except Exception as e:\n                        if strict:\n                            raise ScriptError(str(e))\n                        else:\n                            _logger.warning(str(e))\n                elif data_type == 'signature_object':\n                    signatures.append(data)\n                    hash_type = data.hash_type\n                    blueprint.append('signature')\n                elif data_type == 'key':\n                    keys.append(Key(data))\n                    blueprint.append('key')\n                elif data_type == 'key_object':\n                    keys.append(data)\n                    blueprint.append('key')\n                elif data_type[:4] == 'data':\n                    # FIXME: This is arbitrary\n                    blueprint.append('data-%d' % len(data))\n                elif len(commands) >= 2 and commands[-2] == op.op_return:\n                    blueprint.append('data-%d' % len(data))\n                else:\n                    # FIXME: Only parse sub-scripts if script is expected\n                    try:\n                        if _level >= 1:\n                            blueprint.append('data-%d' % len(data))\n                        else:\n                            s2 = Script.parse_bytes(data, _level=_level+1, strict=strict)\n                            commands.pop()\n                            commands += s2.commands\n                            blueprint += s2.blueprint\n                            keys += s2.keys\n                            signatures += s2.signatures\n                            redeemscript = s2.redeemscript\n                            sigs_required = s2.sigs_required\n                    except (ScriptError, IndexError):\n                        blueprint.append('data-%d' % len(data))\n                data = None\n                data_length = 0\n            else:  # Other opcode\n                if 1 <= ch <= 75:  # Data`\n                    data_length = ch\n                elif ch == op.op_pushdata1:\n                    data_length = int.from_bytes(script.read(1), 'little')\n                elif ch == op.op_pushdata2:\n                    data_length = int.from_bytes(script.read(2), 'little')\n                if data_length:\n                    data = script.read(data_length)\n                    if len(data) != data_length:\n                        msg = \"Malformed script, not enough data found\"\n                        if strict:\n                            raise ScriptError(msg)\n                        else:\n                            chb = b''\n                            _logger.warning(msg)\n                    continue\n\n                commands.append(ch)\n                blueprint.append(ch)\n\n            chb = script.read(1)\n            ch = int.from_bytes(chb, 'big')\n\n        s = cls(commands, message, keys=keys, signatures=signatures, blueprint=blueprint, tx_data=tx_data,\n                hash_type=hash_type)\n        script.seek(0)\n        s._raw = script.read()\n\n        s.script_types = _get_script_types(blueprint)\n        if 'unknown' in s.script_types:\n            s.script_types = ['unknown']\n\n        # Extract extra information from script data\n        for st in s.script_types[:1]:\n            if st == 'multisig':\n                s.redeemscript = s.raw\n                s.sigs_required = s.commands[0] - 80\n                if s.sigs_required > len(keys):\n                    raise ScriptError(\"Number of signatures required (%d) is higher then number of keys (%d)\" %\n                                      (s.sigs_required, len(keys)))\n                if len(s.keys) != s.commands[-2] - 80:\n                    raise ScriptError(\"%d keys found but %d keys expected\" %\n                                      (len(s.keys), s.commands[-2] - 80))\n            elif st in ['p2wpkh', 'p2wsh', 'p2sh', 'p2tr'] and len(s.commands) > 1:\n                s.public_hash = s.commands[1]\n            elif st == 'p2tr_unlock':\n                s.public_hash = s.commands[0]\n            elif st == 'p2pkh' and len(s.commands) > 2:\n                s.public_hash = s.commands[2]\n        s.redeemscript = redeemscript if redeemscript else s.redeemscript\n        if s.redeemscript and 'redeemscript' not in s.tx_data:\n            s.tx_data['redeemscript'] = s.redeemscript\n\n        s.sigs_required = sigs_required if sigs_required else s.sigs_required\n\n        return s\n\n    @classmethod\n    def parse_hex(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert hexadecimal string script to BytesIO.\n\n        >>> Script.parse_hex('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        <Script([op.op_dup, op.op_hash160, data-20, op.op_equalverify, op.op_checksig])>\n\n        :param script: Raw script to parse in hexadecimal string format\n        :type script: str\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = len(script) // 2\n        return cls.parse_bytesio(BytesIO(bytes.fromhex(script)), message, tx_data, data_length, strict, _level)\n\n    @classmethod\n    def parse_bytes(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert bytes script to BytesIO.\n\n        :param script: Raw script to parse in bytes format\n        :type script: bytes\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed or incomplete\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = len(script)\n        return cls.parse_bytesio(BytesIO(script), message, tx_data, data_length, strict, _level)\n\n    def __repr__(self):\n        s_items = []\n        for command in self.blueprint:\n            if isinstance(command, int):\n                s_items.append('op.' + opcodenames.get(command, 'unknown-op-%s' % command).lower())\n            else:\n                s_items.append(command)\n        return '<Script([' + ', '.join(s_items) + '])>'\n\n    def __str__(self):\n        s_items = []\n        for command in self.blueprint:\n            if isinstance(command, int):\n                s_items.append(opcodenames.get(command, 'unknown-op-%s' % command))\n            else:\n                s_items.append(command)\n        return ' '.join(s_items)\n\n    def __add__(self, other):\n        self.commands += other.commands\n        self._raw += other.raw\n        if other.message and not self.message:\n            self.message = other.message\n        self.is_locking = None\n        self.keys += other.keys\n        self.signatures += other.signatures\n        self._blueprint += other._blueprint\n        self.script_types = _get_script_types(self._blueprint)\n        if other.tx_data and not self.tx_data:\n            self.tx_data = other.tx_data\n        if other.redeemscript and not self.redeemscript:\n            self.redeemscript = other.redeemscript\n        return self\n\n    def __bool__(self):\n        return bool(self.commands)\n\n    def __hash__(self):\n        return hash160(self.raw)\n\n    @property\n    def blueprint(self):\n        # TODO: create blueprint from commands if empty\n        return self._blueprint\n\n    @property\n    def raw(self):\n        if not self._raw:\n            self._raw = self.serialize()\n        return self._raw\n\n    def serialize(self):\n        \"\"\"\n        Serialize script. Return all commands and data as bytes\n\n        >>> s = Script.parse_hex('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        >>> s.serialize().hex()\n        '76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac'\n\n        :return bytes:\n        \"\"\"\n        raw = b''\n        for cmd in self.commands:\n            if isinstance(cmd, int):\n                raw += bytes([cmd])\n            else:\n                raw += data_pack(cmd)\n        self._raw = raw\n        return raw\n\n    def serialize_list(self):\n        \"\"\"\n        Serialize script and return commands and data as list\n\n        >>> s = Script.parse_hex('76a9')\n        >>> s.serialize_list()\n        [b'v', b'\\\\xa9']\n\n        :return list of bytes:\n        \"\"\"\n        clist = []\n        for cmd in self.commands:\n            if isinstance(cmd, int):\n                clist.append(bytes([cmd]))\n            else:\n                clist.append(bytes(cmd))\n        return clist\n\n    def evaluate(self, message=None, tx_data=None):\n        \"\"\"\n        Evaluate script, run all commands and check if it is valid\n\n        >>> s = Script([op.op_2, op.op_4, op.op_add])\n        >>> s\n        <Script([op.op_2, op.op_4, op.op_add])>\n        >>> s.blueprint\n        [82, 84, 147]\n        >>> s.evaluate()\n        True\n\n        >>> lock_script = bytes.fromhex('76a914f9cc73824051cc82d64a716c836c54467a21e22c88ac')\n        >>> unlock_script = bytes.fromhex('483045022100ba2ec7c40257b3d22864c9558738eea4d8771ab97888368124e176fdd6d7cd8602200f47c8d0c437df1ea8f9819d344e05b9c93e38e88df1fc46abb6194506c50ce1012103e481f20561573cfd800e64efda61405917cb29e4bd20bed168c52b674937f535')\n        >>> s = Script.parse_bytes(unlock_script + lock_script)\n        >>> transaction_hash = bytes.fromhex('12824db63e7856d00ee5e109fd1c26ac8a6a015858c26f4b336274f6b52da1c3')\n        >>> s.evaluate(message=transaction_hash)\n        True\n\n        :param message: Signed message to verify, normally a transaction hash. Leave empty to use Script.message. If supplied Script.message will be ignored.\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts. Leave emtpy to use Script.tx_data. If supplied Script.tx_data will be ignored\n\n        :return bool: Valid or not valid\n        \"\"\"\n        self.message = self.message if message is None else message\n        self.tx_data = self.tx_data if tx_data is None else tx_data\n        self.stack = Stack()\n\n        commands = self.commands[:]\n        while len(commands):\n            command = commands.pop(0)\n            if isinstance(command, int):\n                if command == op.op_0:  # OP_0\n                    self.stack.append(encode_num(0))\n                elif command == op.op_1negate:  # OP_1NEGATE\n                    self.stack.append(encode_num(-1))\n                elif op.op_1 <= command <= op.op_16:   # OP_1 to OP_16\n                    self.stack.append(encode_num(command-80))\n                elif command == op.op_if or command == op.op_notif:\n                    method = opcodenames[command].lower()\n                    method = getattr(self.stack, method)\n                    if not method(commands):\n                        return False\n                else:\n                    method_name = opcodenames[command].lower()\n                    if method_name not in dir(self.stack):\n                        raise ScriptError(\"Method %s not found\" % method_name)\n                    try:\n                        method = getattr(self.stack, method_name)\n                        if method_name == 'op_checksig' or method_name == 'op_checksigverify':\n                            res = method(self.message)\n                        elif method_name == 'op_checkmultisig' or method_name == 'op_checkmultisigverify':\n                            res = method(self.message, self.tx_data)\n                        elif method_name == 'op_checklocktimeverify':\n                            res = self.stack.op_checklocktimeverify(\n                                self.tx_data['sequence'], self.tx_data.get('locktime'))\n                        elif method_name == 'op_checksequenceverify':\n                            res = self.stack.op_checksequenceverify(self.tx_data['sequence'], self.tx_data['version'])\n                        else:\n                            res = method()\n                        if res is False:\n                            return False\n                    except Exception as e:\n                        _logger.warning(\"Stack evaluate error: %s\" % e)\n                        return False\n            else:\n                self.stack.append(command)\n\n        if len(self.stack) == 0:\n            return False\n        if self.stack.pop() == b'':\n            return False\n\n        return True",
  "class Stack(list):\n    \"\"\"\n    The Stack object is a child of the Python list object with extra operational (OP) methods. The operations as\n    used in the Script language can be used to manipulate the stack / list.\n\n    For documentation of the op-methods you could check https://en.bitcoin.it/wiki/Script\n    \"\"\"\n\n    @classmethod\n    def from_ints(cls, list_ints):\n        \"\"\"\n        Create a Stack item with a list of integers.\n\n        >>> Stack.from_ints([1, 2])\n        [b'\\\\x01', b'\\\\x02']\n\n        :param list_ints:\n        :return:\n        \"\"\"\n        return Stack([encode_num(n) for n in list_ints])\n\n    def as_ints(self):\n        \"\"\"\n        Return the Stack as list of integers\n\n        >>> st = Stack.from_ints([1, 2])\n        >>> st.as_ints()\n        [1, 2]\n\n        :return list of int:\n        \"\"\"\n        # TODO: What to do with data/hashes?\n        return Stack([decode_num(x) for x in self])\n\n    def pop_as_number(self):\n        \"\"\"\n        Pop the latest item from the list and decode as number\n\n        >>> st = Stack.from_ints([1, 2])\n        >>> st.pop_as_number()\n        2\n\n        :return int:\n        \"\"\"\n        return decode_num(self.pop())\n\n    def is_arithmetic(self, items=1):\n        \"\"\"\n        Check if top stack item is or last stock are arithmetic and has no more than 4 bytes\n\n        :return bool:\n        \"\"\"\n        if len(self) < items:\n            raise IndexError(\"Not enough items in list to run operation. Items %d, expected %d\" % (len(self), items))\n        for i in self[-items:]:\n            if len(i) > 4:\n                return False\n        return True\n\n    # def op_ver()  # unused\n\n    def op_if(self, commands):\n        true_items = []\n        false_items = []\n        current_array = true_items\n        found = False\n        num_endifs_needed = 1\n        while len(commands) > 0:\n            item = commands.pop(0)\n            if item in (99, 100):\n                # nested if, we have to go another endif\n                num_endifs_needed += 1\n                current_array.append(item)\n            elif num_endifs_needed == 1 and item == 103:\n                current_array = false_items\n            elif item == 104:\n                if num_endifs_needed == 1:\n                    found = True\n                    break\n                else:\n                    num_endifs_needed -= 1\n                    current_array.append(item)\n            else:\n                current_array.append(item)\n        if not found:\n            return False\n        element = self.pop()\n        if decode_num(element) == 0:\n            commands[:0] = false_items\n        else:\n            commands[:0] = true_items\n        return True\n\n    def op_notif(self, commands):\n        element = self.pop()\n        if decode_num(element) == 0:\n            self.append(b'\\1')\n        else:\n            self.append(b'\\0')\n        return self.op_if(commands)\n\n    def op_nop(self):\n        return True\n\n    def op_verify(self):\n        if self.pop() == b'':\n            return False\n        return True\n\n    @staticmethod\n    def op_return():\n        return False\n\n    def op_2drop(self):\n        self.pop()\n        self.pop()\n        return True\n\n    def op_2dup(self):\n        if len(self) < 2:\n            raise ValueError(\"Stack op_2dup method requires minimum of 2 stack items\")\n        self.extend(self[-2:])\n        return True\n\n    def op_3dup(self):\n        if len(self) < 3:\n            raise ValueError(\"Stack op_3dup method requires minimum of 3 stack items\")\n        self.extend(self[-3:])\n        return True\n\n    def op_2over(self):\n        if len(self) < 4:\n            raise ValueError(\"Stack op_2over method requires minimum of 4 stack items\")\n        self.extend(self[-4:-2])\n        return True\n\n    def op_2rot(self):\n        self.extend([self.pop(-6), self.pop(-5)])\n        return True\n\n    def op_2swap(self):\n        self[-2:-2] = [self.pop(), self.pop()]\n        return True\n\n    def op_ifdup(self):\n        if not len(self):\n            raise ValueError(\"Stack op_ifdup method requires minimum of 1 stack item\")\n        if self[-1] != b'':\n            self.append(self[-1])\n        return True\n\n    def op_depth(self):\n        self.append(encode_num(len(self)))\n        return True\n\n    def op_drop(self):\n        self.pop()\n        return True\n\n    def op_dup(self):\n        if not len(self):\n            return False\n        self.append(self[-1])\n        return True\n\n    def op_nip(self):\n        self.pop(-2)\n        return True\n\n    def op_over(self):\n        if len(self) < 2:\n            raise ValueError(\"Stack op_over method requires minimum of 2 stack items\")\n        self.append(self[-2])\n        return True\n\n    def op_pick(self):\n        self.append(self[-self.pop_as_number()])\n        return True\n\n    def op_roll(self):\n        self.append(self.pop(-self.pop_as_number()))\n        return True\n\n    def op_rot(self):\n        self.append(self.pop(-3))\n        return True\n\n    def op_swap(self):\n        self.append(self.pop(-2))\n        return True\n\n    def op_tuck(self):\n        self.append(self[-2])\n        return True\n\n    def op_size(self):\n        self.append(encode_num(len(self[-1])))\n        return True\n\n    def op_equal(self):\n        self.append(b'\\x01' if self.pop() == self.pop() else b'')\n        return True\n\n    def op_equalverify(self):\n        self.op_equal()\n        return self.op_verify()\n\n    # # 'op_reserved1': unused\n    # # 'op_reserved2': unused\n\n    def op_1add(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(self.pop_as_number() + 1))\n        return True\n\n    def op_1sub(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(self.pop_as_number() - 1))\n        return True\n\n    def op_negate(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(-self.pop_as_number()))\n        return True\n\n    def op_abs(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(abs(self.pop_as_number())))\n        return True\n\n    def op_not(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(b'\\1' if self.pop() == b'' else b'')\n        return True\n\n    def op_0notequal(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(b'' if self.pop() == b'' else b'\\1')\n        return True\n\n    def op_add(self):\n        if not self.is_arithmetic(2):\n            return False\n        self.append(encode_num(self.pop_as_number() + self.pop_as_number()))\n        return True\n\n    def op_sub(self):\n        if not self.is_arithmetic(2):\n            return False\n        self.append(encode_num(self.pop_as_number() - self.pop_as_number()))\n        return True\n\n    def op_booland(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop()\n        b = self.pop()\n        if a != b'' and b != b'':\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_boolor(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop()\n        b = self.pop()\n        if a != b'' or b != b'':\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop() == self.pop():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numequalverify(self):\n        self.op_numequal()\n        return self.op_verify()\n\n    def op_numnotequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop() != self.pop():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numlessthan(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() < self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numgreaterthan(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() > self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numlessthanorequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() <= self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_numgreaterthanorequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() >= self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_min(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop_as_number()\n        b = self.pop_as_number()\n        self.append(encode_num(a) if a < b else encode_num(b))\n        return True\n\n    def op_max(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop_as_number()\n        b = self.pop_as_number()\n        self.append(encode_num(a) if a > b else encode_num(b))\n        return True\n\n    def op_within(self):\n        if not self.is_arithmetic(3):\n            return False\n        x = self.pop_as_number()\n        vmin = self.pop_as_number()\n        vmax = self.pop_as_number()\n        if vmin <= x < vmax:\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_ripemd160(self):\n        # self.append(hashlib.new('ripemd160', self.pop()).digest())\n        self.append(ripemd160(self.pop()))\n        return True\n\n    def op_sha1(self):\n        self.append(hashlib.sha1(self.pop()).digest())\n        return True\n\n    def op_sha256(self):\n        self.append(hashlib.sha256(self.pop()).digest())\n        return True\n\n    def op_hash160(self):\n        self.append(hash160(self.pop()))\n        return True\n\n    def op_hash256(self):\n        self.op_sha256()\n        self.op_sha256()\n        return True\n\n    def op_checksig(self, message, _=None):\n        public_key = self.pop()\n        signature = self.pop()\n        signature = Signature.parse_bytes(signature, public_key=public_key)\n        if signature.verify(message, public_key):\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_checksigverify(self, message, _=None):\n        return self.op_checksig(message, None) and self.op_verify()\n\n    def op_checkmultisig(self, message, data=None):\n        n = decode_num(self.pop())\n        pubkeys = []\n        for _ in range(n):\n            pubkeys.append(self.pop())\n        m = decode_num(self.pop())\n        signatures = []\n        for _ in range(m):\n            signatures.append(self.pop())\n        if len(self):\n            # OP_CHECKMULTISIG bug\n            self.pop()\n        sigcount = 0\n        for pubkey in pubkeys:\n            s = Signature.parse_bytes(signatures[sigcount])\n            if s.verify(message, pubkey):\n                sigcount += 1\n                if sigcount >= len(signatures):\n                    break\n\n        if sigcount == len(signatures):\n            if data and 'redeemscript' in data:\n                self.append(data['redeemscript'])\n            else:\n                self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True\n\n    def op_checkmultisigverify(self, message, data=None):\n        return self.op_checkmultisig(message, data) and self.op_verify()\n\n    def op_nop1(self):\n        return True\n\n    def op_checklocktimeverify(self, sequence, tx_locktime):\n        \"\"\"\n        Implements CHECKLOCKTIMEVERIFY opcode (CLTV) as defined in BIP65.\n\n        CLTV is an absolute timelock and is added to an output locking script. It locks an output until a certain\n        time or block.\n\n        :param sequence: Sequence value from the transaction. Must be 0xffffffff to be valid\n        :type sequence: int\n        :param tx_locktime: The nLocktime value from the transaction in blocks or as Median Time Past timestamp\n        :type tx_locktime: int\n\n        :return bool:\n        \"\"\"\n        # TODO: Check, add to Script/Transaction and add unittests\n        if not tx_locktime:\n            return False\n        if sequence == 0xffffffff:\n            return False\n        locktime = decode_num(self[-1])\n        if locktime < 0:\n            return False\n        if locktime < 50000000 < tx_locktime or locktime > 50000000 > tx_locktime:\n            return False\n        if tx_locktime < locktime:\n            return False\n        return True\n\n    def op_checksequenceverify(self, sequence, version):\n        \"\"\"\n        Implements CHECKSEQUENCEVERIFY opcode (CSV) as defined in BIP112\n\n        CSV is a relative timelock and is added to an output locking script. It locks an output for a certain number\n        of blocks or time.\n\n        :param sequence: Sequence value from the transaction\n        :type sequence: int\n        :param version: Transaction verion. Must be 2 or higher\n        :type version: int\n\n        :return bool:\n        \"\"\"\n        # TODO: Implement\n        # if sequence == 0xffffffff:\n        #     return False\n        # locktime = decode_num(self[-1])\n        # if locktime < 0:\n        #     return False\n        # if locktime != 0xffffffff:\n        #     if version < 2:\n        #         return False\n        # return True\n        return NotImplementedError\n\n    def op_nop4(self):\n        return True\n\n    def op_nop5(self):\n        return True\n\n    def op_nop6(self):\n        return True\n\n    def op_nop7(self):\n        return True\n\n    def op_nop8(self):\n        return True\n\n    def op_nop9(self):\n        return True\n\n    def op_nop10(self):\n        return True",
  "def encode_num(num):\n    \"\"\"\n    Encode number as byte used in Script language. Bitcoin specific little endian format with sign for negative\n    integers.\n\n    >>> encode_num(0)\n    b''\n    >>> encode_num(1)\n    b'\\\\x01'\n    >>> encode_num(1000)\n    b'\\\\xe8\\\\x03'\n    >>> encode_num(1000000)\n    b'@B\\\\x0f'\n\n    :param num: number to represent\n    :type num: int\n\n    :return bytes:\n    \"\"\"\n    if num == 0:\n        return b''\n    abs_num = abs(num)\n    negative = num < 0\n    length = (num.bit_length() + 7) // 8\n    encoded = abs_num.to_bytes(length, byteorder='little')\n    if encoded[-1] & 0x80:\n        if negative:\n            encoded += b'\\x80'\n        else:\n            encoded += b'\\0'\n    elif negative:\n        encoded = encoded[:-1] + (encoded[-1] + 0x80).to_bytes(1, 'big')\n    return encoded",
  "def decode_num(encoded):\n    \"\"\"\n    Decode byte representation of number used in Script language to integer.\n\n    >>> decode_num(b'')\n    0\n    >>> decode_num(b'@B\\\\x0f')\n    1000000\n\n    :param encoded: Number to decode\n    :type encoded: bytes\n\n    :return int:\n    \"\"\"\n    if encoded == b'':\n        return 0\n    negative = False\n    if encoded[-1] & 0x80:\n        negative = True\n    element = encoded[:-1] + (encoded[-1] & 0x7f).to_bytes(1, 'big')\n    num = int.from_bytes(element, 'little')\n    if negative:\n        return -num\n    else:\n        return num",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def __init__(self, commands=None, message=None, script_types='', is_locking=True, keys=None, signatures=None,\n                 blueprint=None, tx_data=None, public_hash=b'', sigs_required=None, redeemscript=b'',\n                 hash_type=SIGHASH_ALL):\n        \"\"\"\n        Create a Script object with specified parameters. Use parse() method to create a Script from raw hex\n\n        >>> s = Script([op.op_2, op.op_4, op.op_add])\n        >>> s\n        <Script([op.op_2, op.op_4, op.op_add])>\n        >>> s.blueprint\n        [82, 84, 147]\n        >>> s.evaluate()\n        True\n\n        Stack is empty now, because evaluate pops last item from stack and check if is non-zero\n        >>> s.stack\n        []\n\n        :param commands: List of script language commands\n        :type commands: list\n        :param message: Signed message to verify, normally a transaction hash. Used to validate script\n        :type message: bytes\n        :param script_types: List of script_types as defined in SCRIPT_TYPES\n        :type script_types: list of str\n        :param is_locking: Is this a locking script (Output), otherwise unlocking (Input)\n        :type is_locking: bool\n        :param keys: Provide list of keys to create script\n        :type keys: list of Key\n        :param signatures: Provide list of signatures to create script\n        :type signatures: list of Signature\n        :param blueprint: Simplified version of script, normally generated by Script object\n        :type blueprint: list of str\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param public_hash: Public hash of key or redeemscript used to create scripts\n        :type public_hash: bytes\n        :param sigs_required: Nubmer of signatures required to create multisig script\n        :type sigs_required: int\n        :param redeemscript: Provide redeemscript to create a new (multisig) script\n        :type redeemscript: bytes\n        :param hash_type: Specific script hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        \"\"\"\n        self.commands = commands if commands else []\n        self._raw = b''\n        self.stack = []\n        self.message = message\n        self.script_types = script_types if script_types else []\n        self.is_locking = is_locking\n        self.keys = keys if keys else []\n        self.signatures = signatures if signatures else []\n        self._blueprint = blueprint if blueprint else []\n        self.tx_data = {} if not tx_data else tx_data\n        self.sigs_required = sigs_required if sigs_required else len(self.keys) if len(self.keys) else 1\n        self.redeemscript = redeemscript\n        self.public_hash = public_hash\n        self.hash_type = hash_type\n\n        if not self.commands and self.script_types and (self.keys or self.signatures or self.public_hash):\n            for st in self.script_types:\n                st_values = SCRIPT_TYPES[st]\n                script_template = st_values[1]\n                self.is_locking = True if st_values[0] == 'locking' else False\n                sig_n_and_m = [len(self.keys), self.sigs_required]\n                for tc in script_template:\n                    command = [tc]\n                    if tc == 'data':\n                        command = [self.public_hash] if self.public_hash else []\n                    elif tc == 'signature':\n                        command = self.signatures\n                    elif tc == 'key':\n                        command = self.keys\n                    elif tc == 'op_n':\n                        command = [sig_n_and_m.pop() + 80]\n                    elif tc == 'redeemscript':\n                        command = [self.redeemscript]\n                    if not command or command == [b'']:\n                        raise ScriptError(\"Cannot create script, please supply %s\" % (tc if tc != 'data' else\n                                          'public key hash'))\n                    self.commands += command\n        if not (self.keys and self.signatures and self.blueprint):\n            self._blueprint = []\n            for c in self.commands:\n                if isinstance(c, int):\n                    self._blueprint.append(c)\n                else:\n                    data_type = get_data_type(c)\n                    if data_type in ['key', 'signature', 'key_object', 'signature_object']:\n                        if data_type == 'key_object':\n                            data_type = 'key'\n                        elif data_type == 'signature_object':\n                            data_type = 'signature'\n                        self._blueprint.append(data_type)\n                    else:\n                        self._blueprint.append('data-%d' % len(c))",
  "def parse(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert hexadecimal string or bytes script to BytesIO.\n\n        >>> Script.parse('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        <Script([op.op_dup, op.op_hash160, data-20, op.op_equalverify, op.op_checksig])>\n\n        :param script: Raw script to parse in bytes, BytesIO or hexadecimal string format\n        :type script: BytesIO, bytes, str\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = None\n        if isinstance(script, bytes):\n            data_length = len(script) // 2\n            script = BytesIO(script)\n        elif isinstance(script, str):\n            data_length = len(script)\n            script = BytesIO(bytes.fromhex(script))\n        return cls.parse_bytesio(script, message, tx_data, data_length, strict, _level)",
  "def parse_bytesio(cls, script, message=None, tx_data=None, data_length=0, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        :param script: Raw script to parse in bytes, BytesIO or hexadecimal string format\n        :type script: BytesIO\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param data_length: Length of script data if known. Supply if you can to increase efficiency and lower change of incorrect parsing\n        :type data_length: int\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        commands = []\n        signatures = []\n        keys = []\n        blueprint = []\n        redeemscript = b''\n        sigs_required = None\n        # hash_type = SIGHASH_ALL  # todo: check\n        hash_type = None\n        if not tx_data:\n            tx_data = {}\n\n        chb = script.read(1)\n        ch = int.from_bytes(chb, 'big')\n        data = None\n        if chb == b'\\x30' and 69 <= data_length <= 74:\n            data = chb + script.read(data_length - 1)\n        elif ((chb == b'\\x02' or chb == b'\\x03') and data_length == 33) or \\\n                (chb == b'\\x04' and data_length == 65):\n            data = chb + script.read(data_length - 1)\n        elif data_length == 64:\n            data = chb + script.read(data_length - 1)\n        else:\n            data_length = 0\n\n        while chb and script:\n            if data:\n                data_type = get_data_type(data)\n                commands.append(data)\n                if data_type == 'signature':\n                    try:\n                        sig = Signature.parse_bytes(data)\n                        signatures.append(sig)\n                        hash_type = sig.hash_type\n                        blueprint.append('signature')\n                    except Exception as e:\n                        if strict:\n                            raise ScriptError(str(e))\n                        else:\n                            _logger.warning(str(e))\n                elif data_type == 'signature_object':\n                    signatures.append(data)\n                    hash_type = data.hash_type\n                    blueprint.append('signature')\n                elif data_type == 'key':\n                    keys.append(Key(data))\n                    blueprint.append('key')\n                elif data_type == 'key_object':\n                    keys.append(data)\n                    blueprint.append('key')\n                elif data_type[:4] == 'data':\n                    # FIXME: This is arbitrary\n                    blueprint.append('data-%d' % len(data))\n                elif len(commands) >= 2 and commands[-2] == op.op_return:\n                    blueprint.append('data-%d' % len(data))\n                else:\n                    # FIXME: Only parse sub-scripts if script is expected\n                    try:\n                        if _level >= 1:\n                            blueprint.append('data-%d' % len(data))\n                        else:\n                            s2 = Script.parse_bytes(data, _level=_level+1, strict=strict)\n                            commands.pop()\n                            commands += s2.commands\n                            blueprint += s2.blueprint\n                            keys += s2.keys\n                            signatures += s2.signatures\n                            redeemscript = s2.redeemscript\n                            sigs_required = s2.sigs_required\n                    except (ScriptError, IndexError):\n                        blueprint.append('data-%d' % len(data))\n                data = None\n                data_length = 0\n            else:  # Other opcode\n                if 1 <= ch <= 75:  # Data`\n                    data_length = ch\n                elif ch == op.op_pushdata1:\n                    data_length = int.from_bytes(script.read(1), 'little')\n                elif ch == op.op_pushdata2:\n                    data_length = int.from_bytes(script.read(2), 'little')\n                if data_length:\n                    data = script.read(data_length)\n                    if len(data) != data_length:\n                        msg = \"Malformed script, not enough data found\"\n                        if strict:\n                            raise ScriptError(msg)\n                        else:\n                            chb = b''\n                            _logger.warning(msg)\n                    continue\n\n                commands.append(ch)\n                blueprint.append(ch)\n\n            chb = script.read(1)\n            ch = int.from_bytes(chb, 'big')\n\n        s = cls(commands, message, keys=keys, signatures=signatures, blueprint=blueprint, tx_data=tx_data,\n                hash_type=hash_type)\n        script.seek(0)\n        s._raw = script.read()\n\n        s.script_types = _get_script_types(blueprint)\n        if 'unknown' in s.script_types:\n            s.script_types = ['unknown']\n\n        # Extract extra information from script data\n        for st in s.script_types[:1]:\n            if st == 'multisig':\n                s.redeemscript = s.raw\n                s.sigs_required = s.commands[0] - 80\n                if s.sigs_required > len(keys):\n                    raise ScriptError(\"Number of signatures required (%d) is higher then number of keys (%d)\" %\n                                      (s.sigs_required, len(keys)))\n                if len(s.keys) != s.commands[-2] - 80:\n                    raise ScriptError(\"%d keys found but %d keys expected\" %\n                                      (len(s.keys), s.commands[-2] - 80))\n            elif st in ['p2wpkh', 'p2wsh', 'p2sh', 'p2tr'] and len(s.commands) > 1:\n                s.public_hash = s.commands[1]\n            elif st == 'p2tr_unlock':\n                s.public_hash = s.commands[0]\n            elif st == 'p2pkh' and len(s.commands) > 2:\n                s.public_hash = s.commands[2]\n        s.redeemscript = redeemscript if redeemscript else s.redeemscript\n        if s.redeemscript and 'redeemscript' not in s.tx_data:\n            s.tx_data['redeemscript'] = s.redeemscript\n\n        s.sigs_required = sigs_required if sigs_required else s.sigs_required\n\n        return s",
  "def parse_hex(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert hexadecimal string script to BytesIO.\n\n        >>> Script.parse_hex('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        <Script([op.op_dup, op.op_hash160, data-20, op.op_equalverify, op.op_checksig])>\n\n        :param script: Raw script to parse in hexadecimal string format\n        :type script: str\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed, incomplete or not understood. Default is True\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = len(script) // 2\n        return cls.parse_bytesio(BytesIO(bytes.fromhex(script)), message, tx_data, data_length, strict, _level)",
  "def parse_bytes(cls, script, message=None, tx_data=None, strict=True, _level=0):\n        \"\"\"\n        Parse raw script and return Script object. Extracts script commands, keys, signatures and other data.\n\n        Wrapper for the :func:`parse_bytesio` method. Convert bytes script to BytesIO.\n\n        :param script: Raw script to parse in bytes format\n        :type script: bytes\n        :param message: Signed message to verify, normally a transaction hash\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts\n        :type tx_data: dict\n        :param strict: Raise exception when script is malformed or incomplete\n        :type strict: bool\n        :param _level: Internal argument used to avoid recursive depth\n        :type _level: int\n\n        :return Script:\n        \"\"\"\n        data_length = len(script)\n        return cls.parse_bytesio(BytesIO(script), message, tx_data, data_length, strict, _level)",
  "def __repr__(self):\n        s_items = []\n        for command in self.blueprint:\n            if isinstance(command, int):\n                s_items.append('op.' + opcodenames.get(command, 'unknown-op-%s' % command).lower())\n            else:\n                s_items.append(command)\n        return '<Script([' + ', '.join(s_items) + '])>'",
  "def __str__(self):\n        s_items = []\n        for command in self.blueprint:\n            if isinstance(command, int):\n                s_items.append(opcodenames.get(command, 'unknown-op-%s' % command))\n            else:\n                s_items.append(command)\n        return ' '.join(s_items)",
  "def __add__(self, other):\n        self.commands += other.commands\n        self._raw += other.raw\n        if other.message and not self.message:\n            self.message = other.message\n        self.is_locking = None\n        self.keys += other.keys\n        self.signatures += other.signatures\n        self._blueprint += other._blueprint\n        self.script_types = _get_script_types(self._blueprint)\n        if other.tx_data and not self.tx_data:\n            self.tx_data = other.tx_data\n        if other.redeemscript and not self.redeemscript:\n            self.redeemscript = other.redeemscript\n        return self",
  "def __bool__(self):\n        return bool(self.commands)",
  "def __hash__(self):\n        return hash160(self.raw)",
  "def blueprint(self):\n        # TODO: create blueprint from commands if empty\n        return self._blueprint",
  "def raw(self):\n        if not self._raw:\n            self._raw = self.serialize()\n        return self._raw",
  "def serialize(self):\n        \"\"\"\n        Serialize script. Return all commands and data as bytes\n\n        >>> s = Script.parse_hex('76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac')\n        >>> s.serialize().hex()\n        '76a914af8e14a2cecd715c363b3a72b55b59a31e2acac988ac'\n\n        :return bytes:\n        \"\"\"\n        raw = b''\n        for cmd in self.commands:\n            if isinstance(cmd, int):\n                raw += bytes([cmd])\n            else:\n                raw += data_pack(cmd)\n        self._raw = raw\n        return raw",
  "def serialize_list(self):\n        \"\"\"\n        Serialize script and return commands and data as list\n\n        >>> s = Script.parse_hex('76a9')\n        >>> s.serialize_list()\n        [b'v', b'\\\\xa9']\n\n        :return list of bytes:\n        \"\"\"\n        clist = []\n        for cmd in self.commands:\n            if isinstance(cmd, int):\n                clist.append(bytes([cmd]))\n            else:\n                clist.append(bytes(cmd))\n        return clist",
  "def evaluate(self, message=None, tx_data=None):\n        \"\"\"\n        Evaluate script, run all commands and check if it is valid\n\n        >>> s = Script([op.op_2, op.op_4, op.op_add])\n        >>> s\n        <Script([op.op_2, op.op_4, op.op_add])>\n        >>> s.blueprint\n        [82, 84, 147]\n        >>> s.evaluate()\n        True\n\n        >>> lock_script = bytes.fromhex('76a914f9cc73824051cc82d64a716c836c54467a21e22c88ac')\n        >>> unlock_script = bytes.fromhex('483045022100ba2ec7c40257b3d22864c9558738eea4d8771ab97888368124e176fdd6d7cd8602200f47c8d0c437df1ea8f9819d344e05b9c93e38e88df1fc46abb6194506c50ce1012103e481f20561573cfd800e64efda61405917cb29e4bd20bed168c52b674937f535')\n        >>> s = Script.parse_bytes(unlock_script + lock_script)\n        >>> transaction_hash = bytes.fromhex('12824db63e7856d00ee5e109fd1c26ac8a6a015858c26f4b336274f6b52da1c3')\n        >>> s.evaluate(message=transaction_hash)\n        True\n\n        :param message: Signed message to verify, normally a transaction hash. Leave empty to use Script.message. If supplied Script.message will be ignored.\n        :type message: bytes\n        :param tx_data: Dictionary with extra information needed to verify script. Such as 'redeemscript' for multisignature scripts and 'blockcount' for time locked scripts. Leave emtpy to use Script.tx_data. If supplied Script.tx_data will be ignored\n\n        :return bool: Valid or not valid\n        \"\"\"\n        self.message = self.message if message is None else message\n        self.tx_data = self.tx_data if tx_data is None else tx_data\n        self.stack = Stack()\n\n        commands = self.commands[:]\n        while len(commands):\n            command = commands.pop(0)\n            if isinstance(command, int):\n                if command == op.op_0:  # OP_0\n                    self.stack.append(encode_num(0))\n                elif command == op.op_1negate:  # OP_1NEGATE\n                    self.stack.append(encode_num(-1))\n                elif op.op_1 <= command <= op.op_16:   # OP_1 to OP_16\n                    self.stack.append(encode_num(command-80))\n                elif command == op.op_if or command == op.op_notif:\n                    method = opcodenames[command].lower()\n                    method = getattr(self.stack, method)\n                    if not method(commands):\n                        return False\n                else:\n                    method_name = opcodenames[command].lower()\n                    if method_name not in dir(self.stack):\n                        raise ScriptError(\"Method %s not found\" % method_name)\n                    try:\n                        method = getattr(self.stack, method_name)\n                        if method_name == 'op_checksig' or method_name == 'op_checksigverify':\n                            res = method(self.message)\n                        elif method_name == 'op_checkmultisig' or method_name == 'op_checkmultisigverify':\n                            res = method(self.message, self.tx_data)\n                        elif method_name == 'op_checklocktimeverify':\n                            res = self.stack.op_checklocktimeverify(\n                                self.tx_data['sequence'], self.tx_data.get('locktime'))\n                        elif method_name == 'op_checksequenceverify':\n                            res = self.stack.op_checksequenceverify(self.tx_data['sequence'], self.tx_data['version'])\n                        else:\n                            res = method()\n                        if res is False:\n                            return False\n                    except Exception as e:\n                        _logger.warning(\"Stack evaluate error: %s\" % e)\n                        return False\n            else:\n                self.stack.append(command)\n\n        if len(self.stack) == 0:\n            return False\n        if self.stack.pop() == b'':\n            return False\n\n        return True",
  "def from_ints(cls, list_ints):\n        \"\"\"\n        Create a Stack item with a list of integers.\n\n        >>> Stack.from_ints([1, 2])\n        [b'\\\\x01', b'\\\\x02']\n\n        :param list_ints:\n        :return:\n        \"\"\"\n        return Stack([encode_num(n) for n in list_ints])",
  "def as_ints(self):\n        \"\"\"\n        Return the Stack as list of integers\n\n        >>> st = Stack.from_ints([1, 2])\n        >>> st.as_ints()\n        [1, 2]\n\n        :return list of int:\n        \"\"\"\n        # TODO: What to do with data/hashes?\n        return Stack([decode_num(x) for x in self])",
  "def pop_as_number(self):\n        \"\"\"\n        Pop the latest item from the list and decode as number\n\n        >>> st = Stack.from_ints([1, 2])\n        >>> st.pop_as_number()\n        2\n\n        :return int:\n        \"\"\"\n        return decode_num(self.pop())",
  "def is_arithmetic(self, items=1):\n        \"\"\"\n        Check if top stack item is or last stock are arithmetic and has no more than 4 bytes\n\n        :return bool:\n        \"\"\"\n        if len(self) < items:\n            raise IndexError(\"Not enough items in list to run operation. Items %d, expected %d\" % (len(self), items))\n        for i in self[-items:]:\n            if len(i) > 4:\n                return False\n        return True",
  "def op_if(self, commands):\n        true_items = []\n        false_items = []\n        current_array = true_items\n        found = False\n        num_endifs_needed = 1\n        while len(commands) > 0:\n            item = commands.pop(0)\n            if item in (99, 100):\n                # nested if, we have to go another endif\n                num_endifs_needed += 1\n                current_array.append(item)\n            elif num_endifs_needed == 1 and item == 103:\n                current_array = false_items\n            elif item == 104:\n                if num_endifs_needed == 1:\n                    found = True\n                    break\n                else:\n                    num_endifs_needed -= 1\n                    current_array.append(item)\n            else:\n                current_array.append(item)\n        if not found:\n            return False\n        element = self.pop()\n        if decode_num(element) == 0:\n            commands[:0] = false_items\n        else:\n            commands[:0] = true_items\n        return True",
  "def op_notif(self, commands):\n        element = self.pop()\n        if decode_num(element) == 0:\n            self.append(b'\\1')\n        else:\n            self.append(b'\\0')\n        return self.op_if(commands)",
  "def op_nop(self):\n        return True",
  "def op_verify(self):\n        if self.pop() == b'':\n            return False\n        return True",
  "def op_return():\n        return False",
  "def op_2drop(self):\n        self.pop()\n        self.pop()\n        return True",
  "def op_2dup(self):\n        if len(self) < 2:\n            raise ValueError(\"Stack op_2dup method requires minimum of 2 stack items\")\n        self.extend(self[-2:])\n        return True",
  "def op_3dup(self):\n        if len(self) < 3:\n            raise ValueError(\"Stack op_3dup method requires minimum of 3 stack items\")\n        self.extend(self[-3:])\n        return True",
  "def op_2over(self):\n        if len(self) < 4:\n            raise ValueError(\"Stack op_2over method requires minimum of 4 stack items\")\n        self.extend(self[-4:-2])\n        return True",
  "def op_2rot(self):\n        self.extend([self.pop(-6), self.pop(-5)])\n        return True",
  "def op_2swap(self):\n        self[-2:-2] = [self.pop(), self.pop()]\n        return True",
  "def op_ifdup(self):\n        if not len(self):\n            raise ValueError(\"Stack op_ifdup method requires minimum of 1 stack item\")\n        if self[-1] != b'':\n            self.append(self[-1])\n        return True",
  "def op_depth(self):\n        self.append(encode_num(len(self)))\n        return True",
  "def op_drop(self):\n        self.pop()\n        return True",
  "def op_dup(self):\n        if not len(self):\n            return False\n        self.append(self[-1])\n        return True",
  "def op_nip(self):\n        self.pop(-2)\n        return True",
  "def op_over(self):\n        if len(self) < 2:\n            raise ValueError(\"Stack op_over method requires minimum of 2 stack items\")\n        self.append(self[-2])\n        return True",
  "def op_pick(self):\n        self.append(self[-self.pop_as_number()])\n        return True",
  "def op_roll(self):\n        self.append(self.pop(-self.pop_as_number()))\n        return True",
  "def op_rot(self):\n        self.append(self.pop(-3))\n        return True",
  "def op_swap(self):\n        self.append(self.pop(-2))\n        return True",
  "def op_tuck(self):\n        self.append(self[-2])\n        return True",
  "def op_size(self):\n        self.append(encode_num(len(self[-1])))\n        return True",
  "def op_equal(self):\n        self.append(b'\\x01' if self.pop() == self.pop() else b'')\n        return True",
  "def op_equalverify(self):\n        self.op_equal()\n        return self.op_verify()",
  "def op_1add(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(self.pop_as_number() + 1))\n        return True",
  "def op_1sub(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(self.pop_as_number() - 1))\n        return True",
  "def op_negate(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(-self.pop_as_number()))\n        return True",
  "def op_abs(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(encode_num(abs(self.pop_as_number())))\n        return True",
  "def op_not(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(b'\\1' if self.pop() == b'' else b'')\n        return True",
  "def op_0notequal(self):\n        if not self.is_arithmetic():\n            return False\n        self.append(b'' if self.pop() == b'' else b'\\1')\n        return True",
  "def op_add(self):\n        if not self.is_arithmetic(2):\n            return False\n        self.append(encode_num(self.pop_as_number() + self.pop_as_number()))\n        return True",
  "def op_sub(self):\n        if not self.is_arithmetic(2):\n            return False\n        self.append(encode_num(self.pop_as_number() - self.pop_as_number()))\n        return True",
  "def op_booland(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop()\n        b = self.pop()\n        if a != b'' and b != b'':\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_boolor(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop()\n        b = self.pop()\n        if a != b'' or b != b'':\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop() == self.pop():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numequalverify(self):\n        self.op_numequal()\n        return self.op_verify()",
  "def op_numnotequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop() != self.pop():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numlessthan(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() < self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numgreaterthan(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() > self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numlessthanorequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() <= self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_numgreaterthanorequal(self):\n        if not self.is_arithmetic(2):\n            return False\n        if self.pop_as_number() >= self.pop_as_number():\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_min(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop_as_number()\n        b = self.pop_as_number()\n        self.append(encode_num(a) if a < b else encode_num(b))\n        return True",
  "def op_max(self):\n        if not self.is_arithmetic(2):\n            return False\n        a = self.pop_as_number()\n        b = self.pop_as_number()\n        self.append(encode_num(a) if a > b else encode_num(b))\n        return True",
  "def op_within(self):\n        if not self.is_arithmetic(3):\n            return False\n        x = self.pop_as_number()\n        vmin = self.pop_as_number()\n        vmax = self.pop_as_number()\n        if vmin <= x < vmax:\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_ripemd160(self):\n        # self.append(hashlib.new('ripemd160', self.pop()).digest())\n        self.append(ripemd160(self.pop()))\n        return True",
  "def op_sha1(self):\n        self.append(hashlib.sha1(self.pop()).digest())\n        return True",
  "def op_sha256(self):\n        self.append(hashlib.sha256(self.pop()).digest())\n        return True",
  "def op_hash160(self):\n        self.append(hash160(self.pop()))\n        return True",
  "def op_hash256(self):\n        self.op_sha256()\n        self.op_sha256()\n        return True",
  "def op_checksig(self, message, _=None):\n        public_key = self.pop()\n        signature = self.pop()\n        signature = Signature.parse_bytes(signature, public_key=public_key)\n        if signature.verify(message, public_key):\n            self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_checksigverify(self, message, _=None):\n        return self.op_checksig(message, None) and self.op_verify()",
  "def op_checkmultisig(self, message, data=None):\n        n = decode_num(self.pop())\n        pubkeys = []\n        for _ in range(n):\n            pubkeys.append(self.pop())\n        m = decode_num(self.pop())\n        signatures = []\n        for _ in range(m):\n            signatures.append(self.pop())\n        if len(self):\n            # OP_CHECKMULTISIG bug\n            self.pop()\n        sigcount = 0\n        for pubkey in pubkeys:\n            s = Signature.parse_bytes(signatures[sigcount])\n            if s.verify(message, pubkey):\n                sigcount += 1\n                if sigcount >= len(signatures):\n                    break\n\n        if sigcount == len(signatures):\n            if data and 'redeemscript' in data:\n                self.append(data['redeemscript'])\n            else:\n                self.append(b'\\1')\n        else:\n            self.append(b'')\n        return True",
  "def op_checkmultisigverify(self, message, data=None):\n        return self.op_checkmultisig(message, data) and self.op_verify()",
  "def op_nop1(self):\n        return True",
  "def op_checklocktimeverify(self, sequence, tx_locktime):\n        \"\"\"\n        Implements CHECKLOCKTIMEVERIFY opcode (CLTV) as defined in BIP65.\n\n        CLTV is an absolute timelock and is added to an output locking script. It locks an output until a certain\n        time or block.\n\n        :param sequence: Sequence value from the transaction. Must be 0xffffffff to be valid\n        :type sequence: int\n        :param tx_locktime: The nLocktime value from the transaction in blocks or as Median Time Past timestamp\n        :type tx_locktime: int\n\n        :return bool:\n        \"\"\"\n        # TODO: Check, add to Script/Transaction and add unittests\n        if not tx_locktime:\n            return False\n        if sequence == 0xffffffff:\n            return False\n        locktime = decode_num(self[-1])\n        if locktime < 0:\n            return False\n        if locktime < 50000000 < tx_locktime or locktime > 50000000 > tx_locktime:\n            return False\n        if tx_locktime < locktime:\n            return False\n        return True",
  "def op_checksequenceverify(self, sequence, version):\n        \"\"\"\n        Implements CHECKSEQUENCEVERIFY opcode (CSV) as defined in BIP112\n\n        CSV is a relative timelock and is added to an output locking script. It locks an output for a certain number\n        of blocks or time.\n\n        :param sequence: Sequence value from the transaction\n        :type sequence: int\n        :param version: Transaction verion. Must be 2 or higher\n        :type version: int\n\n        :return bool:\n        \"\"\"\n        # TODO: Implement\n        # if sequence == 0xffffffff:\n        #     return False\n        # locktime = decode_num(self[-1])\n        # if locktime < 0:\n        #     return False\n        # if locktime != 0xffffffff:\n        #     if version < 2:\n        #         return False\n        # return True\n        return NotImplementedError",
  "def op_nop4(self):\n        return True",
  "def op_nop5(self):\n        return True",
  "def op_nop6(self):\n        return True",
  "def op_nop7(self):\n        return True",
  "def op_nop8(self):\n        return True",
  "def op_nop9(self):\n        return True",
  "def op_nop10(self):\n        return True",
  "class WalletError(Exception):\n    \"\"\"\n    Handle Wallet class Exceptions\n\n    \"\"\"\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "def wallets_list(db_uri=None, include_cosigners=False, db_password=None):\n    \"\"\"\n    List Wallets from database\n\n    :param db_uri: URI of the database\n    :type db_uri: str\n\n    :param include_cosigners: Child wallets for multisig wallets are for internal use only and are skipped by default\n    :type include_cosigners: bool\n    :param db_password: Password to use for encrypted database. Requires the installation of sqlcipher (see\n    documentation).\n    :type db_password: str\n\n    :return dict: Dictionary of wallets defined in database\n    \"\"\"\n\n    session = Db(db_uri=db_uri, password=db_password).session\n    wallets = session.query(DbWallet).order_by(DbWallet.id).all()\n    wlst = []\n    for w in wallets:\n        if w.parent_id and not include_cosigners:\n            continue\n        wlst.append({\n            'id': w.id,\n            'name': w.name,\n            'owner': w.owner,\n            'network': w.network_name,\n            'purpose': w.purpose,\n            'scheme': w.scheme,\n            'main_key_id': w.main_key_id,\n            'parent_id': w.parent_id,\n        })\n    session.close()\n    return wlst",
  "def wallet_exists(wallet, db_uri=None, db_password=None):\n    \"\"\"\n    Check if Wallets is defined in database\n\n    :param wallet: Wallet ID as integer or Wallet Name as string\n    :type wallet: int, str\n    :param db_uri: URI of the database\n    :type db_uri: str\n    :param db_password: Password to use for encrypted database. Requires the installation of sqlcipher (see documentation).\n    :type db_password: str\n\n    :return bool: True if wallet exists otherwise False\n    \"\"\"\n\n    if wallet in [x['name'] for x in wallets_list(db_uri, db_password=db_password)]:\n        return True\n    if isinstance(wallet, int) and wallet in [x['id'] for x in wallets_list(db_uri, db_password=db_password)]:\n        return True\n    return False",
  "def wallet_create_or_open(\n        name, keys='', owner='', network=None, account_id=0, purpose=None, scheme='bip32', sort_keys=True,\n        password='', witness_type=None, encoding=None, multisig=None, sigs_required=None, cosigner_id=None,\n        key_path=None, db_uri=None, db_cache_uri=None, db_password=None):\n    \"\"\"\n    Create a wallet with specified options if it doesn't exist, otherwise just open\n\n    Returns Wallet object\n\n    See Wallets class create method for option documentation\n    \"\"\"\n    if wallet_exists(name, db_uri=db_uri, db_password=db_password):\n        if keys or owner or password or witness_type or key_path:\n            _logger.warning(\"Opening existing wallet, extra options are ignored\")\n        return Wallet(name, db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)\n    else:\n        return Wallet.create(name, keys, owner, network, account_id, purpose, scheme, sort_keys,\n                             password, witness_type, encoding, multisig, sigs_required, cosigner_id,\n                             key_path, db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)",
  "def wallet_delete(wallet, db_uri=None, force=False, db_password=None):\n    \"\"\"\n    Delete wallet and associated keys and transactions from the database. If wallet has unspent outputs it raises a\n    WalletError exception unless 'force=True' is specified\n\n    :param wallet: Wallet ID as integer or Wallet Name as string\n    :type wallet: int, str\n    :param db_uri: URI of the database\n    :type db_uri: str\n    :param force: If set to True wallet will be deleted even if unspent outputs are found. Default is False\n    :type force: bool\n    :param db_password: Password to use for encrypted database. Requires the installation of sqlcipher (see documentation).\n    :type db_password: str\n\n    :return int: Number of rows deleted, so 1 if successful\n    \"\"\"\n\n    session = Db(db_uri=db_uri, password=db_password).session\n    if isinstance(wallet, int) or wallet.isdigit():\n        w = session.query(DbWallet).filter_by(id=wallet)\n    else:\n        w = session.query(DbWallet).filter_by(name=wallet)\n    if not w or not w.first():\n        session.close()\n        raise WalletError(\"Wallet '%s' not found\" % wallet)\n    wallet_id = w.first().id\n\n    # Delete co-signer wallets if this is a multisig wallet\n    for cw in session.query(DbWallet).filter_by(parent_id=wallet_id).all():\n        wallet_delete(cw.id, db_uri=db_uri, force=force)\n\n    # Delete keys from this wallet and update transactions (remove key_id)\n    ks = session.query(DbKey).filter_by(wallet_id=wallet_id)\n    if bool([k for k in ks if k.balance and k.is_private]) and not force:\n        session.close()\n        raise WalletError(\"Wallet still has unspent outputs. Use 'force=True' to delete this wallet\")\n    k_ids = [k.id for k in ks]\n    session.query(DbTransactionOutput).filter(DbTransactionOutput.key_id.in_(k_ids)).update(\n        {DbTransactionOutput.key_id: None})\n    session.query(DbTransactionInput).filter(DbTransactionInput.key_id.in_(k_ids)).update(\n        {DbTransactionInput.key_id: None})\n    session.query(DbKeyMultisigChildren).filter(DbKeyMultisigChildren.parent_id.in_(k_ids)).delete()\n    session.query(DbKeyMultisigChildren).filter(DbKeyMultisigChildren.child_id.in_(k_ids)).delete()\n    ks.delete()\n\n    # Delete incomplete transactions from wallet\n    txs = session.query(DbTransaction).filter_by(wallet_id=wallet_id, is_complete=False)\n    for tx in txs:\n        session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()\n    txs.delete()\n\n    # Unlink transactions from this wallet (remove wallet_id)\n    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update({DbTransaction.wallet_id: None})\n\n    res = w.delete()\n    session.commit()\n    session.close()\n\n    _logger.info(\"Wallet '%s' deleted\" % wallet)\n\n    return res",
  "def wallet_empty(wallet, db_uri=None, db_password=None):\n    \"\"\"\n    Remove all generated keys and transactions from wallet. Does not delete the wallet itself or the masterkey,\n    so everything can be recreated.\n\n    :param wallet: Wallet ID as integer or Wallet Name as string\n    :type wallet: int, str\n    :param db_uri: URI of the database\n    :type db_uri: str\n    :param db_password: Password to use for encrypted database. Requires the installation of sqlcipher (see documentation).\n    :type db_password: str\n\n    :return bool: True if successful\n    \"\"\"\n\n    session = Db(db_uri=db_uri, password=db_password).session\n    if isinstance(wallet, int) or wallet.isdigit():\n        w = session.query(DbWallet).filter_by(id=wallet)\n    else:\n        w = session.query(DbWallet).filter_by(name=wallet)\n    if not w or not w.first():\n        raise WalletError(\"Wallet '%s' not found\" % wallet)\n    wallet_id = w.first().id\n\n    # Delete keys from this wallet and update transactions (remove key_id)\n    ks = session.query(DbKey).filter(DbKey.wallet_id == wallet_id, DbKey.parent_id != 0)\n    for k in ks:\n        session.query(DbTransactionOutput).filter_by(key_id=k.id).update({DbTransactionOutput.key_id: None})\n        session.query(DbTransactionInput).filter_by(key_id=k.id).update({DbTransactionInput.key_id: None})\n        session.query(DbKeyMultisigChildren).filter_by(parent_id=k.id).delete()\n        session.query(DbKeyMultisigChildren).filter_by(child_id=k.id).delete()\n    ks.delete()\n\n    # Delete incomplete transactions from wallet\n    txs = session.query(DbTransaction).filter_by(wallet_id=wallet_id, is_complete=False)\n    for tx in txs:\n        session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()\n    txs.delete()\n\n    # Unlink transactions from this wallet (remove wallet_id)\n    session.query(DbTransaction).filter_by(wallet_id=wallet_id).update({DbTransaction.wallet_id: None})\n\n    session.commit()\n    session.close()\n\n    _logger.info(\"All keys and transactions from wallet '%s' deleted\" % wallet)\n\n    return True",
  "def wallet_delete_if_exists(wallet, db_uri=None, force=False, db_password=None):\n    \"\"\"\n    Delete wallet and associated keys from the database. If wallet has unspent outputs it raises a WalletError exception\n    unless 'force=True' is specified. If the wallet does not exist return False\n\n    :param wallet: Wallet ID as integer or Wallet Name as string\n    :type wallet: int, str\n    :param db_uri: URI of the database\n    :type db_uri: str\n    :param force: If set to True wallet will be deleted even if unspent outputs are found. Default is False\n    :type force: bool\n    :param db_password: Password to use for encrypted database. Requires the installation of sqlcipher (see documentation).\n    :type db_password: str\n\n    :return int: Number of rows deleted, so 1 if successful\n    \"\"\"\n\n    if wallet_exists(wallet, db_uri, db_password=db_password):\n        return wallet_delete(wallet, db_uri, force, db_password=db_password)\n    return False",
  "def normalize_path(path):\n    \"\"\"\n    Normalize BIP0044 key path for HD keys. Using single quotes for hardened keys\n\n    >>> normalize_path(\"m/44h/2p/1'/0/100\")\n    \"m/44'/2'/1'/0/100\"\n\n    :param path: BIP0044 key path\n    :type path: str\n\n    :return str: Normalized BIP0044 key path with single quotes\n    \"\"\"\n\n    levels = path.split(\"/\")\n    npath = \"\"\n    for level in levels:\n        if not level:\n            raise WalletError(\"Could not parse path. Index is empty.\")\n        nlevel = level\n        if level[-1] in \"'HhPp\":\n            nlevel = level[:-1] + \"'\"\n        npath += nlevel + \"/\"\n    if npath[-1] == \"/\":\n        npath = npath[:-1]\n    return npath",
  "class WalletKey(object):\n    \"\"\"\n    Used as attribute of Wallet class. Contains HDKey class, and adds extra wallet related information such as\n    key ID, name, path and balance.\n\n    All WalletKeys are stored in a database\n    \"\"\"\n\n    @staticmethod\n    def from_key(name, wallet_id, session, key, account_id=0, network=None, change=0, purpose=44, parent_id=0,\n                 path='m', key_type=None, encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False,\n                 cosigner_id=None):\n        \"\"\"\n        Create WalletKey from a HDKey object or key.\n\n        Normally you don't need to call this method directly. Key creation is handled by the Wallet class.\n\n        >>> w = wallet_create_or_open('hdwalletkey_test')\n        >>> wif = 'xprv9s21ZrQH143K2mcs9jcK4EjALbu2z1N9qsMTUG1frmnXM3NNCSGR57yLhwTccfNCwdSQEDftgjCGm96P29wGGcbBsPqZH85iqpoHA7LrqVy'\n        >>> wk = WalletKey.from_key('import_key', w.wallet_id, w._session, wif)\n        >>> wk.address\n        '1MwVEhGq6gg1eeSrEdZom5bHyPqXtJSnPg'\n        >>> wk # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=import_key, wif=xprv9s21ZrQH143K2mcs9jcK4EjALbu2z1N9qsMTUG1frmnXM3NNCSGR57yLhwTccfNCwdSQEDftgjCGm96P29wGGcbBsPqZH85iqpoHA7LrqVy, path=m)>\n\n        :param name: New key name\n        :type name: str\n        :param wallet_id: ID of wallet where to store key\n        :type wallet_id: int\n        :param session: Required Sqlalchemy Session object\n        :type session: sqlalchemy.orm.session.Session\n        :param key: Optional key in any format accepted by the HDKey class\n        :type key: str, int, byte, HDKey\n        :param account_id: Account ID for specified key, default is 0\n        :type account_id: int\n        :param network: Network of specified key\n        :type network: str\n        :param change: Use 0 for normal key, and 1 for change key (for returned payments)\n        :type change: int\n        :param purpose: BIP0044 purpose field, default is 44\n        :type purpose: int\n        :param parent_id: Key ID of parent, default is 0 (no parent)\n        :type parent_id: int\n        :param path: BIP0044 path of given key, default is 'm' (masterkey)\n        :type path: str\n        :param key_type: Type of key, single or BIP44 type\n        :type key_type: str\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58\n        :type encoding: str\n        :param witness_type: Witness type used when creating transaction script: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used for create keys and key representations such as WIF and addreses\n        :type multisig: bool\n        :param cosigner_id: Set this if you would like to create keys for other cosigners.\n        :type cosigner_id: int\n\n        :return WalletKey: WalletKey object\n        \"\"\"\n\n        key_is_address = False\n        if isinstance(key, HDKey):\n            k = key\n            if network is None:\n                network = k.network.name\n            elif network != k.network.name:\n                raise WalletError(\"Specified network and key network should be the same\")\n        elif isinstance(key, Address):\n            k = key\n            key_is_address = True\n            if network is None:\n                network = k.network.name\n            elif network != k.network.name:\n                raise WalletError(\"Specified network and key network should be the same\")\n        else:\n            if network is None:\n                network = DEFAULT_NETWORK\n            k = HDKey(import_key=key, network=network)\n        if not encoding and witness_type:\n            encoding = get_encoding_from_witness(witness_type)\n        script_type = script_type_default(witness_type, multisig)\n\n        if not key_is_address:\n            keyexists = session.query(DbKey).\\\n                filter(DbKey.wallet_id == wallet_id,\n                       DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=True)).first()\n            if keyexists:\n                _logger.warning(\"Key already exists in this wallet. Key ID: %d\" % keyexists.id)\n                return WalletKey(keyexists.id, session, k)\n\n            if key_type != 'single' and k.depth != len(path.split('/'))-1:\n                if path == 'm' and k.depth > 1:\n                    path = \"M\"\n\n            address = k.address(encoding=encoding, script_type=script_type)\n            wk = session.query(DbKey).filter(\n                DbKey.wallet_id == wallet_id,\n                or_(DbKey.public == k.public_byte,\n                    DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=False),\n                    DbKey.address == address)).first()\n            if wk:\n                wk.wif = k.wif(witness_type=witness_type, multisig=multisig, is_private=True)\n                wk.is_private = True\n                wk.private = k.private_byte\n                wk.public = k.public_byte\n                wk.path = path\n                session.commit()\n                return WalletKey(wk.id, session, k)\n\n            nk = DbKey(name=name[:80], wallet_id=wallet_id, public=k.public_byte, private=k.private_byte, purpose=purpose,\n                       account_id=account_id, depth=k.depth, change=change, address_index=k.child_index,\n                       wif=k.wif(witness_type=witness_type, multisig=multisig, is_private=True), address=address,\n                       parent_id=parent_id, compressed=k.compressed, is_private=k.is_private, path=path,\n                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)\n        else:\n            keyexists = session.query(DbKey).\\\n                filter(DbKey.wallet_id == wallet_id,\n                       DbKey.address == k.address).first()\n            if keyexists:\n                _logger.warning(\"Key with ID %s already exists\" % keyexists.id)\n                return WalletKey(keyexists.id, session, k)\n            nk = DbKey(name=name[:80], wallet_id=wallet_id, purpose=purpose,\n                       account_id=account_id, depth=k.depth, change=change, address=k.address,\n                       parent_id=parent_id, compressed=k.compressed, is_private=False, path=path,\n                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)\n\n        session.merge(DbNetwork(name=network))\n        session.add(nk)\n        session.commit()\n        return WalletKey(nk.id, session, k)\n\n    def _commit(self):\n        try:\n            self._session.commit()\n        except Exception:\n            self._session.rollback()\n            raise\n\n    def __init__(self, key_id, session, hdkey_object=None):\n        \"\"\"\n        Initialize WalletKey with specified ID, get information from database.\n\n        :param key_id: ID of key as mentioned in database\n        :type key_id: int\n        :param session: Required Sqlalchemy Session object\n        :type session: sqlalchemy.orm.session.Session\n        :param hdkey_object: Optional HDKey object. Specify HDKey object if available for performance\n        :type hdkey_object: HDKey\n\n        \"\"\"\n\n        self._session = session\n        wk = session.query(DbKey).filter_by(id=key_id).first()\n        if wk:\n            self._dbkey = wk\n            self._hdkey_object = hdkey_object\n            if hdkey_object and isinstance(hdkey_object, HDKey):\n                assert(not wk.public or wk.public == hdkey_object.public_byte)\n                assert(not wk.private or wk.private == hdkey_object.private_byte)\n                self._hdkey_object = hdkey_object\n            self.key_id = key_id\n            self._name = wk.name\n            self.wallet_id = wk.wallet_id\n            self.key_public = None if not wk.public else wk.public\n            self.key_private = None if not wk.private else wk.private\n            self.account_id = wk.account_id\n            self.change = wk.change\n            self.address_index = wk.address_index\n            self.wif = wk.wif\n            self.address = wk.address\n            self._balance = wk.balance\n            self.purpose = wk.purpose\n            self.parent_id = wk.parent_id\n            self.is_private = wk.is_private\n            self.path = wk.path\n            self.wallet = wk.wallet\n            self.network_name = wk.network_name\n            if not self.network_name:\n                self.network_name = wk.wallet.network_name\n            self.network = Network(self.network_name)\n            self.depth = wk.depth\n            self.key_type = wk.key_type\n            self.compressed = wk.compressed\n            self.encoding = wk.encoding\n            self.cosigner_id = wk.cosigner_id\n            self.used = wk.used\n        else:\n            raise WalletError(\"Key with id %s not found\" % key_id)\n\n    def __repr__(self):\n        return \"<WalletKey(key_id=%d, name=%s, wif=%s, path=%s)>\" % (self.key_id, self.name, self.wif, self.path)\n\n    @property\n    def name(self):\n        \"\"\"\n        Return name of wallet key\n\n        :return str:\n        \"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        \"\"\"\n        Set key name, update in database\n\n        :param value: Name for this key\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        self._name = value\n        self._dbkey.name = value\n        self._commit()\n\n    def key(self):\n        \"\"\"\n        Get HDKey object for current WalletKey\n\n        :return HDKey:\n        \"\"\"\n\n        self._hdkey_object = None\n        if self.key_type == 'multisig':\n            self._hdkey_object = []\n            for kc in self._dbkey.multisig_children:\n                self._hdkey_object.append(HDKey.from_wif(kc.child_key.wif, network=kc.child_key.network_name, compressed=self.compressed))\n        if self._hdkey_object is None and self.wif:\n            self._hdkey_object = HDKey.from_wif(self.wif, network=self.network_name, compressed=self.compressed)\n        return self._hdkey_object\n\n    def balance(self, as_string=False):\n        \"\"\"\n        Get total value of unspent outputs\n\n        :param as_string: Specify 'string' to return a string in currency format\n        :type as_string: bool\n\n        :return float, str: Key balance\n        \"\"\"\n\n        if as_string:\n            return Value.from_satoshi(self._balance, network=self.network).str_unit()\n        else:\n            return self._balance\n\n    def public(self):\n        \"\"\"\n        Return current key as public WalletKey object with all private information removed\n\n        :return WalletKey:\n        \"\"\"\n        pub_key = self\n        pub_key.is_private = False\n        pub_key.key_private = None\n        if self.key():\n            pub_key.wif = self.key().wif()\n        if self._hdkey_object:\n            self._hdkey_object = pub_key._hdkey_object.public()\n        self._dbkey = None\n        return pub_key\n\n    def as_dict(self, include_private=False):\n        \"\"\"\n        Return current key information as dictionary\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        \"\"\"\n\n        kdict = {\n            'id': self.key_id,\n            'key_type': self.key_type,\n            'network': self.network.name,\n            'is_private': self.is_private,\n            'name': self.name,\n            'key_public': '' if not self.key_public else self.key_public.hex(),\n            'account_id':  self.account_id,\n            'parent_id': self.parent_id,\n            'depth': self.depth,\n            'change': self.change,\n            'address_index': self.address_index,\n            'address': self.address,\n            'encoding': self.encoding,\n            'path': self.path,\n            'balance': self.balance(),\n            'balance_str': self.balance(as_string=True)\n        }\n        if include_private:\n            kdict.update({\n                'key_private': self.key_private.hex(),\n                'wif': self.wif,\n            })\n        return kdict",
  "class WalletTransaction(Transaction):\n    \"\"\"\n    Used as attribute of Wallet class. Child of Transaction object with extra reference to\n    wallet and database object.\n\n    All WalletTransaction items are stored in a database\n    \"\"\"\n\n    def __init__(self, hdwallet, account_id=None, *args, **kwargs):\n        \"\"\"\n        Initialize WalletTransaction object with reference to a Wallet object\n\n        :param hdwallet: Wallet object, wallet name or ID\n        :type hdWallet: HDwallet, str, int\n        :param account_id: Account ID\n        :type account_id: int\n        :param args: Arguments for HDWallet parent class\n        :type args: args\n        :param kwargs: Keyword arguments for Wallet parent class\n        :type kwargs: kwargs\n        \"\"\"\n\n        assert isinstance(hdwallet, Wallet)\n        self.hdwallet = hdwallet\n        self.pushed = False\n        self.error = None\n        self.response_dict = None\n        self.account_id = account_id\n        if not account_id:\n            self.account_id = self.hdwallet.default_account_id\n        witness_type = 'legacy'\n        if hdwallet.witness_type in ['segwit', 'p2sh-segwit']:\n            witness_type = 'segwit'\n        Transaction.__init__(self, witness_type=witness_type, *args, **kwargs)\n        addresslist = hdwallet.addresslist()\n        self.outgoing_tx = bool([i.address for i in self.inputs if i.address in addresslist])\n        self.incoming_tx = bool([o.address for o in self.outputs if o.address in addresslist])\n\n    def __repr__(self):\n        return \"<WalletTransaction(input_count=%d, output_count=%d, status=%s, network=%s)>\" % \\\n               (len(self.inputs), len(self.outputs), self.status, self.network.name)\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        self_dict = self.__dict__\n        for k, v in self_dict.items():\n            if k != 'hdwallet':\n                setattr(result, k, deepcopy(v, memo))\n        result.hdwallet = self.hdwallet\n        return result\n\n    @classmethod\n    def from_transaction(cls, hdwallet, t):\n        \"\"\"\n        Create WalletTransaction object from Transaction object\n\n        :param hdwallet: Wallet object, wallet name or ID\n        :type hdwallet: HDwallet, str, int\n        :param t: Specify Transaction object\n        :type t: Transaction\n\n        :return WalletClass:\n        \"\"\"\n        return cls(hdwallet=hdwallet, inputs=t.inputs, outputs=t.outputs, locktime=t.locktime, version=t.version,\n                   network=t.network.name, fee=t.fee, fee_per_kb=t.fee_per_kb, size=t.size, txid=t.txid,\n                   txhash=t.txhash, date=t.date, confirmations=t.confirmations, block_height=t.block_height,\n                   block_hash=t.block_hash, input_total=t.input_total, output_total=t.output_total,\n                   rawtx=t.rawtx, status=t.status, coinbase=t.coinbase, verified=t.verified, flag=t.flag)\n\n    @classmethod\n    def from_txid(cls, hdwallet, txid):\n        \"\"\"\n        Read single transaction from database with given transaction ID / transaction hash\n\n        :param hdwallet: Wallet object\n        :type hdwallet: Wallet\n        :param txid: Transaction hash as hexadecimal string\n        :type txid: str, bytes\n\n        :return WalletClass:\n\n        \"\"\"\n        sess = hdwallet._session\n        # If txid is unknown add it to database, else update\n        db_tx_query = sess.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == hdwallet.wallet_id, DbTransaction.txid == to_bytes(txid))\n        db_tx = db_tx_query.scalar()\n        if not db_tx:\n            return\n\n        fee_per_kb = None\n        if db_tx.fee and db_tx.size:\n            fee_per_kb = int((db_tx.fee / db_tx.size) * 1000)\n        network = Network(db_tx.network_name)\n\n        inputs = []\n        for inp in db_tx.inputs:\n            sequence = 0xffffffff\n            if inp.sequence:\n                sequence = inp.sequence\n            inp_keys = []\n            if inp.key_id:\n                key = hdwallet.key(inp.key_id)\n                if key.key_type == 'multisig':\n                    db_key = sess.query(DbKey).filter_by(id=key.key_id).scalar()\n                    for ck in db_key.multisig_children:\n                        inp_keys.append(ck.child_key.public.hex())\n                else:\n                    inp_keys = key.key()\n\n            inputs.append(Input(\n                prev_txid=inp.prev_txid, output_n=inp.output_n, keys=inp_keys, unlocking_script=inp.script,\n                script_type=inp.script_type, sequence=sequence, index_n=inp.index_n, value=inp.value,\n                double_spend=inp.double_spend, witness_type=inp.witness_type, network=network, address=inp.address,\n                witnesses=inp.witnesses))\n\n        outputs = []\n        for out in db_tx.outputs:\n            address = ''\n            public_key = b''\n            if out.key_id:\n                key = hdwallet.key(out.key_id)\n                address = key.address\n                if key.key_type != 'multisig':\n                    if key.key() and not isinstance(key.key(), Address):\n                        public_key = key.key().public_hex\n            outputs.append(Output(value=out.value, address=address, public_key=public_key,\n                                  lock_script=out.script, spent=out.spent, output_n=out.output_n,\n                                  script_type=out.script_type, network=network))\n\n        return cls(hdwallet=hdwallet, inputs=inputs, outputs=outputs, locktime=db_tx.locktime,\n                   version=db_tx.version, network=network, fee=db_tx.fee, fee_per_kb=fee_per_kb,\n                   size=db_tx.size, txid=to_hexstring(txid), date=db_tx.date, confirmations=db_tx.confirmations,\n                   block_height=db_tx.block_height, input_total=db_tx.input_total, output_total=db_tx.output_total,\n                   rawtx=db_tx.raw, status=db_tx.status, coinbase=db_tx.coinbase,\n                   verified=db_tx.verified)\n\n    def to_transaction(self):\n        return Transaction(self.inputs, self.outputs, self.locktime, self.version,\n                           self.network.name, self.fee, self.fee_per_kb, self.size,\n                           self.txid, self.txhash, self.date, self.confirmations,\n                           self.block_height, self.block_hash, self.input_total,\n                           self.output_total, self.rawtx, self.status, self.coinbase,\n                           self.verified, self.witness_type, self.flag)\n\n    def sign(self, keys=None, index_n=0, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=False,\n             replace_signatures=False):\n        \"\"\"\n        Sign this transaction. Use existing keys from wallet or use keys argument for extra keys.\n\n        :param keys: Extra private keys to sign the transaction\n        :type keys: HDKey, str\n        :param index_n: Transaction index_n to sign\n        :type index_n: int\n        :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked\n        :type multisig_key_n: int\n        :param hash_type: Hashtype to use, default is SIGHASH_ALL\n        :type hash_type: int\n        :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list\n        :type fail_on_unknown_key: bool\n        :param replace_signatures: Replace signature with new one if already signed.\n        :type replace_signatures: bool\n\n        :return None:\n        \"\"\"\n        priv_key_list_arg = []\n        if keys:\n            key_paths = list(dict.fromkeys([ti.key_path for ti in self.inputs if ti.key_path[0] == 'm']))\n            if not isinstance(keys, list):\n                keys = [keys]\n            for priv_key in keys:\n                if not isinstance(priv_key, HDKey):\n                    if isinstance(priv_key, str) and len(str(priv_key).split(' ')) > 4:\n                        priv_key = HDKey.from_passphrase(priv_key, network=self.network)\n                    else:\n                        priv_key = HDKey(priv_key, network=self.network.name)\n                priv_key_list_arg.append((None, priv_key))\n                if key_paths and priv_key.depth == 0 and priv_key.key_type != \"single\":\n                    for key_path in key_paths:\n                        priv_key_list_arg.append((key_path, priv_key.subkey_for_path(key_path)))\n        for ti in self.inputs:\n            priv_key_list = []\n            for (key_path, priv_key) in priv_key_list_arg:\n                if (not key_path or key_path == ti.key_path) and priv_key not in priv_key_list:\n                    priv_key_list.append(priv_key)\n            priv_key_list += [k for k in ti.keys if k.is_private]\n            Transaction.sign(self, priv_key_list, ti.index_n, multisig_key_n, hash_type, fail_on_unknown_key,\n                             replace_signatures)\n        self.verify()\n        self.error = \"\"\n\n    def send(self, offline=False):\n        \"\"\"\n        Verify and push transaction to network. Update UTXO's in database after successful send\n\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is False\n        :type offline: bool\n\n        :return None:\n\n        \"\"\"\n\n        self.error = None\n        if not self.verified and not self.verify():\n            self.error = \"Cannot verify transaction\"\n            return None\n\n        if offline:\n            return None\n\n        srv = Service(network=self.network.name, providers=self.hdwallet.providers,\n                      cache_uri=self.hdwallet.db_cache_uri)\n        res = srv.sendrawtransaction(self.raw_hex())\n        if not res:\n            self.error = \"Cannot send transaction. %s\" % srv.errors\n            return None\n        if 'txid' in res:\n            _logger.info(\"Successfully pushed transaction, result: %s\" % res)\n            self.txid = res['txid']\n            self.status = 'unconfirmed'\n            self.confirmations = 0\n            self.pushed = True\n            self.response_dict = srv.results\n            self.store()\n\n            # Update db: Update spent UTXO's, add transaction to database\n            for inp in self.inputs:\n                txid = inp.prev_txid\n                utxos = self.hdwallet._session.query(DbTransactionOutput).join(DbTransaction).\\\n                    filter(DbTransaction.txid == txid,\n                           DbTransactionOutput.output_n == inp.output_n_int,\n                           DbTransactionOutput.spent.is_(False)).all()\n                for u in utxos:\n                    u.spent = True\n\n            self.hdwallet._commit()\n            self.hdwallet._balance_update(network=self.network.name)\n            return None\n        self.error = \"Transaction not send, unknown response from service providers\"\n\n    def store(self):\n        \"\"\"\n        Store this transaction to database\n\n        :return int: Transaction index number\n        \"\"\"\n\n        sess = self.hdwallet._session\n        # If txid is unknown add it to database, else update\n        db_tx_query = sess.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.hdwallet.wallet_id, DbTransaction.txid == bytes.fromhex(self.txid))\n        db_tx = db_tx_query.scalar()\n        if not db_tx:\n            db_tx_query = sess.query(DbTransaction). \\\n                filter(DbTransaction.wallet_id.is_(None), DbTransaction.txid == bytes.fromhex(self.txid))\n            db_tx = db_tx_query.first()\n            if db_tx:\n                db_tx.wallet_id = self.hdwallet.wallet_id\n\n        if not db_tx:\n            new_tx = DbTransaction(\n                wallet_id=self.hdwallet.wallet_id, txid=bytes.fromhex(self.txid), block_height=self.block_height,\n                size=self.size, confirmations=self.confirmations, date=self.date, fee=self.fee, status=self.status,\n                input_total=self.input_total, output_total=self.output_total, network_name=self.network.name,\n                raw=self.rawtx, verified=self.verified, account_id=self.account_id)\n            sess.add(new_tx)\n            self.hdwallet._commit()\n            txidn = new_tx.id\n        else:\n            txidn = db_tx.id\n            db_tx.block_height = self.block_height if self.block_height else db_tx.block_height\n            db_tx.confirmations = self.confirmations if self.confirmations else db_tx.confirmations\n            db_tx.date = self.date if self.date else db_tx.date\n            db_tx.fee = self.fee if self.fee else db_tx.fee\n            db_tx.status = self.status if self.status else db_tx.status\n            db_tx.input_total = self.input_total if self.input_total else db_tx.input_total\n            db_tx.output_total = self.output_total if self.output_total else db_tx.output_total\n            db_tx.network_name = self.network.name if self.network.name else db_tx.name\n            db_tx.raw = self.rawtx if self.rawtx else db_tx.raw\n            db_tx.verified = self.verified\n            self.hdwallet._commit()\n\n        assert txidn\n        for ti in self.inputs:\n            tx_key = sess.query(DbKey).filter_by(wallet_id=self.hdwallet.wallet_id, address=ti.address).scalar()\n            key_id = None\n            if tx_key:\n                key_id = tx_key.id\n                tx_key.used = True\n            tx_input = sess.query(DbTransactionInput). \\\n                filter_by(transaction_id=txidn, index_n=ti.index_n).scalar()\n            if not tx_input:\n                witnesses = int_to_varbyteint(len(ti.witnesses)) + b''.join([bytes(varstr(w)) for w in ti.witnesses])\n                new_tx_item = DbTransactionInput(\n                    transaction_id=txidn, output_n=ti.output_n_int, key_id=key_id, value=ti.value,\n                    prev_txid=ti.prev_txid, index_n=ti.index_n, double_spend=ti.double_spend,\n                    script=ti.unlocking_script, script_type=ti.script_type, witness_type=ti.witness_type,\n                    sequence=ti.sequence, address=ti.address, witnesses=witnesses)\n                sess.add(new_tx_item)\n            elif key_id:\n                tx_input.key_id = key_id\n                if ti.value:\n                    tx_input.value = ti.value\n                if ti.prev_txid:\n                    tx_input.prev_txid = ti.prev_txid\n                if ti.unlocking_script:\n                    tx_input.script = ti.unlocking_script\n\n            self.hdwallet._commit()\n        for to in self.outputs:\n            tx_key = sess.query(DbKey).\\\n                filter_by(wallet_id=self.hdwallet.wallet_id, address=to.address).scalar()\n            key_id = None\n            if tx_key:\n                key_id = tx_key.id\n                tx_key.used = True\n            spent = to.spent\n            tx_output = sess.query(DbTransactionOutput). \\\n                filter_by(transaction_id=txidn, output_n=to.output_n).scalar()\n            if not tx_output:\n                new_tx_item = DbTransactionOutput(\n                    transaction_id=txidn, output_n=to.output_n, key_id=key_id, address=to.address, value=to.value,\n                    spent=spent, script=to.lock_script, script_type=to.script_type)\n                sess.add(new_tx_item)\n            elif key_id:\n                tx_output.key_id = key_id\n                tx_output.spent = spent if spent is not None else tx_output.spent\n            self.hdwallet._commit()\n        return txidn\n\n    def info(self):\n        \"\"\"\n        Print Wallet transaction information to standard output. Include send information.\n        \"\"\"\n\n        Transaction.info(self)\n        print(\"Pushed to network: %s\" % self.pushed)\n        print(\"Wallet: %s\" % self.hdwallet.name)\n        if self.error:\n            print(\"Errors: %s\" % self.error)\n        print(\"\\n\")\n\n    def export(self, skip_change=True):\n        \"\"\"\n        Export this transaction as list of tuples in the following format:\n            (transaction_date, transaction_hash, in/out, addresses_in, addresses_out, value, fee)\n\n        A transaction with multiple inputs or outputs results in multiple tuples.\n\n        :param skip_change: Do not include outputs to own wallet (default). Please note: So if this is set to True, then an internal transfer is not exported.\n        :type skip_change: boolean\n\n        :return list of tuple:\n        \"\"\"\n        mut_list = []\n        wlt_addresslist = self.hdwallet.addresslist()\n        input_addresslist = [i.address for i in self.inputs]\n        if self.outgoing_tx:\n            fee_per_output = self.fee / len(self.outputs)\n            for o in self.outputs:\n                o_value = -o.value\n                if o.address in wlt_addresslist:\n                    if skip_change:\n                        continue\n                    elif self.incoming_tx:\n                        o_value = 0\n                mut_list.append((self.date, self.txid, 'out', input_addresslist, o.address, o_value, fee_per_output))\n        else:\n            for o in self.outputs:\n                if o.address not in wlt_addresslist:\n                    continue\n                mut_list.append((self.date, self.txid, 'in', input_addresslist, o.address, o.value, 0))\n        return mut_list\n\n    def save(self, filename=None):\n        \"\"\"\n        Store transaction object as file, so it can be imported in bitcoinlib later with the :func:`load` method.\n\n        :param filename: Location and name of file, leave empty to store transaction in bitcoinlib data directory: .bitcoinlib/<transaction_id.tx)\n        :type filename: str\n\n        :return:\n        \"\"\"\n        if not filename:\n            p = Path(BCL_DATA_DIR, '%s.tx' % self.txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('wb')\n        t = self.to_transaction()\n        pickle.dump(t, f)\n        f.close()\n\n    def delete(self):\n        \"\"\"\n        Delete this transaction from database.\n\n        WARNING: Results in incomplete wallets, transactions will NOT be automatically downloaded again when scanning or updating wallet. In normal situations only used to remove old unconfirmed transactions\n\n        :return int: Number of deleted transactions\n        \"\"\"\n\n        session = self.hdwallet._session\n        txid = bytes.fromhex(self.txid)\n        tx_query = session.query(DbTransaction).filter_by(txid=txid)\n        tx = tx_query.scalar()\n        session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbKey).filter_by(latest_txid=txid).update({DbKey.latest_txid: None})\n        res = tx_query.delete()\n        self.hdwallet._commit()\n        return res",
  "class Wallet(object):\n    \"\"\"\n    Class to create and manage keys Using the BIP0044 Hierarchical Deterministic wallet definitions, so you can\n    use one Masterkey to generate as much child keys as you want in a structured manner.\n\n    You can import keys in many format such as WIF or extended WIF, bytes, hexstring, seeds or private key integer.\n    For the Bitcoin network, Litecoin or any other network you define in the settings.\n\n    Easily send and receive transactions. Compose transactions automatically or select unspent outputs.\n\n    Each wallet name must be unique and can contain only one cointype and purpose, but practically unlimited\n    accounts and addresses.\n    \"\"\"\n\n    @classmethod\n    def _create(cls, name, key, owner, network, account_id, purpose, scheme, parent_id, sort_keys,\n                witness_type, encoding, multisig, sigs_required, cosigner_id, key_path, db_uri, db_cache_uri,\n                db_password):\n\n        db = Db(db_uri, db_password)\n        session = db.session\n        if (db_uri is None or db_uri.startswith(\"sqlite\")) and db_cache_uri is None:\n            db_cache_uri = DEFAULT_DATABASE_CACHE\n        elif not db_cache_uri:\n            db_cache_uri = db.db_uri\n        db_uri = db.db_uri\n        if session.query(DbWallet).filter_by(name=name).count():\n            raise WalletError(\"Wallet with name '%s' already exists\" % name)\n        else:\n            _logger.info(\"Create new wallet '%s'\" % name)\n        if not name:\n            raise WalletError(\"Please enter wallet name\")\n\n        if not isinstance(key_path, list):\n            key_path = key_path.split('/')\n        key_depth = 1 if not key_path else len(key_path) - 1\n        base_path = 'm'\n        if hasattr(key, 'depth'):\n            if key.depth is None:\n                key.depth = key_depth\n            if key.depth > 0:\n                hardened_keys = [x for x in key_path if x[-1:] == \"'\"]\n                if hardened_keys:\n                    depth_public_master = key_path.index(hardened_keys[-1])\n                    if depth_public_master != key.depth:\n                        raise WalletError(\"Depth of provided public master key %d does not correspond with key path \"\n                                          \"%s. Did you provide correct witness_type and multisig attribute?\" %\n                                          (key.depth, key_path))\n                key_path = ['M'] + key_path[key.depth+1:]\n                base_path = 'M'\n\n        if isinstance(key_path, list):\n            key_path = '/'.join(key_path)\n        session.merge(DbNetwork(name=network))\n        new_wallet = DbWallet(name=name, owner=owner, network_name=network, purpose=purpose, scheme=scheme,\n                              sort_keys=sort_keys, witness_type=witness_type, parent_id=parent_id, encoding=encoding,\n                              multisig=multisig, multisig_n_required=sigs_required, cosigner_id=cosigner_id,\n                              key_path=key_path)\n        session.add(new_wallet)\n        session.commit()\n        new_wallet_id = new_wallet.id\n\n        if scheme == 'bip32' and multisig and parent_id is None:\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri)\n        elif scheme == 'bip32':\n            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,\n                                    account_id=account_id, purpose=purpose, key_type='bip32', encoding=encoding,\n                                    witness_type=witness_type, multisig=multisig, path=base_path)\n            new_wallet.main_key_id = mk.key_id\n            session.commit()\n\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri, main_key_object=mk.key())\n            w.key_for_path([0, 0], account_id=account_id, cosigner_id=cosigner_id)\n        else:  # scheme == 'single':\n            if not key:\n                key = HDKey(network=network, depth=key_depth)\n            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,\n                                    account_id=account_id, purpose=purpose, key_type='single', encoding=encoding,\n                                    witness_type=witness_type, multisig=multisig)\n            new_wallet.main_key_id = mk.key_id\n            session.commit()\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri, main_key_object=mk.key())\n\n        session.close()\n        return w\n\n    def _commit(self):\n        try:\n            self._session.commit()\n        except Exception:\n            self._session.rollback()\n            raise\n\n    @classmethod\n    def create(cls, name, keys=None, owner='', network=None, account_id=0, purpose=0, scheme='bip32',\n               sort_keys=True, password='', witness_type=None, encoding=None, multisig=None, sigs_required=None,\n               cosigner_id=None, key_path=None, db_uri=None, db_cache_uri=None, db_password=None):\n        \"\"\"\n        Create Wallet and insert in database. Generate masterkey or import key when specified.\n\n        When only a name is specified a legacy Wallet with a single masterkey is created with standard p2wpkh\n        scripts.\n\n        >>> if wallet_delete_if_exists('create_legacy_wallet_test'): pass\n        >>> w = Wallet.create('create_legacy_wallet_test')\n        >>> w\n        <Wallet(name=\"create_legacy_wallet_test\")>\n\n        To create a multi signature wallet specify multiple keys (private or public) and provide the sigs_required\n        argument if it different then len(keys)\n\n        >>> if wallet_delete_if_exists('create_legacy_multisig_wallet_test'): pass\n        >>> w = Wallet.create('create_legacy_multisig_wallet_test', keys=[HDKey(), HDKey().public()])\n\n        To create a native segwit wallet use the option witness_type = 'segwit' and for old style addresses and p2sh\n        embedded segwit script us 'ps2h-segwit' as witness_type.\n\n        >>> if wallet_delete_if_exists('create_segwit_wallet_test'): pass\n        >>> w = Wallet.create('create_segwit_wallet_test', witness_type='segwit')\n\n        Use a masterkey WIF when creating a wallet:\n\n        >>> wif = 'xprv9s21ZrQH143K3cxbMVswDTYgAc9CeXABQjCD9zmXCpXw4MxN93LanEARbBmV3utHZS9Db4FX1C1RbC5KSNAjQ5WNJ1dDBJ34PjfiSgRvS8x'\n        >>> if wallet_delete_if_exists('bitcoinlib_legacy_wallet_test', force=True): pass\n        >>> w = Wallet.create('bitcoinlib_legacy_wallet_test', wif)\n        >>> w\n        <Wallet(name=\"bitcoinlib_legacy_wallet_test\")>\n        >>> # Add some test utxo data:\n        >>> if w.utxo_add('16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', 100000000, '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', 0): pass\n\n        Please mention account_id if you are using multiple accounts.\n\n        :param name: Unique name of this Wallet\n        :type name: str\n        :param keys: Masterkey to or list of keys to use for this wallet. Will be automatically created if not specified. One or more keys are obligatory for multisig wallets. Can contain all key formats accepted by the HDKey object, a HDKey object or BIP39 passphrase\n        :type keys: str, bytes, int, HDKey, HDWalletKey, list of str, list of bytes, list of int, list of HDKey, list of HDWalletKey\n        :param owner: Wallet owner for your own reference\n        :type owner: str\n        :param network: Network name, use default if not specified\n        :type network: str\n        :param account_id: Account ID, default is 0\n        :type account_id: int\n        :param purpose: BIP43 purpose field, will be derived from witness_type and multisig by default\n        :type purpose: int\n        :param scheme: Key structure type, i.e. BIP32 or single\n        :type scheme: str\n        :param sort_keys: Sort keys according to BIP45 standard (used for multisig keys)\n        :type sort_keys: bool\n        :param password: Password to protect passphrase, only used if a passphrase is supplied in the 'key' argument.\n        :type password: str\n        :param witness_type: Specify witness type, default is 'legacy'. Use 'segwit' for native segregated witness wallet, or 'p2sh-segwit' for legacy compatible wallets\n        :type witness_type: str\n        :param encoding: Encoding used for address generation: base58 or bech32. Default is derive from wallet and/or witness type\n        :type encoding: str\n        :param multisig: Multisig wallet or child of a multisig wallet, default is None / derive from number of keys.\n        :type multisig: bool\n        :param sigs_required: Number of signatures required for validation if using a multisignature wallet. For example 2 for 2-of-3 multisignature. Default is all keys must be signed\n        :type sigs_required: int\n        :param cosigner_id: Set this if wallet contains only public keys, more than one private key or if you would like to create keys for other cosigners. Note: provided keys of a multisig wallet are sorted if sort_keys = True (default) so if your provided key list is not sorted the cosigned_id may be different.\n        :type cosigner_id: int\n        :param key_path: Key path for multisig wallet, use to create your own non-standard key path. Key path must follow the following rules:\n            * Path start with masterkey (m) and end with change / address_index\n            * If accounts are used, the account level must be 3. I.e.: m/purpose/coin_type/account/\n            * All keys must be hardened, except for change, address_index or cosigner_id\n            * Max length of path is 8 levels\n        :type key_path: list, str\n        :param db_uri: URI of the database for wallets, wallet transactions and keys\n        :type db_uri: str\n        :param db_cache_uri: URI of the cache database. If not specified  the default cache database is used when using sqlite, for other databasetypes the cache database is merged with the wallet database (db_uri)\n        :type db_cache_uri: str\n        :param db_password: Password to encrypt database. Requires the installation of sqlcipher (see documentation).\n        :type db_password: str\n\n        :return Wallet:\n        \"\"\"\n\n        if multisig is None:\n            if keys and isinstance(keys, list) and len(keys) > 1:\n                multisig = True\n            else:\n                multisig = False\n        if scheme not in ['bip32', 'single']:\n            raise WalletError(\"Only bip32 or single key scheme's are supported at the moment\")\n        if witness_type not in [None, 'legacy', 'p2sh-segwit', 'segwit']:\n            raise WalletError(\"Witness type %s not supported at the moment\" % witness_type)\n        if name.isdigit():\n            raise WalletError(\"Wallet name '%s' invalid, please include letter characters\" % name)\n\n        if multisig:\n            if password:\n                raise WalletError(\"Password protected multisig wallets not supported\")\n            if scheme != 'bip32':\n                raise WalletError(\"Multisig wallets should use bip32 scheme not %s\" % scheme)\n            if sigs_required is None:\n                sigs_required = len(keys)\n            if sigs_required > len(keys):\n                raise WalletError(\"Number of keys required to sign is greater then number of keys provided\")\n        elif not isinstance(keys, list):\n            keys = [keys]\n        if len(keys) > 15:\n            raise WalletError(\"Redeemscripts with more then 15 keys are non-standard and could result in \"\n                              \"locked up funds\")\n\n        hdkey_list = []\n        if keys and isinstance(keys, list) and sort_keys:\n            keys.sort(key=lambda x: ('0' if isinstance(x, HDKey) else '1'))\n        for key in keys:\n            if isinstance(key, HDKey):\n                if network and network != key.network.name:\n                    raise WalletError(\"Network from key (%s) is different then specified network (%s)\" %\n                                      (key.network.name, network))\n                network = key.network.name\n                if witness_type is None:\n                    witness_type = key.witness_type\n            elif key:\n                # If key consists of several words assume it is a passphrase and convert it to a HDKey object\n                if isinstance(key, str) and len(key.split(\" \")) > 1:\n                    if not network:\n                        raise WalletError(\"Please specify network when using passphrase to create a key\")\n                    key = HDKey.from_seed(Mnemonic().to_seed(key, password), network=network)\n                else:\n                    try:\n                        if isinstance(key, WalletKey):\n                            key = key._hdkey_object\n                        else:\n                            key = HDKey(key, password=password, network=network)\n                    except BKeyError:\n                        try:\n                            scheme = 'single'\n                            key = Address.parse(key, encoding=encoding, network=network)\n                        except Exception:\n                            raise WalletError(\"Invalid key or address: %s\" % key)\n                    if network is None:\n                        network = key.network.name\n                    if witness_type is None:\n                        witness_type = key.witness_type\n            hdkey_list.append(key)\n\n        if network is None:\n            network = DEFAULT_NETWORK\n        if witness_type is None:\n            witness_type = DEFAULT_WITNESS_TYPE\n        if network in ['dash', 'dash_testnet', 'dogecoin', 'dogecoin_testnet'] and witness_type != 'legacy':\n            raise WalletError(\"Segwit is not supported for %s wallets\" % network.capitalize())\n        elif network in ('dogecoin', 'dogecoin_testnet') and witness_type not in ('legacy', 'p2sh-segwit'):\n            raise WalletError(\"Pure segwit addresses are not supported for Dogecoin wallets. \"\n                              \"Please use p2sh-segwit instead\")\n\n        if not key_path:\n            if scheme == 'single':\n                key_path = ['m']\n                purpose = 0\n            else:\n                ks = [k for k in WALLET_KEY_STRUCTURES if k['witness_type'] == witness_type and\n                      k['multisig'] == multisig and k['purpose'] is not None]\n                if len(ks) > 1:\n                    raise WalletError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                                      \"witness_type - multisig combination\")\n                if ks and not purpose:\n                    purpose = ks[0]['purpose']\n                if ks and not encoding:\n                    encoding = ks[0]['encoding']\n                key_path = ks[0]['key_path']\n        else:\n            if purpose is None:\n                purpose = 0\n        if not encoding:\n            encoding = get_encoding_from_witness(witness_type)\n\n        if multisig:\n            key = ''\n        else:\n            key = hdkey_list[0]\n\n        main_key_path = key_path\n        if multisig:\n            if sort_keys:\n                hdkey_list.sort(key=lambda x: x.public_byte)\n            cos_prv_lst = [hdkey_list.index(cw) for cw in hdkey_list if cw.is_private]\n            if cosigner_id is None:\n                if not cos_prv_lst:\n                    raise WalletError(\"This wallet does not contain any private keys, please specify cosigner_id for \"\n                                      \"this wallet\")\n                elif len(cos_prv_lst) > 1:\n                    raise WalletError(\"This wallet contains more then 1 private key, please specify \"\n                                      \"cosigner_id for this wallet\")\n                cosigner_id = 0 if not cos_prv_lst else cos_prv_lst[0]\n            if hdkey_list[cosigner_id].key_type == 'single':\n                main_key_path = 'm'\n\n        hdpm = cls._create(name, key, owner=owner, network=network, account_id=account_id, purpose=purpose,\n                           scheme=scheme, parent_id=None, sort_keys=sort_keys, witness_type=witness_type,\n                           encoding=encoding, multisig=multisig, sigs_required=sigs_required, cosigner_id=cosigner_id,\n                           key_path=main_key_path, db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)\n\n        if multisig:\n            wlt_cos_id = 0\n            for cokey in hdkey_list:\n                if hdpm.network.name != cokey.network.name:\n                    raise WalletError(\"Network for key %s (%s) is different then network specified: %s/%s\" %\n                                      (cokey.wif(is_private=False), cokey.network.name, network, hdpm.network.name))\n                scheme = 'bip32'\n                wn = name + '-cosigner-%d' % wlt_cos_id\n                c_key_path = key_path\n                if cokey.key_type == 'single':\n                    scheme = 'single'\n                    c_key_path = ['m']\n                w = cls._create(name=wn, key=cokey, owner=owner, network=network, account_id=account_id,\n                                purpose=hdpm.purpose, scheme=scheme, parent_id=hdpm.wallet_id, sort_keys=sort_keys,\n                                witness_type=hdpm.witness_type, encoding=encoding, multisig=True,\n                                sigs_required=None, cosigner_id=wlt_cos_id, key_path=c_key_path,\n                                db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)\n                hdpm.cosigner.append(w)\n                wlt_cos_id += 1\n            # hdpm._dbwallet = hdpm._session.query(DbWallet).filter(DbWallet.id == hdpm.wallet_id)\n            # hdpm._dbwallet.update({DbWallet.cosigner_id: hdpm.cosigner_id})\n            # hdpm._dbwallet.update({DbWallet.key_path: hdpm.key_path})\n            # hdpm._session.commit()\n\n        return hdpm\n\n    def __enter__(self):\n        return self\n\n    def __init__(self, wallet, db_uri=None, db_cache_uri=None, session=None, main_key_object=None, db_password=None):\n        \"\"\"\n        Open a wallet with given ID or name\n\n        :param wallet: Wallet name or ID\n        :type wallet: int, str\n        :param db_uri: URI of the database\n        :type db_uri: str\n        :param db_cache_uri: URI of the cache database. If not specified  the default cache database is used when using sqlite, for other databasetypes the cache database is merged with the wallet database (db_uri)\n        :type db_cache_uri: str\n        :param session: Sqlalchemy session\n        :type session: sqlalchemy.orm.session.Session\n        :param main_key_object: Pass main key object to save time\n        :type main_key_object: HDKey\n        \"\"\"\n\n        if session:\n            self._session = session\n        else:\n            dbinit = Db(db_uri=db_uri, password=db_password)\n            self._session = dbinit.session\n            self._engine = dbinit.engine\n        self.db_uri = db_uri\n        self.db_cache_uri = db_cache_uri\n        if isinstance(wallet, int) or wallet.isdigit():\n            db_wlt = self._session.query(DbWallet).filter_by(id=wallet).scalar()\n        else:\n            db_wlt = self._session.query(DbWallet).filter_by(name=wallet).scalar()\n        if db_wlt:\n            self._dbwallet = db_wlt\n            self.wallet_id = db_wlt.id\n            self._name = db_wlt.name\n            self._owner = db_wlt.owner\n            self.network = Network(db_wlt.network_name)\n            self.purpose = db_wlt.purpose\n            self.scheme = db_wlt.scheme\n            self._balance = None\n            self._balances = []\n            self.main_key_id = db_wlt.main_key_id\n            self.main_key = None\n            self._default_account_id = db_wlt.default_account_id\n            self.multisig_n_required = db_wlt.multisig_n_required\n            co_sign_wallets = self._session.query(DbWallet).\\\n                filter(DbWallet.parent_id == self.wallet_id).order_by(DbWallet.name).all()\n            self.cosigner = [Wallet(w.id, db_uri=db_uri, db_cache_uri=db_cache_uri) for w in co_sign_wallets]\n            self.sort_keys = db_wlt.sort_keys\n            if db_wlt.main_key_id:\n                self.main_key = WalletKey(self.main_key_id, session=self._session, hdkey_object=main_key_object)\n            if self._default_account_id is None:\n                self._default_account_id = 0\n                if self.main_key:\n                    self._default_account_id = self.main_key.account_id\n            _logger.info(\"Opening wallet '%s'\" % self.name)\n            self._key_objects = {\n                self.main_key_id: self.main_key\n            }\n            self.providers = None\n            self.witness_type = db_wlt.witness_type\n            self.encoding = db_wlt.encoding\n            self.multisig = db_wlt.multisig\n            self.cosigner_id = db_wlt.cosigner_id\n            self.script_type = script_type_default(self.witness_type, self.multisig, locking_script=True)\n            self.key_path = [] if not db_wlt.key_path else db_wlt.key_path.split('/')\n            self.depth_public_master = 0\n            self.parent_id = db_wlt.parent_id\n            if self.main_key and self.main_key.depth > 0:\n                self.depth_public_master = self.main_key.depth\n                self.key_depth = self.depth_public_master + len(self.key_path) - 1\n            else:\n                hardened_keys = [x for x in self.key_path if x[-1:] == \"'\"]\n                if hardened_keys:\n                    self.depth_public_master = self.key_path.index(hardened_keys[-1])\n                self.key_depth = len(self.key_path) - 1\n            self.last_updated = None\n        else:\n            raise WalletError(\"Wallet '%s' not found, please specify correct wallet ID or name.\" % wallet)\n\n    def __exit__(self, exception_type, exception_value, traceback):\n        try:\n            self._session.close()\n            self._engine.dispose()\n        except Exception:\n            pass\n\n    def __del__(self):\n        try:\n            self._session.close()\n            self._engine.dispose()\n        except Exception:\n            pass\n\n    def __repr__(self):\n        db_uri = self.db_uri.split('?')[0]\n        if DEFAULT_DATABASE in db_uri:\n            return \"<Wallet(name=\\\"%s\\\")>\" % self.name\n        return \"<Wallet(name=\\\"%s\\\", db_uri=\\\"%s\\\")>\" % \\\n               (self.name, db_uri)\n\n    def __str__(self):\n        return self.name\n\n    def _get_account_defaults(self, network=None, account_id=None, key_id=None):\n        \"\"\"\n        Check parameter values for network and account ID, return defaults if no network or account ID is specified.\n        If a network is specified but no account ID this method returns the first account ID it finds.\n\n        :param network: Network code, leave empty for default\n        :type network: str\n        :param account_id: Account ID, leave emtpy for default\n        :type account_id: int\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n\n        :return: network code, account ID and DbKey instance of account ID key\n        \"\"\"\n\n        if key_id:\n            kobj = self.key(key_id)\n            network = kobj.network_name\n            account_id = kobj.account_id\n        if network is None:\n            network = self.network.name\n        if account_id is None and network == self.network.name:\n            account_id = self.default_account_id\n        qr = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, depth=self.depth_public_master,\n                      network_name=network)\n        if account_id is not None:\n            qr = qr.filter_by(account_id=account_id)\n        acckey = qr.first()\n        if len(qr.all()) > 1 and \"account'\" in self.key_path:\n            _logger.warning(\"No account_id specified and more than one account found for this network %s. \"\n                            \"Using a random account\" % network)\n        if account_id is None:\n            if acckey:\n                account_id = acckey.account_id\n            else:\n                account_id = 0\n        return network, account_id, acckey\n\n    @property\n    def default_account_id(self):\n        return self._default_account_id\n\n    @default_account_id.setter\n    def default_account_id(self, value):\n        self._default_account_id = value\n        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id). \\\n            update({DbWallet.default_account_id: value})\n        self._commit()\n\n    @property\n    def owner(self):\n        \"\"\"\n        Get wallet Owner\n\n        :return str:\n        \"\"\"\n\n        return self._owner\n\n    @owner.setter\n    def owner(self, value):\n        \"\"\"\n        Set wallet Owner in database\n\n        :param value: Owner\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        self._owner = value\n        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.owner: value})\n        self._commit()\n\n    @property\n    def name(self):\n        \"\"\"\n        Get wallet name\n\n        :return str:\n        \"\"\"\n\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        \"\"\"\n        Set wallet name, update in database\n\n        :param value: Name for this wallet\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        if wallet_exists(value, db_uri=self.db_uri):\n            raise WalletError(\"Wallet with name '%s' already exists\" % value)\n        self._name = value\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update({DbWallet.name: value})\n        self._commit()\n\n    def default_network_set(self, network):\n        if not isinstance(network, Network):\n            network = Network(network)\n        self.network = network\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.network_name: network.name})\n        self._commit()\n\n    def import_master_key(self, hdkey, name='Masterkey (imported)'):\n        \"\"\"\n        Import (another) masterkey in this wallet\n\n        :param hdkey: Private key\n        :type hdkey: HDKey, str\n        :param name: Key name of masterkey\n        :type name: str\n\n        :return HDKey: Main key as HDKey object\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults()\n        if not isinstance(hdkey, HDKey):\n            hdkey = HDKey(hdkey)\n        if not isinstance(self.main_key, WalletKey):\n            raise WalletError(\"Main wallet key is not an WalletKey instance. Type %s\" % type(self.main_key))\n        if not hdkey.is_private or hdkey.depth != 0:\n            raise WalletError(\"Please supply a valid private BIP32 master key with key depth 0\")\n        if self.main_key.is_private:\n            raise WalletError(\"Main key is already a private key, cannot import key\")\n        if (self.main_key.depth != 1 and self.main_key.depth != 3 and self.main_key.depth != 4) or \\\n                self.main_key.key_type != 'bip32':\n            raise WalletError(\"Current main key is not a valid BIP32 public master key\")\n        # pm = self.public_master()\n        if not (self.network.name == self.main_key.network.name == hdkey.network.name):\n            raise WalletError(\"Network of Wallet class, main account key and the imported private key must use \"\n                              \"the same network\")\n        if self.main_key.wif != hdkey.public_master().wif():\n            raise WalletError(\"This key does not correspond to current public master key\")\n\n        hdkey.key_type = 'bip32'\n        ks = [k for k in WALLET_KEY_STRUCTURES if\n              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]\n        if len(ks) > 1:\n            raise WalletError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                              \"witness_type - multisig combination\")\n        self.key_path = ks[0]['key_path']\n        self.main_key = WalletKey.from_key(\n            key=hdkey, name=name, session=self._session, wallet_id=self.wallet_id, network=network,\n            account_id=account_id, purpose=self.purpose, key_type='bip32', witness_type=self.witness_type)\n        self.main_key_id = self.main_key.key_id\n        self._key_objects.update({self.main_key_id: self.main_key})\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.main_key_id: self.main_key_id})\n\n        for key in self.keys(is_private=False):\n            kp = key.path.split(\"/\")\n            if kp and kp[0] == 'M':\n                kp = self.key_path[:self.depth_public_master+1] + kp[1:]\n            self.key_for_path(kp, recreate=True)\n\n        self._commit()\n        return self.main_key\n\n    def import_key(self, key, account_id=0, name='', network=None, purpose=44, key_type=None):\n        \"\"\"\n        Add new single key to wallet.\n\n        :param key: Key to import\n        :type key: str, bytes, int, HDKey, Address\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param name: Specify name for key, leave empty for default\n        :type name: str\n        :param network: Network name, method will try to extract from key if not specified. Raises warning if network could not be detected\n        :type network: str\n        :param purpose: BIP definition used, default is BIP44\n        :type purpose: int\n        :param key_type: Key type of imported key, can be single. Unrelated to wallet, bip32, bip44 or master for new or extra master key import. Default is 'single'\n        :type key_type: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme not in ['bip32', 'single']:\n            raise WalletError(\"Keys can only be imported to a BIP32 or single type wallet, create a new wallet \"\n                              \"instead\")\n        if isinstance(key, (HDKey, Address)):\n            network = key.network.name\n            hdkey = key\n            if network not in self.network_list():\n                raise WalletError(\"Network %s not found in this wallet\" % network)\n        else:\n            if isinstance(key, str) and len(key.split(\" \")) > 1:\n                if network is None:\n                    network = self.network\n                hdkey = HDKey.from_seed(Mnemonic().to_seed(key), network=network)\n            else:\n                if network is None:\n                    network = check_network_and_key(key, default_network=self.network.name)\n                if network not in self.network_list():\n                    raise WalletError(\"Network %s not available in this wallet, please create an account for this \"\n                                      \"network first.\" % network)\n                hdkey = HDKey(key, network=network, key_type=key_type)\n\n        if not self.multisig:\n            if self.main_key and self.main_key.depth == self.depth_public_master and \\\n                    not isinstance(hdkey, Address) and hdkey.is_private and hdkey.depth == 0 and self.scheme == 'bip32':\n                return self.import_master_key(hdkey, name)\n\n            if key_type is None:\n                hdkey.key_type = 'single'\n                key_type = 'single'\n\n            ik_path = 'm'\n            if key_type == 'single':\n                # Create path for unrelated import keys\n                hdkey.depth = self.key_depth\n                last_import_key = self._session.query(DbKey).filter(DbKey.path.like(\"import_key_%\")).\\\n                    order_by(DbKey.path.desc()).first()\n                if last_import_key:\n                    ik_path = \"import_key_\" + str(int(last_import_key.path[-5:]) + 1).zfill(5)\n                else:\n                    ik_path = \"import_key_00001\"\n                if not name:\n                    name = ik_path\n\n            mk = WalletKey.from_key(\n                key=hdkey, name=name, wallet_id=self.wallet_id, network=network, key_type=key_type,\n                account_id=account_id, purpose=purpose, session=self._session, path=ik_path,\n                witness_type=self.witness_type)\n            self._key_objects.update({mk.key_id: mk})\n            if mk.key_id == self.main_key.key_id:\n                self.main_key = mk\n            return mk\n        else:\n            account_key = hdkey.public_master(witness_type=self.witness_type, multisig=True).wif()\n            for w in self.cosigner:\n                if w.main_key.key().wif_public() == account_key:\n                    _logger.debug(\"Import new private cosigner key in this multisig wallet: %s\" % account_key)\n                    return w.import_master_key(hdkey)\n            raise WalletError(\"Unknown key: Can only import a private key for a known public key in multisig wallets\")\n\n    def _new_key_multisig(self, public_keys, name, account_id, change, cosigner_id, network, address_index):\n        if self.sort_keys:\n            public_keys.sort(key=lambda pubk: pubk.key_public)\n        public_key_list = [pubk.key_public for pubk in public_keys]\n        public_key_ids = [str(x.key_id) for x in public_keys]\n\n        # Calculate redeemscript and address and add multisig key to database\n        # redeemscript = serialize_multisig_redeemscript(public_key_list, n_required=self.multisig_n_required)\n\n        # todo: pass key object, reuse key objects\n        redeemscript = Script(script_types=['multisig'], keys=public_key_list,\n                              sigs_required=self.multisig_n_required).serialize()\n        script_type = 'p2sh'\n        if self.witness_type == 'p2sh-segwit':\n            script_type = 'p2sh_p2wsh'\n        address = Address(redeemscript, encoding=self.encoding, script_type=script_type, network=network)\n        already_found_key = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id,\n                                                                 address=address.address).first()\n        if already_found_key:\n            return self.key(already_found_key.id)\n        path = [pubk.path for pubk in public_keys if pubk.wallet.cosigner_id == self.cosigner_id][0]\n        depth = self.cosigner[self.cosigner_id].main_key.depth + len(path.split(\"/\")) - 1\n        if not name:\n            name = \"Multisig Key \" + '/'.join(public_key_ids)\n\n        multisig_key = DbKey(\n            name=name[:80], wallet_id=self.wallet_id, purpose=self.purpose, account_id=account_id,\n            depth=depth, change=change, address_index=address_index, parent_id=0, is_private=False, path=path,\n            public=address.hash_bytes, wif='multisig-%s' % address, address=address.address, cosigner_id=cosigner_id,\n            key_type='multisig', network_name=network)\n        self._session.add(multisig_key)\n        self._commit()\n        for child_id in public_key_ids:\n            self._session.add(DbKeyMultisigChildren(key_order=public_key_ids.index(child_id), parent_id=multisig_key.id,\n                                                    child_id=int(child_id)))\n        self._commit()\n        return self.key(multisig_key.id)\n\n    def new_key(self, name='', account_id=None, change=0, cosigner_id=None, network=None):\n        \"\"\"\n        Create a new HD Key derived from this wallet's masterkey. An account will be created for this wallet\n        with index 0 if there is no account defined yet.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.new_key('my key') # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=my key, wif=..., path=m/44'/0'/0'/0/...)>\n\n        :param name: Key name. Does not have to be unique but if you use it at reference you might chooce to enforce this. If not specified 'Key #' with a unique sequence number will be used\n        :type name: str\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param change: Change (1) or payments (0). Default is 0\n        :type change: int\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme == 'single':\n            return self.main_key\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if network != self.network.name and \"coin_type'\" not in self.key_path:\n            raise WalletError(\"Multiple networks not supported by wallet key structure\")\n        if self.multisig:\n            if not self.multisig_n_required:\n                raise WalletError(\"Multisig_n_required not set, cannot create new key\")\n            if cosigner_id is None:\n                if self.cosigner_id is None:\n                    raise WalletError(\"Missing Cosigner ID value, cannot create new key\")\n                cosigner_id = self.cosigner_id\n\n        address_index = 0\n        if self.multisig and cosigner_id is not None and (len(self.cosigner) > cosigner_id and self.cosigner[cosigner_id].key_path == 'm' or self.cosigner[cosigner_id].key_path == ['m']):\n            req_path = []\n        else:\n            prevkey = self._session.query(DbKey).\\\n                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network, account_id=account_id,\n                          change=change, cosigner_id=cosigner_id, depth=self.key_depth).\\\n                order_by(DbKey.address_index.desc()).first()\n            if prevkey:\n                address_index = prevkey.address_index + 1\n            req_path = [change, address_index]\n\n        return self.key_for_path(req_path, name=name, account_id=account_id, network=network,\n                                 cosigner_id=cosigner_id, address_index=address_index)\n\n    def new_key_change(self, name='', account_id=None, network=None):\n        \"\"\"\n        Create new key to receive change for a transaction. Calls :func:`new_key` method with change=1.\n\n        :param name: Key name. Default name is 'Change #' with an address index\n        :type name: str\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        return self.new_key(name=name, account_id=account_id, network=network, change=1)\n\n    def scan_key(self, key):\n        \"\"\"\n        Scan for new transactions for specified wallet key and update wallet transactions\n\n        :param key: The wallet key as object or index\n        :type key: WalletKey, int\n\n        :return bool: New transactions found?\n\n        \"\"\"\n        if isinstance(key, int):\n            key = self.key(key)\n        txs_found = False\n        should_be_finished_count = 0\n        while True:\n            n_new = self.transactions_update(key_id=key.key_id)\n            if n_new and n_new < MAX_TRANSACTIONS:\n                if should_be_finished_count:\n                    _logger.info(\"Possible recursive loop detected in scan_key(%d): retry %d/5\" %\n                                 (key.key_id, should_be_finished_count))\n                should_be_finished_count += 1\n            logger.info(\"Scanned key %d, %s Found %d new transactions\" % (key.key_id, key.address, n_new))\n            if not n_new or should_be_finished_count > 5:\n                break\n            txs_found = True\n        return txs_found\n\n    def scan(self, scan_gap_limit=5, account_id=None, change=None, rescan_used=False, network=None, keys_ignore=None):\n        \"\"\"\n        Generate new addresses/keys and scan for new transactions using the Service providers. Updates all UTXO's and balances.\n\n        Keep scanning for new transactions until no new transactions are found for 'scan_gap_limit' addresses. Only scan keys from default network and account unless another network or account is specified.\n\n        Use the faster :func:`utxos_update` method if you are only interested in unspent outputs.\n        Use the :func:`transactions_update` method if you would like to manage the key creation yourself or if you want to scan a single key.\n\n        :param scan_gap_limit: Amount of new keys and change keys (addresses) created for this wallet. Default is 5, so scanning stops if after 5 addresses no transaction are found.\n        :type scan_gap_limit: int\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param change: Filter by change addresses. Set to True to include only change addresses, False to only include regular addresses. None (default) to disable filter and include both\n        :type change: bool\n        :param rescan_used: Rescan already used addressed. Default is False, so funds send to old addresses will be ignored by default.\n        :type rescan_used: bool\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param keys_ignore: Id's of keys to ignore\n        :type keys_ignore: list of int\n\n        :return:\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if self.scheme != 'bip32' and self.scheme != 'multisig' and scan_gap_limit < 2:\n            raise WalletError(\"The wallet scan() method is only available for BIP32 wallets\")\n        if keys_ignore is None:\n            keys_ignore = []\n\n        # Rescan used addresses\n        if rescan_used:\n            for key in self.keys_addresses(account_id=account_id, change=change, network=network, used=True):\n                self.scan_key(key.id)\n\n        # Update already known transactions with known block height\n        self.transactions_update_confirmations()\n\n        # Check unconfirmed transactions\n        db_txs = self._session.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.confirmations == 0).all()\n        for db_tx in db_txs:\n            self.transactions_update_by_txids([db_tx.txid])\n\n        # Scan each key address, stop when no new transactions are found after set scan gap limit\n        if change is None:\n            change_range = [0, 1]\n        else:\n            change_range = [change]\n        counter = 0\n        for chg in change_range:\n            while True:\n                if self.scheme == 'single':\n                    keys_to_scan = [self.key(k.id) for k in self.keys_addresses()[counter:counter+scan_gap_limit]]\n                    counter += scan_gap_limit\n                else:\n                    keys_to_scan = self.get_keys(account_id, network, number_of_keys=scan_gap_limit, change=chg)\n                n_highest_updated = 0\n                for key in keys_to_scan:\n                    if key.key_id in keys_ignore:\n                        continue\n                    keys_ignore.append(key.key_id)\n                    n_high_new = 0\n                    if self.scan_key(key):\n                        if not key.address_index:\n                            key.address_index = 0\n                        n_high_new = key.address_index + 1\n                    if n_high_new > n_highest_updated:\n                        n_highest_updated = n_high_new\n                if not n_highest_updated:\n                    break\n\n    def _get_key(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0, as_list=False):\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if cosigner_id is None:\n            cosigner_id = self.cosigner_id\n        elif cosigner_id > len(self.cosigner):\n            raise WalletError(\"Cosigner ID (%d) can not be greater then number of cosigners for this wallet (%d)\" %\n                              (cosigner_id, len(self.cosigner)))\n\n        last_used_qr = self._session.query(DbKey.id).\\\n            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,\n                      used=True, change=change, depth=self.key_depth).\\\n            order_by(DbKey.id.desc()).first()\n        last_used_key_id = 0\n        if last_used_qr:\n            last_used_key_id = last_used_qr.id\n        dbkey = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,\n                      used=False, change=change, depth=self.key_depth).filter(DbKey.id > last_used_key_id).\\\n            order_by(DbKey.id.desc()).all()\n        key_list = []\n        if self.scheme == 'single' and len(dbkey):\n            number_of_keys = len(dbkey) if number_of_keys > len(dbkey) else number_of_keys\n        for i in range(number_of_keys):\n            if dbkey:\n                dk = dbkey.pop()\n                nk = self.key(dk.id)\n            else:\n                nk = self.new_key(account_id=account_id, change=change, cosigner_id=cosigner_id, network=network)\n            key_list.append(nk)\n        if as_list:\n            return key_list\n        else:\n            return key_list[0]\n\n    def get_key(self, account_id=None, network=None, cosigner_id=None, change=0):\n        \"\"\"\n        Get a unused key / address or create a new one with :func:`new_key` if there are no unused keys.\n        Returns a key from this wallet which has no transactions linked to it.\n\n        Use the get_keys() method to a list of unused keys. Calling the get_key() method repeatelly to receive a\n        list of key doesn't work: since the key is unused it would return the same result every time you call this\n        method.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.get_key() # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=..., wif=..., path=m/44'/0'/0'/0/...)>\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param change: Payment (0) or change key (1). Default is 0\n        :type change: int\n\n        :return WalletKey:\n        \"\"\"\n        return self._get_key(account_id, network, cosigner_id, change=change, as_list=False)\n\n    def get_keys(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0):\n        \"\"\"\n        Get a list of unused keys / addresses or create a new ones with :func:`new_key` if there are no unused keys.\n        Returns a list of keys from this wallet which has no transactions linked to it.\n\n        Use the get_key() method to get a single key.\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param number_of_keys: Number of keys to return. Default is 1\n        :type number_of_keys: int\n        :param change: Payment (0) or change key (1). Default is 0\n        :type change: int\n\n        :return list of WalletKey:\n        \"\"\"\n        if self.scheme == 'single':\n            raise WalletError(\"Single wallet has only one (master)key. Use get_key() or main_key() method\")\n        return self._get_key(account_id, network, cosigner_id, number_of_keys, change, as_list=True)\n\n    def get_key_change(self, account_id=None, network=None):\n        \"\"\"\n        Get a unused change key or create a new one if there are no unused keys.\n        Wrapper for the :func:`get_key` method\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        return self._get_key(account_id=account_id, network=network, change=1, as_list=False)\n\n    def get_keys_change(self, account_id=None, network=None, number_of_keys=1):\n        \"\"\"\n        Get a unused change key or create a new one if there are no unused keys.\n        Wrapper for the :func:`get_key` method\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param number_of_keys: Number of keys to return. Default is 1\n        :type number_of_keys: int\n\n        :return list of WalletKey:\n        \"\"\"\n\n        return self._get_key(account_id=account_id, network=network, change=1, number_of_keys=number_of_keys,\n                             as_list=True)\n\n    def new_account(self, name='', account_id=None, network=None):\n        \"\"\"\n        Create a new account with a child key for payments and 1 for change.\n\n        An account key can only be created if wallet contains a masterkey.\n\n        :param name: Account Name. If not specified \"Account #\" with the account_id will be used as name\n        :type name: str\n        :param account_id: Account ID. Default is last accounts ID + 1\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme != 'bip32':\n            raise WalletError(\"We can only create new accounts for a wallet with a BIP32 key scheme\")\n        if self.main_key and (self.main_key.depth != 0 or self.main_key.is_private is False):\n            raise WalletError(\"A master private key of depth 0 is needed to create new accounts (depth: %d)\" %\n                              self.main_key.depth)\n        if \"account'\" not in self.key_path:\n            raise WalletError(\"Accounts are not supported for this wallet. Account not found in key path %s\" %\n                              self.key_path)\n        if network is None:\n            network = self.network.name\n        elif network != self.network.name and \"coin_type'\" not in self.key_path:\n            raise WalletError(\"Multiple networks not supported by wallet key structure\")\n\n        duplicate_cointypes = [Network(x).name for x in self.network_list() if Network(x).name != network and\n                               Network(x).bip44_cointype == Network(network).bip44_cointype]\n        if duplicate_cointypes:\n            raise WalletError(\"Can not create new account for network %s with same BIP44 cointype: %s\" %\n                              (network, duplicate_cointypes))\n\n        # Determine account_id and name\n        if account_id is None:\n            account_id = 0\n            qr = self._session.query(DbKey). \\\n                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network). \\\n                order_by(DbKey.account_id.desc()).first()\n            if qr:\n                account_id = qr.account_id + 1\n        if self.keys(account_id=account_id, depth=self.depth_public_master, network=network):\n            raise WalletError(\"Account with ID %d already exists for this wallet\" % account_id)\n\n        acckey = self.key_for_path([], level_offset=self.depth_public_master-self.key_depth, account_id=account_id,\n                                   name=name, network=network)\n        self.key_for_path([0, 0], network=network, account_id=account_id)\n        self.key_for_path([1, 0], network=network, account_id=account_id)\n        return acckey\n\n    def path_expand(self, path, level_offset=None, account_id=None, cosigner_id=0, address_index=None, change=0,\n                    network=DEFAULT_NETWORK):\n        \"\"\"\n        Create key path. Specify part of key path to expand to key path used in this wallet.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.path_expand([0,1200])\n        ['m', \"44'\", \"0'\", \"0'\", '0', '1200']\n\n        >>> w = Wallet('create_legacy_multisig_wallet_test')\n        >>> w.path_expand([0,2], cosigner_id=1)\n        ['m', \"45'\", '1', '0', '2']\n\n        :param path: Part of path, for example [0, 2] for change=0 and address_index=2\n        :type path: list, str\n        :param level_offset: Just create part of path. For example -2 means create path with the last 2 items (change, address_index) or 1 will return the master key 'm'\n        :type level_offset: int\n        :param account_id: Account ID\n        :type account_id: int\n        :param cosigner_id: ID of cosigner\n        :type cosigner_id: int\n        :param address_index: Index of key, normally provided to 'path' argument\n        :type address_index: int\n        :param change: Change key = 1 or normal = 0, normally provided to 'path' argument\n        :type change: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return list:\n        \"\"\"\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        return path_expand(path, self.key_path, level_offset, account_id=account_id, cosigner_id=cosigner_id,\n                           address_index=address_index, change=change, purpose=self.purpose,\n                           witness_type=self.witness_type, network=network)\n\n    def key_for_path(self, path, level_offset=None, name=None, account_id=None, cosigner_id=None,\n                     address_index=0, change=0, network=None, recreate=False):\n        \"\"\"\n        Return key for specified path. Derive all wallet keys in path if they not already exists\n\n        >>> w = wallet_create_or_open('key_for_path_example')\n        >>> key = w.key_for_path([0, 0])\n        >>> key.path\n        \"m/44'/0'/0'/0/0\"\n\n        >>> w.key_for_path([], level_offset=-2).path\n        \"m/44'/0'/0'\"\n\n        >>> w.key_for_path([], w.depth_public_master + 1).path\n        \"m/44'/0'/0'\"\n\n        Arguments provided in 'path' take precedence over other arguments. The address_index argument is ignored:\n        >>> key = w.key_for_path([0, 10], address_index=1000)\n        >>> key.path\n        \"m/44'/0'/0'/0/10\"\n        >>> key.address_index\n        10\n\n        :param path: Part of key path, i.e. [0, 0] for [change=0, address_index=0]\n        :type path: list, str\n        :param level_offset: Just create part of path, when creating keys. For example -2 means create path with the last 2 items (change, address_index) or 1 will return the master key 'm'\n        :type level_offset: int\n        :param name: Specify key name for latest/highest key in structure\n        :type name: str\n        :param account_id: Account ID\n        :type account_id: int\n        :param cosigner_id: ID of cosigner\n        :type cosigner_id: int\n        :param address_index: Index of key, normally provided to 'path' argument\n        :type address_index: int\n        :param change: Change key = 1 or normal = 0, normally provided to 'path' argument\n        :type change: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param recreate: Recreate key, even if already found in wallet. Can be used to update public key with private key info\n        :type recreate: bool\n\n        :return WalletKey:\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        cosigner_id = cosigner_id if cosigner_id is not None else self.cosigner_id\n        level_offset_key = level_offset\n        if level_offset and self.main_key and level_offset > 0:\n            level_offset_key = level_offset - self.main_key.depth\n\n        key_path = self.key_path\n        if self.multisig and cosigner_id is not None and len(self.cosigner) > cosigner_id:\n            key_path = self.cosigner[cosigner_id].key_path\n        fullpath = path_expand(path, key_path, level_offset_key, account_id=account_id, cosigner_id=cosigner_id,\n                               purpose=self.purpose, address_index=address_index, change=change,\n                               witness_type=self.witness_type, network=network)\n\n        if self.multisig and self.cosigner:\n            public_keys = []\n            for wlt in self.cosigner:\n                if wlt.scheme == 'single':\n                    wk = wlt.main_key\n                else:\n                    wk = wlt.key_for_path(path, level_offset=level_offset, account_id=account_id, name=name,\n                                          cosigner_id=cosigner_id, network=network, recreate=recreate)\n                public_keys.append(wk)\n            return self._new_key_multisig(public_keys, name, account_id, change, cosigner_id, network, address_index)\n\n        # Check for closest ancestor in wallet\\\n        wpath = fullpath\n        if self.main_key.depth and fullpath and fullpath[0] != 'M':\n            wpath = [\"M\"] + fullpath[self.main_key.depth + 1:]\n        dbkey = None\n        while wpath and not dbkey:\n            qr = self._session.query(DbKey).filter_by(path=normalize_path('/'.join(wpath)), wallet_id=self.wallet_id)\n            if recreate:\n                qr = qr.filter_by(is_private=True)\n            dbkey = qr.first()\n            wpath = wpath[:-1]\n        if not dbkey:\n            _logger.warning(\"No master or public master key found in this wallet\")\n            return None\n        else:\n            topkey = self.key(dbkey.id)\n\n        # Key already found in db, return key\n        if dbkey and dbkey.path == normalize_path('/'.join(fullpath)) and not recreate:\n            return topkey\n        else:\n            # Create 1 or more keys add them to wallet\n            nk = None\n            parent_id = topkey.key_id\n            ck = topkey.key()\n            newpath = topkey.path\n            n_items = len(str(dbkey.path).split('/'))\n            for lvl in fullpath[n_items:]:\n                ck = ck.subkey_for_path(lvl, network=network)\n                newpath += '/' + lvl\n                if not account_id:\n                    account_id = 0 if \"account'\" not in self.key_path or self.key_path.index(\"account'\") >= len(\n                        fullpath) \\\n                        else int(fullpath[self.key_path.index(\"account'\")][:-1])\n                change = None if \"change\" not in self.key_path or self.key_path.index(\"change\") >= len(fullpath) \\\n                    else int(fullpath[self.key_path.index(\"change\")])\n                if name and len(fullpath) == len(newpath.split('/')):\n                    key_name = name\n                else:\n                    key_name = \"%s %s\" % (self.key_path[len(newpath.split('/'))-1], lvl)\n                    key_name = key_name.replace(\"'\", \"\").replace(\"_\", \" \")\n                nk = WalletKey.from_key(key=ck, name=key_name, wallet_id=self.wallet_id, account_id=account_id,\n                                        change=change, purpose=self.purpose, path=newpath, parent_id=parent_id,\n                                        encoding=self.encoding, witness_type=self.witness_type,\n                                        cosigner_id=cosigner_id, network=network, session=self._session)\n                self._key_objects.update({nk.key_id: nk})\n                parent_id = nk.key_id\n            return nk\n\n    def keys(self, account_id=None, name=None, key_id=None, change=None, depth=None, used=None, is_private=None,\n             has_balance=None, is_active=None, network=None, include_private=False, as_dict=False):\n        \"\"\"\n        Search for keys in database. Include 0 or more of account_id, name, key_id, change and depth.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> all_wallet_keys = w.keys()\n        >>> w.keys(depth=0) # doctest:+ELLIPSIS\n        [<DbKey(id=..., name='bitcoinlib_legacy_wallet_test', wif='xprv9s21ZrQH143K3cxbMVswDTYgAc9CeXABQjCD9zmXCpXw4MxN93LanEARbBmV3utHZS9Db4FX1C1RbC5KSNAjQ5WNJ1dDBJ34PjfiSgRvS8x'>]\n\n        Returns a list of DbKey object or dictionary object if as_dict is True\n\n        :param account_id: Search for account ID\n        :type account_id: int\n        :param name: Search for Name\n        :type name: str\n        :param key_id: Search for Key ID\n        :type key_id: int\n        :param change: Search for Change\n        :type change: int\n        :param depth: Only include keys with this depth\n        :type depth: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param is_private: Only return private keys\n        :type is_private: bool\n        :param has_balance: Only include keys with a balance or without a balance, default is both\n        :type has_balance: bool\n        :param is_active: Hide inactive keys. Only include active keys with either a balance or which are unused, default is None (show all)\n        :type is_active: bool\n        :param network: Network name filter\n        :type network: str\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n        :param as_dict: Return keys as dictionary objects. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of DbKey: List of Keys\n        \"\"\"\n\n        qr = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id).order_by(DbKey.id)\n        if network is not None:\n            qr = qr.filter(DbKey.network_name == network)\n        if account_id is not None:\n            qr = qr.filter(DbKey.account_id == account_id)\n            if self.scheme == 'bip32' and depth is None:\n                qr = qr.filter(DbKey.depth >= 3)\n        if change is not None:\n            qr = qr.filter(DbKey.change == change)\n            if self.scheme == 'bip32' and depth is None:\n                qr = qr.filter(DbKey.depth > self.key_depth - 1)\n        if depth is not None:\n            qr = qr.filter(DbKey.depth == depth)\n        if name is not None:\n            qr = qr.filter(DbKey.name == name)\n        if key_id is not None:\n            qr = qr.filter(DbKey.id == key_id)\n            is_active = False\n        elif used is not None:\n            qr = qr.filter(DbKey.used == used)\n        if is_private is not None:\n            qr = qr.filter(DbKey.is_private == is_private)\n        if has_balance is True and is_active is True:\n            raise WalletError(\"Cannot use has_balance and is_active parameter together\")\n        if has_balance is not None:\n            if has_balance:\n                qr = qr.filter(DbKey.balance != 0)\n            else:\n                qr = qr.filter(DbKey.balance == 0)\n        if is_active:  # Unused keys and keys with a balance\n            qr = qr.filter(or_(DbKey.balance != 0, DbKey.used.is_(False)))\n        keys = qr.order_by(DbKey.depth).all()\n        if as_dict:\n            keys = [x.__dict__ for x in keys]\n            keys2 = []\n            private_fields = []\n            if not include_private:\n                private_fields += ['private', 'wif']\n            for key in keys:\n                keys2.append({k: v for (k, v) in key.items()\n                              if k[:1] != '_' and k != 'wallet' and k not in private_fields})\n            return keys2\n        qr.session.close()\n        return keys\n\n    def keys_networks(self, used=None, as_dict=False):\n        \"\"\"\n        Get keys of defined networks for this wallet. Wrapper for the :func:`keys` method\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> network_key = w.keys_networks()\n        >>> # Address index of hardened key 0' is 2147483648\n        >>> network_key[0].address_index\n        2147483648\n        >>> network_key[0].path\n        \"m/44'/0'\"\n\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict):\n\n        \"\"\"\n\n        if self.scheme != 'bip32':\n            raise WalletError(\"The 'keys_network' method can only be used with BIP32 type wallets\")\n        try:\n            depth = self.key_path.index(\"coin_type'\")\n        except ValueError:\n            return []\n        if self.multisig and self.cosigner:\n            _logger.warning(\"No network keys available for multisig wallet, use networks() method for list of networks\")\n        return self.keys(depth=depth, used=used, as_dict=as_dict)\n\n    def keys_accounts(self, account_id=None, network=DEFAULT_NETWORK, as_dict=False):\n        \"\"\"\n        Get Database records of account key(s) with for current wallet. Wrapper for the :func:`keys` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> account_key = w.keys_accounts()\n        >>> account_key[0].path\n        \"m/44'/0'/0'\"\n\n        Returns nothing if no account keys are available for instance in multisig or single account wallets. In this case use :func:`accounts` method instead.\n\n        :param account_id: Search for Account ID\n        :type account_id: int\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict):\n        \"\"\"\n\n        return self.keys(account_id, depth=self.depth_public_master, network=network, as_dict=as_dict)\n\n    def keys_addresses(self, account_id=None, used=None, is_active=None, change=None, network=None, depth=None,\n                       as_dict=False):\n        \"\"\"\n        Get address keys of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.keys_addresses()[0].address\n        '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg'\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param is_active: Hide inactive keys. Only include active keys with either a balance or which are unused, default is True\n        :type is_active: bool\n        :param change: Search for Change\n        :type change: int\n        :param network: Network name filter\n        :type network: str\n        :param depth: Filter by key depth. Default for BIP44 and multisig is 5\n        :type depth: int\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        if depth is None:\n            depth = self.key_depth\n        return self.keys(account_id, depth=depth, used=used, change=change, is_active=is_active, network=network,\n                         as_dict=as_dict)\n\n    def keys_address_payment(self, account_id=None, used=None, network=None, as_dict=False):\n        \"\"\"\n        Get payment addresses (change=0) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        return self.keys(account_id, depth=self.key_depth, change=0, used=used, network=network, as_dict=as_dict)\n\n    def keys_address_change(self, account_id=None, used=None, network=None, as_dict=False):\n        \"\"\"\n        Get payment addresses (change=1) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        return self.keys(account_id, depth=self.key_depth, change=1, used=used, network=network, as_dict=as_dict)\n\n    def addresslist(self, account_id=None, used=None, network=None, change=None, depth=None, key_id=None):\n        \"\"\"\n        Get list of addresses defined in current wallet. Wrapper for the :func:`keys` methods.\n\n        Use :func:`keys_addresses` method to receive full key objects\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.addresslist()[0]\n        '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg'\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool, None\n        :param network: Network name filter\n        :type network: str\n        :param change: Only include change addresses or not. Default is None which returns both\n        :param depth: Filter by key depth. Default is None for standard key depth. Use -1 to show all keys\n        :type depth: int\n        :param key_id: Key ID to get address of just 1 key\n        :type key_id: int\n\n        :return list of str: List of address strings\n        \"\"\"\n\n        addresslist = []\n        if depth is None:\n            depth = self.key_depth\n        elif depth == -1:\n            depth = None\n        for key in self.keys(account_id=account_id, depth=depth, used=used, network=network, change=change,\n                             key_id=key_id, is_active=False):\n            addresslist.append(key.address)\n        return addresslist\n\n    def key(self, term):\n        \"\"\"\n        Return single key with given ID or name as WalletKey object\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.key('change 0').address\n        '1HabJXe8mTwXiMzUWW5KdpYbFWu3hvtsbF'\n\n        :param term: Search term can be key ID, key address, key WIF or key name\n        :type term: int, str\n\n        :return WalletKey: Single key as object\n        \"\"\"\n\n        dbkey = None\n        qr = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id)\n        if self.purpose:\n            qr = qr.filter_by(purpose=self.purpose)\n        if isinstance(term, numbers.Number):\n            dbkey = qr.filter_by(id=term).scalar()\n        if not dbkey:\n            dbkey = qr.filter_by(address=term).first()\n        if not dbkey:\n            dbkey = qr.filter_by(wif=term).first()\n        if not dbkey:\n            dbkey = qr.filter_by(name=term).first()\n        if dbkey:\n            if dbkey.id in self._key_objects.keys():\n                return self._key_objects[dbkey.id]\n            else:\n                hdwltkey = WalletKey(key_id=dbkey.id, session=self._session)\n                self._key_objects.update({dbkey.id: hdwltkey})\n                return hdwltkey\n        else:\n            raise BKeyError(\"Key '%s' not found\" % term)\n\n    def account(self, account_id):\n        \"\"\"\n        Returns wallet key of specific BIP44 account.\n\n        Account keys have a BIP44 path depth of 3 and have the format m/purpose'/network'/account'\n\n        I.e: Use account(0).key().wif_public() to get wallet's public master key\n\n        :param account_id: ID of account. Default is 0\n        :type account_id: int\n\n        :return WalletKey:\n        \"\"\"\n\n        if \"account'\" not in self.key_path:\n            raise WalletError(\"Accounts are not supported for this wallet. Account not found in key path %s\" %\n                              self.key_path)\n        qr = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=self.network.name,\n                      account_id=account_id, depth=3).scalar()\n        if not qr:\n            raise WalletError(\"Account with ID %d not found in this wallet\" % account_id)\n        key_id = qr.id\n        return self.key(key_id)\n\n    def accounts(self, network=DEFAULT_NETWORK):\n        \"\"\"\n        Get list of accounts for this wallet\n\n        :param network: Network name filter. Default filter is DEFAULT_NETWORK\n        :type network: str\n\n        :return list of integers: List of accounts IDs\n        \"\"\"\n\n        if self.multisig and self.cosigner:\n            if self.cosigner_id is None:\n                raise WalletError(\"Missing Cosigner ID value for this wallet, cannot fetch account ID\")\n            accounts = [wk.account_id for wk in self.cosigner[self.cosigner_id].keys_accounts(network=network)]\n        else:\n            accounts = [wk.account_id for wk in self.keys_accounts(network=network)]\n        if not accounts:\n            accounts = [self.default_account_id]\n        return list(dict.fromkeys(accounts))\n\n    def networks(self, as_dict=False):\n        \"\"\"\n        Get list of networks used by this wallet\n\n        :param as_dict: Return as dictionary or as Network objects, default is Network objects\n        :type as_dict: bool\n\n        :return list of (Network, dict):\n        \"\"\"\n\n        nw_list = [self.network]\n        if self.multisig and self.cosigner:\n            keys_qr = self._session.query(DbKey.network_name).\\\n                filter_by(wallet_id=self.wallet_id, depth=self.key_depth).\\\n                group_by(DbKey.network_name).all()\n            nw_list += [Network(nw[0]) for nw in keys_qr]\n        elif self.main_key.key_type != 'single':\n            wks = self.keys_networks()\n            for wk in wks:\n                nw_list.append(Network(wk.network_name))\n\n        networks = []\n        nw_list = list(dict.fromkeys(nw_list))\n        for nw in nw_list:\n            if as_dict:\n                nw = nw.__dict__\n                if '_sa_instance_state' in nw:\n                    del nw['_sa_instance_state']\n            networks.append(nw)\n\n        return networks\n\n    def network_list(self, field='name'):\n        \"\"\"\n        Wrapper for :func:`networks` method, returns a flat list with currently used\n        networks for this wallet.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.network_list()\n        ['bitcoin']\n\n        :return list of str:\n        \"\"\"\n\n        return [getattr(x, field) for x in self.networks()]\n\n    def balance_update_from_serviceprovider(self, account_id=None, network=None):\n        \"\"\"\n        Update balance of currents account addresses using default Service objects :func:`getbalance` method. Update total\n        wallet balance in database.\n\n        Please Note: Does not update UTXO's or the balance per key! For this use the :func:`updatebalance` method\n        instead\n\n        :param account_id: Account ID. Leave empty for default account\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return int: Total balance\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        balance = srv.getbalance(self.addresslist(account_id=account_id, network=network))\n        if srv.results:\n            new_balance = {\n                'account_id': account_id,\n                'network': network,\n                'balance': balance\n            }\n            old_balance_item = [bi for bi in self._balances if bi['network'] == network and\n                                bi['account_id'] == account_id]\n            if old_balance_item:\n                item_n = self._balances.index(old_balance_item[0])\n                self._balances[item_n] = new_balance\n            else:\n                self._balances.append(new_balance)\n        return balance\n\n    def balance(self, account_id=None, network=None, as_string=False):\n        \"\"\"\n        Get total of unspent outputs\n\n        :param account_id: Account ID filter\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param as_string: Set True to return a string in currency format. Default returns float.\n        :type as_string: boolean\n\n        :return float, str: Key balance\n        \"\"\"\n\n        self._balance_update(account_id, network)\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n\n        balance = 0\n        b_res = [b['balance'] for b in self._balances if b['account_id'] == account_id and b['network'] == network]\n        if len(b_res):\n            balance = b_res[0]\n        if as_string:\n            return Value.from_satoshi(balance, network=network).str_unit()\n        else:\n            return float(balance)\n\n    def _balance_update(self, account_id=None, network=None, key_id=None, min_confirms=0):\n        \"\"\"\n        Update balance from UTXO's in database. To get most recent balance use :func:`utxos_update` first.\n\n        Also updates balance of wallet and keys in this wallet for the specified account or all accounts if\n        no account is specified.\n\n        :param account_id: Account ID filter\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param key_id: Key ID Filter\n        :type key_id: int\n        :param min_confirms: Minimal confirmations needed to include in balance (default = 0)\n        :type min_confirms: int\n\n        :return: Updated balance\n        \"\"\"\n\n        qr = self._session.query(DbTransactionOutput, func.sum(DbTransactionOutput.value), DbTransaction.network_name,\n                                 DbTransaction.account_id).\\\n            join(DbTransaction). \\\n            filter(DbTransactionOutput.spent.is_(False),\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.confirmations >= min_confirms)\n        if account_id is not None:\n            qr = qr.filter(DbTransaction.account_id == account_id)\n        if network is not None:\n            qr = qr.filter(DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionOutput.key_id == key_id)\n        else:\n            qr = qr.filter(DbTransactionOutput.key_id.isnot(None))\n        utxos = qr.group_by(\n            DbTransactionOutput.key_id,\n            DbTransactionOutput.transaction_id,\n            DbTransactionOutput.output_n,\n            DbTransaction.network_name,\n            DbTransaction.account_id\n        ).all()\n\n        key_values = [\n            {\n                'id': utxo[0].key_id,\n                'network': utxo[2],\n                'account_id': utxo[3],\n                'balance': utxo[1]\n            }\n            for utxo in utxos\n        ]\n\n        grouper = itemgetter(\"id\", \"network\", \"account_id\")\n        key_balance_list = []\n        for key, grp in groupby(sorted(key_values, key=grouper), grouper):\n            nw_acc_dict = dict(zip([\"id\", \"network\", \"account_id\"], key))\n            nw_acc_dict[\"balance\"] = sum(item[\"balance\"] for item in grp)\n            key_balance_list.append(nw_acc_dict)\n\n        grouper = itemgetter(\"network\", \"account_id\")\n        balance_list = []\n        for key, grp in groupby(sorted(key_balance_list, key=grouper), grouper):\n            nw_acc_dict = dict(zip([\"network\", \"account_id\"], key))\n            nw_acc_dict[\"balance\"] = sum(item[\"balance\"] for item in grp)\n            balance_list.append(nw_acc_dict)\n\n        # Add keys with no UTXO's with 0 balance\n        for key in self.keys(account_id=account_id, network=network, key_id=key_id):\n            if key.id not in [utxo[0].key_id for utxo in utxos]:\n                key_balance_list.append({\n                    'id': key.id,\n                    'network': network,\n                    'account_id': key.account_id,\n                    'balance': 0\n                })\n\n        if not key_id:\n            for bl in balance_list:\n                bl_item = [b for b in self._balances if\n                           b['network'] == bl['network'] and b['account_id'] == bl['account_id']]\n                if not bl_item:\n                    self._balances.append(bl)\n                    continue\n                lx = self._balances.index(bl_item[0])\n                self._balances[lx].update(bl)\n\n        self._balance = sum([b['balance'] for b in balance_list if b['network'] == self.network.name])\n\n        # Bulk update database\n        for kb in key_balance_list:\n            if kb['id'] in self._key_objects:\n                self._key_objects[kb['id']]._balance = kb['balance']\n        self._session.bulk_update_mappings(DbKey, key_balance_list)\n        self._commit()\n        _logger.info(\"Got balance for %d key(s)\" % len(key_balance_list))\n        return self._balances\n\n    def utxos_update(self, account_id=None, used=None, networks=None, key_id=None, depth=None, change=None,\n                     utxos=None, update_balance=True, max_utxos=MAX_TRANSACTIONS, rescan_all=True):\n        \"\"\"\n        Update UTXO's (Unspent Outputs) for addresses/keys in this wallet using various Service providers.\n\n        This method does not import transactions: use :func:`transactions_update` function or to look for new addresses use :func:`scan`.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only check for UTXO for used or unused keys. Default is both\n        :type used: bool\n        :param networks: Network name filter as string or list of strings. Leave empty to update all used networks in wallet\n        :type networks: str, list\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n        :param depth: Only update keys with this depth, default is depth 5 according to BIP0048 standard. Set depth to None to update all keys of this wallet.\n        :type depth: int\n        :param change: Only update change or normal keys, default is both (None)\n        :type change: int\n        :param utxos: List of unspent outputs in dictionary format specified below. For usage on an offline PC, you can import utxos with the utxos parameter as a list of dictionaries\n        :type utxos: list of dict.\n\n        .. code-block:: json\n\n            {\n              \"address\": \"n2S9Czehjvdmpwd2YqekxuUC1Tz5ZdK3YN\",\n              \"script\": \"\",\n              \"confirmations\": 10,\n              \"output_n\": 1,\n              \"txid\": \"9df91f89a3eb4259ce04af66ad4caf3c9a297feea5e0b3bc506898b6728c5003\",\n              \"value\": 8970937\n            }\n\n        :param update_balance: Option to disable balance update after fetching UTXO's. Can be used when utxos_update method is called several times in a row. Default is True\n        :type update_balance: bool\n        :param max_utxos: Maximum number of UTXO's to update\n        :type max_utxos: int\n        :param rescan_all: Remove old utxo's and rescan wallet. Default is True. Set to False if you work with large utxo's sets. Value will be ignored if key_id is specified in your call\n        :type rescan_all: bool\n\n        :return int: Number of new UTXO's added\n        \"\"\"\n\n        _, account_id, acckey = self._get_account_defaults('', account_id, key_id)\n\n        single_key = None\n        if key_id:\n            single_key = self._session.query(DbKey).filter_by(id=key_id).scalar()\n            networks = [single_key.network_name]\n            account_id = single_key.account_id\n            rescan_all = False\n        if networks is None:\n            networks = self.network_list()\n        elif not isinstance(networks, list):\n            networks = [networks]\n        elif len(networks) != 1 and utxos is not None:\n            raise WalletError(\"Please specify maximum 1 network when passing utxo's\")\n\n        count_utxos = 0\n        for network in networks:\n            # Remove current UTXO's\n            if rescan_all:\n                cur_utxos = self._session.query(DbTransactionOutput). \\\n                    join(DbTransaction). \\\n                    filter(DbTransactionOutput.spent.is_(False),\n                           DbTransaction.account_id == account_id,\n                           DbTransaction.wallet_id == self.wallet_id,\n                           DbTransaction.network_name == network).all()\n                for u in cur_utxos:\n                    self._session.query(DbTransactionOutput).filter_by(\n                        transaction_id=u.transaction_id, output_n=u.output_n).update({DbTransactionOutput.spent: True})\n                self._commit()\n\n            if account_id is None and not self.multisig:\n                accounts = self.accounts(network=network)\n            else:\n                accounts = [account_id]\n            for account_id in accounts:\n                if depth is None:\n                    depth = self.key_depth\n                if utxos is None:\n                    # Get all UTXO's for this wallet from default Service object\n                    addresslist = self.addresslist(account_id=account_id, used=used, network=network, key_id=key_id,\n                                                   change=change, depth=depth)\n                    random.shuffle(addresslist)\n                    srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n                    srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n                    utxos = []\n                    for address in addresslist:\n                        if rescan_all:\n                            last_txid = ''\n                        else:\n                            last_txid = self.utxo_last(address)\n                        new_utxos = srv.getutxos(address, after_txid=last_txid, limit=max_utxos)\n                        if new_utxos:\n                            utxos += new_utxos\n                        elif new_utxos is False:\n                            raise WalletError(\"No response from any service provider, could not update UTXO's. \"\n                                              \"Errors: %s\" % srv.errors)\n                    if srv.complete:\n                        self.last_updated = datetime.now()\n                    elif utxos and 'date' in utxos[-1:][0]:\n                        self.last_updated = utxos[-1:][0]['date']\n\n                # If UTXO is new, add to database otherwise update depth (confirmation count)\n                for utxo in utxos:\n                    key = single_key\n                    if not single_key:\n                        key = self._session.query(DbKey).\\\n                            filter_by(wallet_id=self.wallet_id, address=utxo['address']).scalar()\n                    if not key:\n                        raise WalletError(\"Key with address %s not found in this wallet\" % utxo['address'])\n                    key.used = True\n                    status = 'unconfirmed'\n                    if utxo['confirmations']:\n                        status = 'confirmed'\n\n                    # Update confirmations in db if utxo was already imported\n                    transaction_in_db = self._session.query(DbTransaction).\\\n                        filter_by(wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']),\n                                  network_name=network)\n                    utxo_in_db = self._session.query(DbTransactionOutput).join(DbTransaction).\\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransaction.txid == bytes.fromhex(utxo['txid']),\n                               DbTransactionOutput.output_n == utxo['output_n'])\n                    spent_in_db = self._session.query(DbTransactionInput).join(DbTransaction).\\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransactionInput.prev_txid == bytes.fromhex(utxo['txid']),\n                               DbTransactionInput.output_n == utxo['output_n'])\n                    if utxo_in_db.count():\n                        utxo_record = utxo_in_db.scalar()\n                        if not utxo_record.key_id:\n                            count_utxos += 1\n                        utxo_record.key_id = key.id\n                        utxo_record.spent = bool(spent_in_db.count())\n                        if transaction_in_db.count():\n                            transaction_record = transaction_in_db.scalar()\n                            transaction_record.confirmations = utxo['confirmations']\n                            transaction_record.status = status\n                    else:\n                        # Add transaction if not exist and then add output\n                        if not transaction_in_db.count():\n                            block_height = None\n                            if block_height in utxo and utxo['block_height']:\n                                block_height = utxo['block_height']\n                            new_tx = DbTransaction(\n                                wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']), status=status,\n                                is_complete=False, block_height=block_height, account_id=account_id,\n                                confirmations=utxo['confirmations'], network_name=network)\n                            self._session.add(new_tx)\n                            # TODO: Get unique id before inserting to increase performance for large utxo-sets\n                            self._commit()\n                            tid = new_tx.id\n                        else:\n                            tid = transaction_in_db.scalar().id\n\n                        script_type = script_type_default(self.witness_type, multisig=self.multisig,\n                                                          locking_script=True)\n                        new_utxo = DbTransactionOutput(transaction_id=tid,  output_n=utxo['output_n'],\n                                                       value=utxo['value'], key_id=key.id, address=utxo['address'],\n                                                       script=bytes.fromhex(utxo['script']),\n                                                       script_type=script_type,\n                                                       spent=bool(spent_in_db.count()))\n                        self._session.add(new_utxo)\n                        count_utxos += 1\n\n                    self._commit()\n\n                _logger.info(\"Got %d new UTXOs for account %s\" % (count_utxos, account_id))\n                self._commit()\n                if update_balance:\n                    self._balance_update(account_id=account_id, network=network, key_id=key_id, min_confirms=0)\n                utxos = None\n        return count_utxos\n\n    def utxos(self, account_id=None, network=None, min_confirms=0, key_id=None):\n        \"\"\"\n        Get UTXO's (Unspent Outputs) from database. Use :func:`utxos_update` method first for updated values\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.utxos()  # doctest:+SKIP\n        [{'value': 100000000, 'script': '', 'output_n': 0, 'transaction_id': ..., 'spent': False, 'script_type': 'p2pkh', 'key_id': ..., 'address': '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', 'confirmations': 0, 'txid': '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', 'network_name': 'bitcoin'}]\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param min_confirms: Minimal confirmation needed to include in output list\n        :type min_confirms: int\n        :param key_id: Key ID or list of key IDs to filter utxo's for specific keys\n        :type key_id: int, list\n\n        :return list: List of transactions\n        \"\"\"\n\n        first_key_id = key_id\n        if isinstance(key_id, list):\n            first_key_id = key_id[0]\n        network, account_id, acckey = self._get_account_defaults(network, account_id, first_key_id)\n\n        qr = self._session.query(DbTransactionOutput, DbKey.address, DbTransaction.confirmations, DbTransaction.txid,\n                                 DbKey.network_name).\\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransactionOutput.spent.is_(False),\n                   DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network,\n                   DbTransaction.confirmations >= min_confirms)\n        if isinstance(key_id, int):\n            qr = qr.filter(DbKey.id == key_id)\n        elif isinstance(key_id, list):\n            qr = qr.filter(DbKey.id.in_(key_id))\n        utxos = qr.order_by(DbTransaction.confirmations.desc()).all()\n        res = []\n        for utxo in utxos:\n            u = utxo[0].__dict__\n            if '_sa_instance_state' in u:\n                del u['_sa_instance_state']\n            u['address'] = utxo[1]\n            u['confirmations'] = int(utxo[2])\n            u['txid'] = utxo[3].hex()\n            u['network_name'] = utxo[4]\n            res.append(u)\n        return res\n\n    def utxo_add(self, address, value, txid, output_n, confirmations=1, script=''):\n        \"\"\"\n        Add a single UTXO to the wallet database. To update all utxo's use :func:`utxos_update` method.\n\n        Use this method for testing, offline wallets or if you wish to override standard method of retreiving UTXO's\n\n        This method does not check if UTXO exists or is still spendable.\n\n        :param address: Address of Unspent Output. Address should be available in wallet\n        :type address: str\n        :param value: Value of output in sathosis or smallest denominator for type of currency\n        :type value: int\n        :param txid: Transaction hash or previous output as hex-string\n        :type txid: str\n        :param output_n: Output number of previous transaction output\n        :type output_n: int\n        :param confirmations: Number of confirmations. Default is 0, unconfirmed\n        :type confirmations: int\n        :param script: Locking script of previous output as hex-string\n        :type script: str\n\n        :return int: Number of new UTXO's added, so 1 if successful\n        \"\"\"\n\n        utxo = {\n            'address': address,\n            'script': script,\n            'confirmations': confirmations,\n            'output_n': output_n,\n            'txid': txid,\n            'value': value\n        }\n        return self.utxos_update(utxos=[utxo])\n\n    def utxo_last(self, address):\n        \"\"\"\n        Get transaction ID for latest utxo in database for given address\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.utxo_last('16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg')\n        '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4'\n\n        :param address: The address\n        :type address: str\n\n        :return str:\n        \"\"\"\n        to = self._session.query(\n            DbTransaction.txid, DbTransaction.confirmations). \\\n            join(DbTransactionOutput).join(DbKey). \\\n            filter(DbKey.address == address, DbTransaction.wallet_id == self.wallet_id,\n                   DbTransactionOutput.spent.is_(False)). \\\n            order_by(DbTransaction.confirmations).first()\n        return '' if not to else to[0].hex()\n\n    def transactions_update_confirmations(self):\n        \"\"\"\n        Update number of confirmations and status for transactions in database\n\n        :return:\n        \"\"\"\n        network = self.network.name\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        blockcount = srv.blockcount()\n        db_txs = self._session.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()\n        for db_tx in db_txs:\n            self._session.query(DbTransaction).filter_by(id=db_tx.id). \\\n                update({DbTransaction.status: 'confirmed',\n                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})\n        self._commit()\n\n    def transactions_update_by_txids(self, txids):\n        \"\"\"\n        Update transaction or list or transaction for this wallet with provided transaction ID\n\n        :param txids: Transaction ID, or list of transaction IDs\n        :type txids: str, list of str, bytes, list of bytes\n\n        :return:\n        \"\"\"\n        if not isinstance(txids, list):\n            txids = [txids]\n        txids = list(dict.fromkeys(txids))\n\n        txs = []\n        srv = Service(network=self.network.name, providers=self.providers, cache_uri=self.db_cache_uri)\n        for txid in txids:\n            tx = srv.gettransaction(to_hexstring(txid))\n            if tx:\n                txs.append(tx)\n\n        # TODO: Avoid duplicate code in this method and transaction_update()\n        utxo_set = set()\n        for t in txs:\n            wt = WalletTransaction.from_transaction(self, t)\n            wt.store()\n            utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]\n            utxo_set.update(utxos)\n\n        for utxo in list(utxo_set):\n            tos = self._session.query(DbTransactionOutput).join(DbTransaction). \\\n                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],\n                       DbTransactionOutput.spent.is_(False)).all()\n            for u in tos:\n                u.spent = True\n        self._commit()\n        # self._balance_update(account_id=account_id, network=network, key_id=key_id)\n\n    def transactions_update(self, account_id=None, used=None, network=None, key_id=None, depth=None, change=None,\n                            limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Update wallets transaction from service providers. Get all transactions for known keys in this wallet. The balances and unspent outputs (UTXO's) are updated as well. Only scan keys from default network and account unless another network or account is specified.\n\n        Use the :func:`scan` method for automatic address generation/management, and use the :func:`utxos_update` method to only look for unspent outputs and balances.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only update used or unused keys, specify None to update both. Default is None\n        :type used: bool, None\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n        :param depth: Only update keys with this depth, default is depth 5 according to BIP0048 standard. Set depth to None to update all keys of this wallet.\n        :type depth: int\n        :param change: Only update change or normal keys, default is both (None)\n        :type change: int\n        :param limit: Stop update after limit transactions to avoid timeouts with service providers. Default is MAX_TRANSACTIONS defined in config.py\n        :type limit: int\n\n        :return bool: True if all transactions are updated\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)\n        if depth is None:\n            depth = self.key_depth\n\n        # Update number of confirmations and status for already known transactions\n        if not key_id:\n            self.transactions_update_confirmations()\n\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        blockcount = srv.blockcount()\n        db_txs = self._session.query(DbTransaction).\\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()\n        for db_tx in db_txs:\n            self._session.query(DbTransaction).filter_by(id=db_tx.id).\\\n                update({DbTransaction.status: 'confirmed',\n                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})\n        self._commit()\n\n        # Get transactions for wallet's addresses\n        txs = []\n        addresslist = self.addresslist(\n            account_id=account_id, used=used, network=network, key_id=key_id, change=change, depth=depth)\n        last_updated = datetime.now()\n        for address in addresslist:\n            txs += srv.gettransactions(address, limit=limit, after_txid=self.transaction_last(address))\n            if not srv.complete:\n                if txs and txs[-1].date and txs[-1].date < last_updated:\n                    last_updated = txs[-1].date\n            if txs and txs[-1].confirmations:\n                dbkey = self._session.query(DbKey).filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id)\n                if not dbkey.update({DbKey.latest_txid: bytes.fromhex(txs[-1].txid)}):\n                    raise WalletError(\"Failed to update latest transaction id for key with address %s\" % address)\n                self._commit()\n        if txs is False:\n            raise WalletError(\"No response from any service provider, could not update transactions\")\n\n        # Update Transaction outputs to get list of unspent outputs (UTXO's)\n        utxo_set = set()\n        for t in txs:\n            wt = WalletTransaction.from_transaction(self, t)\n            wt.store()\n            utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]\n            utxo_set.update(utxos)\n        for utxo in list(utxo_set):\n            tos = self._session.query(DbTransactionOutput).join(DbTransaction).\\\n                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],\n                       DbTransactionOutput.spent.is_(False), DbTransaction.wallet_id == self.wallet_id).all()\n            for u in tos:\n                u.spent = True\n\n        self.last_updated = last_updated\n        self._commit()\n        self._balance_update(account_id=account_id, network=network, key_id=key_id)\n\n        return len(txs)\n\n    def transaction_last(self, address):\n        \"\"\"\n        Get transaction ID for latest transaction in database for given address\n\n        :param address: The address\n        :type address: str\n\n        :return str:\n        \"\"\"\n        txid = self._session.query(DbKey.latest_txid).\\\n            filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id).scalar()\n        return '' if not txid else txid.hex()\n\n    def transactions(self, account_id=None, network=None, include_new=False, key_id=None, as_dict=False):\n        \"\"\"\n        Get all known transactions input and outputs for this wallet.\n\n        The transaction only includes the inputs and outputs related to this wallet. To get full transactions\n        use the :func:`transactions_full` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.transactions()\n        [<WalletTransaction(input_count=0, output_count=1, status=confirmed, network=bitcoin)>]\n\n        :param account_id: Filter by Account ID. Leave empty for default account_id\n        :type account_id: int, None\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str, None\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param key_id: Filter by key ID\n        :type key_id: int, None\n        :param as_dict: Output as dictionary or WalletTransaction object\n        :type as_dict: bool\n\n        :return list of WalletTransaction: List of WalletTransaction or transactions as dictionary\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)\n        # Transaction inputs\n        qr = self._session.query(DbTransactionInput, DbTransactionInput.address, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbKey.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionInput.key_id == key_id)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs = qr.all()\n        # Transaction outputs\n        qr = self._session.query(DbTransactionOutput, DbTransactionOutput.address, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbKey.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionOutput.key_id == key_id)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs += qr.all()\n\n        txs = sorted(txs, key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True)\n        res = []\n        txids = []\n        for tx in txs:\n            txid = tx[3].hex()\n            if as_dict:\n                u = tx[0].__dict__\n                u['block_height'] = tx[0].transaction.block_height\n                u['date'] = tx[0].transaction.date\n                if '_sa_instance_state' in u:\n                    del u['_sa_instance_state']\n                u['address'] = tx[1]\n                u['confirmations'] = None if tx[2] is None else int(tx[2])\n                u['txid'] = txid\n                u['network_name'] = tx[4]\n                u['status'] = tx[5]\n                if 'index_n' in u:\n                    u['is_output'] = True\n                    u['value'] = -u['value']\n                else:\n                    u['is_output'] = False\n            else:\n                if txid in txids:\n                    continue\n                txids.append(txid)\n                u = self.transaction(txid)\n            res.append(u)\n        return res\n\n    def transactions_full(self, network=None, include_new=False, limit=0, offset=0):\n        \"\"\"\n        Get all transactions of this wallet as WalletTransaction objects\n\n        Use the :func:`transactions` method to only get the inputs and outputs transaction parts related to this wallet\n\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param limit: Maximum number of transactions to return. Combine with offset parameter to use as pagination\n        :type limit: int\n        :param offset: Number of transactions to skip\n        :type offset: int\n\n        :return list of WalletTransaction:\n        \"\"\"\n        network, _, _ = self._get_account_defaults(network)\n        qr = self._session.query(DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs = []\n        if limit:\n            qr = qr.limit(limit)\n        if offset:\n            qr = qr.offset(offset)\n        for tx in qr.all():\n            txs.append(self.transaction(tx[0].hex()))\n        return txs\n\n    def transactions_export(self, account_id=None, network=None, include_new=False, key_id=None, skip_change=True):\n        \"\"\"\n        Export wallets transactions as list of tuples with the following fields:\n            (transaction_date, transaction_hash, in/out, addresses_in, addresses_out, value, value_cumulative, fee)\n\n        :param account_id: Filter by Account ID. Leave empty for default account_id\n        :type account_id: int, None\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str, None\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param key_id: Filter by key ID\n        :type key_id: int, None\n        :param skip_change: Do not include change outputs. Default is True\n        :type skip_change: bool\n\n        :return list of tuple:\n        \"\"\"\n\n        txs_tuples = []\n        cumulative_value = 0\n        for t in self.transactions(account_id, network, include_new, key_id):\n            te = t.export(skip_change=skip_change)\n\n            # When transaction is outgoing deduct fee from cumulative value\n            if t.outgoing_tx:\n                cumulative_value -= t.fee\n\n            # Loop through all transaction inputs and outputs\n            for tei in te:\n                # Create string with  list of inputs addresses for incoming transactions, and outputs addresses\n                # for outgoing txs\n                addr_list_in = tei[3] if isinstance(tei[3], list) else [tei[3]]\n                addr_list_out = tei[4] if isinstance(tei[4], list) else [tei[4]]\n                cumulative_value += tei[5]\n                txs_tuples.append((tei[0], tei[1], tei[2], addr_list_in, addr_list_out, tei[5], cumulative_value,\n                                   tei[6]))\n        return txs_tuples\n\n    def transaction(self, txid):\n        \"\"\"\n        Get WalletTransaction object for given transaction ID (transaction hash)\n\n        :param txid: Hexadecimal transaction hash\n        :type txid: str\n\n        :return WalletTransaction:\n        \"\"\"\n        return WalletTransaction.from_txid(self, txid)\n\n    def transaction_spent(self, txid, output_n):\n        \"\"\"\n        Check if transaction with given transaction ID and output_n is spent and return txid of spent transaction.\n\n        Retrieves information from database, does not update transaction and does not check if transaction is spent with service providers.\n\n        :param txid: Hexadecimal transaction hash\n        :type txid: str, bytes\n        :param output_n: Output n\n        :type output_n: int, bytes\n\n        :return str: Transaction ID\n        \"\"\"\n        txid = to_bytes(txid)\n        if isinstance(output_n, bytes):\n            output_n = int.from_bytes(output_n, 'big')\n        qr = self._session.query(DbTransactionInput, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.status). \\\n            join(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransactionInput.prev_txid == txid, DbTransactionInput.output_n == output_n).scalar()\n        if qr:\n            return qr.transaction.txid.hex()\n\n    def _objects_by_key_id(self, key_id):\n        key = self._session.query(DbKey).filter_by(id=key_id).scalar()\n        if not key:\n            raise WalletError(\"Key '%s' not found in this wallet\" % key_id)\n        if key.key_type == 'multisig':\n            inp_keys = [HDKey.from_wif(ck.child_key.wif, network=ck.child_key.network_name) for ck in\n                        key.multisig_children]\n        elif key.key_type in ['bip32', 'single']:\n            if not key.wif:\n                raise WalletError(\"WIF of key is empty cannot create HDKey\")\n            inp_keys = [HDKey.from_wif(key.wif, network=key.network_name)]\n        else:\n            raise WalletError(\"Input key type %s not supported\" % key.key_type)\n        return inp_keys, key\n\n    def select_inputs(self, amount, variance=None, input_key_id=None, account_id=None, network=None, min_confirms=1,\n                      max_utxos=None, return_input_obj=True, skip_dust_amounts=True):\n        \"\"\"\n        Select available unspent transaction outputs (UTXO's) which can be used as inputs for a transaction for\n        the specified amount.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.select_inputs(50000000)\n        [<Input(prev_txid='748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', output_n=0, address='16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', index_n=0, type='sig_pubkey')>]\n\n        :param amount: Total value of inputs in the smallest denominator (sathosi) to select\n        :type amount: int\n        :param variance: Allowed difference in total input value. Default is dust amount of selected network. Difference will be added to transaction fee.\n        :type variance: int\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1 confirmation. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param return_input_obj: Return inputs as Input class object. Default is True\n        :type return_input_obj: bool\n        :param skip_dust_amounts: Do not include small amount to avoid dust inputs\n        :type skip_dust_amounts: bool\n\n        :return: List of previous outputs\n        :rtype: list of DbTransactionOutput, list of Input\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        dust_amount = Network(network).dust_amount\n        if variance is None:\n            variance = dust_amount\n\n        utxo_query = self._session.query(DbTransactionOutput).join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.wallet_id == self.wallet_id, DbTransaction.account_id == account_id,\n                   DbTransaction.network_name == network, DbKey.public != b'',\n                   DbTransactionOutput.spent.is_(False), DbTransaction.confirmations >= min_confirms)\n        if input_key_id:\n            if isinstance(input_key_id, int):\n                utxo_query = utxo_query.filter(DbKey.id == input_key_id)\n            else:\n                utxo_query = utxo_query.filter(DbKey.id.in_(input_key_id))\n        if skip_dust_amounts:\n            utxo_query = utxo_query.filter(DbTransactionOutput.value > dust_amount)\n        utxos = utxo_query.order_by(DbTransaction.confirmations.desc()).all()\n        if not utxos:\n            raise WalletError(\"Create transaction: No unspent transaction outputs found or no key available for UTXO's\")\n\n        # TODO: Find 1 or 2 UTXO's with exact amount +/- self.network.dust_amount\n\n        # Try to find one utxo with exact amount\n        one_utxo = utxo_query.filter(DbTransactionOutput.spent.is_(False),\n                                     DbTransactionOutput.value >= amount,\n                                     DbTransactionOutput.value <= amount + variance).first()\n        selected_utxos = []\n        if one_utxo:\n            selected_utxos = [one_utxo]\n        else:\n            # Try to find one utxo with higher amount\n            one_utxo = utxo_query. \\\n                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value >= amount).\\\n                order_by(DbTransactionOutput.value).first()\n            if one_utxo:\n                selected_utxos = [one_utxo]\n            elif max_utxos and max_utxos <= 1:\n                _logger.info(\"No single UTXO found with requested amount, use higher 'max_utxo' setting to use \"\n                             \"multiple UTXO's\")\n                return []\n\n        # Otherwise compose of 2 or more lesser outputs\n        if not selected_utxos:\n            lessers = utxo_query. \\\n                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value < amount).\\\n                order_by(DbTransactionOutput.value.desc()).all()\n            total_amount = 0\n            selected_utxos = []\n            for utxo in lessers[:max_utxos]:\n                if total_amount < amount:\n                    selected_utxos.append(utxo)\n                    total_amount += utxo.value\n            if total_amount < amount:\n                return []\n        if not return_input_obj:\n            return selected_utxos\n        else:\n            inputs = []\n            for utxo in selected_utxos:\n                # amount_total_input += utxo.value\n                inp_keys, key = self._objects_by_key_id(utxo.key_id)\n                multisig = False if len(inp_keys) < 2 else True\n                script_type = get_unlocking_script_type(utxo.script_type, multisig=multisig)\n                inputs.append(Input(utxo.transaction.txid, utxo.output_n, keys=inp_keys, script_type=script_type,\n                              sigs_required=self.multisig_n_required, sort=self.sort_keys, address=key.address,\n                              compressed=key.compressed, value=utxo.value, network=key.network_name))\n            return inputs\n\n    def transaction_create(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,\n                           min_confirms=1, max_utxos=None, locktime=0, number_of_change_outputs=1,\n                           random_output_order=True):\n        \"\"\"\n        Create new transaction with specified outputs.\n\n        Inputs can be specified but if not provided they will be selected from wallets utxo's with :func:`select_inputs` method.\n\n        Output array is a list of 1 or more addresses and amounts.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.transaction_create([('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000)])\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param output_arr: List of output as Output objects or tuples with address and amount. Must contain at least one item. Example: [('mxdLD8SAGS9fe2EeCXALDHcdTTbppMHp8N', 5000000)]\n        :type output_arr: list of Output, tuple\n        :param input_arr: List of inputs as Input objects or tuples with reference to a UTXO, a wallet key and value. The format is [(txid, output_n, key_ids, value, signatures, unlocking_script, address)]\n        :type input_arr: list of Input, tuple\n        :param input_key_id: Limit UTXO's search for inputs to this key_id. Only valid if no input array is specified\n        :type input_key_id: int\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1 confirmation. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount        :type number_of_change_outputs: int\n        :type number_of_change_outputs: int\n        :param random_output_order: Shuffle order of transaction outputs to increase privacy. Default is True\n        :type random_output_order: bool\n\n        :return WalletTransaction: object\n        \"\"\"\n\n        if not isinstance(output_arr, list):\n            raise WalletError(\"Output array must be a list of tuples with address and amount. \"\n                              \"Use 'send_to' method to send to one address\")\n        if not network and output_arr:\n            if isinstance(output_arr[0], Output):\n                network = output_arr[0].network.name\n            elif isinstance(output_arr[0][1], str):\n                network = Value(output_arr[0][1]).network.name\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n\n        if input_arr and max_utxos and len(input_arr) > max_utxos:\n            raise WalletError(\"Input array contains %d UTXO's but max_utxos=%d parameter specified\" %\n                              (len(input_arr), max_utxos))\n\n        # Create transaction and add outputs\n        amount_total_output = 0\n        transaction = WalletTransaction(hdwallet=self, account_id=account_id, network=network, locktime=locktime)\n        transaction.outgoing_tx = True\n        for o in output_arr:\n            if isinstance(o, Output):\n                transaction.outputs.append(o)\n                amount_total_output += o.value\n            else:\n                value = value_to_satoshi(o[1], network=transaction.network)\n                amount_total_output += value\n                addr = o[0]\n                if isinstance(addr, WalletKey):\n                    addr = addr.key()\n                transaction.add_output(value, addr)\n\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        transaction.fee_per_kb = None\n        if isinstance(fee, int):\n            fee_estimate = fee\n        else:\n            n_blocks = 3\n            priority = ''\n            if isinstance(fee, str):\n                priority = fee\n            transaction.fee_per_kb = srv.estimatefee(blocks=n_blocks, priority=priority)\n            if not input_arr:\n                fee_estimate = int(transaction.estimate_size(number_of_change_outputs=number_of_change_outputs) /\n                                   1000.0 * transaction.fee_per_kb)\n            else:\n                fee_estimate = 0\n            if isinstance(fee, str):\n                fee = fee_estimate\n\n        # Add inputs\n        sequence = 0xffffffff\n        if 0 < transaction.locktime < 0xffffffff:\n            sequence = 0xfffffffe\n        amount_total_input = 0\n        if input_arr is None:\n            selected_utxos = self.select_inputs(amount_total_output + fee_estimate, transaction.network.dust_amount,\n                                                input_key_id, account_id, network, min_confirms, max_utxos, False)\n            if not selected_utxos:\n                raise WalletError(\"Not enough unspent transaction outputs found\")\n            for utxo in selected_utxos:\n                amount_total_input += utxo.value\n                inp_keys, key = self._objects_by_key_id(utxo.key_id)\n                multisig = False if isinstance(inp_keys, list) and len(inp_keys) < 2 else True\n                unlock_script_type = get_unlocking_script_type(utxo.script_type, self.witness_type, multisig=multisig)\n                transaction.add_input(utxo.transaction.txid, utxo.output_n, keys=inp_keys,\n                                      script_type=unlock_script_type, sigs_required=self.multisig_n_required,\n                                      sort=self.sort_keys, compressed=key.compressed, value=utxo.value,\n                                      address=utxo.key.address, sequence=sequence,\n                                      key_path=utxo.key.path, witness_type=self.witness_type)\n                # FIXME: Missing locktime_cltv=locktime_cltv, locktime_csv=locktime_csv (?)\n        else:\n            for inp in input_arr:\n                locktime_cltv = None\n                locktime_csv = None\n                unlocking_script_unsigned = None\n                unlocking_script_type = ''\n                if isinstance(inp, Input):\n                    prev_txid = inp.prev_txid\n                    output_n = inp.output_n\n                    key_id = None\n                    value = inp.value\n                    signatures = inp.signatures\n                    unlocking_script = inp.unlocking_script\n                    unlocking_script_unsigned = inp.unlocking_script_unsigned\n                    unlocking_script_type = inp.script_type\n                    address = inp.address\n                    sequence = inp.sequence\n                    locktime_cltv = inp.locktime_cltv\n                    locktime_csv = inp.locktime_csv\n                # elif isinstance(inp, DbTransactionOutput):\n                #     prev_txid = inp.transaction.txid\n                #     output_n = inp.output_n\n                #     key_id = inp.key_id\n                #     value = inp.value\n                #     signatures = None\n                #     # FIXME: This is probably not an unlocking_script\n                #     unlocking_script = inp.script\n                #     unlocking_script_type = get_unlocking_script_type(inp.script_type)\n                #     address = inp.key.address\n                else:\n                    prev_txid = inp[0]\n                    output_n = inp[1]\n                    key_id = None if len(inp) <= 2 else inp[2]\n                    value = 0 if len(inp) <= 3 else inp[3]\n                    signatures = None if len(inp) <= 4 else inp[4]\n                    unlocking_script = b'' if len(inp) <= 5 else inp[5]\n                    address = '' if len(inp) <= 6 else inp[6]\n                # Get key_ids, value from Db if not specified\n                if not (key_id and value and unlocking_script_type):\n                    if not isinstance(output_n, TYPE_INT):\n                        output_n = int.from_bytes(output_n, 'big')\n                    inp_utxo = self._session.query(DbTransactionOutput).join(DbTransaction). \\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransaction.txid == to_bytes(prev_txid),\n                               DbTransactionOutput.output_n == output_n).first()\n                    if inp_utxo:\n                        key_id = inp_utxo.key_id\n                        value = inp_utxo.value\n                        address = inp_utxo.key.address\n                        unlocking_script_type = get_unlocking_script_type(inp_utxo.script_type, multisig=self.multisig)\n                        # witness_type = inp_utxo.witness_type\n                    else:\n                        _logger.info(\"UTXO %s not found in this wallet. Please update UTXO's if this is not an \"\n                                     \"offline wallet\" % to_hexstring(prev_txid))\n                        key_id = self._session.query(DbKey.id).\\\n                            filter(DbKey.wallet_id == self.wallet_id, DbKey.address == address).scalar()\n                        if not key_id:\n                            raise WalletError(\"UTXO %s and key with address %s not found in this wallet\" % (\n                                to_hexstring(prev_txid), address))\n                        if not value:\n                            raise WalletError(\"Input value is zero for address %s. Import or update UTXO's first \"\n                                              \"or import transaction as dictionary\" % address)\n\n                amount_total_input += value\n                inp_keys, key = self._objects_by_key_id(key_id)\n                transaction.add_input(prev_txid, output_n, keys=inp_keys, script_type=unlocking_script_type,\n                                      sigs_required=self.multisig_n_required, sort=self.sort_keys,\n                                      compressed=key.compressed, value=value, signatures=signatures,\n                                      unlocking_script=unlocking_script, address=address,\n                                      unlocking_script_unsigned=unlocking_script_unsigned,\n                                      sequence=sequence, locktime_cltv=locktime_cltv, locktime_csv=locktime_csv,\n                                      witness_type=self.witness_type, key_path=key.path)\n        # Calculate fees\n        transaction.fee = fee\n        fee_per_output = None\n        transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)\n        if fee is None:\n            if not input_arr:\n                if not transaction.fee_per_kb:\n                    transaction.fee_per_kb = srv.estimatefee()\n                if transaction.fee_per_kb < transaction.network.fee_min:\n                    transaction.fee_per_kb = transaction.network.fee_min\n                transaction.fee = int((transaction.size / 1000.0) * transaction.fee_per_kb)\n                fee_per_output = int((50 / 1000.0) * transaction.fee_per_kb)\n            else:\n                if amount_total_output and amount_total_input:\n                    fee = False\n                else:\n                    transaction.fee = 0\n\n        if fee is False:\n            transaction.change = 0\n            transaction.fee = int(amount_total_input - amount_total_output)\n        else:\n            transaction.change = int(amount_total_input - (amount_total_output + transaction.fee))\n\n        # Skip change if amount is smaller than the dust limit or estimated fee\n        if (fee_per_output and transaction.change < fee_per_output) or transaction.change <= transaction.network.dust_amount:\n            transaction.fee += transaction.change\n            transaction.change = 0\n        if transaction.change < 0:\n            raise WalletError(\"Total amount of outputs is greater then total amount of inputs\")\n        if transaction.change:\n            min_output_value = transaction.network.dust_amount * 2 + transaction.network.fee_min * 4\n            if transaction.fee and transaction.size:\n                if not transaction.fee_per_kb:\n                    transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)\n                min_output_value = transaction.fee_per_kb + transaction.network.fee_min * 4 + \\\n                                   transaction.network.dust_amount\n\n            if number_of_change_outputs == 0:\n                if transaction.change < amount_total_output / 10 or transaction.change < min_output_value * 8:\n                    number_of_change_outputs = 1\n                elif transaction.change / 10 > amount_total_output:\n                    number_of_change_outputs = random.randint(2, 5)\n                else:\n                    number_of_change_outputs = random.randint(1, 3)\n                    # Prefer 1 and 2 as number of change outputs\n                    if number_of_change_outputs == 3:\n                        number_of_change_outputs = random.randint(3, 4)\n                transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)\n\n            average_change = transaction.change // number_of_change_outputs\n            if number_of_change_outputs > 1 and average_change < min_output_value:\n                raise WalletError(\"Not enough funds to create multiple change outputs. Try less change outputs \"\n                                  \"or lower fees\")\n\n            if self.scheme == 'single':\n                change_keys = [self.get_key(account_id=account_id, network=network, change=1)]\n            else:\n                change_keys = self.get_keys(account_id=account_id, network=network, change=1,\n                                            number_of_keys=number_of_change_outputs)\n\n            if number_of_change_outputs > 1:\n                rand_prop = transaction.change - number_of_change_outputs * min_output_value\n                change_amounts = list(((np.random.dirichlet(np.ones(number_of_change_outputs), size=1)[0] *\n                                        rand_prop) + min_output_value).astype(int))\n                # Fix rounding problems / small amount differences\n                diffs = transaction.change - sum(change_amounts)\n                for idx, co in enumerate(change_amounts):\n                    if co - diffs > min_output_value:\n                        change_amounts[idx] += change_amounts.index(co) + diffs\n                        break\n            else:\n                change_amounts = [transaction.change]\n\n            for idx, ck in enumerate(change_keys):\n                on = transaction.add_output(change_amounts[idx], ck.address, encoding=self.encoding)\n                transaction.outputs[on].key_id = ck.key_id\n\n        # Shuffle output order to increase privacy\n        if random_output_order:\n            transaction.shuffle()\n\n        # Check tx values\n        transaction.input_total = sum([i.value for i in transaction.inputs])\n        transaction.output_total = sum([o.value for o in transaction.outputs])\n        if transaction.input_total != transaction.fee + transaction.output_total:\n            raise WalletError(\"Sum of inputs values is not equal to sum of outputs values plus fees\")\n\n        transaction.txid = transaction.signature_hash()[::-1].hex()\n        if not transaction.fee_per_kb:\n            transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)\n        if transaction.fee_per_kb < transaction.network.fee_min:\n            raise WalletError(\"Fee per kB of %d is lower then minimal network fee of %d\" %\n                              (transaction.fee_per_kb, transaction.network.fee_min))\n        elif transaction.fee_per_kb > transaction.network.fee_max:\n            raise WalletError(\"Fee per kB of %d is higher then maximum network fee of %d\" %\n                              (transaction.fee_per_kb, transaction.network.fee_max))\n\n        return transaction\n\n    def transaction_import(self, t):\n        \"\"\"\n        Import a Transaction into this wallet. Link inputs to wallet keys if possible and return WalletTransaction\n        object. Only imports Transaction objects or dictionaries, use\n        :func:`transaction_import_raw` method to import a raw transaction.\n\n        :param t: A Transaction object or dictionary\n        :type t: Transaction, dict\n\n        :return WalletTransaction:\n\n        \"\"\"\n        if isinstance(t, Transaction):\n            rt = self.transaction_create(t.outputs, t.inputs, fee=t.fee, network=t.network.name,\n                                         random_output_order=False)\n            rt.block_height = t.block_height\n            rt.confirmations = t.confirmations\n            rt.witness_type = t.witness_type\n            rt.date = t.date\n            rt.txid = t.txid\n            rt.txhash = t.txhash\n            rt.locktime = t.locktime\n            rt.version = t.version\n            rt.version_int = t.version_int\n            rt.block_hash = t.block_hash\n            rt.rawtx = t.rawtx\n            rt.coinbase = t.coinbase\n            rt.flag = t.flag\n            rt.size = t.size\n            if not t.size:\n                rt.size = len(t.raw())\n            rt.vsize = t.vsize\n            if not t.vsize:\n                rt.vsize = rt.size\n            rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        elif isinstance(t, dict):\n            input_arr = []\n            for i in t['inputs']:\n                signatures = [bytes.fromhex(sig) for sig in i['signatures']]\n                script = b'' if 'script' not in i else i['script']\n                address = '' if 'address' not in i else i['address']\n                input_arr.append((i['prev_txid'], i['output_n'], None, int(i['value']), signatures, script,\n                                  address))\n            output_arr = []\n            for o in t['outputs']:\n                output_arr.append((o['address'], int(o['value'])))\n            rt = self.transaction_create(output_arr, input_arr, fee=t['fee'], network=t['network'],\n                                         random_output_order=False)\n            rt.block_height = t['block_height']\n            rt.confirmations = t['confirmations']\n            rt.witness_type = t['witness_type']\n            rt.date = t['date']\n            rt.txid = t['txid']\n            rt.txhash = t['txhash']\n            rt.locktime = t['locktime']\n            rt.version = t['version'].to_bytes(4, 'big')\n            rt.version_int = t['version']\n            rt.block_hash = t['block_hash']\n            rt.rawtx = t['raw']\n            rt.coinbase = t['coinbase']\n            rt.flag = t['flag']\n            rt.size = t['size']\n            if not t['size']:\n                rt.size = len(rt.raw())\n            rt.vsize = t['vsize']\n            if not rt.vsize:\n                rt.vsize = rt.size\n            rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        else:\n            raise WalletError(\"Import transaction must be of type Transaction or dict\")\n        rt.verify()\n        return rt\n\n    def transaction_import_raw(self, rawtx, network=None):\n        \"\"\"\n        Import a raw transaction. Link inputs to wallet keys if possible and return WalletTransaction object\n\n        :param rawtx: Raw transaction\n        :type rawtx: str, bytes\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletTransaction:\n        \"\"\"\n\n        if network is None:\n            network = self.network.name\n        if isinstance(rawtx, str):\n            rawtx = bytes.fromhex(rawtx)\n        t_import = Transaction.parse_bytes(rawtx, network=network)\n        rt = self.transaction_create(t_import.outputs, t_import.inputs, network=network, locktime=t_import.locktime,\n                                     random_output_order=False)\n        rt.version_int = t_import.version_int\n        rt.version = t_import.version\n        rt.verify()\n        rt.size = len(rawtx)\n        rt.calc_weight_units()\n        rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        return rt\n\n    def send(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,\n             min_confirms=1, priv_keys=None, max_utxos=None, locktime=0, offline=True, number_of_change_outputs=1):\n        \"\"\"\n        Create a new transaction with specified outputs and push it to the network.\n        Inputs can be specified but if not provided they will be selected from wallets utxo's\n        Output array is a list of 1 or more addresses and amounts.\n\n        Uses the :func:`transaction_create` method to create a new transaction, and uses a random service client to send the transaction.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.send([('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000)], offline=True)\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param output_arr: List of output tuples with address and amount. Must contain at least one item. Example: [('mxdLD8SAGS9fe2EeCXALDHcdTTbppMHp8N', 5000000)]. Address can be an address string, Address object, HDKey object or WalletKey object\n        :type output_arr: list\n        :param input_arr: List of inputs tuples with reference to a UTXO, a wallet key and value. The format is [(txid, output_n, key_id, value)]\n        :type input_arr: list\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param priv_keys: Specify extra private key if not available in this wallet\n        :type priv_keys: HDKey, list\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount\n        :type number_of_change_outputs: int\n\n        :return WalletTransaction:\n        \"\"\"\n\n        if input_arr and max_utxos and len(input_arr) > max_utxos:\n            raise WalletError(\"Input array contains %d UTXO's but max_utxos=%d parameter specified\" %\n                              (len(input_arr), max_utxos))\n\n        transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network, fee,\n                                              min_confirms, max_utxos, locktime, number_of_change_outputs)\n        transaction.sign(priv_keys)\n        # Calculate exact fees and update change output if necessary\n        if fee is None and transaction.fee_per_kb and transaction.change:\n            fee_exact = transaction.calculate_fee()\n            # Recreate transaction if fee estimation more than 10% off\n            if fee_exact != self.network.fee_min and fee_exact != self.network.fee_max and \\\n                    fee_exact and abs((float(transaction.fee) - float(fee_exact)) / float(fee_exact)) > 0.10:\n                _logger.info(\"Transaction fee not correctly estimated (est.: %d, real: %d). \"\n                             \"Recreate transaction with correct fee\" % (transaction.fee, fee_exact))\n                transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network,\n                                                      fee_exact, min_confirms, max_utxos, locktime,\n                                                      number_of_change_outputs)\n                transaction.sign(priv_keys)\n\n        transaction.rawtx = transaction.raw()\n        transaction.size = len(transaction.rawtx)\n        transaction.calc_weight_units()\n        transaction.fee_per_kb = int(float(transaction.fee) / float(transaction.vsize) * 1000)\n        transaction.txid = transaction.signature_hash()[::-1].hex()\n        transaction.send(offline)\n        return transaction\n\n    def send_to(self, to_address, amount, input_key_id=None, account_id=None, network=None, fee=None, min_confirms=1,\n                priv_keys=None, locktime=0, offline=True, number_of_change_outputs=1):\n        \"\"\"\n        Create transaction and send it with default Service objects :func:`services.sendrawtransaction` method.\n\n        Wrapper for wallet :func:`send` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.send_to('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000, offline=True)\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param to_address: Single output address as string Address object, HDKey object or WalletKey object\n        :type to_address: str, Address, HDKey, WalletKey\n        :param amount: Output is the smallest denominator for this network (ie: Satoshi's for Bitcoin), as Value object or value string as accepted by Value class\n        :type amount: int, str, Value\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID, default is last used\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param priv_keys: Specify extra private key if not available in this wallet\n        :type priv_keys: HDKey, list\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount\n        :type number_of_change_outputs: int\n\n        :return WalletTransaction:\n        \"\"\"\n\n        outputs = [(to_address, amount)]\n        return self.send(outputs, input_key_id=input_key_id, account_id=account_id, network=network, fee=fee,\n                         min_confirms=min_confirms, priv_keys=priv_keys, locktime=locktime, offline=offline,\n                         number_of_change_outputs=number_of_change_outputs)\n\n    def sweep(self, to_address, account_id=None, input_key_id=None, network=None, max_utxos=999, min_confirms=1,\n              fee_per_kb=None, fee=None, locktime=0, offline=True):\n        \"\"\"\n        Sweep all unspent transaction outputs (UTXO's) and send them to one or more output addresses.\n\n        Wrapper for the :func:`send` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.sweep('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb')\n        >>> t\n        <WalletTransaction(input_count=1, output_count=1, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb, type=p2pkh)>]\n\n        Output to multiple addresses\n\n        >>> to_list = [('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 100000), (w.get_key(), 0)]\n        >>> w.sweep(to_list)\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n\n        :param to_address: Single output address or list of outputs in format [(<adddress>, <amount>)]. If you specify a list of outputs, use amount value = 0 to indicate a change output\n        :type to_address: str, list\n        :param account_id: Wallet's account ID\n        :type account_id: int\n        :param input_key_id: Limit sweep to UTXO's with this key ID or list of key IDs\n        :type input_key_id: int, list\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param max_utxos: Limit maximum number of outputs to use. Default is 999\n        :type max_utxos: int\n        :param min_confirms: Minimal confirmations needed to include utxo\n        :type min_confirms: int\n        :param fee_per_kb: Fee per kilobyte transaction size, leave empty to get estimated fee costs from Service provider. This option is ignored when the 'fee' option is specified\n        :type fee_per_kb: int\n        :param fee: Total transaction fee in the smallest denominator (i.e. satoshis). Leave empty to get estimated fee from service providers. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n\n        :return WalletTransaction:\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n\n        utxos = self.utxos(account_id=account_id, network=network, min_confirms=min_confirms, key_id=input_key_id)\n        utxos = utxos[0:max_utxos]\n        input_arr = []\n        total_amount = 0\n        if not utxos:\n            raise WalletError(\"Cannot sweep wallet, no UTXO's found\")\n        for utxo in utxos:\n            # Skip dust transactions to avoid forced address reuse\n            if utxo['value'] <= self.network.dust_amount:\n                continue\n            input_arr.append((utxo['txid'], utxo['output_n'], utxo['key_id'], utxo['value']))\n            total_amount += utxo['value']\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n\n        if isinstance(fee, str):\n            n_outputs = 1 if not isinstance(to_address, list) else len(to_address)\n            fee_per_kb = srv.estimatefee(priority=fee)\n            tr_size = 125 + (len(input_arr) * (77 + self.multisig_n_required * 72)) + n_outputs * 30\n            fee = 100 + int((tr_size / 1000.0) * fee_per_kb)\n\n        if not fee:\n            if fee_per_kb is None:\n                fee_per_kb = srv.estimatefee()\n            tr_size = 125 + (len(input_arr) * 125)\n            fee = int((tr_size / 1000.0) * fee_per_kb)\n        if total_amount - fee <= self.network.dust_amount:\n            raise WalletError(\"Amount to send is smaller then dust amount: %s\" % (total_amount - fee))\n\n        if isinstance(to_address, str):\n            to_list = [(to_address, total_amount - fee)]\n        else:\n            to_list = []\n            for o in to_address:\n                if o[1] == 0:\n                    o_amount = total_amount - sum([x[1] for x in to_list]) - fee\n                    if o_amount > 0:\n                        to_list.append((o[0], o_amount))\n                else:\n                    to_list.append(o)\n\n        if sum(x[1] for x in to_list) + fee != total_amount:\n            raise WalletError(\"Total amount of outputs does not match total input amount. If you specify a list of \"\n                              \"outputs, use amount value = 0 to indicate a change/rest output\")\n\n        return self.send(to_list, input_arr, network=network, fee=fee, min_confirms=min_confirms, locktime=locktime,\n                         offline=offline)\n\n    def wif(self, is_private=False, account_id=0):\n        \"\"\"\n        Return Wallet Import Format string for master private or public key which can be used to import key and\n        recreate wallet in other software.\n\n        A list of keys will be exported for a multisig wallet.\n\n        :param is_private: Export public or private key, default is False\n        :type is_private: bool\n        :param account_id: Account ID of key to export\n        :type account_id: bool\n\n        :return list, str:\n        \"\"\"\n        if not self.multisig or not self.cosigner:\n            if is_private and self.main_key:\n                return self.main_key.wif\n            else:\n                return self.public_master(account_id=account_id).key().\\\n                    wif(is_private=is_private, witness_type=self.witness_type, multisig=self.multisig)\n        else:\n            wiflist = []\n            for cs in self.cosigner:\n                wiflist.append(cs.wif(is_private=is_private))\n            return wiflist\n\n    def public_master(self, account_id=None, name=None, as_private=False, network=None):\n        \"\"\"\n        Return public master key(s) for this wallet. Use to import in other wallets to sign transactions or create keys.\n\n        For a multisig wallet all public master keys are return as list.\n\n        Returns private key information if available and as_private is True is specified\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.public_master().wif\n        'xpub6D2qEr8Z8WYKKns2xZYyyvvRviPh1NKt1kfHwwfiTxJwj7peReEJt3iXoWWsr8tXWTsejDjMfAezM53KVFVkSZzA5i2pNy3otprtYUvh4u1'\n\n        :param account_id: Account ID of key to export\n        :type account_id: int\n        :param name: Optional name for account key\n        :type name: str\n        :param as_private: Export public or private key, default is False\n        :type as_private: bool\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return list of WalletKey, WalletKey:\n        \"\"\"\n        if self.main_key and self.main_key.key_type == 'single':\n            key = self.main_key\n            return key if as_private else key.public()\n        elif not self.cosigner:\n            depth = -self.key_depth + self.depth_public_master\n            key = self.key_for_path([], depth, name=name, account_id=account_id, network=network,\n                                    cosigner_id=self.cosigner_id)\n            return key if as_private else key.public()\n        else:\n            pm_list = []\n            for cs in self.cosigner:\n                pm_list.append(cs.public_master(account_id, name, as_private, network))\n            return pm_list\n\n    def transaction_load(self, txid=None, filename=None):\n        \"\"\"\n        Load transaction object from file which has been stored with the :func:`Transaction.save` method.\n\n        Specify transaction ID or filename.\n\n        :param txid: Transaction ID. Transaction object will be read from .bitcoinlib datadir\n        :type txid: str\n        :param filename: Name of transaction object file\n        :type filename: str\n\n        :return Transaction:\n        \"\"\"\n        if not filename and not txid:\n            raise WalletError(\"Please supply filename or txid\")\n        elif not filename and txid:\n            p = Path(BCL_DATA_DIR, '%s.tx' % txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('rb')\n        t = pickle.load(f)\n        f.close()\n        return self.transaction_import(t)\n\n    def info(self, detail=3):\n        \"\"\"\n        Prints wallet information to standard output\n\n        :param detail: Level of detail to show. Specify a number between 0 and 5, with 0 low detail and 5 highest detail\n        :type detail: int\n        \"\"\"\n\n        print(\"=== WALLET ===\")\n        print(\" ID                             %s\" % self.wallet_id)\n        print(\" Name                           %s\" % self.name)\n        print(\" Owner                          %s\" % self.owner)\n        print(\" Scheme                         %s\" % self.scheme)\n        print(\" Multisig                       %s\" % self.multisig)\n        if self.multisig:\n            print(\" Multisig Wallet IDs            %s\" % str([w.wallet_id for w in self.cosigner]).strip('[]'))\n            print(\" Cosigner ID                    %s\" % self.cosigner_id)\n        print(\" Witness type                   %s\" % self.witness_type)\n        print(\" Main network                   %s\" % self.network.name)\n        print(\" Latest update                  %s\" % self.last_updated)\n\n        if self.multisig:\n            print(\"\\n= Multisig Public Master Keys =\")\n            for cs in self.cosigner:\n                print(\"%5s %3s %-70s %-6s %-8s %s\" %\n                      (cs.cosigner_id, cs.main_key.key_id, cs.wif(is_private=False), cs.scheme,\n                       \"main\" if cs.main_key.is_private else \"cosigner\",\n                       '*' if cs.cosigner_id == self.cosigner_id else ''))\n\n            print(\"For main keys a private master key is available in this wallet to sign transactions. \"\n                  \"* cosigner key for this wallet\")\n\n        if detail and self.main_key:\n            print(\"\\n= Wallet Master Key =\")\n            print(\" ID                             %s\" % self.main_key_id)\n            print(\" Private                        %s\" % self.main_key.is_private)\n            print(\" Depth                          %s\" % self.main_key.depth)\n\n        balances = self._balance_update()\n        if detail > 1:\n            for nw in self.networks():\n                print(\"\\n- NETWORK: %s -\" % nw.name)\n                print(\"- - Keys\")\n                if detail < 4:\n                    ds = [self.key_depth]\n                elif detail < 5:\n                    if self.purpose == 45:\n                        ds = [0, self.key_depth]\n                    else:\n                        ds = [0, self.depth_public_master, self.key_depth]\n                else:\n                    ds = range(8)\n                for d in ds:\n                    is_active = True\n                    if detail > 3:\n                        is_active = False\n                    for key in self.keys(depth=d, network=nw.name, is_active=is_active):\n                        print(\"%5s %-28s %-45s %-25s %25s\" %\n                              (key.id, key.path, key.address, key.name,\n                               Value.from_satoshi(key.balance, network=nw).str_unit(currency_repr='symbol')))\n\n                if detail > 2:\n                    include_new = False\n                    if detail > 3:\n                        include_new = True\n                    accounts = self.accounts(network=nw.name)\n                    if not accounts:\n                        accounts = [0]\n                    for account_id in accounts:\n                        txs = self.transactions(include_new=include_new, account_id=account_id, network=nw.name,\n                                                as_dict=True)\n                        print(\"\\n- - Transactions Account %d (%d)\" % (account_id, len(txs)))\n                        for tx in txs:\n                            spent = \" \"\n                            address = tx['address']\n                            if not tx['address']:\n                                address = 'nulldata'\n                            elif 'spent' in tx and tx['spent'] is False:\n                                spent = \"U\"\n                            status = \"\"\n                            if tx['status'] not in ['confirmed', 'unconfirmed']:\n                                status = tx['status']\n                            print(\"%64s %43s %8d %21s %s %s\" % (tx['txid'], address, tx['confirmations'],\n                                                                Value.from_satoshi(tx['value'], network=nw).str_unit(\n                                                                    currency_repr='symbol'),\n                                                                spent, status))\n\n        print(\"\\n= Balance Totals (includes unconfirmed) =\")\n        for na_balance in balances:\n            print(\"%-20s %-20s %20s\" % (na_balance['network'], \"(Account %s)\" % na_balance['account_id'],\n                                        Value.from_satoshi(na_balance['balance'], network=na_balance['network']).\n                                        str_unit(currency_repr='symbol')))\n        print(\"\\n\")\n\n    def as_dict(self, include_private=False):\n        \"\"\"\n        Return wallet information in dictionary format\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return dict:\n        \"\"\"\n\n        keys = []\n        transactions = []\n        for netw in self.networks():\n            for key in self.keys(network=netw.name, include_private=include_private, as_dict=True):\n                keys.append(key)\n\n            if self.multisig:\n                for t in self.transactions(include_new=True, account_id=0, network=netw.name):\n                    transactions.append(t.as_dict())\n            else:\n                accounts = self.accounts(network=netw.name)\n                if not accounts:\n                    accounts = [0]\n                for account_id in accounts:\n                    for t in self.transactions(include_new=True, account_id=account_id, network=netw.name):\n                        transactions.append(t.as_dict())\n\n        return {\n            'wallet_id': self.wallet_id,\n            'name': self.name,\n            'owner': self._owner,\n            'scheme': self.scheme,\n            'witness_type': self.witness_type,\n            'main_network': self.network.name,\n            'main_balance': self.balance(),\n            'main_balance_str': self.balance(as_string=True),\n            'balances': self._balances,\n            'default_account_id': self.default_account_id,\n            'multisig_n_required': self.multisig_n_required,\n            'cosigner_wallet_ids': [w.wallet_id for w in self.cosigner],\n            'cosigner_public_masters': [w.public_master().key().wif() for w in self.cosigner],\n            'sort_keys': self.sort_keys,\n            'main_key_id': self.main_key_id,\n            'encoding': self.encoding,\n            'keys': keys,\n            'transactions': transactions,\n        }\n\n    def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in JSON\n        :type include_private: bool\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict(include_private=include_private)\n        return json.dumps(adict, indent=4, default=str)",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def from_key(name, wallet_id, session, key, account_id=0, network=None, change=0, purpose=44, parent_id=0,\n                 path='m', key_type=None, encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False,\n                 cosigner_id=None):\n        \"\"\"\n        Create WalletKey from a HDKey object or key.\n\n        Normally you don't need to call this method directly. Key creation is handled by the Wallet class.\n\n        >>> w = wallet_create_or_open('hdwalletkey_test')\n        >>> wif = 'xprv9s21ZrQH143K2mcs9jcK4EjALbu2z1N9qsMTUG1frmnXM3NNCSGR57yLhwTccfNCwdSQEDftgjCGm96P29wGGcbBsPqZH85iqpoHA7LrqVy'\n        >>> wk = WalletKey.from_key('import_key', w.wallet_id, w._session, wif)\n        >>> wk.address\n        '1MwVEhGq6gg1eeSrEdZom5bHyPqXtJSnPg'\n        >>> wk # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=import_key, wif=xprv9s21ZrQH143K2mcs9jcK4EjALbu2z1N9qsMTUG1frmnXM3NNCSGR57yLhwTccfNCwdSQEDftgjCGm96P29wGGcbBsPqZH85iqpoHA7LrqVy, path=m)>\n\n        :param name: New key name\n        :type name: str\n        :param wallet_id: ID of wallet where to store key\n        :type wallet_id: int\n        :param session: Required Sqlalchemy Session object\n        :type session: sqlalchemy.orm.session.Session\n        :param key: Optional key in any format accepted by the HDKey class\n        :type key: str, int, byte, HDKey\n        :param account_id: Account ID for specified key, default is 0\n        :type account_id: int\n        :param network: Network of specified key\n        :type network: str\n        :param change: Use 0 for normal key, and 1 for change key (for returned payments)\n        :type change: int\n        :param purpose: BIP0044 purpose field, default is 44\n        :type purpose: int\n        :param parent_id: Key ID of parent, default is 0 (no parent)\n        :type parent_id: int\n        :param path: BIP0044 path of given key, default is 'm' (masterkey)\n        :type path: str\n        :param key_type: Type of key, single or BIP44 type\n        :type key_type: str\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58\n        :type encoding: str\n        :param witness_type: Witness type used when creating transaction script: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used for create keys and key representations such as WIF and addreses\n        :type multisig: bool\n        :param cosigner_id: Set this if you would like to create keys for other cosigners.\n        :type cosigner_id: int\n\n        :return WalletKey: WalletKey object\n        \"\"\"\n\n        key_is_address = False\n        if isinstance(key, HDKey):\n            k = key\n            if network is None:\n                network = k.network.name\n            elif network != k.network.name:\n                raise WalletError(\"Specified network and key network should be the same\")\n        elif isinstance(key, Address):\n            k = key\n            key_is_address = True\n            if network is None:\n                network = k.network.name\n            elif network != k.network.name:\n                raise WalletError(\"Specified network and key network should be the same\")\n        else:\n            if network is None:\n                network = DEFAULT_NETWORK\n            k = HDKey(import_key=key, network=network)\n        if not encoding and witness_type:\n            encoding = get_encoding_from_witness(witness_type)\n        script_type = script_type_default(witness_type, multisig)\n\n        if not key_is_address:\n            keyexists = session.query(DbKey).\\\n                filter(DbKey.wallet_id == wallet_id,\n                       DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=True)).first()\n            if keyexists:\n                _logger.warning(\"Key already exists in this wallet. Key ID: %d\" % keyexists.id)\n                return WalletKey(keyexists.id, session, k)\n\n            if key_type != 'single' and k.depth != len(path.split('/'))-1:\n                if path == 'm' and k.depth > 1:\n                    path = \"M\"\n\n            address = k.address(encoding=encoding, script_type=script_type)\n            wk = session.query(DbKey).filter(\n                DbKey.wallet_id == wallet_id,\n                or_(DbKey.public == k.public_byte,\n                    DbKey.wif == k.wif(witness_type=witness_type, multisig=multisig, is_private=False),\n                    DbKey.address == address)).first()\n            if wk:\n                wk.wif = k.wif(witness_type=witness_type, multisig=multisig, is_private=True)\n                wk.is_private = True\n                wk.private = k.private_byte\n                wk.public = k.public_byte\n                wk.path = path\n                session.commit()\n                return WalletKey(wk.id, session, k)\n\n            nk = DbKey(name=name[:80], wallet_id=wallet_id, public=k.public_byte, private=k.private_byte, purpose=purpose,\n                       account_id=account_id, depth=k.depth, change=change, address_index=k.child_index,\n                       wif=k.wif(witness_type=witness_type, multisig=multisig, is_private=True), address=address,\n                       parent_id=parent_id, compressed=k.compressed, is_private=k.is_private, path=path,\n                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)\n        else:\n            keyexists = session.query(DbKey).\\\n                filter(DbKey.wallet_id == wallet_id,\n                       DbKey.address == k.address).first()\n            if keyexists:\n                _logger.warning(\"Key with ID %s already exists\" % keyexists.id)\n                return WalletKey(keyexists.id, session, k)\n            nk = DbKey(name=name[:80], wallet_id=wallet_id, purpose=purpose,\n                       account_id=account_id, depth=k.depth, change=change, address=k.address,\n                       parent_id=parent_id, compressed=k.compressed, is_private=False, path=path,\n                       key_type=key_type, network_name=network, encoding=encoding, cosigner_id=cosigner_id)\n\n        session.merge(DbNetwork(name=network))\n        session.add(nk)\n        session.commit()\n        return WalletKey(nk.id, session, k)",
  "def _commit(self):\n        try:\n            self._session.commit()\n        except Exception:\n            self._session.rollback()\n            raise",
  "def __init__(self, key_id, session, hdkey_object=None):\n        \"\"\"\n        Initialize WalletKey with specified ID, get information from database.\n\n        :param key_id: ID of key as mentioned in database\n        :type key_id: int\n        :param session: Required Sqlalchemy Session object\n        :type session: sqlalchemy.orm.session.Session\n        :param hdkey_object: Optional HDKey object. Specify HDKey object if available for performance\n        :type hdkey_object: HDKey\n\n        \"\"\"\n\n        self._session = session\n        wk = session.query(DbKey).filter_by(id=key_id).first()\n        if wk:\n            self._dbkey = wk\n            self._hdkey_object = hdkey_object\n            if hdkey_object and isinstance(hdkey_object, HDKey):\n                assert(not wk.public or wk.public == hdkey_object.public_byte)\n                assert(not wk.private or wk.private == hdkey_object.private_byte)\n                self._hdkey_object = hdkey_object\n            self.key_id = key_id\n            self._name = wk.name\n            self.wallet_id = wk.wallet_id\n            self.key_public = None if not wk.public else wk.public\n            self.key_private = None if not wk.private else wk.private\n            self.account_id = wk.account_id\n            self.change = wk.change\n            self.address_index = wk.address_index\n            self.wif = wk.wif\n            self.address = wk.address\n            self._balance = wk.balance\n            self.purpose = wk.purpose\n            self.parent_id = wk.parent_id\n            self.is_private = wk.is_private\n            self.path = wk.path\n            self.wallet = wk.wallet\n            self.network_name = wk.network_name\n            if not self.network_name:\n                self.network_name = wk.wallet.network_name\n            self.network = Network(self.network_name)\n            self.depth = wk.depth\n            self.key_type = wk.key_type\n            self.compressed = wk.compressed\n            self.encoding = wk.encoding\n            self.cosigner_id = wk.cosigner_id\n            self.used = wk.used\n        else:\n            raise WalletError(\"Key with id %s not found\" % key_id)",
  "def __repr__(self):\n        return \"<WalletKey(key_id=%d, name=%s, wif=%s, path=%s)>\" % (self.key_id, self.name, self.wif, self.path)",
  "def name(self):\n        \"\"\"\n        Return name of wallet key\n\n        :return str:\n        \"\"\"\n        return self._name",
  "def name(self, value):\n        \"\"\"\n        Set key name, update in database\n\n        :param value: Name for this key\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        self._name = value\n        self._dbkey.name = value\n        self._commit()",
  "def key(self):\n        \"\"\"\n        Get HDKey object for current WalletKey\n\n        :return HDKey:\n        \"\"\"\n\n        self._hdkey_object = None\n        if self.key_type == 'multisig':\n            self._hdkey_object = []\n            for kc in self._dbkey.multisig_children:\n                self._hdkey_object.append(HDKey.from_wif(kc.child_key.wif, network=kc.child_key.network_name, compressed=self.compressed))\n        if self._hdkey_object is None and self.wif:\n            self._hdkey_object = HDKey.from_wif(self.wif, network=self.network_name, compressed=self.compressed)\n        return self._hdkey_object",
  "def balance(self, as_string=False):\n        \"\"\"\n        Get total value of unspent outputs\n\n        :param as_string: Specify 'string' to return a string in currency format\n        :type as_string: bool\n\n        :return float, str: Key balance\n        \"\"\"\n\n        if as_string:\n            return Value.from_satoshi(self._balance, network=self.network).str_unit()\n        else:\n            return self._balance",
  "def public(self):\n        \"\"\"\n        Return current key as public WalletKey object with all private information removed\n\n        :return WalletKey:\n        \"\"\"\n        pub_key = self\n        pub_key.is_private = False\n        pub_key.key_private = None\n        if self.key():\n            pub_key.wif = self.key().wif()\n        if self._hdkey_object:\n            self._hdkey_object = pub_key._hdkey_object.public()\n        self._dbkey = None\n        return pub_key",
  "def as_dict(self, include_private=False):\n        \"\"\"\n        Return current key information as dictionary\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        \"\"\"\n\n        kdict = {\n            'id': self.key_id,\n            'key_type': self.key_type,\n            'network': self.network.name,\n            'is_private': self.is_private,\n            'name': self.name,\n            'key_public': '' if not self.key_public else self.key_public.hex(),\n            'account_id':  self.account_id,\n            'parent_id': self.parent_id,\n            'depth': self.depth,\n            'change': self.change,\n            'address_index': self.address_index,\n            'address': self.address,\n            'encoding': self.encoding,\n            'path': self.path,\n            'balance': self.balance(),\n            'balance_str': self.balance(as_string=True)\n        }\n        if include_private:\n            kdict.update({\n                'key_private': self.key_private.hex(),\n                'wif': self.wif,\n            })\n        return kdict",
  "def __init__(self, hdwallet, account_id=None, *args, **kwargs):\n        \"\"\"\n        Initialize WalletTransaction object with reference to a Wallet object\n\n        :param hdwallet: Wallet object, wallet name or ID\n        :type hdWallet: HDwallet, str, int\n        :param account_id: Account ID\n        :type account_id: int\n        :param args: Arguments for HDWallet parent class\n        :type args: args\n        :param kwargs: Keyword arguments for Wallet parent class\n        :type kwargs: kwargs\n        \"\"\"\n\n        assert isinstance(hdwallet, Wallet)\n        self.hdwallet = hdwallet\n        self.pushed = False\n        self.error = None\n        self.response_dict = None\n        self.account_id = account_id\n        if not account_id:\n            self.account_id = self.hdwallet.default_account_id\n        witness_type = 'legacy'\n        if hdwallet.witness_type in ['segwit', 'p2sh-segwit']:\n            witness_type = 'segwit'\n        Transaction.__init__(self, witness_type=witness_type, *args, **kwargs)\n        addresslist = hdwallet.addresslist()\n        self.outgoing_tx = bool([i.address for i in self.inputs if i.address in addresslist])\n        self.incoming_tx = bool([o.address for o in self.outputs if o.address in addresslist])",
  "def __repr__(self):\n        return \"<WalletTransaction(input_count=%d, output_count=%d, status=%s, network=%s)>\" % \\\n               (len(self.inputs), len(self.outputs), self.status, self.network.name)",
  "def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        self_dict = self.__dict__\n        for k, v in self_dict.items():\n            if k != 'hdwallet':\n                setattr(result, k, deepcopy(v, memo))\n        result.hdwallet = self.hdwallet\n        return result",
  "def from_transaction(cls, hdwallet, t):\n        \"\"\"\n        Create WalletTransaction object from Transaction object\n\n        :param hdwallet: Wallet object, wallet name or ID\n        :type hdwallet: HDwallet, str, int\n        :param t: Specify Transaction object\n        :type t: Transaction\n\n        :return WalletClass:\n        \"\"\"\n        return cls(hdwallet=hdwallet, inputs=t.inputs, outputs=t.outputs, locktime=t.locktime, version=t.version,\n                   network=t.network.name, fee=t.fee, fee_per_kb=t.fee_per_kb, size=t.size, txid=t.txid,\n                   txhash=t.txhash, date=t.date, confirmations=t.confirmations, block_height=t.block_height,\n                   block_hash=t.block_hash, input_total=t.input_total, output_total=t.output_total,\n                   rawtx=t.rawtx, status=t.status, coinbase=t.coinbase, verified=t.verified, flag=t.flag)",
  "def from_txid(cls, hdwallet, txid):\n        \"\"\"\n        Read single transaction from database with given transaction ID / transaction hash\n\n        :param hdwallet: Wallet object\n        :type hdwallet: Wallet\n        :param txid: Transaction hash as hexadecimal string\n        :type txid: str, bytes\n\n        :return WalletClass:\n\n        \"\"\"\n        sess = hdwallet._session\n        # If txid is unknown add it to database, else update\n        db_tx_query = sess.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == hdwallet.wallet_id, DbTransaction.txid == to_bytes(txid))\n        db_tx = db_tx_query.scalar()\n        if not db_tx:\n            return\n\n        fee_per_kb = None\n        if db_tx.fee and db_tx.size:\n            fee_per_kb = int((db_tx.fee / db_tx.size) * 1000)\n        network = Network(db_tx.network_name)\n\n        inputs = []\n        for inp in db_tx.inputs:\n            sequence = 0xffffffff\n            if inp.sequence:\n                sequence = inp.sequence\n            inp_keys = []\n            if inp.key_id:\n                key = hdwallet.key(inp.key_id)\n                if key.key_type == 'multisig':\n                    db_key = sess.query(DbKey).filter_by(id=key.key_id).scalar()\n                    for ck in db_key.multisig_children:\n                        inp_keys.append(ck.child_key.public.hex())\n                else:\n                    inp_keys = key.key()\n\n            inputs.append(Input(\n                prev_txid=inp.prev_txid, output_n=inp.output_n, keys=inp_keys, unlocking_script=inp.script,\n                script_type=inp.script_type, sequence=sequence, index_n=inp.index_n, value=inp.value,\n                double_spend=inp.double_spend, witness_type=inp.witness_type, network=network, address=inp.address,\n                witnesses=inp.witnesses))\n\n        outputs = []\n        for out in db_tx.outputs:\n            address = ''\n            public_key = b''\n            if out.key_id:\n                key = hdwallet.key(out.key_id)\n                address = key.address\n                if key.key_type != 'multisig':\n                    if key.key() and not isinstance(key.key(), Address):\n                        public_key = key.key().public_hex\n            outputs.append(Output(value=out.value, address=address, public_key=public_key,\n                                  lock_script=out.script, spent=out.spent, output_n=out.output_n,\n                                  script_type=out.script_type, network=network))\n\n        return cls(hdwallet=hdwallet, inputs=inputs, outputs=outputs, locktime=db_tx.locktime,\n                   version=db_tx.version, network=network, fee=db_tx.fee, fee_per_kb=fee_per_kb,\n                   size=db_tx.size, txid=to_hexstring(txid), date=db_tx.date, confirmations=db_tx.confirmations,\n                   block_height=db_tx.block_height, input_total=db_tx.input_total, output_total=db_tx.output_total,\n                   rawtx=db_tx.raw, status=db_tx.status, coinbase=db_tx.coinbase,\n                   verified=db_tx.verified)",
  "def to_transaction(self):\n        return Transaction(self.inputs, self.outputs, self.locktime, self.version,\n                           self.network.name, self.fee, self.fee_per_kb, self.size,\n                           self.txid, self.txhash, self.date, self.confirmations,\n                           self.block_height, self.block_hash, self.input_total,\n                           self.output_total, self.rawtx, self.status, self.coinbase,\n                           self.verified, self.witness_type, self.flag)",
  "def sign(self, keys=None, index_n=0, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=False,\n             replace_signatures=False):\n        \"\"\"\n        Sign this transaction. Use existing keys from wallet or use keys argument for extra keys.\n\n        :param keys: Extra private keys to sign the transaction\n        :type keys: HDKey, str\n        :param index_n: Transaction index_n to sign\n        :type index_n: int\n        :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked\n        :type multisig_key_n: int\n        :param hash_type: Hashtype to use, default is SIGHASH_ALL\n        :type hash_type: int\n        :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list\n        :type fail_on_unknown_key: bool\n        :param replace_signatures: Replace signature with new one if already signed.\n        :type replace_signatures: bool\n\n        :return None:\n        \"\"\"\n        priv_key_list_arg = []\n        if keys:\n            key_paths = list(dict.fromkeys([ti.key_path for ti in self.inputs if ti.key_path[0] == 'm']))\n            if not isinstance(keys, list):\n                keys = [keys]\n            for priv_key in keys:\n                if not isinstance(priv_key, HDKey):\n                    if isinstance(priv_key, str) and len(str(priv_key).split(' ')) > 4:\n                        priv_key = HDKey.from_passphrase(priv_key, network=self.network)\n                    else:\n                        priv_key = HDKey(priv_key, network=self.network.name)\n                priv_key_list_arg.append((None, priv_key))\n                if key_paths and priv_key.depth == 0 and priv_key.key_type != \"single\":\n                    for key_path in key_paths:\n                        priv_key_list_arg.append((key_path, priv_key.subkey_for_path(key_path)))\n        for ti in self.inputs:\n            priv_key_list = []\n            for (key_path, priv_key) in priv_key_list_arg:\n                if (not key_path or key_path == ti.key_path) and priv_key not in priv_key_list:\n                    priv_key_list.append(priv_key)\n            priv_key_list += [k for k in ti.keys if k.is_private]\n            Transaction.sign(self, priv_key_list, ti.index_n, multisig_key_n, hash_type, fail_on_unknown_key,\n                             replace_signatures)\n        self.verify()\n        self.error = \"\"",
  "def send(self, offline=False):\n        \"\"\"\n        Verify and push transaction to network. Update UTXO's in database after successful send\n\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is False\n        :type offline: bool\n\n        :return None:\n\n        \"\"\"\n\n        self.error = None\n        if not self.verified and not self.verify():\n            self.error = \"Cannot verify transaction\"\n            return None\n\n        if offline:\n            return None\n\n        srv = Service(network=self.network.name, providers=self.hdwallet.providers,\n                      cache_uri=self.hdwallet.db_cache_uri)\n        res = srv.sendrawtransaction(self.raw_hex())\n        if not res:\n            self.error = \"Cannot send transaction. %s\" % srv.errors\n            return None\n        if 'txid' in res:\n            _logger.info(\"Successfully pushed transaction, result: %s\" % res)\n            self.txid = res['txid']\n            self.status = 'unconfirmed'\n            self.confirmations = 0\n            self.pushed = True\n            self.response_dict = srv.results\n            self.store()\n\n            # Update db: Update spent UTXO's, add transaction to database\n            for inp in self.inputs:\n                txid = inp.prev_txid\n                utxos = self.hdwallet._session.query(DbTransactionOutput).join(DbTransaction).\\\n                    filter(DbTransaction.txid == txid,\n                           DbTransactionOutput.output_n == inp.output_n_int,\n                           DbTransactionOutput.spent.is_(False)).all()\n                for u in utxos:\n                    u.spent = True\n\n            self.hdwallet._commit()\n            self.hdwallet._balance_update(network=self.network.name)\n            return None\n        self.error = \"Transaction not send, unknown response from service providers\"",
  "def store(self):\n        \"\"\"\n        Store this transaction to database\n\n        :return int: Transaction index number\n        \"\"\"\n\n        sess = self.hdwallet._session\n        # If txid is unknown add it to database, else update\n        db_tx_query = sess.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.hdwallet.wallet_id, DbTransaction.txid == bytes.fromhex(self.txid))\n        db_tx = db_tx_query.scalar()\n        if not db_tx:\n            db_tx_query = sess.query(DbTransaction). \\\n                filter(DbTransaction.wallet_id.is_(None), DbTransaction.txid == bytes.fromhex(self.txid))\n            db_tx = db_tx_query.first()\n            if db_tx:\n                db_tx.wallet_id = self.hdwallet.wallet_id\n\n        if not db_tx:\n            new_tx = DbTransaction(\n                wallet_id=self.hdwallet.wallet_id, txid=bytes.fromhex(self.txid), block_height=self.block_height,\n                size=self.size, confirmations=self.confirmations, date=self.date, fee=self.fee, status=self.status,\n                input_total=self.input_total, output_total=self.output_total, network_name=self.network.name,\n                raw=self.rawtx, verified=self.verified, account_id=self.account_id)\n            sess.add(new_tx)\n            self.hdwallet._commit()\n            txidn = new_tx.id\n        else:\n            txidn = db_tx.id\n            db_tx.block_height = self.block_height if self.block_height else db_tx.block_height\n            db_tx.confirmations = self.confirmations if self.confirmations else db_tx.confirmations\n            db_tx.date = self.date if self.date else db_tx.date\n            db_tx.fee = self.fee if self.fee else db_tx.fee\n            db_tx.status = self.status if self.status else db_tx.status\n            db_tx.input_total = self.input_total if self.input_total else db_tx.input_total\n            db_tx.output_total = self.output_total if self.output_total else db_tx.output_total\n            db_tx.network_name = self.network.name if self.network.name else db_tx.name\n            db_tx.raw = self.rawtx if self.rawtx else db_tx.raw\n            db_tx.verified = self.verified\n            self.hdwallet._commit()\n\n        assert txidn\n        for ti in self.inputs:\n            tx_key = sess.query(DbKey).filter_by(wallet_id=self.hdwallet.wallet_id, address=ti.address).scalar()\n            key_id = None\n            if tx_key:\n                key_id = tx_key.id\n                tx_key.used = True\n            tx_input = sess.query(DbTransactionInput). \\\n                filter_by(transaction_id=txidn, index_n=ti.index_n).scalar()\n            if not tx_input:\n                witnesses = int_to_varbyteint(len(ti.witnesses)) + b''.join([bytes(varstr(w)) for w in ti.witnesses])\n                new_tx_item = DbTransactionInput(\n                    transaction_id=txidn, output_n=ti.output_n_int, key_id=key_id, value=ti.value,\n                    prev_txid=ti.prev_txid, index_n=ti.index_n, double_spend=ti.double_spend,\n                    script=ti.unlocking_script, script_type=ti.script_type, witness_type=ti.witness_type,\n                    sequence=ti.sequence, address=ti.address, witnesses=witnesses)\n                sess.add(new_tx_item)\n            elif key_id:\n                tx_input.key_id = key_id\n                if ti.value:\n                    tx_input.value = ti.value\n                if ti.prev_txid:\n                    tx_input.prev_txid = ti.prev_txid\n                if ti.unlocking_script:\n                    tx_input.script = ti.unlocking_script\n\n            self.hdwallet._commit()\n        for to in self.outputs:\n            tx_key = sess.query(DbKey).\\\n                filter_by(wallet_id=self.hdwallet.wallet_id, address=to.address).scalar()\n            key_id = None\n            if tx_key:\n                key_id = tx_key.id\n                tx_key.used = True\n            spent = to.spent\n            tx_output = sess.query(DbTransactionOutput). \\\n                filter_by(transaction_id=txidn, output_n=to.output_n).scalar()\n            if not tx_output:\n                new_tx_item = DbTransactionOutput(\n                    transaction_id=txidn, output_n=to.output_n, key_id=key_id, address=to.address, value=to.value,\n                    spent=spent, script=to.lock_script, script_type=to.script_type)\n                sess.add(new_tx_item)\n            elif key_id:\n                tx_output.key_id = key_id\n                tx_output.spent = spent if spent is not None else tx_output.spent\n            self.hdwallet._commit()\n        return txidn",
  "def info(self):\n        \"\"\"\n        Print Wallet transaction information to standard output. Include send information.\n        \"\"\"\n\n        Transaction.info(self)\n        print(\"Pushed to network: %s\" % self.pushed)\n        print(\"Wallet: %s\" % self.hdwallet.name)\n        if self.error:\n            print(\"Errors: %s\" % self.error)\n        print(\"\\n\")",
  "def export(self, skip_change=True):\n        \"\"\"\n        Export this transaction as list of tuples in the following format:\n            (transaction_date, transaction_hash, in/out, addresses_in, addresses_out, value, fee)\n\n        A transaction with multiple inputs or outputs results in multiple tuples.\n\n        :param skip_change: Do not include outputs to own wallet (default). Please note: So if this is set to True, then an internal transfer is not exported.\n        :type skip_change: boolean\n\n        :return list of tuple:\n        \"\"\"\n        mut_list = []\n        wlt_addresslist = self.hdwallet.addresslist()\n        input_addresslist = [i.address for i in self.inputs]\n        if self.outgoing_tx:\n            fee_per_output = self.fee / len(self.outputs)\n            for o in self.outputs:\n                o_value = -o.value\n                if o.address in wlt_addresslist:\n                    if skip_change:\n                        continue\n                    elif self.incoming_tx:\n                        o_value = 0\n                mut_list.append((self.date, self.txid, 'out', input_addresslist, o.address, o_value, fee_per_output))\n        else:\n            for o in self.outputs:\n                if o.address not in wlt_addresslist:\n                    continue\n                mut_list.append((self.date, self.txid, 'in', input_addresslist, o.address, o.value, 0))\n        return mut_list",
  "def save(self, filename=None):\n        \"\"\"\n        Store transaction object as file, so it can be imported in bitcoinlib later with the :func:`load` method.\n\n        :param filename: Location and name of file, leave empty to store transaction in bitcoinlib data directory: .bitcoinlib/<transaction_id.tx)\n        :type filename: str\n\n        :return:\n        \"\"\"\n        if not filename:\n            p = Path(BCL_DATA_DIR, '%s.tx' % self.txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('wb')\n        t = self.to_transaction()\n        pickle.dump(t, f)\n        f.close()",
  "def delete(self):\n        \"\"\"\n        Delete this transaction from database.\n\n        WARNING: Results in incomplete wallets, transactions will NOT be automatically downloaded again when scanning or updating wallet. In normal situations only used to remove old unconfirmed transactions\n\n        :return int: Number of deleted transactions\n        \"\"\"\n\n        session = self.hdwallet._session\n        txid = bytes.fromhex(self.txid)\n        tx_query = session.query(DbTransaction).filter_by(txid=txid)\n        tx = tx_query.scalar()\n        session.query(DbTransactionOutput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbTransactionInput).filter_by(transaction_id=tx.id).delete()\n        session.query(DbKey).filter_by(latest_txid=txid).update({DbKey.latest_txid: None})\n        res = tx_query.delete()\n        self.hdwallet._commit()\n        return res",
  "def _create(cls, name, key, owner, network, account_id, purpose, scheme, parent_id, sort_keys,\n                witness_type, encoding, multisig, sigs_required, cosigner_id, key_path, db_uri, db_cache_uri,\n                db_password):\n\n        db = Db(db_uri, db_password)\n        session = db.session\n        if (db_uri is None or db_uri.startswith(\"sqlite\")) and db_cache_uri is None:\n            db_cache_uri = DEFAULT_DATABASE_CACHE\n        elif not db_cache_uri:\n            db_cache_uri = db.db_uri\n        db_uri = db.db_uri\n        if session.query(DbWallet).filter_by(name=name).count():\n            raise WalletError(\"Wallet with name '%s' already exists\" % name)\n        else:\n            _logger.info(\"Create new wallet '%s'\" % name)\n        if not name:\n            raise WalletError(\"Please enter wallet name\")\n\n        if not isinstance(key_path, list):\n            key_path = key_path.split('/')\n        key_depth = 1 if not key_path else len(key_path) - 1\n        base_path = 'm'\n        if hasattr(key, 'depth'):\n            if key.depth is None:\n                key.depth = key_depth\n            if key.depth > 0:\n                hardened_keys = [x for x in key_path if x[-1:] == \"'\"]\n                if hardened_keys:\n                    depth_public_master = key_path.index(hardened_keys[-1])\n                    if depth_public_master != key.depth:\n                        raise WalletError(\"Depth of provided public master key %d does not correspond with key path \"\n                                          \"%s. Did you provide correct witness_type and multisig attribute?\" %\n                                          (key.depth, key_path))\n                key_path = ['M'] + key_path[key.depth+1:]\n                base_path = 'M'\n\n        if isinstance(key_path, list):\n            key_path = '/'.join(key_path)\n        session.merge(DbNetwork(name=network))\n        new_wallet = DbWallet(name=name, owner=owner, network_name=network, purpose=purpose, scheme=scheme,\n                              sort_keys=sort_keys, witness_type=witness_type, parent_id=parent_id, encoding=encoding,\n                              multisig=multisig, multisig_n_required=sigs_required, cosigner_id=cosigner_id,\n                              key_path=key_path)\n        session.add(new_wallet)\n        session.commit()\n        new_wallet_id = new_wallet.id\n\n        if scheme == 'bip32' and multisig and parent_id is None:\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri)\n        elif scheme == 'bip32':\n            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,\n                                    account_id=account_id, purpose=purpose, key_type='bip32', encoding=encoding,\n                                    witness_type=witness_type, multisig=multisig, path=base_path)\n            new_wallet.main_key_id = mk.key_id\n            session.commit()\n\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri, main_key_object=mk.key())\n            w.key_for_path([0, 0], account_id=account_id, cosigner_id=cosigner_id)\n        else:  # scheme == 'single':\n            if not key:\n                key = HDKey(network=network, depth=key_depth)\n            mk = WalletKey.from_key(key=key, name=name, session=session, wallet_id=new_wallet_id, network=network,\n                                    account_id=account_id, purpose=purpose, key_type='single', encoding=encoding,\n                                    witness_type=witness_type, multisig=multisig)\n            new_wallet.main_key_id = mk.key_id\n            session.commit()\n            w = cls(new_wallet_id, db_uri=db_uri, db_cache_uri=db_cache_uri, main_key_object=mk.key())\n\n        session.close()\n        return w",
  "def _commit(self):\n        try:\n            self._session.commit()\n        except Exception:\n            self._session.rollback()\n            raise",
  "def create(cls, name, keys=None, owner='', network=None, account_id=0, purpose=0, scheme='bip32',\n               sort_keys=True, password='', witness_type=None, encoding=None, multisig=None, sigs_required=None,\n               cosigner_id=None, key_path=None, db_uri=None, db_cache_uri=None, db_password=None):\n        \"\"\"\n        Create Wallet and insert in database. Generate masterkey or import key when specified.\n\n        When only a name is specified a legacy Wallet with a single masterkey is created with standard p2wpkh\n        scripts.\n\n        >>> if wallet_delete_if_exists('create_legacy_wallet_test'): pass\n        >>> w = Wallet.create('create_legacy_wallet_test')\n        >>> w\n        <Wallet(name=\"create_legacy_wallet_test\")>\n\n        To create a multi signature wallet specify multiple keys (private or public) and provide the sigs_required\n        argument if it different then len(keys)\n\n        >>> if wallet_delete_if_exists('create_legacy_multisig_wallet_test'): pass\n        >>> w = Wallet.create('create_legacy_multisig_wallet_test', keys=[HDKey(), HDKey().public()])\n\n        To create a native segwit wallet use the option witness_type = 'segwit' and for old style addresses and p2sh\n        embedded segwit script us 'ps2h-segwit' as witness_type.\n\n        >>> if wallet_delete_if_exists('create_segwit_wallet_test'): pass\n        >>> w = Wallet.create('create_segwit_wallet_test', witness_type='segwit')\n\n        Use a masterkey WIF when creating a wallet:\n\n        >>> wif = 'xprv9s21ZrQH143K3cxbMVswDTYgAc9CeXABQjCD9zmXCpXw4MxN93LanEARbBmV3utHZS9Db4FX1C1RbC5KSNAjQ5WNJ1dDBJ34PjfiSgRvS8x'\n        >>> if wallet_delete_if_exists('bitcoinlib_legacy_wallet_test', force=True): pass\n        >>> w = Wallet.create('bitcoinlib_legacy_wallet_test', wif)\n        >>> w\n        <Wallet(name=\"bitcoinlib_legacy_wallet_test\")>\n        >>> # Add some test utxo data:\n        >>> if w.utxo_add('16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', 100000000, '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', 0): pass\n\n        Please mention account_id if you are using multiple accounts.\n\n        :param name: Unique name of this Wallet\n        :type name: str\n        :param keys: Masterkey to or list of keys to use for this wallet. Will be automatically created if not specified. One or more keys are obligatory for multisig wallets. Can contain all key formats accepted by the HDKey object, a HDKey object or BIP39 passphrase\n        :type keys: str, bytes, int, HDKey, HDWalletKey, list of str, list of bytes, list of int, list of HDKey, list of HDWalletKey\n        :param owner: Wallet owner for your own reference\n        :type owner: str\n        :param network: Network name, use default if not specified\n        :type network: str\n        :param account_id: Account ID, default is 0\n        :type account_id: int\n        :param purpose: BIP43 purpose field, will be derived from witness_type and multisig by default\n        :type purpose: int\n        :param scheme: Key structure type, i.e. BIP32 or single\n        :type scheme: str\n        :param sort_keys: Sort keys according to BIP45 standard (used for multisig keys)\n        :type sort_keys: bool\n        :param password: Password to protect passphrase, only used if a passphrase is supplied in the 'key' argument.\n        :type password: str\n        :param witness_type: Specify witness type, default is 'legacy'. Use 'segwit' for native segregated witness wallet, or 'p2sh-segwit' for legacy compatible wallets\n        :type witness_type: str\n        :param encoding: Encoding used for address generation: base58 or bech32. Default is derive from wallet and/or witness type\n        :type encoding: str\n        :param multisig: Multisig wallet or child of a multisig wallet, default is None / derive from number of keys.\n        :type multisig: bool\n        :param sigs_required: Number of signatures required for validation if using a multisignature wallet. For example 2 for 2-of-3 multisignature. Default is all keys must be signed\n        :type sigs_required: int\n        :param cosigner_id: Set this if wallet contains only public keys, more than one private key or if you would like to create keys for other cosigners. Note: provided keys of a multisig wallet are sorted if sort_keys = True (default) so if your provided key list is not sorted the cosigned_id may be different.\n        :type cosigner_id: int\n        :param key_path: Key path for multisig wallet, use to create your own non-standard key path. Key path must follow the following rules:\n            * Path start with masterkey (m) and end with change / address_index\n            * If accounts are used, the account level must be 3. I.e.: m/purpose/coin_type/account/\n            * All keys must be hardened, except for change, address_index or cosigner_id\n            * Max length of path is 8 levels\n        :type key_path: list, str\n        :param db_uri: URI of the database for wallets, wallet transactions and keys\n        :type db_uri: str\n        :param db_cache_uri: URI of the cache database. If not specified  the default cache database is used when using sqlite, for other databasetypes the cache database is merged with the wallet database (db_uri)\n        :type db_cache_uri: str\n        :param db_password: Password to encrypt database. Requires the installation of sqlcipher (see documentation).\n        :type db_password: str\n\n        :return Wallet:\n        \"\"\"\n\n        if multisig is None:\n            if keys and isinstance(keys, list) and len(keys) > 1:\n                multisig = True\n            else:\n                multisig = False\n        if scheme not in ['bip32', 'single']:\n            raise WalletError(\"Only bip32 or single key scheme's are supported at the moment\")\n        if witness_type not in [None, 'legacy', 'p2sh-segwit', 'segwit']:\n            raise WalletError(\"Witness type %s not supported at the moment\" % witness_type)\n        if name.isdigit():\n            raise WalletError(\"Wallet name '%s' invalid, please include letter characters\" % name)\n\n        if multisig:\n            if password:\n                raise WalletError(\"Password protected multisig wallets not supported\")\n            if scheme != 'bip32':\n                raise WalletError(\"Multisig wallets should use bip32 scheme not %s\" % scheme)\n            if sigs_required is None:\n                sigs_required = len(keys)\n            if sigs_required > len(keys):\n                raise WalletError(\"Number of keys required to sign is greater then number of keys provided\")\n        elif not isinstance(keys, list):\n            keys = [keys]\n        if len(keys) > 15:\n            raise WalletError(\"Redeemscripts with more then 15 keys are non-standard and could result in \"\n                              \"locked up funds\")\n\n        hdkey_list = []\n        if keys and isinstance(keys, list) and sort_keys:\n            keys.sort(key=lambda x: ('0' if isinstance(x, HDKey) else '1'))\n        for key in keys:\n            if isinstance(key, HDKey):\n                if network and network != key.network.name:\n                    raise WalletError(\"Network from key (%s) is different then specified network (%s)\" %\n                                      (key.network.name, network))\n                network = key.network.name\n                if witness_type is None:\n                    witness_type = key.witness_type\n            elif key:\n                # If key consists of several words assume it is a passphrase and convert it to a HDKey object\n                if isinstance(key, str) and len(key.split(\" \")) > 1:\n                    if not network:\n                        raise WalletError(\"Please specify network when using passphrase to create a key\")\n                    key = HDKey.from_seed(Mnemonic().to_seed(key, password), network=network)\n                else:\n                    try:\n                        if isinstance(key, WalletKey):\n                            key = key._hdkey_object\n                        else:\n                            key = HDKey(key, password=password, network=network)\n                    except BKeyError:\n                        try:\n                            scheme = 'single'\n                            key = Address.parse(key, encoding=encoding, network=network)\n                        except Exception:\n                            raise WalletError(\"Invalid key or address: %s\" % key)\n                    if network is None:\n                        network = key.network.name\n                    if witness_type is None:\n                        witness_type = key.witness_type\n            hdkey_list.append(key)\n\n        if network is None:\n            network = DEFAULT_NETWORK\n        if witness_type is None:\n            witness_type = DEFAULT_WITNESS_TYPE\n        if network in ['dash', 'dash_testnet', 'dogecoin', 'dogecoin_testnet'] and witness_type != 'legacy':\n            raise WalletError(\"Segwit is not supported for %s wallets\" % network.capitalize())\n        elif network in ('dogecoin', 'dogecoin_testnet') and witness_type not in ('legacy', 'p2sh-segwit'):\n            raise WalletError(\"Pure segwit addresses are not supported for Dogecoin wallets. \"\n                              \"Please use p2sh-segwit instead\")\n\n        if not key_path:\n            if scheme == 'single':\n                key_path = ['m']\n                purpose = 0\n            else:\n                ks = [k for k in WALLET_KEY_STRUCTURES if k['witness_type'] == witness_type and\n                      k['multisig'] == multisig and k['purpose'] is not None]\n                if len(ks) > 1:\n                    raise WalletError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                                      \"witness_type - multisig combination\")\n                if ks and not purpose:\n                    purpose = ks[0]['purpose']\n                if ks and not encoding:\n                    encoding = ks[0]['encoding']\n                key_path = ks[0]['key_path']\n        else:\n            if purpose is None:\n                purpose = 0\n        if not encoding:\n            encoding = get_encoding_from_witness(witness_type)\n\n        if multisig:\n            key = ''\n        else:\n            key = hdkey_list[0]\n\n        main_key_path = key_path\n        if multisig:\n            if sort_keys:\n                hdkey_list.sort(key=lambda x: x.public_byte)\n            cos_prv_lst = [hdkey_list.index(cw) for cw in hdkey_list if cw.is_private]\n            if cosigner_id is None:\n                if not cos_prv_lst:\n                    raise WalletError(\"This wallet does not contain any private keys, please specify cosigner_id for \"\n                                      \"this wallet\")\n                elif len(cos_prv_lst) > 1:\n                    raise WalletError(\"This wallet contains more then 1 private key, please specify \"\n                                      \"cosigner_id for this wallet\")\n                cosigner_id = 0 if not cos_prv_lst else cos_prv_lst[0]\n            if hdkey_list[cosigner_id].key_type == 'single':\n                main_key_path = 'm'\n\n        hdpm = cls._create(name, key, owner=owner, network=network, account_id=account_id, purpose=purpose,\n                           scheme=scheme, parent_id=None, sort_keys=sort_keys, witness_type=witness_type,\n                           encoding=encoding, multisig=multisig, sigs_required=sigs_required, cosigner_id=cosigner_id,\n                           key_path=main_key_path, db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)\n\n        if multisig:\n            wlt_cos_id = 0\n            for cokey in hdkey_list:\n                if hdpm.network.name != cokey.network.name:\n                    raise WalletError(\"Network for key %s (%s) is different then network specified: %s/%s\" %\n                                      (cokey.wif(is_private=False), cokey.network.name, network, hdpm.network.name))\n                scheme = 'bip32'\n                wn = name + '-cosigner-%d' % wlt_cos_id\n                c_key_path = key_path\n                if cokey.key_type == 'single':\n                    scheme = 'single'\n                    c_key_path = ['m']\n                w = cls._create(name=wn, key=cokey, owner=owner, network=network, account_id=account_id,\n                                purpose=hdpm.purpose, scheme=scheme, parent_id=hdpm.wallet_id, sort_keys=sort_keys,\n                                witness_type=hdpm.witness_type, encoding=encoding, multisig=True,\n                                sigs_required=None, cosigner_id=wlt_cos_id, key_path=c_key_path,\n                                db_uri=db_uri, db_cache_uri=db_cache_uri, db_password=db_password)\n                hdpm.cosigner.append(w)\n                wlt_cos_id += 1\n            # hdpm._dbwallet = hdpm._session.query(DbWallet).filter(DbWallet.id == hdpm.wallet_id)\n            # hdpm._dbwallet.update({DbWallet.cosigner_id: hdpm.cosigner_id})\n            # hdpm._dbwallet.update({DbWallet.key_path: hdpm.key_path})\n            # hdpm._session.commit()\n\n        return hdpm",
  "def __enter__(self):\n        return self",
  "def __init__(self, wallet, db_uri=None, db_cache_uri=None, session=None, main_key_object=None, db_password=None):\n        \"\"\"\n        Open a wallet with given ID or name\n\n        :param wallet: Wallet name or ID\n        :type wallet: int, str\n        :param db_uri: URI of the database\n        :type db_uri: str\n        :param db_cache_uri: URI of the cache database. If not specified  the default cache database is used when using sqlite, for other databasetypes the cache database is merged with the wallet database (db_uri)\n        :type db_cache_uri: str\n        :param session: Sqlalchemy session\n        :type session: sqlalchemy.orm.session.Session\n        :param main_key_object: Pass main key object to save time\n        :type main_key_object: HDKey\n        \"\"\"\n\n        if session:\n            self._session = session\n        else:\n            dbinit = Db(db_uri=db_uri, password=db_password)\n            self._session = dbinit.session\n            self._engine = dbinit.engine\n        self.db_uri = db_uri\n        self.db_cache_uri = db_cache_uri\n        if isinstance(wallet, int) or wallet.isdigit():\n            db_wlt = self._session.query(DbWallet).filter_by(id=wallet).scalar()\n        else:\n            db_wlt = self._session.query(DbWallet).filter_by(name=wallet).scalar()\n        if db_wlt:\n            self._dbwallet = db_wlt\n            self.wallet_id = db_wlt.id\n            self._name = db_wlt.name\n            self._owner = db_wlt.owner\n            self.network = Network(db_wlt.network_name)\n            self.purpose = db_wlt.purpose\n            self.scheme = db_wlt.scheme\n            self._balance = None\n            self._balances = []\n            self.main_key_id = db_wlt.main_key_id\n            self.main_key = None\n            self._default_account_id = db_wlt.default_account_id\n            self.multisig_n_required = db_wlt.multisig_n_required\n            co_sign_wallets = self._session.query(DbWallet).\\\n                filter(DbWallet.parent_id == self.wallet_id).order_by(DbWallet.name).all()\n            self.cosigner = [Wallet(w.id, db_uri=db_uri, db_cache_uri=db_cache_uri) for w in co_sign_wallets]\n            self.sort_keys = db_wlt.sort_keys\n            if db_wlt.main_key_id:\n                self.main_key = WalletKey(self.main_key_id, session=self._session, hdkey_object=main_key_object)\n            if self._default_account_id is None:\n                self._default_account_id = 0\n                if self.main_key:\n                    self._default_account_id = self.main_key.account_id\n            _logger.info(\"Opening wallet '%s'\" % self.name)\n            self._key_objects = {\n                self.main_key_id: self.main_key\n            }\n            self.providers = None\n            self.witness_type = db_wlt.witness_type\n            self.encoding = db_wlt.encoding\n            self.multisig = db_wlt.multisig\n            self.cosigner_id = db_wlt.cosigner_id\n            self.script_type = script_type_default(self.witness_type, self.multisig, locking_script=True)\n            self.key_path = [] if not db_wlt.key_path else db_wlt.key_path.split('/')\n            self.depth_public_master = 0\n            self.parent_id = db_wlt.parent_id\n            if self.main_key and self.main_key.depth > 0:\n                self.depth_public_master = self.main_key.depth\n                self.key_depth = self.depth_public_master + len(self.key_path) - 1\n            else:\n                hardened_keys = [x for x in self.key_path if x[-1:] == \"'\"]\n                if hardened_keys:\n                    self.depth_public_master = self.key_path.index(hardened_keys[-1])\n                self.key_depth = len(self.key_path) - 1\n            self.last_updated = None\n        else:\n            raise WalletError(\"Wallet '%s' not found, please specify correct wallet ID or name.\" % wallet)",
  "def __exit__(self, exception_type, exception_value, traceback):\n        try:\n            self._session.close()\n            self._engine.dispose()\n        except Exception:\n            pass",
  "def __del__(self):\n        try:\n            self._session.close()\n            self._engine.dispose()\n        except Exception:\n            pass",
  "def __repr__(self):\n        db_uri = self.db_uri.split('?')[0]\n        if DEFAULT_DATABASE in db_uri:\n            return \"<Wallet(name=\\\"%s\\\")>\" % self.name\n        return \"<Wallet(name=\\\"%s\\\", db_uri=\\\"%s\\\")>\" % \\\n               (self.name, db_uri)",
  "def __str__(self):\n        return self.name",
  "def _get_account_defaults(self, network=None, account_id=None, key_id=None):\n        \"\"\"\n        Check parameter values for network and account ID, return defaults if no network or account ID is specified.\n        If a network is specified but no account ID this method returns the first account ID it finds.\n\n        :param network: Network code, leave empty for default\n        :type network: str\n        :param account_id: Account ID, leave emtpy for default\n        :type account_id: int\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n\n        :return: network code, account ID and DbKey instance of account ID key\n        \"\"\"\n\n        if key_id:\n            kobj = self.key(key_id)\n            network = kobj.network_name\n            account_id = kobj.account_id\n        if network is None:\n            network = self.network.name\n        if account_id is None and network == self.network.name:\n            account_id = self.default_account_id\n        qr = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, depth=self.depth_public_master,\n                      network_name=network)\n        if account_id is not None:\n            qr = qr.filter_by(account_id=account_id)\n        acckey = qr.first()\n        if len(qr.all()) > 1 and \"account'\" in self.key_path:\n            _logger.warning(\"No account_id specified and more than one account found for this network %s. \"\n                            \"Using a random account\" % network)\n        if account_id is None:\n            if acckey:\n                account_id = acckey.account_id\n            else:\n                account_id = 0\n        return network, account_id, acckey",
  "def default_account_id(self):\n        return self._default_account_id",
  "def default_account_id(self, value):\n        self._default_account_id = value\n        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id). \\\n            update({DbWallet.default_account_id: value})\n        self._commit()",
  "def owner(self):\n        \"\"\"\n        Get wallet Owner\n\n        :return str:\n        \"\"\"\n\n        return self._owner",
  "def owner(self, value):\n        \"\"\"\n        Set wallet Owner in database\n\n        :param value: Owner\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        self._owner = value\n        self._dbwallet = self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.owner: value})\n        self._commit()",
  "def name(self):\n        \"\"\"\n        Get wallet name\n\n        :return str:\n        \"\"\"\n\n        return self._name",
  "def name(self, value):\n        \"\"\"\n        Set wallet name, update in database\n\n        :param value: Name for this wallet\n        :type value: str\n\n        :return str:\n        \"\"\"\n\n        if wallet_exists(value, db_uri=self.db_uri):\n            raise WalletError(\"Wallet with name '%s' already exists\" % value)\n        self._name = value\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).update({DbWallet.name: value})\n        self._commit()",
  "def default_network_set(self, network):\n        if not isinstance(network, Network):\n            network = Network(network)\n        self.network = network\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.network_name: network.name})\n        self._commit()",
  "def import_master_key(self, hdkey, name='Masterkey (imported)'):\n        \"\"\"\n        Import (another) masterkey in this wallet\n\n        :param hdkey: Private key\n        :type hdkey: HDKey, str\n        :param name: Key name of masterkey\n        :type name: str\n\n        :return HDKey: Main key as HDKey object\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults()\n        if not isinstance(hdkey, HDKey):\n            hdkey = HDKey(hdkey)\n        if not isinstance(self.main_key, WalletKey):\n            raise WalletError(\"Main wallet key is not an WalletKey instance. Type %s\" % type(self.main_key))\n        if not hdkey.is_private or hdkey.depth != 0:\n            raise WalletError(\"Please supply a valid private BIP32 master key with key depth 0\")\n        if self.main_key.is_private:\n            raise WalletError(\"Main key is already a private key, cannot import key\")\n        if (self.main_key.depth != 1 and self.main_key.depth != 3 and self.main_key.depth != 4) or \\\n                self.main_key.key_type != 'bip32':\n            raise WalletError(\"Current main key is not a valid BIP32 public master key\")\n        # pm = self.public_master()\n        if not (self.network.name == self.main_key.network.name == hdkey.network.name):\n            raise WalletError(\"Network of Wallet class, main account key and the imported private key must use \"\n                              \"the same network\")\n        if self.main_key.wif != hdkey.public_master().wif():\n            raise WalletError(\"This key does not correspond to current public master key\")\n\n        hdkey.key_type = 'bip32'\n        ks = [k for k in WALLET_KEY_STRUCTURES if\n              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]\n        if len(ks) > 1:\n            raise WalletError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                              \"witness_type - multisig combination\")\n        self.key_path = ks[0]['key_path']\n        self.main_key = WalletKey.from_key(\n            key=hdkey, name=name, session=self._session, wallet_id=self.wallet_id, network=network,\n            account_id=account_id, purpose=self.purpose, key_type='bip32', witness_type=self.witness_type)\n        self.main_key_id = self.main_key.key_id\n        self._key_objects.update({self.main_key_id: self.main_key})\n        self._session.query(DbWallet).filter(DbWallet.id == self.wallet_id).\\\n            update({DbWallet.main_key_id: self.main_key_id})\n\n        for key in self.keys(is_private=False):\n            kp = key.path.split(\"/\")\n            if kp and kp[0] == 'M':\n                kp = self.key_path[:self.depth_public_master+1] + kp[1:]\n            self.key_for_path(kp, recreate=True)\n\n        self._commit()\n        return self.main_key",
  "def import_key(self, key, account_id=0, name='', network=None, purpose=44, key_type=None):\n        \"\"\"\n        Add new single key to wallet.\n\n        :param key: Key to import\n        :type key: str, bytes, int, HDKey, Address\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param name: Specify name for key, leave empty for default\n        :type name: str\n        :param network: Network name, method will try to extract from key if not specified. Raises warning if network could not be detected\n        :type network: str\n        :param purpose: BIP definition used, default is BIP44\n        :type purpose: int\n        :param key_type: Key type of imported key, can be single. Unrelated to wallet, bip32, bip44 or master for new or extra master key import. Default is 'single'\n        :type key_type: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme not in ['bip32', 'single']:\n            raise WalletError(\"Keys can only be imported to a BIP32 or single type wallet, create a new wallet \"\n                              \"instead\")\n        if isinstance(key, (HDKey, Address)):\n            network = key.network.name\n            hdkey = key\n            if network not in self.network_list():\n                raise WalletError(\"Network %s not found in this wallet\" % network)\n        else:\n            if isinstance(key, str) and len(key.split(\" \")) > 1:\n                if network is None:\n                    network = self.network\n                hdkey = HDKey.from_seed(Mnemonic().to_seed(key), network=network)\n            else:\n                if network is None:\n                    network = check_network_and_key(key, default_network=self.network.name)\n                if network not in self.network_list():\n                    raise WalletError(\"Network %s not available in this wallet, please create an account for this \"\n                                      \"network first.\" % network)\n                hdkey = HDKey(key, network=network, key_type=key_type)\n\n        if not self.multisig:\n            if self.main_key and self.main_key.depth == self.depth_public_master and \\\n                    not isinstance(hdkey, Address) and hdkey.is_private and hdkey.depth == 0 and self.scheme == 'bip32':\n                return self.import_master_key(hdkey, name)\n\n            if key_type is None:\n                hdkey.key_type = 'single'\n                key_type = 'single'\n\n            ik_path = 'm'\n            if key_type == 'single':\n                # Create path for unrelated import keys\n                hdkey.depth = self.key_depth\n                last_import_key = self._session.query(DbKey).filter(DbKey.path.like(\"import_key_%\")).\\\n                    order_by(DbKey.path.desc()).first()\n                if last_import_key:\n                    ik_path = \"import_key_\" + str(int(last_import_key.path[-5:]) + 1).zfill(5)\n                else:\n                    ik_path = \"import_key_00001\"\n                if not name:\n                    name = ik_path\n\n            mk = WalletKey.from_key(\n                key=hdkey, name=name, wallet_id=self.wallet_id, network=network, key_type=key_type,\n                account_id=account_id, purpose=purpose, session=self._session, path=ik_path,\n                witness_type=self.witness_type)\n            self._key_objects.update({mk.key_id: mk})\n            if mk.key_id == self.main_key.key_id:\n                self.main_key = mk\n            return mk\n        else:\n            account_key = hdkey.public_master(witness_type=self.witness_type, multisig=True).wif()\n            for w in self.cosigner:\n                if w.main_key.key().wif_public() == account_key:\n                    _logger.debug(\"Import new private cosigner key in this multisig wallet: %s\" % account_key)\n                    return w.import_master_key(hdkey)\n            raise WalletError(\"Unknown key: Can only import a private key for a known public key in multisig wallets\")",
  "def _new_key_multisig(self, public_keys, name, account_id, change, cosigner_id, network, address_index):\n        if self.sort_keys:\n            public_keys.sort(key=lambda pubk: pubk.key_public)\n        public_key_list = [pubk.key_public for pubk in public_keys]\n        public_key_ids = [str(x.key_id) for x in public_keys]\n\n        # Calculate redeemscript and address and add multisig key to database\n        # redeemscript = serialize_multisig_redeemscript(public_key_list, n_required=self.multisig_n_required)\n\n        # todo: pass key object, reuse key objects\n        redeemscript = Script(script_types=['multisig'], keys=public_key_list,\n                              sigs_required=self.multisig_n_required).serialize()\n        script_type = 'p2sh'\n        if self.witness_type == 'p2sh-segwit':\n            script_type = 'p2sh_p2wsh'\n        address = Address(redeemscript, encoding=self.encoding, script_type=script_type, network=network)\n        already_found_key = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id,\n                                                                 address=address.address).first()\n        if already_found_key:\n            return self.key(already_found_key.id)\n        path = [pubk.path for pubk in public_keys if pubk.wallet.cosigner_id == self.cosigner_id][0]\n        depth = self.cosigner[self.cosigner_id].main_key.depth + len(path.split(\"/\")) - 1\n        if not name:\n            name = \"Multisig Key \" + '/'.join(public_key_ids)\n\n        multisig_key = DbKey(\n            name=name[:80], wallet_id=self.wallet_id, purpose=self.purpose, account_id=account_id,\n            depth=depth, change=change, address_index=address_index, parent_id=0, is_private=False, path=path,\n            public=address.hash_bytes, wif='multisig-%s' % address, address=address.address, cosigner_id=cosigner_id,\n            key_type='multisig', network_name=network)\n        self._session.add(multisig_key)\n        self._commit()\n        for child_id in public_key_ids:\n            self._session.add(DbKeyMultisigChildren(key_order=public_key_ids.index(child_id), parent_id=multisig_key.id,\n                                                    child_id=int(child_id)))\n        self._commit()\n        return self.key(multisig_key.id)",
  "def new_key(self, name='', account_id=None, change=0, cosigner_id=None, network=None):\n        \"\"\"\n        Create a new HD Key derived from this wallet's masterkey. An account will be created for this wallet\n        with index 0 if there is no account defined yet.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.new_key('my key') # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=my key, wif=..., path=m/44'/0'/0'/0/...)>\n\n        :param name: Key name. Does not have to be unique but if you use it at reference you might chooce to enforce this. If not specified 'Key #' with a unique sequence number will be used\n        :type name: str\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param change: Change (1) or payments (0). Default is 0\n        :type change: int\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme == 'single':\n            return self.main_key\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if network != self.network.name and \"coin_type'\" not in self.key_path:\n            raise WalletError(\"Multiple networks not supported by wallet key structure\")\n        if self.multisig:\n            if not self.multisig_n_required:\n                raise WalletError(\"Multisig_n_required not set, cannot create new key\")\n            if cosigner_id is None:\n                if self.cosigner_id is None:\n                    raise WalletError(\"Missing Cosigner ID value, cannot create new key\")\n                cosigner_id = self.cosigner_id\n\n        address_index = 0\n        if self.multisig and cosigner_id is not None and (len(self.cosigner) > cosigner_id and self.cosigner[cosigner_id].key_path == 'm' or self.cosigner[cosigner_id].key_path == ['m']):\n            req_path = []\n        else:\n            prevkey = self._session.query(DbKey).\\\n                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network, account_id=account_id,\n                          change=change, cosigner_id=cosigner_id, depth=self.key_depth).\\\n                order_by(DbKey.address_index.desc()).first()\n            if prevkey:\n                address_index = prevkey.address_index + 1\n            req_path = [change, address_index]\n\n        return self.key_for_path(req_path, name=name, account_id=account_id, network=network,\n                                 cosigner_id=cosigner_id, address_index=address_index)",
  "def new_key_change(self, name='', account_id=None, network=None):\n        \"\"\"\n        Create new key to receive change for a transaction. Calls :func:`new_key` method with change=1.\n\n        :param name: Key name. Default name is 'Change #' with an address index\n        :type name: str\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        return self.new_key(name=name, account_id=account_id, network=network, change=1)",
  "def scan_key(self, key):\n        \"\"\"\n        Scan for new transactions for specified wallet key and update wallet transactions\n\n        :param key: The wallet key as object or index\n        :type key: WalletKey, int\n\n        :return bool: New transactions found?\n\n        \"\"\"\n        if isinstance(key, int):\n            key = self.key(key)\n        txs_found = False\n        should_be_finished_count = 0\n        while True:\n            n_new = self.transactions_update(key_id=key.key_id)\n            if n_new and n_new < MAX_TRANSACTIONS:\n                if should_be_finished_count:\n                    _logger.info(\"Possible recursive loop detected in scan_key(%d): retry %d/5\" %\n                                 (key.key_id, should_be_finished_count))\n                should_be_finished_count += 1\n            logger.info(\"Scanned key %d, %s Found %d new transactions\" % (key.key_id, key.address, n_new))\n            if not n_new or should_be_finished_count > 5:\n                break\n            txs_found = True\n        return txs_found",
  "def scan(self, scan_gap_limit=5, account_id=None, change=None, rescan_used=False, network=None, keys_ignore=None):\n        \"\"\"\n        Generate new addresses/keys and scan for new transactions using the Service providers. Updates all UTXO's and balances.\n\n        Keep scanning for new transactions until no new transactions are found for 'scan_gap_limit' addresses. Only scan keys from default network and account unless another network or account is specified.\n\n        Use the faster :func:`utxos_update` method if you are only interested in unspent outputs.\n        Use the :func:`transactions_update` method if you would like to manage the key creation yourself or if you want to scan a single key.\n\n        :param scan_gap_limit: Amount of new keys and change keys (addresses) created for this wallet. Default is 5, so scanning stops if after 5 addresses no transaction are found.\n        :type scan_gap_limit: int\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param change: Filter by change addresses. Set to True to include only change addresses, False to only include regular addresses. None (default) to disable filter and include both\n        :type change: bool\n        :param rescan_used: Rescan already used addressed. Default is False, so funds send to old addresses will be ignored by default.\n        :type rescan_used: bool\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param keys_ignore: Id's of keys to ignore\n        :type keys_ignore: list of int\n\n        :return:\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if self.scheme != 'bip32' and self.scheme != 'multisig' and scan_gap_limit < 2:\n            raise WalletError(\"The wallet scan() method is only available for BIP32 wallets\")\n        if keys_ignore is None:\n            keys_ignore = []\n\n        # Rescan used addresses\n        if rescan_used:\n            for key in self.keys_addresses(account_id=account_id, change=change, network=network, used=True):\n                self.scan_key(key.id)\n\n        # Update already known transactions with known block height\n        self.transactions_update_confirmations()\n\n        # Check unconfirmed transactions\n        db_txs = self._session.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.confirmations == 0).all()\n        for db_tx in db_txs:\n            self.transactions_update_by_txids([db_tx.txid])\n\n        # Scan each key address, stop when no new transactions are found after set scan gap limit\n        if change is None:\n            change_range = [0, 1]\n        else:\n            change_range = [change]\n        counter = 0\n        for chg in change_range:\n            while True:\n                if self.scheme == 'single':\n                    keys_to_scan = [self.key(k.id) for k in self.keys_addresses()[counter:counter+scan_gap_limit]]\n                    counter += scan_gap_limit\n                else:\n                    keys_to_scan = self.get_keys(account_id, network, number_of_keys=scan_gap_limit, change=chg)\n                n_highest_updated = 0\n                for key in keys_to_scan:\n                    if key.key_id in keys_ignore:\n                        continue\n                    keys_ignore.append(key.key_id)\n                    n_high_new = 0\n                    if self.scan_key(key):\n                        if not key.address_index:\n                            key.address_index = 0\n                        n_high_new = key.address_index + 1\n                    if n_high_new > n_highest_updated:\n                        n_highest_updated = n_high_new\n                if not n_highest_updated:\n                    break",
  "def _get_key(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0, as_list=False):\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        if cosigner_id is None:\n            cosigner_id = self.cosigner_id\n        elif cosigner_id > len(self.cosigner):\n            raise WalletError(\"Cosigner ID (%d) can not be greater then number of cosigners for this wallet (%d)\" %\n                              (cosigner_id, len(self.cosigner)))\n\n        last_used_qr = self._session.query(DbKey.id).\\\n            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,\n                      used=True, change=change, depth=self.key_depth).\\\n            order_by(DbKey.id.desc()).first()\n        last_used_key_id = 0\n        if last_used_qr:\n            last_used_key_id = last_used_qr.id\n        dbkey = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, account_id=account_id, network_name=network, cosigner_id=cosigner_id,\n                      used=False, change=change, depth=self.key_depth).filter(DbKey.id > last_used_key_id).\\\n            order_by(DbKey.id.desc()).all()\n        key_list = []\n        if self.scheme == 'single' and len(dbkey):\n            number_of_keys = len(dbkey) if number_of_keys > len(dbkey) else number_of_keys\n        for i in range(number_of_keys):\n            if dbkey:\n                dk = dbkey.pop()\n                nk = self.key(dk.id)\n            else:\n                nk = self.new_key(account_id=account_id, change=change, cosigner_id=cosigner_id, network=network)\n            key_list.append(nk)\n        if as_list:\n            return key_list\n        else:\n            return key_list[0]",
  "def get_key(self, account_id=None, network=None, cosigner_id=None, change=0):\n        \"\"\"\n        Get a unused key / address or create a new one with :func:`new_key` if there are no unused keys.\n        Returns a key from this wallet which has no transactions linked to it.\n\n        Use the get_keys() method to a list of unused keys. Calling the get_key() method repeatelly to receive a\n        list of key doesn't work: since the key is unused it would return the same result every time you call this\n        method.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.get_key() # doctest:+ELLIPSIS\n        <WalletKey(key_id=..., name=..., wif=..., path=m/44'/0'/0'/0/...)>\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param change: Payment (0) or change key (1). Default is 0\n        :type change: int\n\n        :return WalletKey:\n        \"\"\"\n        return self._get_key(account_id, network, cosigner_id, change=change, as_list=False)",
  "def get_keys(self, account_id=None, network=None, cosigner_id=None, number_of_keys=1, change=0):\n        \"\"\"\n        Get a list of unused keys / addresses or create a new ones with :func:`new_key` if there are no unused keys.\n        Returns a list of keys from this wallet which has no transactions linked to it.\n\n        Use the get_key() method to get a single key.\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param cosigner_id: Cosigner ID for key path\n        :type cosigner_id: int\n        :param number_of_keys: Number of keys to return. Default is 1\n        :type number_of_keys: int\n        :param change: Payment (0) or change key (1). Default is 0\n        :type change: int\n\n        :return list of WalletKey:\n        \"\"\"\n        if self.scheme == 'single':\n            raise WalletError(\"Single wallet has only one (master)key. Use get_key() or main_key() method\")\n        return self._get_key(account_id, network, cosigner_id, number_of_keys, change, as_list=True)",
  "def get_key_change(self, account_id=None, network=None):\n        \"\"\"\n        Get a unused change key or create a new one if there are no unused keys.\n        Wrapper for the :func:`get_key` method\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        return self._get_key(account_id=account_id, network=network, change=1, as_list=False)",
  "def get_keys_change(self, account_id=None, network=None, number_of_keys=1):\n        \"\"\"\n        Get a unused change key or create a new one if there are no unused keys.\n        Wrapper for the :func:`get_key` method\n\n        :param account_id: Account ID. Default is last used or created account ID.\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param number_of_keys: Number of keys to return. Default is 1\n        :type number_of_keys: int\n\n        :return list of WalletKey:\n        \"\"\"\n\n        return self._get_key(account_id=account_id, network=network, change=1, number_of_keys=number_of_keys,\n                             as_list=True)",
  "def new_account(self, name='', account_id=None, network=None):\n        \"\"\"\n        Create a new account with a child key for payments and 1 for change.\n\n        An account key can only be created if wallet contains a masterkey.\n\n        :param name: Account Name. If not specified \"Account #\" with the account_id will be used as name\n        :type name: str\n        :param account_id: Account ID. Default is last accounts ID + 1\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletKey:\n        \"\"\"\n\n        if self.scheme != 'bip32':\n            raise WalletError(\"We can only create new accounts for a wallet with a BIP32 key scheme\")\n        if self.main_key and (self.main_key.depth != 0 or self.main_key.is_private is False):\n            raise WalletError(\"A master private key of depth 0 is needed to create new accounts (depth: %d)\" %\n                              self.main_key.depth)\n        if \"account'\" not in self.key_path:\n            raise WalletError(\"Accounts are not supported for this wallet. Account not found in key path %s\" %\n                              self.key_path)\n        if network is None:\n            network = self.network.name\n        elif network != self.network.name and \"coin_type'\" not in self.key_path:\n            raise WalletError(\"Multiple networks not supported by wallet key structure\")\n\n        duplicate_cointypes = [Network(x).name for x in self.network_list() if Network(x).name != network and\n                               Network(x).bip44_cointype == Network(network).bip44_cointype]\n        if duplicate_cointypes:\n            raise WalletError(\"Can not create new account for network %s with same BIP44 cointype: %s\" %\n                              (network, duplicate_cointypes))\n\n        # Determine account_id and name\n        if account_id is None:\n            account_id = 0\n            qr = self._session.query(DbKey). \\\n                filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=network). \\\n                order_by(DbKey.account_id.desc()).first()\n            if qr:\n                account_id = qr.account_id + 1\n        if self.keys(account_id=account_id, depth=self.depth_public_master, network=network):\n            raise WalletError(\"Account with ID %d already exists for this wallet\" % account_id)\n\n        acckey = self.key_for_path([], level_offset=self.depth_public_master-self.key_depth, account_id=account_id,\n                                   name=name, network=network)\n        self.key_for_path([0, 0], network=network, account_id=account_id)\n        self.key_for_path([1, 0], network=network, account_id=account_id)\n        return acckey",
  "def path_expand(self, path, level_offset=None, account_id=None, cosigner_id=0, address_index=None, change=0,\n                    network=DEFAULT_NETWORK):\n        \"\"\"\n        Create key path. Specify part of key path to expand to key path used in this wallet.\n\n        >>> w = Wallet('create_legacy_wallet_test')\n        >>> w.path_expand([0,1200])\n        ['m', \"44'\", \"0'\", \"0'\", '0', '1200']\n\n        >>> w = Wallet('create_legacy_multisig_wallet_test')\n        >>> w.path_expand([0,2], cosigner_id=1)\n        ['m', \"45'\", '1', '0', '2']\n\n        :param path: Part of path, for example [0, 2] for change=0 and address_index=2\n        :type path: list, str\n        :param level_offset: Just create part of path. For example -2 means create path with the last 2 items (change, address_index) or 1 will return the master key 'm'\n        :type level_offset: int\n        :param account_id: Account ID\n        :type account_id: int\n        :param cosigner_id: ID of cosigner\n        :type cosigner_id: int\n        :param address_index: Index of key, normally provided to 'path' argument\n        :type address_index: int\n        :param change: Change key = 1 or normal = 0, normally provided to 'path' argument\n        :type change: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return list:\n        \"\"\"\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        return path_expand(path, self.key_path, level_offset, account_id=account_id, cosigner_id=cosigner_id,\n                           address_index=address_index, change=change, purpose=self.purpose,\n                           witness_type=self.witness_type, network=network)",
  "def key_for_path(self, path, level_offset=None, name=None, account_id=None, cosigner_id=None,\n                     address_index=0, change=0, network=None, recreate=False):\n        \"\"\"\n        Return key for specified path. Derive all wallet keys in path if they not already exists\n\n        >>> w = wallet_create_or_open('key_for_path_example')\n        >>> key = w.key_for_path([0, 0])\n        >>> key.path\n        \"m/44'/0'/0'/0/0\"\n\n        >>> w.key_for_path([], level_offset=-2).path\n        \"m/44'/0'/0'\"\n\n        >>> w.key_for_path([], w.depth_public_master + 1).path\n        \"m/44'/0'/0'\"\n\n        Arguments provided in 'path' take precedence over other arguments. The address_index argument is ignored:\n        >>> key = w.key_for_path([0, 10], address_index=1000)\n        >>> key.path\n        \"m/44'/0'/0'/0/10\"\n        >>> key.address_index\n        10\n\n        :param path: Part of key path, i.e. [0, 0] for [change=0, address_index=0]\n        :type path: list, str\n        :param level_offset: Just create part of path, when creating keys. For example -2 means create path with the last 2 items (change, address_index) or 1 will return the master key 'm'\n        :type level_offset: int\n        :param name: Specify key name for latest/highest key in structure\n        :type name: str\n        :param account_id: Account ID\n        :type account_id: int\n        :param cosigner_id: ID of cosigner\n        :type cosigner_id: int\n        :param address_index: Index of key, normally provided to 'path' argument\n        :type address_index: int\n        :param change: Change key = 1 or normal = 0, normally provided to 'path' argument\n        :type change: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param recreate: Recreate key, even if already found in wallet. Can be used to update public key with private key info\n        :type recreate: bool\n\n        :return WalletKey:\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        cosigner_id = cosigner_id if cosigner_id is not None else self.cosigner_id\n        level_offset_key = level_offset\n        if level_offset and self.main_key and level_offset > 0:\n            level_offset_key = level_offset - self.main_key.depth\n\n        key_path = self.key_path\n        if self.multisig and cosigner_id is not None and len(self.cosigner) > cosigner_id:\n            key_path = self.cosigner[cosigner_id].key_path\n        fullpath = path_expand(path, key_path, level_offset_key, account_id=account_id, cosigner_id=cosigner_id,\n                               purpose=self.purpose, address_index=address_index, change=change,\n                               witness_type=self.witness_type, network=network)\n\n        if self.multisig and self.cosigner:\n            public_keys = []\n            for wlt in self.cosigner:\n                if wlt.scheme == 'single':\n                    wk = wlt.main_key\n                else:\n                    wk = wlt.key_for_path(path, level_offset=level_offset, account_id=account_id, name=name,\n                                          cosigner_id=cosigner_id, network=network, recreate=recreate)\n                public_keys.append(wk)\n            return self._new_key_multisig(public_keys, name, account_id, change, cosigner_id, network, address_index)\n\n        # Check for closest ancestor in wallet\\\n        wpath = fullpath\n        if self.main_key.depth and fullpath and fullpath[0] != 'M':\n            wpath = [\"M\"] + fullpath[self.main_key.depth + 1:]\n        dbkey = None\n        while wpath and not dbkey:\n            qr = self._session.query(DbKey).filter_by(path=normalize_path('/'.join(wpath)), wallet_id=self.wallet_id)\n            if recreate:\n                qr = qr.filter_by(is_private=True)\n            dbkey = qr.first()\n            wpath = wpath[:-1]\n        if not dbkey:\n            _logger.warning(\"No master or public master key found in this wallet\")\n            return None\n        else:\n            topkey = self.key(dbkey.id)\n\n        # Key already found in db, return key\n        if dbkey and dbkey.path == normalize_path('/'.join(fullpath)) and not recreate:\n            return topkey\n        else:\n            # Create 1 or more keys add them to wallet\n            nk = None\n            parent_id = topkey.key_id\n            ck = topkey.key()\n            newpath = topkey.path\n            n_items = len(str(dbkey.path).split('/'))\n            for lvl in fullpath[n_items:]:\n                ck = ck.subkey_for_path(lvl, network=network)\n                newpath += '/' + lvl\n                if not account_id:\n                    account_id = 0 if \"account'\" not in self.key_path or self.key_path.index(\"account'\") >= len(\n                        fullpath) \\\n                        else int(fullpath[self.key_path.index(\"account'\")][:-1])\n                change = None if \"change\" not in self.key_path or self.key_path.index(\"change\") >= len(fullpath) \\\n                    else int(fullpath[self.key_path.index(\"change\")])\n                if name and len(fullpath) == len(newpath.split('/')):\n                    key_name = name\n                else:\n                    key_name = \"%s %s\" % (self.key_path[len(newpath.split('/'))-1], lvl)\n                    key_name = key_name.replace(\"'\", \"\").replace(\"_\", \" \")\n                nk = WalletKey.from_key(key=ck, name=key_name, wallet_id=self.wallet_id, account_id=account_id,\n                                        change=change, purpose=self.purpose, path=newpath, parent_id=parent_id,\n                                        encoding=self.encoding, witness_type=self.witness_type,\n                                        cosigner_id=cosigner_id, network=network, session=self._session)\n                self._key_objects.update({nk.key_id: nk})\n                parent_id = nk.key_id\n            return nk",
  "def keys(self, account_id=None, name=None, key_id=None, change=None, depth=None, used=None, is_private=None,\n             has_balance=None, is_active=None, network=None, include_private=False, as_dict=False):\n        \"\"\"\n        Search for keys in database. Include 0 or more of account_id, name, key_id, change and depth.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> all_wallet_keys = w.keys()\n        >>> w.keys(depth=0) # doctest:+ELLIPSIS\n        [<DbKey(id=..., name='bitcoinlib_legacy_wallet_test', wif='xprv9s21ZrQH143K3cxbMVswDTYgAc9CeXABQjCD9zmXCpXw4MxN93LanEARbBmV3utHZS9Db4FX1C1RbC5KSNAjQ5WNJ1dDBJ34PjfiSgRvS8x'>]\n\n        Returns a list of DbKey object or dictionary object if as_dict is True\n\n        :param account_id: Search for account ID\n        :type account_id: int\n        :param name: Search for Name\n        :type name: str\n        :param key_id: Search for Key ID\n        :type key_id: int\n        :param change: Search for Change\n        :type change: int\n        :param depth: Only include keys with this depth\n        :type depth: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param is_private: Only return private keys\n        :type is_private: bool\n        :param has_balance: Only include keys with a balance or without a balance, default is both\n        :type has_balance: bool\n        :param is_active: Hide inactive keys. Only include active keys with either a balance or which are unused, default is None (show all)\n        :type is_active: bool\n        :param network: Network name filter\n        :type network: str\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n        :param as_dict: Return keys as dictionary objects. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of DbKey: List of Keys\n        \"\"\"\n\n        qr = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id).order_by(DbKey.id)\n        if network is not None:\n            qr = qr.filter(DbKey.network_name == network)\n        if account_id is not None:\n            qr = qr.filter(DbKey.account_id == account_id)\n            if self.scheme == 'bip32' and depth is None:\n                qr = qr.filter(DbKey.depth >= 3)\n        if change is not None:\n            qr = qr.filter(DbKey.change == change)\n            if self.scheme == 'bip32' and depth is None:\n                qr = qr.filter(DbKey.depth > self.key_depth - 1)\n        if depth is not None:\n            qr = qr.filter(DbKey.depth == depth)\n        if name is not None:\n            qr = qr.filter(DbKey.name == name)\n        if key_id is not None:\n            qr = qr.filter(DbKey.id == key_id)\n            is_active = False\n        elif used is not None:\n            qr = qr.filter(DbKey.used == used)\n        if is_private is not None:\n            qr = qr.filter(DbKey.is_private == is_private)\n        if has_balance is True and is_active is True:\n            raise WalletError(\"Cannot use has_balance and is_active parameter together\")\n        if has_balance is not None:\n            if has_balance:\n                qr = qr.filter(DbKey.balance != 0)\n            else:\n                qr = qr.filter(DbKey.balance == 0)\n        if is_active:  # Unused keys and keys with a balance\n            qr = qr.filter(or_(DbKey.balance != 0, DbKey.used.is_(False)))\n        keys = qr.order_by(DbKey.depth).all()\n        if as_dict:\n            keys = [x.__dict__ for x in keys]\n            keys2 = []\n            private_fields = []\n            if not include_private:\n                private_fields += ['private', 'wif']\n            for key in keys:\n                keys2.append({k: v for (k, v) in key.items()\n                              if k[:1] != '_' and k != 'wallet' and k not in private_fields})\n            return keys2\n        qr.session.close()\n        return keys",
  "def keys_networks(self, used=None, as_dict=False):\n        \"\"\"\n        Get keys of defined networks for this wallet. Wrapper for the :func:`keys` method\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> network_key = w.keys_networks()\n        >>> # Address index of hardened key 0' is 2147483648\n        >>> network_key[0].address_index\n        2147483648\n        >>> network_key[0].path\n        \"m/44'/0'\"\n\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict):\n\n        \"\"\"\n\n        if self.scheme != 'bip32':\n            raise WalletError(\"The 'keys_network' method can only be used with BIP32 type wallets\")\n        try:\n            depth = self.key_path.index(\"coin_type'\")\n        except ValueError:\n            return []\n        if self.multisig and self.cosigner:\n            _logger.warning(\"No network keys available for multisig wallet, use networks() method for list of networks\")\n        return self.keys(depth=depth, used=used, as_dict=as_dict)",
  "def keys_accounts(self, account_id=None, network=DEFAULT_NETWORK, as_dict=False):\n        \"\"\"\n        Get Database records of account key(s) with for current wallet. Wrapper for the :func:`keys` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> account_key = w.keys_accounts()\n        >>> account_key[0].path\n        \"m/44'/0'/0'\"\n\n        Returns nothing if no account keys are available for instance in multisig or single account wallets. In this case use :func:`accounts` method instead.\n\n        :param account_id: Search for Account ID\n        :type account_id: int\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict):\n        \"\"\"\n\n        return self.keys(account_id, depth=self.depth_public_master, network=network, as_dict=as_dict)",
  "def keys_addresses(self, account_id=None, used=None, is_active=None, change=None, network=None, depth=None,\n                       as_dict=False):\n        \"\"\"\n        Get address keys of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.keys_addresses()[0].address\n        '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg'\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param is_active: Hide inactive keys. Only include active keys with either a balance or which are unused, default is True\n        :type is_active: bool\n        :param change: Search for Change\n        :type change: int\n        :param network: Network name filter\n        :type network: str\n        :param depth: Filter by key depth. Default for BIP44 and multisig is 5\n        :type depth: int\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        if depth is None:\n            depth = self.key_depth\n        return self.keys(account_id, depth=depth, used=used, change=change, is_active=is_active, network=network,\n                         as_dict=as_dict)",
  "def keys_address_payment(self, account_id=None, used=None, network=None, as_dict=False):\n        \"\"\"\n        Get payment addresses (change=0) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        return self.keys(account_id, depth=self.key_depth, change=0, used=used, network=network, as_dict=as_dict)",
  "def keys_address_change(self, account_id=None, used=None, network=None, as_dict=False):\n        \"\"\"\n        Get payment addresses (change=1) of specified account_id for current wallet. Wrapper for the :func:`keys` methods.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool\n        :param network: Network name filter\n        :type network: str\n        :param as_dict: Return as dictionary or DbKey object. Default is False: DbKey objects\n        :type as_dict: bool\n\n        :return list of (DbKey, dict)\n        \"\"\"\n\n        return self.keys(account_id, depth=self.key_depth, change=1, used=used, network=network, as_dict=as_dict)",
  "def addresslist(self, account_id=None, used=None, network=None, change=None, depth=None, key_id=None):\n        \"\"\"\n        Get list of addresses defined in current wallet. Wrapper for the :func:`keys` methods.\n\n        Use :func:`keys_addresses` method to receive full key objects\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.addresslist()[0]\n        '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg'\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only return used or unused keys\n        :type used: bool, None\n        :param network: Network name filter\n        :type network: str\n        :param change: Only include change addresses or not. Default is None which returns both\n        :param depth: Filter by key depth. Default is None for standard key depth. Use -1 to show all keys\n        :type depth: int\n        :param key_id: Key ID to get address of just 1 key\n        :type key_id: int\n\n        :return list of str: List of address strings\n        \"\"\"\n\n        addresslist = []\n        if depth is None:\n            depth = self.key_depth\n        elif depth == -1:\n            depth = None\n        for key in self.keys(account_id=account_id, depth=depth, used=used, network=network, change=change,\n                             key_id=key_id, is_active=False):\n            addresslist.append(key.address)\n        return addresslist",
  "def key(self, term):\n        \"\"\"\n        Return single key with given ID or name as WalletKey object\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.key('change 0').address\n        '1HabJXe8mTwXiMzUWW5KdpYbFWu3hvtsbF'\n\n        :param term: Search term can be key ID, key address, key WIF or key name\n        :type term: int, str\n\n        :return WalletKey: Single key as object\n        \"\"\"\n\n        dbkey = None\n        qr = self._session.query(DbKey).filter_by(wallet_id=self.wallet_id)\n        if self.purpose:\n            qr = qr.filter_by(purpose=self.purpose)\n        if isinstance(term, numbers.Number):\n            dbkey = qr.filter_by(id=term).scalar()\n        if not dbkey:\n            dbkey = qr.filter_by(address=term).first()\n        if not dbkey:\n            dbkey = qr.filter_by(wif=term).first()\n        if not dbkey:\n            dbkey = qr.filter_by(name=term).first()\n        if dbkey:\n            if dbkey.id in self._key_objects.keys():\n                return self._key_objects[dbkey.id]\n            else:\n                hdwltkey = WalletKey(key_id=dbkey.id, session=self._session)\n                self._key_objects.update({dbkey.id: hdwltkey})\n                return hdwltkey\n        else:\n            raise BKeyError(\"Key '%s' not found\" % term)",
  "def account(self, account_id):\n        \"\"\"\n        Returns wallet key of specific BIP44 account.\n\n        Account keys have a BIP44 path depth of 3 and have the format m/purpose'/network'/account'\n\n        I.e: Use account(0).key().wif_public() to get wallet's public master key\n\n        :param account_id: ID of account. Default is 0\n        :type account_id: int\n\n        :return WalletKey:\n        \"\"\"\n\n        if \"account'\" not in self.key_path:\n            raise WalletError(\"Accounts are not supported for this wallet. Account not found in key path %s\" %\n                              self.key_path)\n        qr = self._session.query(DbKey).\\\n            filter_by(wallet_id=self.wallet_id, purpose=self.purpose, network_name=self.network.name,\n                      account_id=account_id, depth=3).scalar()\n        if not qr:\n            raise WalletError(\"Account with ID %d not found in this wallet\" % account_id)\n        key_id = qr.id\n        return self.key(key_id)",
  "def accounts(self, network=DEFAULT_NETWORK):\n        \"\"\"\n        Get list of accounts for this wallet\n\n        :param network: Network name filter. Default filter is DEFAULT_NETWORK\n        :type network: str\n\n        :return list of integers: List of accounts IDs\n        \"\"\"\n\n        if self.multisig and self.cosigner:\n            if self.cosigner_id is None:\n                raise WalletError(\"Missing Cosigner ID value for this wallet, cannot fetch account ID\")\n            accounts = [wk.account_id for wk in self.cosigner[self.cosigner_id].keys_accounts(network=network)]\n        else:\n            accounts = [wk.account_id for wk in self.keys_accounts(network=network)]\n        if not accounts:\n            accounts = [self.default_account_id]\n        return list(dict.fromkeys(accounts))",
  "def networks(self, as_dict=False):\n        \"\"\"\n        Get list of networks used by this wallet\n\n        :param as_dict: Return as dictionary or as Network objects, default is Network objects\n        :type as_dict: bool\n\n        :return list of (Network, dict):\n        \"\"\"\n\n        nw_list = [self.network]\n        if self.multisig and self.cosigner:\n            keys_qr = self._session.query(DbKey.network_name).\\\n                filter_by(wallet_id=self.wallet_id, depth=self.key_depth).\\\n                group_by(DbKey.network_name).all()\n            nw_list += [Network(nw[0]) for nw in keys_qr]\n        elif self.main_key.key_type != 'single':\n            wks = self.keys_networks()\n            for wk in wks:\n                nw_list.append(Network(wk.network_name))\n\n        networks = []\n        nw_list = list(dict.fromkeys(nw_list))\n        for nw in nw_list:\n            if as_dict:\n                nw = nw.__dict__\n                if '_sa_instance_state' in nw:\n                    del nw['_sa_instance_state']\n            networks.append(nw)\n\n        return networks",
  "def network_list(self, field='name'):\n        \"\"\"\n        Wrapper for :func:`networks` method, returns a flat list with currently used\n        networks for this wallet.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.network_list()\n        ['bitcoin']\n\n        :return list of str:\n        \"\"\"\n\n        return [getattr(x, field) for x in self.networks()]",
  "def balance_update_from_serviceprovider(self, account_id=None, network=None):\n        \"\"\"\n        Update balance of currents account addresses using default Service objects :func:`getbalance` method. Update total\n        wallet balance in database.\n\n        Please Note: Does not update UTXO's or the balance per key! For this use the :func:`updatebalance` method\n        instead\n\n        :param account_id: Account ID. Leave empty for default account\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return int: Total balance\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        balance = srv.getbalance(self.addresslist(account_id=account_id, network=network))\n        if srv.results:\n            new_balance = {\n                'account_id': account_id,\n                'network': network,\n                'balance': balance\n            }\n            old_balance_item = [bi for bi in self._balances if bi['network'] == network and\n                                bi['account_id'] == account_id]\n            if old_balance_item:\n                item_n = self._balances.index(old_balance_item[0])\n                self._balances[item_n] = new_balance\n            else:\n                self._balances.append(new_balance)\n        return balance",
  "def balance(self, account_id=None, network=None, as_string=False):\n        \"\"\"\n        Get total of unspent outputs\n\n        :param account_id: Account ID filter\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param as_string: Set True to return a string in currency format. Default returns float.\n        :type as_string: boolean\n\n        :return float, str: Key balance\n        \"\"\"\n\n        self._balance_update(account_id, network)\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n\n        balance = 0\n        b_res = [b['balance'] for b in self._balances if b['account_id'] == account_id and b['network'] == network]\n        if len(b_res):\n            balance = b_res[0]\n        if as_string:\n            return Value.from_satoshi(balance, network=network).str_unit()\n        else:\n            return float(balance)",
  "def _balance_update(self, account_id=None, network=None, key_id=None, min_confirms=0):\n        \"\"\"\n        Update balance from UTXO's in database. To get most recent balance use :func:`utxos_update` first.\n\n        Also updates balance of wallet and keys in this wallet for the specified account or all accounts if\n        no account is specified.\n\n        :param account_id: Account ID filter\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param key_id: Key ID Filter\n        :type key_id: int\n        :param min_confirms: Minimal confirmations needed to include in balance (default = 0)\n        :type min_confirms: int\n\n        :return: Updated balance\n        \"\"\"\n\n        qr = self._session.query(DbTransactionOutput, func.sum(DbTransactionOutput.value), DbTransaction.network_name,\n                                 DbTransaction.account_id).\\\n            join(DbTransaction). \\\n            filter(DbTransactionOutput.spent.is_(False),\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.confirmations >= min_confirms)\n        if account_id is not None:\n            qr = qr.filter(DbTransaction.account_id == account_id)\n        if network is not None:\n            qr = qr.filter(DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionOutput.key_id == key_id)\n        else:\n            qr = qr.filter(DbTransactionOutput.key_id.isnot(None))\n        utxos = qr.group_by(\n            DbTransactionOutput.key_id,\n            DbTransactionOutput.transaction_id,\n            DbTransactionOutput.output_n,\n            DbTransaction.network_name,\n            DbTransaction.account_id\n        ).all()\n\n        key_values = [\n            {\n                'id': utxo[0].key_id,\n                'network': utxo[2],\n                'account_id': utxo[3],\n                'balance': utxo[1]\n            }\n            for utxo in utxos\n        ]\n\n        grouper = itemgetter(\"id\", \"network\", \"account_id\")\n        key_balance_list = []\n        for key, grp in groupby(sorted(key_values, key=grouper), grouper):\n            nw_acc_dict = dict(zip([\"id\", \"network\", \"account_id\"], key))\n            nw_acc_dict[\"balance\"] = sum(item[\"balance\"] for item in grp)\n            key_balance_list.append(nw_acc_dict)\n\n        grouper = itemgetter(\"network\", \"account_id\")\n        balance_list = []\n        for key, grp in groupby(sorted(key_balance_list, key=grouper), grouper):\n            nw_acc_dict = dict(zip([\"network\", \"account_id\"], key))\n            nw_acc_dict[\"balance\"] = sum(item[\"balance\"] for item in grp)\n            balance_list.append(nw_acc_dict)\n\n        # Add keys with no UTXO's with 0 balance\n        for key in self.keys(account_id=account_id, network=network, key_id=key_id):\n            if key.id not in [utxo[0].key_id for utxo in utxos]:\n                key_balance_list.append({\n                    'id': key.id,\n                    'network': network,\n                    'account_id': key.account_id,\n                    'balance': 0\n                })\n\n        if not key_id:\n            for bl in balance_list:\n                bl_item = [b for b in self._balances if\n                           b['network'] == bl['network'] and b['account_id'] == bl['account_id']]\n                if not bl_item:\n                    self._balances.append(bl)\n                    continue\n                lx = self._balances.index(bl_item[0])\n                self._balances[lx].update(bl)\n\n        self._balance = sum([b['balance'] for b in balance_list if b['network'] == self.network.name])\n\n        # Bulk update database\n        for kb in key_balance_list:\n            if kb['id'] in self._key_objects:\n                self._key_objects[kb['id']]._balance = kb['balance']\n        self._session.bulk_update_mappings(DbKey, key_balance_list)\n        self._commit()\n        _logger.info(\"Got balance for %d key(s)\" % len(key_balance_list))\n        return self._balances",
  "def utxos_update(self, account_id=None, used=None, networks=None, key_id=None, depth=None, change=None,\n                     utxos=None, update_balance=True, max_utxos=MAX_TRANSACTIONS, rescan_all=True):\n        \"\"\"\n        Update UTXO's (Unspent Outputs) for addresses/keys in this wallet using various Service providers.\n\n        This method does not import transactions: use :func:`transactions_update` function or to look for new addresses use :func:`scan`.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only check for UTXO for used or unused keys. Default is both\n        :type used: bool\n        :param networks: Network name filter as string or list of strings. Leave empty to update all used networks in wallet\n        :type networks: str, list\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n        :param depth: Only update keys with this depth, default is depth 5 according to BIP0048 standard. Set depth to None to update all keys of this wallet.\n        :type depth: int\n        :param change: Only update change or normal keys, default is both (None)\n        :type change: int\n        :param utxos: List of unspent outputs in dictionary format specified below. For usage on an offline PC, you can import utxos with the utxos parameter as a list of dictionaries\n        :type utxos: list of dict.\n\n        .. code-block:: json\n\n            {\n              \"address\": \"n2S9Czehjvdmpwd2YqekxuUC1Tz5ZdK3YN\",\n              \"script\": \"\",\n              \"confirmations\": 10,\n              \"output_n\": 1,\n              \"txid\": \"9df91f89a3eb4259ce04af66ad4caf3c9a297feea5e0b3bc506898b6728c5003\",\n              \"value\": 8970937\n            }\n\n        :param update_balance: Option to disable balance update after fetching UTXO's. Can be used when utxos_update method is called several times in a row. Default is True\n        :type update_balance: bool\n        :param max_utxos: Maximum number of UTXO's to update\n        :type max_utxos: int\n        :param rescan_all: Remove old utxo's and rescan wallet. Default is True. Set to False if you work with large utxo's sets. Value will be ignored if key_id is specified in your call\n        :type rescan_all: bool\n\n        :return int: Number of new UTXO's added\n        \"\"\"\n\n        _, account_id, acckey = self._get_account_defaults('', account_id, key_id)\n\n        single_key = None\n        if key_id:\n            single_key = self._session.query(DbKey).filter_by(id=key_id).scalar()\n            networks = [single_key.network_name]\n            account_id = single_key.account_id\n            rescan_all = False\n        if networks is None:\n            networks = self.network_list()\n        elif not isinstance(networks, list):\n            networks = [networks]\n        elif len(networks) != 1 and utxos is not None:\n            raise WalletError(\"Please specify maximum 1 network when passing utxo's\")\n\n        count_utxos = 0\n        for network in networks:\n            # Remove current UTXO's\n            if rescan_all:\n                cur_utxos = self._session.query(DbTransactionOutput). \\\n                    join(DbTransaction). \\\n                    filter(DbTransactionOutput.spent.is_(False),\n                           DbTransaction.account_id == account_id,\n                           DbTransaction.wallet_id == self.wallet_id,\n                           DbTransaction.network_name == network).all()\n                for u in cur_utxos:\n                    self._session.query(DbTransactionOutput).filter_by(\n                        transaction_id=u.transaction_id, output_n=u.output_n).update({DbTransactionOutput.spent: True})\n                self._commit()\n\n            if account_id is None and not self.multisig:\n                accounts = self.accounts(network=network)\n            else:\n                accounts = [account_id]\n            for account_id in accounts:\n                if depth is None:\n                    depth = self.key_depth\n                if utxos is None:\n                    # Get all UTXO's for this wallet from default Service object\n                    addresslist = self.addresslist(account_id=account_id, used=used, network=network, key_id=key_id,\n                                                   change=change, depth=depth)\n                    random.shuffle(addresslist)\n                    srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n                    srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n                    utxos = []\n                    for address in addresslist:\n                        if rescan_all:\n                            last_txid = ''\n                        else:\n                            last_txid = self.utxo_last(address)\n                        new_utxos = srv.getutxos(address, after_txid=last_txid, limit=max_utxos)\n                        if new_utxos:\n                            utxos += new_utxos\n                        elif new_utxos is False:\n                            raise WalletError(\"No response from any service provider, could not update UTXO's. \"\n                                              \"Errors: %s\" % srv.errors)\n                    if srv.complete:\n                        self.last_updated = datetime.now()\n                    elif utxos and 'date' in utxos[-1:][0]:\n                        self.last_updated = utxos[-1:][0]['date']\n\n                # If UTXO is new, add to database otherwise update depth (confirmation count)\n                for utxo in utxos:\n                    key = single_key\n                    if not single_key:\n                        key = self._session.query(DbKey).\\\n                            filter_by(wallet_id=self.wallet_id, address=utxo['address']).scalar()\n                    if not key:\n                        raise WalletError(\"Key with address %s not found in this wallet\" % utxo['address'])\n                    key.used = True\n                    status = 'unconfirmed'\n                    if utxo['confirmations']:\n                        status = 'confirmed'\n\n                    # Update confirmations in db if utxo was already imported\n                    transaction_in_db = self._session.query(DbTransaction).\\\n                        filter_by(wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']),\n                                  network_name=network)\n                    utxo_in_db = self._session.query(DbTransactionOutput).join(DbTransaction).\\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransaction.txid == bytes.fromhex(utxo['txid']),\n                               DbTransactionOutput.output_n == utxo['output_n'])\n                    spent_in_db = self._session.query(DbTransactionInput).join(DbTransaction).\\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransactionInput.prev_txid == bytes.fromhex(utxo['txid']),\n                               DbTransactionInput.output_n == utxo['output_n'])\n                    if utxo_in_db.count():\n                        utxo_record = utxo_in_db.scalar()\n                        if not utxo_record.key_id:\n                            count_utxos += 1\n                        utxo_record.key_id = key.id\n                        utxo_record.spent = bool(spent_in_db.count())\n                        if transaction_in_db.count():\n                            transaction_record = transaction_in_db.scalar()\n                            transaction_record.confirmations = utxo['confirmations']\n                            transaction_record.status = status\n                    else:\n                        # Add transaction if not exist and then add output\n                        if not transaction_in_db.count():\n                            block_height = None\n                            if block_height in utxo and utxo['block_height']:\n                                block_height = utxo['block_height']\n                            new_tx = DbTransaction(\n                                wallet_id=self.wallet_id, txid=bytes.fromhex(utxo['txid']), status=status,\n                                is_complete=False, block_height=block_height, account_id=account_id,\n                                confirmations=utxo['confirmations'], network_name=network)\n                            self._session.add(new_tx)\n                            # TODO: Get unique id before inserting to increase performance for large utxo-sets\n                            self._commit()\n                            tid = new_tx.id\n                        else:\n                            tid = transaction_in_db.scalar().id\n\n                        script_type = script_type_default(self.witness_type, multisig=self.multisig,\n                                                          locking_script=True)\n                        new_utxo = DbTransactionOutput(transaction_id=tid,  output_n=utxo['output_n'],\n                                                       value=utxo['value'], key_id=key.id, address=utxo['address'],\n                                                       script=bytes.fromhex(utxo['script']),\n                                                       script_type=script_type,\n                                                       spent=bool(spent_in_db.count()))\n                        self._session.add(new_utxo)\n                        count_utxos += 1\n\n                    self._commit()\n\n                _logger.info(\"Got %d new UTXOs for account %s\" % (count_utxos, account_id))\n                self._commit()\n                if update_balance:\n                    self._balance_update(account_id=account_id, network=network, key_id=key_id, min_confirms=0)\n                utxos = None\n        return count_utxos",
  "def utxos(self, account_id=None, network=None, min_confirms=0, key_id=None):\n        \"\"\"\n        Get UTXO's (Unspent Outputs) from database. Use :func:`utxos_update` method first for updated values\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.utxos()  # doctest:+SKIP\n        [{'value': 100000000, 'script': '', 'output_n': 0, 'transaction_id': ..., 'spent': False, 'script_type': 'p2pkh', 'key_id': ..., 'address': '16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', 'confirmations': 0, 'txid': '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', 'network_name': 'bitcoin'}]\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param min_confirms: Minimal confirmation needed to include in output list\n        :type min_confirms: int\n        :param key_id: Key ID or list of key IDs to filter utxo's for specific keys\n        :type key_id: int, list\n\n        :return list: List of transactions\n        \"\"\"\n\n        first_key_id = key_id\n        if isinstance(key_id, list):\n            first_key_id = key_id[0]\n        network, account_id, acckey = self._get_account_defaults(network, account_id, first_key_id)\n\n        qr = self._session.query(DbTransactionOutput, DbKey.address, DbTransaction.confirmations, DbTransaction.txid,\n                                 DbKey.network_name).\\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransactionOutput.spent.is_(False),\n                   DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network,\n                   DbTransaction.confirmations >= min_confirms)\n        if isinstance(key_id, int):\n            qr = qr.filter(DbKey.id == key_id)\n        elif isinstance(key_id, list):\n            qr = qr.filter(DbKey.id.in_(key_id))\n        utxos = qr.order_by(DbTransaction.confirmations.desc()).all()\n        res = []\n        for utxo in utxos:\n            u = utxo[0].__dict__\n            if '_sa_instance_state' in u:\n                del u['_sa_instance_state']\n            u['address'] = utxo[1]\n            u['confirmations'] = int(utxo[2])\n            u['txid'] = utxo[3].hex()\n            u['network_name'] = utxo[4]\n            res.append(u)\n        return res",
  "def utxo_add(self, address, value, txid, output_n, confirmations=1, script=''):\n        \"\"\"\n        Add a single UTXO to the wallet database. To update all utxo's use :func:`utxos_update` method.\n\n        Use this method for testing, offline wallets or if you wish to override standard method of retreiving UTXO's\n\n        This method does not check if UTXO exists or is still spendable.\n\n        :param address: Address of Unspent Output. Address should be available in wallet\n        :type address: str\n        :param value: Value of output in sathosis or smallest denominator for type of currency\n        :type value: int\n        :param txid: Transaction hash or previous output as hex-string\n        :type txid: str\n        :param output_n: Output number of previous transaction output\n        :type output_n: int\n        :param confirmations: Number of confirmations. Default is 0, unconfirmed\n        :type confirmations: int\n        :param script: Locking script of previous output as hex-string\n        :type script: str\n\n        :return int: Number of new UTXO's added, so 1 if successful\n        \"\"\"\n\n        utxo = {\n            'address': address,\n            'script': script,\n            'confirmations': confirmations,\n            'output_n': output_n,\n            'txid': txid,\n            'value': value\n        }\n        return self.utxos_update(utxos=[utxo])",
  "def utxo_last(self, address):\n        \"\"\"\n        Get transaction ID for latest utxo in database for given address\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.utxo_last('16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg')\n        '748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4'\n\n        :param address: The address\n        :type address: str\n\n        :return str:\n        \"\"\"\n        to = self._session.query(\n            DbTransaction.txid, DbTransaction.confirmations). \\\n            join(DbTransactionOutput).join(DbKey). \\\n            filter(DbKey.address == address, DbTransaction.wallet_id == self.wallet_id,\n                   DbTransactionOutput.spent.is_(False)). \\\n            order_by(DbTransaction.confirmations).first()\n        return '' if not to else to[0].hex()",
  "def transactions_update_confirmations(self):\n        \"\"\"\n        Update number of confirmations and status for transactions in database\n\n        :return:\n        \"\"\"\n        network = self.network.name\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        blockcount = srv.blockcount()\n        db_txs = self._session.query(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()\n        for db_tx in db_txs:\n            self._session.query(DbTransaction).filter_by(id=db_tx.id). \\\n                update({DbTransaction.status: 'confirmed',\n                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})\n        self._commit()",
  "def transactions_update_by_txids(self, txids):\n        \"\"\"\n        Update transaction or list or transaction for this wallet with provided transaction ID\n\n        :param txids: Transaction ID, or list of transaction IDs\n        :type txids: str, list of str, bytes, list of bytes\n\n        :return:\n        \"\"\"\n        if not isinstance(txids, list):\n            txids = [txids]\n        txids = list(dict.fromkeys(txids))\n\n        txs = []\n        srv = Service(network=self.network.name, providers=self.providers, cache_uri=self.db_cache_uri)\n        for txid in txids:\n            tx = srv.gettransaction(to_hexstring(txid))\n            if tx:\n                txs.append(tx)\n\n        # TODO: Avoid duplicate code in this method and transaction_update()\n        utxo_set = set()\n        for t in txs:\n            wt = WalletTransaction.from_transaction(self, t)\n            wt.store()\n            utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]\n            utxo_set.update(utxos)\n\n        for utxo in list(utxo_set):\n            tos = self._session.query(DbTransactionOutput).join(DbTransaction). \\\n                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],\n                       DbTransactionOutput.spent.is_(False)).all()\n            for u in tos:\n                u.spent = True\n        self._commit()",
  "def transactions_update(self, account_id=None, used=None, network=None, key_id=None, depth=None, change=None,\n                            limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Update wallets transaction from service providers. Get all transactions for known keys in this wallet. The balances and unspent outputs (UTXO's) are updated as well. Only scan keys from default network and account unless another network or account is specified.\n\n        Use the :func:`scan` method for automatic address generation/management, and use the :func:`utxos_update` method to only look for unspent outputs and balances.\n\n        :param account_id: Account ID\n        :type account_id: int\n        :param used: Only update used or unused keys, specify None to update both. Default is None\n        :type used: bool, None\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param key_id: Key ID to just update 1 key\n        :type key_id: int\n        :param depth: Only update keys with this depth, default is depth 5 according to BIP0048 standard. Set depth to None to update all keys of this wallet.\n        :type depth: int\n        :param change: Only update change or normal keys, default is both (None)\n        :type change: int\n        :param limit: Stop update after limit transactions to avoid timeouts with service providers. Default is MAX_TRANSACTIONS defined in config.py\n        :type limit: int\n\n        :return bool: True if all transactions are updated\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)\n        if depth is None:\n            depth = self.key_depth\n\n        # Update number of confirmations and status for already known transactions\n        if not key_id:\n            self.transactions_update_confirmations()\n\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        blockcount = srv.blockcount()\n        db_txs = self._session.query(DbTransaction).\\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network, DbTransaction.block_height > 0).all()\n        for db_tx in db_txs:\n            self._session.query(DbTransaction).filter_by(id=db_tx.id).\\\n                update({DbTransaction.status: 'confirmed',\n                        DbTransaction.confirmations: (blockcount - DbTransaction.block_height) + 1})\n        self._commit()\n\n        # Get transactions for wallet's addresses\n        txs = []\n        addresslist = self.addresslist(\n            account_id=account_id, used=used, network=network, key_id=key_id, change=change, depth=depth)\n        last_updated = datetime.now()\n        for address in addresslist:\n            txs += srv.gettransactions(address, limit=limit, after_txid=self.transaction_last(address))\n            if not srv.complete:\n                if txs and txs[-1].date and txs[-1].date < last_updated:\n                    last_updated = txs[-1].date\n            if txs and txs[-1].confirmations:\n                dbkey = self._session.query(DbKey).filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id)\n                if not dbkey.update({DbKey.latest_txid: bytes.fromhex(txs[-1].txid)}):\n                    raise WalletError(\"Failed to update latest transaction id for key with address %s\" % address)\n                self._commit()\n        if txs is False:\n            raise WalletError(\"No response from any service provider, could not update transactions\")\n\n        # Update Transaction outputs to get list of unspent outputs (UTXO's)\n        utxo_set = set()\n        for t in txs:\n            wt = WalletTransaction.from_transaction(self, t)\n            wt.store()\n            utxos = [(ti.prev_txid.hex(), ti.output_n_int) for ti in wt.inputs]\n            utxo_set.update(utxos)\n        for utxo in list(utxo_set):\n            tos = self._session.query(DbTransactionOutput).join(DbTransaction).\\\n                filter(DbTransaction.txid == bytes.fromhex(utxo[0]), DbTransactionOutput.output_n == utxo[1],\n                       DbTransactionOutput.spent.is_(False), DbTransaction.wallet_id == self.wallet_id).all()\n            for u in tos:\n                u.spent = True\n\n        self.last_updated = last_updated\n        self._commit()\n        self._balance_update(account_id=account_id, network=network, key_id=key_id)\n\n        return len(txs)",
  "def transaction_last(self, address):\n        \"\"\"\n        Get transaction ID for latest transaction in database for given address\n\n        :param address: The address\n        :type address: str\n\n        :return str:\n        \"\"\"\n        txid = self._session.query(DbKey.latest_txid).\\\n            filter(DbKey.address == address, DbKey.wallet_id == self.wallet_id).scalar()\n        return '' if not txid else txid.hex()",
  "def transactions(self, account_id=None, network=None, include_new=False, key_id=None, as_dict=False):\n        \"\"\"\n        Get all known transactions input and outputs for this wallet.\n\n        The transaction only includes the inputs and outputs related to this wallet. To get full transactions\n        use the :func:`transactions_full` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.transactions()\n        [<WalletTransaction(input_count=0, output_count=1, status=confirmed, network=bitcoin)>]\n\n        :param account_id: Filter by Account ID. Leave empty for default account_id\n        :type account_id: int, None\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str, None\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param key_id: Filter by key ID\n        :type key_id: int, None\n        :param as_dict: Output as dictionary or WalletTransaction object\n        :type as_dict: bool\n\n        :return list of WalletTransaction: List of WalletTransaction or transactions as dictionary\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id, key_id)\n        # Transaction inputs\n        qr = self._session.query(DbTransactionInput, DbTransactionInput.address, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbKey.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionInput.key_id == key_id)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs = qr.all()\n        # Transaction outputs\n        qr = self._session.query(DbTransactionOutput, DbTransactionOutput.address, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.account_id == account_id,\n                   DbTransaction.wallet_id == self.wallet_id,\n                   DbKey.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if key_id is not None:\n            qr = qr.filter(DbTransactionOutput.key_id == key_id)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs += qr.all()\n\n        txs = sorted(txs, key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True)\n        res = []\n        txids = []\n        for tx in txs:\n            txid = tx[3].hex()\n            if as_dict:\n                u = tx[0].__dict__\n                u['block_height'] = tx[0].transaction.block_height\n                u['date'] = tx[0].transaction.date\n                if '_sa_instance_state' in u:\n                    del u['_sa_instance_state']\n                u['address'] = tx[1]\n                u['confirmations'] = None if tx[2] is None else int(tx[2])\n                u['txid'] = txid\n                u['network_name'] = tx[4]\n                u['status'] = tx[5]\n                if 'index_n' in u:\n                    u['is_output'] = True\n                    u['value'] = -u['value']\n                else:\n                    u['is_output'] = False\n            else:\n                if txid in txids:\n                    continue\n                txids.append(txid)\n                u = self.transaction(txid)\n            res.append(u)\n        return res",
  "def transactions_full(self, network=None, include_new=False, limit=0, offset=0):\n        \"\"\"\n        Get all transactions of this wallet as WalletTransaction objects\n\n        Use the :func:`transactions` method to only get the inputs and outputs transaction parts related to this wallet\n\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param limit: Maximum number of transactions to return. Combine with offset parameter to use as pagination\n        :type limit: int\n        :param offset: Number of transactions to skip\n        :type offset: int\n\n        :return list of WalletTransaction:\n        \"\"\"\n        network, _, _ = self._get_account_defaults(network)\n        qr = self._session.query(DbTransaction.txid, DbTransaction.network_name, DbTransaction.status). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransaction.network_name == network)\n        if not include_new:\n            qr = qr.filter(or_(DbTransaction.status == 'confirmed', DbTransaction.status == 'unconfirmed'))\n        txs = []\n        if limit:\n            qr = qr.limit(limit)\n        if offset:\n            qr = qr.offset(offset)\n        for tx in qr.all():\n            txs.append(self.transaction(tx[0].hex()))\n        return txs",
  "def transactions_export(self, account_id=None, network=None, include_new=False, key_id=None, skip_change=True):\n        \"\"\"\n        Export wallets transactions as list of tuples with the following fields:\n            (transaction_date, transaction_hash, in/out, addresses_in, addresses_out, value, value_cumulative, fee)\n\n        :param account_id: Filter by Account ID. Leave empty for default account_id\n        :type account_id: int, None\n        :param network: Filter by network name. Leave empty for default network\n        :type network: str, None\n        :param include_new: Also include new and incomplete transactions in list. Default is False\n        :type include_new: bool\n        :param key_id: Filter by key ID\n        :type key_id: int, None\n        :param skip_change: Do not include change outputs. Default is True\n        :type skip_change: bool\n\n        :return list of tuple:\n        \"\"\"\n\n        txs_tuples = []\n        cumulative_value = 0\n        for t in self.transactions(account_id, network, include_new, key_id):\n            te = t.export(skip_change=skip_change)\n\n            # When transaction is outgoing deduct fee from cumulative value\n            if t.outgoing_tx:\n                cumulative_value -= t.fee\n\n            # Loop through all transaction inputs and outputs\n            for tei in te:\n                # Create string with  list of inputs addresses for incoming transactions, and outputs addresses\n                # for outgoing txs\n                addr_list_in = tei[3] if isinstance(tei[3], list) else [tei[3]]\n                addr_list_out = tei[4] if isinstance(tei[4], list) else [tei[4]]\n                cumulative_value += tei[5]\n                txs_tuples.append((tei[0], tei[1], tei[2], addr_list_in, addr_list_out, tei[5], cumulative_value,\n                                   tei[6]))\n        return txs_tuples",
  "def transaction(self, txid):\n        \"\"\"\n        Get WalletTransaction object for given transaction ID (transaction hash)\n\n        :param txid: Hexadecimal transaction hash\n        :type txid: str\n\n        :return WalletTransaction:\n        \"\"\"\n        return WalletTransaction.from_txid(self, txid)",
  "def transaction_spent(self, txid, output_n):\n        \"\"\"\n        Check if transaction with given transaction ID and output_n is spent and return txid of spent transaction.\n\n        Retrieves information from database, does not update transaction and does not check if transaction is spent with service providers.\n\n        :param txid: Hexadecimal transaction hash\n        :type txid: str, bytes\n        :param output_n: Output n\n        :type output_n: int, bytes\n\n        :return str: Transaction ID\n        \"\"\"\n        txid = to_bytes(txid)\n        if isinstance(output_n, bytes):\n            output_n = int.from_bytes(output_n, 'big')\n        qr = self._session.query(DbTransactionInput, DbTransaction.confirmations,\n                                 DbTransaction.txid, DbTransaction.status). \\\n            join(DbTransaction). \\\n            filter(DbTransaction.wallet_id == self.wallet_id,\n                   DbTransactionInput.prev_txid == txid, DbTransactionInput.output_n == output_n).scalar()\n        if qr:\n            return qr.transaction.txid.hex()",
  "def _objects_by_key_id(self, key_id):\n        key = self._session.query(DbKey).filter_by(id=key_id).scalar()\n        if not key:\n            raise WalletError(\"Key '%s' not found in this wallet\" % key_id)\n        if key.key_type == 'multisig':\n            inp_keys = [HDKey.from_wif(ck.child_key.wif, network=ck.child_key.network_name) for ck in\n                        key.multisig_children]\n        elif key.key_type in ['bip32', 'single']:\n            if not key.wif:\n                raise WalletError(\"WIF of key is empty cannot create HDKey\")\n            inp_keys = [HDKey.from_wif(key.wif, network=key.network_name)]\n        else:\n            raise WalletError(\"Input key type %s not supported\" % key.key_type)\n        return inp_keys, key",
  "def select_inputs(self, amount, variance=None, input_key_id=None, account_id=None, network=None, min_confirms=1,\n                      max_utxos=None, return_input_obj=True, skip_dust_amounts=True):\n        \"\"\"\n        Select available unspent transaction outputs (UTXO's) which can be used as inputs for a transaction for\n        the specified amount.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.select_inputs(50000000)\n        [<Input(prev_txid='748799c9047321cb27a6320a827f1f69d767fe889c14bf11f27549638d566fe4', output_n=0, address='16QaHuFkfuebXGcYHmehRXBBX7RG9NbtLg', index_n=0, type='sig_pubkey')>]\n\n        :param amount: Total value of inputs in the smallest denominator (sathosi) to select\n        :type amount: int\n        :param variance: Allowed difference in total input value. Default is dust amount of selected network. Difference will be added to transaction fee.\n        :type variance: int\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1 confirmation. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param return_input_obj: Return inputs as Input class object. Default is True\n        :type return_input_obj: bool\n        :param skip_dust_amounts: Do not include small amount to avoid dust inputs\n        :type skip_dust_amounts: bool\n\n        :return: List of previous outputs\n        :rtype: list of DbTransactionOutput, list of Input\n        \"\"\"\n\n        network, account_id, _ = self._get_account_defaults(network, account_id)\n        dust_amount = Network(network).dust_amount\n        if variance is None:\n            variance = dust_amount\n\n        utxo_query = self._session.query(DbTransactionOutput).join(DbTransaction).join(DbKey). \\\n            filter(DbTransaction.wallet_id == self.wallet_id, DbTransaction.account_id == account_id,\n                   DbTransaction.network_name == network, DbKey.public != b'',\n                   DbTransactionOutput.spent.is_(False), DbTransaction.confirmations >= min_confirms)\n        if input_key_id:\n            if isinstance(input_key_id, int):\n                utxo_query = utxo_query.filter(DbKey.id == input_key_id)\n            else:\n                utxo_query = utxo_query.filter(DbKey.id.in_(input_key_id))\n        if skip_dust_amounts:\n            utxo_query = utxo_query.filter(DbTransactionOutput.value > dust_amount)\n        utxos = utxo_query.order_by(DbTransaction.confirmations.desc()).all()\n        if not utxos:\n            raise WalletError(\"Create transaction: No unspent transaction outputs found or no key available for UTXO's\")\n\n        # TODO: Find 1 or 2 UTXO's with exact amount +/- self.network.dust_amount\n\n        # Try to find one utxo with exact amount\n        one_utxo = utxo_query.filter(DbTransactionOutput.spent.is_(False),\n                                     DbTransactionOutput.value >= amount,\n                                     DbTransactionOutput.value <= amount + variance).first()\n        selected_utxos = []\n        if one_utxo:\n            selected_utxos = [one_utxo]\n        else:\n            # Try to find one utxo with higher amount\n            one_utxo = utxo_query. \\\n                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value >= amount).\\\n                order_by(DbTransactionOutput.value).first()\n            if one_utxo:\n                selected_utxos = [one_utxo]\n            elif max_utxos and max_utxos <= 1:\n                _logger.info(\"No single UTXO found with requested amount, use higher 'max_utxo' setting to use \"\n                             \"multiple UTXO's\")\n                return []\n\n        # Otherwise compose of 2 or more lesser outputs\n        if not selected_utxos:\n            lessers = utxo_query. \\\n                filter(DbTransactionOutput.spent.is_(False), DbTransactionOutput.value < amount).\\\n                order_by(DbTransactionOutput.value.desc()).all()\n            total_amount = 0\n            selected_utxos = []\n            for utxo in lessers[:max_utxos]:\n                if total_amount < amount:\n                    selected_utxos.append(utxo)\n                    total_amount += utxo.value\n            if total_amount < amount:\n                return []\n        if not return_input_obj:\n            return selected_utxos\n        else:\n            inputs = []\n            for utxo in selected_utxos:\n                # amount_total_input += utxo.value\n                inp_keys, key = self._objects_by_key_id(utxo.key_id)\n                multisig = False if len(inp_keys) < 2 else True\n                script_type = get_unlocking_script_type(utxo.script_type, multisig=multisig)\n                inputs.append(Input(utxo.transaction.txid, utxo.output_n, keys=inp_keys, script_type=script_type,\n                              sigs_required=self.multisig_n_required, sort=self.sort_keys, address=key.address,\n                              compressed=key.compressed, value=utxo.value, network=key.network_name))\n            return inputs",
  "def transaction_create(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,\n                           min_confirms=1, max_utxos=None, locktime=0, number_of_change_outputs=1,\n                           random_output_order=True):\n        \"\"\"\n        Create new transaction with specified outputs.\n\n        Inputs can be specified but if not provided they will be selected from wallets utxo's with :func:`select_inputs` method.\n\n        Output array is a list of 1 or more addresses and amounts.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.transaction_create([('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000)])\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param output_arr: List of output as Output objects or tuples with address and amount. Must contain at least one item. Example: [('mxdLD8SAGS9fe2EeCXALDHcdTTbppMHp8N', 5000000)]\n        :type output_arr: list of Output, tuple\n        :param input_arr: List of inputs as Input objects or tuples with reference to a UTXO, a wallet key and value. The format is [(txid, output_n, key_ids, value, signatures, unlocking_script, address)]\n        :type input_arr: list of Input, tuple\n        :param input_key_id: Limit UTXO's search for inputs to this key_id. Only valid if no input array is specified\n        :type input_key_id: int\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1 confirmation. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount        :type number_of_change_outputs: int\n        :type number_of_change_outputs: int\n        :param random_output_order: Shuffle order of transaction outputs to increase privacy. Default is True\n        :type random_output_order: bool\n\n        :return WalletTransaction: object\n        \"\"\"\n\n        if not isinstance(output_arr, list):\n            raise WalletError(\"Output array must be a list of tuples with address and amount. \"\n                              \"Use 'send_to' method to send to one address\")\n        if not network and output_arr:\n            if isinstance(output_arr[0], Output):\n                network = output_arr[0].network.name\n            elif isinstance(output_arr[0][1], str):\n                network = Value(output_arr[0][1]).network.name\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n\n        if input_arr and max_utxos and len(input_arr) > max_utxos:\n            raise WalletError(\"Input array contains %d UTXO's but max_utxos=%d parameter specified\" %\n                              (len(input_arr), max_utxos))\n\n        # Create transaction and add outputs\n        amount_total_output = 0\n        transaction = WalletTransaction(hdwallet=self, account_id=account_id, network=network, locktime=locktime)\n        transaction.outgoing_tx = True\n        for o in output_arr:\n            if isinstance(o, Output):\n                transaction.outputs.append(o)\n                amount_total_output += o.value\n            else:\n                value = value_to_satoshi(o[1], network=transaction.network)\n                amount_total_output += value\n                addr = o[0]\n                if isinstance(addr, WalletKey):\n                    addr = addr.key()\n                transaction.add_output(value, addr)\n\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n        transaction.fee_per_kb = None\n        if isinstance(fee, int):\n            fee_estimate = fee\n        else:\n            n_blocks = 3\n            priority = ''\n            if isinstance(fee, str):\n                priority = fee\n            transaction.fee_per_kb = srv.estimatefee(blocks=n_blocks, priority=priority)\n            if not input_arr:\n                fee_estimate = int(transaction.estimate_size(number_of_change_outputs=number_of_change_outputs) /\n                                   1000.0 * transaction.fee_per_kb)\n            else:\n                fee_estimate = 0\n            if isinstance(fee, str):\n                fee = fee_estimate\n\n        # Add inputs\n        sequence = 0xffffffff\n        if 0 < transaction.locktime < 0xffffffff:\n            sequence = 0xfffffffe\n        amount_total_input = 0\n        if input_arr is None:\n            selected_utxos = self.select_inputs(amount_total_output + fee_estimate, transaction.network.dust_amount,\n                                                input_key_id, account_id, network, min_confirms, max_utxos, False)\n            if not selected_utxos:\n                raise WalletError(\"Not enough unspent transaction outputs found\")\n            for utxo in selected_utxos:\n                amount_total_input += utxo.value\n                inp_keys, key = self._objects_by_key_id(utxo.key_id)\n                multisig = False if isinstance(inp_keys, list) and len(inp_keys) < 2 else True\n                unlock_script_type = get_unlocking_script_type(utxo.script_type, self.witness_type, multisig=multisig)\n                transaction.add_input(utxo.transaction.txid, utxo.output_n, keys=inp_keys,\n                                      script_type=unlock_script_type, sigs_required=self.multisig_n_required,\n                                      sort=self.sort_keys, compressed=key.compressed, value=utxo.value,\n                                      address=utxo.key.address, sequence=sequence,\n                                      key_path=utxo.key.path, witness_type=self.witness_type)\n                # FIXME: Missing locktime_cltv=locktime_cltv, locktime_csv=locktime_csv (?)\n        else:\n            for inp in input_arr:\n                locktime_cltv = None\n                locktime_csv = None\n                unlocking_script_unsigned = None\n                unlocking_script_type = ''\n                if isinstance(inp, Input):\n                    prev_txid = inp.prev_txid\n                    output_n = inp.output_n\n                    key_id = None\n                    value = inp.value\n                    signatures = inp.signatures\n                    unlocking_script = inp.unlocking_script\n                    unlocking_script_unsigned = inp.unlocking_script_unsigned\n                    unlocking_script_type = inp.script_type\n                    address = inp.address\n                    sequence = inp.sequence\n                    locktime_cltv = inp.locktime_cltv\n                    locktime_csv = inp.locktime_csv\n                # elif isinstance(inp, DbTransactionOutput):\n                #     prev_txid = inp.transaction.txid\n                #     output_n = inp.output_n\n                #     key_id = inp.key_id\n                #     value = inp.value\n                #     signatures = None\n                #     # FIXME: This is probably not an unlocking_script\n                #     unlocking_script = inp.script\n                #     unlocking_script_type = get_unlocking_script_type(inp.script_type)\n                #     address = inp.key.address\n                else:\n                    prev_txid = inp[0]\n                    output_n = inp[1]\n                    key_id = None if len(inp) <= 2 else inp[2]\n                    value = 0 if len(inp) <= 3 else inp[3]\n                    signatures = None if len(inp) <= 4 else inp[4]\n                    unlocking_script = b'' if len(inp) <= 5 else inp[5]\n                    address = '' if len(inp) <= 6 else inp[6]\n                # Get key_ids, value from Db if not specified\n                if not (key_id and value and unlocking_script_type):\n                    if not isinstance(output_n, TYPE_INT):\n                        output_n = int.from_bytes(output_n, 'big')\n                    inp_utxo = self._session.query(DbTransactionOutput).join(DbTransaction). \\\n                        filter(DbTransaction.wallet_id == self.wallet_id,\n                               DbTransaction.txid == to_bytes(prev_txid),\n                               DbTransactionOutput.output_n == output_n).first()\n                    if inp_utxo:\n                        key_id = inp_utxo.key_id\n                        value = inp_utxo.value\n                        address = inp_utxo.key.address\n                        unlocking_script_type = get_unlocking_script_type(inp_utxo.script_type, multisig=self.multisig)\n                        # witness_type = inp_utxo.witness_type\n                    else:\n                        _logger.info(\"UTXO %s not found in this wallet. Please update UTXO's if this is not an \"\n                                     \"offline wallet\" % to_hexstring(prev_txid))\n                        key_id = self._session.query(DbKey.id).\\\n                            filter(DbKey.wallet_id == self.wallet_id, DbKey.address == address).scalar()\n                        if not key_id:\n                            raise WalletError(\"UTXO %s and key with address %s not found in this wallet\" % (\n                                to_hexstring(prev_txid), address))\n                        if not value:\n                            raise WalletError(\"Input value is zero for address %s. Import or update UTXO's first \"\n                                              \"or import transaction as dictionary\" % address)\n\n                amount_total_input += value\n                inp_keys, key = self._objects_by_key_id(key_id)\n                transaction.add_input(prev_txid, output_n, keys=inp_keys, script_type=unlocking_script_type,\n                                      sigs_required=self.multisig_n_required, sort=self.sort_keys,\n                                      compressed=key.compressed, value=value, signatures=signatures,\n                                      unlocking_script=unlocking_script, address=address,\n                                      unlocking_script_unsigned=unlocking_script_unsigned,\n                                      sequence=sequence, locktime_cltv=locktime_cltv, locktime_csv=locktime_csv,\n                                      witness_type=self.witness_type, key_path=key.path)\n        # Calculate fees\n        transaction.fee = fee\n        fee_per_output = None\n        transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)\n        if fee is None:\n            if not input_arr:\n                if not transaction.fee_per_kb:\n                    transaction.fee_per_kb = srv.estimatefee()\n                if transaction.fee_per_kb < transaction.network.fee_min:\n                    transaction.fee_per_kb = transaction.network.fee_min\n                transaction.fee = int((transaction.size / 1000.0) * transaction.fee_per_kb)\n                fee_per_output = int((50 / 1000.0) * transaction.fee_per_kb)\n            else:\n                if amount_total_output and amount_total_input:\n                    fee = False\n                else:\n                    transaction.fee = 0\n\n        if fee is False:\n            transaction.change = 0\n            transaction.fee = int(amount_total_input - amount_total_output)\n        else:\n            transaction.change = int(amount_total_input - (amount_total_output + transaction.fee))\n\n        # Skip change if amount is smaller than the dust limit or estimated fee\n        if (fee_per_output and transaction.change < fee_per_output) or transaction.change <= transaction.network.dust_amount:\n            transaction.fee += transaction.change\n            transaction.change = 0\n        if transaction.change < 0:\n            raise WalletError(\"Total amount of outputs is greater then total amount of inputs\")\n        if transaction.change:\n            min_output_value = transaction.network.dust_amount * 2 + transaction.network.fee_min * 4\n            if transaction.fee and transaction.size:\n                if not transaction.fee_per_kb:\n                    transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)\n                min_output_value = transaction.fee_per_kb + transaction.network.fee_min * 4 + \\\n                                   transaction.network.dust_amount\n\n            if number_of_change_outputs == 0:\n                if transaction.change < amount_total_output / 10 or transaction.change < min_output_value * 8:\n                    number_of_change_outputs = 1\n                elif transaction.change / 10 > amount_total_output:\n                    number_of_change_outputs = random.randint(2, 5)\n                else:\n                    number_of_change_outputs = random.randint(1, 3)\n                    # Prefer 1 and 2 as number of change outputs\n                    if number_of_change_outputs == 3:\n                        number_of_change_outputs = random.randint(3, 4)\n                transaction.size = transaction.estimate_size(number_of_change_outputs=number_of_change_outputs)\n\n            average_change = transaction.change // number_of_change_outputs\n            if number_of_change_outputs > 1 and average_change < min_output_value:\n                raise WalletError(\"Not enough funds to create multiple change outputs. Try less change outputs \"\n                                  \"or lower fees\")\n\n            if self.scheme == 'single':\n                change_keys = [self.get_key(account_id=account_id, network=network, change=1)]\n            else:\n                change_keys = self.get_keys(account_id=account_id, network=network, change=1,\n                                            number_of_keys=number_of_change_outputs)\n\n            if number_of_change_outputs > 1:\n                rand_prop = transaction.change - number_of_change_outputs * min_output_value\n                change_amounts = list(((np.random.dirichlet(np.ones(number_of_change_outputs), size=1)[0] *\n                                        rand_prop) + min_output_value).astype(int))\n                # Fix rounding problems / small amount differences\n                diffs = transaction.change - sum(change_amounts)\n                for idx, co in enumerate(change_amounts):\n                    if co - diffs > min_output_value:\n                        change_amounts[idx] += change_amounts.index(co) + diffs\n                        break\n            else:\n                change_amounts = [transaction.change]\n\n            for idx, ck in enumerate(change_keys):\n                on = transaction.add_output(change_amounts[idx], ck.address, encoding=self.encoding)\n                transaction.outputs[on].key_id = ck.key_id\n\n        # Shuffle output order to increase privacy\n        if random_output_order:\n            transaction.shuffle()\n\n        # Check tx values\n        transaction.input_total = sum([i.value for i in transaction.inputs])\n        transaction.output_total = sum([o.value for o in transaction.outputs])\n        if transaction.input_total != transaction.fee + transaction.output_total:\n            raise WalletError(\"Sum of inputs values is not equal to sum of outputs values plus fees\")\n\n        transaction.txid = transaction.signature_hash()[::-1].hex()\n        if not transaction.fee_per_kb:\n            transaction.fee_per_kb = int((transaction.fee * 1000.0) / transaction.vsize)\n        if transaction.fee_per_kb < transaction.network.fee_min:\n            raise WalletError(\"Fee per kB of %d is lower then minimal network fee of %d\" %\n                              (transaction.fee_per_kb, transaction.network.fee_min))\n        elif transaction.fee_per_kb > transaction.network.fee_max:\n            raise WalletError(\"Fee per kB of %d is higher then maximum network fee of %d\" %\n                              (transaction.fee_per_kb, transaction.network.fee_max))\n\n        return transaction",
  "def transaction_import(self, t):\n        \"\"\"\n        Import a Transaction into this wallet. Link inputs to wallet keys if possible and return WalletTransaction\n        object. Only imports Transaction objects or dictionaries, use\n        :func:`transaction_import_raw` method to import a raw transaction.\n\n        :param t: A Transaction object or dictionary\n        :type t: Transaction, dict\n\n        :return WalletTransaction:\n\n        \"\"\"\n        if isinstance(t, Transaction):\n            rt = self.transaction_create(t.outputs, t.inputs, fee=t.fee, network=t.network.name,\n                                         random_output_order=False)\n            rt.block_height = t.block_height\n            rt.confirmations = t.confirmations\n            rt.witness_type = t.witness_type\n            rt.date = t.date\n            rt.txid = t.txid\n            rt.txhash = t.txhash\n            rt.locktime = t.locktime\n            rt.version = t.version\n            rt.version_int = t.version_int\n            rt.block_hash = t.block_hash\n            rt.rawtx = t.rawtx\n            rt.coinbase = t.coinbase\n            rt.flag = t.flag\n            rt.size = t.size\n            if not t.size:\n                rt.size = len(t.raw())\n            rt.vsize = t.vsize\n            if not t.vsize:\n                rt.vsize = rt.size\n            rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        elif isinstance(t, dict):\n            input_arr = []\n            for i in t['inputs']:\n                signatures = [bytes.fromhex(sig) for sig in i['signatures']]\n                script = b'' if 'script' not in i else i['script']\n                address = '' if 'address' not in i else i['address']\n                input_arr.append((i['prev_txid'], i['output_n'], None, int(i['value']), signatures, script,\n                                  address))\n            output_arr = []\n            for o in t['outputs']:\n                output_arr.append((o['address'], int(o['value'])))\n            rt = self.transaction_create(output_arr, input_arr, fee=t['fee'], network=t['network'],\n                                         random_output_order=False)\n            rt.block_height = t['block_height']\n            rt.confirmations = t['confirmations']\n            rt.witness_type = t['witness_type']\n            rt.date = t['date']\n            rt.txid = t['txid']\n            rt.txhash = t['txhash']\n            rt.locktime = t['locktime']\n            rt.version = t['version'].to_bytes(4, 'big')\n            rt.version_int = t['version']\n            rt.block_hash = t['block_hash']\n            rt.rawtx = t['raw']\n            rt.coinbase = t['coinbase']\n            rt.flag = t['flag']\n            rt.size = t['size']\n            if not t['size']:\n                rt.size = len(rt.raw())\n            rt.vsize = t['vsize']\n            if not rt.vsize:\n                rt.vsize = rt.size\n            rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        else:\n            raise WalletError(\"Import transaction must be of type Transaction or dict\")\n        rt.verify()\n        return rt",
  "def transaction_import_raw(self, rawtx, network=None):\n        \"\"\"\n        Import a raw transaction. Link inputs to wallet keys if possible and return WalletTransaction object\n\n        :param rawtx: Raw transaction\n        :type rawtx: str, bytes\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return WalletTransaction:\n        \"\"\"\n\n        if network is None:\n            network = self.network.name\n        if isinstance(rawtx, str):\n            rawtx = bytes.fromhex(rawtx)\n        t_import = Transaction.parse_bytes(rawtx, network=network)\n        rt = self.transaction_create(t_import.outputs, t_import.inputs, network=network, locktime=t_import.locktime,\n                                     random_output_order=False)\n        rt.version_int = t_import.version_int\n        rt.version = t_import.version\n        rt.verify()\n        rt.size = len(rawtx)\n        rt.calc_weight_units()\n        rt.fee_per_kb = int((rt.fee / float(rt.vsize)) * 1000)\n        return rt",
  "def send(self, output_arr, input_arr=None, input_key_id=None, account_id=None, network=None, fee=None,\n             min_confirms=1, priv_keys=None, max_utxos=None, locktime=0, offline=True, number_of_change_outputs=1):\n        \"\"\"\n        Create a new transaction with specified outputs and push it to the network.\n        Inputs can be specified but if not provided they will be selected from wallets utxo's\n        Output array is a list of 1 or more addresses and amounts.\n\n        Uses the :func:`transaction_create` method to create a new transaction, and uses a random service client to send the transaction.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.send([('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000)], offline=True)\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param output_arr: List of output tuples with address and amount. Must contain at least one item. Example: [('mxdLD8SAGS9fe2EeCXALDHcdTTbppMHp8N', 5000000)]. Address can be an address string, Address object, HDKey object or WalletKey object\n        :type output_arr: list\n        :param input_arr: List of inputs tuples with reference to a UTXO, a wallet key and value. The format is [(txid, output_n, key_id, value)]\n        :type input_arr: list\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param priv_keys: Specify extra private key if not available in this wallet\n        :type priv_keys: HDKey, list\n        :param max_utxos: Maximum number of UTXO's to use. Set to 1 for optimal privacy. Default is None: No maximum\n        :type max_utxos: int\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount\n        :type number_of_change_outputs: int\n\n        :return WalletTransaction:\n        \"\"\"\n\n        if input_arr and max_utxos and len(input_arr) > max_utxos:\n            raise WalletError(\"Input array contains %d UTXO's but max_utxos=%d parameter specified\" %\n                              (len(input_arr), max_utxos))\n\n        transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network, fee,\n                                              min_confirms, max_utxos, locktime, number_of_change_outputs)\n        transaction.sign(priv_keys)\n        # Calculate exact fees and update change output if necessary\n        if fee is None and transaction.fee_per_kb and transaction.change:\n            fee_exact = transaction.calculate_fee()\n            # Recreate transaction if fee estimation more than 10% off\n            if fee_exact != self.network.fee_min and fee_exact != self.network.fee_max and \\\n                    fee_exact and abs((float(transaction.fee) - float(fee_exact)) / float(fee_exact)) > 0.10:\n                _logger.info(\"Transaction fee not correctly estimated (est.: %d, real: %d). \"\n                             \"Recreate transaction with correct fee\" % (transaction.fee, fee_exact))\n                transaction = self.transaction_create(output_arr, input_arr, input_key_id, account_id, network,\n                                                      fee_exact, min_confirms, max_utxos, locktime,\n                                                      number_of_change_outputs)\n                transaction.sign(priv_keys)\n\n        transaction.rawtx = transaction.raw()\n        transaction.size = len(transaction.rawtx)\n        transaction.calc_weight_units()\n        transaction.fee_per_kb = int(float(transaction.fee) / float(transaction.vsize) * 1000)\n        transaction.txid = transaction.signature_hash()[::-1].hex()\n        transaction.send(offline)\n        return transaction",
  "def send_to(self, to_address, amount, input_key_id=None, account_id=None, network=None, fee=None, min_confirms=1,\n                priv_keys=None, locktime=0, offline=True, number_of_change_outputs=1):\n        \"\"\"\n        Create transaction and send it with default Service objects :func:`services.sendrawtransaction` method.\n\n        Wrapper for wallet :func:`send` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.send_to('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 200000, offline=True)\n        >>> t\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=..., type=p2pkh)>, <Output(value=..., address=..., type=p2pkh)>]\n\n        :param to_address: Single output address as string Address object, HDKey object or WalletKey object\n        :type to_address: str, Address, HDKey, WalletKey\n        :param amount: Output is the smallest denominator for this network (ie: Satoshi's for Bitcoin), as Value object or value string as accepted by Value class\n        :type amount: int, str, Value\n        :param input_key_id: Limit UTXO's search for inputs to this key ID or list of key IDs. Only valid if no input array is specified\n        :type input_key_id: int, list\n        :param account_id: Account ID, default is last used\n        :type account_id: int\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param fee: Set fee manually, leave empty to calculate fees automatically. Set fees in the smallest currency  denominator, for example satoshi's if you are using bitcoins. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param min_confirms: Minimal confirmation needed for an UTXO before it will be included in inputs. Default is 1. Option is ignored if input_arr is provided.\n        :type min_confirms: int\n        :param priv_keys: Specify extra private key if not available in this wallet\n        :type priv_keys: HDKey, list\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n        :param number_of_change_outputs: Number of change outputs to create when there is a change value. Default is 1. Use 0 for random number of outputs: between 1 and 5 depending on send and change amount\n        :type number_of_change_outputs: int\n\n        :return WalletTransaction:\n        \"\"\"\n\n        outputs = [(to_address, amount)]\n        return self.send(outputs, input_key_id=input_key_id, account_id=account_id, network=network, fee=fee,\n                         min_confirms=min_confirms, priv_keys=priv_keys, locktime=locktime, offline=offline,\n                         number_of_change_outputs=number_of_change_outputs)",
  "def sweep(self, to_address, account_id=None, input_key_id=None, network=None, max_utxos=999, min_confirms=1,\n              fee_per_kb=None, fee=None, locktime=0, offline=True):\n        \"\"\"\n        Sweep all unspent transaction outputs (UTXO's) and send them to one or more output addresses.\n\n        Wrapper for the :func:`send` method.\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> t = w.sweep('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb')\n        >>> t\n        <WalletTransaction(input_count=1, output_count=1, status=new, network=bitcoin)>\n        >>> t.outputs # doctest:+ELLIPSIS\n        [<Output(value=..., address=1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb, type=p2pkh)>]\n\n        Output to multiple addresses\n\n        >>> to_list = [('1J9GDZMKEr3ZTj8q6pwtMy4Arvt92FDBTb', 100000), (w.get_key(), 0)]\n        >>> w.sweep(to_list)\n        <WalletTransaction(input_count=1, output_count=2, status=new, network=bitcoin)>\n\n        :param to_address: Single output address or list of outputs in format [(<adddress>, <amount>)]. If you specify a list of outputs, use amount value = 0 to indicate a change output\n        :type to_address: str, list\n        :param account_id: Wallet's account ID\n        :type account_id: int\n        :param input_key_id: Limit sweep to UTXO's with this key ID or list of key IDs\n        :type input_key_id: int, list\n        :param network: Network name. Leave empty for default network\n        :type network: str\n        :param max_utxos: Limit maximum number of outputs to use. Default is 999\n        :type max_utxos: int\n        :param min_confirms: Minimal confirmations needed to include utxo\n        :type min_confirms: int\n        :param fee_per_kb: Fee per kilobyte transaction size, leave empty to get estimated fee costs from Service provider. This option is ignored when the 'fee' option is specified\n        :type fee_per_kb: int\n        :param fee: Total transaction fee in the smallest denominator (i.e. satoshis). Leave empty to get estimated fee from service providers. You can also supply a string: 'low', 'normal' or 'high' to determine fees automatically.\n        :type fee: int, str\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param offline: Just return the transaction object and do not send it when offline = True. Default is True\n        :type offline: bool\n\n        :return WalletTransaction:\n        \"\"\"\n\n        network, account_id, acckey = self._get_account_defaults(network, account_id)\n\n        utxos = self.utxos(account_id=account_id, network=network, min_confirms=min_confirms, key_id=input_key_id)\n        utxos = utxos[0:max_utxos]\n        input_arr = []\n        total_amount = 0\n        if not utxos:\n            raise WalletError(\"Cannot sweep wallet, no UTXO's found\")\n        for utxo in utxos:\n            # Skip dust transactions to avoid forced address reuse\n            if utxo['value'] <= self.network.dust_amount:\n                continue\n            input_arr.append((utxo['txid'], utxo['output_n'], utxo['key_id'], utxo['value']))\n            total_amount += utxo['value']\n        srv = Service(network=network, providers=self.providers, cache_uri=self.db_cache_uri)\n\n        if isinstance(fee, str):\n            n_outputs = 1 if not isinstance(to_address, list) else len(to_address)\n            fee_per_kb = srv.estimatefee(priority=fee)\n            tr_size = 125 + (len(input_arr) * (77 + self.multisig_n_required * 72)) + n_outputs * 30\n            fee = 100 + int((tr_size / 1000.0) * fee_per_kb)\n\n        if not fee:\n            if fee_per_kb is None:\n                fee_per_kb = srv.estimatefee()\n            tr_size = 125 + (len(input_arr) * 125)\n            fee = int((tr_size / 1000.0) * fee_per_kb)\n        if total_amount - fee <= self.network.dust_amount:\n            raise WalletError(\"Amount to send is smaller then dust amount: %s\" % (total_amount - fee))\n\n        if isinstance(to_address, str):\n            to_list = [(to_address, total_amount - fee)]\n        else:\n            to_list = []\n            for o in to_address:\n                if o[1] == 0:\n                    o_amount = total_amount - sum([x[1] for x in to_list]) - fee\n                    if o_amount > 0:\n                        to_list.append((o[0], o_amount))\n                else:\n                    to_list.append(o)\n\n        if sum(x[1] for x in to_list) + fee != total_amount:\n            raise WalletError(\"Total amount of outputs does not match total input amount. If you specify a list of \"\n                              \"outputs, use amount value = 0 to indicate a change/rest output\")\n\n        return self.send(to_list, input_arr, network=network, fee=fee, min_confirms=min_confirms, locktime=locktime,\n                         offline=offline)",
  "def wif(self, is_private=False, account_id=0):\n        \"\"\"\n        Return Wallet Import Format string for master private or public key which can be used to import key and\n        recreate wallet in other software.\n\n        A list of keys will be exported for a multisig wallet.\n\n        :param is_private: Export public or private key, default is False\n        :type is_private: bool\n        :param account_id: Account ID of key to export\n        :type account_id: bool\n\n        :return list, str:\n        \"\"\"\n        if not self.multisig or not self.cosigner:\n            if is_private and self.main_key:\n                return self.main_key.wif\n            else:\n                return self.public_master(account_id=account_id).key().\\\n                    wif(is_private=is_private, witness_type=self.witness_type, multisig=self.multisig)\n        else:\n            wiflist = []\n            for cs in self.cosigner:\n                wiflist.append(cs.wif(is_private=is_private))\n            return wiflist",
  "def public_master(self, account_id=None, name=None, as_private=False, network=None):\n        \"\"\"\n        Return public master key(s) for this wallet. Use to import in other wallets to sign transactions or create keys.\n\n        For a multisig wallet all public master keys are return as list.\n\n        Returns private key information if available and as_private is True is specified\n\n        >>> w = Wallet('bitcoinlib_legacy_wallet_test')\n        >>> w.public_master().wif\n        'xpub6D2qEr8Z8WYKKns2xZYyyvvRviPh1NKt1kfHwwfiTxJwj7peReEJt3iXoWWsr8tXWTsejDjMfAezM53KVFVkSZzA5i2pNy3otprtYUvh4u1'\n\n        :param account_id: Account ID of key to export\n        :type account_id: int\n        :param name: Optional name for account key\n        :type name: str\n        :param as_private: Export public or private key, default is False\n        :type as_private: bool\n        :param network: Network name. Leave empty for default network\n        :type network: str\n\n        :return list of WalletKey, WalletKey:\n        \"\"\"\n        if self.main_key and self.main_key.key_type == 'single':\n            key = self.main_key\n            return key if as_private else key.public()\n        elif not self.cosigner:\n            depth = -self.key_depth + self.depth_public_master\n            key = self.key_for_path([], depth, name=name, account_id=account_id, network=network,\n                                    cosigner_id=self.cosigner_id)\n            return key if as_private else key.public()\n        else:\n            pm_list = []\n            for cs in self.cosigner:\n                pm_list.append(cs.public_master(account_id, name, as_private, network))\n            return pm_list",
  "def transaction_load(self, txid=None, filename=None):\n        \"\"\"\n        Load transaction object from file which has been stored with the :func:`Transaction.save` method.\n\n        Specify transaction ID or filename.\n\n        :param txid: Transaction ID. Transaction object will be read from .bitcoinlib datadir\n        :type txid: str\n        :param filename: Name of transaction object file\n        :type filename: str\n\n        :return Transaction:\n        \"\"\"\n        if not filename and not txid:\n            raise WalletError(\"Please supply filename or txid\")\n        elif not filename and txid:\n            p = Path(BCL_DATA_DIR, '%s.tx' % txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('rb')\n        t = pickle.load(f)\n        f.close()\n        return self.transaction_import(t)",
  "def info(self, detail=3):\n        \"\"\"\n        Prints wallet information to standard output\n\n        :param detail: Level of detail to show. Specify a number between 0 and 5, with 0 low detail and 5 highest detail\n        :type detail: int\n        \"\"\"\n\n        print(\"=== WALLET ===\")\n        print(\" ID                             %s\" % self.wallet_id)\n        print(\" Name                           %s\" % self.name)\n        print(\" Owner                          %s\" % self.owner)\n        print(\" Scheme                         %s\" % self.scheme)\n        print(\" Multisig                       %s\" % self.multisig)\n        if self.multisig:\n            print(\" Multisig Wallet IDs            %s\" % str([w.wallet_id for w in self.cosigner]).strip('[]'))\n            print(\" Cosigner ID                    %s\" % self.cosigner_id)\n        print(\" Witness type                   %s\" % self.witness_type)\n        print(\" Main network                   %s\" % self.network.name)\n        print(\" Latest update                  %s\" % self.last_updated)\n\n        if self.multisig:\n            print(\"\\n= Multisig Public Master Keys =\")\n            for cs in self.cosigner:\n                print(\"%5s %3s %-70s %-6s %-8s %s\" %\n                      (cs.cosigner_id, cs.main_key.key_id, cs.wif(is_private=False), cs.scheme,\n                       \"main\" if cs.main_key.is_private else \"cosigner\",\n                       '*' if cs.cosigner_id == self.cosigner_id else ''))\n\n            print(\"For main keys a private master key is available in this wallet to sign transactions. \"\n                  \"* cosigner key for this wallet\")\n\n        if detail and self.main_key:\n            print(\"\\n= Wallet Master Key =\")\n            print(\" ID                             %s\" % self.main_key_id)\n            print(\" Private                        %s\" % self.main_key.is_private)\n            print(\" Depth                          %s\" % self.main_key.depth)\n\n        balances = self._balance_update()\n        if detail > 1:\n            for nw in self.networks():\n                print(\"\\n- NETWORK: %s -\" % nw.name)\n                print(\"- - Keys\")\n                if detail < 4:\n                    ds = [self.key_depth]\n                elif detail < 5:\n                    if self.purpose == 45:\n                        ds = [0, self.key_depth]\n                    else:\n                        ds = [0, self.depth_public_master, self.key_depth]\n                else:\n                    ds = range(8)\n                for d in ds:\n                    is_active = True\n                    if detail > 3:\n                        is_active = False\n                    for key in self.keys(depth=d, network=nw.name, is_active=is_active):\n                        print(\"%5s %-28s %-45s %-25s %25s\" %\n                              (key.id, key.path, key.address, key.name,\n                               Value.from_satoshi(key.balance, network=nw).str_unit(currency_repr='symbol')))\n\n                if detail > 2:\n                    include_new = False\n                    if detail > 3:\n                        include_new = True\n                    accounts = self.accounts(network=nw.name)\n                    if not accounts:\n                        accounts = [0]\n                    for account_id in accounts:\n                        txs = self.transactions(include_new=include_new, account_id=account_id, network=nw.name,\n                                                as_dict=True)\n                        print(\"\\n- - Transactions Account %d (%d)\" % (account_id, len(txs)))\n                        for tx in txs:\n                            spent = \" \"\n                            address = tx['address']\n                            if not tx['address']:\n                                address = 'nulldata'\n                            elif 'spent' in tx and tx['spent'] is False:\n                                spent = \"U\"\n                            status = \"\"\n                            if tx['status'] not in ['confirmed', 'unconfirmed']:\n                                status = tx['status']\n                            print(\"%64s %43s %8d %21s %s %s\" % (tx['txid'], address, tx['confirmations'],\n                                                                Value.from_satoshi(tx['value'], network=nw).str_unit(\n                                                                    currency_repr='symbol'),\n                                                                spent, status))\n\n        print(\"\\n= Balance Totals (includes unconfirmed) =\")\n        for na_balance in balances:\n            print(\"%-20s %-20s %20s\" % (na_balance['network'], \"(Account %s)\" % na_balance['account_id'],\n                                        Value.from_satoshi(na_balance['balance'], network=na_balance['network']).\n                                        str_unit(currency_repr='symbol')))\n        print(\"\\n\")",
  "def as_dict(self, include_private=False):\n        \"\"\"\n        Return wallet information in dictionary format\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return dict:\n        \"\"\"\n\n        keys = []\n        transactions = []\n        for netw in self.networks():\n            for key in self.keys(network=netw.name, include_private=include_private, as_dict=True):\n                keys.append(key)\n\n            if self.multisig:\n                for t in self.transactions(include_new=True, account_id=0, network=netw.name):\n                    transactions.append(t.as_dict())\n            else:\n                accounts = self.accounts(network=netw.name)\n                if not accounts:\n                    accounts = [0]\n                for account_id in accounts:\n                    for t in self.transactions(include_new=True, account_id=account_id, network=netw.name):\n                        transactions.append(t.as_dict())\n\n        return {\n            'wallet_id': self.wallet_id,\n            'name': self.name,\n            'owner': self._owner,\n            'scheme': self.scheme,\n            'witness_type': self.witness_type,\n            'main_network': self.network.name,\n            'main_balance': self.balance(),\n            'main_balance_str': self.balance(as_string=True),\n            'balances': self._balances,\n            'default_account_id': self.default_account_id,\n            'multisig_n_required': self.multisig_n_required,\n            'cosigner_wallet_ids': [w.wallet_id for w in self.cosigner],\n            'cosigner_public_masters': [w.public_master().key().wif() for w in self.cosigner],\n            'sort_keys': self.sort_keys,\n            'main_key_id': self.main_key_id,\n            'encoding': self.encoding,\n            'keys': keys,\n            'transactions': transactions,\n        }",
  "def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in JSON\n        :type include_private: bool\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict(include_private=include_private)\n        return json.dumps(adict, indent=4, default=str)",
  "class EncodingError(Exception):\n    \"\"\" Log and raise encoding errors \"\"\"\n    def __init__(self, msg=''):\n        self.msg = msg\n\n    def __str__(self):\n        return self.msg",
  "def _get_code_string(base):\n    if base in code_strings:\n        return code_strings[base]\n    else:\n        return list(range(0, base))",
  "def _array_to_codestring(array, base):\n    codebase = code_strings[base]\n    codestring = \"\"\n    for i in array:\n        codestring += chr(codebase[i])\n    return codestring",
  "def _codestring_to_array(codestring, base):\n    codestring = bytes(codestring, 'utf8')\n    codebase = code_strings[base]\n    array = []\n    for s in codestring:\n        try:\n            array.append(codebase.index(s))\n        except ValueError:\n            raise EncodingError(\"Character '%s' not found in codebase\" % s)\n    return array",
  "def normalize_var(var, base=256):\n    \"\"\"\n    For Python 2 convert variable to string\n\n    For Python 3 convert to bytes\n\n    Convert decimals to integer type\n\n    :param var: input variable in any format\n    :type var: str, byte\n    :param base: specify variable format, i.e. 10 for decimal, 16 for hex\n    :type base: int\n\n    :return: Normalized var in string for Python 2, bytes for Python 3, decimal for base10\n    \"\"\"\n    try:\n        if isinstance(var, str):\n            var = var.encode('ISO-8859-1')\n    except ValueError:\n        try:\n            var = var.encode('utf-8')\n        except ValueError:\n            raise EncodingError(\"Unknown character '%s' in input format\" % var)\n\n    if base == 10:\n        return int(var)\n    elif isinstance(var, list):\n        return deepcopy(var)\n    else:\n        return var",
  "def change_base(chars, base_from, base_to, min_length=0, output_even=None, output_as_list=None):\n    \"\"\"\n    Convert input chars from one numeric base to another. For instance from hexadecimal (base-16) to decimal (base-10)\n\n    From and to numeric base can be any base. If base is not found in definitions an array of index numbers will be returned\n\n    Examples:\n\n    >>> change_base('FF', 16, 10)\n    255\n    >>> change_base('101', 2, 10)\n    5\n\n    Convert base-58 public WIF of a key to hexadecimal format\n\n    >>> change_base('xpub661MyMwAqRbcFnkbk13gaJba22ibnEdJS7KAMY99C4jBBHMxWaCBSTrTinNTc9G5LTFtUqbLpWnzY5yPTNEF9u8sB1kBSygy4UsvuViAmiR', 58, 16)\n    '0488b21e0000000000000000007d3cc6702f48bf618f3f14cce5ee2cacf3f70933345ee4710af6fa4a330cc7d503c045227451b3454ca8b6022b0f0155271d013b58d57d322fd05b519753a46e876388698a'\n\n    Convert base-58 address to public key hash: '00' + length '21' + 20 byte key\n\n    >>> change_base('142Zp9WZn9Fh4MV8F3H5Dv4Rbg7Ja1sPWZ', 58, 16)\n    '0021342f229392d7c9ed82c932916cee6517fbc9a2487cd97a'\n\n    Convert to 2048-base, for example a Mnemonic word list. Will return a list of integers\n\n    >>> change_base(100, 16, 2048)\n    [100]\n\n    :param chars: Input string\n    :type chars: any\n    :param base_from: Base number or name from input. For example 2 for binary, 10 for decimal and 16 for hexadecimal\n    :type base_from: int, str\n    :param base_to: Base number or name for output. For example 2 for binary, 10 for decimal and 16 for hexadecimal\n    :type base_to: int\n    :param min_length: Minimal output length. Required for decimal, advised for all output to avoid leading zeros conversion problems.\n    :type min_length: int\n    :param output_even: Specify if output must contain an even number of characters. Sometimes handy for hex conversions.\n    :type output_even: bool\n    :param output_as_list: Always output as list instead of string.\n    :type output_as_list: bool\n\n    :return str, list: Base converted input as string or list.\n    \"\"\"\n    if base_from == 10 and not min_length:\n        raise EncodingError(\"For a decimal input a minimum output length is required\")\n\n    code_str = _get_code_string(base_to)\n\n    if base_to not in code_strings:\n        output_as_list = True\n\n    code_str_from = _get_code_string(base_from)\n    if not isinstance(code_str_from, (bytes, list)):\n        raise EncodingError(\"Code strings must be a list or defined as bytes\")\n    output = []\n    input_dec = 0\n    addzeros = 0\n    inp = normalize_var(chars, base_from)\n\n    # Use bytes and int's methods for standard conversions to speedup things\n    if not min_length:\n        if base_from == 256 and base_to == 16:\n            return inp.hex()\n        elif base_from == 16 and base_to == 256:\n            return bytes.fromhex(chars)\n    if base_from == 16 and base_to == 10:\n        return int(inp, 16)\n    if base_from == 10 and base_to == 16:\n        hex_outp = hex(inp)[2:]\n        return hex_outp.zfill(min_length) if min_length else hex_outp\n    if base_from == 256 and base_to == 10:\n        return int.from_bytes(inp, 'big')\n    if base_from == 10 and base_to == 256:\n        return inp.to_bytes(min_length, byteorder='big')\n    if base_from == 256 and base_to == 58:\n        return base58encode(inp)\n    if base_from == 16 and base_to == 58:\n        return base58encode(bytes.fromhex(chars))\n\n    if output_even is None and base_to == 16:\n        output_even = True\n\n    if isinstance(inp, numbers.Number):\n        input_dec = inp\n    elif isinstance(inp, (str, list, bytes)):\n        factor = 1\n        while len(inp):\n            if isinstance(inp, list):\n                item = inp.pop()\n            else:\n                item = inp[-1:]\n                inp = inp[:-1]\n            try:\n                pos = code_str_from.index(item)\n            except ValueError:\n                try:\n                    pos = code_str_from.index(item.lower())\n                except ValueError:\n                    raise EncodingError(\"Unknown character %s found in input string\" % item)\n            input_dec += pos * factor\n\n            # Add leading zero if there are leading zero's in input\n            firstchar = chr(code_str_from[0]).encode('utf-8')\n            if not pos * factor:\n                if isinstance(inp, list):\n                    if not len([x for x in inp if x != firstchar]):\n                        addzeros += 1\n                elif not len(inp.strip(firstchar)):\n                    addzeros += 1\n            factor *= base_from\n    else:\n        raise EncodingError(\"Unknown input format %s\" % inp)\n\n    # Convert decimal to output base\n    while input_dec != 0:\n        input_dec, remainder = divmod(input_dec, base_to)\n        output = [code_str[remainder]] + output\n\n    if base_to != 10:\n        pos_fact = math.log(base_to, base_from)\n        expected_length = len(str(chars)) / pos_fact\n\n        zeros = int(addzeros / pos_fact)\n        if addzeros == 1:\n            zeros = 1\n        # Different rules for base58 addresses\n        if (base_from == 256 and base_to == 58) or (base_from == 58 and base_to == 256):\n            zeros = addzeros\n        elif base_from == 16 and base_to == 58:\n            zeros = -(-addzeros // 2)\n        elif base_from == 58 and base_to == 16:\n            zeros = addzeros * 2\n\n        for _ in range(zeros):\n            if base_to != 10 and not expected_length == len(output):\n                output = [code_str[0]] + output\n\n        # Add zero's to make even number of digits on Hex output (or if specified)\n        if output_even and len(output) % 2:\n            output = [code_str[0]] + output\n\n        # Add leading zero's\n        while len(output) < min_length:\n            output = [code_str[0]] + output\n\n    if not output_as_list and isinstance(output, list):\n        output = 0 if not len(output) else ''.join([chr(c) for c in output])\n    if base_to == 10:\n        return int(0) or (output != '' and int(output))\n    if base_to == 256 and not output_as_list:\n        return output.encode('ISO-8859-1')\n    else:\n        return output",
  "def base58encode(inp):\n    \"\"\"\n    Convert bytes to base58 encode string\n\n    :param inp: Input string\n    :type inp: bytes\n\n    :return str:\n    \"\"\"\n    origlen = len(inp)\n    inp = inp.lstrip(b'\\0')\n    padding_zeros = origlen - len(inp)\n    code_str = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n    acc = int.from_bytes(inp, 'big')\n\n    string = ''\n    while acc:\n        acc, idx = divmod(acc, 58)\n        string = code_str[idx:idx + 1] + string\n    return '1' * padding_zeros + string",
  "def varbyteint_to_int(byteint):\n    \"\"\"\n    Convert CompactSize Variable length integer in byte format to integer.\n\n    See https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer for specification\n\n    >>> varbyteint_to_int(bytes.fromhex('fd1027'))\n    (10000, 3)\n\n    :param byteint: 1-9 byte representation\n    :type byteint: bytes, list\n\n    :return (int, int): tuple wit converted integer and size\n    \"\"\"\n    if not isinstance(byteint, (bytes, list)):\n        raise EncodingError(\"Byteint must be a list or defined as bytes\")\n    if byteint == b'':\n        return 0, 0\n    ni = byteint[0]\n    if ni < 253:\n        return ni, 1\n    if ni == 253:  # integer of 2 bytes\n        size = 2\n    elif ni == 254:  # integer of 4 bytes\n        size = 4\n    else:  # integer of 8 bytes\n        size = 8\n    return int.from_bytes(byteint[1:1+size][::-1], 'big'), size + 1",
  "def read_varbyteint(s):\n    \"\"\"\n    Read variable length integer from BytesIO stream. Wrapper for the varbyteint_to_int method\n\n    :param s: A binary stream\n    :type s: BytesIO\n\n    :return int:\n    \"\"\"\n    pos = s.tell()\n    value, size = varbyteint_to_int(s.read(9))\n    s.seek(pos + size)\n    return value",
  "def read_varbyteint_return(s):\n    \"\"\"\n    Read variable length integer from BytesIO stream. Return original converted bytes (to reconstruct transaction or\n    script).\n\n    :param s: A binary stream\n    :type s: BytesIO\n\n    :return (int, bytes):\n    \"\"\"\n    pos = s.tell()\n    byteint = s.read(9)\n    if not byteint:\n        return 0, b''\n\n    ni = byteint[0]\n    if ni < 253:\n        s.seek(pos + 1)\n        return ni, byteint[0:1]\n    if ni == 253:  # integer of 2 bytes\n        size = 2\n    elif ni == 254:  # integer of 4 bytes\n        size = 4\n    else:  # integer of 8 bytes\n        size = 8\n    varbytes = byteint[1:1+size]\n    s.seek(pos + size + 1)\n    return int.from_bytes(varbytes[::-1], 'big'), byteint[0:1] + varbytes",
  "def int_to_varbyteint(inp):\n    \"\"\"\n    Convert integer to CompactSize Variable length integer in byte format.\n\n    See https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer for specification\n\n    >>> int_to_varbyteint(10000).hex()\n    'fd1027'\n\n    :param inp: Integer to convert\n    :type inp: int\n\n    :return: byteint: 1-9 byte representation as integer\n    \"\"\"\n    if not isinstance(inp, numbers.Number):\n        raise EncodingError(\"Input must be a number type\")\n    if inp < 0xfd:\n        return inp.to_bytes(1, 'little')\n    elif inp < 0xffff:\n        return b'\\xfd' + inp.to_bytes(2, 'little')\n    elif inp < 0xffffffff:\n        return b'\\xfe' + inp.to_bytes(4, 'little')\n    else:\n        return b'\\xff' + inp.to_bytes(8, 'little')",
  "def convert_der_sig(signature, as_hex=True):\n    \"\"\"\n    Extract content from DER encoded string: Convert DER encoded signature to signature string.\n\n    :param signature: DER signature\n    :type signature: bytes\n    :param as_hex: Output as hexstring\n    :type as_hex: bool\n\n    :return bytes, str: Signature\n    \"\"\"\n\n    if not signature:\n        return \"\"\n    if USE_FASTECDSA:\n        r, s = DEREncoder.decode_signature(bytes(signature))\n    else:\n        sg, junk = ecdsa.der.remove_sequence(signature)\n        if junk != b'':\n            raise EncodingError(\"Junk found in encoding sequence %s\" % junk)\n        r, sg = ecdsa.der.remove_integer(sg)\n        s, sg = ecdsa.der.remove_integer(sg)\n    sig = '%064x%064x' % (r, s)\n    if as_hex:\n        return sig\n    else:\n        return bytes.fromhex(sig)",
  "def der_encode_sig(r, s):\n    \"\"\"\n    Create DER encoded signature string with signature r and s value.\n\n    :param r: r value of signature\n    :type r: int\n    :param s: s value of signature\n    :type s: int\n\n    :return bytes:\n    \"\"\"\n    if USE_FASTECDSA:\n        return DEREncoder.encode_signature(r, s)\n    else:\n        rb = ecdsa.der.encode_integer(r)\n        sb = ecdsa.der.encode_integer(s)\n        return ecdsa.der.encode_sequence(rb, sb)",
  "def addr_to_pubkeyhash(address, as_hex=False, encoding=None):\n    \"\"\"\n    Convert base58 or bech32 address to public key hash\n\n    Wrapper for the :func:`addr_base58_to_pubkeyhash` and :func:`addr_bech32_to_pubkeyhash` method\n\n    :param address: Crypto currency address in base-58 format\n    :type address: str\n    :param as_hex: Output as hexstring\n    :type as_hex: bool\n    :param encoding: Address encoding used: base58 or bech32. Default is base58. Try to derive from address if encoding=None is provided\n    :type encoding: str\n\n    :return bytes, str: public key hash\n    \"\"\"\n\n    if encoding == 'base58' or encoding is None:\n        try:\n            pkh = addr_base58_to_pubkeyhash(address, as_hex)\n        except EncodingError:\n            pkh = None\n        if pkh is not None:\n            return pkh\n    if encoding == 'bech32' or encoding is None:\n        return addr_bech32_to_pubkeyhash(address, as_hex=as_hex)",
  "def addr_base58_to_pubkeyhash(address, as_hex=False):\n    \"\"\"\n    Convert Base58 encoded address to public key hash\n\n    >>> addr_base58_to_pubkeyhash('142Zp9WZn9Fh4MV8F3H5Dv4Rbg7Ja1sPWZ', as_hex=True)\n    '21342f229392d7c9ed82c932916cee6517fbc9a2'\n\n    :param address: Crypto currency address in base-58 format\n    :type address: str, bytes\n    :param as_hex: Output as hexstring\n    :type as_hex: bool\n\n    :return bytes, str: Public Key Hash\n    \"\"\"\n\n    try:\n        address = change_base(address, 58, 256, 25)\n    except EncodingError as err:\n        raise EncodingError(\"Invalid address %s: %s\" % (address, err))\n    if len(address) != 25:\n        raise EncodingError(\"Invalid address hash160 length, should be 25 characters not %d\" % len(address))\n    check = address[-4:]\n    pkh = address[:-4]\n    checksum = double_sha256(pkh)[0:4]\n    assert (check == checksum), \"Invalid address, checksum incorrect\"\n    if as_hex:\n        return pkh.hex()[2:]\n    else:\n        return pkh[1:]",
  "def addr_bech32_to_pubkeyhash(bech, prefix=None, include_witver=False, as_hex=False):\n    \"\"\"\n    Decode bech32 / segwit address to public key hash\n\n    >>> addr_bech32_to_pubkeyhash('bc1qy8qmc6262m68ny0ftlexs4h9paud8sgce3sf84', as_hex=True)\n    '21c1bc695a56f47991e95ff26856e50f78d3c118'\n\n    Validate the bech32 string, and determine HRP and data. Only standard data size of 20 and 32 bytes are excepted\n\n    :param bech: Bech32 address to convert\n    :type bech: str\n    :param prefix: Address prefix called Human-readable part. Default is None and tries to derive prefix, for bitcoin specify 'bc' and for bitcoin testnet 'tb'\n    :type prefix: str\n    :param include_witver: Include witness version in output? Default is False\n    :type include_witver: bool\n    :param as_hex: Output public key hash as hex or bytes. Default is False\n    :type as_hex: bool\n\n    :return str: Public Key Hash\n    \"\"\"\n    if (any(ord(x) < 33 or ord(x) > 126 for x in bech)) or (bech.lower() != bech and bech.upper() != bech):\n        raise EncodingError(\"Invalid bech32 character in bech string\")\n    bech = bech.lower()\n    pos = bech.rfind('1')\n    if pos < 1 or pos + 7 > len(bech) or len(bech) > 90:\n        raise EncodingError(\"Invalid bech32 string length\")\n    if prefix and prefix != bech[:pos]:\n        raise EncodingError(\"Invalid bech32 address. Prefix '%s', prefix expected is '%s'\" % (bech[:pos], prefix))\n    hrp = bech[:pos]\n    data = _codestring_to_array(bech[pos + 1:], 'bech32')\n    hrp_expanded = [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]\n    check = _bech32_polymod(hrp_expanded + data)\n    if not (check == 1 or check == BECH32M_CONST):\n        raise EncodingError(\"Bech polymod check failed\")\n    if data[0] == 0 and check != 1:\n        raise EncodingError(\"Invalid checksum (Bech32m instead of Bech32)\")\n    if data[0] != 0 and check != BECH32M_CONST:\n        raise EncodingError(\"Invalid checksum (Bech32 instead of Bech32m)\")\n    data = data[:-6]\n    decoded = bytes(convertbits(data[1:], 5, 8, pad=False))\n    if decoded is None or len(decoded) < 2 or len(decoded) > 40:\n        raise EncodingError(\"Invalid decoded data length, must be between 2 and 40\")\n    if data[0] > 16:\n        raise EncodingError(\"Invalid witness version\")\n    if data[0] == 0 and len(decoded) not in [20, 32]:\n        raise EncodingError(\"Invalid decoded data length, must be 20 or 32 bytes\")\n    prefix = b''\n    if include_witver:\n        datalen = len(decoded)\n        prefix = bytes([data[0] + 0x50 if data[0] else 0, datalen])\n    if as_hex:\n        return (prefix + decoded).hex()\n    return prefix + decoded",
  "def addr_bech32_checksum(bech):\n    \"\"\"\n    Get bech32 checksum. Returns 1 for bech32 addresses and 0x2bc830a3 for bech32m addresses.\n    More info https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki\n\n    >>> addr_bech32_checksum('bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kt5nd6y')\n    734539939\n\n    :param bech: Bech32 address to convert\n    :type bech: str\n\n    :return bool: Bech32 checksum\n    \"\"\"\n\n    bech = bech.lower()\n    pos = bech.rfind('1')\n    hrp = bech[:pos]\n    data = _codestring_to_array(bech[pos + 1:], 'bech32')\n    hrp_expanded = [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]\n    return _bech32_polymod(hrp_expanded + data)",
  "def pubkeyhash_to_addr(pubkeyhash, prefix=None, encoding='base58', witver=0):\n    \"\"\"\n    Convert public key hash to base58 encoded address\n\n    Wrapper for the :func:`pubkeyhash_to_addr_base58` and :func:`pubkeyhash_to_addr_bech32` method\n\n    :param pubkeyhash: Public key hash\n    :type pubkeyhash: bytes, str\n    :param prefix: Prefix version byte of network, default is bitcoin '\\x00'\n    :type prefix: str, bytes\n    :param encoding: Encoding of address to calculate: base58 or bech32. Default is base58\n    :type encoding: str\n    :param witver: Witness version used. Currently used for Taproot addresses with witver=1. Ignored for base58 addresses\n    :type witver: int\n\n    :return str: Base58 or bech32 encoded address\n\n    \"\"\"\n    if encoding == 'base58':\n        if prefix is None:\n            prefix = b'\\x00'\n        return pubkeyhash_to_addr_base58(pubkeyhash, prefix)\n    elif encoding == 'bech32':\n        if prefix is None:\n            prefix = 'bc'\n        return pubkeyhash_to_addr_bech32(pubkeyhash, prefix, witver)\n    else:\n        raise EncodingError(\"Encoding %s not supported\" % encoding)",
  "def pubkeyhash_to_addr_base58(pubkeyhash, prefix=b'\\x00'):\n    \"\"\"\n    Convert public key hash to base58 encoded address\n\n    >>> pubkeyhash_to_addr_base58('21342f229392d7c9ed82c932916cee6517fbc9a2')\n    '142Zp9WZn9Fh4MV8F3H5Dv4Rbg7Ja1sPWZ'\n\n    :param pubkeyhash: Public key hash\n    :type pubkeyhash: bytes, str\n    :param prefix: Prefix version byte of network, default is bitcoin '\\x00'\n    :type prefix: str, bytes\n\n    :return str: Base-58 encoded address\n    \"\"\"\n    key = to_bytes(prefix) + to_bytes(pubkeyhash)\n    addr256 = key + double_sha256(key)[:4]\n    return base58encode(addr256)",
  "def pubkeyhash_to_addr_bech32(pubkeyhash, prefix='bc', witver=0, separator='1', checksum_xor=1):\n    \"\"\"\n    Encode public key hash as bech32 encoded (segwit) address\n\n    >>> pubkeyhash_to_addr_bech32('21c1bc695a56f47991e95ff26856e50f78d3c118')\n    'bc1qy8qmc6262m68ny0ftlexs4h9paud8sgce3sf84'\n\n    Format of address is prefix/hrp + seperator + bech32 address + checksum\n\n    For more information see BIP173 proposal at https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\n\n    :param pubkeyhash: Public key hash\n    :type pubkeyhash: str, bytes\n    :param prefix: Address prefix or Human-readable part. Default is 'bc' an abbreviation of Bitcoin. Use 'tb' for testnet.\n    :type prefix: str\n    :param witver: Witness version between 0 and 16\n    :type witver: int\n    :param separator: Separator char between hrp and data, should always be left to '1' otherwise it's not standard.\n    :type separator: str\n    :param checksum_xor: checksum 1 for bech32 v0 addresses and 0x2bc830a3 for bech32m v1+ addresses\n    :type checksum_xor: int\n\n    :return str: Bech32 encoded address\n    \"\"\"\n\n    pubkeyhash = list(to_bytes(pubkeyhash))\n\n    # To simplify and speedup: assume pubkeyhash of size 20, 32 and 40 does not contain witness version and size byte\n    if len(pubkeyhash) not in [20, 32, 40]:\n        if pubkeyhash[0] != 0:\n            witver = pubkeyhash[0] - 0x50\n        if pubkeyhash[1] != len(pubkeyhash[2:]):\n            raise EncodingError(\"Incorrect pubkeyhash length\")\n        pubkeyhash = pubkeyhash[2:]\n\n    if witver > 16:\n        raise EncodingError(\"Witness version must be between 0 and 16\")\n\n    if checksum_xor == BECH32M_CONST and not witver:\n        witver = 1\n    elif witver > 0:\n        checksum_xor = BECH32M_CONST\n\n    data = [witver] + convertbits(pubkeyhash, 8, 5)\n\n    # Expand the HRP into values for checksum computation\n    hrp_expanded = [ord(x) >> 5 for x in prefix] + [0] + [ord(x) & 31 for x in prefix]\n    polymod = _bech32_polymod(hrp_expanded + data + [0, 0, 0, 0, 0, 0]) ^ checksum_xor\n    checksum = [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]\n\n    return prefix + separator + _array_to_codestring(data, 'bech32') + _array_to_codestring(checksum, 'bech32')",
  "def _bech32_polymod(values):\n    \"\"\"\n    Internal function that computes the Bech32 checksum\n    \"\"\"\n    generator = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\n    chk = 1\n    for value in values:\n        top = chk >> 25\n        chk = (chk & 0x1ffffff) << 5 ^ value\n        for i in range(5):\n            chk ^= generator[i] if ((top >> i) & 1) else 0\n    return chk",
  "def convertbits(data, frombits, tobits, pad=True):\n    \"\"\"\n    'General power-of-2 base conversion'\n\n    Source: https://github.com/sipa/bech32/tree/master/ref/python\n\n    :param data: Data values to convert\n    :type data: list\n    :param frombits: Number of bits in source data\n    :type frombits: int\n    :param tobits: Number of bits in result data\n    :type tobits: int\n    :param pad: Use padding zero's or not. Default is True\n    :type pad: bool\n\n    :return list: Converted values\n    \"\"\"\n    acc = 0\n    bits = 0\n    ret = []\n    maxv = (1 << tobits) - 1\n    max_acc = (1 << (frombits + tobits - 1)) - 1\n    for value in data:\n        if value < 0 or (value >> frombits):\n            return None\n        acc = ((acc << frombits) | value) & max_acc\n        bits += frombits\n        while bits >= tobits:\n            bits -= tobits\n            ret.append((acc >> bits) & maxv)\n    if pad:\n        if bits:\n            ret.append((acc << (tobits - bits)) & maxv)\n    elif bits >= frombits or ((acc << (tobits - bits)) & maxv):\n        return None\n    return ret",
  "def varstr(string):\n    \"\"\"\n    Convert string to variably sized string: Bytestring preceded with length byte\n\n    >>> varstr(to_bytes('5468697320737472696e67206861732061206c656e677468206f66203330')).hex()\n    '1e5468697320737472696e67206861732061206c656e677468206f66203330'\n\n    :param string: String input\n    :type string: bytes, str\n\n    :return bytes: varstring\n    \"\"\"\n    s = normalize_var(string)\n    if s == b'\\0':\n        return s\n    return int_to_varbyteint(len(s)) + s",
  "def to_bytes(string, unhexlify=True):\n    \"\"\"\n    Convert string, hexadecimal string to bytes\n\n    :param string: String to convert\n    :type string: str, bytes\n    :param unhexlify: Try to unhexlify hexstring\n    :type unhexlify: bool\n\n    :return: Bytes var\n    \"\"\"\n    if not string:\n        return b''\n    if unhexlify:\n        try:\n            if isinstance(string, bytes):\n                string = string.decode()\n            s = bytes.fromhex(string)\n            return s\n        except (TypeError, ValueError):\n            pass\n    if isinstance(string, bytes):\n        return string\n    else:\n        return bytes(string, 'utf8')",
  "def to_hexstring(string):\n    \"\"\"\n    Convert bytes, string to a hexadecimal string. Use instead of built-in hex() method if format\n    of input string is not known.\n\n    >>> to_hexstring(b'\\\\x12\\\\xaa\\\\xdd')\n    '12aadd'\n\n    :param string: Variable to convert to hex string\n    :type string: bytes, str\n\n    :return: hexstring\n    \"\"\"\n    if not string:\n        return ''\n    try:\n        bytes.fromhex(string)\n        return string\n    except (ValueError, TypeError):\n        pass\n\n    if not isinstance(string, bytes):\n        string = bytes(string, 'utf8')\n    return string.hex()",
  "def normalize_string(string):\n    \"\"\"\n    Normalize a string to the default NFKD unicode format\n    See https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization\n\n    :param string: string value\n    :type string: bytes, str\n\n    :return: string\n    \"\"\"\n    if isinstance(string, bytes):\n        utxt = string.decode('utf8')\n    elif isinstance(string, TYPE_TEXT):\n        utxt = string\n    else:\n        raise TypeError(\"String value expected\")\n\n    return unicodedata.normalize('NFKD', utxt)",
  "def double_sha256(string, as_hex=False):\n    \"\"\"\n    Get double SHA256 hash of string\n\n    :param string: String to be hashed\n    :type string: bytes\n    :param as_hex: Return value as hexadecimal string. Default is False\n    :type as_hex: bool\n\n    :return bytes, str:\n    \"\"\"\n    if not as_hex:\n        return hashlib.sha256(hashlib.sha256(string).digest()).digest()\n    else:\n        return hashlib.sha256(hashlib.sha256(string).digest()).hexdigest()",
  "def ripemd160(string):\n    try:\n        return RIPEMD160.new(string).digest()\n    except Exception:\n        return hashlib.new('ripemd160', string).digest()",
  "def hash160(string):\n    \"\"\"\n    Creates a RIPEMD-160 + SHA256 hash of the input string\n\n    :param string: Script\n    :type string: bytes\n\n    :return bytes: RIPEMD-160 hash of script\n    \"\"\"\n    return ripemd160(hashlib.sha256(string).digest())",
  "def aes_encrypt(data, key):\n    \"\"\"\n    Encrypt data using AES Symmetric Block cipher Encryption in SIV mode (see\n    https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#siv-mode)\n\n    A nonce is not used so data is encrypted deterministic, in SIV mode this doesn't reduce security.\n\n    Method returns a byte string with ciphertext and a 16-byte tag. The ciphertext has the same length as the data.\n\n    Data can be decrypted with the :func:`aes_decrypt` method\n\n    :param data: Data to encrypt\n    :type data: bytes\n    :param key: The cryptographic key, size must be 32 bytes because AES-128 is used as cipher\n    :type key: bytes\n\n    :return bytes: Ciphertext and 16 bytes tag\n\n    \"\"\"\n    cipher = AES.new(key, AES.MODE_SIV)\n    ct, tag = cipher.encrypt_and_digest(data)\n    return ct + tag",
  "def aes_decrypt(encrypted_data, key):\n    \"\"\"\n    Decrypt encrypted data using AES Symmetric Block cipher Encryption in SIV mode. Use to decrypt data encrypted\n    with the :func:`aes_encrypt` method. The encrypted data attribute must contain a Ciphertext and 16-byte tag.\n\n    A nonce is not used so data is encrypted deterministic, in SIV mode this doesn't reduce security.\n    (see https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#siv-mode)\n\n    :param encrypted_data: Data to decrypt. Must consist of a ciphertext and 16 byte tag.\n    :type encrypted_data: bytes\n    :param key: The cryptographic key, size must be 32 bytes because AES-128 is used as cipher\n    :type key: bytes\n\n    :return bytes: Ciphertext and 16 bytes tag\n\n    \"\"\"\n    ct = encrypted_data[:-16]\n    tag = encrypted_data[-16:]\n    cipher2 = AES.new(key, AES.MODE_SIV)\n    return cipher2.decrypt_and_verify(ct, tag)",
  "def bip38_decrypt(encrypted_privkey, password):\n    \"\"\"\n    BIP0038 non-ec-multiply decryption. Returns WIF private key.\n    Based on code from https://github.com/nomorecoin/python-bip38-testing\n    This method is called by Key class init function when importing BIP0038 key.\n\n    :param encrypted_privkey: Encrypted private key using WIF protected key format\n    :type encrypted_privkey: str\n    :param password: Required password for decryption\n    :type password: str\n\n    :return tupple (bytes, bytes): (Private Key bytes, 4 byte address hash for verification)\n    \"\"\"\n    d = change_base(encrypted_privkey, 58, 256)[2:]\n    flagbyte = d[0:1]\n    d = d[1:]\n    if flagbyte == b'\\xc0':\n        compressed = False\n    elif flagbyte == b'\\xe0':\n        compressed = True\n    else:\n        raise EncodingError(\"Unrecognised password protected key format. Flagbyte incorrect.\")\n    if isinstance(password, str):\n        password = password.encode('utf-8')\n    addresshash = d[0:4]\n    d = d[4:-4]\n    try:\n        key = scrypt(password, addresshash, 64, 16384, 8, 8)\n    except Exception:\n        key = scrypt.hash(password, addresshash, 16384, 8, 8, 64)\n    derivedhalf1 = key[0:32]\n    derivedhalf2 = key[32:64]\n    encryptedhalf1 = d[0:16]\n    encryptedhalf2 = d[16:32]\n    # aes = pyaes.AESModeOfOperationECB(derivedhalf2)\n    aes = AES.new(derivedhalf2, AES.MODE_ECB)\n    decryptedhalf2 = aes.decrypt(encryptedhalf2)\n    decryptedhalf1 = aes.decrypt(encryptedhalf1)\n    priv = decryptedhalf1 + decryptedhalf2\n    priv = (int.from_bytes(priv, 'big') ^ int.from_bytes(derivedhalf1, 'big')).to_bytes(32, 'big')\n    # if compressed:\n    #     # FIXME: This works but does probably not follow the BIP38 standards (was before: priv = b'\\0' + priv)\n    #     priv += b'\\1'\n    return priv, addresshash, compressed",
  "def bip38_encrypt(private_hex, address, password, flagbyte=b'\\xe0'):\n    \"\"\"\n    BIP0038 non-ec-multiply encryption. Returns BIP0038 encrypted private key\n    Based on code from https://github.com/nomorecoin/python-bip38-testing\n\n    :param private_hex: Private key in hex format\n    :type private_hex: str\n    :param address: Address string\n    :type address: str\n    :param password: Required password for encryption\n    :type password: str\n    :param flagbyte: Flagbyte prefix for WIF\n    :type flagbyte: bytes\n\n    :return str: BIP38 password encrypted private key\n    \"\"\"\n    if isinstance(address, str):\n        address = address.encode('utf-8')\n    if isinstance(password, str):\n        password = password.encode('utf-8')\n    addresshash = double_sha256(address)[0:4]\n    try:\n        key = scrypt(password, addresshash, 64, 16384, 8, 8)\n    except Exception:\n        key = scrypt.hash(password, addresshash, 16384, 8, 8, 64)\n    derivedhalf1 = key[0:32]\n    derivedhalf2 = key[32:64]\n    aes = AES.new(derivedhalf2, AES.MODE_ECB)\n    # aes = pyaes.AESModeOfOperationECB(derivedhalf2)\n    encryptedhalf1 = \\\n        aes.encrypt((int(private_hex[0:32], 16) ^ int.from_bytes(derivedhalf1[0:16], 'big')).to_bytes(16, 'big'))\n    encryptedhalf2 = \\\n        aes.encrypt((int(private_hex[32:64], 16) ^ int.from_bytes(derivedhalf1[16:32], 'big')).to_bytes(16, 'big'))\n    encrypted_privkey = b'\\x01\\x42' + flagbyte + addresshash + encryptedhalf1 + encryptedhalf2\n    encrypted_privkey += double_sha256(encrypted_privkey)[:4]\n    return base58encode(encrypted_privkey)",
  "class Quantity:\n    \"\"\"\n    Class to convert very large or very small numbers to a readable format.\n\n    Provided value is converted to number between 0 and 1000, and a metric prefix will be added.\n\n    >>> # Example - the Hashrate on 10th July 2020\n    >>> str(Quantity(122972532877979100000, 'H/s'))\n    '122.973 EH/s'\n\n    \"\"\"\n\n    def __init__(self, value, units='', precision=3):\n        \"\"\"\n        Convert given value to number between 0 and 1000 and determine metric prefix\n\n        :param value: Value as integer in base 0\n        :type value: int, float\n        :param units: Base units, so 'g' for grams for instance\n        :type units: str\n        :param precision: Number of digits after the comma\n        :type precision: int\n\n        \"\"\"\n        # Metric prefixes according to BIPM, the International System of Units (SI) in 10**3 steps\n        self.prefix_list = list('yzafpn\u03bcm1kMGTPEZY')\n        self.base = self.prefix_list.index('1')\n        assert value >= 0\n\n        self.absolute = value\n        self.units = units\n        self.precision = precision\n        while value != 0 and (value < 1 or value > 1000) and 0 < self.base < len(self.prefix_list)-1:\n            if value > 1000:\n                self.base += 1\n                value /= 1000.0\n            elif value < 1000:\n                self.base -= 1\n                value *= 1000.0\n        self.value = value\n\n    def __str__(self):\n        # > Python 3.6: return f\"{self.value:4.{self.precision}f} {self.prefix_list[self.base]}{self.units}\"\n        prefix = self.prefix_list[self.base]\n        if prefix == '1':\n            prefix = ''\n        return ('%4.*f %s%s' % (self.precision, self.value, prefix, self.units)).strip()",
  "def __init__(self, msg=''):\n        self.msg = msg",
  "def __str__(self):\n        return self.msg",
  "def __init__(self, value, units='', precision=3):\n        \"\"\"\n        Convert given value to number between 0 and 1000 and determine metric prefix\n\n        :param value: Value as integer in base 0\n        :type value: int, float\n        :param units: Base units, so 'g' for grams for instance\n        :type units: str\n        :param precision: Number of digits after the comma\n        :type precision: int\n\n        \"\"\"\n        # Metric prefixes according to BIPM, the International System of Units (SI) in 10**3 steps\n        self.prefix_list = list('yzafpn\u03bcm1kMGTPEZY')\n        self.base = self.prefix_list.index('1')\n        assert value >= 0\n\n        self.absolute = value\n        self.units = units\n        self.precision = precision\n        while value != 0 and (value < 1 or value > 1000) and 0 < self.base < len(self.prefix_list)-1:\n            if value > 1000:\n                self.base += 1\n                value /= 1000.0\n            elif value < 1000:\n                self.base -= 1\n                value *= 1000.0\n        self.value = value",
  "def __str__(self):\n        # > Python 3.6: return f\"{self.value:4.{self.precision}f} {self.prefix_list[self.base]}{self.units}\"\n        prefix = self.prefix_list[self.base]\n        if prefix == '1':\n            prefix = ''\n        return ('%4.*f %s%s' % (self.precision, self.value, prefix, self.units)).strip()",
  "class BKeyError(Exception):\n    \"\"\"\n    Handle Key class Exceptions\n\n    \"\"\"\n\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "def check_network_and_key(key, network=None, kf_networks=None, default_network=DEFAULT_NETWORK):\n    \"\"\"\n    Check if given key corresponds with given network and return network if it does. If no network is specified\n    this method tries to extract the network from the key. If no network can be extracted from the key the\n    default network will be returned.\n\n    >>> check_network_and_key('L4dTuJf2ceEdWDvCPsLhYf8GiiuYqXtqfbcKdC21BPDvEM1ykJRC')\n    'bitcoin'\n    \n    A BKeyError will be raised if key does not correspond with network or if multiple network are found.\n    \n    :param key: Key in any format recognized by get_key_format function\n    :type key: str, int, bytes\n    :param network: Optional network. Method raises BKeyError if keys belongs to another network\n    :type network: str, None\n    :param kf_networks: Optional list of networks which is returned by get_key_format. If left empty the get_key_format function will be called.\n    :type kf_networks: list, None\n    :param default_network: Specify different default network, leave empty for default (bitcoin)\n    :type default_network: str, None\n    \n    :return str: Network name\n    \"\"\"\n    if not kf_networks:\n        kf = get_key_format(key)\n        if kf['networks']:\n            kf_networks = kf['networks']\n    if kf_networks:\n        if network is not None and network not in kf_networks:\n            raise BKeyError(\"Specified key %s is from different network then specified: %s\" % (kf_networks, network))\n        elif network is None and len(kf_networks) == 1:\n            return kf_networks[0]\n        elif network is None and len(kf_networks) > 1:\n            if default_network in kf_networks:\n                return default_network\n            elif 'testnet' in kf_networks:\n                return 'testnet'\n            raise BKeyError(\"Could not determine network of specified key, multiple networks found: %s\" % kf_networks)\n    if network is None:\n        return default_network\n    else:\n        return network",
  "def get_key_format(key, is_private=None):\n    \"\"\"\n    Determines the type (private or public), format and network key.\n    \n    This method does not validate if a key is valid.\n\n    >>> get_key_format('L4dTuJf2ceEdWDvCPsLhYf8GiiuYqXtqfbcKdC21BPDvEM1ykJRC')\n    {'format': 'wif_compressed', 'networks': ['bitcoin', 'regtest'], 'is_private': True, 'script_types': [], 'witness_types': ['legacy'], 'multisig': [False]}\n\n    >>> get_key_format('becc7ac3b383cd609bd644aa5f102a811bac49b6a34bbd8afe706e32a9ac5c5e')\n    {'format': 'hex', 'networks': None, 'is_private': True, 'script_types': [], 'witness_types': ['legacy'], 'multisig': [False]}\n\n    >>> get_key_format('Zpub6vZyhw1ShkEwNxtqfjk7jiwoEbZYMJdbWLHvEwo6Ns2fFc9rdQn3SerYFQXYxtZYbA8a1d83shW3g4WbsnVsymy2L8m7wpeApiuPxug3ARu')\n    {'format': 'hdkey_public', 'networks': ['bitcoin', 'regtest'], 'is_private': False, 'script_types': ['p2wsh'], 'witness_types': ['segwit'], 'multisig': [True]}\n\n    :param key: Any private or public key\n    :type key: str, int, bytes\n    :param is_private: Is key private or not?\n    :type is_private: bool\n    \n    :return dict: Dictionary with format, network and is_private\n    \"\"\"\n    if not key:\n        raise BKeyError(\"Key empty, please specify a valid key\")\n    key_format = \"\"\n    networks = None\n    script_types = []\n    witness_types = ['legacy']\n    multisig = [False]\n\n    # if isinstance(key, bytes) and len(key) in [128, 130]:\n    #     key = to_hexstring(key)\n    if not (is_private is None or isinstance(is_private, bool)):\n        raise BKeyError(\"Attribute 'is_private' must be False or True\")\n    elif isinstance(key, numbers.Number):\n        key_format = 'decimal'\n        is_private = True\n    elif isinstance(key, bytes) and len(key) in [33, 65] and key[:1] in [b'\\2', b'\\3']:\n        key_format = 'bin_compressed'\n        is_private = False\n    elif isinstance(key, bytes) and (len(key) in [33, 65] and key[:1] == b'\\4'):\n        key_format = 'bin'\n        is_private = False\n    elif isinstance(key, bytes) and len(key) == 33 and key[-1:] == b'\\1':\n        key_format = 'bin_compressed'\n        is_private = True\n    elif isinstance(key, bytes) and len(key) == 32:\n        key_format = 'bin'\n        is_private = True\n    elif len(key) == 130 and key[:2] == '04' and not is_private:\n        key_format = 'public_uncompressed'\n        is_private = False\n    elif len(key) == 128:\n        key_format = 'hex'\n        if is_private is None:\n            is_private = True\n    elif len(key) == 66 and key[:2] in ['02', '03'] and not is_private:\n        key_format = 'public'\n        is_private = False\n    elif len(key) == 64:\n        key_format = 'hex'\n        if is_private is None:\n            is_private = True\n    elif len(key) == 66 and key[-2:] in ['01'] and not (is_private is False):\n        key_format = 'hex_compressed'\n        is_private = True\n    elif len(key) == 58 and key[:2] == '6P':\n        key_format = 'wif_protected'\n        is_private = True\n    elif isinstance(key, TYPE_TEXT) and len(key.split(' ')) > 1:\n        key_format = 'mnemonic'\n        is_private = True\n    else:\n        try:\n            key_hex = change_base(key, 58, 16)\n            prefix_data = wif_prefix_search(key_hex[:8])\n            if prefix_data:\n                networks = list(dict.fromkeys([n['network'] for n in prefix_data]))\n                if is_private is None and len(set([n['is_private'] for n in prefix_data])) > 1:\n                    raise BKeyError(\"Cannot determine if key is private or public, please specify is_private \"\n                                    \"attribute\")\n                is_private = prefix_data[0]['is_private']\n                script_types = list(dict.fromkeys([n['script_type'] for n in prefix_data]))\n                witness_types = list(dict.fromkeys([n['witness_type'] for n in prefix_data]))\n                multisig = list(dict.fromkeys([n['multisig'] for n in prefix_data]))\n                key_format = 'hdkey_public'\n                if is_private:\n                    key_format = 'hdkey_private'\n            else:\n                networks = network_by_value('prefix_wif', key_hex[:2])\n                if networks:\n                    if key_hex[-10:-8] == '01':\n                        key_format = 'wif_compressed'\n                    else:\n                        key_format = 'wif'\n                    is_private = True\n        except (TypeError, EncodingError):\n            pass\n    if not key_format:\n        try:\n            int(key)\n            if 70 < len(key) < 78:\n                key_format = 'decimal'\n                is_private = True\n        except (TypeError, ValueError):\n            pass\n    if not key_format:\n        try:\n            da = deserialize_address(key)\n            key_format = 'address'\n            networks = da['network']\n            is_private = False\n            script_types = da['script_type']\n        except (EncodingError, TypeError):\n            pass\n    if not key_format:\n        raise BKeyError(\"Unrecognised key format\")\n    else:\n        return {\n            \"format\": key_format,\n            \"networks\": networks,\n            \"is_private\": is_private,\n            \"script_types\": script_types,\n            \"witness_types\": witness_types,\n            \"multisig\": multisig\n        }",
  "def deserialize_address(address, encoding=None, network=None):\n    \"\"\"\n    Deserialize address. Calculate public key hash and try to determine script type and network.\n\n    The 'network' dictionary item with contains the network with the highest priority if multiple networks are found. Same applies for the script type.\n\n    Specify the network argument if network is known to avoid unexpected results.\n\n    If more networks and or script types are found you can find these in the 'networks' field.\n\n    >>> deserialize_address('1Khyc5eUddbhYZ8bEZi9wiN8TrmQ8uND4j')\n    {'address': '1Khyc5eUddbhYZ8bEZi9wiN8TrmQ8uND4j', 'encoding': 'base58', 'public_key_hash': 'cd322766c02e7c37c3e3f9b825cd41ffbdcd17d7', 'public_key_hash_bytes': b\"\\\\xcd2'f\\\\xc0.|7\\\\xc3\\\\xe3\\\\xf9\\\\xb8%\\\\xcdA\\\\xff\\\\xbd\\\\xcd\\\\x17\\\\xd7\", 'prefix': b'\\\\x00', 'network': 'bitcoin', 'script_type': 'p2pkh', 'witness_type': 'legacy', 'networks': ['bitcoin', 'regtest'], 'witver': None}\n\n    :param address: A base58 or bech32 encoded address\n    :type address: str\n    :param encoding: Encoding scheme used for address encoding. Attempts to guess encoding if not specified.\n    :type encoding: str\n    :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network\n    :type network: str\n\n    :return dict: with information about this address\n    \"\"\"\n\n    if encoding is None or encoding == 'base58':\n        try:\n            address_bytes = change_base(address, 58, 256, 25)\n        except EncodingError:\n            pass\n        else:\n            check = address_bytes[-4:]\n            key_hash = address_bytes[:-4]\n            checksum = double_sha256(key_hash)[0:4]\n            if check != checksum and encoding == 'base58':\n                raise BKeyError(\"Invalid address %s, checksum incorrect\" % address)\n            elif check == checksum:\n                address_prefix = key_hash[0:1]\n                networks_p2pkh = network_by_value('prefix_address', address_prefix.hex())\n                networks_p2sh = network_by_value('prefix_address_p2sh', address_prefix.hex())\n                public_key_hash = key_hash[1:]\n                script_type = ''\n                witness_type = ''\n                networks = []\n                if networks_p2pkh and not networks_p2sh:\n                    script_type = 'p2pkh'\n                    witness_type = 'legacy'\n                    networks = networks_p2pkh\n                elif networks_p2sh:\n                    script_type = 'p2sh'\n                    networks = networks_p2sh\n                if network:\n                    if network not in networks:\n                        raise BKeyError(\"Network %s not found in extracted networks: %s\" % (network, networks))\n                elif len(networks) >= 1:\n                    network = networks[0]\n                return {\n                    'address': address,\n                    'encoding': 'base58',\n                    'public_key_hash': '' if not public_key_hash else public_key_hash.hex(),\n                    'public_key_hash_bytes': public_key_hash,\n                    'prefix': address_prefix,\n                    'network': network,\n                    'script_type': script_type,\n                    'witness_type': witness_type,\n                    'networks': networks,\n                    'witver': None,\n                }\n    if encoding == 'bech32' or encoding is None:\n        try:\n            pkh_incl = addr_bech32_to_pubkeyhash(address, include_witver=True)\n            public_key_hash = pkh_incl[2:]\n            witver = pkh_incl[0] - 0x50 if pkh_incl[0] else 0\n            prefix = address[:address.rfind('1')]\n            networks = network_by_value('prefix_bech32', prefix)\n            witness_type = 'segwit' if not witver else 'taproot'\n            if len(public_key_hash) == 20:\n                script_type = 'p2wpkh'\n            else:\n                script_type = 'p2wsh' if not witver else 'p2tr'\n            return {\n                'address': address,\n                'encoding': 'bech32',\n                'public_key_hash': '' if not public_key_hash else public_key_hash.hex(),\n                'public_key_hash_bytes': public_key_hash,\n                'prefix': prefix,\n                'network': '' if not networks else networks[0],\n                'script_type': script_type,\n                'witness_type': witness_type,\n                'networks': networks,\n                'witver': witver,\n            }\n        except EncodingError as err:\n            raise EncodingError(\"Invalid address %s: %s\" % (address, err))\n    else:\n        raise EncodingError(\"Address %s is not in specified encoding %s\" % (address, encoding))",
  "def addr_convert(addr, prefix, encoding=None, to_encoding=None):\n    \"\"\"\n    Convert address to another encoding and/or address with another prefix.\n\n    >>> addr_convert('1GMDUKLom6bJuY37RuFNc6PHv1rv2Hziuo', prefix='bc', to_encoding='bech32')\n    'bc1q4pwfmstmw8q80nxtxud2h42lev9xzcjqwqyq7t'\n\n    :param addr: Base58 address\n    :type addr: str\n    :param prefix: New address prefix\n    :type prefix: str, bytes\n    :param encoding: Encoding of original address: base58 or bech32. Leave empty to extract from address\n    :type encoding: str\n    :param to_encoding: Encoding of converted address: base58 or bech32. Leave empty use same encoding as original address\n    :type to_encoding: str\n\n    :return str: New converted address\n    \"\"\"\n\n    if encoding is None:\n        da = deserialize_address(addr)\n        encoding = da['encoding']\n    pkh = addr_to_pubkeyhash(addr, encoding=encoding)\n    if to_encoding is None:\n        to_encoding = encoding\n    if isinstance(prefix, TYPE_TEXT) and to_encoding == 'base58':\n        prefix = to_hexstring(prefix)\n    return pubkeyhash_to_addr(pkh, prefix=prefix, encoding=to_encoding)",
  "def path_expand(path, path_template=None, level_offset=None, account_id=0, cosigner_id=0, purpose=44,\n                address_index=0, change=0, witness_type=DEFAULT_WITNESS_TYPE, multisig=False, network=DEFAULT_NETWORK):\n    \"\"\"\n    Create key path. Specify part of key path and path settings\n\n    >>> path_expand([10, 20], witness_type='segwit')\n    ['m', \"84'\", \"0'\", \"0'\", '10', '20']\n\n    :param path: Part of path, for example [0, 2] for change=0 and address_index=2\n    :type path: list, str\n    :param path_template: Template for path to create, default is BIP 44: [\"m\", \"purpose'\", \"coin_type'\",  \"account'\", \"change\", \"address_index\"]\n    :type path_template: list\n    :param level_offset: Just create part of path. For example -2 means create path with the last 2 items (change, address_index) or 1 will return the master key 'm'\n    :type level_offset: int\n    :param account_id: Account ID\n    :type account_id: int\n    :param cosigner_id: ID of cosigner\n    :type cosigner_id: int\n    :param purpose: Purpose value\n    :type purpose: int\n    :param address_index: Index of key, normally provided to 'path' argument\n    :type address_index: int\n    :param change: Change key = 1 or normal = 0, normally provided to 'path' argument\n    :type change: int\n    :param witness_type: Witness type for paths with a script ID, specify 'p2sh-segwit' or 'segwit'\n    :type witness_type: str\n    :param multisig: Is path for multisig keys?\n    :type multisig: bool\n    :param network: Network name. Leave empty for default network\n    :type network: str\n\n    :return list:\n    \"\"\"\n    if isinstance(path, TYPE_TEXT):\n        path = path.split('/')\n    if not path_template:\n        ks = [k for k in WALLET_KEY_STRUCTURES if\n              k['witness_type'] == witness_type and k['multisig'] == multisig and k['purpose'] is not None]\n        if ks:\n            purpose = ks[0]['purpose']\n            path_template = ks[0]['key_path']\n    if not isinstance(path, list):\n        raise BKeyError(\"Please provide path as list with at least 1 item. Wallet key path format is %s\" %\n                        path_template)\n    if len(path) > len(path_template):\n        raise BKeyError(\"Invalid path provided. Path should be shorter than %d items. \"\n                        \"Wallet key path format is %s\" % (len(path_template), path_template))\n\n    # If path doesn't start with m/M complement path\n    poppath = deepcopy(path)\n    if path == [] or path[0] not in ['m', 'M']:\n        wallet_key_path = path_template\n        if level_offset:\n            wallet_key_path = wallet_key_path[:level_offset]\n        new_path = []\n        for pi in wallet_key_path[::-1]:\n            if not len(poppath):\n                new_path.append(pi)\n            else:\n                new_path.append(poppath.pop())\n        new_path = new_path[::-1]\n    else:\n        new_path = deepcopy(path)\n\n    # Replace variable names in path with corresponding values\n    # network, account_id, _ = self._get_account_defaults(network, account_id)\n    script_type_id = 1 if witness_type == 'p2sh-segwit' else 2\n    var_defaults = {\n        'network': network,\n        'account': account_id,\n        'purpose': purpose,\n        'coin_type': Network(network).bip44_cointype,\n        'script_type': script_type_id,\n        'cosigner_index': cosigner_id,\n        'change': change,\n        'address_index': address_index\n    }\n    npath = new_path\n    for i, pi in enumerate(new_path):\n        if not isinstance(pi, TYPE_TEXT):\n            pi = str(pi)\n        if pi in \"mM\":\n            continue\n        hardened = False\n        varname = pi\n        if pi[-1:] == \"'\" or (pi[-1:] in \"HhPp\" and pi[:-1].isdigit()):\n            varname = pi[:-1]\n            hardened = True\n        if path_template[i][-1:] == \"'\":\n            hardened = True\n        new_varname = (str(var_defaults[varname]) if varname in var_defaults else varname)\n        if new_varname == varname and not new_varname.isdigit():\n            raise BKeyError(\"Variable %s not found in Key structure definitions in main.py\" % varname)\n        if varname == 'address_index' and address_index is None:\n            raise BKeyError(\"Please provide value for 'address_index' or 'path'\")\n        npath[i] = new_varname + (\"'\" if hardened else '')\n    if \"None'\" in npath or \"None\" in npath:\n        raise BKeyError(\"Could not parse all variables in path %s\" % npath)\n    return npath",
  "class Address(object):\n    \"\"\"\n    Class to store, convert and analyse various address types as representation of public keys or scripts hashes\n    \"\"\"\n\n    @classmethod\n    @deprecated\n    def import_address(cls, address, compressed=None, encoding=None, depth=None, change=None,\n                       address_index=None, network=None, network_overrides=None):\n        \"\"\"\n        Import an address to the Address class. Specify network if available, otherwise it will be\n        derived form the address.\n\n        :param address: Address to import\n        :type address: str\n        :param compressed: Is key compressed or not, default is None\n        :type compressed: bool\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding. Leave empty to derive from address\n        :type encoding: str\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param change: Use 0 for normal address/key, and 1 for change address (for returned/change payments)\n        :type change: int\n        :param address_index: Index of address. Used in BIP32 key paths\n        :type address_index: int\n        :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network\n        :type network: str\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        :return Address:\n        \"\"\"\n        return cls.parse(address, compressed, encoding, depth, change, address_index, network, network_overrides)\n\n    @classmethod\n    def parse(cls, address, compressed=None, encoding=None, depth=None, change=None,\n              address_index=None, network=None, network_overrides=None):\n        \"\"\"\n        Import an address to the Address class. Specify network if available, otherwise it will be\n        derived form the address.\n\n        >>> addr = Address.parse('bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3')\n        >>> addr.as_dict()\n        {'network': 'bitcoin', '_data': None, 'script_type': 'p2wsh', 'encoding': 'bech32', 'compressed': None, 'witver': 0, 'witness_type': 'segwit', 'depth': None, 'change': None, 'address_index': None, 'prefix': 'bc', 'redeemscript': '', '_hashed_data': None, 'address': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3', 'address_orig': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3'}\n\n        :param address: Address to import\n        :type address: str\n        :param compressed: Is key compressed or not, default is None\n        :type compressed: bool\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding. Leave empty to derive from address\n        :type encoding: str\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param change: Use 0 for normal address/key, and 1 for change address (for returned/change payments)\n        :type change: int\n        :param address_index: Index of address. Used in BIP32 key paths\n        :type address_index: int\n        :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network\n        :type network: str\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        :return Address:\n        \"\"\"\n        if encoding is None and address[:3].split(\"1\")[0] in ENCODING_BECH32_PREFIXES:\n            encoding = 'bech32'\n        addr_dict = deserialize_address(address, encoding=encoding, network=network)\n        public_key_hash_bytes = addr_dict['public_key_hash_bytes']\n        prefix = addr_dict['prefix']\n        if network is None:\n            network = addr_dict['network']\n        script_type = addr_dict['script_type']\n        return Address(hashed_data=public_key_hash_bytes, prefix=prefix, script_type=script_type,\n                       compressed=compressed, encoding=addr_dict['encoding'], depth=depth, change=change,\n                       address_index=address_index, network=network, network_overrides=network_overrides)\n\n    def __init__(self, data='', hashed_data='', prefix=None, script_type=None,\n                 compressed=None, encoding=None, witness_type=None, witver=0, depth=None, change=None,\n                 address_index=None, network=DEFAULT_NETWORK, network_overrides=None):\n        \"\"\"\n        Initialize an Address object. Specify a public key, redeemscript or a hash.\n\n        >>> addr = Address('03715219f51a2681b7642d1e0e35f61e5288ff59b87d275be9eaf1a5f481dcdeb6', encoding='bech32', script_type='p2wsh')\n        >>> addr.address\n        'bc1qaehsuffn0stxmugx3z69z9hm6gnjd9qzeqlfv92cpf5adw63x4tsfl7vwl'\n\n        :param data: Public key, redeem script or other type of script.\n        :type data: str, bytes\n        :param hashed_data: Hash of a public key or script. Will be generated if 'data' parameter is provided\n        :type hashed_data: str, bytes\n        :param prefix: Address prefix. Use default network / script_type prefix if not provided\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param witver: Witness version. Used for p2tr addresses\n        :type witver: int\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding\n        :type encoding: str\n        :param witness_type: Specify 'legacy', 'segwit' or 'p2sh-segwit'. Legacy for old-style bitcoin addresses, segwit for native segwit addresses and p2sh-segwit for segwit embedded in a p2sh script. Leave empty to derive automatically from script type if possible\n        :type witness_type: str\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        \"\"\"\n        self.network = network\n        if not (data or hashed_data):\n            raise BKeyError(\"Please specify data (public key or script) or hashed_data argument\")\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.data_bytes = to_bytes(data)\n        self._data = None\n        self.script_type = script_type\n        self.encoding = encoding\n        self.compressed = compressed\n        self.witver = witver\n        if witness_type is None:\n            if self.script_type in ['p2wpkh', 'p2wsh']:\n                witness_type = 'segwit'\n            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:\n                witness_type = 'p2sh-segwit'\n            elif self.script_type == 'p2tr':\n                witness_type = 'taproot'\n                self.witver = 1 if self.witver == 0 else self.witver\n        self.witness_type = witness_type\n        self.depth = depth\n        self.change = change\n        self.address_index = address_index\n\n        if self.encoding is None:\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr'] or self.witness_type == 'segwit':\n                self.encoding = 'bech32'\n            else:\n                self.encoding = 'base58'\n        self.hash_bytes = to_bytes(hashed_data)\n        self.prefix = prefix\n        self.redeemscript = b''\n        if not self.hash_bytes:\n            if (self.encoding == 'bech32' and self.script_type in ['p2sh', 'p2sh_multisig', 'p2tr']) or \\\n                    self.script_type in ['p2wsh', 'p2sh_p2wsh']:\n                self.hash_bytes = hashlib.sha256(self.data_bytes).digest()\n            else:\n                self.hash_bytes = hash160(self.data_bytes)\n        self._hashed_data = None\n        if self.encoding == 'base58':\n            if self.script_type is None:\n                self.script_type = 'p2pkh'\n            if self.witness_type == 'p2sh-segwit':\n                self.redeemscript = b'\\0' + varstr(self.hash_bytes)\n                # overwrite hash_bytes with hash of redeemscript\n                self.hash_bytes = hash160(self.redeemscript)\n            if self.prefix is None:\n                if self.script_type in ['p2sh', 'p2sh_p2wpkh', 'p2sh_p2wsh', 'p2sh_multisig'] or \\\n                        self.witness_type == 'p2sh-segwit':\n                    self.prefix = self.network.prefix_address_p2sh\n                else:\n                    self.prefix = self.network.prefix_address\n            else:\n                self.prefix = to_bytes(prefix)\n        elif self.encoding == 'bech32':\n            if self.script_type is None:\n                self.script_type = 'p2wpkh'\n            if self.prefix is None:\n                self.prefix = self.network.prefix_bech32\n        else:\n            raise BKeyError(\"Encoding %s not supported\" % self.encoding)\n        self.address = pubkeyhash_to_addr(self.hash_bytes, prefix=self.prefix, encoding=self.encoding,\n                                          witver=self.witver)\n        self.address_orig = None\n        provider_prefix = None\n        if network_overrides and 'prefix_address_p2sh' in network_overrides and self.script_type == 'p2sh':\n            provider_prefix = network_overrides['prefix_address_p2sh']\n        self.address_orig = self.address\n        if provider_prefix:\n            self.address = addr_convert(self.address, provider_prefix)\n\n    def __repr__(self):\n        return \"<Address(address=%s)>\" % self.address\n\n    @property\n    def hashed_data(self):\n        if not self._hashed_data:\n            self._hashed_data = self.hash_bytes.hex()\n        return self._hashed_data\n\n    @property\n    def data(self):\n        if not self._data:\n            self._data = self.data_bytes.hex()\n        return self._data\n\n    def as_dict(self):\n        \"\"\"\n        Get current Address class as dictionary. Byte values are represented by hexadecimal strings\n\n        :return dict:\n        \"\"\"\n        addr_dict = deepcopy(self.__dict__)\n        del (addr_dict['data_bytes'])\n        del (addr_dict['hash_bytes'])\n        if isinstance(addr_dict['network'], Network):\n            addr_dict['network'] = addr_dict['network'].name\n        addr_dict['redeemscript'] = addr_dict['redeemscript'].hex()\n        addr_dict['prefix'] = addr_dict['prefix']\n        return addr_dict\n\n    def as_json(self):\n        \"\"\"\n        Get current key as json formatted string\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict()\n        return json.dumps(adict, indent=4)\n\n    def with_prefix(self, prefix):\n        \"\"\"\n        Convert address using another prefix\n\n        :param prefix: Address prefix\n        :type prefix: str, bytes\n\n        :return str: Converted address\n        \"\"\"\n        return addr_convert(self.address, prefix)",
  "class Key(object):\n    \"\"\"\n    Class to generate, import and convert public cryptographic key pairs used for bitcoin.\n\n    If no key is specified when creating class a cryptographically secure Private Key is\n    generated using the os.urandom() function.\n    \"\"\"\n\n    @staticmethod\n    def from_wif(wif, network=None):\n        \"\"\"\n        Import private key in WIF format.\n\n        :param wif: Private key in WIF format\n        :type wif: str\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n\n        :return Key:\n        \"\"\"\n        key_hex = change_base(wif, 58, 16)\n        networks = network_by_value('prefix_wif', key_hex[:2])\n        compressed = False\n        if networks:\n            if key_hex[-10:-8] == '01':\n                compressed = True\n            network = network or next(iter(networks), DEFAULT_NETWORK)\n        else:\n            raise BKeyError(\"Could not create key, wif format not recognised\")\n        return Key(wif, network, compressed, is_private=True)\n\n    def __init__(self, import_key=None, network=None, compressed=True, password='', is_private=None, strict=True):\n        \"\"\"\n        Initialize a Key object. Import key can be in WIF, bytes, hexstring, etc. If import_key is empty a new\n        private key will be generated.\n\n        If a private key is imported a public key will be derived. If a public is imported the private key data will\n        be empty.\n\n        Both compressed and uncompressed key version is available, the compressed boolean attribute tells if the\n        original imported key was compressed or not.\n\n        >>> k = Key('cNUpWJbC1hVJtyxyV4bVAnb4uJ7FPhr82geo1vnoA29XWkeiiCQn')\n        >>> k.secret\n        12127227708610754620337553985245292396444216111803695028419544944213442390363\n\n        Can also be used to import BIP-38 password protected keys\n\n        >>> k2 = Key('6PYM8wAnnmAK5mHYoF7zqj88y5HtK7eiPeqPdu4WnYEFkYKEEoMFEVfuDg', password='test', network='testnet')\n        >>> k2.secret\n        12127227708610754620337553985245292396444216111803695028419544944213442390363\n\n        :param import_key: If specified import given private or public key. If not specified a new private key is generated.\n        :type import_key: str, int, bytes\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param password: Optional password if imported key is password protected\n        :type password: str\n        :param is_private: Specify if imported key is private or public. Default is None: derive from provided key\n        :type is_private: bool\n        :param strict: Raise BKeyError if key is invalid. Default is True. Set to False if you're parsing blockchain transactions, as some may contain invalid keys, but the transaction is/was still valid.\n        :type strict: bool\n\n        :return: Key object\n        \"\"\"\n        self.public_hex = None\n        self._public_uncompressed_hex = None\n        self.public_compressed_hex = None\n        self.public_byte = None\n        self._public_uncompressed_byte = None\n        self.public_compressed_byte = None\n        self.private_byte = None\n        self.private_hex = None\n        self._x = None\n        self._y = None\n        self.x_hex = None\n        self.y_hex = None\n        self.secret = None\n        self.compressed = compressed\n        self._hash160 = None\n        self.key_format = None\n        self.is_private = None\n\n        if not import_key:\n            import_key = random.SystemRandom().randint(1, secp256k1_n - 1)\n            self.key_format = 'decimal'\n            networks_extracted = network\n            assert is_private is True or is_private is None\n            self.is_private = True  # Ignore provided attribute\n        else:\n            try:\n                kf = get_key_format(import_key)\n            except BKeyError:\n                if strict:\n                    raise BKeyError(\"Unrecognised key format\")\n                else:\n                    networks_extracted = []\n            else:\n                if kf['format'] == 'address':\n                    raise BKeyError(\"Can not create Key object from address\")\n                self.key_format = kf[\"format\"]\n                networks_extracted = kf[\"networks\"]\n                self.is_private = is_private if is_private else kf['is_private']\n                if self.is_private is None:\n                    raise BKeyError(\"Could not determine if key is private or public\")\n\n        if network is not None:\n            self.network = network\n            if not isinstance(network, Network):\n                self.network = Network(network)\n        elif networks_extracted:\n            self.network = Network(check_network_and_key(import_key, None, networks_extracted))\n        else:\n            self.network = Network(DEFAULT_NETWORK)\n\n        if self.key_format == \"wif_protected\":\n            import_key, self.compressed = self._bip38_decrypt(import_key, password, network)\n            self.key_format = 'bin_compressed' if self.compressed else 'bin'\n\n        if not self.is_private:\n            self.secret = None\n            pub_key = to_hexstring(import_key)\n            if len(pub_key) == 130:\n                self._public_uncompressed_hex = pub_key\n                self.x_hex = pub_key[2:66]\n                self.y_hex = pub_key[66:130]\n                self._y = int(self.y_hex, 16)\n                self.compressed = False\n                if self._y % 2:\n                    prefix = '03'\n                else:\n                    prefix = '02'\n                self.public_hex = pub_key\n                self.public_compressed_hex = prefix + self.x_hex\n            else:\n                self.public_hex = pub_key\n                self.x_hex = pub_key[2:66]\n                self.compressed = True\n                self._x = int(self.x_hex, 16)\n                self.public_compressed_hex = pub_key\n            self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)\n            if self._public_uncompressed_hex:\n                self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)\n            if self.compressed:\n                self.public_byte = self.public_compressed_byte\n            else:\n                self.public_byte = self.public_uncompressed_byte\n        elif self.is_private and self.key_format == 'decimal':\n            self.secret = int(import_key)\n            self.private_hex = change_base(self.secret, 10, 16, 64)\n            self.private_byte = bytes.fromhex(self.private_hex)\n        elif self.is_private:\n            if self.key_format == 'hex':\n                key_hex = import_key\n                key_byte = bytes.fromhex(key_hex)\n            elif self.key_format == 'hex_compressed':\n                key_hex = import_key[:-2]\n                key_byte = bytes.fromhex(key_hex)\n                self.compressed = True\n            elif self.key_format == 'bin':\n                key_byte = import_key\n                key_hex = key_byte.hex()\n            elif self.key_format == 'bin_compressed':\n                key_byte = import_key\n                if len(import_key) in [33, 65, 129] and import_key[-1:] == b'\\1':\n                    key_byte = import_key[:-1]\n                key_hex = key_byte.hex()\n                self.compressed = True\n            elif self.is_private and self.key_format in ['wif', 'wif_compressed']:\n                # Check and remove Checksum, prefix and postfix tags\n                key = change_base(import_key, 58, 256)\n                checksum = key[-4:]\n                key = key[:-4]\n                if checksum != double_sha256(key)[:4]:\n                    raise BKeyError(\"Invalid checksum, not a valid WIF key\")\n                found_networks = network_by_value('prefix_wif', key[0:1].hex())\n                if not len(found_networks):\n                    raise BKeyError(\"Unrecognised WIF private key, version byte unknown. Versionbyte: %s\" % key[0:1])\n                self._wif = import_key\n                self._wif_prefix = key[0:1]\n                # if self.network.name not in found_networks:\n                #     if len(found_networks) > 1:\n                #         raise BKeyError(\"More then one network found with this versionbyte, please specify network. \"\n                #                         \"Networks found: %s\" % found_networks)\n                #     else:\n                #         _logger.warning(\"Current network %s is different then the one found in key: %s\" %\n                #                         (network, found_networks[0]))\n                #         self.network = Network(found_networks[0])\n                if key[-1:] == b'\\x01':\n                    self.compressed = True\n                    key = key[:-1]\n                else:\n                    self.compressed = False\n                key_byte = key[1:]\n                key_hex = key_byte.hex()\n            else:\n                raise BKeyError(\"Unknown key format %s\" % self.key_format)\n\n            if not (key_byte or key_hex):\n                raise BKeyError(\"Cannot format key in hex or byte format\")\n            self.private_hex = key_hex\n            self.private_byte = key_byte\n            self.secret = int(key_hex, 16)\n        else:\n            raise BKeyError(\"Cannot import key. Public key format unknown\")\n\n        if self.is_private and not (self.public_byte or self.public_hex):\n            if not self.is_private:\n                raise BKeyError(\"Private key has no known secret number\")\n            p = ec_point(self.secret)\n            if USE_FASTECDSA:\n                self._x = p.x\n                self._y = p.y\n            else:\n                self._x = p.x()\n                self._y = p.y()\n            self.x_hex = change_base(self._x, 10, 16, 64)\n            self.y_hex = change_base(self._y, 10, 16, 64)\n            if self._y % 2:\n                prefix = '03'\n            else:\n                prefix = '02'\n\n            self.public_compressed_hex = prefix + self.x_hex\n            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex\n            self.public_hex = self.public_compressed_hex if self.compressed else self.public_uncompressed_hex\n\n            self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)\n            self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)\n            self.public_byte = self.public_compressed_byte if self.compressed else self.public_uncompressed_byte\n        self._address_obj = None\n        self._wif = None\n        self._wif_prefix = None\n\n    def __repr__(self):\n        return \"<Key(public_hex=%s, network=%s)>\" % (self.public_hex, self.network.name)\n\n    def __str__(self):\n        return self.public_hex\n\n    def __bytes__(self):\n        return self.public_byte\n\n    def __add__(self, other):\n        return self.public_byte + other\n\n    def __radd__(self, other):\n        return other + self.public_byte\n\n    def __len__(self):\n        return len(self.public_byte)\n\n    def __eq__(self, other):\n        if other is None or not isinstance(other, Key):\n            return False\n        if self.is_private and other.is_private:\n            return self.private_hex == other.private_hex\n        else:\n            return self.public_hex == other.public_hex\n\n    def __hash__(self):\n        if self.is_private:\n            return hash(self.private_byte)\n        else:\n            return hash(self.public_byte)\n\n    def __int__(self):\n        if self.is_private:\n            return self.secret\n        else:\n            return None\n\n    @property\n    def x(self):\n        if not self._x and self.x_hex:\n            self._x = int(self.x_hex, 16)\n        return self._x\n\n    @property\n    def y(self):\n        if not self._y:\n            if not self.y_hex:\n                self._public_uncompressed_hex = self.public_uncompressed_hex\n            self._y = int(self.y_hex, 16)\n        return self._y\n\n    @property\n    def public_uncompressed_hex(self):\n        if not self._public_uncompressed_hex:\n            # Calculate y from x with y=x^3 + 7 function\n            sign = self.public_hex[:2] == '03'\n            ys = pow(self._x, 3, secp256k1_p) + 7 % secp256k1_p\n            self._y = mod_sqrt(ys)\n            if self._y & 1 != sign:\n                self._y = secp256k1_p - self._y\n            self.y_hex = change_base(self._y, 10, 16, 64)\n            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex\n        return self._public_uncompressed_hex\n\n    @property\n    def public_uncompressed_byte(self):\n        if not self._public_uncompressed_byte:\n            self._public_uncompressed_byte = bytes.fromhex(self.public_uncompressed_hex)\n        return self._public_uncompressed_byte\n\n    def hex(self):\n        return self.public_hex\n\n    def as_dict(self, include_private=False):\n        \"\"\"\n        Get current Key class as dictionary. Byte values are represented by hexadecimal strings.\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return collections.OrderedDict:\n        \"\"\"\n\n        key_dict = collections.OrderedDict()\n        key_dict['network'] = self.network.name\n        key_dict['key_format'] = self.key_format\n        key_dict['compressed'] = self.compressed\n        key_dict['is_private'] = self.is_private\n        if include_private:\n            key_dict['private_hex'] = self.private_hex\n            key_dict['secret'] = self.secret\n            key_dict['wif'] = self.wif()\n        key_dict['public_hex'] = self.public_hex\n        key_dict['public_uncompressed_hex'] = self.public_uncompressed_hex\n        key_dict['hash160'] = self.hash160.hex()\n        key_dict['address'] = self.address()\n        x, y = self.public_point()\n        key_dict['point_x'] = x\n        key_dict['point_y'] = y\n        return key_dict\n\n    def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return str:\n        \"\"\"\n        return json.dumps(self.as_dict(include_private=include_private), indent=4)\n\n    @staticmethod\n    def _bip38_decrypt(encrypted_privkey, password, network=DEFAULT_NETWORK):\n        \"\"\"\n        BIP0038 non-ec-multiply decryption. Returns WIF private key.\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n        This method is called by Key class init function when importing BIP0038 key.\n\n        :param encrypted_privkey: Encrypted private key using WIF protected key format\n        :type encrypted_privkey: str\n        :param password: Required password for decryption\n        :type password: str\n\n        :return str: Private Key WIF\n        \"\"\"\n        priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)\n\n        # Verify addresshash\n        k = Key(priv, compressed=compressed, network=network)\n        addr = k.address()\n        if isinstance(addr, str):\n            addr = addr.encode('utf-8')\n        if double_sha256(addr)[0:4] != addresshash:\n            raise BKeyError('Addresshash verification failed! Password or '\n                            'specified network %s might be incorrect' % network)\n        return priv, compressed\n\n    def encrypt(self, password):\n        \"\"\"\n        BIP0038 non-ec-multiply encryption. Returns BIP0038 encrypted private key\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n\n        >>> k = Key('cNUpWJbC1hVJtyxyV4bVAnb4uJ7FPhr82geo1vnoA29XWkeiiCQn')\n        >>> k.encrypt('test')\n        '6PYM8wAnnmAK5mHYoF7zqj88y5HtK7eiPeqPdu4WnYEFkYKEEoMFEVfuDg'\n\n        :param password: Required password for encryption\n        :type password: str\n\n        :return str: BIP38 password encrypted private key\n        \"\"\"\n        flagbyte = b'\\xe0' if self.compressed else b'\\xc0'\n        return bip38_encrypt(self.private_hex, self.address(), password, flagbyte)\n\n    @deprecated\n    def bip38_encrypt(self, password):\n        return self.encrypt(password)\n\n    def wif(self, prefix=None):\n        \"\"\"\n        Get private Key in Wallet Import Format, steps:\n        # Convert to Binary and add 0x80 hex\n        # Calculate Double SHA256 and add as checksum to end of key\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n\n        :return str: Base58Check encoded Private Key WIF\n        \"\"\"\n        if not self.secret:\n            raise BKeyError(\"WIF format not supported for public key\")\n        if prefix is None:\n            versionbyte = self.network.prefix_wif\n        else:\n            if not isinstance(prefix, bytes):\n                versionbyte = bytes.fromhex(prefix)\n            else:\n                versionbyte = prefix\n\n        if self._wif and self._wif_prefix == versionbyte:\n            return self._wif\n\n        key = versionbyte + self.secret.to_bytes(32, byteorder='big')\n        if self.compressed:\n            key += b'\\1'\n        key += double_sha256(key)[:4]\n        self._wif = base58encode(key)\n        self._wif_prefix = versionbyte\n        return self._wif\n\n    def public(self):\n        \"\"\"\n        Get public version of current key. Removes all private information from current key\n\n        :return Key: Public key\n        \"\"\"\n        key = deepcopy(self)\n        key.is_private = False\n        key.private_byte = None\n        key.private_hex = None\n        key.secret = None\n        return key\n\n    def public_point(self):\n        \"\"\"\n        Get public key point on Elliptic curve\n\n        :return tuple: (x, y) point\n        \"\"\"\n        return (self.x, self.y)\n\n    @property\n    def hash160(self):\n        \"\"\"\n        Get public key in RIPEMD-160 + SHA256 format\n\n        :return bytes:\n        \"\"\"\n        if not self._hash160:\n            self._hash160 = hash160(self.public_byte if self.compressed else self.public_uncompressed_byte)\n        return self._hash160\n\n    @property\n    def address_obj(self):\n        \"\"\"\n        Get address object property. Create standard address object if not defined already.\n\n        :return Address:\n        \"\"\"\n        if not self._address_obj:\n            self.address()\n        return self._address_obj\n\n    def address(self, compressed=None, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get address derived from public key\n\n        :param compressed: Always return compressed address\n        :type compressed: bool\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 or Bech32 encoded address\n        \"\"\"\n        if (self.compressed and compressed is None) or compressed:\n            data = self.public_byte\n            self.compressed = True\n        else:\n            data = self.public_uncompressed_byte\n            self.compressed = False\n        if encoding is None:\n            if self._address_obj:\n                encoding = self._address_obj.encoding\n            else:\n                encoding = 'base58'\n        if not self.compressed and encoding == 'bech32':\n            raise BKeyError(\"Uncompressed keys are non-standard for segwit/bech32 encoded addresses\")\n        if self._address_obj and script_type is None:\n            script_type = self._address_obj.script_type\n        if not (self._address_obj and self._address_obj.prefix == prefix and self._address_obj.encoding == encoding):\n            self._address_obj = Address(data, prefix=prefix, network=self.network, script_type=script_type,\n                                        encoding=encoding, compressed=compressed)\n        return self._address_obj.address\n\n    def address_uncompressed(self, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get uncompressed address from public key\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 encoded address\n        \"\"\"\n        return self.address(compressed=False, prefix=prefix, script_type=script_type, encoding=encoding)\n\n    def info(self):\n        \"\"\"\n        Prints key information to standard output\n\n        \"\"\"\n\n        print(\"KEY INFO\")\n        print(\" Network                     %s\" % self.network.name)\n        print(\" Compressed                  %s\" % self.compressed)\n        if self.secret:\n            print(\"SECRET EXPONENT\")\n            print(\" Private Key (hex)              %s\" % self.private_hex)\n            print(\" Private Key (long)             %s\" % self.secret)\n            if isinstance(self, HDKey):\n                print(\" Private Key (wif)              %s\" % self.wif_key())\n            else:\n                print(\" Private Key (wif)              %s\" % self.wif())\n        else:\n            print(\"PUBLIC KEY ONLY, NO SECRET EXPONENT\")\n        print(\"PUBLIC KEY\")\n        print(\" Public Key (hex)            %s\" % self.public_hex)\n        print(\" Public Key uncompr. (hex)   %s\" % self.public_uncompressed_hex)\n        print(\" Public Key Hash160          %s\" % self.hash160.hex())\n        print(\" Address (b58)               %s\" % self.address())\n        point_x, point_y = self.public_point()\n        print(\" Point x                     %s\" % point_x)\n        print(\" Point y                     %s\" % point_y)",
  "class HDKey(Key):\n    \"\"\"\n    Class for Hierarchical Deterministic keys as defined in BIP0032\n\n    Besides a private or public key a HD Key has a chain code, allowing to create\n    a structure of related keys.\n\n    The structure and key-path are defined in BIP0043 and BIP0044.\n    \"\"\"\n\n    @staticmethod\n    def from_seed(import_seed, key_type='bip32', network=DEFAULT_NETWORK, compressed=True,\n                  encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):\n        \"\"\"\n        Used by class init function, import key from seed\n\n        :param import_seed: Private key seed as bytes or hexstring\n        :type import_seed: str, bytes\n        :param key_type: Specify type of key, default is BIP32\n        :type key_type: str\n        :param network: Network to use\n        :type network: str, Network\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addresses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        seed = to_bytes(import_seed)\n        i = hmac.new(b\"Bitcoin seed\", seed, hashlib.sha512).digest()\n        key = i[:32]\n        chain = i[32:]\n        key_int = int.from_bytes(key, 'big')\n        if key_int >= secp256k1_n:\n            raise BKeyError(\"Key int value cannot be greater than secp256k1_n\")\n        return HDKey(key=key, chain=chain, network=network, key_type=key_type, compressed=compressed,\n                     encoding=encoding, witness_type=witness_type, multisig=multisig)\n\n    @staticmethod\n    def from_passphrase(passphrase, password='', network=DEFAULT_NETWORK, key_type='bip32', compressed=True,\n                        encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):\n        \"\"\"\n        Create key from Mnemonic passphrase\n\n        :param passphrase: Mnemonic passphrase, list of words as string seperated with a space character\n        :type passphrase: str\n        :param password: Password to protect passphrase\n        :type password: str\n        :param network: Network to use\n        :type network: str, Network\n        :param key_type: HD BIP32 or normal Private Key. Default is 'bip32'\n        :type key_type: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addreses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        return HDKey.from_seed(Mnemonic().to_seed(passphrase, password), network=network, key_type=key_type,\n                               compressed=compressed, encoding=encoding, witness_type=witness_type, multisig=multisig)\n\n    @staticmethod\n    def from_wif(wif, network=None, compressed=True, multisig=None):\n        \"\"\"\n        Create HDKey from BIP32 WIF\n\n        :param wif: HDKey WIF\n        :type wif: str\n        :param network: Network to use as string\n        :type network: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addresses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        bkey = change_base(wif, 58, 256)\n        if len(bkey) != 82:\n            raise BKeyError(\"Invalid BIP32 HDkey WIF. Length must be 82 characters\")\n\n        if ord(bkey[45:46]):\n            is_private = False\n            key = bkey[45:78]\n        else:\n            is_private = True\n            key = bkey[46:78]\n        depth = ord(bkey[4:5])\n        parent_fingerprint = bkey[5:9]\n        child_index = int.from_bytes(bkey[9:13], 'big')\n        chain = bkey[13:45]\n\n        key_hex = bkey.hex()\n        prefix_data = wif_prefix_search(key_hex[:8], network=network, multisig=multisig)\n        if not prefix_data:\n            raise BKeyError(\"Invalid BIP32 HDkey WIF. Cannot find prefix in network definitions\")\n\n        networks = list(dict.fromkeys([n['network'] for n in prefix_data]))\n        if not network and networks:\n            network = networks[0]\n        elif network not in networks:\n            raise BKeyError(\"Network %s not found in list of derived networks %s\" % (network, networks))\n\n        witness_type = next(iter(list(dict.fromkeys([n['witness_type'] for n in prefix_data]))), None)\n        multisig = multisig or next(iter(list(dict.fromkeys([n['multisig'] for n in prefix_data]))), None)\n\n        return HDKey(key=key, chain=chain, depth=depth, parent_fingerprint=parent_fingerprint,\n                     child_index=child_index, is_private=is_private, network=network, witness_type=witness_type,\n                     multisig=multisig, compressed=compressed)\n\n    def __init__(self, import_key=None, key=None, chain=None, depth=0, parent_fingerprint=b'\\0\\0\\0\\0',\n                 child_index=0, is_private=True, network=None, key_type='bip32', password='', compressed=True,\n                 encoding=None, witness_type=None, multisig=False):\n        \"\"\"\n        Hierarchical Deterministic Key class init function.\n\n        If no import_key is specified a key will be generated with systems cryptographically random function.\n        Import key can be any format normal or HD key (extended key) accepted by get_key_format.\n        If a normal key with no chain part is provided, a chain with only 32 0-bytes will be used.\n\n        >>> private_hex = '221ff330268a9bb5549a02c801764cffbc79d5c26f4041b26293a425fd5b557c'\n        >>> k = HDKey(private_hex)\n        >>> k\n        <HDKey(public_hex=0363c152144dcd5253c1216b733fdc6eb8a94ab2cd5caa8ead5e59ab456ff99927, wif_public=xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6SmypHzZG2cYrwpGkWJqRxS6EAW77gd7CHFoXNpBd3LN8xjAyCW, network=bitcoin)>\n\n        :param import_key: HD Key to import in WIF format or as byte with key (32 bytes) and chain (32 bytes)\n        :type import_key: str, bytes, int\n        :param key: Private or public key (length 32)\n        :type key: bytes\n        :param chain: A chain code (length 32)\n        :type chain: bytes\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param parent_fingerprint: 4-byte fingerprint of parent\n        :type parent_fingerprint: bytes\n        :param child_index: Index number of child as integer\n        :type child_index: int\n        :param is_private: True for private, False for public key. Default is True\n        :type is_private: bool\n        :param network: Network name. Derived from import_key if possible\n        :type network: str, Network\n        :param key_type: HD BIP32 or normal Private Key. Default is 'bip32'\n        :type key_type: str\n        :param password: Optional password if imported key is password protected\n        :type password: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addreses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n\n        if not encoding and witness_type:\n            encoding = get_encoding_from_witness(witness_type)\n        self.script_type = script_type_default(witness_type, multisig)\n\n        # if (key and not chain) or (not key and chain):\n        #     raise BKeyError(\"Please specify both key and chain, use import_key attribute \"\n        #                     \"or use simple Key class instead\")\n        if not key:\n            if not import_key:\n                # Generate new Master Key\n                seed = os.urandom(64)\n                key, chain = self._key_derivation(seed)\n            # If key is 64 bytes long assume a HD Key with key and chain part\n            elif isinstance(import_key, bytes) and len(import_key) == 64:\n                key = import_key[:32]\n                chain = import_key[32:]\n            elif isinstance(import_key, Key):\n                if not import_key.compressed:\n                    _logger.warning(\"Uncompressed private keys are not standard for BIP32 keys, use at your own risk!\")\n                    compressed = False\n                chain = chain if chain else b'\\0' * 32\n                if not import_key.private_byte:\n                    raise BKeyError('Cannot import public Key in HDKey')\n                key = import_key.private_byte\n                key_type = 'private'\n            else:\n                kf = get_key_format(import_key)\n                if kf['format'] == 'address':\n                    raise BKeyError(\"Can not create HDKey object from address\")\n                if len(kf['script_types']) == 1:\n                    self.script_type = kf['script_types'][0]\n                if len(kf['witness_types']) == 1 and not witness_type:\n                    witness_type = kf['witness_types'][0]\n                    encoding = get_encoding_from_witness(witness_type)\n                if len(kf['multisig']) == 1:\n                    multisig = kf['multisig'][0]\n                network = Network(check_network_and_key(import_key, network, kf[\"networks\"]))\n                if kf['format'] in ['hdkey_private', 'hdkey_public']:\n                    bkey = change_base(import_key, 58, 256)\n                    # Derive key, chain, depth, child_index and fingerprint part from extended key WIF\n                    if ord(bkey[45:46]):\n                        is_private = False\n                        key = bkey[45:78]\n                    else:\n                        key = bkey[46:78]\n                    depth = ord(bkey[4:5])\n                    parent_fingerprint = bkey[5:9]\n                    child_index = int.from_bytes(bkey[9:13], 'big')\n                    chain = bkey[13:45]\n                elif kf['format'] == 'mnemonic':\n                    raise BKeyError(\"Use HDKey.from_passphrase() method to parse a passphrase\")\n                elif kf['format'] == 'wif_protected':\n                    key, compressed = self._bip38_decrypt(import_key, password, network.name, witness_type)\n                    chain = chain if chain else b'\\0' * 32\n                    key_type = 'private'\n                else:\n                    key = import_key\n                    chain = chain if chain else b'\\0' * 32\n                    is_private = kf['is_private']\n                    key_type = 'private' if is_private else 'public'\n\n        if witness_type is None:\n            witness_type = DEFAULT_WITNESS_TYPE\n\n        Key.__init__(self, key, network, compressed, password, is_private)\n\n        self.encoding = encoding\n        self.witness_type = witness_type\n        self.multisig = multisig\n\n        self.chain = chain\n        self.depth = depth\n        self.parent_fingerprint = parent_fingerprint\n        self.child_index = child_index\n        self.key_type = key_type\n\n    def __repr__(self):\n        return \"<HDKey(public_hex=%s, wif_public=%s, network=%s)>\" % \\\n               (self.public_hex, self.wif_public(), self.network.name)\n\n    def info(self):\n        \"\"\"\n        Prints key information to standard output\n\n        \"\"\"\n        super(HDKey, self).info()\n\n        print(\"EXTENDED KEY\")\n        print(\" Key Type                    %s\" % self.key_type)\n        print(\" Chain code (hex)            %s\" % self.chain.hex())\n        print(\" Child Index                 %s\" % self.child_index)\n        print(\" Parent Fingerprint (hex)    %s\" % self.parent_fingerprint.hex())\n        print(\" Depth                       %s\" % self.depth)\n        print(\" Extended Public Key (wif)   %s\" % self.wif_public())\n        print(\" Witness type                %s\" % self.witness_type)\n        print(\" Script type                 %s\" % self.script_type)\n        print(\" Multisig                    %s\" % self.multisig)\n        if self.is_private:\n            print(\" Extended Private Key (wif)  %s\" % self.wif(is_private=True))\n        print(\"\\n\")\n\n    def as_dict(self, include_private=False):\n        \"\"\"\n        Get current HDKey class as dictionary. Byte values are represented by hexadecimal strings.\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return collections.OrderedDict:\n        \"\"\"\n\n        key_dict = super(HDKey, self).as_dict()\n        if include_private:\n            key_dict['fingerprint'] = self.fingerprint.hex()\n            key_dict['chain_code'] = self.chain.hex()\n            key_dict['fingerprint_parent'] = self.parent_fingerprint.hex()\n        key_dict['child_index'] = self.child_index\n        key_dict['depth'] = self.depth\n        key_dict['extended_wif_public'] = self.wif_public()\n        if include_private:\n            key_dict['extended_wif_private'] = self.wif(is_private=True)\n        return key_dict\n\n    def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n        \n        :return str:\n        \"\"\"\n        return json.dumps(self.as_dict(include_private=include_private), indent=4)\n\n    def _key_derivation(self, seed):\n        \"\"\"\n        Derive extended private key with key and chain part from seed\n\n        :param seed:\n        :type seed: bytes\n\n        :return tuple: key and chain bytes\n        \"\"\"\n        chain = hasattr(self, 'chain') and self.chain or b\"Bitcoin seed\"\n        i = hmac.new(chain, seed, hashlib.sha512).digest()\n        key = i[:32]\n        chain = i[32:]\n        key_int = int.from_bytes(key, 'big')\n        if key_int >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n        return key, chain\n\n    @property\n    def fingerprint(self):\n        \"\"\"\n        Get key fingerprint: the last for bytes of the hash160 of this key.\n\n        :return bytes:\n        \"\"\"\n\n        return self.hash160[:4]\n\n    @staticmethod\n    def _bip38_decrypt(encrypted_privkey, password, network=DEFAULT_NETWORK, witness_type=DEFAULT_WITNESS_TYPE):\n        \"\"\"\n        BIP0038 non-ec-multiply decryption. Returns WIF private key.\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n        This method is called by Key class init function when importing BIP0038 key.\n\n        :param encrypted_privkey: Encrypted private key using WIF protected key format\n        :type encrypted_privkey: str\n        :param password: Required password for decryption\n        :type password: str\n\n        :return str: Private Key WIF\n        \"\"\"\n        priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)\n        # compressed = True if priv[-1:] == b'\\1' else False\n\n        # Verify addresshash\n        k = HDKey(priv, compressed=compressed, network=network, witness_type=witness_type)\n        addr = k.address()\n        if isinstance(addr, str):\n            addr = addr.encode('utf-8')\n        if double_sha256(addr)[0:4] != addresshash:\n            raise BKeyError('Addresshash verification failed! Password or '\n                            'specified network %s might be incorrect' % network)\n        return priv, compressed\n\n    def wif(self, is_private=None, child_index=None, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF of current key\n\n        >>> private_hex = '221ff330268a9bb5549a02c801764cffbc79d5c26f4041b26293a425fd5b557c'\n        >>> k = HDKey(private_hex)\n        >>> k.wif()\n        'xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6SmypHzZG2cYrwpGkWJqRxS6EAW77gd7CHFoXNpBd3LN8xjAyCW'\n\n        :param is_private: Return public or private key\n        :type is_private: bool\n        :param child_index: Change child index of output WIF key\n        :type child_index: int\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n\n        if not witness_type:\n            witness_type = DEFAULT_WITNESS_TYPE if not self.witness_type else self.witness_type\n        if not multisig:\n            multisig = False if not self.multisig else self.multisig\n\n        rkey = self.private_byte or self.public_compressed_byte\n        if prefix and not isinstance(prefix, bytes):\n            prefix = bytes.fromhex(prefix)\n        if self.is_private and is_private:\n            if not prefix:\n                prefix = self.network.wif_prefix(is_private=True, witness_type=witness_type, multisig=multisig)\n            typebyte = b'\\x00'\n        else:\n            if not prefix:\n                prefix = self.network.wif_prefix(witness_type=witness_type, multisig=multisig)\n            typebyte = b''\n            if not is_private:\n                rkey = self.public_byte\n        if child_index:\n            self.child_index = child_index\n        raw = prefix + self.depth.to_bytes(1, 'big') + self.parent_fingerprint + \\\n              self.child_index.to_bytes(4, 'big') + self.chain + typebyte + rkey\n        chk = double_sha256(raw)[:4]\n        ret = raw + chk\n        return change_base(ret, 256, 58, 111)\n\n    def wif_key(self, prefix=None):\n        \"\"\"\n        Get WIF of Key object. Call to parent object Key.wif()\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :return str: Base58Check encoded Private Key WIF\n        \"\"\"\n        return super(HDKey, self).wif(prefix)\n\n    def wif_public(self, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF public key. Wrapper for the :func:`wif` method\n\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n        return self.wif(is_private=False, prefix=prefix, witness_type=witness_type, multisig=multisig)\n\n    def wif_private(self, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF private key. Wrapper for the :func:`wif` method\n\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multi signature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n        return self.wif(is_private=True, prefix=prefix, witness_type=witness_type, multisig=multisig)\n\n    def address(self, compressed=None, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get address derived from public key\n\n        >>> wif = 'xpub661MyMwAqRbcFcXi3aM3fVdd42FGDSdufhrr5tdobiPjMrPUykFMTdaFEr7yoy1xxeifDY8kh2k4h9N77MY6rk18nfgg5rPtbFDF2YHzLfA'\n        >>> k = HDKey.from_wif(wif)\n        >>> k.address()\n        '15CacK61qnzJKpSpx9PFiC8X1ajeQxhq8a'\n\n        :param compressed: Always return compressed address\n        :type compressed: bool\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 or Bech32 encoded address\n        \"\"\"\n        if compressed is None:\n            compressed = self.compressed\n        if script_type is None:\n            script_type = self.script_type\n        if encoding is None:\n            encoding = self.encoding\n        return super(HDKey, self).address(compressed, prefix, script_type, encoding)\n\n    def subkey_for_path(self, path, network=None):\n        \"\"\"\n        Determine subkey for HD Key for given path.\n        Path format: m / purpose' / coin_type' / account' / change / address_index\n\n        See BIP0044 bitcoin proposal for more explanation.\n\n        >>> wif = 'xprv9s21ZrQH143K4LvcS93AHEZh7gBiYND6zMoRiZQGL5wqbpCU2KJDY87Txuv9dduk9hAcsL76F8b5JKzDREf8EmXjbUwN1c4nR9GEx56QGg2'\n        >>> k = HDKey.from_wif(wif)\n        >>> k.subkey_for_path(\"m/44'/0'/0'/0/2\")\n        <HDKey(public_hex=03004331ca7f0dcdd925abc4d0800a0d4a0562a02c257fa39185c55abdfc4f0c0c, wif_public=xpub6GyQoEbMUNwu1LnbiCSaD8wLrcjyRCEQA8tNsFCH4pnvCbuWSZkSB6LUNe89YsCBTg1Ncs7vHJBjMvw2Q7siy3A4g1srAq7Lv3CtEXghv44, network=bitcoin)>\n\n        :param path: BIP0044 key path\n        :type path: str, list\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object of subkey\n        \"\"\"\n\n        if isinstance(path, TYPE_TEXT):\n            path = path.split(\"/\")\n        if self.key_type == 'single':\n            raise BKeyError(\"Key derivation cannot be used for 'single' type keys\")\n        key = self\n        first_public = False\n        if path[0] == 'm':  # Use Private master key\n            path = path[1:]\n        elif path[0] == 'M':  # Use Public master key\n            path = path[1:]\n            first_public = True\n        if path:\n            if len(path) > 1:\n                _logger.info(\"Path length > 1 can be slow for larger paths, use Wallet Class to generate keys paths\")\n            for item in path:\n                if not item:\n                    raise BKeyError(\"Could not parse path. Index is empty.\")\n                hardened = item[-1] in \"'HhPp\"\n                if hardened:\n                    item = item[:-1]\n                index = int(item)\n                if index < 0:\n                    raise BKeyError(\"Could not parse path. Index must be a positive integer.\")\n                if first_public or not key.is_private:\n                    key = key.child_public(index=index, network=network)  # TODO hardened=hardened key?\n                    first_public = False\n                else:\n                    key = key.child_private(index=index, hardened=hardened, network=network)\n        return key\n\n    def public_master(self, account_id=0, purpose=None, multisig=None, witness_type=None, as_private=False):\n        \"\"\"\n        Derives a public master key for current HDKey. A public master key can be shared with other software\n        administration tools to create readonly wallets or can be used to create multisignature wallets.\n\n        >>> private_hex = 'b66ed9778029d32ebede042c79f448da8f7ab9efba19c63b7d3cdf6925203b71'\n        >>> k = HDKey(private_hex)\n        >>> pm = k.public_master()\n        >>> pm.wif()\n        'xpub6CjFexgdDZEtHdW7V4LT8wS9rtG3m187pM9qhTpoZdViFhSv3tW9sWonQNtFN1TCkRGAQGKj1UC2ViHTqb7vJV3X67xSKuCDzv14tBHR3Y7'\n\n        :param account_id: Account ID. Leave empty for account 0\n        :type account_id: int\n        :param purpose: BIP standard used, i.e. 44 for default, 45 for multisig, 84 for segwit. Derived from witness_type and multisig arguments if not provided\n        :type purpose: int\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' or 'p2sh-segwit' for segregated witness.\n        :type witness_type: str\n        :param as_private: Return private key if available. Default is to return public key\n\n        :return HDKey:\n        \"\"\"\n        if multisig:\n            self.multisig = multisig\n        if witness_type:\n            self.witness_type = witness_type\n        ks = [k for k in WALLET_KEY_STRUCTURES if\n              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]\n        if len(ks) > 1:\n            raise BKeyError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                            \"witness_type - multisig combination\")\n        if ks and not purpose:\n            purpose = ks[0]['purpose']\n        path_template = ks[0]['key_path']\n\n        # Use last hardened key as public master root\n        pm_depth = path_template.index([x for x in path_template if x[-1:] == \"'\"][-1]) + 1\n        path = path_expand(path_template[:pm_depth], path_template, account_id=account_id, purpose=purpose,\n                           witness_type=self.witness_type, network=self.network.name)\n        if as_private:\n            return self.subkey_for_path(path)\n        else:\n            return self.subkey_for_path(path).public()\n\n    def public_master_multisig(self, account_id=0, purpose=None, witness_type=None, as_private=False):\n        \"\"\"\n        Derives a public master key for current HDKey for use with multi signature wallets. Wrapper for the\n        :func:`public_master` method.\n\n        :param account_id: Account ID. Leave empty for account 0\n        :type account_id: int\n        :param purpose: BIP standard used, i.e. 44 for default, 45 for multisig, 84 for segwit.\n        :type purpose: int\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' or 'p2sh-segwit' for segregated witness.\n        :type witness_type: str\n        :param as_private: Return private key if available. Default is to return public key\n\n        :return HDKey:\n        \"\"\"\n\n        return self.public_master(account_id, purpose, True, witness_type, as_private)\n\n    def network_change(self, new_network):\n        \"\"\"\n        Change network for current key\n\n        :param new_network: Name of new network\n        :type new_network: str\n\n        :return bool: True\n        \"\"\"\n        self.network = Network(new_network)\n        return True\n\n    def child_private(self, index=0, hardened=False, network=None):\n        \"\"\"\n        Use Child Key Derivation (CDK) to derive child private key of current HD Key object.\n\n        Used by :func:`subkey_for_path` to create key paths for instance to use in HD wallets. You can use this method to create your own key structures.\n\n        This method create private child keys, use :func:`child_public` to create public child keys.\n\n        >>> private_hex = 'd02220828cad5e0e0f25057071f4dae9bf38720913e46a596fd7eb8f83ad045d'\n        >>> k = HDKey(private_hex)\n        >>> ck = k.child_private(10)\n        >>> ck.address()\n        '1FgHK5JUa87ASxz5mz3ypeaUV23z9yW654'\n        >>> ck.depth\n        1\n        >>> ck.child_index\n        10\n\n        :param index: Key index number\n        :type index: int\n        :param hardened: Specify if key must be hardened (True) or normal (False)\n        :type hardened: bool\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object\n        \"\"\"\n\n        if network is None:\n            network = self.network.name\n        if not self.is_private:\n            raise BKeyError(\"Need a private key to create child private key\")\n        if hardened:\n            index |= 0x80000000\n            data = b'\\0' + self.private_byte + index.to_bytes(4, 'big')\n        else:\n            data = self.public_byte + index.to_bytes(4, 'big')\n        key, chain = self._key_derivation(data)\n\n        key = int.from_bytes(key, 'big')\n        if key >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n        newkey = (key + self.secret) % secp256k1_n\n        if newkey == 0:\n            raise BKeyError(\"Key cannot be zero. Try another index number.\")\n        newkey = int.to_bytes(newkey, 32, 'big')\n\n        return HDKey(key=newkey, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,\n                     child_index=index, witness_type=self.witness_type, multisig=self.multisig,\n                     encoding=self.encoding, network=network)\n\n    def child_public(self, index=0, network=None):\n        \"\"\"\n        Use Child Key Derivation to derive child public key of current HD Key object.\n\n        Used by :func:`subkey_for_path` to create key paths for instance to use in HD wallets. You can use this method to create your own key structures.\n\n        This method create public child keys, use :func:`child_private` to create private child keys.\n\n        >>> private_hex = 'd02220828cad5e0e0f25057071f4dae9bf38720913e46a596fd7eb8f83ad045d'\n        >>> k = HDKey(private_hex)\n        >>> ck = k.child_public(15)\n        >>> ck.address()\n        '1PfLJJgKs8nUbMPpaQUucbGmr8qyNSMGeK'\n        >>> ck.depth\n        1\n        >>> ck.child_index\n        15\n\n        :param index: Key index number\n        :type index: int\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object\n        \"\"\"\n        if network is None:\n            network = self.network.name\n        if index > 0x80000000:\n            raise BKeyError(\"Cannot derive hardened key from public private key. Index must be less than 0x80000000\")\n        data = self.public_byte + index.to_bytes(4, 'big')\n        key, chain = self._key_derivation(data)\n        key = int.from_bytes(key, 'big')\n        if key >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n\n        x, y = self.public_point()\n        if USE_FASTECDSA:\n            ki = ec_point(key) + fastecdsa_point.Point(x, y, fastecdsa_secp256k1)\n            ki_x = ki.x\n            ki_y = ki.y\n        else:\n            ki = ec_point(key) + ecdsa.ellipticcurve.Point(secp256k1_curve, x, y, secp256k1_n)\n            ki_x = ki.x()\n            ki_y = ki.y()\n\n        if ki_y % 2:\n            prefix = '03'\n        else:\n            prefix = '02'\n        xhex = change_base(ki_x, 10, 16, 64)\n        secret = bytes.fromhex(prefix + xhex)\n        return HDKey(key=secret, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,\n                     child_index=index, is_private=False, witness_type=self.witness_type, multisig=self.multisig,\n                     encoding=self.encoding, network=network)\n\n    def public(self):\n        \"\"\"\n        Public version of current private key. Strips all private information from HDKey object, returns deepcopy\n        version of current object\n\n        :return HDKey:\n        \"\"\"\n\n        hdkey = deepcopy(self)\n        hdkey.is_private = False\n        hdkey.secret = None\n        hdkey.private_hex = None\n        hdkey.private_byte = None\n        hdkey.key_hex = hdkey.public_hex\n        # hdkey.key = self.key.public()\n        return hdkey",
  "class Signature(object):\n    \"\"\"\n    Signature class for transactions. Used to create signatures to sign transaction and verification\n    \n    Sign a transaction hash with a private key and show DER encoded signature:\n\n    >>> sk = HDKey('f2620684cef2b677dc2f043be8f0873b61e79b274c7e7feeb434477c082e0dc2')\n    >>> txid = 'c77545c8084b6178366d4e9a06cf99a28d7b5ff94ba8bd76bbbce66ba8cdef70'\n    >>> signature = sign(txid, sk)\n    >>> signature.as_der_encoded().hex()\n    '3044022015f9d39d8b53c68c7549d5dc4cbdafe1c71bae3656b93a02d2209e413d9bbcd00220615cf626da0a81945a707f42814cc51ecde499442eb31913a870b9401af6a4ba01'\n    \n    \"\"\"\n\n    @classmethod\n    def parse(cls, signature, public_key=None):\n        if isinstance(signature, bytes):\n            return cls.parse_bytes(signature, public_key)\n        elif isinstance(signature, str):\n            return cls.parse_hex(signature, public_key)\n\n    @classmethod\n    def parse_hex(cls, signature, public_key=None):\n        return cls.parse_bytes(bytes.fromhex(signature), public_key)\n\n    @staticmethod\n    def parse_bytes(signature, public_key=None):\n        \"\"\"\n        Create a signature from signature string with r and s part. Signature length must be 64 bytes or 128\n        character hexstring\n\n        :param signature: Signature string\n        :type signature: bytes\n        :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object\n        :type public_key: HDKey, Key, str, hexstring, bytes\n\n        :return Signature:\n        \"\"\"\n\n        der_signature = ''\n        hash_type = SIGHASH_ALL\n        if len(signature) > 64 and signature.startswith(b'\\x30'):\n            der_signature = signature[:-1]\n            hash_type = int.from_bytes(signature[-1:], 'big')\n            signature = convert_der_sig(signature[:-1], as_hex=False)\n        if len(signature) != 64:\n            raise BKeyError(\"Signature length must be 64 bytes or 128 character hexstring\")\n        r = int.from_bytes(signature[:32], 'big')\n        s = int.from_bytes(signature[32:], 'big')\n        return Signature(r, s, signature=signature, der_signature=der_signature, public_key=public_key,\n                         hash_type=hash_type)\n\n    @staticmethod\n    @deprecated\n    def from_str(signature, public_key=None):\n        \"\"\"\n        Create a signature from signature string with r and s part. Signature length must be 64 bytes or 128 \n        character hexstring \n        \n        :param signature: Signature string\n        :type signature: bytes, str\n        :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object\n        :type public_key: HDKey, Key, str, hexstring, bytes\n        \n        :return Signature: \n        \"\"\"\n\n        signature = to_bytes(signature)\n        return Signature(signature, public_key)\n\n    @staticmethod\n    def create(txid, private, use_rfc6979=True, k=None):\n        \"\"\"\n        Sign a transaction hash and create a signature with provided private key.\n\n        >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'\n        >>> txid = '0d12fdc4aac9eaaab9730999e0ce84c3bd5bb38dfd1f4c90c613ee177987429c'\n        >>> sig = Signature.create(txid, k)\n        >>> sig.hex()\n        '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        >>> sig.r\n        32979225540043540145671192266052053680452913207619328973512110841045982813493\n        >>> sig.s\n        12990793585889366641563976043319195006380846016310271470330687369836458989268\n\n        :param txid: Transaction signature or transaction hash. If unhashed transaction or message is provided the double_sha256 hash of message will be calculated.\n        :type txid: bytes, str\n        :param private: Private key as HDKey or Key object, or any other string accepted by HDKey object\n        :type private: HDKey, Key, str, hexstring, bytes\n        :param use_rfc6979: Use deterministic value for k nonce to derive k from txid/message according to RFC6979 standard. Default is True, set to False to use random k\n        :type use_rfc6979: bool\n        :param k: Provide own k. Only use for testing or if you know what you are doing. Providing wrong value for k can result in leaking your private key!\n        :type k: int\n        \n        :return Signature: \n        \"\"\"\n        if isinstance(txid, bytes):\n            txid = txid.hex()\n        if len(txid) > 64:\n            txid = double_sha256(bytes.fromhex(txid), as_hex=True)\n        if not isinstance(private, (Key, HDKey)):\n            private = HDKey(private)\n        pub_key = private.public()\n        secret = private.secret\n\n        if not k:\n            if use_rfc6979 and USE_FASTECDSA:\n                rfc6979 = RFC6979(txid, secret, secp256k1_n, hashlib.sha256)\n                k = rfc6979.gen_nonce()\n            else:\n                global rfc6979_warning_given\n                if not USE_FASTECDSA and not rfc6979_warning_given:\n                    _logger.warning(\"RFC6979 only supported when fastecdsa library is used\")\n                    rfc6979_warning_given = True\n                k = random.SystemRandom().randint(1, secp256k1_n - 1)\n\n        if USE_FASTECDSA:\n            r, s = _ecdsa.sign(\n                txid,\n                str(secret),\n                str(k),\n                str(secp256k1_p),\n                str(secp256k1_a),\n                str(secp256k1_b),\n                str(secp256k1_n),\n                str(secp256k1_Gx),\n                str(secp256k1_Gy)\n            )\n            if int(s) > secp256k1_n / 2:\n                s = secp256k1_n - int(s)\n            return Signature(r, s, txid, secret, public_key=pub_key, k=k)\n        else:\n            sk = ecdsa.SigningKey.from_string(private.private_byte, curve=ecdsa.SECP256k1)\n            txid_bytes = to_bytes(txid)\n            sig_der = sk.sign_digest(txid_bytes, sigencode=ecdsa.util.sigencode_der, k=k)\n            signature = convert_der_sig(sig_der)\n            r = int(signature[:64], 16)\n            s = int(signature[64:], 16)\n            if s > secp256k1_n / 2:\n                s = secp256k1_n - s\n            return Signature(r, s, txid, secret, public_key=pub_key, k=k)\n\n    def __init__(self, r, s, txid=None, secret=None, signature=None, der_signature=None, public_key=None, k=None,\n                 hash_type=SIGHASH_ALL):\n        \"\"\"\n        Initialize Signature object with provided r and r value\n\n        >>> r = 32979225540043540145671192266052053680452913207619328973512110841045982813493\n        >>> s = 12990793585889366641563976043319195006380846016310271470330687369836458989268\n        >>> sig = Signature(r, s)\n        >>> sig.hex()\n        '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        \n        :param r: r value of signature\n        :type r: int\n        :param s: s value of signature\n        :type s: int\n        :param txid: Transaction hash z to sign if known\n        :type txid: bytes, hexstring\n        :param secret: Private key secret number\n        :type secret: int\n        :param signature: r and s value of signature as string\n        :type signature: str, bytes\n        :param der_signature: DER encoded signature\n        :type der_signature: str, bytes\n        :param public_key: Provide public key P if known\n        :type public_key: HDKey, Key, str, hexstring, bytes\n        :param k: k value used for signature\n        :type k: int\n        \"\"\"\n\n        self.r = int(r)\n        self.s = int(s)\n        self.x = None\n        self.y = None\n        if self.r < 1 or self.r >= secp256k1_n:\n            raise BKeyError('Invalid Signature: r is not a positive integer smaller than the curve order')\n        elif self.s < 1 or self.s >= secp256k1_n:\n            raise BKeyError('Invalid Signature: s is not a positive integer smaller than the curve order')\n        self._txid = None\n        self.txid = txid\n        self.secret = None if not secret else int(secret)\n        if isinstance(signature, bytes):\n            self._signature = signature\n            signature = signature.hex()\n        else:\n            self._signature = to_bytes(signature)\n        if signature and len(signature) != 128:\n            raise BKeyError('Invalid Signature: length must be 64 bytes')\n        self._public_key = None\n        self.public_key = public_key\n        self.k = k\n        self.hash_type = hash_type\n        self.hash_type_byte = self.hash_type.to_bytes(1, 'big')\n        self.der_signature = der_signature\n        if not der_signature:\n            self.der_signature = der_encode_sig(self.r, self.s)\n\n        self._der_encoded = to_bytes(der_signature) + self.hash_type_byte\n\n    def __repr__(self):\n        der_sig = '' if not self._der_encoded else self._der_encoded.hex()\n        return \"<Signature(r=%d, s=%d, signature=%s, der_signature=%s)>\" % \\\n               (self.r, self.s, self.hex(), der_sig)\n\n    def __str__(self):\n        return self.as_der_encoded(as_hex=True)\n\n    def __bytes__(self):\n        return self.as_der_encoded()\n\n    def __add__(self, other):\n        return self.as_der_encoded() + other\n\n    def __radd__(self, other):\n        return other + self.as_der_encoded()\n\n    def __len__(self):\n        return len(self.as_der_encoded())\n\n    @property\n    def txid(self):\n        return self._txid\n\n    @txid.setter\n    def txid(self, value):\n        if value is not None:\n            self._txid = value\n            if isinstance(value, bytes):\n                self._txid = value.hex()\n\n    @property\n    def public_key(self):\n        \"\"\"\n        Return public key as HDKey object\n        \n        :return HDKey: \n        \"\"\"\n        return self._public_key\n\n    @public_key.setter\n    def public_key(self, value):\n        if value is None:\n            return\n        if isinstance(value, bytes):\n            value = HDKey(value)\n        if value.is_private:\n            value = value.public()\n        self.x, self.y = value.public_point()\n\n        if USE_FASTECDSA:\n            if not fastecdsa_secp256k1.is_point_on_curve((self.x, self.y)):\n                raise BKeyError('Invalid public key, point is not on secp256k1 curve')\n        self._public_key = value\n\n    def hex(self):\n        \"\"\"\n        Signature r and s value as single hexadecimal string\n\n        :return hexstring:\n        \"\"\"\n        return self.bytes().hex()\n\n    def __index__(self):\n        return self.bytes()\n\n    def bytes(self):\n        \"\"\"\n        Signature r and s value as single bytes string\n\n        :return bytes:\n        \"\"\"\n\n        if not self._signature:\n            self._signature = self.r.to_bytes(32, 'big') + self.s.to_bytes(32, 'big')\n        return self._signature\n\n    def as_der_encoded(self, as_hex=False, include_hash_type=True):\n        \"\"\"\n        Get DER encoded signature\n\n        :param as_hex: Output as hexstring\n        :type as_hex: bool\n        :param include_hash_type: Include hash_type byte at end of signatures as used in raw scripts. Default is True\n        :type include_hash_type: bool\n\n        :return bytes: \n        \"\"\"\n        if not self._der_encoded or len(self._der_encoded) < 2:\n            self._der_encoded = der_encode_sig(self.r, self.s) + self.hash_type_byte\n\n        if include_hash_type:\n            return self._der_encoded.hex() if as_hex else self._der_encoded\n        else:\n            return der_encode_sig(self.r, self.s).hex() if as_hex else der_encode_sig(self.r, self.s)\n\n    def verify(self, txid=None, public_key=None):\n        \"\"\"\n        Verify this signature. Provide txid or public_key if not already known\n\n        >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'\n        >>> pub_key = HDKey(k).public()\n        >>> txid = '0d12fdc4aac9eaaab9730999e0ce84c3bd5bb38dfd1f4c90c613ee177987429c'\n        >>> sig = '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        >>> sig = Signature.parse_hex(sig)\n        >>> sig.verify(txid, pub_key)\n        True\n\n        :param txid: Transaction hash\n        :type txid: bytes, hexstring\n        :param public_key: Public key P\n        :type public_key: HDKey, Key, str, hexstring, bytes\n                \n        :return bool: \n        \"\"\"\n        if txid is not None:\n            self.txid = to_hexstring(txid)\n        if public_key is not None:\n            self.public_key = public_key\n\n        if not self.txid or not self.public_key:\n            raise BKeyError(\"Please provide txid and public_key to verify signature\")\n\n        if USE_FASTECDSA:\n            return _ecdsa.verify(\n                str(self.r),\n                str(self.s),\n                self.txid,\n                str(self.x),\n                str(self.y),\n                str(secp256k1_p),\n                str(secp256k1_a),\n                str(secp256k1_b),\n                str(secp256k1_n),\n                str(secp256k1_Gx),\n                str(secp256k1_Gy)\n            )\n        else:\n            transaction_to_sign = to_bytes(self.txid)\n            signature = self.bytes()\n            if len(transaction_to_sign) != 32:\n                transaction_to_sign = double_sha256(transaction_to_sign)\n            ver_key = ecdsa.VerifyingKey.from_string(self.public_key.public_uncompressed_byte[1:],\n                                                     curve=ecdsa.SECP256k1)\n            try:\n                if len(signature) > 64 and signature.startswith(b'\\x30'):\n                    try:\n                        signature = convert_der_sig(signature[:-1], as_hex=False)\n                    except Exception:\n                        pass\n                ver_key.verify_digest(signature, transaction_to_sign)\n            except ecdsa.keys.BadSignatureError:\n                return False\n            except ecdsa.keys.BadDigestError as e:\n                _logger.info(\"Bad Digest %s (error %s)\" % (signature.hex(), e))\n                return False\n            return True",
  "def sign(txid, private, use_rfc6979=True, k=None):\n    \"\"\"\n    Sign transaction hash or message with secret private key. Creates a signature object.\n    \n    Sign a transaction hash with a private key and show DER encoded signature\n\n    >>> sk = HDKey('728afb86a98a0b60cc81faadaa2c12bc17d5da61b8deaf1c08fc07caf424d493')\n    >>> txid = 'c77545c8084b6178366d4e9a06cf99a28d7b5ff94ba8bd76bbbce66ba8cdef70'\n    >>> signature = sign(txid, sk)\n    >>> signature.as_der_encoded().hex()\n    '30440220792f04c5ba654e27eb636ceb7804c5590051dd77da8b80244f1fa8dfbff369b302204ba03b039c808a0403d067f3d75fbe9c65831444c35d64d4192b408d2a7410a101'\n\n    :param txid: Transaction signature or transaction hash. If unhashed transaction or message is provided the double_sha256 hash of message will be calculated.\n    :type txid: bytes, str\n    :param private: Private key as HDKey or Key object, or any other string accepted by HDKey object\n    :type private: HDKey, Key, str, hexstring, bytes\n    :param use_rfc6979: Use deterministic value for k nonce to derive k from txid/message according to RFC6979 standard. Default is True, set to False to use random k\n    :type use_rfc6979: bool\n    :param k: Provide own k. Only use for testing or if you know what you are doing. Providing wrong value for k can result in leaking your private key!\n    :type k: int\n        \n    :return Signature: \n    \"\"\"\n    return Signature.create(txid, private, use_rfc6979, k)",
  "def verify(txid, signature, public_key=None):\n    \"\"\"\n    Verify provided signature with txid message. If provided signature is no Signature object a new object will\n    be created for verification.\n\n    >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'\n    >>> pub_key = HDKey(k).public()\n    >>> txid = '0d12fdc4aac9eaaab9730999e0ce84c3bd5bb38dfd1f4c90c613ee177987429c'\n    >>> sig = '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n    >>> verify(txid, sig, pub_key)\n    True\n\n    :param txid: Transaction hash\n    :type txid: bytes, hexstring\n    :param signature: signature as hexstring or bytes\n    :type signature: str, bytes\n    :param public_key: Public key P. If not provided it will be derived from provided Signature object or raise an error if not available\n    :type public_key: HDKey, Key, str, hexstring, bytes\n\n    :return bool: \n    \"\"\"\n    if not isinstance(signature, Signature):\n        if not public_key:\n            raise BKeyError(\"No public key provided, cannot verify\")\n        signature = Signature.parse(signature, public_key=public_key)\n    return signature.verify(txid, public_key)",
  "def ec_point(m):\n    \"\"\"\n    Method for elliptic curve multiplication on the secp256k1 curve. Multiply Generator point G by m\n\n    :param m: A scalar multiplier\n    :type m: int\n\n    :return Point: Generator point G multiplied by m\n    \"\"\"\n    m = int(m)\n    if USE_FASTECDSA:\n        return fastecdsa_keys.get_public_key(m, fastecdsa_secp256k1)\n    else:\n        point = secp256k1_generator\n        point *= m\n        return point",
  "def mod_sqrt(a):\n    \"\"\"\n    Compute the square root of 'a' using the secp256k1 'bitcoin' curve\n\n    Used to calculate y-coordinate if only x-coordinate from public key point is known.\n    Formula: y ** 2 == x ** 3 + 7\n    \n    :param a: Number to calculate square root\n    :type a: int\n    \n    :return int: \n    \"\"\"\n\n    # Square root formula: k = (secp256k1_p - 3) // 4\n    k = 28948022309329048855892746252171976963317496166410141009864396001977208667915\n    return pow(a, k + 1, secp256k1_p)",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def import_address(cls, address, compressed=None, encoding=None, depth=None, change=None,\n                       address_index=None, network=None, network_overrides=None):\n        \"\"\"\n        Import an address to the Address class. Specify network if available, otherwise it will be\n        derived form the address.\n\n        :param address: Address to import\n        :type address: str\n        :param compressed: Is key compressed or not, default is None\n        :type compressed: bool\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding. Leave empty to derive from address\n        :type encoding: str\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param change: Use 0 for normal address/key, and 1 for change address (for returned/change payments)\n        :type change: int\n        :param address_index: Index of address. Used in BIP32 key paths\n        :type address_index: int\n        :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network\n        :type network: str\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        :return Address:\n        \"\"\"\n        return cls.parse(address, compressed, encoding, depth, change, address_index, network, network_overrides)",
  "def parse(cls, address, compressed=None, encoding=None, depth=None, change=None,\n              address_index=None, network=None, network_overrides=None):\n        \"\"\"\n        Import an address to the Address class. Specify network if available, otherwise it will be\n        derived form the address.\n\n        >>> addr = Address.parse('bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3')\n        >>> addr.as_dict()\n        {'network': 'bitcoin', '_data': None, 'script_type': 'p2wsh', 'encoding': 'bech32', 'compressed': None, 'witver': 0, 'witness_type': 'segwit', 'depth': None, 'change': None, 'address_index': None, 'prefix': 'bc', 'redeemscript': '', '_hashed_data': None, 'address': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3', 'address_orig': 'bc1qyftqrh3hm2yapnhh0ukaht83d02a7pda8l5uhkxk9ftzqsmyu7pst6rke3'}\n\n        :param address: Address to import\n        :type address: str\n        :param compressed: Is key compressed or not, default is None\n        :type compressed: bool\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding. Leave empty to derive from address\n        :type encoding: str\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param change: Use 0 for normal address/key, and 1 for change address (for returned/change payments)\n        :type change: int\n        :param address_index: Index of address. Used in BIP32 key paths\n        :type address_index: int\n        :param network: Specify network filter, i.e.: bitcoin, testnet, litecoin, etc. Wil trigger check if address is valid for this network\n        :type network: str\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        :return Address:\n        \"\"\"\n        if encoding is None and address[:3].split(\"1\")[0] in ENCODING_BECH32_PREFIXES:\n            encoding = 'bech32'\n        addr_dict = deserialize_address(address, encoding=encoding, network=network)\n        public_key_hash_bytes = addr_dict['public_key_hash_bytes']\n        prefix = addr_dict['prefix']\n        if network is None:\n            network = addr_dict['network']\n        script_type = addr_dict['script_type']\n        return Address(hashed_data=public_key_hash_bytes, prefix=prefix, script_type=script_type,\n                       compressed=compressed, encoding=addr_dict['encoding'], depth=depth, change=change,\n                       address_index=address_index, network=network, network_overrides=network_overrides)",
  "def __init__(self, data='', hashed_data='', prefix=None, script_type=None,\n                 compressed=None, encoding=None, witness_type=None, witver=0, depth=None, change=None,\n                 address_index=None, network=DEFAULT_NETWORK, network_overrides=None):\n        \"\"\"\n        Initialize an Address object. Specify a public key, redeemscript or a hash.\n\n        >>> addr = Address('03715219f51a2681b7642d1e0e35f61e5288ff59b87d275be9eaf1a5f481dcdeb6', encoding='bech32', script_type='p2wsh')\n        >>> addr.address\n        'bc1qaehsuffn0stxmugx3z69z9hm6gnjd9qzeqlfv92cpf5adw63x4tsfl7vwl'\n\n        :param data: Public key, redeem script or other type of script.\n        :type data: str, bytes\n        :param hashed_data: Hash of a public key or script. Will be generated if 'data' parameter is provided\n        :type hashed_data: str, bytes\n        :param prefix: Address prefix. Use default network / script_type prefix if not provided\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param witver: Witness version. Used for p2tr addresses\n        :type witver: int\n        :param encoding: Address encoding. Default is base58 encoding, for native segwit addresses specify bech32 encoding\n        :type encoding: str\n        :param witness_type: Specify 'legacy', 'segwit' or 'p2sh-segwit'. Legacy for old-style bitcoin addresses, segwit for native segwit addresses and p2sh-segwit for segwit embedded in a p2sh script. Leave empty to derive automatically from script type if possible\n        :type witness_type: str\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n        :param network_overrides: Override network settings for specific prefixes, i.e.: {\"prefix_address_p2sh\": \"32\"}. Used by settings in providers.json\n        :type network_overrides: dict\n\n        \"\"\"\n        self.network = network\n        if not (data or hashed_data):\n            raise BKeyError(\"Please specify data (public key or script) or hashed_data argument\")\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.data_bytes = to_bytes(data)\n        self._data = None\n        self.script_type = script_type\n        self.encoding = encoding\n        self.compressed = compressed\n        self.witver = witver\n        if witness_type is None:\n            if self.script_type in ['p2wpkh', 'p2wsh']:\n                witness_type = 'segwit'\n            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:\n                witness_type = 'p2sh-segwit'\n            elif self.script_type == 'p2tr':\n                witness_type = 'taproot'\n                self.witver = 1 if self.witver == 0 else self.witver\n        self.witness_type = witness_type\n        self.depth = depth\n        self.change = change\n        self.address_index = address_index\n\n        if self.encoding is None:\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr'] or self.witness_type == 'segwit':\n                self.encoding = 'bech32'\n            else:\n                self.encoding = 'base58'\n        self.hash_bytes = to_bytes(hashed_data)\n        self.prefix = prefix\n        self.redeemscript = b''\n        if not self.hash_bytes:\n            if (self.encoding == 'bech32' and self.script_type in ['p2sh', 'p2sh_multisig', 'p2tr']) or \\\n                    self.script_type in ['p2wsh', 'p2sh_p2wsh']:\n                self.hash_bytes = hashlib.sha256(self.data_bytes).digest()\n            else:\n                self.hash_bytes = hash160(self.data_bytes)\n        self._hashed_data = None\n        if self.encoding == 'base58':\n            if self.script_type is None:\n                self.script_type = 'p2pkh'\n            if self.witness_type == 'p2sh-segwit':\n                self.redeemscript = b'\\0' + varstr(self.hash_bytes)\n                # overwrite hash_bytes with hash of redeemscript\n                self.hash_bytes = hash160(self.redeemscript)\n            if self.prefix is None:\n                if self.script_type in ['p2sh', 'p2sh_p2wpkh', 'p2sh_p2wsh', 'p2sh_multisig'] or \\\n                        self.witness_type == 'p2sh-segwit':\n                    self.prefix = self.network.prefix_address_p2sh\n                else:\n                    self.prefix = self.network.prefix_address\n            else:\n                self.prefix = to_bytes(prefix)\n        elif self.encoding == 'bech32':\n            if self.script_type is None:\n                self.script_type = 'p2wpkh'\n            if self.prefix is None:\n                self.prefix = self.network.prefix_bech32\n        else:\n            raise BKeyError(\"Encoding %s not supported\" % self.encoding)\n        self.address = pubkeyhash_to_addr(self.hash_bytes, prefix=self.prefix, encoding=self.encoding,\n                                          witver=self.witver)\n        self.address_orig = None\n        provider_prefix = None\n        if network_overrides and 'prefix_address_p2sh' in network_overrides and self.script_type == 'p2sh':\n            provider_prefix = network_overrides['prefix_address_p2sh']\n        self.address_orig = self.address\n        if provider_prefix:\n            self.address = addr_convert(self.address, provider_prefix)",
  "def __repr__(self):\n        return \"<Address(address=%s)>\" % self.address",
  "def hashed_data(self):\n        if not self._hashed_data:\n            self._hashed_data = self.hash_bytes.hex()\n        return self._hashed_data",
  "def data(self):\n        if not self._data:\n            self._data = self.data_bytes.hex()\n        return self._data",
  "def as_dict(self):\n        \"\"\"\n        Get current Address class as dictionary. Byte values are represented by hexadecimal strings\n\n        :return dict:\n        \"\"\"\n        addr_dict = deepcopy(self.__dict__)\n        del (addr_dict['data_bytes'])\n        del (addr_dict['hash_bytes'])\n        if isinstance(addr_dict['network'], Network):\n            addr_dict['network'] = addr_dict['network'].name\n        addr_dict['redeemscript'] = addr_dict['redeemscript'].hex()\n        addr_dict['prefix'] = addr_dict['prefix']\n        return addr_dict",
  "def as_json(self):\n        \"\"\"\n        Get current key as json formatted string\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict()\n        return json.dumps(adict, indent=4)",
  "def with_prefix(self, prefix):\n        \"\"\"\n        Convert address using another prefix\n\n        :param prefix: Address prefix\n        :type prefix: str, bytes\n\n        :return str: Converted address\n        \"\"\"\n        return addr_convert(self.address, prefix)",
  "def from_wif(wif, network=None):\n        \"\"\"\n        Import private key in WIF format.\n\n        :param wif: Private key in WIF format\n        :type wif: str\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n\n        :return Key:\n        \"\"\"\n        key_hex = change_base(wif, 58, 16)\n        networks = network_by_value('prefix_wif', key_hex[:2])\n        compressed = False\n        if networks:\n            if key_hex[-10:-8] == '01':\n                compressed = True\n            network = network or next(iter(networks), DEFAULT_NETWORK)\n        else:\n            raise BKeyError(\"Could not create key, wif format not recognised\")\n        return Key(wif, network, compressed, is_private=True)",
  "def __init__(self, import_key=None, network=None, compressed=True, password='', is_private=None, strict=True):\n        \"\"\"\n        Initialize a Key object. Import key can be in WIF, bytes, hexstring, etc. If import_key is empty a new\n        private key will be generated.\n\n        If a private key is imported a public key will be derived. If a public is imported the private key data will\n        be empty.\n\n        Both compressed and uncompressed key version is available, the compressed boolean attribute tells if the\n        original imported key was compressed or not.\n\n        >>> k = Key('cNUpWJbC1hVJtyxyV4bVAnb4uJ7FPhr82geo1vnoA29XWkeiiCQn')\n        >>> k.secret\n        12127227708610754620337553985245292396444216111803695028419544944213442390363\n\n        Can also be used to import BIP-38 password protected keys\n\n        >>> k2 = Key('6PYM8wAnnmAK5mHYoF7zqj88y5HtK7eiPeqPdu4WnYEFkYKEEoMFEVfuDg', password='test', network='testnet')\n        >>> k2.secret\n        12127227708610754620337553985245292396444216111803695028419544944213442390363\n\n        :param import_key: If specified import given private or public key. If not specified a new private key is generated.\n        :type import_key: str, int, bytes\n        :param network: Bitcoin, testnet, litecoin or other network\n        :type network: str, Network\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param password: Optional password if imported key is password protected\n        :type password: str\n        :param is_private: Specify if imported key is private or public. Default is None: derive from provided key\n        :type is_private: bool\n        :param strict: Raise BKeyError if key is invalid. Default is True. Set to False if you're parsing blockchain transactions, as some may contain invalid keys, but the transaction is/was still valid.\n        :type strict: bool\n\n        :return: Key object\n        \"\"\"\n        self.public_hex = None\n        self._public_uncompressed_hex = None\n        self.public_compressed_hex = None\n        self.public_byte = None\n        self._public_uncompressed_byte = None\n        self.public_compressed_byte = None\n        self.private_byte = None\n        self.private_hex = None\n        self._x = None\n        self._y = None\n        self.x_hex = None\n        self.y_hex = None\n        self.secret = None\n        self.compressed = compressed\n        self._hash160 = None\n        self.key_format = None\n        self.is_private = None\n\n        if not import_key:\n            import_key = random.SystemRandom().randint(1, secp256k1_n - 1)\n            self.key_format = 'decimal'\n            networks_extracted = network\n            assert is_private is True or is_private is None\n            self.is_private = True  # Ignore provided attribute\n        else:\n            try:\n                kf = get_key_format(import_key)\n            except BKeyError:\n                if strict:\n                    raise BKeyError(\"Unrecognised key format\")\n                else:\n                    networks_extracted = []\n            else:\n                if kf['format'] == 'address':\n                    raise BKeyError(\"Can not create Key object from address\")\n                self.key_format = kf[\"format\"]\n                networks_extracted = kf[\"networks\"]\n                self.is_private = is_private if is_private else kf['is_private']\n                if self.is_private is None:\n                    raise BKeyError(\"Could not determine if key is private or public\")\n\n        if network is not None:\n            self.network = network\n            if not isinstance(network, Network):\n                self.network = Network(network)\n        elif networks_extracted:\n            self.network = Network(check_network_and_key(import_key, None, networks_extracted))\n        else:\n            self.network = Network(DEFAULT_NETWORK)\n\n        if self.key_format == \"wif_protected\":\n            import_key, self.compressed = self._bip38_decrypt(import_key, password, network)\n            self.key_format = 'bin_compressed' if self.compressed else 'bin'\n\n        if not self.is_private:\n            self.secret = None\n            pub_key = to_hexstring(import_key)\n            if len(pub_key) == 130:\n                self._public_uncompressed_hex = pub_key\n                self.x_hex = pub_key[2:66]\n                self.y_hex = pub_key[66:130]\n                self._y = int(self.y_hex, 16)\n                self.compressed = False\n                if self._y % 2:\n                    prefix = '03'\n                else:\n                    prefix = '02'\n                self.public_hex = pub_key\n                self.public_compressed_hex = prefix + self.x_hex\n            else:\n                self.public_hex = pub_key\n                self.x_hex = pub_key[2:66]\n                self.compressed = True\n                self._x = int(self.x_hex, 16)\n                self.public_compressed_hex = pub_key\n            self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)\n            if self._public_uncompressed_hex:\n                self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)\n            if self.compressed:\n                self.public_byte = self.public_compressed_byte\n            else:\n                self.public_byte = self.public_uncompressed_byte\n        elif self.is_private and self.key_format == 'decimal':\n            self.secret = int(import_key)\n            self.private_hex = change_base(self.secret, 10, 16, 64)\n            self.private_byte = bytes.fromhex(self.private_hex)\n        elif self.is_private:\n            if self.key_format == 'hex':\n                key_hex = import_key\n                key_byte = bytes.fromhex(key_hex)\n            elif self.key_format == 'hex_compressed':\n                key_hex = import_key[:-2]\n                key_byte = bytes.fromhex(key_hex)\n                self.compressed = True\n            elif self.key_format == 'bin':\n                key_byte = import_key\n                key_hex = key_byte.hex()\n            elif self.key_format == 'bin_compressed':\n                key_byte = import_key\n                if len(import_key) in [33, 65, 129] and import_key[-1:] == b'\\1':\n                    key_byte = import_key[:-1]\n                key_hex = key_byte.hex()\n                self.compressed = True\n            elif self.is_private and self.key_format in ['wif', 'wif_compressed']:\n                # Check and remove Checksum, prefix and postfix tags\n                key = change_base(import_key, 58, 256)\n                checksum = key[-4:]\n                key = key[:-4]\n                if checksum != double_sha256(key)[:4]:\n                    raise BKeyError(\"Invalid checksum, not a valid WIF key\")\n                found_networks = network_by_value('prefix_wif', key[0:1].hex())\n                if not len(found_networks):\n                    raise BKeyError(\"Unrecognised WIF private key, version byte unknown. Versionbyte: %s\" % key[0:1])\n                self._wif = import_key\n                self._wif_prefix = key[0:1]\n                # if self.network.name not in found_networks:\n                #     if len(found_networks) > 1:\n                #         raise BKeyError(\"More then one network found with this versionbyte, please specify network. \"\n                #                         \"Networks found: %s\" % found_networks)\n                #     else:\n                #         _logger.warning(\"Current network %s is different then the one found in key: %s\" %\n                #                         (network, found_networks[0]))\n                #         self.network = Network(found_networks[0])\n                if key[-1:] == b'\\x01':\n                    self.compressed = True\n                    key = key[:-1]\n                else:\n                    self.compressed = False\n                key_byte = key[1:]\n                key_hex = key_byte.hex()\n            else:\n                raise BKeyError(\"Unknown key format %s\" % self.key_format)\n\n            if not (key_byte or key_hex):\n                raise BKeyError(\"Cannot format key in hex or byte format\")\n            self.private_hex = key_hex\n            self.private_byte = key_byte\n            self.secret = int(key_hex, 16)\n        else:\n            raise BKeyError(\"Cannot import key. Public key format unknown\")\n\n        if self.is_private and not (self.public_byte or self.public_hex):\n            if not self.is_private:\n                raise BKeyError(\"Private key has no known secret number\")\n            p = ec_point(self.secret)\n            if USE_FASTECDSA:\n                self._x = p.x\n                self._y = p.y\n            else:\n                self._x = p.x()\n                self._y = p.y()\n            self.x_hex = change_base(self._x, 10, 16, 64)\n            self.y_hex = change_base(self._y, 10, 16, 64)\n            if self._y % 2:\n                prefix = '03'\n            else:\n                prefix = '02'\n\n            self.public_compressed_hex = prefix + self.x_hex\n            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex\n            self.public_hex = self.public_compressed_hex if self.compressed else self.public_uncompressed_hex\n\n            self.public_compressed_byte = bytes.fromhex(self.public_compressed_hex)\n            self._public_uncompressed_byte = bytes.fromhex(self._public_uncompressed_hex)\n            self.public_byte = self.public_compressed_byte if self.compressed else self.public_uncompressed_byte\n        self._address_obj = None\n        self._wif = None\n        self._wif_prefix = None",
  "def __repr__(self):\n        return \"<Key(public_hex=%s, network=%s)>\" % (self.public_hex, self.network.name)",
  "def __str__(self):\n        return self.public_hex",
  "def __bytes__(self):\n        return self.public_byte",
  "def __add__(self, other):\n        return self.public_byte + other",
  "def __radd__(self, other):\n        return other + self.public_byte",
  "def __len__(self):\n        return len(self.public_byte)",
  "def __eq__(self, other):\n        if other is None or not isinstance(other, Key):\n            return False\n        if self.is_private and other.is_private:\n            return self.private_hex == other.private_hex\n        else:\n            return self.public_hex == other.public_hex",
  "def __hash__(self):\n        if self.is_private:\n            return hash(self.private_byte)\n        else:\n            return hash(self.public_byte)",
  "def __int__(self):\n        if self.is_private:\n            return self.secret\n        else:\n            return None",
  "def x(self):\n        if not self._x and self.x_hex:\n            self._x = int(self.x_hex, 16)\n        return self._x",
  "def y(self):\n        if not self._y:\n            if not self.y_hex:\n                self._public_uncompressed_hex = self.public_uncompressed_hex\n            self._y = int(self.y_hex, 16)\n        return self._y",
  "def public_uncompressed_hex(self):\n        if not self._public_uncompressed_hex:\n            # Calculate y from x with y=x^3 + 7 function\n            sign = self.public_hex[:2] == '03'\n            ys = pow(self._x, 3, secp256k1_p) + 7 % secp256k1_p\n            self._y = mod_sqrt(ys)\n            if self._y & 1 != sign:\n                self._y = secp256k1_p - self._y\n            self.y_hex = change_base(self._y, 10, 16, 64)\n            self._public_uncompressed_hex = '04' + self.x_hex + self.y_hex\n        return self._public_uncompressed_hex",
  "def public_uncompressed_byte(self):\n        if not self._public_uncompressed_byte:\n            self._public_uncompressed_byte = bytes.fromhex(self.public_uncompressed_hex)\n        return self._public_uncompressed_byte",
  "def hex(self):\n        return self.public_hex",
  "def as_dict(self, include_private=False):\n        \"\"\"\n        Get current Key class as dictionary. Byte values are represented by hexadecimal strings.\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return collections.OrderedDict:\n        \"\"\"\n\n        key_dict = collections.OrderedDict()\n        key_dict['network'] = self.network.name\n        key_dict['key_format'] = self.key_format\n        key_dict['compressed'] = self.compressed\n        key_dict['is_private'] = self.is_private\n        if include_private:\n            key_dict['private_hex'] = self.private_hex\n            key_dict['secret'] = self.secret\n            key_dict['wif'] = self.wif()\n        key_dict['public_hex'] = self.public_hex\n        key_dict['public_uncompressed_hex'] = self.public_uncompressed_hex\n        key_dict['hash160'] = self.hash160.hex()\n        key_dict['address'] = self.address()\n        x, y = self.public_point()\n        key_dict['point_x'] = x\n        key_dict['point_y'] = y\n        return key_dict",
  "def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return str:\n        \"\"\"\n        return json.dumps(self.as_dict(include_private=include_private), indent=4)",
  "def _bip38_decrypt(encrypted_privkey, password, network=DEFAULT_NETWORK):\n        \"\"\"\n        BIP0038 non-ec-multiply decryption. Returns WIF private key.\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n        This method is called by Key class init function when importing BIP0038 key.\n\n        :param encrypted_privkey: Encrypted private key using WIF protected key format\n        :type encrypted_privkey: str\n        :param password: Required password for decryption\n        :type password: str\n\n        :return str: Private Key WIF\n        \"\"\"\n        priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)\n\n        # Verify addresshash\n        k = Key(priv, compressed=compressed, network=network)\n        addr = k.address()\n        if isinstance(addr, str):\n            addr = addr.encode('utf-8')\n        if double_sha256(addr)[0:4] != addresshash:\n            raise BKeyError('Addresshash verification failed! Password or '\n                            'specified network %s might be incorrect' % network)\n        return priv, compressed",
  "def encrypt(self, password):\n        \"\"\"\n        BIP0038 non-ec-multiply encryption. Returns BIP0038 encrypted private key\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n\n        >>> k = Key('cNUpWJbC1hVJtyxyV4bVAnb4uJ7FPhr82geo1vnoA29XWkeiiCQn')\n        >>> k.encrypt('test')\n        '6PYM8wAnnmAK5mHYoF7zqj88y5HtK7eiPeqPdu4WnYEFkYKEEoMFEVfuDg'\n\n        :param password: Required password for encryption\n        :type password: str\n\n        :return str: BIP38 password encrypted private key\n        \"\"\"\n        flagbyte = b'\\xe0' if self.compressed else b'\\xc0'\n        return bip38_encrypt(self.private_hex, self.address(), password, flagbyte)",
  "def bip38_encrypt(self, password):\n        return self.encrypt(password)",
  "def wif(self, prefix=None):\n        \"\"\"\n        Get private Key in Wallet Import Format, steps:\n        # Convert to Binary and add 0x80 hex\n        # Calculate Double SHA256 and add as checksum to end of key\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n\n        :return str: Base58Check encoded Private Key WIF\n        \"\"\"\n        if not self.secret:\n            raise BKeyError(\"WIF format not supported for public key\")\n        if prefix is None:\n            versionbyte = self.network.prefix_wif\n        else:\n            if not isinstance(prefix, bytes):\n                versionbyte = bytes.fromhex(prefix)\n            else:\n                versionbyte = prefix\n\n        if self._wif and self._wif_prefix == versionbyte:\n            return self._wif\n\n        key = versionbyte + self.secret.to_bytes(32, byteorder='big')\n        if self.compressed:\n            key += b'\\1'\n        key += double_sha256(key)[:4]\n        self._wif = base58encode(key)\n        self._wif_prefix = versionbyte\n        return self._wif",
  "def public(self):\n        \"\"\"\n        Get public version of current key. Removes all private information from current key\n\n        :return Key: Public key\n        \"\"\"\n        key = deepcopy(self)\n        key.is_private = False\n        key.private_byte = None\n        key.private_hex = None\n        key.secret = None\n        return key",
  "def public_point(self):\n        \"\"\"\n        Get public key point on Elliptic curve\n\n        :return tuple: (x, y) point\n        \"\"\"\n        return (self.x, self.y)",
  "def hash160(self):\n        \"\"\"\n        Get public key in RIPEMD-160 + SHA256 format\n\n        :return bytes:\n        \"\"\"\n        if not self._hash160:\n            self._hash160 = hash160(self.public_byte if self.compressed else self.public_uncompressed_byte)\n        return self._hash160",
  "def address_obj(self):\n        \"\"\"\n        Get address object property. Create standard address object if not defined already.\n\n        :return Address:\n        \"\"\"\n        if not self._address_obj:\n            self.address()\n        return self._address_obj",
  "def address(self, compressed=None, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get address derived from public key\n\n        :param compressed: Always return compressed address\n        :type compressed: bool\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 or Bech32 encoded address\n        \"\"\"\n        if (self.compressed and compressed is None) or compressed:\n            data = self.public_byte\n            self.compressed = True\n        else:\n            data = self.public_uncompressed_byte\n            self.compressed = False\n        if encoding is None:\n            if self._address_obj:\n                encoding = self._address_obj.encoding\n            else:\n                encoding = 'base58'\n        if not self.compressed and encoding == 'bech32':\n            raise BKeyError(\"Uncompressed keys are non-standard for segwit/bech32 encoded addresses\")\n        if self._address_obj and script_type is None:\n            script_type = self._address_obj.script_type\n        if not (self._address_obj and self._address_obj.prefix == prefix and self._address_obj.encoding == encoding):\n            self._address_obj = Address(data, prefix=prefix, network=self.network, script_type=script_type,\n                                        encoding=encoding, compressed=compressed)\n        return self._address_obj.address",
  "def address_uncompressed(self, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get uncompressed address from public key\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 encoded address\n        \"\"\"\n        return self.address(compressed=False, prefix=prefix, script_type=script_type, encoding=encoding)",
  "def info(self):\n        \"\"\"\n        Prints key information to standard output\n\n        \"\"\"\n\n        print(\"KEY INFO\")\n        print(\" Network                     %s\" % self.network.name)\n        print(\" Compressed                  %s\" % self.compressed)\n        if self.secret:\n            print(\"SECRET EXPONENT\")\n            print(\" Private Key (hex)              %s\" % self.private_hex)\n            print(\" Private Key (long)             %s\" % self.secret)\n            if isinstance(self, HDKey):\n                print(\" Private Key (wif)              %s\" % self.wif_key())\n            else:\n                print(\" Private Key (wif)              %s\" % self.wif())\n        else:\n            print(\"PUBLIC KEY ONLY, NO SECRET EXPONENT\")\n        print(\"PUBLIC KEY\")\n        print(\" Public Key (hex)            %s\" % self.public_hex)\n        print(\" Public Key uncompr. (hex)   %s\" % self.public_uncompressed_hex)\n        print(\" Public Key Hash160          %s\" % self.hash160.hex())\n        print(\" Address (b58)               %s\" % self.address())\n        point_x, point_y = self.public_point()\n        print(\" Point x                     %s\" % point_x)\n        print(\" Point y                     %s\" % point_y)",
  "def from_seed(import_seed, key_type='bip32', network=DEFAULT_NETWORK, compressed=True,\n                  encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):\n        \"\"\"\n        Used by class init function, import key from seed\n\n        :param import_seed: Private key seed as bytes or hexstring\n        :type import_seed: str, bytes\n        :param key_type: Specify type of key, default is BIP32\n        :type key_type: str\n        :param network: Network to use\n        :type network: str, Network\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addresses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        seed = to_bytes(import_seed)\n        i = hmac.new(b\"Bitcoin seed\", seed, hashlib.sha512).digest()\n        key = i[:32]\n        chain = i[32:]\n        key_int = int.from_bytes(key, 'big')\n        if key_int >= secp256k1_n:\n            raise BKeyError(\"Key int value cannot be greater than secp256k1_n\")\n        return HDKey(key=key, chain=chain, network=network, key_type=key_type, compressed=compressed,\n                     encoding=encoding, witness_type=witness_type, multisig=multisig)",
  "def from_passphrase(passphrase, password='', network=DEFAULT_NETWORK, key_type='bip32', compressed=True,\n                        encoding=None, witness_type=DEFAULT_WITNESS_TYPE, multisig=False):\n        \"\"\"\n        Create key from Mnemonic passphrase\n\n        :param passphrase: Mnemonic passphrase, list of words as string seperated with a space character\n        :type passphrase: str\n        :param password: Password to protect passphrase\n        :type password: str\n        :param network: Network to use\n        :type network: str, Network\n        :param key_type: HD BIP32 or normal Private Key. Default is 'bip32'\n        :type key_type: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addreses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        return HDKey.from_seed(Mnemonic().to_seed(passphrase, password), network=network, key_type=key_type,\n                               compressed=compressed, encoding=encoding, witness_type=witness_type, multisig=multisig)",
  "def from_wif(wif, network=None, compressed=True, multisig=None):\n        \"\"\"\n        Create HDKey from BIP32 WIF\n\n        :param wif: HDKey WIF\n        :type wif: str\n        :param network: Network to use as string\n        :type network: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addresses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n        bkey = change_base(wif, 58, 256)\n        if len(bkey) != 82:\n            raise BKeyError(\"Invalid BIP32 HDkey WIF. Length must be 82 characters\")\n\n        if ord(bkey[45:46]):\n            is_private = False\n            key = bkey[45:78]\n        else:\n            is_private = True\n            key = bkey[46:78]\n        depth = ord(bkey[4:5])\n        parent_fingerprint = bkey[5:9]\n        child_index = int.from_bytes(bkey[9:13], 'big')\n        chain = bkey[13:45]\n\n        key_hex = bkey.hex()\n        prefix_data = wif_prefix_search(key_hex[:8], network=network, multisig=multisig)\n        if not prefix_data:\n            raise BKeyError(\"Invalid BIP32 HDkey WIF. Cannot find prefix in network definitions\")\n\n        networks = list(dict.fromkeys([n['network'] for n in prefix_data]))\n        if not network and networks:\n            network = networks[0]\n        elif network not in networks:\n            raise BKeyError(\"Network %s not found in list of derived networks %s\" % (network, networks))\n\n        witness_type = next(iter(list(dict.fromkeys([n['witness_type'] for n in prefix_data]))), None)\n        multisig = multisig or next(iter(list(dict.fromkeys([n['multisig'] for n in prefix_data]))), None)\n\n        return HDKey(key=key, chain=chain, depth=depth, parent_fingerprint=parent_fingerprint,\n                     child_index=child_index, is_private=is_private, network=network, witness_type=witness_type,\n                     multisig=multisig, compressed=compressed)",
  "def __init__(self, import_key=None, key=None, chain=None, depth=0, parent_fingerprint=b'\\0\\0\\0\\0',\n                 child_index=0, is_private=True, network=None, key_type='bip32', password='', compressed=True,\n                 encoding=None, witness_type=None, multisig=False):\n        \"\"\"\n        Hierarchical Deterministic Key class init function.\n\n        If no import_key is specified a key will be generated with systems cryptographically random function.\n        Import key can be any format normal or HD key (extended key) accepted by get_key_format.\n        If a normal key with no chain part is provided, a chain with only 32 0-bytes will be used.\n\n        >>> private_hex = '221ff330268a9bb5549a02c801764cffbc79d5c26f4041b26293a425fd5b557c'\n        >>> k = HDKey(private_hex)\n        >>> k\n        <HDKey(public_hex=0363c152144dcd5253c1216b733fdc6eb8a94ab2cd5caa8ead5e59ab456ff99927, wif_public=xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6SmypHzZG2cYrwpGkWJqRxS6EAW77gd7CHFoXNpBd3LN8xjAyCW, network=bitcoin)>\n\n        :param import_key: HD Key to import in WIF format or as byte with key (32 bytes) and chain (32 bytes)\n        :type import_key: str, bytes, int\n        :param key: Private or public key (length 32)\n        :type key: bytes\n        :param chain: A chain code (length 32)\n        :type chain: bytes\n        :param depth: Level of depth in BIP32 key path\n        :type depth: int\n        :param parent_fingerprint: 4-byte fingerprint of parent\n        :type parent_fingerprint: bytes\n        :param child_index: Index number of child as integer\n        :type child_index: int\n        :param is_private: True for private, False for public key. Default is True\n        :type is_private: bool\n        :param network: Network name. Derived from import_key if possible\n        :type network: str, Network\n        :param key_type: HD BIP32 or normal Private Key. Default is 'bip32'\n        :type key_type: str\n        :param password: Optional password if imported key is password protected\n        :type password: str\n        :param compressed: Is key compressed or not, default is True\n        :type compressed: bool\n        :param encoding: Encoding used for address, i.e.: base58 or bech32. Default is base58 or derive from witness type\n        :type encoding: str\n        :param witness_type: Witness type used when creating scripts: legacy, p2sh-segwit or segwit.\n        :type witness_type: str\n        :param multisig: Specify if key is part of multisig wallet, used when creating key representations such as WIF and addreses\n        :type multisig: bool\n\n        :return HDKey:\n        \"\"\"\n\n        if not encoding and witness_type:\n            encoding = get_encoding_from_witness(witness_type)\n        self.script_type = script_type_default(witness_type, multisig)\n\n        # if (key and not chain) or (not key and chain):\n        #     raise BKeyError(\"Please specify both key and chain, use import_key attribute \"\n        #                     \"or use simple Key class instead\")\n        if not key:\n            if not import_key:\n                # Generate new Master Key\n                seed = os.urandom(64)\n                key, chain = self._key_derivation(seed)\n            # If key is 64 bytes long assume a HD Key with key and chain part\n            elif isinstance(import_key, bytes) and len(import_key) == 64:\n                key = import_key[:32]\n                chain = import_key[32:]\n            elif isinstance(import_key, Key):\n                if not import_key.compressed:\n                    _logger.warning(\"Uncompressed private keys are not standard for BIP32 keys, use at your own risk!\")\n                    compressed = False\n                chain = chain if chain else b'\\0' * 32\n                if not import_key.private_byte:\n                    raise BKeyError('Cannot import public Key in HDKey')\n                key = import_key.private_byte\n                key_type = 'private'\n            else:\n                kf = get_key_format(import_key)\n                if kf['format'] == 'address':\n                    raise BKeyError(\"Can not create HDKey object from address\")\n                if len(kf['script_types']) == 1:\n                    self.script_type = kf['script_types'][0]\n                if len(kf['witness_types']) == 1 and not witness_type:\n                    witness_type = kf['witness_types'][0]\n                    encoding = get_encoding_from_witness(witness_type)\n                if len(kf['multisig']) == 1:\n                    multisig = kf['multisig'][0]\n                network = Network(check_network_and_key(import_key, network, kf[\"networks\"]))\n                if kf['format'] in ['hdkey_private', 'hdkey_public']:\n                    bkey = change_base(import_key, 58, 256)\n                    # Derive key, chain, depth, child_index and fingerprint part from extended key WIF\n                    if ord(bkey[45:46]):\n                        is_private = False\n                        key = bkey[45:78]\n                    else:\n                        key = bkey[46:78]\n                    depth = ord(bkey[4:5])\n                    parent_fingerprint = bkey[5:9]\n                    child_index = int.from_bytes(bkey[9:13], 'big')\n                    chain = bkey[13:45]\n                elif kf['format'] == 'mnemonic':\n                    raise BKeyError(\"Use HDKey.from_passphrase() method to parse a passphrase\")\n                elif kf['format'] == 'wif_protected':\n                    key, compressed = self._bip38_decrypt(import_key, password, network.name, witness_type)\n                    chain = chain if chain else b'\\0' * 32\n                    key_type = 'private'\n                else:\n                    key = import_key\n                    chain = chain if chain else b'\\0' * 32\n                    is_private = kf['is_private']\n                    key_type = 'private' if is_private else 'public'\n\n        if witness_type is None:\n            witness_type = DEFAULT_WITNESS_TYPE\n\n        Key.__init__(self, key, network, compressed, password, is_private)\n\n        self.encoding = encoding\n        self.witness_type = witness_type\n        self.multisig = multisig\n\n        self.chain = chain\n        self.depth = depth\n        self.parent_fingerprint = parent_fingerprint\n        self.child_index = child_index\n        self.key_type = key_type",
  "def __repr__(self):\n        return \"<HDKey(public_hex=%s, wif_public=%s, network=%s)>\" % \\\n               (self.public_hex, self.wif_public(), self.network.name)",
  "def info(self):\n        \"\"\"\n        Prints key information to standard output\n\n        \"\"\"\n        super(HDKey, self).info()\n\n        print(\"EXTENDED KEY\")\n        print(\" Key Type                    %s\" % self.key_type)\n        print(\" Chain code (hex)            %s\" % self.chain.hex())\n        print(\" Child Index                 %s\" % self.child_index)\n        print(\" Parent Fingerprint (hex)    %s\" % self.parent_fingerprint.hex())\n        print(\" Depth                       %s\" % self.depth)\n        print(\" Extended Public Key (wif)   %s\" % self.wif_public())\n        print(\" Witness type                %s\" % self.witness_type)\n        print(\" Script type                 %s\" % self.script_type)\n        print(\" Multisig                    %s\" % self.multisig)\n        if self.is_private:\n            print(\" Extended Private Key (wif)  %s\" % self.wif(is_private=True))\n        print(\"\\n\")",
  "def as_dict(self, include_private=False):\n        \"\"\"\n        Get current HDKey class as dictionary. Byte values are represented by hexadecimal strings.\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n\n        :return collections.OrderedDict:\n        \"\"\"\n\n        key_dict = super(HDKey, self).as_dict()\n        if include_private:\n            key_dict['fingerprint'] = self.fingerprint.hex()\n            key_dict['chain_code'] = self.chain.hex()\n            key_dict['fingerprint_parent'] = self.parent_fingerprint.hex()\n        key_dict['child_index'] = self.child_index\n        key_dict['depth'] = self.depth\n        key_dict['extended_wif_public'] = self.wif_public()\n        if include_private:\n            key_dict['extended_wif_private'] = self.wif(is_private=True)\n        return key_dict",
  "def as_json(self, include_private=False):\n        \"\"\"\n        Get current key as json formatted string\n\n        :param include_private: Include private key information in dictionary\n        :type include_private: bool\n        \n        :return str:\n        \"\"\"\n        return json.dumps(self.as_dict(include_private=include_private), indent=4)",
  "def _key_derivation(self, seed):\n        \"\"\"\n        Derive extended private key with key and chain part from seed\n\n        :param seed:\n        :type seed: bytes\n\n        :return tuple: key and chain bytes\n        \"\"\"\n        chain = hasattr(self, 'chain') and self.chain or b\"Bitcoin seed\"\n        i = hmac.new(chain, seed, hashlib.sha512).digest()\n        key = i[:32]\n        chain = i[32:]\n        key_int = int.from_bytes(key, 'big')\n        if key_int >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n        return key, chain",
  "def fingerprint(self):\n        \"\"\"\n        Get key fingerprint: the last for bytes of the hash160 of this key.\n\n        :return bytes:\n        \"\"\"\n\n        return self.hash160[:4]",
  "def _bip38_decrypt(encrypted_privkey, password, network=DEFAULT_NETWORK, witness_type=DEFAULT_WITNESS_TYPE):\n        \"\"\"\n        BIP0038 non-ec-multiply decryption. Returns WIF private key.\n        Based on code from https://github.com/nomorecoin/python-bip38-testing\n        This method is called by Key class init function when importing BIP0038 key.\n\n        :param encrypted_privkey: Encrypted private key using WIF protected key format\n        :type encrypted_privkey: str\n        :param password: Required password for decryption\n        :type password: str\n\n        :return str: Private Key WIF\n        \"\"\"\n        priv, addresshash, compressed = bip38_decrypt(encrypted_privkey, password)\n        # compressed = True if priv[-1:] == b'\\1' else False\n\n        # Verify addresshash\n        k = HDKey(priv, compressed=compressed, network=network, witness_type=witness_type)\n        addr = k.address()\n        if isinstance(addr, str):\n            addr = addr.encode('utf-8')\n        if double_sha256(addr)[0:4] != addresshash:\n            raise BKeyError('Addresshash verification failed! Password or '\n                            'specified network %s might be incorrect' % network)\n        return priv, compressed",
  "def wif(self, is_private=None, child_index=None, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF of current key\n\n        >>> private_hex = '221ff330268a9bb5549a02c801764cffbc79d5c26f4041b26293a425fd5b557c'\n        >>> k = HDKey(private_hex)\n        >>> k.wif()\n        'xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6SmypHzZG2cYrwpGkWJqRxS6EAW77gd7CHFoXNpBd3LN8xjAyCW'\n\n        :param is_private: Return public or private key\n        :type is_private: bool\n        :param child_index: Change child index of output WIF key\n        :type child_index: int\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n\n        if not witness_type:\n            witness_type = DEFAULT_WITNESS_TYPE if not self.witness_type else self.witness_type\n        if not multisig:\n            multisig = False if not self.multisig else self.multisig\n\n        rkey = self.private_byte or self.public_compressed_byte\n        if prefix and not isinstance(prefix, bytes):\n            prefix = bytes.fromhex(prefix)\n        if self.is_private and is_private:\n            if not prefix:\n                prefix = self.network.wif_prefix(is_private=True, witness_type=witness_type, multisig=multisig)\n            typebyte = b'\\x00'\n        else:\n            if not prefix:\n                prefix = self.network.wif_prefix(witness_type=witness_type, multisig=multisig)\n            typebyte = b''\n            if not is_private:\n                rkey = self.public_byte\n        if child_index:\n            self.child_index = child_index\n        raw = prefix + self.depth.to_bytes(1, 'big') + self.parent_fingerprint + \\\n              self.child_index.to_bytes(4, 'big') + self.chain + typebyte + rkey\n        chk = double_sha256(raw)[:4]\n        ret = raw + chk\n        return change_base(ret, 256, 58, 111)",
  "def wif_key(self, prefix=None):\n        \"\"\"\n        Get WIF of Key object. Call to parent object Key.wif()\n\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :return str: Base58Check encoded Private Key WIF\n        \"\"\"\n        return super(HDKey, self).wif(prefix)",
  "def wif_public(self, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF public key. Wrapper for the :func:`wif` method\n\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n        return self.wif(is_private=False, prefix=prefix, witness_type=witness_type, multisig=multisig)",
  "def wif_private(self, prefix=None, witness_type=None, multisig=None):\n        \"\"\"\n        Get Extended WIF private key. Wrapper for the :func:`wif` method\n\n        :param prefix: Specify version prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' for segregated witness.\n        :type witness_type: str\n        :param multisig: Key is part of a multi signature wallet?\n        :type multisig: bool\n\n        :return str: Base58 encoded WIF key\n        \"\"\"\n        return self.wif(is_private=True, prefix=prefix, witness_type=witness_type, multisig=multisig)",
  "def address(self, compressed=None, prefix=None, script_type=None, encoding=None):\n        \"\"\"\n        Get address derived from public key\n\n        >>> wif = 'xpub661MyMwAqRbcFcXi3aM3fVdd42FGDSdufhrr5tdobiPjMrPUykFMTdaFEr7yoy1xxeifDY8kh2k4h9N77MY6rk18nfgg5rPtbFDF2YHzLfA'\n        >>> k = HDKey.from_wif(wif)\n        >>> k.address()\n        '15CacK61qnzJKpSpx9PFiC8X1ajeQxhq8a'\n\n        :param compressed: Always return compressed address\n        :type compressed: bool\n        :param prefix: Specify versionbyte prefix in hexstring or bytes. Normally doesn't need to be specified, method uses default prefix from network settings\n        :type prefix: str, bytes\n        :param script_type: Type of script, i.e. p2sh or p2pkh.\n        :type script_type: str\n        :param encoding: Address encoding. Default is base58 encoding, for segwit you can specify bech32 encoding\n        :type encoding: str\n\n        :return str: Base58 or Bech32 encoded address\n        \"\"\"\n        if compressed is None:\n            compressed = self.compressed\n        if script_type is None:\n            script_type = self.script_type\n        if encoding is None:\n            encoding = self.encoding\n        return super(HDKey, self).address(compressed, prefix, script_type, encoding)",
  "def subkey_for_path(self, path, network=None):\n        \"\"\"\n        Determine subkey for HD Key for given path.\n        Path format: m / purpose' / coin_type' / account' / change / address_index\n\n        See BIP0044 bitcoin proposal for more explanation.\n\n        >>> wif = 'xprv9s21ZrQH143K4LvcS93AHEZh7gBiYND6zMoRiZQGL5wqbpCU2KJDY87Txuv9dduk9hAcsL76F8b5JKzDREf8EmXjbUwN1c4nR9GEx56QGg2'\n        >>> k = HDKey.from_wif(wif)\n        >>> k.subkey_for_path(\"m/44'/0'/0'/0/2\")\n        <HDKey(public_hex=03004331ca7f0dcdd925abc4d0800a0d4a0562a02c257fa39185c55abdfc4f0c0c, wif_public=xpub6GyQoEbMUNwu1LnbiCSaD8wLrcjyRCEQA8tNsFCH4pnvCbuWSZkSB6LUNe89YsCBTg1Ncs7vHJBjMvw2Q7siy3A4g1srAq7Lv3CtEXghv44, network=bitcoin)>\n\n        :param path: BIP0044 key path\n        :type path: str, list\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object of subkey\n        \"\"\"\n\n        if isinstance(path, TYPE_TEXT):\n            path = path.split(\"/\")\n        if self.key_type == 'single':\n            raise BKeyError(\"Key derivation cannot be used for 'single' type keys\")\n        key = self\n        first_public = False\n        if path[0] == 'm':  # Use Private master key\n            path = path[1:]\n        elif path[0] == 'M':  # Use Public master key\n            path = path[1:]\n            first_public = True\n        if path:\n            if len(path) > 1:\n                _logger.info(\"Path length > 1 can be slow for larger paths, use Wallet Class to generate keys paths\")\n            for item in path:\n                if not item:\n                    raise BKeyError(\"Could not parse path. Index is empty.\")\n                hardened = item[-1] in \"'HhPp\"\n                if hardened:\n                    item = item[:-1]\n                index = int(item)\n                if index < 0:\n                    raise BKeyError(\"Could not parse path. Index must be a positive integer.\")\n                if first_public or not key.is_private:\n                    key = key.child_public(index=index, network=network)  # TODO hardened=hardened key?\n                    first_public = False\n                else:\n                    key = key.child_private(index=index, hardened=hardened, network=network)\n        return key",
  "def public_master(self, account_id=0, purpose=None, multisig=None, witness_type=None, as_private=False):\n        \"\"\"\n        Derives a public master key for current HDKey. A public master key can be shared with other software\n        administration tools to create readonly wallets or can be used to create multisignature wallets.\n\n        >>> private_hex = 'b66ed9778029d32ebede042c79f448da8f7ab9efba19c63b7d3cdf6925203b71'\n        >>> k = HDKey(private_hex)\n        >>> pm = k.public_master()\n        >>> pm.wif()\n        'xpub6CjFexgdDZEtHdW7V4LT8wS9rtG3m187pM9qhTpoZdViFhSv3tW9sWonQNtFN1TCkRGAQGKj1UC2ViHTqb7vJV3X67xSKuCDzv14tBHR3Y7'\n\n        :param account_id: Account ID. Leave empty for account 0\n        :type account_id: int\n        :param purpose: BIP standard used, i.e. 44 for default, 45 for multisig, 84 for segwit. Derived from witness_type and multisig arguments if not provided\n        :type purpose: int\n        :param multisig: Key is part of a multisignature wallet?\n        :type multisig: bool\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' or 'p2sh-segwit' for segregated witness.\n        :type witness_type: str\n        :param as_private: Return private key if available. Default is to return public key\n\n        :return HDKey:\n        \"\"\"\n        if multisig:\n            self.multisig = multisig\n        if witness_type:\n            self.witness_type = witness_type\n        ks = [k for k in WALLET_KEY_STRUCTURES if\n              k['witness_type'] == self.witness_type and k['multisig'] == self.multisig and k['purpose'] is not None]\n        if len(ks) > 1:\n            raise BKeyError(\"Please check definitions in WALLET_KEY_STRUCTURES. Multiple options found for \"\n                            \"witness_type - multisig combination\")\n        if ks and not purpose:\n            purpose = ks[0]['purpose']\n        path_template = ks[0]['key_path']\n\n        # Use last hardened key as public master root\n        pm_depth = path_template.index([x for x in path_template if x[-1:] == \"'\"][-1]) + 1\n        path = path_expand(path_template[:pm_depth], path_template, account_id=account_id, purpose=purpose,\n                           witness_type=self.witness_type, network=self.network.name)\n        if as_private:\n            return self.subkey_for_path(path)\n        else:\n            return self.subkey_for_path(path).public()",
  "def public_master_multisig(self, account_id=0, purpose=None, witness_type=None, as_private=False):\n        \"\"\"\n        Derives a public master key for current HDKey for use with multi signature wallets. Wrapper for the\n        :func:`public_master` method.\n\n        :param account_id: Account ID. Leave empty for account 0\n        :type account_id: int\n        :param purpose: BIP standard used, i.e. 44 for default, 45 for multisig, 84 for segwit.\n        :type purpose: int\n        :param witness_type: Specify witness type, default is legacy. Use 'segwit' or 'p2sh-segwit' for segregated witness.\n        :type witness_type: str\n        :param as_private: Return private key if available. Default is to return public key\n\n        :return HDKey:\n        \"\"\"\n\n        return self.public_master(account_id, purpose, True, witness_type, as_private)",
  "def network_change(self, new_network):\n        \"\"\"\n        Change network for current key\n\n        :param new_network: Name of new network\n        :type new_network: str\n\n        :return bool: True\n        \"\"\"\n        self.network = Network(new_network)\n        return True",
  "def child_private(self, index=0, hardened=False, network=None):\n        \"\"\"\n        Use Child Key Derivation (CDK) to derive child private key of current HD Key object.\n\n        Used by :func:`subkey_for_path` to create key paths for instance to use in HD wallets. You can use this method to create your own key structures.\n\n        This method create private child keys, use :func:`child_public` to create public child keys.\n\n        >>> private_hex = 'd02220828cad5e0e0f25057071f4dae9bf38720913e46a596fd7eb8f83ad045d'\n        >>> k = HDKey(private_hex)\n        >>> ck = k.child_private(10)\n        >>> ck.address()\n        '1FgHK5JUa87ASxz5mz3ypeaUV23z9yW654'\n        >>> ck.depth\n        1\n        >>> ck.child_index\n        10\n\n        :param index: Key index number\n        :type index: int\n        :param hardened: Specify if key must be hardened (True) or normal (False)\n        :type hardened: bool\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object\n        \"\"\"\n\n        if network is None:\n            network = self.network.name\n        if not self.is_private:\n            raise BKeyError(\"Need a private key to create child private key\")\n        if hardened:\n            index |= 0x80000000\n            data = b'\\0' + self.private_byte + index.to_bytes(4, 'big')\n        else:\n            data = self.public_byte + index.to_bytes(4, 'big')\n        key, chain = self._key_derivation(data)\n\n        key = int.from_bytes(key, 'big')\n        if key >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n        newkey = (key + self.secret) % secp256k1_n\n        if newkey == 0:\n            raise BKeyError(\"Key cannot be zero. Try another index number.\")\n        newkey = int.to_bytes(newkey, 32, 'big')\n\n        return HDKey(key=newkey, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,\n                     child_index=index, witness_type=self.witness_type, multisig=self.multisig,\n                     encoding=self.encoding, network=network)",
  "def child_public(self, index=0, network=None):\n        \"\"\"\n        Use Child Key Derivation to derive child public key of current HD Key object.\n\n        Used by :func:`subkey_for_path` to create key paths for instance to use in HD wallets. You can use this method to create your own key structures.\n\n        This method create public child keys, use :func:`child_private` to create private child keys.\n\n        >>> private_hex = 'd02220828cad5e0e0f25057071f4dae9bf38720913e46a596fd7eb8f83ad045d'\n        >>> k = HDKey(private_hex)\n        >>> ck = k.child_public(15)\n        >>> ck.address()\n        '1PfLJJgKs8nUbMPpaQUucbGmr8qyNSMGeK'\n        >>> ck.depth\n        1\n        >>> ck.child_index\n        15\n\n        :param index: Key index number\n        :type index: int\n        :param network: Network name.\n        :type network: str\n\n        :return HDKey: HD Key class object\n        \"\"\"\n        if network is None:\n            network = self.network.name\n        if index > 0x80000000:\n            raise BKeyError(\"Cannot derive hardened key from public private key. Index must be less than 0x80000000\")\n        data = self.public_byte + index.to_bytes(4, 'big')\n        key, chain = self._key_derivation(data)\n        key = int.from_bytes(key, 'big')\n        if key >= secp256k1_n:\n            raise BKeyError(\"Key cannot be greater than secp256k1_n. Try another index number.\")\n\n        x, y = self.public_point()\n        if USE_FASTECDSA:\n            ki = ec_point(key) + fastecdsa_point.Point(x, y, fastecdsa_secp256k1)\n            ki_x = ki.x\n            ki_y = ki.y\n        else:\n            ki = ec_point(key) + ecdsa.ellipticcurve.Point(secp256k1_curve, x, y, secp256k1_n)\n            ki_x = ki.x()\n            ki_y = ki.y()\n\n        if ki_y % 2:\n            prefix = '03'\n        else:\n            prefix = '02'\n        xhex = change_base(ki_x, 10, 16, 64)\n        secret = bytes.fromhex(prefix + xhex)\n        return HDKey(key=secret, chain=chain, depth=self.depth + 1, parent_fingerprint=self.fingerprint,\n                     child_index=index, is_private=False, witness_type=self.witness_type, multisig=self.multisig,\n                     encoding=self.encoding, network=network)",
  "def public(self):\n        \"\"\"\n        Public version of current private key. Strips all private information from HDKey object, returns deepcopy\n        version of current object\n\n        :return HDKey:\n        \"\"\"\n\n        hdkey = deepcopy(self)\n        hdkey.is_private = False\n        hdkey.secret = None\n        hdkey.private_hex = None\n        hdkey.private_byte = None\n        hdkey.key_hex = hdkey.public_hex\n        # hdkey.key = self.key.public()\n        return hdkey",
  "def parse(cls, signature, public_key=None):\n        if isinstance(signature, bytes):\n            return cls.parse_bytes(signature, public_key)\n        elif isinstance(signature, str):\n            return cls.parse_hex(signature, public_key)",
  "def parse_hex(cls, signature, public_key=None):\n        return cls.parse_bytes(bytes.fromhex(signature), public_key)",
  "def parse_bytes(signature, public_key=None):\n        \"\"\"\n        Create a signature from signature string with r and s part. Signature length must be 64 bytes or 128\n        character hexstring\n\n        :param signature: Signature string\n        :type signature: bytes\n        :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object\n        :type public_key: HDKey, Key, str, hexstring, bytes\n\n        :return Signature:\n        \"\"\"\n\n        der_signature = ''\n        hash_type = SIGHASH_ALL\n        if len(signature) > 64 and signature.startswith(b'\\x30'):\n            der_signature = signature[:-1]\n            hash_type = int.from_bytes(signature[-1:], 'big')\n            signature = convert_der_sig(signature[:-1], as_hex=False)\n        if len(signature) != 64:\n            raise BKeyError(\"Signature length must be 64 bytes or 128 character hexstring\")\n        r = int.from_bytes(signature[:32], 'big')\n        s = int.from_bytes(signature[32:], 'big')\n        return Signature(r, s, signature=signature, der_signature=der_signature, public_key=public_key,\n                         hash_type=hash_type)",
  "def from_str(signature, public_key=None):\n        \"\"\"\n        Create a signature from signature string with r and s part. Signature length must be 64 bytes or 128 \n        character hexstring \n        \n        :param signature: Signature string\n        :type signature: bytes, str\n        :param public_key: Public key as HDKey or Key object or any other string accepted by HDKey object\n        :type public_key: HDKey, Key, str, hexstring, bytes\n        \n        :return Signature: \n        \"\"\"\n\n        signature = to_bytes(signature)\n        return Signature(signature, public_key)",
  "def create(txid, private, use_rfc6979=True, k=None):\n        \"\"\"\n        Sign a transaction hash and create a signature with provided private key.\n\n        >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'\n        >>> txid = '0d12fdc4aac9eaaab9730999e0ce84c3bd5bb38dfd1f4c90c613ee177987429c'\n        >>> sig = Signature.create(txid, k)\n        >>> sig.hex()\n        '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        >>> sig.r\n        32979225540043540145671192266052053680452913207619328973512110841045982813493\n        >>> sig.s\n        12990793585889366641563976043319195006380846016310271470330687369836458989268\n\n        :param txid: Transaction signature or transaction hash. If unhashed transaction or message is provided the double_sha256 hash of message will be calculated.\n        :type txid: bytes, str\n        :param private: Private key as HDKey or Key object, or any other string accepted by HDKey object\n        :type private: HDKey, Key, str, hexstring, bytes\n        :param use_rfc6979: Use deterministic value for k nonce to derive k from txid/message according to RFC6979 standard. Default is True, set to False to use random k\n        :type use_rfc6979: bool\n        :param k: Provide own k. Only use for testing or if you know what you are doing. Providing wrong value for k can result in leaking your private key!\n        :type k: int\n        \n        :return Signature: \n        \"\"\"\n        if isinstance(txid, bytes):\n            txid = txid.hex()\n        if len(txid) > 64:\n            txid = double_sha256(bytes.fromhex(txid), as_hex=True)\n        if not isinstance(private, (Key, HDKey)):\n            private = HDKey(private)\n        pub_key = private.public()\n        secret = private.secret\n\n        if not k:\n            if use_rfc6979 and USE_FASTECDSA:\n                rfc6979 = RFC6979(txid, secret, secp256k1_n, hashlib.sha256)\n                k = rfc6979.gen_nonce()\n            else:\n                global rfc6979_warning_given\n                if not USE_FASTECDSA and not rfc6979_warning_given:\n                    _logger.warning(\"RFC6979 only supported when fastecdsa library is used\")\n                    rfc6979_warning_given = True\n                k = random.SystemRandom().randint(1, secp256k1_n - 1)\n\n        if USE_FASTECDSA:\n            r, s = _ecdsa.sign(\n                txid,\n                str(secret),\n                str(k),\n                str(secp256k1_p),\n                str(secp256k1_a),\n                str(secp256k1_b),\n                str(secp256k1_n),\n                str(secp256k1_Gx),\n                str(secp256k1_Gy)\n            )\n            if int(s) > secp256k1_n / 2:\n                s = secp256k1_n - int(s)\n            return Signature(r, s, txid, secret, public_key=pub_key, k=k)\n        else:\n            sk = ecdsa.SigningKey.from_string(private.private_byte, curve=ecdsa.SECP256k1)\n            txid_bytes = to_bytes(txid)\n            sig_der = sk.sign_digest(txid_bytes, sigencode=ecdsa.util.sigencode_der, k=k)\n            signature = convert_der_sig(sig_der)\n            r = int(signature[:64], 16)\n            s = int(signature[64:], 16)\n            if s > secp256k1_n / 2:\n                s = secp256k1_n - s\n            return Signature(r, s, txid, secret, public_key=pub_key, k=k)",
  "def __init__(self, r, s, txid=None, secret=None, signature=None, der_signature=None, public_key=None, k=None,\n                 hash_type=SIGHASH_ALL):\n        \"\"\"\n        Initialize Signature object with provided r and r value\n\n        >>> r = 32979225540043540145671192266052053680452913207619328973512110841045982813493\n        >>> s = 12990793585889366641563976043319195006380846016310271470330687369836458989268\n        >>> sig = Signature(r, s)\n        >>> sig.hex()\n        '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        \n        :param r: r value of signature\n        :type r: int\n        :param s: s value of signature\n        :type s: int\n        :param txid: Transaction hash z to sign if known\n        :type txid: bytes, hexstring\n        :param secret: Private key secret number\n        :type secret: int\n        :param signature: r and s value of signature as string\n        :type signature: str, bytes\n        :param der_signature: DER encoded signature\n        :type der_signature: str, bytes\n        :param public_key: Provide public key P if known\n        :type public_key: HDKey, Key, str, hexstring, bytes\n        :param k: k value used for signature\n        :type k: int\n        \"\"\"\n\n        self.r = int(r)\n        self.s = int(s)\n        self.x = None\n        self.y = None\n        if self.r < 1 or self.r >= secp256k1_n:\n            raise BKeyError('Invalid Signature: r is not a positive integer smaller than the curve order')\n        elif self.s < 1 or self.s >= secp256k1_n:\n            raise BKeyError('Invalid Signature: s is not a positive integer smaller than the curve order')\n        self._txid = None\n        self.txid = txid\n        self.secret = None if not secret else int(secret)\n        if isinstance(signature, bytes):\n            self._signature = signature\n            signature = signature.hex()\n        else:\n            self._signature = to_bytes(signature)\n        if signature and len(signature) != 128:\n            raise BKeyError('Invalid Signature: length must be 64 bytes')\n        self._public_key = None\n        self.public_key = public_key\n        self.k = k\n        self.hash_type = hash_type\n        self.hash_type_byte = self.hash_type.to_bytes(1, 'big')\n        self.der_signature = der_signature\n        if not der_signature:\n            self.der_signature = der_encode_sig(self.r, self.s)\n\n        self._der_encoded = to_bytes(der_signature) + self.hash_type_byte",
  "def __repr__(self):\n        der_sig = '' if not self._der_encoded else self._der_encoded.hex()\n        return \"<Signature(r=%d, s=%d, signature=%s, der_signature=%s)>\" % \\\n               (self.r, self.s, self.hex(), der_sig)",
  "def __str__(self):\n        return self.as_der_encoded(as_hex=True)",
  "def __bytes__(self):\n        return self.as_der_encoded()",
  "def __add__(self, other):\n        return self.as_der_encoded() + other",
  "def __radd__(self, other):\n        return other + self.as_der_encoded()",
  "def __len__(self):\n        return len(self.as_der_encoded())",
  "def txid(self):\n        return self._txid",
  "def txid(self, value):\n        if value is not None:\n            self._txid = value\n            if isinstance(value, bytes):\n                self._txid = value.hex()",
  "def public_key(self):\n        \"\"\"\n        Return public key as HDKey object\n        \n        :return HDKey: \n        \"\"\"\n        return self._public_key",
  "def public_key(self, value):\n        if value is None:\n            return\n        if isinstance(value, bytes):\n            value = HDKey(value)\n        if value.is_private:\n            value = value.public()\n        self.x, self.y = value.public_point()\n\n        if USE_FASTECDSA:\n            if not fastecdsa_secp256k1.is_point_on_curve((self.x, self.y)):\n                raise BKeyError('Invalid public key, point is not on secp256k1 curve')\n        self._public_key = value",
  "def hex(self):\n        \"\"\"\n        Signature r and s value as single hexadecimal string\n\n        :return hexstring:\n        \"\"\"\n        return self.bytes().hex()",
  "def __index__(self):\n        return self.bytes()",
  "def bytes(self):\n        \"\"\"\n        Signature r and s value as single bytes string\n\n        :return bytes:\n        \"\"\"\n\n        if not self._signature:\n            self._signature = self.r.to_bytes(32, 'big') + self.s.to_bytes(32, 'big')\n        return self._signature",
  "def as_der_encoded(self, as_hex=False, include_hash_type=True):\n        \"\"\"\n        Get DER encoded signature\n\n        :param as_hex: Output as hexstring\n        :type as_hex: bool\n        :param include_hash_type: Include hash_type byte at end of signatures as used in raw scripts. Default is True\n        :type include_hash_type: bool\n\n        :return bytes: \n        \"\"\"\n        if not self._der_encoded or len(self._der_encoded) < 2:\n            self._der_encoded = der_encode_sig(self.r, self.s) + self.hash_type_byte\n\n        if include_hash_type:\n            return self._der_encoded.hex() if as_hex else self._der_encoded\n        else:\n            return der_encode_sig(self.r, self.s).hex() if as_hex else der_encode_sig(self.r, self.s)",
  "def verify(self, txid=None, public_key=None):\n        \"\"\"\n        Verify this signature. Provide txid or public_key if not already known\n\n        >>> k = 'b2da575054fb5daba0efde613b0b8e37159b8110e4be50f73cbe6479f6038f5b'\n        >>> pub_key = HDKey(k).public()\n        >>> txid = '0d12fdc4aac9eaaab9730999e0ce84c3bd5bb38dfd1f4c90c613ee177987429c'\n        >>> sig = '48e994862e2cdb372149bad9d9894cf3a5562b4565035943efe0acc502769d351cb88752b5fe8d70d85f3541046df617f8459e991d06a7c0db13b5d4531cd6d4'\n        >>> sig = Signature.parse_hex(sig)\n        >>> sig.verify(txid, pub_key)\n        True\n\n        :param txid: Transaction hash\n        :type txid: bytes, hexstring\n        :param public_key: Public key P\n        :type public_key: HDKey, Key, str, hexstring, bytes\n                \n        :return bool: \n        \"\"\"\n        if txid is not None:\n            self.txid = to_hexstring(txid)\n        if public_key is not None:\n            self.public_key = public_key\n\n        if not self.txid or not self.public_key:\n            raise BKeyError(\"Please provide txid and public_key to verify signature\")\n\n        if USE_FASTECDSA:\n            return _ecdsa.verify(\n                str(self.r),\n                str(self.s),\n                self.txid,\n                str(self.x),\n                str(self.y),\n                str(secp256k1_p),\n                str(secp256k1_a),\n                str(secp256k1_b),\n                str(secp256k1_n),\n                str(secp256k1_Gx),\n                str(secp256k1_Gy)\n            )\n        else:\n            transaction_to_sign = to_bytes(self.txid)\n            signature = self.bytes()\n            if len(transaction_to_sign) != 32:\n                transaction_to_sign = double_sha256(transaction_to_sign)\n            ver_key = ecdsa.VerifyingKey.from_string(self.public_key.public_uncompressed_byte[1:],\n                                                     curve=ecdsa.SECP256k1)\n            try:\n                if len(signature) > 64 and signature.startswith(b'\\x30'):\n                    try:\n                        signature = convert_der_sig(signature[:-1], as_hex=False)\n                    except Exception:\n                        pass\n                ver_key.verify_digest(signature, transaction_to_sign)\n            except ecdsa.keys.BadSignatureError:\n                return False\n            except ecdsa.keys.BadDigestError as e:\n                _logger.info(\"Bad Digest %s (error %s)\" % (signature.hex(), e))\n                return False\n            return True",
  "class TransactionError(Exception):\n    \"\"\"\n    Handle Transaction class Exceptions\n    \"\"\"\n\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "def transaction_deserialize(rawtx, network=DEFAULT_NETWORK, check_size=True):  # pragma: no cover\n    \"\"\"\n    Deserialize a raw transaction\n    \n    Returns a dictionary with list of input and output objects, locktime and version.\n    \n    Will raise an error if wrong number of inputs are found or if there are no output found.\n    \n    :param rawtx: Raw transaction as hexadecimal string or bytes\n    :type rawtx: str, bytes\n    :param network: Network code, i.e. 'bitcoin', 'testnet', 'litecoin', etc. Leave emtpy for default network\n    :type network: str, Network\n    :param check_size: Check if not bytes are left when parsing is finished. Disable when parsing list of transactions, such as the transactions in a raw block. Default is True\n    :type check_size: bool\n\n    :return Transaction:\n    \"\"\"\n\n    rawtx = to_bytes(rawtx)\n    coinbase = False\n    flag = None\n    witness_type = 'legacy'\n\n    version = rawtx[0:4][::-1]\n    cursor = 4\n    if rawtx[4:5] == b'\\0':\n        flag = rawtx[5:6]\n        if flag == b'\\1':\n            witness_type = 'segwit'\n        cursor += 2\n    n_inputs, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n    cursor += size\n    inputs = []\n    if not isinstance(network, Network):\n        network = Network(network)\n    for n in range(0, n_inputs):\n        inp_hash = rawtx[cursor:cursor + 32][::-1]\n        if not len(inp_hash):\n            raise TransactionError(\"Input transaction hash not found. Probably malformed raw transaction\")\n        if inp_hash == 32 * b'\\0':\n            coinbase = True\n        output_n = rawtx[cursor + 32:cursor + 36][::-1]\n        cursor += 36\n        unlocking_script_size, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n        cursor += size\n        unlocking_script = rawtx[cursor:cursor + unlocking_script_size]\n        inp_type = 'legacy'\n        if witness_type == 'segwit' and not unlocking_script_size:\n            inp_type = 'segwit'\n        cursor += unlocking_script_size\n        sequence_number = rawtx[cursor:cursor + 4]\n        cursor += 4\n        inputs.append(Input(prev_txid=inp_hash, output_n=output_n, unlocking_script=unlocking_script,\n                            witness_type=inp_type, sequence=sequence_number, index_n=n, network=network))\n    if len(inputs) != n_inputs:\n        raise TransactionError(\"Error parsing inputs. Number of tx specified %d but %d found\" % (n_inputs, len(inputs)))\n\n    outputs = []\n    n_outputs, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n    cursor += size\n    output_total = 0\n    for n in range(0, n_outputs):\n        value = int.from_bytes(rawtx[cursor:cursor + 8][::-1], 'big')\n        cursor += 8\n        lock_script_size, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n        cursor += size\n        lock_script = rawtx[cursor:cursor + lock_script_size]\n        cursor += lock_script_size\n        outputs.append(Output(value=value, lock_script=lock_script, network=network, output_n=n))\n        output_total += value\n    if not outputs:\n        raise TransactionError(\"Error no outputs found in this transaction\")\n\n    if witness_type == 'segwit':\n        for n in range(0, len(inputs)):\n            n_items, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n            cursor += size\n            witnesses = []\n            for m in range(0, n_items):\n                witness = b'\\0'\n                item_size, size = varbyteint_to_int(rawtx[cursor:cursor + 9])\n                if item_size:\n                    witness = rawtx[cursor + size:cursor + item_size + size]\n                cursor += item_size + size\n                witnesses.append(witness)\n            if witnesses and not coinbase:\n                script_type = inputs[n].script_type\n                witness_script_type = 'sig_pubkey'\n                signatures = []\n                keys = []\n                sigs_required = 1\n                public_hash = b''\n                for witness in witnesses:\n                    if witness == b'\\0':\n                        continue\n                    if 69 <= len(witness) <= 74 and witness[0:1] == b'\\x30':  # witness is DER encoded signature\n                        signatures.append(witness)\n                    elif len(witness) == 33 and len(signatures) == 1:  # key from sig_pk\n                        keys.append(witness)\n                    else:\n                        rsds = script_deserialize(witness, script_types=['multisig'])\n                        if not rsds['script_type'] == 'multisig':\n                            _logger.warning(\"Could not parse witnesses in transaction. Multisig redeemscript expected\")\n                            witness_script_type = 'unknown'\n                            script_type = 'unknown'\n                        else:\n                            keys = rsds['signatures']\n                            sigs_required = rsds['number_of_sigs_m']\n                            witness_script_type = 'p2sh'\n                            script_type = 'p2sh_multisig'\n\n                inp_witness_type = inputs[n].witness_type\n                usd = script_deserialize(inputs[n].unlocking_script, locking_script=True)\n\n                if usd['script_type'] == \"p2wpkh\" and witness_script_type == 'sig_pubkey':\n                    inp_witness_type = 'p2sh-segwit'\n                    script_type = 'p2sh_p2wpkh'\n                elif usd['script_type'] == \"p2wsh\" and witness_script_type == 'p2sh':\n                    inp_witness_type = 'p2sh-segwit'\n                    script_type = 'p2sh_p2wsh'\n                inputs[n] = Input(prev_txid=inputs[n].prev_txid, output_n=inputs[n].output_n, keys=keys,\n                                  unlocking_script_unsigned=inputs[n].unlocking_script_unsigned,\n                                  unlocking_script=inputs[n].unlocking_script, sigs_required=sigs_required,\n                                  signatures=signatures, witness_type=inp_witness_type, script_type=script_type,\n                                  sequence=inputs[n].sequence, index_n=inputs[n].index_n, public_hash=public_hash,\n                                  network=inputs[n].network, witnesses=witnesses)\n    if len(rawtx[cursor:]) != 4 and check_size:\n        raise TransactionError(\"Error when deserializing raw transaction, bytes left for locktime must be 4 not %d\" %\n                               len(rawtx[cursor:]))\n    locktime = int.from_bytes(rawtx[cursor:cursor + 4][::-1], 'big')\n\n    return Transaction(inputs, outputs, locktime, version, network, size=cursor + 4, output_total=output_total,\n                       coinbase=coinbase, flag=flag, witness_type=witness_type, rawtx=rawtx)",
  "def script_deserialize(script, script_types=None, locking_script=None, size_bytes_check=True):  # pragma: no cover\n    \"\"\"\n    Deserialize a script: determine type, number of signatures and script data.\n    \n    :param script: Raw script\n    :type script: str, bytes\n    :param script_types: Limit script type determination to this list. Leave to default None to search in all script types.\n    :type script_types: list\n    :param locking_script: Only deserialize locking scripts. Specify False to only deserialize for unlocking scripts. Default is None for both\n    :type locking_script: bool\n    :param size_bytes_check: Check if script or signature starts with size bytes and remove size bytes before parsing. Default is True\n    :type size_bytes_check: bool\n\n    :return list: With this items: [script_type, data, number_of_sigs_n, number_of_sigs_m] \n    \"\"\"\n\n    def _parse_data(scr, max_items=None, redeemscript_expected=False, item_length=0):\n        # scr = to_bytes(scr)\n        items = []\n        total_length = 0\n        if 69 <= len(scr) <= 74 and scr[:1] == b'\\x30':\n            return [scr], len(scr)\n        while len(scr) and (max_items is None or max_items > len(items)):\n            itemlen, size = varbyteint_to_int(scr[0:9])\n            if item_length and itemlen != item_length:\n                break\n            if not item_length and itemlen not in [20, 33, 65, 70, 71, 72, 73]:\n                break\n            if redeemscript_expected and len(scr[itemlen + 1:]) < 20:\n                break\n            items.append(scr[1:itemlen + 1])\n            total_length += itemlen + size\n            scr = scr[itemlen + 1:]\n        return items, total_length\n\n    def _get_empty_data():\n        return {'script_type': '', 'keys': [], 'signatures': [], 'hashes': [], 'redeemscript': b'',\n                'number_of_sigs_n': 1, 'number_of_sigs_m': 1, 'locktime_cltv': None, 'locktime_csv': None, 'result': ''}\n\n    def _parse_script(script):\n        found = False\n        cur = 0\n        data = _get_empty_data()\n        for script_type in script_types:\n            cur = 0\n            try:\n                ost = SCRIPT_TYPES_UNLOCKING[script_type]\n            except KeyError:\n                ost = SCRIPT_TYPES_LOCKING[script_type]\n            data = _get_empty_data()\n            data['script_type'] = script_type\n            found = True\n            for ch in ost:\n                if cur >= len(script):\n                    found = False\n                    break\n                cur_char = script[cur]\n                if ch[:4] == 'hash':\n                    hash_length = 0\n                    if len(ch) > 5:\n                        hash_length = int(ch.split(\"-\")[1])\n                    s, total_length = _parse_data(script[cur:], 1, item_length=hash_length)\n                    if not s:\n                        found = False\n                        break\n                    data['hashes'] += s\n                    cur += total_length\n                elif ch == 'signature':\n                    signature_length = 0\n                    s, total_length = _parse_data(script[cur:], 1, item_length=signature_length)\n                    if not s:\n                        found = False\n                        break\n                    data['signatures'] += s\n                    cur += total_length\n                elif ch == 'public_key':\n                    pk_size, size = varbyteint_to_int(script[cur:cur + 9])\n                    key = script[cur + size:cur + size + pk_size]\n                    if not key:\n                        found = False\n                        break\n                    data['keys'].append(key)\n                    cur += size + pk_size\n                elif ch == 'OP_RETURN':\n                    if cur_char == op.op_return and cur == 0:\n                        data.update({'op_return': script[cur + 1:]})\n                        cur = len(script)\n                        found = True\n                        break\n                    else:\n                        found = False\n                        break\n                elif ch == 'multisig':  # one or more signatures\n                    redeemscript_expected = False\n                    if 'redeemscript' in ost:\n                        redeemscript_expected = True\n                    s, total_length = _parse_data(script[cur:], redeemscript_expected=redeemscript_expected)\n                    if not s:\n                        found = False\n                        break\n                    data['signatures'] += s\n                    cur += total_length\n                elif ch == 'redeemscript':\n                    size_byte = 0\n                    if script[cur:cur + 1] == b'\\x4c':\n                        size_byte = 1\n                    elif script[cur:cur + 1] == b'\\x4d':\n                        size_byte = 2\n                    elif script[cur:cur + 1] == b'\\x4e':\n                        size_byte = 3\n                    data['redeemscript'] = script[cur + 1 + size_byte:]\n                    data2 = script_deserialize(data['redeemscript'], locking_script=True)\n                    if 'signatures' not in data2 or not data2['signatures']:\n                        found = False\n                        break\n                    data['keys'] = data2['signatures']\n                    data['number_of_sigs_m'] = data2['number_of_sigs_m']\n                    data['number_of_sigs_n'] = data2['number_of_sigs_n']\n                    cur = len(script)\n                elif ch == 'push_size':\n                    push_size, size = varbyteint_to_int(script[cur:cur + 9])\n                    found = bool(len(script[cur:]) - size == push_size)\n                    if not found:\n                        break\n                elif ch == 'op_m':\n                    if cur_char in OP_N_CODES:\n                        data['number_of_sigs_m'] = cur_char - op.op_1 + 1\n                    else:\n                        found = False\n                        break\n                    cur += 1\n                elif ch == 'op_n':\n                    if cur_char in OP_N_CODES:\n                        data['number_of_sigs_n'] = cur_char - op.op_1 + 1\n                    else:\n                        found = False\n                        break\n                    if data['number_of_sigs_m'] > data['number_of_sigs_n']:\n                        raise TransactionError(\"Number of signatures to sign (%s) is higher then actual \"\n                                               \"amount of signatures (%s)\" %\n                                               (data['number_of_sigs_m'], data['number_of_sigs_n']))\n                    if len(data['signatures']) > int(data['number_of_sigs_n']):\n                        raise TransactionError(\"%d signatures found, but %s sigs expected\" %\n                                               (len(data['signatures']), data['number_of_sigs_n']))\n                    cur += 1\n                elif ch == 'SIGHASH_ALL':\n                    pass\n                    # if cur_char != SIGHASH_ALL:\n                    #     found = False\n                    #     break\n                elif ch == 'locktime_cltv':\n                    if len(script) < 4:\n                        found = False\n                        break\n                    data['locktime_cltv'] = int.from_bytes(script[cur:cur + 4], 'little')\n                    cur += 4\n                elif ch == 'locktime_csv':\n                    if len(script) < 4:\n                        found = False\n                        break\n                    data['locktime_csv'] = int.from_bytes(script[cur:cur + 4], 'little')\n                    cur += 4\n                else:\n                    try:\n                        if opcodenames.get(cur_char) == ch:\n                            cur += 1\n                        else:\n                            found = False\n                            data = _get_empty_data()\n                            break\n                    except IndexError:\n                        raise TransactionError(\"Opcode %s not found [type %s]\" % (ch, script_type))\n            if found and not len(script[cur:]):  # Found is True and no remaining script to parse\n                break\n\n        if found and not len(script[cur:]):\n            return data, script[cur:]\n        data = _get_empty_data()\n        data['result'] = 'Script not recognised'\n        return data, ''\n\n    data = _get_empty_data()\n    script = to_bytes(script)\n    if not script:\n        data.update({'result': 'Empty script'})\n        return data\n\n    # Check if script starts with size byte\n    if size_bytes_check:\n        script_size, size = varbyteint_to_int(script[0:9])\n        if len(script[1:]) == script_size:\n            data = script_deserialize(script[1:], script_types, locking_script, size_bytes_check=False)\n            if 'result' in data and data['result'][:22] not in \\\n                    ['Script not recognised', 'Empty script', 'Could not parse script']:\n                return data\n\n    if script_types is None:\n        if locking_script is None:\n            script_types = dict(SCRIPT_TYPES_UNLOCKING, **SCRIPT_TYPES_LOCKING)\n        elif locking_script:\n            script_types = SCRIPT_TYPES_LOCKING\n        else:\n            script_types = SCRIPT_TYPES_UNLOCKING\n    elif not isinstance(script_types, list):\n        script_types = [script_types]\n\n    locktime_cltv = 0\n    locktime_csv = 0\n    while len(script):\n        begin_script = script\n        data, script = _parse_script(script)\n        if begin_script == script:\n            break\n        if script and data['script_type'] == 'locktime_cltv':\n            locktime_cltv = data['locktime_cltv']\n        if script and data['script_type'] == 'locktime_csv':\n            locktime_csv = data['locktime_csv']\n    if data and data['result'] != 'Script not recognised':\n        data['locktime_cltv'] = locktime_cltv\n        data['locktime_csv'] = locktime_csv\n        return data\n\n    wrn_msg = \"Could not parse script, unrecognized script\"\n    # _logger.debug(wrn_msg)\n    data = _get_empty_data()\n    data['result'] = wrn_msg\n    return data",
  "def script_to_string(script, name_data=False):  # pragma: no cover\n    \"\"\"\n    Convert script to human-readable string format with OP-codes, signatures, keys, etc\n    \n    :param script: A locking or unlocking script\n    :type script: bytes, str\n    :param name_data: Replace signatures and keys strings with name\n    :type name_data: bool\n\n    :return str: \n    \"\"\"\n\n    # script = to_bytes(script)\n    data = script_deserialize(script)\n    if not data or data['script_type'] == 'empty':\n        return \"\"\n    if name_data:\n        name = 'signature'\n        if data['signatures'] and len(data['signatures'][0]) in [33, 65]:\n            name = 'key'\n        sigs = ' '.join(['%s-%d' % (name, i) for i in range(1, len(data['signatures']) + 1)])\n    else:\n        sigs = ' '.join([i.hex() for i in data['signatures']])\n\n    try:\n        scriptstr = SCRIPT_TYPES_LOCKING[data['script_type']]\n    except KeyError:\n        scriptstr = SCRIPT_TYPES_UNLOCKING[data['script_type']]\n    scriptstr = [sigs if x in ['signature', 'multisig', 'return_data'] else x for x in scriptstr]\n    if 'redeemscript' in data and data['redeemscript']:\n        redeemscript_str = script_to_string(data['redeemscript'], name_data=name_data)\n        scriptstr = [redeemscript_str if x == 'redeemscript' else x for x in scriptstr]\n    scriptstr = [opcodenames[80 + int(data['number_of_sigs_m'])] if x == 'op_m' else x for x in scriptstr]\n    scriptstr = [opcodenames[80 + int(data['number_of_sigs_n'])] if x == 'op_n' else x for x in scriptstr]\n\n    return ' '.join(scriptstr)",
  "def _serialize_multisig_redeemscript(public_key_list, n_required=None):  # pragma: no cover\n    # Serialize m-to-n multisig script. Needs a list of public keys\n    for key in public_key_list:\n        if not isinstance(key, (str, bytes)):\n            raise TransactionError(\"Item %s in public_key_list is not of type string or bytes\")\n    if n_required is None:\n        n_required = len(public_key_list)\n\n    script = int_to_varbyteint(op.op_1 + n_required - 1)\n    for key in public_key_list:\n        script += varstr(key)\n    script += int_to_varbyteint(op.op_1 + len(public_key_list) - 1)\n    script += b'\\xae'  # 'OP_CHECKMULTISIG'\n\n    return script",
  "def serialize_multisig_redeemscript(key_list, n_required=None, compressed=True):  # pragma: no cover\n    \"\"\"\n    Create a multisig redeemscript used in a p2sh.\n\n    Contains the number of signatures, followed by the list of public keys and the OP-code for the number of signatures required.\n\n    :param key_list: List of public keys\n    :type key_list: Key, list\n    :param n_required: Number of required signatures\n    :type n_required: int\n    :param compressed: Use compressed public keys?\n    :type compressed: bool\n\n    :return bytes: A multisig redeemscript\n    \"\"\"\n\n    if not key_list:\n        return b''\n    if not isinstance(key_list, list):\n        raise TransactionError(\"Argument public_key_list must be of type list\")\n    if len(key_list) > 15:\n        raise TransactionError(\"Redeemscripts with more then 15 keys are non-standard and could result in \"\n                               \"locked up funds\")\n    public_key_list = []\n    for k in key_list:\n        if isinstance(k, Key):\n            if compressed:\n                public_key_list.append(k.public_byte)\n            else:\n                public_key_list.append(k.public_uncompressed_byte)\n        elif len(k) == 65 and k[0:1] == b'\\x04' or len(k) == 33 and k[0:1] in [b'\\x02', b'\\x03']:\n            public_key_list.append(k)\n        elif len(k) == 132 and k[0:2] == '04' or len(k) == 66 and k[0:2] in ['02', '03']:\n            public_key_list.append(bytes.fromhex(k))\n        else:\n            kobj = Key(k)\n            if compressed:\n                public_key_list.append(kobj.public_byte)\n            else:\n                public_key_list.append(kobj.public_uncompressed_byte)\n\n    return _serialize_multisig_redeemscript(public_key_list, n_required)",
  "def _p2sh_multisig_unlocking_script(sigs, redeemscript, hash_type=None, as_list=False):  # pragma: no cover\n    usu = b'\\x00'\n    if as_list:\n        usu = [usu]\n    if not isinstance(sigs, list):\n        sigs = [sigs]\n    for sig in sigs:\n        s = sig\n        if hash_type:\n            s += hash_type.to_bytes(1, 'big')\n        if as_list:\n            usu.append(s)\n        else:\n            usu += varstr(s)\n\n    rs_size = b''\n    size_byte = b''\n    if not as_list:\n        rs_size = int_to_varbyteint(len(redeemscript))\n        if len(rs_size) > 1:\n            rs_size = rs_size[1:]\n        if len(redeemscript) >= 76:\n            if len(rs_size) == 1:\n                size_byte = b'\\x4c'\n            elif len(rs_size) == 2:\n                size_byte = b'\\x4d'\n            else:\n                size_byte = b'\\x4e'\n\n    redeemscript_str = size_byte + rs_size + redeemscript\n    if as_list:\n        usu.append(redeemscript_str)\n    else:\n        usu += redeemscript_str\n    return usu",
  "def script_add_locktime_cltv(locktime_cltv, script):  # pragma: no cover\n    lockbytes = bytes([op.op_checklocktimeverify, op.op_drop])\n    if script and len(script) > 6:\n        if script[4:6] == lockbytes:\n            return script\n    return varstr(locktime_cltv.to_bytes(4, 'little')) + lockbytes + script",
  "def script_add_locktime_csv(locktime_csv, script):  # pragma: no cover\n    lockbytes = bytes([op.op_checklocktimeverify, op.op_drop])\n    if script and len(script) > 6:\n        if script[4:6] == lockbytes:\n            return script\n    return varstr(locktime_csv.to_bytes(4, 'little')) + lockbytes + script",
  "def get_unlocking_script_type(locking_script_type, witness_type='legacy', multisig=False):\n    \"\"\"\n    Specify locking script type and get corresponding script type for unlocking script\n\n    >>> get_unlocking_script_type('p2wsh')\n    'p2sh_multisig'\n\n    :param locking_script_type: Locking script type. I.e.: p2pkh, p2sh, p2wpkh, p2wsh\n    :type locking_script_type: str\n    :param witness_type: Type of witness: legacy or segwit. Default is legacy\n    :type witness_type: str\n    :param multisig: Is multisig script or not? Default is False\n    :type multisig: bool\n\n    :return str: Unlocking script type such as sig_pubkey or p2sh_multisig\n    \"\"\"\n\n    if locking_script_type in ['p2pkh', 'p2wpkh']:\n        return 'sig_pubkey'\n    elif locking_script_type == 'p2wsh' or (witness_type == 'legacy' and multisig):\n        return 'p2sh_multisig'\n    elif locking_script_type == 'p2sh':\n        if not multisig:\n            return 'sig_pubkey'\n        else:\n            return 'p2sh_multisig'\n    elif locking_script_type == 'p2pk':\n        return 'signature'\n    else:\n        raise TransactionError(\"Unknown locking script type %s\" % locking_script_type)",
  "def transaction_update_spents(txs, address):\n    \"\"\"\n    Update spent information for list of transactions for a specific address. This method assumes the list of\n    transaction complete and up-to-date.\n\n    This method loops through all the transaction and update all transaction outputs for given address, checks\n    if the output is spent and add the spending transaction ID and index number to the outputs.\n\n    The same list of transactions with updates outputs will be returned\n\n    :param txs: Complete list of transactions for given address\n    :type txs: list of Transaction\n    :param address: Address string\n    :type address: str\n\n    :return list of Transaction:\n    \"\"\"\n    spend_list = {}\n    for t in txs:\n        for inp in t.inputs:\n            if inp.address == address:\n                spend_list.update({(inp.prev_txid.hex(), inp.output_n_int): t})\n    address_inputs = list(spend_list.keys())\n    for t in txs:\n        for to in t.outputs:\n            if to.address != address:\n                continue\n            spent = True if (t.txid, to.output_n) in address_inputs else False\n            txs[txs.index(t)].outputs[to.output_n].spent = spent\n            if spent:\n                spending_tx = spend_list[(t.txid, to.output_n)]\n                spending_index_n = \\\n                    [inp for inp in txs[txs.index(spending_tx)].inputs\n                     if inp.prev_txid.hex() == t.txid and inp.output_n_int == to.output_n][0].index_n\n                txs[txs.index(t)].outputs[to.output_n].spending_txid = spending_tx.txid\n                txs[txs.index(t)].outputs[to.output_n].spending_index_n = spending_index_n\n    return txs",
  "class Input(object):\n    \"\"\"\n    Transaction Input class, used by Transaction class\n    \n    An Input contains a reference to an UTXO or Unspent Transaction Output (prev_txid + output_n).\n    To spend the UTXO an unlocking script can be included to prove ownership.\n    \n    Inputs are verified by the Transaction class.\n    \"\"\"\n\n    def __init__(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',\n                 unlocking_script_unsigned=None, script=None, script_type=None, address='',\n                 sequence=0xffffffff, compressed=None, sigs_required=None, sort=False, index_n=0,\n                 value=0, double_spend=False, locktime_cltv=None, locktime_csv=None, key_path='', witness_type=None,\n                 witnesses=None, encoding=None, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new transaction input\n        \n        :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.\n        :type prev_txid: bytes, str\n        :param output_n: Output number in previous transaction.\n        :type output_n: bytes, int\n        :param keys: A list of Key objects or public / private key string in various formats. If no list is provided but a bytes or string variable, a list with one item will be created. Optional\n        :type keys: list (bytes, str, Key)\n        :param signatures: Specify optional signatures\n        :type signatures: list (bytes, str, Signature)\n        :param public_hash: Public key hash or script hash. Specify if key is not available\n        :type public_hash: bytes\n        :param unlocking_script: Unlocking script (scriptSig) to prove ownership. Optional\n        :type unlocking_script: bytes, hexstring\n        :param unlocking_script_unsigned: Unlocking script for signing transaction\n        :type unlocking_script_unsigned: bytes, hexstring\n        :param script_type: Type of unlocking script used, i.e. p2pkh or p2sh_multisig. Default is p2pkh\n        :type script_type: str\n        :param address: Address string or object for input\n        :type address: str, Address\n        :param sequence: Sequence part of input, you normally do not have to touch this\n        :type sequence: bytes, int\n        :param compressed: Use compressed or uncompressed public keys. Default is compressed\n        :type compressed: bool\n        :param sigs_required: Number of signatures required for a p2sh_multisig unlocking script\n        :type sigs_required: int\n        :param sort: Sort public keys according to BIP0045 standard. Default is False to avoid unexpected change of key order.\n        :type sort: boolean\n        :param index_n: Index of input in transaction. Used by Transaction class.\n        :type index_n: int\n        :param value: Value of input in the smallest denominator integers (Satoshi's) or as Value object or string\n        :type value: int, Value, str\n        :param double_spend: Is this input also spend in another transaction\n        :type double_spend: bool\n        :param locktime_cltv: Check Lock Time Verify value. Script level absolute time lock for this input\n        :type locktime_cltv: int\n        :param locktime_csv: Check Sequence Verify value\n        :type locktime_csv: int\n        :param key_path: Key path of input key as BIP32 string or list\n        :type key_path: str, list\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param witnesses: List of witnesses for inputs, used for segwit transactions for instance. Argument can be list of bytes or string or a single bytes string with concatenated witnesses as found in a raw transaction.\n        :type witnesses: list of bytes, list of str, bytes\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty for default\n        :type encoding: str\n        :param strict: Raise exception when input is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        \"\"\"\n\n        self.prev_txid = to_bytes(prev_txid)\n        self.output_n = output_n\n        if isinstance(output_n, int):\n            self.output_n_int = output_n\n            self.output_n = output_n.to_bytes(4, 'big')\n        else:\n            self.output_n_int = int.from_bytes(output_n, 'big')\n            self.output_n = output_n\n        self.unlocking_script = b'' if unlocking_script is None else to_bytes(unlocking_script)\n        self.unlocking_script_unsigned = b'' if unlocking_script_unsigned is None \\\n            else to_bytes(unlocking_script_unsigned)\n        self.script = None\n        self.hash_type = SIGHASH_ALL\n        if isinstance(sequence, numbers.Number):\n            self.sequence = sequence\n        else:\n            self.sequence = int.from_bytes(sequence, 'little')\n        self.compressed = compressed\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.index_n = index_n\n        self.value = value_to_satoshi(value, network=network)\n        if not keys:\n            keys = []\n        self.keys = []\n        if not isinstance(keys, list):\n            keys = [keys]\n        self.public_hash = public_hash\n        if not signatures:\n            signatures = []\n        if not isinstance(signatures, list):\n            signatures = [signatures]\n        self.sort = sort\n        if isinstance(address, Address):\n            self.address = address.address\n            self.encoding = address.encoding\n            self.network = address.network\n        else:\n            self.address = address\n        self.signatures = []\n        self.redeemscript = b''\n        self.script_type = script_type\n        if self.prev_txid == b'\\0' * 32:\n            self.script_type = 'coinbase'\n        self.double_spend = double_spend\n        self.locktime_cltv = locktime_cltv\n        self.locktime_csv = locktime_csv\n        self.witness_type = witness_type\n        if encoding is None:\n            self.encoding = 'base58'\n            if self.witness_type == 'segwit':\n                self.encoding = 'bech32'\n        else:\n            self.encoding = encoding\n        self.valid = None\n        self.key_path = key_path\n\n        self.witnesses = []\n        if isinstance(witnesses, bytes):\n            n_items, cursor = varbyteint_to_int(witnesses[0:9])\n            for m in range(0, n_items):\n                witness = b'\\0'\n                item_size, size = varbyteint_to_int(witnesses[cursor:cursor + 9])\n                if item_size:\n                    witness = witnesses[cursor + size:cursor + item_size + size]\n                cursor += item_size + size\n                self.witnesses.append(witness)\n        elif witnesses:\n            self.witnesses = [bytes.fromhex(w) if isinstance(w, str) else w for w in witnesses]\n        self.script_code = b''\n        self.script = script\n\n        # If unlocking script is specified extract keys, signatures, type from script\n        if self.unlocking_script and self.script_type != 'coinbase' and not (signatures and keys) and not script:\n            self.script = Script.parse_bytes(self.unlocking_script, strict=strict)\n            self.keys = self.script.keys\n            self.signatures = self.script.signatures\n            if len(self.signatures):\n                self.hash_type = self.signatures[0].hash_type\n            sigs_required = self.script.sigs_required\n            self.redeemscript = self.script.redeemscript if self.script.redeemscript else self.redeemscript\n            if len(self.script.script_types) == 1 and not self.script_type:\n                self.script_type = self.script.script_types[0]\n            elif self.script.script_types == ['signature_multisig', 'multisig']:\n                self.script_type = 'p2sh_multisig'\n            # TODO: Check if this if is necessary\n            if 'p2wpkh' in self.script.script_types:\n                self.script_type = 'p2sh_p2wpkh'\n                self.witness_type = 'p2sh-segwit'\n            elif 'p2wsh' in self.script.script_types:\n                self.script_type = 'p2sh_p2wsh'\n                self.witness_type = 'p2sh-segwit'\n        if self.unlocking_script_unsigned and not self.signatures:\n            ls = Script.parse_bytes(self.unlocking_script_unsigned, strict=strict)\n            self.public_hash = self.public_hash if not ls.public_hash else ls.public_hash\n            if ls.script_types[0] in ['p2wpkh', 'p2wsh']:\n                self.witness_type = 'segwit'\n        self.sigs_required = sigs_required if sigs_required else 1\n\n        if self.script_type is None and self.witness_type is None and self.witnesses:\n            self.witness_type = 'segwit'\n        if self.witness_type is None or self.witness_type == 'legacy':\n            # if self.script_type in ['p2wpkh', 'p2wsh', 'p2sh_p2wpkh', 'p2sh_p2wsh']:\n            if self.script_type in ['p2wpkh', 'p2wsh']:\n                self.witness_type = 'segwit'\n            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:\n                self.witness_type = 'p2sh-segwit'\n            else:\n                self.witness_type = 'legacy'\n        elif self.witness_type == 'segwit' and self.script_type == 'sig_pubkey' and encoding is None:\n            self.encoding = 'bech32'\n        if not self.script_type:\n            self.script_type = 'sig_pubkey'\n\n        for key in keys:\n            if not isinstance(key, Key):\n                kobj = Key(key, network=network, strict=strict)\n            else:\n                kobj = key\n            if kobj not in self.keys:\n                # if self.compressed is not None and kobj.compressed != self.compressed:\n                #     _logger.warning(\"Key compressed is %s but Input class compressed argument is %s \" %\n                #                     (kobj.compressed, self.compressed))\n                self.compressed = kobj.compressed\n                self.keys.append(kobj)\n        if self.compressed is None:\n            self.compressed = True\n        if self.sort:\n            self.keys.sort(key=lambda k: k.public_byte)\n        self.strict = strict\n\n        for sig in signatures:\n            if not isinstance(sig, Signature):\n                try:\n                    sig = Signature.parse(sig)\n                except Exception as e:\n                    _logger.error(\"Could not parse signature %s in Input. Error: %s\" % (to_hexstring(sig), e))\n                    continue\n            if sig.as_der_encoded() not in [x.as_der_encoded() for x in self.signatures]:\n                self.signatures.append(sig)\n                if sig.hash_type:\n                    self.hash_type = sig.hash_type\n\n        # fixme: p2wpkh == p2sh_p2wpkh\n        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh'] and self.witnesses and not self.signatures and \\\n                self.script_type in ['sig_pubkey', 'p2sh_p2wpkh'] and len(self.witnesses) == 2 and \\\n                b'\\0' not in self.witnesses:\n            self.signatures = [Signature.parse_bytes(self.witnesses[0])]\n            self.hash_type = self.signatures[0].hash_type\n            self.keys = [Key(self.witnesses[1], network=self.network)]\n\n        self.update_scripts(hash_type=self.hash_type)\n\n    @classmethod\n    def parse(cls, raw, witness_type='segwit', index_n=0, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse raw BytesIO string and return Input object\n\n        :param raw: Input\n        :type raw: BytesIO\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Derived from script if not specified.\n        :type witness_type: str\n        :param index_n: Index number of input\n        :type index_n: int\n        :param strict: Raise exception when input is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n\n        :return Input:\n        \"\"\"\n        prev_hash = raw.read(32)[::-1]\n        if len(prev_hash) != 32:\n            raise TransactionError(\"Input transaction hash not found. Probably malformed raw transaction\")\n        output_n = raw.read(4)[::-1]\n        unlocking_script_size = read_varbyteint(raw)\n        unlocking_script = raw.read(unlocking_script_size)\n        # TODO - handle non-standard input script b'\\1\\0',\n        #  see tx 38cf5779d1c5ca32b79cd5052b54e824102e878f041607d3b962038f5a8cf1ed\n        # if unlocking_script_size == 1 and unlocking_script == b'\\0':\n\n        inp_type = 'legacy'\n        if witness_type == 'segwit' and not unlocking_script_size:\n            inp_type = 'segwit'\n        sequence_number = raw.read(4)\n\n        return Input(prev_txid=prev_hash, output_n=output_n, unlocking_script=unlocking_script,\n                     witness_type=inp_type, sequence=sequence_number, index_n=index_n, strict=strict, network=network)\n\n    def update_scripts(self, hash_type=SIGHASH_ALL):\n        \"\"\"\n        Method to update Input scripts.\n\n        Creates or updates unlocking script, witness script for segwit inputs, multisig redeemscripts and\n        locktime scripts. This method is called when initializing an Input class or when signing an input.\n\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n\n        :return bool: Always returns True when method is completed\n        \"\"\"\n\n        addr_data = b''\n        unlock_script = b''\n        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh']:  # fixme: p2wpkh == p2sh_p2wpkh\n            if not self.public_hash and self.keys:\n                self.public_hash = self.keys[0].hash160\n            if not self.keys and not self.public_hash:\n                return\n            self.script_code = b'\\x76\\xa9\\x14' + self.public_hash + b'\\x88\\xac'\n            self.unlocking_script_unsigned = self.script_code\n            addr_data = self.public_hash\n            if self.signatures and self.keys:\n                self.witnesses = [self.signatures[0].as_der_encoded() if hash_type else b'', self.keys[0].public_byte]\n                unlock_script = b''.join([bytes(varstr(w)) for w in self.witnesses])\n            if not self.unlocking_script or self.strict:\n                if self.witness_type == 'p2sh-segwit':\n                    self.unlocking_script = varstr(b'\\0' + varstr(self.public_hash))\n                elif self.witness_type == 'segwit':\n                    self.unlocking_script = b''\n                elif unlock_script != b'':\n                    self.unlocking_script = unlock_script\n        elif self.script_type in ['p2sh_multisig', 'p2sh_p2wsh', 'p2wsh']:  # fixme: p2sh_p2wsh == p2wsh\n            if not self.redeemscript and self.keys:\n                self.redeemscript = Script(script_types=['multisig'], keys=self.keys,\n                                           sigs_required=self.sigs_required).serialize()\n            if self.redeemscript:\n                if self.witness_type == 'segwit' or self.witness_type == 'p2sh-segwit':\n                    self.public_hash = hashlib.sha256(self.redeemscript).digest()\n                else:\n                    self.public_hash = hash160(self.redeemscript)\n            addr_data = self.public_hash\n            self.unlocking_script_unsigned = self.redeemscript\n\n            if self.redeemscript and self.keys:\n                n_tag = self.redeemscript[0:1]\n                if not isinstance(n_tag, int):\n                    n_tag = int.from_bytes(n_tag, 'big')\n                self.sigs_required = n_tag - 80\n                signatures = [s.as_der_encoded() for s in self.signatures[:self.sigs_required]]\n                if b'' in signatures:\n                    raise TransactionError(\"Empty signature found in signature list when signing. \"\n                                           \"Is DER encoded version of signature defined?\")\n                if len(signatures) and len(signatures) >= self.sigs_required:  # and not self.unlocking_script\n                    unlock_script_obj = Script(script_types=['p2sh_multisig'], keys=[k.public_byte for k in self.keys],\n                                               signatures=self.signatures[:self.sigs_required],\n                                               sigs_required=self.sigs_required, redeemscript=self.redeemscript)\n                    if self.witness_type in ['segwit', 'p2sh-segwit']:\n                        unlock_script = unlock_script_obj.serialize_list()\n                    else:\n                        unlock_script = unlock_script_obj.serialize()\n                if self.witness_type == 'segwit':\n                    script_code = b''\n                    for k in self.keys:\n                        script_code += varstr(k.public_byte) + b'\\xad\\xab'\n                    if len(script_code) > 3:\n                        script_code = script_code[:-2] + b'\\xac'\n                    self.script_code = script_code\n                    if signatures:\n                        self.witnesses = unlock_script\n                elif self.witness_type == 'p2sh-segwit':\n                    self.unlocking_script = varstr(b'\\0' + varstr(self.public_hash))\n                    self.script_code = self.unlocking_script\n                    if signatures:\n                        self.witnesses = unlock_script\n                elif unlock_script != b'' and self.strict:\n                    self.unlocking_script = unlock_script\n        elif self.script_type == 'signature':\n            if self.keys:\n                self.script_code = varstr(self.keys[0].public_byte) + b'\\xac'\n                self.unlocking_script_unsigned = self.script_code\n                addr_data = self.keys[0].public_byte\n            if self.signatures and not self.unlocking_script:\n                self.unlocking_script = varstr(self.signatures[0].as_der_encoded())\n        elif self.script_type == 'p2tr':  # segwit_v1\n            self.redeemscript = self.witnesses[0]\n            # FIXME: Address cannot be known without looking at previous transaction\n        elif self.script_type not in ['coinbase', 'unknown'] and self.strict:\n            raise TransactionError(\"Unknown unlocking script type %s for input %d\" % (self.script_type, self.index_n))\n        if addr_data and not self.address:\n            self.address = Address(hashed_data=addr_data, encoding=self.encoding, network=self.network,\n                                   script_type=self.script_type, witness_type=self.witness_type).address\n\n        if self.locktime_cltv:\n            self.unlocking_script_unsigned = script_add_locktime_cltv(self.locktime_cltv,\n                                                                      self.unlocking_script_unsigned)\n            self.unlocking_script = script_add_locktime_cltv(self.locktime_cltv, self.unlocking_script)\n        elif self.locktime_csv:\n            self.unlocking_script_unsigned = script_add_locktime_csv(self.locktime_csv, self.unlocking_script_unsigned)\n            self.unlocking_script = script_add_locktime_csv(self.locktime_csv, self.unlocking_script)\n        return True\n\n    def verify(self, transaction_hash):\n        \"\"\"\n        Verify input with provided transaction hash, check if signatures matches public key.\n\n        Does not check if UTXO is valid or has already been spent\n\n        :param transaction_hash: Double SHA256 Hash of Transaction signature\n        :type transaction_hash: bytes\n\n        :return bool: True if enough signatures provided and if all signatures are valid\n        \"\"\"\n\n        if self.script_type == 'coinbase':\n            self.valid = True\n            return True\n        if not self.signatures:\n            _logger.info(\"No signatures found for transaction input %d\" % self.index_n)\n            return False\n\n        sig_n = 0\n        key_n = 0\n        sigs_verified = 0\n        while sigs_verified < self.sigs_required:\n            if key_n >= len(self.keys):\n                _logger.info(\n                    \"Not enough valid signatures provided for input %d. Found %d signatures but %d needed\" %\n                    (self.index_n, sigs_verified, self.sigs_required))\n                return False\n            if sig_n >= len(self.signatures):\n                _logger.info(\"No valid signatures found\")\n                return False\n            key = self.keys[key_n]\n            sig = self.signatures[sig_n]\n            if verify(transaction_hash, sig, key):\n                sigs_verified += 1\n                sig_n += 1\n            elif sig_n > 0:\n                # try previous signature\n                prev_sig = deepcopy(self.signatures[sig_n - 1])\n                if verify(transaction_hash, prev_sig, key):\n                    sigs_verified += 1\n            key_n += 1\n        self.valid = True\n        return True\n\n    def as_dict(self):\n        \"\"\"\n        Get transaction input information in json format\n        \n        :return dict: Json with output_n, prev_txid, output_n, type, address, public_key, public_hash, unlocking_script and sequence\n        \"\"\"\n\n        pks = []\n        for k in self.keys:\n            pks.append(k.public_hex)\n        if len(self.keys) == 1:\n            pks = pks[0]\n        return {\n            'index_n': self.index_n,\n            'prev_txid': self.prev_txid.hex(),\n            'output_n': self.output_n_int,\n            'script_type': self.script_type,\n            'address': self.address,\n            'value': self.value,\n            'public_keys': pks,\n            'compressed': self.compressed,\n            'encoding': self.encoding,\n            'double_spend': self.double_spend,\n            'script': self.unlocking_script.hex(),\n            'redeemscript': self.redeemscript.hex(),\n            'sequence': self.sequence,\n            'signatures': [s.hex() for s in self.signatures],\n            'sigs_required': self.sigs_required,\n            'locktime_cltv': self.locktime_cltv,\n            'locktime_csv': self.locktime_csv,\n            'public_hash': self.public_hash.hex(),\n            'script_code': self.script_code.hex(),\n            'unlocking_script': self.unlocking_script.hex(),\n            'unlocking_script_unsigned': self.unlocking_script_unsigned.hex(),\n            'witness_type': self.witness_type,\n            'witness': b''.join(self.witnesses).hex(),\n            'sort': self.sort,\n            'valid': self.valid,\n        }\n\n    def __repr__(self):\n        return \"<Input(prev_txid='%s', output_n=%d, address='%s', index_n=%s, type='%s')>\" % \\\n               (self.prev_txid.hex(), self.output_n_int, self.address, self.index_n, self.script_type)",
  "class Output(object):\n    \"\"\"\n    Transaction Output class, normally part of Transaction class.\n    \n    Contains the amount and destination of a transaction.\n    \"\"\"\n\n    def __init__(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,\n                 output_n=0, script_type=None, witver=0, encoding=None, spending_txid='', spending_index_n=None,\n                 strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new transaction output\n        \n        A transaction outputs locks the specified amount to a public key. Anyone with the private key can unlock\n        this output.\n        \n        The transaction output class contains an amount and the destination which can be provided either as address, \n        public key, public key hash or a locking script. Only one needs to be provided as they all can be derived\n        from each other, but you can provide as many attributes as you know to improve speed.\n        \n        :param value: Amount of output in the smallest denominator integers (Satoshi's) or as Value object or string\n        :type value: int, Value, str\n        :param address: Destination address of output. Leave empty to derive from other attributes you provide. An instance of an Address or HDKey class is allowed as argument.\n        :type address: str, Address, HDKey\n        :param public_hash: Hash of public key or script\n        :type public_hash: bytes, str\n        :param public_key: Destination public key\n        :type public_key: bytes, str\n        :param lock_script: Locking script of output. If not provided a default unlocking script will be provided with a public key hash.\n        :type lock_script: bytes, str\n        :param spent: Is output already spent? Default is False\n        :type spent: bool\n        :param output_n: Output index number, default is 0. Index number has to be unique per transaction and 0 for first output, 1 for second, etc\n        :type output_n: int\n        :param script_type: Script type of output (p2pkh, p2sh, segwit p2wpkh, etc). Extracted from lock_script if provided.\n        :type script_type: str\n        :param witver: Witness version\n        :type witver: int\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty to derive from address or default base58 encoding\n        :type encoding: str\n        :param spending_txid: Transaction hash of input spending this transaction output\n        :type spending_txid: str\n        :param spending_index_n: Index number of input spending this transaction output\n        :type spending_index_n: int\n        :param strict: Raise exception when output is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        \"\"\"\n\n        if strict and not (address or public_hash or public_key or lock_script):\n            raise TransactionError(\"Please specify address, lock_script, public key or public key hash when \"\n                                   \"creating output\")\n\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.value = value_to_satoshi(value, network=network)\n        self.lock_script = b'' if lock_script is None else to_bytes(lock_script)\n        self.public_hash = to_bytes(public_hash)\n        if isinstance(address, Address):\n            self._address = address.address\n            self._address_obj = address\n        elif isinstance(address, HDKey):\n            self._address = address.address()\n            self._address_obj = address.address_obj\n            public_key = address.public_byte\n            if not script_type:\n                script_type = script_type_default(address.witness_type, address.multisig, True)\n            self.public_hash = address.hash160\n        else:\n            self._address = address\n            self._address_obj = None\n        self.public_key = to_bytes(public_key)\n        self.compressed = True\n        self.k = None\n        self.versionbyte = self.network.prefix_address\n        self.script_type = script_type\n        self.encoding = encoding\n        if not self._address and self.encoding is None:\n            self.encoding = 'base58'\n        self.spent = spent\n        self.output_n = output_n\n        self.script = Script.parse_bytes(self.lock_script, strict=strict)\n        self.witver = witver\n\n        if self._address_obj:\n            self.script_type = self._address_obj.script_type if script_type is None else script_type\n            self.public_hash = self._address_obj.hash_bytes\n            self.network = self._address_obj.network\n            self.encoding = self._address_obj.encoding\n\n        if self.script:\n            self.script_type = self.script_type if not self.script.script_types else self.script.script_types[0]\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:\n                self.encoding = 'bech32'\n            self.public_hash = self.script.public_hash\n            if self.script.keys:\n                self.public_key = self.script.keys[0].public_hex\n            if self.script_type == 'p2tr':\n                self.witver = self.script.commands[0] - 80\n\n        if self.public_key and not self.public_hash:\n            k = Key(self.public_key, is_private=False, network=network)\n            self.public_hash = k.hash160\n        elif self._address and (not self.public_hash or not self.script_type or not self.encoding):\n            address_dict = deserialize_address(self._address, self.encoding, self.network.name)\n            if address_dict['script_type'] and not script_type:\n                self.script_type = address_dict['script_type']\n            if not self.script_type:\n                raise TransactionError(\"Could not determine script type of address %s\" % self._address)\n            self.encoding = address_dict['encoding']\n            network_guesses = address_dict['networks']\n            if address_dict['network'] and self.network.name != address_dict['network']:\n                raise TransactionError(\"Address %s is from %s network and transaction from %s network\" %\n                                       (self._address, address_dict['network'], self.network.name))\n            elif self.network.name not in network_guesses:\n                raise TransactionError(\"Network for output address %s is different from transaction network. %s not \"\n                                       \"in %s\" % (self._address, self.network.name, network_guesses))\n            self.public_hash = address_dict['public_key_hash_bytes']\n        if not self.encoding:\n            self.encoding = 'base58'\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:\n                self.encoding = 'bech32'\n\n        if self.script_type is None:\n            self.script_type = 'p2pkh'\n            if self.encoding == 'bech32':\n                self.script_type = 'p2wpkh'\n        if not self.script and strict and (self.public_hash or self.public_key):\n            self.script = Script(script_types=[self.script_type], public_hash=self.public_hash, keys=[self.public_key])\n            self.lock_script = self.script.serialize()\n            if not self.script:\n                raise TransactionError(\"Unknown output script type %s, please provide locking script\" %\n                                       self.script_type)\n        self.spending_txid = spending_txid\n        self.spending_index_n = spending_index_n\n        # if self.script_type != 'nulldata' and value < self.network.dust_amount:\n        #     raise TransactionError(\"Output to %s must be more than dust amount %d\" %\n        #                            (self.address, self.network.dust_amount))\n\n    @property\n    def address_obj(self):\n        \"\"\"\n        Get address object property. Create standard address object if not defined already.\n\n        :return Address:\n        \"\"\"\n        if not self._address_obj:\n            if self.public_hash:\n                self._address_obj = Address(hashed_data=self.public_hash, script_type=self.script_type,\n                                            witver=self.witver, encoding=self.encoding, network=self.network)\n                self._address = self._address_obj.address\n                self.versionbyte = self._address_obj.prefix\n        return self._address_obj\n\n    @property\n    def address(self):\n        if not self._address:\n            address_obj = self.address_obj\n            if not address_obj:\n                return ''\n            self._address = address_obj.address\n        return self._address\n\n    @classmethod\n    def parse(cls, raw, output_n=0, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse raw BytesIO string and return Output object\n\n        :param raw: raw output stream\n        :type raw: BytesIO\n        :param output_n: Output number of Transaction output\n        :type output_n: int\n        :param strict: Raise exception when output is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Output:\n        \"\"\"\n        value = int.from_bytes(raw.read(8)[::-1], 'big')\n        lock_script_size = read_varbyteint(raw)\n        lock_script = raw.read(lock_script_size)\n        return Output(value=value, lock_script=lock_script, output_n=output_n, strict=strict, network=network)\n\n    # TODO: Write and rewrite locktime methods\n    # def set_locktime - CLTV (BIP65)\n    # def set_locktime_blocks\n    # def set_locktime_time\n\n    def set_locktime_relative(self, locktime):\n        \"\"\"\n        Relative timelocks with CHECKSEQUENCEVERIFY (CSV) as defined in BIP112\n        :param locktime:\n        :return:\n        \"\"\"\n        pass\n\n    def set_locktime_relative_blocks(self, blocks):\n        \"\"\"\n        Set nSequence relative locktime for this transaction input. The transaction will only be valid if the specified number of blocks has been mined since the previous UTXO is confirmed.\n\n        Maximum number of blocks is 65535 as defined in BIP-0068, which is around 455 days.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param blocks: The blocks value is the number of blocks since the previous transaction output has been confirmed.\n        :type blocks: int\n\n        :return None:\n        \"\"\"\n        # if blocks == 0 or blocks == 0xffffffff:\n        #     self.sequence = 0xffffffff\n        #     return\n        # if blocks > SEQUENCE_LOCKTIME_MASK:\n        #     raise TransactionError(\"Number of nSequence timelock blocks exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        # self.sequence = blocks\n        # self.signatures = []\n\n    def set_locktime_relative_time(self, seconds):\n        \"\"\"\n        Set nSequence relative locktime for this transaction input. The transaction will only be valid if the specified amount of seconds have been passed since the previous UTXO is confirmed.\n\n        Number of seconds will be rounded to the nearest 512 seconds. Any value below 512 will be interpreted as 512 seconds.\n\n        Maximum number of seconds is 33553920 (512 * 65535), which equals 384 days. See BIP-0068 definition.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param seconds: Number of seconds since the related previous transaction output has been confirmed.\n        :return:\n        \"\"\"\n        # if seconds == 0 or seconds == 0xffffffff:\n        #     self.sequence = 0xffffffff\n        #     return\n        # if seconds < 512:\n        #     seconds = 512\n        # if (seconds // 512) > SEQUENCE_LOCKTIME_MASK:\n        #     raise TransactionError(\"Number of relative nSeqence timelock seconds exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        # self.sequence = seconds // 512 + SEQUENCE_LOCKTIME_TYPE_FLAG\n        # self.signatures = []\n\n    def as_dict(self):\n        \"\"\"\n        Get transaction output information in json format\n\n        :return dict: Json with amount, locking script, public key, public key hash and address\n        \"\"\"\n\n        return {\n            'value': self.value,\n            'script': self.lock_script.hex(),\n            'script_type': self.script_type,\n            'public_key': self.public_key.hex(),\n            'public_hash': self.public_hash.hex(),\n            'address': self.address,\n            'output_n': self.output_n,\n            'spent': self.spent,\n            'spending_txid': self.spending_txid,\n            'spending_index_n': self.spending_index_n,\n        }\n\n    def __repr__(self):\n        return \"<Output(value=%d, address=%s, type=%s)>\" % (self.value, self.address, self.script_type)",
  "class Transaction(object):\n    \"\"\"\n    Transaction Class\n\n    Contains 1 or more Input class object with UTXO's to spent and 1 or more Output class objects with destinations.\n    Besides the transaction class contains a locktime and version.\n\n    Inputs and outputs can be included when creating the transaction, or can be added later with add_input and\n    add_output respectively.\n\n    A verify method is available to check if the transaction Inputs have valid unlocking scripts.\n\n    Each input in the transaction can be signed with the sign method provided a valid private key.\n    \"\"\"\n\n    @staticmethod\n    @deprecated  # Replaced by Transaction.parse() in version 0.6\n    def import_raw(rawtx, network=DEFAULT_NETWORK, check_size=True):  # pragma: no cover\n        \"\"\"\n        Import a raw transaction and create a Transaction object\n\n        Uses the transaction_deserialize method to parse the raw transaction and then calls the init method of\n        this transaction class to create the transaction object\n\n        REPLACED BY THE PARSE() METHOD\n\n        :param rawtx: Raw transaction string\n        :type rawtx: bytes, str\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        :param check_size: Check if no bytes are left when parsing is finished. Disable when parsing list of transactions, such as the transactions in a raw block. Default is True\n        :type check_size: bool\n\n        :return Transaction:\n        \"\"\"\n\n        return transaction_deserialize(rawtx, network=network, check_size=check_size)\n\n    @classmethod\n    def parse(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw transaction and create a Transaction object\n\n        :param rawtx: Raw transaction string\n        :type rawtx: BytesIO, bytes, str\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n        if isinstance(rawtx, bytes):\n            rawtx = BytesIO(rawtx)\n        elif isinstance(rawtx, str):\n            rawtx = BytesIO(bytes.fromhex(rawtx))\n\n        return cls.parse_bytesio(rawtx, strict, network)\n\n    @classmethod\n    def parse_bytesio(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw transaction and create a Transaction object\n\n        :param rawtx: Raw transaction string\n        :type rawtx: BytesIO\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n        coinbase = False\n        flag = None\n        witness_type = 'legacy'\n        network = network\n        if not isinstance(network, Network):\n            cls.network = Network(network)\n        raw_bytes = b''\n\n        try:\n            pos_start = rawtx.tell()\n        except AttributeError:\n            raise TransactionError(\"Provide raw transaction as BytesIO. Use parse, parse_bytes, parse_hex to parse \"\n                                   \"other data types\")\n\n        version = rawtx.read(4)[::-1]\n        if rawtx.read(1) == b'\\0':\n            flag = rawtx.read(1)\n            if flag == b'\\1':\n                witness_type = 'segwit'\n        else:\n            rawtx.seek(-1, 1)\n\n        n_inputs = read_varbyteint(rawtx)\n        inputs = []\n        for n in range(0, n_inputs):\n            inp = Input.parse(rawtx, index_n=n, witness_type=witness_type, strict=strict, network=network)\n            if inp.prev_txid == 32 * b'\\0':\n                coinbase = True\n            inputs.append(inp)\n\n        outputs = []\n        output_total = 0\n        n_outputs = read_varbyteint(rawtx)\n        for n in range(0, n_outputs):\n            o = Output.parse(rawtx, output_n=n, strict=strict, network=network)\n            outputs.append(o)\n            output_total += o.value\n        if not outputs:\n            raise TransactionError(\"Error no outputs found in this transaction\")\n\n        if witness_type == 'segwit':\n            for n in range(0, len(inputs)):\n                n_items = read_varbyteint(rawtx)\n                if not n_items:\n                    continue\n                script = Script()\n                is_taproot = False\n                for m in range(0, n_items):\n                    item_size = read_varbyteint(rawtx)\n                    if item_size == 0:\n                        witness = b'\\0'\n                    else:\n                        witness = rawtx.read(item_size)\n                    inputs[n].witnesses.append(witness)\n                    if not is_taproot:\n                        s = Script.parse_bytes(witness, strict=strict)\n                        if s.script_types == ['p2tr_unlock']:\n                            # FIXME: Support Taproot unlocking scripts\n                            _logger.warning(\"Taproot is not supported at the moment, rest of parsing input transaction \"\n                                            \"skipped\")\n                            is_taproot = True\n                        script += s\n\n                inputs[n].script = script if not inputs[n].script else inputs[n].script + script\n                inputs[n].keys = script.keys\n                inputs[n].signatures = script.signatures\n                if script.script_types[0][:13] == 'p2sh_multisig' or script.script_types[0] =='signature_multisig':\n                    inputs[n].script_type = 'p2sh_multisig'\n                    inputs[n].redeemscript = inputs[n].witnesses[-1]\n                elif script.script_types[0] == 'p2tr_unlock':\n                    inputs[n].script_type = 'p2tr'\n                    inputs[n].witness_type = 'segwit'\n                elif inputs[n].script_type == 'p2wpkh':\n                    inputs[n].script_type = 'p2sh_p2wpkh'\n                    inputs[n].witness_type = 'p2sh-segwit'\n                elif inputs[n].script_type == 'p2wpkh' or inputs[n].script_type == 'p2wsh':\n                    inputs[n].script_type = 'p2sh_p2wsh'\n                    inputs[n].witness_type = 'p2sh-segwit'\n                elif 'unknown' in script.script_types and not coinbase:\n                    inputs[n].script_type = 'unknown'\n\n                inputs[n].update_scripts()\n\n        locktime = int.from_bytes(rawtx.read(4)[::-1], 'big')\n        raw_len = len(raw_bytes)\n        if not raw_bytes:\n            pos_end = rawtx.tell()\n            raw_len = pos_end - pos_start\n            rawtx.seek(pos_start)\n            raw_bytes = rawtx.read(raw_len)\n\n        return Transaction(inputs, outputs, locktime, version, network, size=raw_len, output_total=output_total,\n                           coinbase=coinbase, flag=flag, witness_type=witness_type, rawtx=raw_bytes)\n\n    @classmethod\n    def parse_hex(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw hexadecimal transaction and create a Transaction object. Wrapper for the :func:`parse_bytesio`\n        method\n\n        :param rawtx: Raw transaction hexadecimal string\n        :type rawtx: str\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n\n        return cls.parse_bytesio(BytesIO(bytes.fromhex(rawtx)), strict, network)\n\n    @classmethod\n    def parse_bytes(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw bytes transaction and create a Transaction object.  Wrapper for the :func:`parse_bytesio`\n        method\n\n        :param rawtx: Raw transaction hexadecimal string\n        :type rawtx: bytes\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n\n        return cls.parse(BytesIO(rawtx), strict, network)\n\n    @staticmethod\n    def load(txid=None, filename=None):\n        \"\"\"\n        Load transaction object from file which has been stored with the :func:`save` method.\n\n        Specify transaction ID or filename.\n\n        :param txid: Transaction ID. Transaction object will be read from .bitcoinlib datadir\n        :type txid: str\n        :param filename: Name of transaction object file\n        :type filename: str\n\n        :return Transaction:\n        \"\"\"\n        if not filename and not txid:\n            raise TransactionError(\"Please supply filename or txid\")\n        elif not filename and txid:\n            p = Path(BCL_DATA_DIR, '%s.tx' % txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('rb')\n        t = pickle.load(f)\n        f.close()\n        return t\n\n    def __init__(self, inputs=None, outputs=None, locktime=0, version=None,\n                 network=DEFAULT_NETWORK, fee=None, fee_per_kb=None, size=None, txid='', txhash='', date=None,\n                 confirmations=None, block_height=None, block_hash=None, input_total=0, output_total=0, rawtx=b'',\n                 status='new', coinbase=False, verified=False, witness_type='legacy', flag=None):\n        \"\"\"\n        Create a new transaction class with provided inputs and outputs.\n\n        You can also create an empty transaction and add input and outputs later.\n\n        To verify and sign transactions all inputs and outputs need to be included in transaction. Any modification\n        after signing makes the transaction invalid.\n\n        :param inputs: Array of Input objects. Leave empty to add later\n        :type inputs: list (Input)\n        :param outputs: Array of Output object. Leave empty to add later\n        :type outputs: list (Output)\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param version: Version rules. Defaults to 1 in bytes\n        :type version: bytes, int\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n        :param fee: Fee in smallest denominator (ie Satoshi) for complete transaction\n        :type fee: int\n        :param fee_per_kb: Fee in smallest denominator per kilobyte. Specify when exact transaction size is not known.\n        :type fee_per_kb: int\n        :param size: Transaction size in bytes\n        :type size: int\n        :param txid: The transaction id (same for legacy/segwit) based on [nVersion][txins][txouts][nLockTime as hexadecimal string\n        :type txid: str\n        :param txhash: The transaction hash (differs from txid for witness transactions), based on [nVersion][marker][flag][txins][txouts][witness][nLockTime] in Segwit (as hexadecimal string). Unused at the moment\n        :type txhash: str\n        :param date: Confirmation date of transaction\n        :type date: datetime\n        :param confirmations: Number of confirmations\n        :type confirmations: int\n        :param block_height: Block number which includes transaction\n        :type block_height: int\n        :param block_hash: Hash of block for this transaction\n        :type block_hash: str\n        :param input_total: Total value of inputs\n        :type input_total: int\n        :param output_total: Total value of outputs\n        :type output_total: int\n        :param rawtx: Bytes representation of complete transaction\n        :type rawtx: bytes\n        :param status: Transaction status, for example: 'new', 'unconfirmed', 'confirmed'\n        :type status: str\n        :param coinbase: Coinbase transaction or not?\n        :type coinbase: bool\n        :param verified: Is transaction successfully verified? Updated when verified() method is called\n        :type verified: bool\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param flag: Transaction flag to indicate version, for example for SegWit\n        :type flag: bytes, str\n\n        \"\"\"\n\n        self.coinbase = coinbase\n        self.inputs = []\n        if inputs is not None:\n            for inp in inputs:\n                self.inputs.append(inp)\n            if not input_total:\n                input_total = sum([i.value for i in inputs])\n        id_list = [i.index_n for i in self.inputs]\n        if list(dict.fromkeys(id_list)) != id_list:\n            _logger.info(\"Identical transaction indexes (tid) found in inputs, please specify unique index. \"\n                         \"Indexes will be automatically recreated\")\n            index_n = 0\n            for inp in self.inputs:\n                inp.index_n = index_n\n                index_n += 1\n        if outputs is None:\n            self.outputs = []\n        else:\n            self.outputs = outputs\n            if not output_total:\n                output_total = sum([o.value for o in outputs])\n        if fee is None and output_total and input_total:\n            fee = input_total - output_total\n            if fee < 0 or fee == 0 and not self.coinbase:\n                raise TransactionError(\"Transaction inputs total value must be greater then total value of \"\n                                       \"transaction outputs\")\n        if not version:\n            version = b'\\x00\\x00\\x00\\x01'\n        if isinstance(version, int):\n            self.version = version.to_bytes(4, 'big')\n            self.version_int = version\n        else:\n            self.version = version\n            self.version_int = int.from_bytes(version, 'big')\n        self.locktime = locktime\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.flag = flag\n        self.fee = fee\n        self.fee_per_kb = fee_per_kb\n        self.size = size\n        self.vsize = size\n        self.txid = txid\n        self.txhash = txhash\n        self.date = date\n        self.confirmations = confirmations\n        self.block_height = block_height\n        self.block_hash = block_hash\n        self.input_total = input_total\n        self.output_total = output_total\n        self.rawtx = rawtx\n        self.status = status\n        self.verified = verified\n        self.witness_type = witness_type\n        self.change = 0\n        self.calc_weight_units()\n        if self.witness_type not in ['legacy', 'segwit']:\n            raise TransactionError(\"Please specify a valid witness type: legacy or segwit\")\n        if not self.txid:\n            self.txid = self.signature_hash()[::-1].hex()\n\n    def __repr__(self):\n        return \"<Transaction(id=%s, inputs=%d, outputs=%d, status=%s, network=%s)>\" % \\\n               (self.txid, len(self.inputs), len(self.outputs), self.status, self.network.name)\n\n    def __str__(self):\n        return self.txid\n\n    def __add__(self, other):\n        \"\"\"\n        Merge this transaction with another transaction keeping the original transaction intact.\n\n        :return Transaction:\n        \"\"\"\n        t = deepcopy(self)\n        t.merge_transaction(other)\n        return t\n\n    def __hash__(self):\n        return self.txid\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two transaction, must have same transaction ID\n\n        :param other: Other transaction object\n        :type other: Transaction\n\n        :return bool:\n        \"\"\"\n        if not isinstance(other, Transaction):\n            raise TransactionError(\"Can only compare with other Transaction object\")\n        return self.txid == other.txid\n\n    def as_dict(self):\n        \"\"\"\n        Return Json dictionary with transaction information: Inputs, outputs, version and locktime\n\n        :return dict:\n        \"\"\"\n\n        inputs = []\n        outputs = []\n        for i in self.inputs:\n            inputs.append(i.as_dict())\n        for o in self.outputs:\n            outputs.append(o.as_dict())\n        return {\n            'txid': self.txid,\n            'date': self.date,\n            'network': self.network.name,\n            'witness_type': self.witness_type,\n            'coinbase': self.coinbase,\n            'flag': None if not self.flag else ord(self.flag),\n            'txhash': self.txhash,\n            'confirmations': self.confirmations,\n            'block_height': self.block_height,\n            'block_hash': self.block_hash,\n            'fee': self.fee,\n            'fee_per_kb': self.fee_per_kb,\n            'inputs': inputs,\n            'outputs': outputs,\n            'input_total': self.input_total,\n            'output_total': self.output_total,\n            'version': self.version_int,\n            'locktime': self.locktime,\n            'raw': self.raw_hex(),\n            'size': self.size,\n            'vsize': self.vsize,\n            'verified': self.verified,\n            'status': self.status\n        }\n\n    def as_json(self):\n        \"\"\"\n        Get current key as json formatted string\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict()\n        return json.dumps(adict, indent=4, default=str)\n\n    def info(self):\n        \"\"\"\n        Prints transaction information to standard output\n        \"\"\"\n\n        print(\"Transaction %s\" % self.txid)\n        print(\"Date: %s\" % self.date)\n        print(\"Network: %s\" % self.network.name)\n        if self.locktime and self.locktime != 0xffffffff:\n            if self.locktime < 500000000:\n                print(\"Locktime: Until block %d\" % self.locktime)\n            else:\n                print(\"Locktime: Until %s UTC\" % datetime.utcfromtimestamp(self.locktime))\n        print(\"Version: %d\" % self.version_int)\n        print(\"Witness type: %s\" % self.witness_type)\n        print(\"Status: %s\" % self.status)\n        print(\"Verified: %s\" % self.verified)\n        print(\"Inputs\")\n        replace_by_fee = False\n        for ti in self.inputs:\n            print(\"-\", ti.address, Value.from_satoshi(ti.value, network=self.network).str(1), ti.prev_txid.hex(),\n                  ti.output_n_int)\n            validstr = \"not validated\"\n            if ti.valid:\n                validstr = \"valid\"\n            elif ti.valid is False:\n                validstr = \"invalid\"\n            print(\"  %s %s; sigs: %d (%d-of-%d) %s\" %\n                  (ti.witness_type, ti.script_type, len(ti.signatures), ti.sigs_required or 0, len(ti.keys), validstr))\n            if ti.sequence <= SEQUENCE_REPLACE_BY_FEE:\n                replace_by_fee = True\n            if ti.sequence <= SEQUENCE_LOCKTIME_DISABLE_FLAG:\n                if ti.sequence & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Relative timelock for %d seconds\" % (512 * (ti.sequence - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Relative timelock for %d blocks\" % ti.sequence)\n            if ti.locktime_cltv:\n                if ti.locktime_cltv & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Check Locktime Verify (CLTV) for %d seconds\" %\n                          (512 * (ti.locktime_cltv - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Check Locktime Verify (CLTV) for %d blocks\" % ti.locktime_cltv)\n            if ti.locktime_csv:\n                if ti.locktime_csv & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Check Sequence Verify Timelock (CSV) for %d seconds\" %\n                          (512 * (ti.locktime_csv - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Check Sequence Verify Timelock (CSV) for %d blocks\" % ti.locktime_csv)\n\n        print(\"Outputs\")\n        for to in self.outputs:\n            if to.script_type == 'nulldata':\n                print(\"- NULLDATA \", to.lock_script[2:])\n            else:\n                spent_str = ''\n                if to.spent:\n                    spent_str = 'S'\n                elif to.spent is False:\n                    spent_str = 'U'\n                print(\"-\", to.address, Value.from_satoshi(to.value, network=self.network).str(1), to.script_type,\n                      spent_str)\n        if replace_by_fee:\n            print(\"Replace by fee: Enabled\")\n        print(\"Size: %s\" % self.size)\n        print(\"Vsize: %s\" % self.vsize)\n        print(\"Fee: %s\" % self.fee)\n        print(\"Confirmations: %s\" % self.confirmations)\n        print(\"Block: %s\" % self.block_height)\n\n    def set_locktime_relative_blocks(self, blocks, input_index_n=0):\n        \"\"\"\n        Set nSequence relative locktime for this transaction. The transaction will only be valid if the specified number of blocks has been mined since the previous UTXO is confirmed.\n\n        Maximum number of blocks is 65535 as defined in BIP-0068, which is around 455 days.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param blocks: The blocks value is the number of blocks since the previous transaction output has been confirmed.\n        :type blocks: int\n        :param input_index_n: Index number of input for nSequence locktime\n        :type input_index_n: int\n\n        :return:\n        \"\"\"\n        if blocks == 0 or blocks == 0xffffffff:\n            self.inputs[input_index_n].sequence = 0xffffffff\n            self.sign(index_n=input_index_n, replace_signatures=True)\n            return\n        if blocks > SEQUENCE_LOCKTIME_MASK:\n            raise TransactionError(\"Number of nSequence timelock blocks exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        self.inputs[input_index_n].sequence = blocks\n        self.version_int = 2\n        self.sign_and_update(index_n=input_index_n)\n\n    def set_locktime_relative_time(self, seconds, input_index_n=0):\n        \"\"\"\n        Set nSequence relative locktime for this transaction. The transaction will only be valid if the specified amount of seconds have been passed since the previous UTXO is confirmed.\n\n        Number of seconds will be rounded to the nearest 512 seconds. Any value below 512 will be interpreted as 512 seconds.\n\n        Maximum number of seconds is 33553920 (512 * 65535), which equals 384 days. See BIP-0068 definition.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param seconds: Number of seconds since the related previous transaction output has been confirmed.\n        :type seconds: int\n        :param input_index_n: Index number of input for nSequence locktime\n        :type input_index_n: int\n\n        :return:\n        \"\"\"\n        if seconds == 0 or seconds == 0xffffffff:\n            self.inputs[input_index_n].sequence = 0xffffffff\n            self.sign(index_n=input_index_n, replace_signatures=True)\n            return\n        elif seconds < 512:\n            seconds = 512\n        elif (seconds // 512) > SEQUENCE_LOCKTIME_MASK:\n            raise TransactionError(\"Number of relative nSeqence timelock seconds exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        self.inputs[input_index_n].sequence = seconds // 512 + SEQUENCE_LOCKTIME_TYPE_FLAG\n        self.version_int = 2\n        self.sign_and_update(index_n=input_index_n)\n\n    def set_locktime_blocks(self, blocks):\n        \"\"\"\n        Set nLocktime, a transaction level absolute lock time in blocks using the transaction sequence field.\n\n        So for example if you set this value to 600000 the transaction will only be valid after block 600000.\n\n        :param blocks: Transaction is valid after supplied block number. Value must be between 0 and 500000000. Zero means no locktime.\n        :type blocks: int\n\n        :return:\n        \"\"\"\n        if blocks == 0 or blocks == 0xffffffff:\n            self.locktime = 0xffffffff\n            self.sign(replace_signatures=True)\n            self.verify()\n            return\n        elif blocks > 500000000:\n            raise TransactionError(\"Number of locktime blocks must be below %d\" % 500000000)\n        self.locktime = blocks\n        if blocks != 0 and blocks != 0xffffffff:\n            for i in self.inputs:\n                if i.sequence == 0xffffffff:\n                    i.sequence = 0xfffffffd\n        self.sign_and_update()\n\n    def set_locktime_time(self, timestamp):\n        \"\"\"\n        Set nLocktime, a transaction level absolute lock time in timestamp using the transaction sequence field.\n\n        :param timestamp: Transaction is valid after the given timestamp. Value must be between 500000000 and 0xfffffffe\n        :return:\n        \"\"\"\n        if timestamp == 0 or timestamp == 0xffffffff:\n            self.locktime = 0xffffffff\n            self.sign(replace_signatures=True)\n            self.verify()\n            return\n\n        if timestamp <= 500000000:\n            raise TransactionError(\"Timestamp must have a value higher then %d\" % 500000000)\n        if timestamp > 0xfffffffe:\n            raise TransactionError(\"Timestamp must have a value lower then %d\" % 0xfffffffe)\n        self.locktime = timestamp\n\n        # Input sequence value must be below 0xffffffff\n        for i in self.inputs:\n            if i.sequence == 0xffffffff:\n                i.sequence = 0xfffffffd\n        self.sign_and_update()\n\n    def signature_hash(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False):\n        \"\"\"\n        Double SHA256 Hash of Transaction signature\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Legacy or Segwit witness type? Leave empty to use Transaction witness type\n        :type witness_type: str\n        :param as_hex: Return value as hexadecimal string. Default is False\n        :type as_hex: bool\n\n        :return bytes: Transaction signature hash\n        \"\"\"\n        return double_sha256(self.signature(sign_id, hash_type, witness_type), as_hex=as_hex)\n\n    def signature(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Serializes transaction and calculates signature for Legacy or Segwit transactions\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Legacy or Segwit witness type? Leave empty to use Transaction witness type\n        :type witness_type: str\n\n        :return bytes: Transaction signature\n        \"\"\"\n\n        if witness_type is None:\n            witness_type = self.witness_type\n        if witness_type == 'legacy' or sign_id is None:\n            return self.raw(sign_id, hash_type, 'legacy')\n        elif witness_type in ['segwit', 'p2sh-segwit']:\n            return self.signature_segwit(sign_id, hash_type)\n        else:\n            raise TransactionError(\"Witness_type %s not supported\" % self.witness_type)\n\n    def signature_segwit(self, sign_id, hash_type=SIGHASH_ALL):\n        \"\"\"\n        Serialize transaction signature for segregated witness transaction\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n\n        :return bytes: Segwit transaction signature\n        \"\"\"\n        assert (self.witness_type == 'segwit')\n        prevouts_serialized = b''\n        sequence_serialized = b''\n        outputs_serialized = b''\n        hash_prevouts = b'\\0' * 32\n        hash_sequence = b'\\0' * 32\n        hash_outputs = b'\\0' * 32\n\n        for i in self.inputs:\n            prevouts_serialized += i.prev_txid[::-1] + i.output_n[::-1]\n            sequence_serialized += i.sequence.to_bytes(4, 'little')\n        if not hash_type & SIGHASH_ANYONECANPAY:\n            hash_prevouts = double_sha256(prevouts_serialized)\n            if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:\n                hash_sequence = double_sha256(sequence_serialized)\n        if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:\n            for o in self.outputs:\n                outputs_serialized += int(o.value).to_bytes(8, 'little')\n                outputs_serialized += varstr(o.lock_script)\n            hash_outputs = double_sha256(outputs_serialized)\n        elif (hash_type & 0x1f) != SIGHASH_SINGLE and sign_id < len(self.outputs):\n            outputs_serialized += int(self.outputs[sign_id].value).to_bytes(8, 'little')\n            outputs_serialized += varstr(self.outputs[sign_id].lock_script)\n            hash_outputs = double_sha256(outputs_serialized)\n\n        is_coinbase = self.inputs[sign_id].script_type == 'coinbase'\n        if not self.inputs[sign_id].value and not is_coinbase:\n            raise TransactionError(\"Need value of input %d to create transaction signature, value can not be 0\" %\n                                   sign_id)\n\n        if not self.inputs[sign_id].redeemscript:\n            self.inputs[sign_id].redeemscript = self.inputs[sign_id].script_code\n\n        if (not self.inputs[sign_id].redeemscript or self.inputs[sign_id].redeemscript == b'\\0') and \\\n                self.inputs[sign_id].redeemscript != 'unknown' and not is_coinbase:\n            raise TransactionError(\"Redeem script missing\")\n\n        ser_tx = \\\n            self.version[::-1] + hash_prevouts + hash_sequence + self.inputs[sign_id].prev_txid[::-1] + \\\n            self.inputs[sign_id].output_n[::-1] + \\\n            varstr(self.inputs[sign_id].redeemscript) + int(self.inputs[sign_id].value).to_bytes(8, 'little') + \\\n            self.inputs[sign_id].sequence.to_bytes(4, 'little') + \\\n            hash_outputs + self.locktime.to_bytes(4, 'little') + hash_type.to_bytes(4, 'little')\n        return ser_tx\n\n    def raw(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Serialize raw transaction\n\n        Return transaction with signed inputs if signatures are available\n\n        :param sign_id: Create raw transaction which can be signed by transaction with this input ID\n        :type sign_id: int, None\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Serialize transaction with other witness type then default. Use to create legacy raw transaction for segwit transaction to create transaction signature ID's\n        :type witness_type: str\n\n        :return bytes:\n        \"\"\"\n\n        if witness_type is None:\n            witness_type = self.witness_type\n\n        r = self.version[::-1]\n        if sign_id is None and witness_type == 'segwit':\n            r += b'\\x00'  # marker (BIP 141)\n            r += b'\\x01'  # flag (BIP 141)\n\n        r += int_to_varbyteint(len(self.inputs))\n        r_witness = b''\n        for i in self.inputs:\n            r += i.prev_txid[::-1] + i.output_n[::-1]\n            if i.witnesses and i.witness_type != 'legacy':\n                r_witness += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n            else:\n                r_witness += b'\\0'\n            if sign_id is None:\n                r += varstr(i.unlocking_script)\n            elif sign_id == i.index_n:\n                r += varstr(i.unlocking_script_unsigned)\n            else:\n                r += b'\\0'\n            r += i.sequence.to_bytes(4, 'little')\n\n        r += int_to_varbyteint(len(self.outputs))\n        for o in self.outputs:\n            if o.value < 0:\n                raise TransactionError(\"Output value < 0 not allowed\")\n            r += int(o.value).to_bytes(8, 'little')\n            r += varstr(o.lock_script)\n\n        if sign_id is None and witness_type == 'segwit':\n            r += r_witness\n\n        r += self.locktime.to_bytes(4, 'little')\n        if sign_id is not None:\n            r += hash_type.to_bytes(4, 'little')\n        else:\n            if not self.size and b'' not in [i.unlocking_script for i in self.inputs]:\n                self.size = len(r)\n                self.calc_weight_units()\n        return r\n\n    def raw_hex(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Wrapper for raw() method. Return current raw transaction hex\n\n        :param sign_id: Create raw transaction which can be signed by transaction with this input ID\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Serialize transaction with other witness type then default. Use to create legacy raw transaction for segwit transaction to create transaction signature ID's\n        :type witness_type: str\n\n        :return hexstring:\n        \"\"\"\n\n        return self.raw(sign_id, hash_type=hash_type, witness_type=witness_type).hex()\n\n    def witness_data(self):\n        \"\"\"\n        Get witness data for all inputs of this transaction\n\n        :return bytes:\n        \"\"\"\n        witness_data = b''\n        for i in self.inputs:\n            witness_data += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n        return witness_data\n\n    def verify(self):\n        \"\"\"\n        Verify all inputs of a transaction, check if signatures match public key.\n\n        Does not check if UTXO is valid or has already been spent\n\n        :return bool: True if enough signatures provided and if all signatures are valid\n        \"\"\"\n\n        self.verified = False\n        for inp in self.inputs:\n            try:\n                transaction_hash = self.signature_hash(inp.index_n, inp.hash_type, inp.witness_type)\n            except TransactionError as e:\n                _logger.info(\"Could not create transaction hash. Error: %s\" % e)\n                return False\n            if not transaction_hash:\n                _logger.info(\"Need at least 1 key to create segwit transaction signature\")\n                return False\n            self.verified = inp.verify(transaction_hash)\n            if not self.verified:\n                return False\n\n        self.verified = True\n        return True\n\n    def sign(self, keys=None, index_n=None, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=True,\n             replace_signatures=False):\n        \"\"\"\n        Sign the transaction input with provided private key\n\n        :param keys: A private key or list of private keys\n        :type keys: HDKey, Key, bytes, list\n        :param index_n: Index of transaction input. Leave empty to sign all inputs\n        :type index_n: int\n        :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked\n        :type multisig_key_n: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list\n        :type fail_on_unknown_key: bool\n        :param replace_signatures: Replace signature with new one if already signed.\n        :type replace_signatures: bool\n\n        :return None:\n        \"\"\"\n\n        if index_n is None:\n            tids = range(len(self.inputs))\n        else:\n            tids = [index_n]\n\n        if keys is None:\n            keys = []\n        elif not isinstance(keys, list):\n            keys = [keys]\n\n        for tid in tids:\n            n_signs = 0\n            tid_keys = [k if isinstance(k, (HDKey, Key)) else Key(k, compressed=self.inputs[tid].compressed)\n                        for k in keys]\n            for k in self.inputs[tid].keys:\n                if k.is_private and k not in tid_keys:\n                    tid_keys.append(k)\n            # If input does not contain any keys, try using provided keys\n            if not self.inputs[tid].keys:\n                self.inputs[tid].keys = tid_keys\n                self.inputs[tid].update_scripts(hash_type=hash_type)\n            if self.inputs[tid].script_type == 'coinbase':\n                raise TransactionError(\"Can not sign coinbase transactions\")\n            pub_key_list = [k.public_byte for k in self.inputs[tid].keys]\n            n_total_sigs = len(self.inputs[tid].keys)\n            sig_domain = [''] * n_total_sigs\n\n            txid = self.signature_hash(tid, witness_type=self.inputs[tid].witness_type)\n            for key in tid_keys:\n                # Check if signature signs known key and is not already in list\n                if key.public_byte not in pub_key_list:\n                    if fail_on_unknown_key:\n                        raise TransactionError(\"This key does not sign any known key: %s\" % key.public_hex)\n                    else:\n                        _logger.info(\"This key does not sign any known key: %s\" % key.public_hex)\n                        continue\n                if not replace_signatures and key in [x.public_key for x in self.inputs[tid].signatures]:\n                    _logger.info(\"Key %s already signed\" % key.public_hex)\n                    break\n\n                if not key.private_byte:\n                    raise TransactionError(\"Please provide a valid private key to sign the transaction\")\n                sig = sign(txid, key)\n                newsig_pos = pub_key_list.index(key.public_byte)\n                sig_domain[newsig_pos] = sig\n                n_signs += 1\n\n            if not n_signs:\n                break\n\n            # Add already known signatures on correct position\n            n_sigs_to_insert = len(self.inputs[tid].signatures)\n            for sig in self.inputs[tid].signatures:\n                if not sig.public_key:\n                    break\n                newsig_pos = pub_key_list.index(sig.public_key.public_byte)\n                if sig_domain[newsig_pos] == '':\n                    sig_domain[newsig_pos] = sig\n                    n_sigs_to_insert -= 1\n            if n_sigs_to_insert:\n                for sig in self.inputs[tid].signatures:\n                    free_positions = [i for i, s in enumerate(sig_domain) if s == '']\n                    for pos in free_positions:\n                        sig_domain[pos] = sig\n                        n_sigs_to_insert -= 1\n                        break\n            if n_sigs_to_insert:\n                _logger.info(\"Some signatures are replaced with the signatures of the provided keys\")\n            self.inputs[tid].signatures = [s for s in sig_domain if s != '']\n            self.inputs[tid].update_scripts(hash_type)\n\n    def sign_and_update(self, index_n=None):\n        \"\"\"\n        Update transaction ID and resign. Use if some properties of the transaction changed\n\n        :param index_n: Index of transaction input. Leave empty to sign all inputs\n        :type index_n: int\n\n        :return:\n        \"\"\"\n\n        self.version = self.version_int.to_bytes(4, 'big')\n        self.sign(index_n=index_n, replace_signatures=True)\n        self.txid = self.signature_hash()[::-1].hex()\n        self.size = len(self.raw())\n        self.calc_weight_units()\n        self.update_totals()\n        if self.fee:\n            self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)\n\n    def add_input(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',\n                  unlocking_script_unsigned=None, script_type=None, address='',\n                  sequence=0xffffffff, compressed=True, sigs_required=None, sort=False, index_n=None,\n                  value=None, double_spend=False, locktime_cltv=None, locktime_csv=None,\n                  key_path='', witness_type=None, witnesses=None, encoding=None, strict=True):\n        \"\"\"\n        Add input to this transaction\n\n        Wrapper for append method of Input class.\n\n        :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.\n        :type prev_txid: bytes, hexstring\n        :param output_n: Output number in previous transaction.\n        :type output_n: bytes, int\n        :param keys: Public keys can be provided to construct an Unlocking script. Optional\n        :type keys: bytes, str\n        :param signatures: Add signatures to input if already known\n        :type signatures: bytes, str\n        :param public_hash: Specify public hash from key or redeemscript if key is not available\n        :type public_hash: bytes\n        :param unlocking_script: Unlocking script (scriptSig) to prove ownership. Optional\n        :type unlocking_script: bytes, hexstring\n        :param unlocking_script_unsigned: TODO: find better name...\n        :type unlocking_script_unsigned: bytes, str\n        :param script_type: Type of unlocking script used, i.e. p2pkh or p2sh_multisig. Default is p2pkh\n        :type script_type: str\n        :param address: Specify address of input if known, default is to derive from key or scripts\n        :type address: str, Address\n        :param sequence: Sequence part of input, used for timelocked transactions\n        :type sequence: int, bytes\n        :param compressed: Use compressed or uncompressed public keys. Default is compressed\n        :type compressed: bool\n        :param sigs_required: Number of signatures required for a p2sh_multisig unlocking script\n        :param sigs_required: int\n        :param sort: Sort public keys according to BIP0045 standard. Default is False to avoid unexpected change of key order.\n        :type sort: boolean\n        :param index_n: Index number of position in transaction, leave empty to add input to end of inputs list\n        :type index_n: int\n        :param value: Value of input\n        :type value: int\n        :param double_spend: True if double spend is detected, depends on which service provider is selected\n        :type double_spend: bool\n        :param locktime_cltv: Check Lock Time Verify value. Script level absolute time lock for this input\n        :type locktime_cltv: int\n        :param locktime_csv: Check Sequency Verify value.\n        :type locktime_csv: int\n        :param key_path: Key path of input key as BIP32 string or list\n        :type key_path: str, list\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param witnesses: List of witnesses for inputs, used for segwit transactions for instance.\n        :type witnesses: list of bytes, list of str\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty to derive from script or script type\n        :type encoding: str\n        :param strict: Raise exception when input is malformed or incomplete\n        :type strict: bool\n\n        :return int: Transaction index number (index_n)\n        \"\"\"\n\n        if index_n is None:\n            index_n = len(self.inputs)\n        sequence_int = sequence\n        if isinstance(sequence, bytes):\n            sequence_int = int.from_bytes(sequence, 'little')\n        if self.version == b'\\x00\\x00\\x00\\x01' and 0 < sequence_int < SEQUENCE_LOCKTIME_DISABLE_FLAG:\n            self.version = b'\\x00\\x00\\x00\\x02'\n            self.version_int = 2\n        self.inputs.append(\n            Input(prev_txid=prev_txid, output_n=output_n, keys=keys, signatures=signatures, public_hash=public_hash,\n                  unlocking_script=unlocking_script, unlocking_script_unsigned=unlocking_script_unsigned,\n                  script_type=script_type, address=address, sequence=sequence, compressed=compressed,\n                  sigs_required=sigs_required, sort=sort, index_n=index_n, value=value, double_spend=double_spend,\n                  locktime_cltv=locktime_cltv, locktime_csv=locktime_csv, key_path=key_path, witness_type=witness_type,\n                  witnesses=witnesses, encoding=encoding, strict=strict, network=self.network.name))\n        return index_n\n\n    def add_output(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,\n                   output_n=None, encoding=None, spending_txid=None, spending_index_n=None, strict=True):\n        \"\"\"\n        Add an output to this transaction\n\n        Wrapper for the append method of the Output class.\n\n        :param value: Value of output in the smallest denominator of currency, for example satoshi's for bitcoins\n        :type value: int\n        :param address: Destination address of output. Leave empty to derive from other attributes you provide.\n        :type address: str, Address\n        :param public_hash: Hash of public key or script\n        :type public_hash: bytes, str\n        :param public_key: Destination public key\n        :type public_key: bytes, str\n        :param lock_script: Locking script of output. If not provided a default unlocking script will be provided with a public key hash.\n        :type lock_script: bytes, str\n        :param spent: Has output been spent in new transaction?\n        :type spent: bool, None\n        :param output_n: Index number of output in transaction\n        :type output_n: int\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty for to derive from script or script type\n        :type encoding: str\n        :param spending_txid: Transaction hash of input spending this transaction output\n        :type spending_txid: str\n        :param spending_index_n: Index number of input spending this transaction output\n        :type spending_index_n: int\n        :param strict: Raise exception when output is malformed or incomplete\n        :type strict: bool\n\n        :return int: Transaction output number (output_n)\n        \"\"\"\n\n        lock_script = to_bytes(lock_script)\n        if output_n is None:\n            output_n = len(self.outputs)\n        if not float(value).is_integer():\n            raise TransactionError(\"Output must be of type integer and contain no decimals\")\n        if lock_script.startswith(b'\\x6a'):\n            if value != 0:\n                raise TransactionError(\"Output value for OP_RETURN script must be 0\")\n        self.outputs.append(Output(value=int(value), address=address, public_hash=public_hash,\n                                   public_key=public_key, lock_script=lock_script, spent=spent, output_n=output_n,\n                                   encoding=encoding, spending_txid=spending_txid, spending_index_n=spending_index_n,\n                                   strict=strict, network=self.network.name))\n        return output_n\n\n    def merge_transaction(self, transaction):\n        \"\"\"\n        Merge this transaction with provided Transaction object.\n\n        Add all inputs and outputs of a transaction to this Transaction object. Because the transaction signature\n        changes with this operation, the transaction inputs need to be signed again.\n\n        Can be used to implement CoinJoin. Where two or more unrelated Transactions are merged into 1 transaction\n        to safe fees and increase privacy.\n\n        :param transaction: The transaction to be merged\n        :type transaction: Transaction\n\n        \"\"\"\n        self.inputs += transaction.inputs\n        self.outputs += transaction.outputs\n        self.shuffle()\n        self.update_totals()\n        self.sign_and_update()\n\n    def estimate_size(self, number_of_change_outputs=0):\n        \"\"\"\n        Get estimated vsize in for current transaction based on transaction type and number of inputs and outputs.\n\n        For old-style legacy transaction the vsize is the length of the transaction. In segwit transaction the\n        witness data has less weight. The formula used is: math.ceil(((est_size-witness_size) * 3 + est_size) / 4)\n\n        :param number_of_change_outputs: Number of change outputs, default is 0\n        :type number_of_change_outputs: int\n\n        :return int: Estimated transaction size\n        \"\"\"\n\n        # if self.input_total and self.output_total + self.fee == self.input_total:\n        #     add_change_output = False\n        est_size = 12\n        witness_size = 2\n        if self.witness_type != 'legacy':\n            est_size += 2\n        # TODO: if no inputs assume 1 input\n        if not self.inputs:\n            est_size += 125\n            witness_size += 72\n        for inp in self.inputs:\n            est_size += 40\n            scr_size = 0\n            if inp.witness_type != 'legacy':\n                est_size += 1\n            if inp.unlocking_script and len(inp.signatures) >= inp.sigs_required:\n                scr_size += len(varstr(inp.unlocking_script))\n                if inp.witness_type == 'p2sh-segwit':\n                    scr_size += sum([1 + len(w) for w in inp.witnesses])\n            else:\n                if inp.script_type == 'sig_pubkey':\n                    scr_size += 107\n                    if not inp.compressed:\n                        scr_size += 33\n                    if inp.witness_type == 'p2sh-segwit':\n                        scr_size += 24\n                # elif inp.script_type in ['p2sh_multisig', 'p2sh_p2wpkh', 'p2sh_p2wsh']:\n                elif inp.script_type == 'p2sh_multisig':\n                    scr_size += 9 + (len(inp.keys) * 34) + (inp.sigs_required * 72)\n                    if inp.witness_type == 'p2sh-segwit':\n                        scr_size += 17 * inp.sigs_required\n                elif inp.script_type == 'signature':\n                    scr_size += 9 + 72\n                else:\n                    raise TransactionError(\"Unknown input script type %s cannot estimate transaction size\" %\n                                           inp.script_type)\n            est_size += scr_size\n            witness_size += scr_size\n        for outp in self.outputs:\n            est_size += 8\n            if outp.lock_script:\n                est_size += len(varstr(outp.lock_script))\n            else:\n                raise TransactionError(\"Need locking script for output %d to estimate size\" % outp.output_n)\n        if number_of_change_outputs:\n            is_multisig = True if self.inputs and self.inputs[0].script_type == 'p2sh_multisig' else False\n            co_size = 8\n            if not self.inputs or self.inputs[0].witness_type == 'legacy':\n                co_size += 24 if is_multisig else 26\n            elif self.inputs[0].witness_type == 'p2sh-segwit':\n                co_size += 24\n            else:\n                co_size += 33 if is_multisig else 23\n            est_size += (number_of_change_outputs * co_size)\n        self.size = est_size\n        self.vsize = est_size\n        if self.witness_type == 'legacy':\n            return est_size\n        else:\n            self.vsize = math.ceil((((est_size - witness_size) * 3 + est_size) / 4) - 1.5)\n            return self.vsize\n\n    def calc_weight_units(self):\n        \"\"\"\n        Calculate weight units and vsize for this Transaction. Weight units are used to determine fee.\n\n        :return int:\n        \"\"\"\n        if not self.size:\n            return None\n        witness_data_size = len(self.witness_data())\n        wu = self.size * 4\n        if self.witness_type == 'segwit' and witness_data_size > 1:\n            wu = wu - 6  # for segwit marker and flag\n            wu = wu - witness_data_size * 3\n        self.vsize = math.ceil(wu / 4)\n        return wu\n\n    @property\n    def weight_units(self):\n        return self.calc_weight_units()\n\n    def calculate_fee(self):\n        \"\"\"\n        Get fee for this transaction in the smallest denominator (i.e. Satoshi) based on its size and the\n        transaction.fee_per_kb value\n\n        :return int: Estimated transaction fee\n        \"\"\"\n\n        if not self.fee_per_kb:\n            raise TransactionError(\"Cannot calculate transaction fees: transaction.fee_per_kb is not set\")\n        if self.fee_per_kb < self.network.fee_min:\n            self.fee_per_kb = self.network.fee_min\n        elif self.fee_per_kb > self.network.fee_max:\n            self.fee_per_kb = self.network.fee_max\n        if not self.vsize:\n            self.estimate_size()\n        fee = int(self.vsize / 1000.0 * self.fee_per_kb)\n        return fee\n\n    def update_totals(self):\n        \"\"\"\n        Update input_total, output_total and fee according to inputs and outputs of this transaction\n\n        :return int:\n        \"\"\"\n\n        self.input_total = sum([i.value for i in self.inputs if i.value])\n        self.output_total = sum([o.value for o in self.outputs if o.value])\n        if self.coinbase:\n            self.input_total = self.output_total\n        # self.fee = 0\n        if self.input_total:\n            self.fee = self.input_total - self.output_total\n            if self.vsize:\n                self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)\n\n    def save(self, filename=None):\n        \"\"\"\n        Store transaction object as file, so it can be imported in bitcoinlib later with the :func:`load` method.\n\n        :param filename: Location and name of file, leave empty to store transaction in bitcoinlib data directory: .bitcoinlib/<transaction_id.tx)\n        :type filename: str\n\n        :return:\n        \"\"\"\n        if not filename:\n            p = Path(BCL_DATA_DIR, '%s.tx' % self.txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('wb')\n        pickle.dump(self, f)\n        f.close()\n\n    def shuffle_inputs(self):\n        \"\"\"\n        Shuffle transaction inputs in random order.\n\n        :return:\n        \"\"\"\n        random.shuffle(self.inputs)\n        for idx, o in enumerate(self.inputs):\n            o.index_n = idx\n\n    def shuffle_outputs(self):\n        \"\"\"\n        Shuffle transaction outputs in random order.\n\n        :return:\n        \"\"\"\n        random.shuffle(self.outputs)\n        for idx, o in enumerate(self.outputs):\n            o.output_n = idx\n\n    def shuffle(self):\n        \"\"\"\n        Shuffle transaction inputs and outputs in random order.\n\n        :return:\n        \"\"\"\n        self.shuffle_inputs()\n        self.shuffle_outputs()",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def _parse_data(scr, max_items=None, redeemscript_expected=False, item_length=0):\n        # scr = to_bytes(scr)\n        items = []\n        total_length = 0\n        if 69 <= len(scr) <= 74 and scr[:1] == b'\\x30':\n            return [scr], len(scr)\n        while len(scr) and (max_items is None or max_items > len(items)):\n            itemlen, size = varbyteint_to_int(scr[0:9])\n            if item_length and itemlen != item_length:\n                break\n            if not item_length and itemlen not in [20, 33, 65, 70, 71, 72, 73]:\n                break\n            if redeemscript_expected and len(scr[itemlen + 1:]) < 20:\n                break\n            items.append(scr[1:itemlen + 1])\n            total_length += itemlen + size\n            scr = scr[itemlen + 1:]\n        return items, total_length",
  "def _get_empty_data():\n        return {'script_type': '', 'keys': [], 'signatures': [], 'hashes': [], 'redeemscript': b'',\n                'number_of_sigs_n': 1, 'number_of_sigs_m': 1, 'locktime_cltv': None, 'locktime_csv': None, 'result': ''}",
  "def _parse_script(script):\n        found = False\n        cur = 0\n        data = _get_empty_data()\n        for script_type in script_types:\n            cur = 0\n            try:\n                ost = SCRIPT_TYPES_UNLOCKING[script_type]\n            except KeyError:\n                ost = SCRIPT_TYPES_LOCKING[script_type]\n            data = _get_empty_data()\n            data['script_type'] = script_type\n            found = True\n            for ch in ost:\n                if cur >= len(script):\n                    found = False\n                    break\n                cur_char = script[cur]\n                if ch[:4] == 'hash':\n                    hash_length = 0\n                    if len(ch) > 5:\n                        hash_length = int(ch.split(\"-\")[1])\n                    s, total_length = _parse_data(script[cur:], 1, item_length=hash_length)\n                    if not s:\n                        found = False\n                        break\n                    data['hashes'] += s\n                    cur += total_length\n                elif ch == 'signature':\n                    signature_length = 0\n                    s, total_length = _parse_data(script[cur:], 1, item_length=signature_length)\n                    if not s:\n                        found = False\n                        break\n                    data['signatures'] += s\n                    cur += total_length\n                elif ch == 'public_key':\n                    pk_size, size = varbyteint_to_int(script[cur:cur + 9])\n                    key = script[cur + size:cur + size + pk_size]\n                    if not key:\n                        found = False\n                        break\n                    data['keys'].append(key)\n                    cur += size + pk_size\n                elif ch == 'OP_RETURN':\n                    if cur_char == op.op_return and cur == 0:\n                        data.update({'op_return': script[cur + 1:]})\n                        cur = len(script)\n                        found = True\n                        break\n                    else:\n                        found = False\n                        break\n                elif ch == 'multisig':  # one or more signatures\n                    redeemscript_expected = False\n                    if 'redeemscript' in ost:\n                        redeemscript_expected = True\n                    s, total_length = _parse_data(script[cur:], redeemscript_expected=redeemscript_expected)\n                    if not s:\n                        found = False\n                        break\n                    data['signatures'] += s\n                    cur += total_length\n                elif ch == 'redeemscript':\n                    size_byte = 0\n                    if script[cur:cur + 1] == b'\\x4c':\n                        size_byte = 1\n                    elif script[cur:cur + 1] == b'\\x4d':\n                        size_byte = 2\n                    elif script[cur:cur + 1] == b'\\x4e':\n                        size_byte = 3\n                    data['redeemscript'] = script[cur + 1 + size_byte:]\n                    data2 = script_deserialize(data['redeemscript'], locking_script=True)\n                    if 'signatures' not in data2 or not data2['signatures']:\n                        found = False\n                        break\n                    data['keys'] = data2['signatures']\n                    data['number_of_sigs_m'] = data2['number_of_sigs_m']\n                    data['number_of_sigs_n'] = data2['number_of_sigs_n']\n                    cur = len(script)\n                elif ch == 'push_size':\n                    push_size, size = varbyteint_to_int(script[cur:cur + 9])\n                    found = bool(len(script[cur:]) - size == push_size)\n                    if not found:\n                        break\n                elif ch == 'op_m':\n                    if cur_char in OP_N_CODES:\n                        data['number_of_sigs_m'] = cur_char - op.op_1 + 1\n                    else:\n                        found = False\n                        break\n                    cur += 1\n                elif ch == 'op_n':\n                    if cur_char in OP_N_CODES:\n                        data['number_of_sigs_n'] = cur_char - op.op_1 + 1\n                    else:\n                        found = False\n                        break\n                    if data['number_of_sigs_m'] > data['number_of_sigs_n']:\n                        raise TransactionError(\"Number of signatures to sign (%s) is higher then actual \"\n                                               \"amount of signatures (%s)\" %\n                                               (data['number_of_sigs_m'], data['number_of_sigs_n']))\n                    if len(data['signatures']) > int(data['number_of_sigs_n']):\n                        raise TransactionError(\"%d signatures found, but %s sigs expected\" %\n                                               (len(data['signatures']), data['number_of_sigs_n']))\n                    cur += 1\n                elif ch == 'SIGHASH_ALL':\n                    pass\n                    # if cur_char != SIGHASH_ALL:\n                    #     found = False\n                    #     break\n                elif ch == 'locktime_cltv':\n                    if len(script) < 4:\n                        found = False\n                        break\n                    data['locktime_cltv'] = int.from_bytes(script[cur:cur + 4], 'little')\n                    cur += 4\n                elif ch == 'locktime_csv':\n                    if len(script) < 4:\n                        found = False\n                        break\n                    data['locktime_csv'] = int.from_bytes(script[cur:cur + 4], 'little')\n                    cur += 4\n                else:\n                    try:\n                        if opcodenames.get(cur_char) == ch:\n                            cur += 1\n                        else:\n                            found = False\n                            data = _get_empty_data()\n                            break\n                    except IndexError:\n                        raise TransactionError(\"Opcode %s not found [type %s]\" % (ch, script_type))\n            if found and not len(script[cur:]):  # Found is True and no remaining script to parse\n                break\n\n        if found and not len(script[cur:]):\n            return data, script[cur:]\n        data = _get_empty_data()\n        data['result'] = 'Script not recognised'\n        return data, ''",
  "def __init__(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',\n                 unlocking_script_unsigned=None, script=None, script_type=None, address='',\n                 sequence=0xffffffff, compressed=None, sigs_required=None, sort=False, index_n=0,\n                 value=0, double_spend=False, locktime_cltv=None, locktime_csv=None, key_path='', witness_type=None,\n                 witnesses=None, encoding=None, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new transaction input\n        \n        :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.\n        :type prev_txid: bytes, str\n        :param output_n: Output number in previous transaction.\n        :type output_n: bytes, int\n        :param keys: A list of Key objects or public / private key string in various formats. If no list is provided but a bytes or string variable, a list with one item will be created. Optional\n        :type keys: list (bytes, str, Key)\n        :param signatures: Specify optional signatures\n        :type signatures: list (bytes, str, Signature)\n        :param public_hash: Public key hash or script hash. Specify if key is not available\n        :type public_hash: bytes\n        :param unlocking_script: Unlocking script (scriptSig) to prove ownership. Optional\n        :type unlocking_script: bytes, hexstring\n        :param unlocking_script_unsigned: Unlocking script for signing transaction\n        :type unlocking_script_unsigned: bytes, hexstring\n        :param script_type: Type of unlocking script used, i.e. p2pkh or p2sh_multisig. Default is p2pkh\n        :type script_type: str\n        :param address: Address string or object for input\n        :type address: str, Address\n        :param sequence: Sequence part of input, you normally do not have to touch this\n        :type sequence: bytes, int\n        :param compressed: Use compressed or uncompressed public keys. Default is compressed\n        :type compressed: bool\n        :param sigs_required: Number of signatures required for a p2sh_multisig unlocking script\n        :type sigs_required: int\n        :param sort: Sort public keys according to BIP0045 standard. Default is False to avoid unexpected change of key order.\n        :type sort: boolean\n        :param index_n: Index of input in transaction. Used by Transaction class.\n        :type index_n: int\n        :param value: Value of input in the smallest denominator integers (Satoshi's) or as Value object or string\n        :type value: int, Value, str\n        :param double_spend: Is this input also spend in another transaction\n        :type double_spend: bool\n        :param locktime_cltv: Check Lock Time Verify value. Script level absolute time lock for this input\n        :type locktime_cltv: int\n        :param locktime_csv: Check Sequence Verify value\n        :type locktime_csv: int\n        :param key_path: Key path of input key as BIP32 string or list\n        :type key_path: str, list\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param witnesses: List of witnesses for inputs, used for segwit transactions for instance. Argument can be list of bytes or string or a single bytes string with concatenated witnesses as found in a raw transaction.\n        :type witnesses: list of bytes, list of str, bytes\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty for default\n        :type encoding: str\n        :param strict: Raise exception when input is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        \"\"\"\n\n        self.prev_txid = to_bytes(prev_txid)\n        self.output_n = output_n\n        if isinstance(output_n, int):\n            self.output_n_int = output_n\n            self.output_n = output_n.to_bytes(4, 'big')\n        else:\n            self.output_n_int = int.from_bytes(output_n, 'big')\n            self.output_n = output_n\n        self.unlocking_script = b'' if unlocking_script is None else to_bytes(unlocking_script)\n        self.unlocking_script_unsigned = b'' if unlocking_script_unsigned is None \\\n            else to_bytes(unlocking_script_unsigned)\n        self.script = None\n        self.hash_type = SIGHASH_ALL\n        if isinstance(sequence, numbers.Number):\n            self.sequence = sequence\n        else:\n            self.sequence = int.from_bytes(sequence, 'little')\n        self.compressed = compressed\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.index_n = index_n\n        self.value = value_to_satoshi(value, network=network)\n        if not keys:\n            keys = []\n        self.keys = []\n        if not isinstance(keys, list):\n            keys = [keys]\n        self.public_hash = public_hash\n        if not signatures:\n            signatures = []\n        if not isinstance(signatures, list):\n            signatures = [signatures]\n        self.sort = sort\n        if isinstance(address, Address):\n            self.address = address.address\n            self.encoding = address.encoding\n            self.network = address.network\n        else:\n            self.address = address\n        self.signatures = []\n        self.redeemscript = b''\n        self.script_type = script_type\n        if self.prev_txid == b'\\0' * 32:\n            self.script_type = 'coinbase'\n        self.double_spend = double_spend\n        self.locktime_cltv = locktime_cltv\n        self.locktime_csv = locktime_csv\n        self.witness_type = witness_type\n        if encoding is None:\n            self.encoding = 'base58'\n            if self.witness_type == 'segwit':\n                self.encoding = 'bech32'\n        else:\n            self.encoding = encoding\n        self.valid = None\n        self.key_path = key_path\n\n        self.witnesses = []\n        if isinstance(witnesses, bytes):\n            n_items, cursor = varbyteint_to_int(witnesses[0:9])\n            for m in range(0, n_items):\n                witness = b'\\0'\n                item_size, size = varbyteint_to_int(witnesses[cursor:cursor + 9])\n                if item_size:\n                    witness = witnesses[cursor + size:cursor + item_size + size]\n                cursor += item_size + size\n                self.witnesses.append(witness)\n        elif witnesses:\n            self.witnesses = [bytes.fromhex(w) if isinstance(w, str) else w for w in witnesses]\n        self.script_code = b''\n        self.script = script\n\n        # If unlocking script is specified extract keys, signatures, type from script\n        if self.unlocking_script and self.script_type != 'coinbase' and not (signatures and keys) and not script:\n            self.script = Script.parse_bytes(self.unlocking_script, strict=strict)\n            self.keys = self.script.keys\n            self.signatures = self.script.signatures\n            if len(self.signatures):\n                self.hash_type = self.signatures[0].hash_type\n            sigs_required = self.script.sigs_required\n            self.redeemscript = self.script.redeemscript if self.script.redeemscript else self.redeemscript\n            if len(self.script.script_types) == 1 and not self.script_type:\n                self.script_type = self.script.script_types[0]\n            elif self.script.script_types == ['signature_multisig', 'multisig']:\n                self.script_type = 'p2sh_multisig'\n            # TODO: Check if this if is necessary\n            if 'p2wpkh' in self.script.script_types:\n                self.script_type = 'p2sh_p2wpkh'\n                self.witness_type = 'p2sh-segwit'\n            elif 'p2wsh' in self.script.script_types:\n                self.script_type = 'p2sh_p2wsh'\n                self.witness_type = 'p2sh-segwit'\n        if self.unlocking_script_unsigned and not self.signatures:\n            ls = Script.parse_bytes(self.unlocking_script_unsigned, strict=strict)\n            self.public_hash = self.public_hash if not ls.public_hash else ls.public_hash\n            if ls.script_types[0] in ['p2wpkh', 'p2wsh']:\n                self.witness_type = 'segwit'\n        self.sigs_required = sigs_required if sigs_required else 1\n\n        if self.script_type is None and self.witness_type is None and self.witnesses:\n            self.witness_type = 'segwit'\n        if self.witness_type is None or self.witness_type == 'legacy':\n            # if self.script_type in ['p2wpkh', 'p2wsh', 'p2sh_p2wpkh', 'p2sh_p2wsh']:\n            if self.script_type in ['p2wpkh', 'p2wsh']:\n                self.witness_type = 'segwit'\n            elif self.script_type in ['p2sh_p2wpkh', 'p2sh_p2wsh']:\n                self.witness_type = 'p2sh-segwit'\n            else:\n                self.witness_type = 'legacy'\n        elif self.witness_type == 'segwit' and self.script_type == 'sig_pubkey' and encoding is None:\n            self.encoding = 'bech32'\n        if not self.script_type:\n            self.script_type = 'sig_pubkey'\n\n        for key in keys:\n            if not isinstance(key, Key):\n                kobj = Key(key, network=network, strict=strict)\n            else:\n                kobj = key\n            if kobj not in self.keys:\n                # if self.compressed is not None and kobj.compressed != self.compressed:\n                #     _logger.warning(\"Key compressed is %s but Input class compressed argument is %s \" %\n                #                     (kobj.compressed, self.compressed))\n                self.compressed = kobj.compressed\n                self.keys.append(kobj)\n        if self.compressed is None:\n            self.compressed = True\n        if self.sort:\n            self.keys.sort(key=lambda k: k.public_byte)\n        self.strict = strict\n\n        for sig in signatures:\n            if not isinstance(sig, Signature):\n                try:\n                    sig = Signature.parse(sig)\n                except Exception as e:\n                    _logger.error(\"Could not parse signature %s in Input. Error: %s\" % (to_hexstring(sig), e))\n                    continue\n            if sig.as_der_encoded() not in [x.as_der_encoded() for x in self.signatures]:\n                self.signatures.append(sig)\n                if sig.hash_type:\n                    self.hash_type = sig.hash_type\n\n        # fixme: p2wpkh == p2sh_p2wpkh\n        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh'] and self.witnesses and not self.signatures and \\\n                self.script_type in ['sig_pubkey', 'p2sh_p2wpkh'] and len(self.witnesses) == 2 and \\\n                b'\\0' not in self.witnesses:\n            self.signatures = [Signature.parse_bytes(self.witnesses[0])]\n            self.hash_type = self.signatures[0].hash_type\n            self.keys = [Key(self.witnesses[1], network=self.network)]\n\n        self.update_scripts(hash_type=self.hash_type)",
  "def parse(cls, raw, witness_type='segwit', index_n=0, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse raw BytesIO string and return Input object\n\n        :param raw: Input\n        :type raw: BytesIO\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Derived from script if not specified.\n        :type witness_type: str\n        :param index_n: Index number of input\n        :type index_n: int\n        :param strict: Raise exception when input is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n\n        :return Input:\n        \"\"\"\n        prev_hash = raw.read(32)[::-1]\n        if len(prev_hash) != 32:\n            raise TransactionError(\"Input transaction hash not found. Probably malformed raw transaction\")\n        output_n = raw.read(4)[::-1]\n        unlocking_script_size = read_varbyteint(raw)\n        unlocking_script = raw.read(unlocking_script_size)\n        # TODO - handle non-standard input script b'\\1\\0',\n        #  see tx 38cf5779d1c5ca32b79cd5052b54e824102e878f041607d3b962038f5a8cf1ed\n        # if unlocking_script_size == 1 and unlocking_script == b'\\0':\n\n        inp_type = 'legacy'\n        if witness_type == 'segwit' and not unlocking_script_size:\n            inp_type = 'segwit'\n        sequence_number = raw.read(4)\n\n        return Input(prev_txid=prev_hash, output_n=output_n, unlocking_script=unlocking_script,\n                     witness_type=inp_type, sequence=sequence_number, index_n=index_n, strict=strict, network=network)",
  "def update_scripts(self, hash_type=SIGHASH_ALL):\n        \"\"\"\n        Method to update Input scripts.\n\n        Creates or updates unlocking script, witness script for segwit inputs, multisig redeemscripts and\n        locktime scripts. This method is called when initializing an Input class or when signing an input.\n\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n\n        :return bool: Always returns True when method is completed\n        \"\"\"\n\n        addr_data = b''\n        unlock_script = b''\n        if self.script_type in ['sig_pubkey', 'p2sh_p2wpkh', 'p2wpkh']:  # fixme: p2wpkh == p2sh_p2wpkh\n            if not self.public_hash and self.keys:\n                self.public_hash = self.keys[0].hash160\n            if not self.keys and not self.public_hash:\n                return\n            self.script_code = b'\\x76\\xa9\\x14' + self.public_hash + b'\\x88\\xac'\n            self.unlocking_script_unsigned = self.script_code\n            addr_data = self.public_hash\n            if self.signatures and self.keys:\n                self.witnesses = [self.signatures[0].as_der_encoded() if hash_type else b'', self.keys[0].public_byte]\n                unlock_script = b''.join([bytes(varstr(w)) for w in self.witnesses])\n            if not self.unlocking_script or self.strict:\n                if self.witness_type == 'p2sh-segwit':\n                    self.unlocking_script = varstr(b'\\0' + varstr(self.public_hash))\n                elif self.witness_type == 'segwit':\n                    self.unlocking_script = b''\n                elif unlock_script != b'':\n                    self.unlocking_script = unlock_script\n        elif self.script_type in ['p2sh_multisig', 'p2sh_p2wsh', 'p2wsh']:  # fixme: p2sh_p2wsh == p2wsh\n            if not self.redeemscript and self.keys:\n                self.redeemscript = Script(script_types=['multisig'], keys=self.keys,\n                                           sigs_required=self.sigs_required).serialize()\n            if self.redeemscript:\n                if self.witness_type == 'segwit' or self.witness_type == 'p2sh-segwit':\n                    self.public_hash = hashlib.sha256(self.redeemscript).digest()\n                else:\n                    self.public_hash = hash160(self.redeemscript)\n            addr_data = self.public_hash\n            self.unlocking_script_unsigned = self.redeemscript\n\n            if self.redeemscript and self.keys:\n                n_tag = self.redeemscript[0:1]\n                if not isinstance(n_tag, int):\n                    n_tag = int.from_bytes(n_tag, 'big')\n                self.sigs_required = n_tag - 80\n                signatures = [s.as_der_encoded() for s in self.signatures[:self.sigs_required]]\n                if b'' in signatures:\n                    raise TransactionError(\"Empty signature found in signature list when signing. \"\n                                           \"Is DER encoded version of signature defined?\")\n                if len(signatures) and len(signatures) >= self.sigs_required:  # and not self.unlocking_script\n                    unlock_script_obj = Script(script_types=['p2sh_multisig'], keys=[k.public_byte for k in self.keys],\n                                               signatures=self.signatures[:self.sigs_required],\n                                               sigs_required=self.sigs_required, redeemscript=self.redeemscript)\n                    if self.witness_type in ['segwit', 'p2sh-segwit']:\n                        unlock_script = unlock_script_obj.serialize_list()\n                    else:\n                        unlock_script = unlock_script_obj.serialize()\n                if self.witness_type == 'segwit':\n                    script_code = b''\n                    for k in self.keys:\n                        script_code += varstr(k.public_byte) + b'\\xad\\xab'\n                    if len(script_code) > 3:\n                        script_code = script_code[:-2] + b'\\xac'\n                    self.script_code = script_code\n                    if signatures:\n                        self.witnesses = unlock_script\n                elif self.witness_type == 'p2sh-segwit':\n                    self.unlocking_script = varstr(b'\\0' + varstr(self.public_hash))\n                    self.script_code = self.unlocking_script\n                    if signatures:\n                        self.witnesses = unlock_script\n                elif unlock_script != b'' and self.strict:\n                    self.unlocking_script = unlock_script\n        elif self.script_type == 'signature':\n            if self.keys:\n                self.script_code = varstr(self.keys[0].public_byte) + b'\\xac'\n                self.unlocking_script_unsigned = self.script_code\n                addr_data = self.keys[0].public_byte\n            if self.signatures and not self.unlocking_script:\n                self.unlocking_script = varstr(self.signatures[0].as_der_encoded())\n        elif self.script_type == 'p2tr':  # segwit_v1\n            self.redeemscript = self.witnesses[0]\n            # FIXME: Address cannot be known without looking at previous transaction\n        elif self.script_type not in ['coinbase', 'unknown'] and self.strict:\n            raise TransactionError(\"Unknown unlocking script type %s for input %d\" % (self.script_type, self.index_n))\n        if addr_data and not self.address:\n            self.address = Address(hashed_data=addr_data, encoding=self.encoding, network=self.network,\n                                   script_type=self.script_type, witness_type=self.witness_type).address\n\n        if self.locktime_cltv:\n            self.unlocking_script_unsigned = script_add_locktime_cltv(self.locktime_cltv,\n                                                                      self.unlocking_script_unsigned)\n            self.unlocking_script = script_add_locktime_cltv(self.locktime_cltv, self.unlocking_script)\n        elif self.locktime_csv:\n            self.unlocking_script_unsigned = script_add_locktime_csv(self.locktime_csv, self.unlocking_script_unsigned)\n            self.unlocking_script = script_add_locktime_csv(self.locktime_csv, self.unlocking_script)\n        return True",
  "def verify(self, transaction_hash):\n        \"\"\"\n        Verify input with provided transaction hash, check if signatures matches public key.\n\n        Does not check if UTXO is valid or has already been spent\n\n        :param transaction_hash: Double SHA256 Hash of Transaction signature\n        :type transaction_hash: bytes\n\n        :return bool: True if enough signatures provided and if all signatures are valid\n        \"\"\"\n\n        if self.script_type == 'coinbase':\n            self.valid = True\n            return True\n        if not self.signatures:\n            _logger.info(\"No signatures found for transaction input %d\" % self.index_n)\n            return False\n\n        sig_n = 0\n        key_n = 0\n        sigs_verified = 0\n        while sigs_verified < self.sigs_required:\n            if key_n >= len(self.keys):\n                _logger.info(\n                    \"Not enough valid signatures provided for input %d. Found %d signatures but %d needed\" %\n                    (self.index_n, sigs_verified, self.sigs_required))\n                return False\n            if sig_n >= len(self.signatures):\n                _logger.info(\"No valid signatures found\")\n                return False\n            key = self.keys[key_n]\n            sig = self.signatures[sig_n]\n            if verify(transaction_hash, sig, key):\n                sigs_verified += 1\n                sig_n += 1\n            elif sig_n > 0:\n                # try previous signature\n                prev_sig = deepcopy(self.signatures[sig_n - 1])\n                if verify(transaction_hash, prev_sig, key):\n                    sigs_verified += 1\n            key_n += 1\n        self.valid = True\n        return True",
  "def as_dict(self):\n        \"\"\"\n        Get transaction input information in json format\n        \n        :return dict: Json with output_n, prev_txid, output_n, type, address, public_key, public_hash, unlocking_script and sequence\n        \"\"\"\n\n        pks = []\n        for k in self.keys:\n            pks.append(k.public_hex)\n        if len(self.keys) == 1:\n            pks = pks[0]\n        return {\n            'index_n': self.index_n,\n            'prev_txid': self.prev_txid.hex(),\n            'output_n': self.output_n_int,\n            'script_type': self.script_type,\n            'address': self.address,\n            'value': self.value,\n            'public_keys': pks,\n            'compressed': self.compressed,\n            'encoding': self.encoding,\n            'double_spend': self.double_spend,\n            'script': self.unlocking_script.hex(),\n            'redeemscript': self.redeemscript.hex(),\n            'sequence': self.sequence,\n            'signatures': [s.hex() for s in self.signatures],\n            'sigs_required': self.sigs_required,\n            'locktime_cltv': self.locktime_cltv,\n            'locktime_csv': self.locktime_csv,\n            'public_hash': self.public_hash.hex(),\n            'script_code': self.script_code.hex(),\n            'unlocking_script': self.unlocking_script.hex(),\n            'unlocking_script_unsigned': self.unlocking_script_unsigned.hex(),\n            'witness_type': self.witness_type,\n            'witness': b''.join(self.witnesses).hex(),\n            'sort': self.sort,\n            'valid': self.valid,\n        }",
  "def __repr__(self):\n        return \"<Input(prev_txid='%s', output_n=%d, address='%s', index_n=%s, type='%s')>\" % \\\n               (self.prev_txid.hex(), self.output_n_int, self.address, self.index_n, self.script_type)",
  "def __init__(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,\n                 output_n=0, script_type=None, witver=0, encoding=None, spending_txid='', spending_index_n=None,\n                 strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Create a new transaction output\n        \n        A transaction outputs locks the specified amount to a public key. Anyone with the private key can unlock\n        this output.\n        \n        The transaction output class contains an amount and the destination which can be provided either as address, \n        public key, public key hash or a locking script. Only one needs to be provided as they all can be derived\n        from each other, but you can provide as many attributes as you know to improve speed.\n        \n        :param value: Amount of output in the smallest denominator integers (Satoshi's) or as Value object or string\n        :type value: int, Value, str\n        :param address: Destination address of output. Leave empty to derive from other attributes you provide. An instance of an Address or HDKey class is allowed as argument.\n        :type address: str, Address, HDKey\n        :param public_hash: Hash of public key or script\n        :type public_hash: bytes, str\n        :param public_key: Destination public key\n        :type public_key: bytes, str\n        :param lock_script: Locking script of output. If not provided a default unlocking script will be provided with a public key hash.\n        :type lock_script: bytes, str\n        :param spent: Is output already spent? Default is False\n        :type spent: bool\n        :param output_n: Output index number, default is 0. Index number has to be unique per transaction and 0 for first output, 1 for second, etc\n        :type output_n: int\n        :param script_type: Script type of output (p2pkh, p2sh, segwit p2wpkh, etc). Extracted from lock_script if provided.\n        :type script_type: str\n        :param witver: Witness version\n        :type witver: int\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty to derive from address or default base58 encoding\n        :type encoding: str\n        :param spending_txid: Transaction hash of input spending this transaction output\n        :type spending_txid: str\n        :param spending_index_n: Index number of input spending this transaction output\n        :type spending_index_n: int\n        :param strict: Raise exception when output is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        \"\"\"\n\n        if strict and not (address or public_hash or public_key or lock_script):\n            raise TransactionError(\"Please specify address, lock_script, public key or public key hash when \"\n                                   \"creating output\")\n\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.value = value_to_satoshi(value, network=network)\n        self.lock_script = b'' if lock_script is None else to_bytes(lock_script)\n        self.public_hash = to_bytes(public_hash)\n        if isinstance(address, Address):\n            self._address = address.address\n            self._address_obj = address\n        elif isinstance(address, HDKey):\n            self._address = address.address()\n            self._address_obj = address.address_obj\n            public_key = address.public_byte\n            if not script_type:\n                script_type = script_type_default(address.witness_type, address.multisig, True)\n            self.public_hash = address.hash160\n        else:\n            self._address = address\n            self._address_obj = None\n        self.public_key = to_bytes(public_key)\n        self.compressed = True\n        self.k = None\n        self.versionbyte = self.network.prefix_address\n        self.script_type = script_type\n        self.encoding = encoding\n        if not self._address and self.encoding is None:\n            self.encoding = 'base58'\n        self.spent = spent\n        self.output_n = output_n\n        self.script = Script.parse_bytes(self.lock_script, strict=strict)\n        self.witver = witver\n\n        if self._address_obj:\n            self.script_type = self._address_obj.script_type if script_type is None else script_type\n            self.public_hash = self._address_obj.hash_bytes\n            self.network = self._address_obj.network\n            self.encoding = self._address_obj.encoding\n\n        if self.script:\n            self.script_type = self.script_type if not self.script.script_types else self.script.script_types[0]\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:\n                self.encoding = 'bech32'\n            self.public_hash = self.script.public_hash\n            if self.script.keys:\n                self.public_key = self.script.keys[0].public_hex\n            if self.script_type == 'p2tr':\n                self.witver = self.script.commands[0] - 80\n\n        if self.public_key and not self.public_hash:\n            k = Key(self.public_key, is_private=False, network=network)\n            self.public_hash = k.hash160\n        elif self._address and (not self.public_hash or not self.script_type or not self.encoding):\n            address_dict = deserialize_address(self._address, self.encoding, self.network.name)\n            if address_dict['script_type'] and not script_type:\n                self.script_type = address_dict['script_type']\n            if not self.script_type:\n                raise TransactionError(\"Could not determine script type of address %s\" % self._address)\n            self.encoding = address_dict['encoding']\n            network_guesses = address_dict['networks']\n            if address_dict['network'] and self.network.name != address_dict['network']:\n                raise TransactionError(\"Address %s is from %s network and transaction from %s network\" %\n                                       (self._address, address_dict['network'], self.network.name))\n            elif self.network.name not in network_guesses:\n                raise TransactionError(\"Network for output address %s is different from transaction network. %s not \"\n                                       \"in %s\" % (self._address, self.network.name, network_guesses))\n            self.public_hash = address_dict['public_key_hash_bytes']\n        if not self.encoding:\n            self.encoding = 'base58'\n            if self.script_type in ['p2wpkh', 'p2wsh', 'p2tr']:\n                self.encoding = 'bech32'\n\n        if self.script_type is None:\n            self.script_type = 'p2pkh'\n            if self.encoding == 'bech32':\n                self.script_type = 'p2wpkh'\n        if not self.script and strict and (self.public_hash or self.public_key):\n            self.script = Script(script_types=[self.script_type], public_hash=self.public_hash, keys=[self.public_key])\n            self.lock_script = self.script.serialize()\n            if not self.script:\n                raise TransactionError(\"Unknown output script type %s, please provide locking script\" %\n                                       self.script_type)\n        self.spending_txid = spending_txid\n        self.spending_index_n = spending_index_n",
  "def address_obj(self):\n        \"\"\"\n        Get address object property. Create standard address object if not defined already.\n\n        :return Address:\n        \"\"\"\n        if not self._address_obj:\n            if self.public_hash:\n                self._address_obj = Address(hashed_data=self.public_hash, script_type=self.script_type,\n                                            witver=self.witver, encoding=self.encoding, network=self.network)\n                self._address = self._address_obj.address\n                self.versionbyte = self._address_obj.prefix\n        return self._address_obj",
  "def address(self):\n        if not self._address:\n            address_obj = self.address_obj\n            if not address_obj:\n                return ''\n            self._address = address_obj.address\n        return self._address",
  "def parse(cls, raw, output_n=0, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse raw BytesIO string and return Output object\n\n        :param raw: raw output stream\n        :type raw: BytesIO\n        :param output_n: Output number of Transaction output\n        :type output_n: int\n        :param strict: Raise exception when output is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Output:\n        \"\"\"\n        value = int.from_bytes(raw.read(8)[::-1], 'big')\n        lock_script_size = read_varbyteint(raw)\n        lock_script = raw.read(lock_script_size)\n        return Output(value=value, lock_script=lock_script, output_n=output_n, strict=strict, network=network)",
  "def set_locktime_relative(self, locktime):\n        \"\"\"\n        Relative timelocks with CHECKSEQUENCEVERIFY (CSV) as defined in BIP112\n        :param locktime:\n        :return:\n        \"\"\"\n        pass",
  "def set_locktime_relative_blocks(self, blocks):\n        \"\"\"\n        Set nSequence relative locktime for this transaction input. The transaction will only be valid if the specified number of blocks has been mined since the previous UTXO is confirmed.\n\n        Maximum number of blocks is 65535 as defined in BIP-0068, which is around 455 days.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param blocks: The blocks value is the number of blocks since the previous transaction output has been confirmed.\n        :type blocks: int\n\n        :return None:\n        \"\"\"",
  "def set_locktime_relative_time(self, seconds):\n        \"\"\"\n        Set nSequence relative locktime for this transaction input. The transaction will only be valid if the specified amount of seconds have been passed since the previous UTXO is confirmed.\n\n        Number of seconds will be rounded to the nearest 512 seconds. Any value below 512 will be interpreted as 512 seconds.\n\n        Maximum number of seconds is 33553920 (512 * 65535), which equals 384 days. See BIP-0068 definition.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param seconds: Number of seconds since the related previous transaction output has been confirmed.\n        :return:\n        \"\"\"",
  "def as_dict(self):\n        \"\"\"\n        Get transaction output information in json format\n\n        :return dict: Json with amount, locking script, public key, public key hash and address\n        \"\"\"\n\n        return {\n            'value': self.value,\n            'script': self.lock_script.hex(),\n            'script_type': self.script_type,\n            'public_key': self.public_key.hex(),\n            'public_hash': self.public_hash.hex(),\n            'address': self.address,\n            'output_n': self.output_n,\n            'spent': self.spent,\n            'spending_txid': self.spending_txid,\n            'spending_index_n': self.spending_index_n,\n        }",
  "def __repr__(self):\n        return \"<Output(value=%d, address=%s, type=%s)>\" % (self.value, self.address, self.script_type)",
  "def import_raw(rawtx, network=DEFAULT_NETWORK, check_size=True):  # pragma: no cover\n        \"\"\"\n        Import a raw transaction and create a Transaction object\n\n        Uses the transaction_deserialize method to parse the raw transaction and then calls the init method of\n        this transaction class to create the transaction object\n\n        REPLACED BY THE PARSE() METHOD\n\n        :param rawtx: Raw transaction string\n        :type rawtx: bytes, str\n        :param network: Network, leave empty for default\n        :type network: str, Network\n        :param check_size: Check if no bytes are left when parsing is finished. Disable when parsing list of transactions, such as the transactions in a raw block. Default is True\n        :type check_size: bool\n\n        :return Transaction:\n        \"\"\"\n\n        return transaction_deserialize(rawtx, network=network, check_size=check_size)",
  "def parse(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw transaction and create a Transaction object\n\n        :param rawtx: Raw transaction string\n        :type rawtx: BytesIO, bytes, str\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n        if isinstance(rawtx, bytes):\n            rawtx = BytesIO(rawtx)\n        elif isinstance(rawtx, str):\n            rawtx = BytesIO(bytes.fromhex(rawtx))\n\n        return cls.parse_bytesio(rawtx, strict, network)",
  "def parse_bytesio(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw transaction and create a Transaction object\n\n        :param rawtx: Raw transaction string\n        :type rawtx: BytesIO\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n        coinbase = False\n        flag = None\n        witness_type = 'legacy'\n        network = network\n        if not isinstance(network, Network):\n            cls.network = Network(network)\n        raw_bytes = b''\n\n        try:\n            pos_start = rawtx.tell()\n        except AttributeError:\n            raise TransactionError(\"Provide raw transaction as BytesIO. Use parse, parse_bytes, parse_hex to parse \"\n                                   \"other data types\")\n\n        version = rawtx.read(4)[::-1]\n        if rawtx.read(1) == b'\\0':\n            flag = rawtx.read(1)\n            if flag == b'\\1':\n                witness_type = 'segwit'\n        else:\n            rawtx.seek(-1, 1)\n\n        n_inputs = read_varbyteint(rawtx)\n        inputs = []\n        for n in range(0, n_inputs):\n            inp = Input.parse(rawtx, index_n=n, witness_type=witness_type, strict=strict, network=network)\n            if inp.prev_txid == 32 * b'\\0':\n                coinbase = True\n            inputs.append(inp)\n\n        outputs = []\n        output_total = 0\n        n_outputs = read_varbyteint(rawtx)\n        for n in range(0, n_outputs):\n            o = Output.parse(rawtx, output_n=n, strict=strict, network=network)\n            outputs.append(o)\n            output_total += o.value\n        if not outputs:\n            raise TransactionError(\"Error no outputs found in this transaction\")\n\n        if witness_type == 'segwit':\n            for n in range(0, len(inputs)):\n                n_items = read_varbyteint(rawtx)\n                if not n_items:\n                    continue\n                script = Script()\n                is_taproot = False\n                for m in range(0, n_items):\n                    item_size = read_varbyteint(rawtx)\n                    if item_size == 0:\n                        witness = b'\\0'\n                    else:\n                        witness = rawtx.read(item_size)\n                    inputs[n].witnesses.append(witness)\n                    if not is_taproot:\n                        s = Script.parse_bytes(witness, strict=strict)\n                        if s.script_types == ['p2tr_unlock']:\n                            # FIXME: Support Taproot unlocking scripts\n                            _logger.warning(\"Taproot is not supported at the moment, rest of parsing input transaction \"\n                                            \"skipped\")\n                            is_taproot = True\n                        script += s\n\n                inputs[n].script = script if not inputs[n].script else inputs[n].script + script\n                inputs[n].keys = script.keys\n                inputs[n].signatures = script.signatures\n                if script.script_types[0][:13] == 'p2sh_multisig' or script.script_types[0] =='signature_multisig':\n                    inputs[n].script_type = 'p2sh_multisig'\n                    inputs[n].redeemscript = inputs[n].witnesses[-1]\n                elif script.script_types[0] == 'p2tr_unlock':\n                    inputs[n].script_type = 'p2tr'\n                    inputs[n].witness_type = 'segwit'\n                elif inputs[n].script_type == 'p2wpkh':\n                    inputs[n].script_type = 'p2sh_p2wpkh'\n                    inputs[n].witness_type = 'p2sh-segwit'\n                elif inputs[n].script_type == 'p2wpkh' or inputs[n].script_type == 'p2wsh':\n                    inputs[n].script_type = 'p2sh_p2wsh'\n                    inputs[n].witness_type = 'p2sh-segwit'\n                elif 'unknown' in script.script_types and not coinbase:\n                    inputs[n].script_type = 'unknown'\n\n                inputs[n].update_scripts()\n\n        locktime = int.from_bytes(rawtx.read(4)[::-1], 'big')\n        raw_len = len(raw_bytes)\n        if not raw_bytes:\n            pos_end = rawtx.tell()\n            raw_len = pos_end - pos_start\n            rawtx.seek(pos_start)\n            raw_bytes = rawtx.read(raw_len)\n\n        return Transaction(inputs, outputs, locktime, version, network, size=raw_len, output_total=output_total,\n                           coinbase=coinbase, flag=flag, witness_type=witness_type, rawtx=raw_bytes)",
  "def parse_hex(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw hexadecimal transaction and create a Transaction object. Wrapper for the :func:`parse_bytesio`\n        method\n\n        :param rawtx: Raw transaction hexadecimal string\n        :type rawtx: str\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n\n        return cls.parse_bytesio(BytesIO(bytes.fromhex(rawtx)), strict, network)",
  "def parse_bytes(cls, rawtx, strict=True, network=DEFAULT_NETWORK):\n        \"\"\"\n        Parse a raw bytes transaction and create a Transaction object.  Wrapper for the :func:`parse_bytesio`\n        method\n\n        :param rawtx: Raw transaction hexadecimal string\n        :type rawtx: bytes\n        :param strict: Raise exception when transaction is malformed, incomplete or not understood\n        :type strict: bool\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n\n        :return Transaction:\n        \"\"\"\n\n        return cls.parse(BytesIO(rawtx), strict, network)",
  "def load(txid=None, filename=None):\n        \"\"\"\n        Load transaction object from file which has been stored with the :func:`save` method.\n\n        Specify transaction ID or filename.\n\n        :param txid: Transaction ID. Transaction object will be read from .bitcoinlib datadir\n        :type txid: str\n        :param filename: Name of transaction object file\n        :type filename: str\n\n        :return Transaction:\n        \"\"\"\n        if not filename and not txid:\n            raise TransactionError(\"Please supply filename or txid\")\n        elif not filename and txid:\n            p = Path(BCL_DATA_DIR, '%s.tx' % txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('rb')\n        t = pickle.load(f)\n        f.close()\n        return t",
  "def __init__(self, inputs=None, outputs=None, locktime=0, version=None,\n                 network=DEFAULT_NETWORK, fee=None, fee_per_kb=None, size=None, txid='', txhash='', date=None,\n                 confirmations=None, block_height=None, block_hash=None, input_total=0, output_total=0, rawtx=b'',\n                 status='new', coinbase=False, verified=False, witness_type='legacy', flag=None):\n        \"\"\"\n        Create a new transaction class with provided inputs and outputs.\n\n        You can also create an empty transaction and add input and outputs later.\n\n        To verify and sign transactions all inputs and outputs need to be included in transaction. Any modification\n        after signing makes the transaction invalid.\n\n        :param inputs: Array of Input objects. Leave empty to add later\n        :type inputs: list (Input)\n        :param outputs: Array of Output object. Leave empty to add later\n        :type outputs: list (Output)\n        :param locktime: Transaction level locktime. Locks the transaction until a specified block (value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970). Default value is 0 for transactions without locktime\n        :type locktime: int\n        :param version: Version rules. Defaults to 1 in bytes\n        :type version: bytes, int\n        :param network: Network, leave empty for default network\n        :type network: str, Network\n        :param fee: Fee in smallest denominator (ie Satoshi) for complete transaction\n        :type fee: int\n        :param fee_per_kb: Fee in smallest denominator per kilobyte. Specify when exact transaction size is not known.\n        :type fee_per_kb: int\n        :param size: Transaction size in bytes\n        :type size: int\n        :param txid: The transaction id (same for legacy/segwit) based on [nVersion][txins][txouts][nLockTime as hexadecimal string\n        :type txid: str\n        :param txhash: The transaction hash (differs from txid for witness transactions), based on [nVersion][marker][flag][txins][txouts][witness][nLockTime] in Segwit (as hexadecimal string). Unused at the moment\n        :type txhash: str\n        :param date: Confirmation date of transaction\n        :type date: datetime\n        :param confirmations: Number of confirmations\n        :type confirmations: int\n        :param block_height: Block number which includes transaction\n        :type block_height: int\n        :param block_hash: Hash of block for this transaction\n        :type block_hash: str\n        :param input_total: Total value of inputs\n        :type input_total: int\n        :param output_total: Total value of outputs\n        :type output_total: int\n        :param rawtx: Bytes representation of complete transaction\n        :type rawtx: bytes\n        :param status: Transaction status, for example: 'new', 'unconfirmed', 'confirmed'\n        :type status: str\n        :param coinbase: Coinbase transaction or not?\n        :type coinbase: bool\n        :param verified: Is transaction successfully verified? Updated when verified() method is called\n        :type verified: bool\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param flag: Transaction flag to indicate version, for example for SegWit\n        :type flag: bytes, str\n\n        \"\"\"\n\n        self.coinbase = coinbase\n        self.inputs = []\n        if inputs is not None:\n            for inp in inputs:\n                self.inputs.append(inp)\n            if not input_total:\n                input_total = sum([i.value for i in inputs])\n        id_list = [i.index_n for i in self.inputs]\n        if list(dict.fromkeys(id_list)) != id_list:\n            _logger.info(\"Identical transaction indexes (tid) found in inputs, please specify unique index. \"\n                         \"Indexes will be automatically recreated\")\n            index_n = 0\n            for inp in self.inputs:\n                inp.index_n = index_n\n                index_n += 1\n        if outputs is None:\n            self.outputs = []\n        else:\n            self.outputs = outputs\n            if not output_total:\n                output_total = sum([o.value for o in outputs])\n        if fee is None and output_total and input_total:\n            fee = input_total - output_total\n            if fee < 0 or fee == 0 and not self.coinbase:\n                raise TransactionError(\"Transaction inputs total value must be greater then total value of \"\n                                       \"transaction outputs\")\n        if not version:\n            version = b'\\x00\\x00\\x00\\x01'\n        if isinstance(version, int):\n            self.version = version.to_bytes(4, 'big')\n            self.version_int = version\n        else:\n            self.version = version\n            self.version_int = int.from_bytes(version, 'big')\n        self.locktime = locktime\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        self.flag = flag\n        self.fee = fee\n        self.fee_per_kb = fee_per_kb\n        self.size = size\n        self.vsize = size\n        self.txid = txid\n        self.txhash = txhash\n        self.date = date\n        self.confirmations = confirmations\n        self.block_height = block_height\n        self.block_hash = block_hash\n        self.input_total = input_total\n        self.output_total = output_total\n        self.rawtx = rawtx\n        self.status = status\n        self.verified = verified\n        self.witness_type = witness_type\n        self.change = 0\n        self.calc_weight_units()\n        if self.witness_type not in ['legacy', 'segwit']:\n            raise TransactionError(\"Please specify a valid witness type: legacy or segwit\")\n        if not self.txid:\n            self.txid = self.signature_hash()[::-1].hex()",
  "def __repr__(self):\n        return \"<Transaction(id=%s, inputs=%d, outputs=%d, status=%s, network=%s)>\" % \\\n               (self.txid, len(self.inputs), len(self.outputs), self.status, self.network.name)",
  "def __str__(self):\n        return self.txid",
  "def __add__(self, other):\n        \"\"\"\n        Merge this transaction with another transaction keeping the original transaction intact.\n\n        :return Transaction:\n        \"\"\"\n        t = deepcopy(self)\n        t.merge_transaction(other)\n        return t",
  "def __hash__(self):\n        return self.txid",
  "def __eq__(self, other):\n        \"\"\"\n        Compare two transaction, must have same transaction ID\n\n        :param other: Other transaction object\n        :type other: Transaction\n\n        :return bool:\n        \"\"\"\n        if not isinstance(other, Transaction):\n            raise TransactionError(\"Can only compare with other Transaction object\")\n        return self.txid == other.txid",
  "def as_dict(self):\n        \"\"\"\n        Return Json dictionary with transaction information: Inputs, outputs, version and locktime\n\n        :return dict:\n        \"\"\"\n\n        inputs = []\n        outputs = []\n        for i in self.inputs:\n            inputs.append(i.as_dict())\n        for o in self.outputs:\n            outputs.append(o.as_dict())\n        return {\n            'txid': self.txid,\n            'date': self.date,\n            'network': self.network.name,\n            'witness_type': self.witness_type,\n            'coinbase': self.coinbase,\n            'flag': None if not self.flag else ord(self.flag),\n            'txhash': self.txhash,\n            'confirmations': self.confirmations,\n            'block_height': self.block_height,\n            'block_hash': self.block_hash,\n            'fee': self.fee,\n            'fee_per_kb': self.fee_per_kb,\n            'inputs': inputs,\n            'outputs': outputs,\n            'input_total': self.input_total,\n            'output_total': self.output_total,\n            'version': self.version_int,\n            'locktime': self.locktime,\n            'raw': self.raw_hex(),\n            'size': self.size,\n            'vsize': self.vsize,\n            'verified': self.verified,\n            'status': self.status\n        }",
  "def as_json(self):\n        \"\"\"\n        Get current key as json formatted string\n\n        :return str:\n        \"\"\"\n        adict = self.as_dict()\n        return json.dumps(adict, indent=4, default=str)",
  "def info(self):\n        \"\"\"\n        Prints transaction information to standard output\n        \"\"\"\n\n        print(\"Transaction %s\" % self.txid)\n        print(\"Date: %s\" % self.date)\n        print(\"Network: %s\" % self.network.name)\n        if self.locktime and self.locktime != 0xffffffff:\n            if self.locktime < 500000000:\n                print(\"Locktime: Until block %d\" % self.locktime)\n            else:\n                print(\"Locktime: Until %s UTC\" % datetime.utcfromtimestamp(self.locktime))\n        print(\"Version: %d\" % self.version_int)\n        print(\"Witness type: %s\" % self.witness_type)\n        print(\"Status: %s\" % self.status)\n        print(\"Verified: %s\" % self.verified)\n        print(\"Inputs\")\n        replace_by_fee = False\n        for ti in self.inputs:\n            print(\"-\", ti.address, Value.from_satoshi(ti.value, network=self.network).str(1), ti.prev_txid.hex(),\n                  ti.output_n_int)\n            validstr = \"not validated\"\n            if ti.valid:\n                validstr = \"valid\"\n            elif ti.valid is False:\n                validstr = \"invalid\"\n            print(\"  %s %s; sigs: %d (%d-of-%d) %s\" %\n                  (ti.witness_type, ti.script_type, len(ti.signatures), ti.sigs_required or 0, len(ti.keys), validstr))\n            if ti.sequence <= SEQUENCE_REPLACE_BY_FEE:\n                replace_by_fee = True\n            if ti.sequence <= SEQUENCE_LOCKTIME_DISABLE_FLAG:\n                if ti.sequence & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Relative timelock for %d seconds\" % (512 * (ti.sequence - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Relative timelock for %d blocks\" % ti.sequence)\n            if ti.locktime_cltv:\n                if ti.locktime_cltv & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Check Locktime Verify (CLTV) for %d seconds\" %\n                          (512 * (ti.locktime_cltv - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Check Locktime Verify (CLTV) for %d blocks\" % ti.locktime_cltv)\n            if ti.locktime_csv:\n                if ti.locktime_csv & SEQUENCE_LOCKTIME_TYPE_FLAG:\n                    print(\"  Check Sequence Verify Timelock (CSV) for %d seconds\" %\n                          (512 * (ti.locktime_csv - SEQUENCE_LOCKTIME_TYPE_FLAG)))\n                else:\n                    print(\"  Check Sequence Verify Timelock (CSV) for %d blocks\" % ti.locktime_csv)\n\n        print(\"Outputs\")\n        for to in self.outputs:\n            if to.script_type == 'nulldata':\n                print(\"- NULLDATA \", to.lock_script[2:])\n            else:\n                spent_str = ''\n                if to.spent:\n                    spent_str = 'S'\n                elif to.spent is False:\n                    spent_str = 'U'\n                print(\"-\", to.address, Value.from_satoshi(to.value, network=self.network).str(1), to.script_type,\n                      spent_str)\n        if replace_by_fee:\n            print(\"Replace by fee: Enabled\")\n        print(\"Size: %s\" % self.size)\n        print(\"Vsize: %s\" % self.vsize)\n        print(\"Fee: %s\" % self.fee)\n        print(\"Confirmations: %s\" % self.confirmations)\n        print(\"Block: %s\" % self.block_height)",
  "def set_locktime_relative_blocks(self, blocks, input_index_n=0):\n        \"\"\"\n        Set nSequence relative locktime for this transaction. The transaction will only be valid if the specified number of blocks has been mined since the previous UTXO is confirmed.\n\n        Maximum number of blocks is 65535 as defined in BIP-0068, which is around 455 days.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param blocks: The blocks value is the number of blocks since the previous transaction output has been confirmed.\n        :type blocks: int\n        :param input_index_n: Index number of input for nSequence locktime\n        :type input_index_n: int\n\n        :return:\n        \"\"\"\n        if blocks == 0 or blocks == 0xffffffff:\n            self.inputs[input_index_n].sequence = 0xffffffff\n            self.sign(index_n=input_index_n, replace_signatures=True)\n            return\n        if blocks > SEQUENCE_LOCKTIME_MASK:\n            raise TransactionError(\"Number of nSequence timelock blocks exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        self.inputs[input_index_n].sequence = blocks\n        self.version_int = 2\n        self.sign_and_update(index_n=input_index_n)",
  "def set_locktime_relative_time(self, seconds, input_index_n=0):\n        \"\"\"\n        Set nSequence relative locktime for this transaction. The transaction will only be valid if the specified amount of seconds have been passed since the previous UTXO is confirmed.\n\n        Number of seconds will be rounded to the nearest 512 seconds. Any value below 512 will be interpreted as 512 seconds.\n\n        Maximum number of seconds is 33553920 (512 * 65535), which equals 384 days. See BIP-0068 definition.\n\n        When setting a relative timelock, the transaction version must be at least 2. The transaction will be updated so existing signatures for this input will be removed.\n\n        :param seconds: Number of seconds since the related previous transaction output has been confirmed.\n        :type seconds: int\n        :param input_index_n: Index number of input for nSequence locktime\n        :type input_index_n: int\n\n        :return:\n        \"\"\"\n        if seconds == 0 or seconds == 0xffffffff:\n            self.inputs[input_index_n].sequence = 0xffffffff\n            self.sign(index_n=input_index_n, replace_signatures=True)\n            return\n        elif seconds < 512:\n            seconds = 512\n        elif (seconds // 512) > SEQUENCE_LOCKTIME_MASK:\n            raise TransactionError(\"Number of relative nSeqence timelock seconds exceeds %d\" % SEQUENCE_LOCKTIME_MASK)\n        self.inputs[input_index_n].sequence = seconds // 512 + SEQUENCE_LOCKTIME_TYPE_FLAG\n        self.version_int = 2\n        self.sign_and_update(index_n=input_index_n)",
  "def set_locktime_blocks(self, blocks):\n        \"\"\"\n        Set nLocktime, a transaction level absolute lock time in blocks using the transaction sequence field.\n\n        So for example if you set this value to 600000 the transaction will only be valid after block 600000.\n\n        :param blocks: Transaction is valid after supplied block number. Value must be between 0 and 500000000. Zero means no locktime.\n        :type blocks: int\n\n        :return:\n        \"\"\"\n        if blocks == 0 or blocks == 0xffffffff:\n            self.locktime = 0xffffffff\n            self.sign(replace_signatures=True)\n            self.verify()\n            return\n        elif blocks > 500000000:\n            raise TransactionError(\"Number of locktime blocks must be below %d\" % 500000000)\n        self.locktime = blocks\n        if blocks != 0 and blocks != 0xffffffff:\n            for i in self.inputs:\n                if i.sequence == 0xffffffff:\n                    i.sequence = 0xfffffffd\n        self.sign_and_update()",
  "def set_locktime_time(self, timestamp):\n        \"\"\"\n        Set nLocktime, a transaction level absolute lock time in timestamp using the transaction sequence field.\n\n        :param timestamp: Transaction is valid after the given timestamp. Value must be between 500000000 and 0xfffffffe\n        :return:\n        \"\"\"\n        if timestamp == 0 or timestamp == 0xffffffff:\n            self.locktime = 0xffffffff\n            self.sign(replace_signatures=True)\n            self.verify()\n            return\n\n        if timestamp <= 500000000:\n            raise TransactionError(\"Timestamp must have a value higher then %d\" % 500000000)\n        if timestamp > 0xfffffffe:\n            raise TransactionError(\"Timestamp must have a value lower then %d\" % 0xfffffffe)\n        self.locktime = timestamp\n\n        # Input sequence value must be below 0xffffffff\n        for i in self.inputs:\n            if i.sequence == 0xffffffff:\n                i.sequence = 0xfffffffd\n        self.sign_and_update()",
  "def signature_hash(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None, as_hex=False):\n        \"\"\"\n        Double SHA256 Hash of Transaction signature\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Legacy or Segwit witness type? Leave empty to use Transaction witness type\n        :type witness_type: str\n        :param as_hex: Return value as hexadecimal string. Default is False\n        :type as_hex: bool\n\n        :return bytes: Transaction signature hash\n        \"\"\"\n        return double_sha256(self.signature(sign_id, hash_type, witness_type), as_hex=as_hex)",
  "def signature(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Serializes transaction and calculates signature for Legacy or Segwit transactions\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Legacy or Segwit witness type? Leave empty to use Transaction witness type\n        :type witness_type: str\n\n        :return bytes: Transaction signature\n        \"\"\"\n\n        if witness_type is None:\n            witness_type = self.witness_type\n        if witness_type == 'legacy' or sign_id is None:\n            return self.raw(sign_id, hash_type, 'legacy')\n        elif witness_type in ['segwit', 'p2sh-segwit']:\n            return self.signature_segwit(sign_id, hash_type)\n        else:\n            raise TransactionError(\"Witness_type %s not supported\" % self.witness_type)",
  "def signature_segwit(self, sign_id, hash_type=SIGHASH_ALL):\n        \"\"\"\n        Serialize transaction signature for segregated witness transaction\n\n        :param sign_id: Index of input to sign\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n\n        :return bytes: Segwit transaction signature\n        \"\"\"\n        assert (self.witness_type == 'segwit')\n        prevouts_serialized = b''\n        sequence_serialized = b''\n        outputs_serialized = b''\n        hash_prevouts = b'\\0' * 32\n        hash_sequence = b'\\0' * 32\n        hash_outputs = b'\\0' * 32\n\n        for i in self.inputs:\n            prevouts_serialized += i.prev_txid[::-1] + i.output_n[::-1]\n            sequence_serialized += i.sequence.to_bytes(4, 'little')\n        if not hash_type & SIGHASH_ANYONECANPAY:\n            hash_prevouts = double_sha256(prevouts_serialized)\n            if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:\n                hash_sequence = double_sha256(sequence_serialized)\n        if (hash_type & 0x1f) != SIGHASH_SINGLE and (hash_type & 0x1f) != SIGHASH_NONE:\n            for o in self.outputs:\n                outputs_serialized += int(o.value).to_bytes(8, 'little')\n                outputs_serialized += varstr(o.lock_script)\n            hash_outputs = double_sha256(outputs_serialized)\n        elif (hash_type & 0x1f) != SIGHASH_SINGLE and sign_id < len(self.outputs):\n            outputs_serialized += int(self.outputs[sign_id].value).to_bytes(8, 'little')\n            outputs_serialized += varstr(self.outputs[sign_id].lock_script)\n            hash_outputs = double_sha256(outputs_serialized)\n\n        is_coinbase = self.inputs[sign_id].script_type == 'coinbase'\n        if not self.inputs[sign_id].value and not is_coinbase:\n            raise TransactionError(\"Need value of input %d to create transaction signature, value can not be 0\" %\n                                   sign_id)\n\n        if not self.inputs[sign_id].redeemscript:\n            self.inputs[sign_id].redeemscript = self.inputs[sign_id].script_code\n\n        if (not self.inputs[sign_id].redeemscript or self.inputs[sign_id].redeemscript == b'\\0') and \\\n                self.inputs[sign_id].redeemscript != 'unknown' and not is_coinbase:\n            raise TransactionError(\"Redeem script missing\")\n\n        ser_tx = \\\n            self.version[::-1] + hash_prevouts + hash_sequence + self.inputs[sign_id].prev_txid[::-1] + \\\n            self.inputs[sign_id].output_n[::-1] + \\\n            varstr(self.inputs[sign_id].redeemscript) + int(self.inputs[sign_id].value).to_bytes(8, 'little') + \\\n            self.inputs[sign_id].sequence.to_bytes(4, 'little') + \\\n            hash_outputs + self.locktime.to_bytes(4, 'little') + hash_type.to_bytes(4, 'little')\n        return ser_tx",
  "def raw(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Serialize raw transaction\n\n        Return transaction with signed inputs if signatures are available\n\n        :param sign_id: Create raw transaction which can be signed by transaction with this input ID\n        :type sign_id: int, None\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Serialize transaction with other witness type then default. Use to create legacy raw transaction for segwit transaction to create transaction signature ID's\n        :type witness_type: str\n\n        :return bytes:\n        \"\"\"\n\n        if witness_type is None:\n            witness_type = self.witness_type\n\n        r = self.version[::-1]\n        if sign_id is None and witness_type == 'segwit':\n            r += b'\\x00'  # marker (BIP 141)\n            r += b'\\x01'  # flag (BIP 141)\n\n        r += int_to_varbyteint(len(self.inputs))\n        r_witness = b''\n        for i in self.inputs:\n            r += i.prev_txid[::-1] + i.output_n[::-1]\n            if i.witnesses and i.witness_type != 'legacy':\n                r_witness += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n            else:\n                r_witness += b'\\0'\n            if sign_id is None:\n                r += varstr(i.unlocking_script)\n            elif sign_id == i.index_n:\n                r += varstr(i.unlocking_script_unsigned)\n            else:\n                r += b'\\0'\n            r += i.sequence.to_bytes(4, 'little')\n\n        r += int_to_varbyteint(len(self.outputs))\n        for o in self.outputs:\n            if o.value < 0:\n                raise TransactionError(\"Output value < 0 not allowed\")\n            r += int(o.value).to_bytes(8, 'little')\n            r += varstr(o.lock_script)\n\n        if sign_id is None and witness_type == 'segwit':\n            r += r_witness\n\n        r += self.locktime.to_bytes(4, 'little')\n        if sign_id is not None:\n            r += hash_type.to_bytes(4, 'little')\n        else:\n            if not self.size and b'' not in [i.unlocking_script for i in self.inputs]:\n                self.size = len(r)\n                self.calc_weight_units()\n        return r",
  "def raw_hex(self, sign_id=None, hash_type=SIGHASH_ALL, witness_type=None):\n        \"\"\"\n        Wrapper for raw() method. Return current raw transaction hex\n\n        :param sign_id: Create raw transaction which can be signed by transaction with this input ID\n        :type sign_id: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param witness_type: Serialize transaction with other witness type then default. Use to create legacy raw transaction for segwit transaction to create transaction signature ID's\n        :type witness_type: str\n\n        :return hexstring:\n        \"\"\"\n\n        return self.raw(sign_id, hash_type=hash_type, witness_type=witness_type).hex()",
  "def witness_data(self):\n        \"\"\"\n        Get witness data for all inputs of this transaction\n\n        :return bytes:\n        \"\"\"\n        witness_data = b''\n        for i in self.inputs:\n            witness_data += int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n        return witness_data",
  "def verify(self):\n        \"\"\"\n        Verify all inputs of a transaction, check if signatures match public key.\n\n        Does not check if UTXO is valid or has already been spent\n\n        :return bool: True if enough signatures provided and if all signatures are valid\n        \"\"\"\n\n        self.verified = False\n        for inp in self.inputs:\n            try:\n                transaction_hash = self.signature_hash(inp.index_n, inp.hash_type, inp.witness_type)\n            except TransactionError as e:\n                _logger.info(\"Could not create transaction hash. Error: %s\" % e)\n                return False\n            if not transaction_hash:\n                _logger.info(\"Need at least 1 key to create segwit transaction signature\")\n                return False\n            self.verified = inp.verify(transaction_hash)\n            if not self.verified:\n                return False\n\n        self.verified = True\n        return True",
  "def sign(self, keys=None, index_n=None, multisig_key_n=None, hash_type=SIGHASH_ALL, fail_on_unknown_key=True,\n             replace_signatures=False):\n        \"\"\"\n        Sign the transaction input with provided private key\n\n        :param keys: A private key or list of private keys\n        :type keys: HDKey, Key, bytes, list\n        :param index_n: Index of transaction input. Leave empty to sign all inputs\n        :type index_n: int\n        :param multisig_key_n: Index number of key for multisig input for segwit transactions. Leave empty if not known. If not specified all possibilities will be checked\n        :type multisig_key_n: int\n        :param hash_type: Specific hash type, default is SIGHASH_ALL\n        :type hash_type: int\n        :param fail_on_unknown_key: Method fails if public key from signature is not found in public key list\n        :type fail_on_unknown_key: bool\n        :param replace_signatures: Replace signature with new one if already signed.\n        :type replace_signatures: bool\n\n        :return None:\n        \"\"\"\n\n        if index_n is None:\n            tids = range(len(self.inputs))\n        else:\n            tids = [index_n]\n\n        if keys is None:\n            keys = []\n        elif not isinstance(keys, list):\n            keys = [keys]\n\n        for tid in tids:\n            n_signs = 0\n            tid_keys = [k if isinstance(k, (HDKey, Key)) else Key(k, compressed=self.inputs[tid].compressed)\n                        for k in keys]\n            for k in self.inputs[tid].keys:\n                if k.is_private and k not in tid_keys:\n                    tid_keys.append(k)\n            # If input does not contain any keys, try using provided keys\n            if not self.inputs[tid].keys:\n                self.inputs[tid].keys = tid_keys\n                self.inputs[tid].update_scripts(hash_type=hash_type)\n            if self.inputs[tid].script_type == 'coinbase':\n                raise TransactionError(\"Can not sign coinbase transactions\")\n            pub_key_list = [k.public_byte for k in self.inputs[tid].keys]\n            n_total_sigs = len(self.inputs[tid].keys)\n            sig_domain = [''] * n_total_sigs\n\n            txid = self.signature_hash(tid, witness_type=self.inputs[tid].witness_type)\n            for key in tid_keys:\n                # Check if signature signs known key and is not already in list\n                if key.public_byte not in pub_key_list:\n                    if fail_on_unknown_key:\n                        raise TransactionError(\"This key does not sign any known key: %s\" % key.public_hex)\n                    else:\n                        _logger.info(\"This key does not sign any known key: %s\" % key.public_hex)\n                        continue\n                if not replace_signatures and key in [x.public_key for x in self.inputs[tid].signatures]:\n                    _logger.info(\"Key %s already signed\" % key.public_hex)\n                    break\n\n                if not key.private_byte:\n                    raise TransactionError(\"Please provide a valid private key to sign the transaction\")\n                sig = sign(txid, key)\n                newsig_pos = pub_key_list.index(key.public_byte)\n                sig_domain[newsig_pos] = sig\n                n_signs += 1\n\n            if not n_signs:\n                break\n\n            # Add already known signatures on correct position\n            n_sigs_to_insert = len(self.inputs[tid].signatures)\n            for sig in self.inputs[tid].signatures:\n                if not sig.public_key:\n                    break\n                newsig_pos = pub_key_list.index(sig.public_key.public_byte)\n                if sig_domain[newsig_pos] == '':\n                    sig_domain[newsig_pos] = sig\n                    n_sigs_to_insert -= 1\n            if n_sigs_to_insert:\n                for sig in self.inputs[tid].signatures:\n                    free_positions = [i for i, s in enumerate(sig_domain) if s == '']\n                    for pos in free_positions:\n                        sig_domain[pos] = sig\n                        n_sigs_to_insert -= 1\n                        break\n            if n_sigs_to_insert:\n                _logger.info(\"Some signatures are replaced with the signatures of the provided keys\")\n            self.inputs[tid].signatures = [s for s in sig_domain if s != '']\n            self.inputs[tid].update_scripts(hash_type)",
  "def sign_and_update(self, index_n=None):\n        \"\"\"\n        Update transaction ID and resign. Use if some properties of the transaction changed\n\n        :param index_n: Index of transaction input. Leave empty to sign all inputs\n        :type index_n: int\n\n        :return:\n        \"\"\"\n\n        self.version = self.version_int.to_bytes(4, 'big')\n        self.sign(index_n=index_n, replace_signatures=True)\n        self.txid = self.signature_hash()[::-1].hex()\n        self.size = len(self.raw())\n        self.calc_weight_units()\n        self.update_totals()\n        if self.fee:\n            self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)",
  "def add_input(self, prev_txid, output_n, keys=None, signatures=None, public_hash=b'', unlocking_script=b'',\n                  unlocking_script_unsigned=None, script_type=None, address='',\n                  sequence=0xffffffff, compressed=True, sigs_required=None, sort=False, index_n=None,\n                  value=None, double_spend=False, locktime_cltv=None, locktime_csv=None,\n                  key_path='', witness_type=None, witnesses=None, encoding=None, strict=True):\n        \"\"\"\n        Add input to this transaction\n\n        Wrapper for append method of Input class.\n\n        :param prev_txid: Transaction hash of the UTXO (previous output) which will be spent.\n        :type prev_txid: bytes, hexstring\n        :param output_n: Output number in previous transaction.\n        :type output_n: bytes, int\n        :param keys: Public keys can be provided to construct an Unlocking script. Optional\n        :type keys: bytes, str\n        :param signatures: Add signatures to input if already known\n        :type signatures: bytes, str\n        :param public_hash: Specify public hash from key or redeemscript if key is not available\n        :type public_hash: bytes\n        :param unlocking_script: Unlocking script (scriptSig) to prove ownership. Optional\n        :type unlocking_script: bytes, hexstring\n        :param unlocking_script_unsigned: TODO: find better name...\n        :type unlocking_script_unsigned: bytes, str\n        :param script_type: Type of unlocking script used, i.e. p2pkh or p2sh_multisig. Default is p2pkh\n        :type script_type: str\n        :param address: Specify address of input if known, default is to derive from key or scripts\n        :type address: str, Address\n        :param sequence: Sequence part of input, used for timelocked transactions\n        :type sequence: int, bytes\n        :param compressed: Use compressed or uncompressed public keys. Default is compressed\n        :type compressed: bool\n        :param sigs_required: Number of signatures required for a p2sh_multisig unlocking script\n        :param sigs_required: int\n        :param sort: Sort public keys according to BIP0045 standard. Default is False to avoid unexpected change of key order.\n        :type sort: boolean\n        :param index_n: Index number of position in transaction, leave empty to add input to end of inputs list\n        :type index_n: int\n        :param value: Value of input\n        :type value: int\n        :param double_spend: True if double spend is detected, depends on which service provider is selected\n        :type double_spend: bool\n        :param locktime_cltv: Check Lock Time Verify value. Script level absolute time lock for this input\n        :type locktime_cltv: int\n        :param locktime_csv: Check Sequency Verify value.\n        :type locktime_csv: int\n        :param key_path: Key path of input key as BIP32 string or list\n        :type key_path: str, list\n        :param witness_type: Specify witness/signature position: 'segwit' or 'legacy'. Determine from script, address or encoding if not specified.\n        :type witness_type: str\n        :param witnesses: List of witnesses for inputs, used for segwit transactions for instance.\n        :type witnesses: list of bytes, list of str\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty to derive from script or script type\n        :type encoding: str\n        :param strict: Raise exception when input is malformed or incomplete\n        :type strict: bool\n\n        :return int: Transaction index number (index_n)\n        \"\"\"\n\n        if index_n is None:\n            index_n = len(self.inputs)\n        sequence_int = sequence\n        if isinstance(sequence, bytes):\n            sequence_int = int.from_bytes(sequence, 'little')\n        if self.version == b'\\x00\\x00\\x00\\x01' and 0 < sequence_int < SEQUENCE_LOCKTIME_DISABLE_FLAG:\n            self.version = b'\\x00\\x00\\x00\\x02'\n            self.version_int = 2\n        self.inputs.append(\n            Input(prev_txid=prev_txid, output_n=output_n, keys=keys, signatures=signatures, public_hash=public_hash,\n                  unlocking_script=unlocking_script, unlocking_script_unsigned=unlocking_script_unsigned,\n                  script_type=script_type, address=address, sequence=sequence, compressed=compressed,\n                  sigs_required=sigs_required, sort=sort, index_n=index_n, value=value, double_spend=double_spend,\n                  locktime_cltv=locktime_cltv, locktime_csv=locktime_csv, key_path=key_path, witness_type=witness_type,\n                  witnesses=witnesses, encoding=encoding, strict=strict, network=self.network.name))\n        return index_n",
  "def add_output(self, value, address='', public_hash=b'', public_key=b'', lock_script=b'', spent=False,\n                   output_n=None, encoding=None, spending_txid=None, spending_index_n=None, strict=True):\n        \"\"\"\n        Add an output to this transaction\n\n        Wrapper for the append method of the Output class.\n\n        :param value: Value of output in the smallest denominator of currency, for example satoshi's for bitcoins\n        :type value: int\n        :param address: Destination address of output. Leave empty to derive from other attributes you provide.\n        :type address: str, Address\n        :param public_hash: Hash of public key or script\n        :type public_hash: bytes, str\n        :param public_key: Destination public key\n        :type public_key: bytes, str\n        :param lock_script: Locking script of output. If not provided a default unlocking script will be provided with a public key hash.\n        :type lock_script: bytes, str\n        :param spent: Has output been spent in new transaction?\n        :type spent: bool, None\n        :param output_n: Index number of output in transaction\n        :type output_n: int\n        :param encoding: Address encoding used. For example bech32/base32 or base58. Leave empty for to derive from script or script type\n        :type encoding: str\n        :param spending_txid: Transaction hash of input spending this transaction output\n        :type spending_txid: str\n        :param spending_index_n: Index number of input spending this transaction output\n        :type spending_index_n: int\n        :param strict: Raise exception when output is malformed or incomplete\n        :type strict: bool\n\n        :return int: Transaction output number (output_n)\n        \"\"\"\n\n        lock_script = to_bytes(lock_script)\n        if output_n is None:\n            output_n = len(self.outputs)\n        if not float(value).is_integer():\n            raise TransactionError(\"Output must be of type integer and contain no decimals\")\n        if lock_script.startswith(b'\\x6a'):\n            if value != 0:\n                raise TransactionError(\"Output value for OP_RETURN script must be 0\")\n        self.outputs.append(Output(value=int(value), address=address, public_hash=public_hash,\n                                   public_key=public_key, lock_script=lock_script, spent=spent, output_n=output_n,\n                                   encoding=encoding, spending_txid=spending_txid, spending_index_n=spending_index_n,\n                                   strict=strict, network=self.network.name))\n        return output_n",
  "def merge_transaction(self, transaction):\n        \"\"\"\n        Merge this transaction with provided Transaction object.\n\n        Add all inputs and outputs of a transaction to this Transaction object. Because the transaction signature\n        changes with this operation, the transaction inputs need to be signed again.\n\n        Can be used to implement CoinJoin. Where two or more unrelated Transactions are merged into 1 transaction\n        to safe fees and increase privacy.\n\n        :param transaction: The transaction to be merged\n        :type transaction: Transaction\n\n        \"\"\"\n        self.inputs += transaction.inputs\n        self.outputs += transaction.outputs\n        self.shuffle()\n        self.update_totals()\n        self.sign_and_update()",
  "def estimate_size(self, number_of_change_outputs=0):\n        \"\"\"\n        Get estimated vsize in for current transaction based on transaction type and number of inputs and outputs.\n\n        For old-style legacy transaction the vsize is the length of the transaction. In segwit transaction the\n        witness data has less weight. The formula used is: math.ceil(((est_size-witness_size) * 3 + est_size) / 4)\n\n        :param number_of_change_outputs: Number of change outputs, default is 0\n        :type number_of_change_outputs: int\n\n        :return int: Estimated transaction size\n        \"\"\"\n\n        # if self.input_total and self.output_total + self.fee == self.input_total:\n        #     add_change_output = False\n        est_size = 12\n        witness_size = 2\n        if self.witness_type != 'legacy':\n            est_size += 2\n        # TODO: if no inputs assume 1 input\n        if not self.inputs:\n            est_size += 125\n            witness_size += 72\n        for inp in self.inputs:\n            est_size += 40\n            scr_size = 0\n            if inp.witness_type != 'legacy':\n                est_size += 1\n            if inp.unlocking_script and len(inp.signatures) >= inp.sigs_required:\n                scr_size += len(varstr(inp.unlocking_script))\n                if inp.witness_type == 'p2sh-segwit':\n                    scr_size += sum([1 + len(w) for w in inp.witnesses])\n            else:\n                if inp.script_type == 'sig_pubkey':\n                    scr_size += 107\n                    if not inp.compressed:\n                        scr_size += 33\n                    if inp.witness_type == 'p2sh-segwit':\n                        scr_size += 24\n                # elif inp.script_type in ['p2sh_multisig', 'p2sh_p2wpkh', 'p2sh_p2wsh']:\n                elif inp.script_type == 'p2sh_multisig':\n                    scr_size += 9 + (len(inp.keys) * 34) + (inp.sigs_required * 72)\n                    if inp.witness_type == 'p2sh-segwit':\n                        scr_size += 17 * inp.sigs_required\n                elif inp.script_type == 'signature':\n                    scr_size += 9 + 72\n                else:\n                    raise TransactionError(\"Unknown input script type %s cannot estimate transaction size\" %\n                                           inp.script_type)\n            est_size += scr_size\n            witness_size += scr_size\n        for outp in self.outputs:\n            est_size += 8\n            if outp.lock_script:\n                est_size += len(varstr(outp.lock_script))\n            else:\n                raise TransactionError(\"Need locking script for output %d to estimate size\" % outp.output_n)\n        if number_of_change_outputs:\n            is_multisig = True if self.inputs and self.inputs[0].script_type == 'p2sh_multisig' else False\n            co_size = 8\n            if not self.inputs or self.inputs[0].witness_type == 'legacy':\n                co_size += 24 if is_multisig else 26\n            elif self.inputs[0].witness_type == 'p2sh-segwit':\n                co_size += 24\n            else:\n                co_size += 33 if is_multisig else 23\n            est_size += (number_of_change_outputs * co_size)\n        self.size = est_size\n        self.vsize = est_size\n        if self.witness_type == 'legacy':\n            return est_size\n        else:\n            self.vsize = math.ceil((((est_size - witness_size) * 3 + est_size) / 4) - 1.5)\n            return self.vsize",
  "def calc_weight_units(self):\n        \"\"\"\n        Calculate weight units and vsize for this Transaction. Weight units are used to determine fee.\n\n        :return int:\n        \"\"\"\n        if not self.size:\n            return None\n        witness_data_size = len(self.witness_data())\n        wu = self.size * 4\n        if self.witness_type == 'segwit' and witness_data_size > 1:\n            wu = wu - 6  # for segwit marker and flag\n            wu = wu - witness_data_size * 3\n        self.vsize = math.ceil(wu / 4)\n        return wu",
  "def weight_units(self):\n        return self.calc_weight_units()",
  "def calculate_fee(self):\n        \"\"\"\n        Get fee for this transaction in the smallest denominator (i.e. Satoshi) based on its size and the\n        transaction.fee_per_kb value\n\n        :return int: Estimated transaction fee\n        \"\"\"\n\n        if not self.fee_per_kb:\n            raise TransactionError(\"Cannot calculate transaction fees: transaction.fee_per_kb is not set\")\n        if self.fee_per_kb < self.network.fee_min:\n            self.fee_per_kb = self.network.fee_min\n        elif self.fee_per_kb > self.network.fee_max:\n            self.fee_per_kb = self.network.fee_max\n        if not self.vsize:\n            self.estimate_size()\n        fee = int(self.vsize / 1000.0 * self.fee_per_kb)\n        return fee",
  "def update_totals(self):\n        \"\"\"\n        Update input_total, output_total and fee according to inputs and outputs of this transaction\n\n        :return int:\n        \"\"\"\n\n        self.input_total = sum([i.value for i in self.inputs if i.value])\n        self.output_total = sum([o.value for o in self.outputs if o.value])\n        if self.coinbase:\n            self.input_total = self.output_total\n        # self.fee = 0\n        if self.input_total:\n            self.fee = self.input_total - self.output_total\n            if self.vsize:\n                self.fee_per_kb = int((self.fee / float(self.vsize)) * 1000)",
  "def save(self, filename=None):\n        \"\"\"\n        Store transaction object as file, so it can be imported in bitcoinlib later with the :func:`load` method.\n\n        :param filename: Location and name of file, leave empty to store transaction in bitcoinlib data directory: .bitcoinlib/<transaction_id.tx)\n        :type filename: str\n\n        :return:\n        \"\"\"\n        if not filename:\n            p = Path(BCL_DATA_DIR, '%s.tx' % self.txid)\n        else:\n            p = Path(filename)\n            if not p.parent or str(p.parent) == '.':\n                p = Path(BCL_DATA_DIR, filename)\n        f = p.open('wb')\n        pickle.dump(self, f)\n        f.close()",
  "def shuffle_inputs(self):\n        \"\"\"\n        Shuffle transaction inputs in random order.\n\n        :return:\n        \"\"\"\n        random.shuffle(self.inputs)\n        for idx, o in enumerate(self.inputs):\n            o.index_n = idx",
  "def shuffle_outputs(self):\n        \"\"\"\n        Shuffle transaction outputs in random order.\n\n        :return:\n        \"\"\"\n        random.shuffle(self.outputs)\n        for idx, o in enumerate(self.outputs):\n            o.output_n = idx",
  "def shuffle(self):\n        \"\"\"\n        Shuffle transaction inputs and outputs in random order.\n\n        :return:\n        \"\"\"\n        self.shuffle_inputs()\n        self.shuffle_outputs()",
  "class WitnessTypeTransactions(enum.Enum):\n    legacy = \"legacy\"\n    segwit = \"segwit\"",
  "class DbCache:\n    \"\"\"\n    Cache Database object. Initialize database and open session when creating database object.\n\n    Create new database if is doesn't exist yet\n\n    \"\"\"\n    def __init__(self, db_uri=None):\n        self.engine = None\n        self.session = None\n        if db_uri is None:\n            db_uri = DEFAULT_DATABASE_CACHE\n        elif not db_uri:\n            return\n        self.o = urlparse(db_uri)\n\n        if not self.o.scheme or len(self.o.scheme) < 2:\n            db_uri = 'sqlite:///%s' % db_uri\n        if db_uri.startswith(\"sqlite://\") and ALLOW_DATABASE_THREADS:\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += \"check_same_thread=False\"\n        if self.o.scheme == 'mysql':\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += 'binary_prefix=true'\n        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')\n\n        Session = sessionmaker(bind=self.engine)\n        Base.metadata.create_all(self.engine)\n        self.db_uri = db_uri\n        _logger.info(\"Using cache database: %s://%s:%s/%s\" % (self.o.scheme or '', self.o.hostname or '',\n                                                              self.o.port or '', self.o.path or ''))\n        self.session = Session()\n\n    def drop_db(self):\n        self.session.commit()\n        # self.session.close_all()\n        close_all_sessions()\n        Base.metadata.drop_all(self.engine)",
  "class DbCacheTransactionNode(Base):\n    \"\"\"\n    Link table for cache transactions and addresses\n    \"\"\"\n    __tablename__ = 'cache_transactions_node'\n    txid = Column(LargeBinary(32), ForeignKey('cache_transactions.txid'), primary_key=True)\n    transaction = relationship(\"DbCacheTransaction\", back_populates='nodes', doc=\"Related transaction object\")\n    index_n = Column(Integer, primary_key=True, doc=\"Order of input/output in this transaction\")\n    value = Column(BigInteger, default=0, doc=\"Value of transaction input\")\n    address = Column(String(255), index=True, doc=\"Address string base32 or base58 encoded\")\n    script = Column(LargeBinary, doc=\"Locking or unlocking script\")\n    witnesses = Column(LargeBinary, doc=\"Witnesses (signatures) used in Segwit transaction inputs\")\n    sequence = Column(BigInteger, default=0xffffffff,\n                      doc=\"Transaction sequence number. Used for timelock transaction inputs\")\n    is_input = Column(Boolean, primary_key=True, doc=\"True if input, False if output\")\n    spent = Column(Boolean, default=None, doc=\"Is output spent?\")\n    ref_txid = Column(LargeBinary(32), index=True, doc=\"Transaction hash of input which spends this output\")\n    ref_index_n = Column(BigInteger, doc=\"Index number of transaction input which spends this output\")\n\n    def prev_txid(self):\n        if self.is_input:\n            return self.ref_txid\n\n    def output_n(self):\n        if self.is_input:\n            return self.ref_index_n\n\n    def spending_txid(self):\n        if not self.is_input:\n            return self.ref_txid\n\n    def spending_index_n(self):\n        if not self.is_input:\n            return self.ref_index_n",
  "class DbCacheTransaction(Base):\n    \"\"\"\n    Transaction Cache Table\n\n    Database which stores transactions received from service providers as cache\n\n    \"\"\"\n    __tablename__ = 'cache_transactions'\n    txid = Column(LargeBinary(32), primary_key=True, doc=\"Hexadecimal representation of transaction hash or transaction ID\")\n    date = Column(DateTime, doc=\"Date when transaction was confirmed and included in a block\")\n    version = Column(BigInteger, default=1,\n                     doc=\"Tranaction version. Default is 1 but some wallets use another version number\")\n    locktime = Column(BigInteger, default=0,\n                      doc=\"Transaction level locktime. Locks the transaction until a specified block \"\n                          \"(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970).\"\n                          \" Default value is 0 for transactions without locktime\")\n    confirmations = Column(Integer, default=0,\n                           doc=\"Number of confirmation when this transaction is included in a block. \"\n                               \"Default is 0: unconfirmed\")\n    block_height = Column(Integer, index=True, doc=\"Height of block this transaction is included in\")\n    network_name = Column(String(20), doc=\"Blockchain network name of this transaction\")\n    fee = Column(BigInteger, doc=\"Transaction fee\")\n    nodes = relationship(\"DbCacheTransactionNode\", cascade=\"all,delete\",\n                         doc=\"List of all inputs and outputs as DbCacheTransactionNode objects\")\n    order_n = Column(Integer, doc=\"Order of transaction in block\")\n    witness_type = Column(Enum(WitnessTypeTransactions), default=WitnessTypeTransactions.legacy,\n                          doc=\"Transaction type enum: legacy or segwit\")",
  "class DbCacheAddress(Base):\n    \"\"\"\n    Address Cache Table\n\n    Stores transactions and unspent outputs (UTXO's) per address\n\n    \"\"\"\n    __tablename__ = 'cache_address'\n    address = Column(String(255), primary_key=True, doc=\"Address string base32 or base58 encoded\")\n    network_name = Column(String(20), doc=\"Blockchain network name of this transaction\")\n    balance = Column(BigInteger, default=0, doc=\"Total balance of UTXO's linked to this key\")\n    last_block = Column(Integer, doc=\"Number of last updated block\")\n    last_txid = Column(LargeBinary(32), doc=\"Transaction ID of latest transaction in cache\")\n    n_utxos = Column(Integer, doc=\"Total number of UTXO's for this address\")\n    n_txs = Column(Integer, doc=\"Total number of transactions for this address\")",
  "class DbCacheBlock(Base):\n    \"\"\"\n    Block Cache Table\n\n    Stores block headers\n    \"\"\"\n    __tablename__ = 'cache_blocks'\n    height = Column(Integer, primary_key=True, doc=\"Height or sequence number for this block\")\n    block_hash = Column(LargeBinary(32), index=True, doc=\"Hash of this block\")\n    network_name = Column(String(20), doc=\"Blockchain network name\")\n    version = Column(BigInteger, doc=\"Block version to specify which features are used (hex)\")\n    prev_block = Column(LargeBinary(32), doc=\"Block hash of previous block\")\n    merkle_root = Column(LargeBinary(32), doc=\"Merkle root used to validate transaction in block\")\n    time = Column(BigInteger, doc=\"Timestamp to indicated when block was created\")\n    bits = Column(BigInteger, doc=\"Encoding for proof-of-work, used to determine target and difficulty\")\n    nonce = Column(BigInteger, doc=\"Nonce (number used only once or n-once) is used to create different block hashes\")\n    tx_count = Column(Integer, doc=\"Number of transactions included in this block\")",
  "class DbCacheVars(Base):\n    \"\"\"\n    Table to store various blockchain related variables\n    \"\"\"\n    __tablename__ = 'cache_variables'\n    varname = Column(String(50), primary_key=True, doc=\"Variable unique name\")\n    network_name = Column(String(20), primary_key=True, doc=\"Blockchain network name of this transaction\")\n    value = Column(String(255), doc=\"Value of variable\")\n    type = Column(String(20), doc=\"Type of variable: int, string or float\")\n    expires = Column(DateTime, doc=\"Datetime value when variable expires\")",
  "def __init__(self, db_uri=None):\n        self.engine = None\n        self.session = None\n        if db_uri is None:\n            db_uri = DEFAULT_DATABASE_CACHE\n        elif not db_uri:\n            return\n        self.o = urlparse(db_uri)\n\n        if not self.o.scheme or len(self.o.scheme) < 2:\n            db_uri = 'sqlite:///%s' % db_uri\n        if db_uri.startswith(\"sqlite://\") and ALLOW_DATABASE_THREADS:\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += \"check_same_thread=False\"\n        if self.o.scheme == 'mysql':\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += 'binary_prefix=true'\n        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')\n\n        Session = sessionmaker(bind=self.engine)\n        Base.metadata.create_all(self.engine)\n        self.db_uri = db_uri\n        _logger.info(\"Using cache database: %s://%s:%s/%s\" % (self.o.scheme or '', self.o.hostname or '',\n                                                              self.o.port or '', self.o.path or ''))\n        self.session = Session()",
  "def drop_db(self):\n        self.session.commit()\n        # self.session.close_all()\n        close_all_sessions()\n        Base.metadata.drop_all(self.engine)",
  "def prev_txid(self):\n        if self.is_input:\n            return self.ref_txid",
  "def output_n(self):\n        if self.is_input:\n            return self.ref_index_n",
  "def spending_txid(self):\n        if not self.is_input:\n            return self.ref_txid",
  "def spending_index_n(self):\n        if not self.is_input:\n            return self.ref_index_n",
  "def script_type_default(witness_type=None, multisig=False, locking_script=False):\n    \"\"\"\n    Determine default script type for provided witness type and key type combination used in this library.\n\n    >>> script_type_default('segwit', locking_script=True)\n    'p2wpkh'\n\n    :param witness_type: Witness type used: standard, p2sh-segwit or segwit\n    :type witness_type: str\n    :param multisig: Multi-signature key or not, default is False\n    :type multisig: bool\n    :param locking_script: Limit search to locking_script. Specify False for locking scripts and True for unlocking scripts\n    :type locking_script: bool\n\n    :return str: Default script type\n    \"\"\"\n\n    if not witness_type:\n        return None\n    if witness_type == 'legacy' and not multisig:\n        return 'p2pkh' if locking_script else 'sig_pubkey'\n    elif witness_type == 'legacy' and multisig:\n        return 'p2sh' if locking_script else 'p2sh_multisig'\n    elif witness_type == 'segwit' and not multisig:\n        return 'p2wpkh' if locking_script else 'sig_pubkey'\n    elif witness_type == 'segwit' and multisig:\n        return 'p2wsh' if locking_script else 'p2sh_multisig'\n    elif witness_type == 'p2sh-segwit' and not multisig:\n        return 'p2sh' if locking_script else 'p2sh_p2wpkh'\n    elif witness_type == 'p2sh-segwit' and multisig:\n        return 'p2sh' if locking_script else 'p2sh_p2wsh'\n    else:\n        raise ValueError(\"Wallet and key type combination not supported: %s / %s\" % (witness_type, multisig))",
  "def get_encoding_from_witness(witness_type=None):\n    \"\"\"\n    Derive address encoding (base58 or bech32) from transaction witness type.\n\n    Returns 'base58' for legacy and p2sh-segwit witness type and 'bech32' for segwit\n\n    :param witness_type: Witness type: legacy, p2sh-segwit or segwit\n    :type witness_type: str\n\n    :return str:\n    \"\"\"\n\n    if witness_type == 'segwit':\n        return 'bech32'\n    elif witness_type in [None, 'legacy', 'p2sh-segwit']:\n        return 'base58'\n    else:\n        raise ValueError(\"Unknown witness type %s\" % witness_type)",
  "def deprecated(func):\n    \"\"\"\n    This is a decorator which can be used to mark functions as deprecated. It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    @functools.wraps(func)\n    def new_func(*args, **kwargs):\n        logging.warning(\"Call to deprecated function {}.\".format(func.__name__))\n        return func(*args, **kwargs)\n    \n    return new_func",
  "def new_func(*args, **kwargs):\n        logging.warning(\"Call to deprecated function {}.\".format(func.__name__))\n        return func(*args, **kwargs)",
  "def compile_largebinary_mysql(type_, compiler, **kwargs):\n    length = type_.length\n    element = \"BLOB\" if not length else \"VARBINARY(%d)\" % length\n    return element",
  "class Db:\n    \"\"\"\n    Bitcoinlib Database object used by Service() and HDWallet() class. Initialize database and open session when\n    creating database object.\n\n    Create new database if is doesn't exist yet\n\n    \"\"\"\n    def __init__(self, db_uri=None, password=None):\n        if db_uri is None:\n            db_uri = DEFAULT_DATABASE\n        self.o = urlparse(db_uri)\n        if not self.o.scheme or \\\n                len(self.o.scheme) < 2:  # Dirty hack to avoid issues with urlparse on Windows confusing drive with scheme\n            if password:\n                # Warning: This requires the pysqlcipher3 module\n                db_uri = 'sqlite+pysqlcipher://:%s@/%s?cipher=aes-256-cfb&kdf_iter=64000' % (password, db_uri)\n            else:\n                db_uri = 'sqlite:///%s' % db_uri\n        elif password:\n            raise NotImplementedError(\"Password protection is only available for sqlite databases at the moment\")\n\n        if db_uri.startswith(\"sqlite\") and ALLOW_DATABASE_THREADS:\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += \"check_same_thread=False\"\n        if self.o.scheme == 'mysql':\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += 'binary_prefix=true'\n        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')\n\n        Session = sessionmaker(bind=self.engine)\n        Base.metadata.create_all(self.engine)\n        self._import_config_data(Session)\n        self.session = Session()\n\n        _logger.info(\"Using database: %s://%s:%s/%s\" % (self.o.scheme or '', self.o.hostname or '',\n                                                        self.o.port or '', self.o.path or ''))\n        self.db_uri = db_uri\n\n        # VERIFY AND UPDATE DATABASE\n        # Just a very simple database update script, without any external libraries for now\n        #\n        version_db = self.session.query(DbConfig.value).filter_by(variable='version').scalar()\n        if version_db[:3] == '0.4' and BITCOINLIB_VERSION[:3] >= '0.5':\n            raise ValueError(\"Old database version found (<0.4.19). Can not convert to >0.5 version database \"\n                             \"automatically, use updatedb.py tool to update\")\n        try:\n            if BITCOINLIB_VERSION != version_db:\n                _logger.warning(\"BitcoinLib database (%s) is from different version then library code (%s). \"\n                                \"Let's try to update database.\" % (version_db, BITCOINLIB_VERSION))\n                db_update(self, version_db, BITCOINLIB_VERSION)\n        except Exception as e:\n            _logger.warning(\"Error when verifying version or updating database: %s\" % e)\n\n    def drop_db(self, yes_i_am_sure=False):\n        if yes_i_am_sure:\n            self.session.commit()\n            self.session.close_all()\n            close_all_sessions()\n            Base.metadata.drop_all(self.engine)\n\n    @staticmethod\n    def _import_config_data(ses):\n        session = ses()\n        installation_date = session.query(DbConfig.value).filter_by(variable='installation_date').scalar()\n        if not installation_date:\n            session.merge(DbConfig(variable='version', value=BITCOINLIB_VERSION))\n            session.merge(DbConfig(variable='installation_date', value=str(datetime.now())))\n            url = ''\n            try:\n                url = str(session.bind.url)\n            except Exception:\n                pass\n            session.merge(DbConfig(variable='installation_url', value=url))\n            session.commit()\n        session.close()",
  "def add_column(engine, table_name, column):\n    \"\"\"\n    Used to add new column to database with migration and update scripts\n\n    :param engine:\n    :param table_name:\n    :param column:\n    :return:\n    \"\"\"\n    column_name = column.compile(dialect=engine.dialect)\n    column_type = column.type.compile(engine.dialect)\n    engine.execute(\"ALTER TABLE %s ADD COLUMN %s %s\" % (table_name, column_name, column_type))",
  "class EncryptedBinary(TypeDecorator):\n    \"\"\"\n    FieldType for encrypted Binary storage using EAS encryption\n    \"\"\"\n\n    impl = LargeBinary\n    cache_ok = True\n    key = None\n    if DATABASE_ENCRYPTION_ENABLED:\n        if not DB_FIELD_ENCRYPTION_KEY:\n            _logger.warning(\"Database encryption is enabled but value DB_FIELD_ENCRYPTION_KEY not found in \"\n                            \"environment. Please supply 32 bytes key as hexadecimal string.\")\n        else:\n            key = bytes().fromhex(DB_FIELD_ENCRYPTION_KEY)\n\n    def process_bind_param(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_encrypt(value, self.key)\n\n    def process_result_value(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_decrypt(value, self.key)",
  "class EncryptedString(TypeDecorator):\n    \"\"\"\n    FieldType for encrypted String storage using EAS encryption\n    \"\"\"\n\n    impl = String\n    cache_ok = True\n    key = None\n    if DATABASE_ENCRYPTION_ENABLED:\n        if not DB_FIELD_ENCRYPTION_KEY:\n            _logger.warning(\"Database encryption is enabled but value DB_FIELD_ENCRYPTION_KEY not found in \"\n                            \"environment. Please supply 32 bytes key as hexadecimal string.\")\n        else:\n            impl = LargeBinary\n            key = bytes().fromhex(DB_FIELD_ENCRYPTION_KEY)\n\n    def process_bind_param(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        if not isinstance(value, bytes):\n            value = bytes(value, 'utf8')\n        return aes_encrypt(value, self.key)\n\n    def process_result_value(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_decrypt(value, self.key).decode('utf8')",
  "class DbConfig(Base):\n    \"\"\"\n    BitcoinLib configuration variables\n\n    \"\"\"\n    __tablename__ = 'config'\n    variable = Column(String(30), primary_key=True)\n    value = Column(String(255))",
  "class DbWallet(Base):\n    \"\"\"\n    Database definitions for wallets in Sqlalchemy format\n\n    Contains one or more keys.\n\n    \"\"\"\n    __tablename__ = 'wallets'\n    id = Column(Integer, Sequence('wallet_id_seq'), primary_key=True, doc=\"Unique wallet ID\")\n    name = Column(String(80), unique=True, doc=\"Unique wallet name\")\n    owner = Column(String(50), doc=\"Wallet owner\")\n    network_name = Column(String(20), ForeignKey('networks.name'), doc=\"Name of network, i.e.: bitcoin, litecoin\")\n    network = relationship(\"DbNetwork\", doc=\"Link to DbNetwork object\")\n    purpose = Column(Integer,\n                     doc=\"Wallet purpose ID. BIP-44 purpose field, indicating which key-scheme is used default is 44\")\n    scheme = Column(String(25), doc=\"Key structure type, can be BIP-32 or single\")\n    witness_type = Column(String(20), default='legacy',\n                          doc=\"Wallet witness type. Can be 'legacy', 'segwit' or 'p2sh-segwit'. Default is legacy.\")\n    encoding = Column(String(15), default='base58',\n                      doc=\"Default encoding to use for address generation, i.e. base58 or bech32. Default is base58.\")\n    main_key_id = Column(Integer,\n                         doc=\"Masterkey ID for this wallet. All other keys are derived from the masterkey in a \"\n                             \"HD wallet bip32 wallet\")\n    keys = relationship(\"DbKey\", back_populates=\"wallet\", doc=\"Link to keys (DbKeys objects) in this wallet\")\n    transactions = relationship(\"DbTransaction\", back_populates=\"wallet\",\n                                doc=\"Link to transaction (DbTransactions) in this wallet\")\n    multisig_n_required = Column(Integer, default=1, doc=\"Number of required signature for multisig, \"\n                                                         \"only used for multisignature master key\")\n    sort_keys = Column(Boolean, default=False, doc=\"Sort keys in multisig wallet\")\n    parent_id = Column(Integer, ForeignKey('wallets.id'), doc=\"Wallet ID of parent wallet, used in multisig wallets\")\n    children = relationship(\"DbWallet\", lazy=\"joined\", join_depth=2,\n                            doc=\"Wallet IDs of children wallets, used in multisig wallets\")\n    multisig = Column(Boolean, default=True, doc=\"Indicates if wallet is a multisig wallet. Default is True\")\n    cosigner_id = Column(Integer,\n                         doc=\"ID of cosigner of this wallet. Used in multisig wallets to differentiate between \"\n                             \"different wallets\")\n    key_path = Column(String(100),\n                      doc=\"Key path structure used in this wallet. Key path for multisig wallet, use to create \"\n                          \"your own non-standard key path. Key path must follow the following rules: \"\n                          \"* Path start with masterkey (m) and end with change / address_index \"\n                          \"* If accounts are used, the account level must be 3. I.e.: m/purpose/coin_type/account/ \"\n                          \"* All keys must be hardened, except for change, address_index or cosigner_id \"\n                          \" Max length of path is 8 levels\")\n    default_account_id = Column(Integer, doc=\"ID of default account for this wallet if multiple accounts are used\")\n\n    __table_args__ = (\n        CheckConstraint(scheme.in_(['single', 'bip32']), name='constraint_allowed_schemes'),\n        CheckConstraint(encoding.in_(['base58', 'bech32']), name='constraint_default_address_encodings_allowed'),\n        CheckConstraint(witness_type.in_(['legacy', 'segwit', 'p2sh-segwit']), name='wallet_constraint_allowed_types'),\n    )\n\n    def __repr__(self):\n        return \"<DbWallet(name='%s', network='%s'>\" % (self.name, self.network_name)",
  "class DbKeyMultisigChildren(Base):\n    \"\"\"\n    Use many-to-many relationship for multisig keys. A multisig keys contains 2 or more child keys\n    and a child key can be used in more then one multisig key.\n\n    \"\"\"\n    __tablename__ = 'key_multisig_children'\n\n    parent_id = Column(Integer, ForeignKey('keys.id'), primary_key=True)\n    child_id = Column(Integer, ForeignKey('keys.id'), primary_key=True)\n    key_order = Column(Integer, Sequence('key_multisig_children_id_seq'))",
  "class DbKey(Base):\n    \"\"\"\n    Database definitions for keys in Sqlalchemy format\n\n    Part of a wallet, and used by transactions\n\n    \"\"\"\n    __tablename__ = 'keys'\n    id = Column(Integer, Sequence('key_id_seq'), primary_key=True, doc=\"Unique Key ID\")\n    parent_id = Column(Integer, Sequence('parent_id_seq'), doc=\"Parent Key ID. Used in HD wallets\")\n    name = Column(String(80), index=True, doc=\"Key name string\")\n    account_id = Column(Integer, index=True, doc=\"ID of account if key is part of a HD structure\")\n    depth = Column(Integer,\n                   doc=\"Depth of key if it is part of a HD structure. Depth=0 means masterkey, \"\n                       \"depth=1 are the masterkeys children.\")\n    change = Column(Integer, doc=\"Change or normal address: Normal=0, Change=1\")\n    address_index = Column(BigInteger, doc=\"Index of address in HD key structure address level\")\n    public = Column(LargeBinary(128), index=True, doc=\"Bytes representation of public key\")\n    private = Column(EncryptedBinary(48), doc=\"Bytes representation of private key\")\n    wif = Column(EncryptedString(255), index=True, doc=\"Public or private WIF (Wallet Import Format) representation\")\n    compressed = Column(Boolean, default=True, doc=\"Is key compressed or not. Default is True\")\n    key_type = Column(String(10), default='bip32', doc=\"Type of key: single, bip32 or multisig. Default is bip32\")\n    address = Column(String(255), index=True,\n                     doc=\"Address representation of key. An cryptocurrency address is a hash of the public key\")\n    cosigner_id = Column(Integer, doc=\"ID of cosigner, used if key is part of HD Wallet\")\n    encoding = Column(String(15), default='base58', doc='Encoding used to represent address: base58 or bech32')\n    purpose = Column(Integer, default=44, doc=\"Purpose ID, default is 44\")\n    is_private = Column(Boolean, doc=\"Is key private or not?\")\n    path = Column(String(100), doc=\"String of BIP-32 key path\")\n    wallet_id = Column(Integer, ForeignKey('wallets.id'), index=True, doc=\"Wallet ID which contains this key\")\n    wallet = relationship(\"DbWallet\", back_populates=\"keys\", doc=\"Related Wallet object\")\n    transaction_inputs = relationship(\"DbTransactionInput\", cascade=\"all,delete\", back_populates=\"key\",\n                                      doc=\"All DbTransactionInput objects this key is part of\")\n    transaction_outputs = relationship(\"DbTransactionOutput\", cascade=\"all,delete\", back_populates=\"key\",\n                                       doc=\"All DbTransactionOutput objects this key is part of\")\n    balance = Column(BigInteger, default=0, doc=\"Total balance of UTXO's linked to this key\")\n    used = Column(Boolean, default=False, doc=\"Has key already been used on the blockchain in as input or output? \"\n                                              \"Default is False\")\n    network_name = Column(String(20), ForeignKey('networks.name'),\n                          doc=\"Name of key network, i.e. bitcoin, litecoin, dash\")\n    latest_txid = Column(LargeBinary(32), doc=\"TxId of latest transaction downloaded from the blockchain\")\n    network = relationship(\"DbNetwork\", doc=\"DbNetwork object for this key\")\n    multisig_parents = relationship(\"DbKeyMultisigChildren\", backref='child_key',\n                                    primaryjoin=id == DbKeyMultisigChildren.child_id,\n                                    doc=\"List of parent keys\")\n    multisig_children = relationship(\"DbKeyMultisigChildren\", backref='parent_key',\n                                     order_by=\"DbKeyMultisigChildren.key_order\",\n                                     primaryjoin=id == DbKeyMultisigChildren.parent_id,\n                                     doc=\"List of children keys\")\n\n    __table_args__ = (\n        CheckConstraint(key_type.in_(['single', 'bip32', 'multisig']), name='constraint_key_types_allowed'),\n        CheckConstraint(encoding.in_(['base58', 'bech32']), name='constraint_address_encodings_allowed'),\n        UniqueConstraint('wallet_id', 'public', name='constraint_wallet_pubkey_unique'),\n        UniqueConstraint('wallet_id', 'private', name='constraint_wallet_privkey_unique'),\n        UniqueConstraint('wallet_id', 'wif', name='constraint_wallet_wif_unique'),\n        UniqueConstraint('wallet_id', 'address', name='constraint_wallet_address_unique'),\n    )\n\n    def __repr__(self):\n        return \"<DbKey(id='%s', name='%s', wif='%s'>\" % (self.id, self.name, self.wif)",
  "class DbNetwork(Base):\n    \"\"\"\n    Database definitions for networks in Sqlalchemy format\n\n    Most network settings and variables can be found outside the database in the libraries configurations settings.\n    Use the bitcoinlib/data/networks.json file to view and manage settings.\n\n    \"\"\"\n    __tablename__ = 'networks'\n    name = Column(String(20), unique=True, primary_key=True, doc=\"Network name, i.e.: bitcoin, litecoin, dash\")\n    description = Column(String(50))\n\n    def __repr__(self):\n        return \"<DbNetwork(name='%s', description='%s'>\" % (self.name, self.description)",
  "class DbTransaction(Base):\n    \"\"\"\n    Database definitions for transactions in Sqlalchemy format\n\n    Refers to 1 or more keys which can be part of a wallet\n\n    \"\"\"\n    __tablename__ = 'transactions'\n    id = Column(Integer, Sequence('transaction_id_seq'), primary_key=True,\n                doc=\"Unique transaction index for internal usage\")\n    txid = Column(LargeBinary(32), index=True, doc=\"Bytes representation of transaction ID\")\n    wallet_id = Column(Integer, ForeignKey('wallets.id'), index=True,\n                       doc=\"ID of wallet which contains this transaction\")\n    account_id = Column(Integer, index=True, doc=\"ID of account\")\n    wallet = relationship(\"DbWallet\", back_populates=\"transactions\",\n                          doc=\"Link to Wallet object which contains this transaction\")\n    witness_type = Column(String(20), default='legacy', doc=\"Is this a legacy or segwit transaction?\")\n    version = Column(BigInteger, default=1,\n                     doc=\"Tranaction version. Default is 1 but some wallets use another version number\")\n    locktime = Column(BigInteger, default=0,\n                      doc=\"Transaction level locktime. Locks the transaction until a specified block \"\n                          \"(value from 1 to 5 million) or until a certain time (Timestamp in seconds after 1-jan-1970).\"\n                          \" Default value is 0 for transactions without locktime\")\n    date = Column(DateTime, default=datetime.utcnow,\n                  doc=\"Date when transaction was confirmed and included in a block. \"\n                      \"Or when it was created when transaction is not send or confirmed\")\n    coinbase = Column(Boolean, default=False, doc=\"Is True when this is a coinbase transaction, default is False\")\n    confirmations = Column(Integer, default=0,\n                           doc=\"Number of confirmation when this transaction is included in a block. \"\n                               \"Default is 0: unconfirmed\")\n    block_height = Column(Integer, index=True, doc=\"Number of block this transaction is included in\")\n    size = Column(Integer, doc=\"Size of the raw transaction in bytes\")\n    fee = Column(BigInteger, doc=\"Transaction fee\")\n    inputs = relationship(\"DbTransactionInput\", cascade=\"all,delete\",\n                          doc=\"List of all inputs as DbTransactionInput objects\")\n    outputs = relationship(\"DbTransactionOutput\", cascade=\"all,delete\",\n                           doc=\"List of all outputs as DbTransactionOutput objects\")\n    status = Column(String(20), default='new',\n                    doc=\"Current status of transaction, can be one of the following: new', \"\n                        \"'unconfirmed', 'confirmed'. Default is 'new'\")\n    is_complete = Column(Boolean, default=True, doc=\"Allow to store incomplete transactions, for instance if not all \"\n                                                    \"inputs are known when retrieving UTXO's\")\n    input_total = Column(BigInteger, default=0,\n                         doc=\"Total value of the inputs of this transaction. Input total = Output total + fee. \"\n                             \"Default is 0\")\n    output_total = Column(BigInteger, default=0,\n                          doc=\"Total value of the outputs of this transaction. Output total = Input total - fee\")\n    network_name = Column(String(20), ForeignKey('networks.name'), doc=\"Blockchain network name of this transaction\")\n    network = relationship(\"DbNetwork\", doc=\"Link to DbNetwork object\")\n    raw = Column(LargeBinary,\n                 doc=\"Raw transaction hexadecimal string. Transaction is included in raw format on the blockchain\")\n    verified = Column(Boolean, default=False, doc=\"Is transaction verified. Default is False\")\n\n    __table_args__ = (\n        UniqueConstraint('wallet_id', 'txid', name='constraint_wallet_transaction_hash_unique'),\n        CheckConstraint(status.in_(['new', 'unconfirmed', 'confirmed']),\n                        name='constraint_status_allowed'),\n        CheckConstraint(witness_type.in_(['legacy', 'segwit']), name='transaction_constraint_allowed_types'),\n    )\n\n    def __repr__(self):\n        return \"<DbTransaction(txid='%s', confirmations='%s')>\" % (self.txid, self.confirmations)",
  "class DbTransactionInput(Base):\n    \"\"\"\n    Transaction Input Table\n\n    Relates to Transaction table and Key table\n\n    \"\"\"\n    __tablename__ = 'transaction_inputs'\n    transaction_id = Column(Integer, ForeignKey('transactions.id'), primary_key=True,\n                            doc=\"Input is part of transaction with this ID\")\n    transaction = relationship(\"DbTransaction\", back_populates='inputs', doc=\"Related DbTransaction object\")\n    index_n = Column(Integer, primary_key=True, doc=\"Index number of transaction input\")\n    key_id = Column(Integer, ForeignKey('keys.id'), index=True, doc=\"ID of key used in this input\")\n    key = relationship(\"DbKey\", back_populates=\"transaction_inputs\", doc=\"Related DbKey object\")\n    address = Column(String(255),\n                     doc=\"Address string of input, used if no key is associated. \"\n                         \"An cryptocurrency address is a hash of the public key or a redeemscript\")\n    witnesses = Column(LargeBinary, doc=\"Witnesses (signatures) used in Segwit transaction inputs\")\n    witness_type = Column(String(20), default='legacy',\n                          doc=\"Type of transaction, can be legacy, segwit or p2sh-segwit. Default is legacy\")\n    prev_txid = Column(LargeBinary(32),\n                       doc=\"Transaction hash of previous transaction. Previous unspent outputs (UTXO) is spent \"\n                           \"in this input\")\n    output_n = Column(BigInteger, doc=\"Output_n of previous transaction output that is spent in this input\")\n    script = Column(LargeBinary, doc=\"Unlocking script to unlock previous locked output\")\n    script_type = Column(String(20), default='sig_pubkey',\n                         doc=\"Unlocking script type. Can be 'coinbase', 'sig_pubkey', 'p2sh_multisig', 'signature', \"\n                             \"'unknown', 'p2sh_p2wpkh' or 'p2sh_p2wsh'. Default is sig_pubkey\")\n    sequence = Column(BigInteger, doc=\"Transaction sequence number. Used for timelock transaction inputs\")\n    value = Column(BigInteger, default=0, doc=\"Value of transaction input\")\n    double_spend = Column(Boolean, default=False,\n                          doc=\"Indicates if a service provider tagged this transaction as double spend\")\n\n    __table_args__ = (CheckConstraint(witness_type.in_(['legacy', 'segwit', 'p2sh-segwit']),\n                                      name='transactioninput_constraint_allowed_types'),\n                      UniqueConstraint('transaction_id', 'index_n', name='constraint_transaction_input_unique'))",
  "class DbTransactionOutput(Base):\n    \"\"\"\n    Transaction Output Table\n\n    Relates to Transaction and Key table\n\n    When spent is False output is considered an UTXO\n\n    \"\"\"\n    __tablename__ = 'transaction_outputs'\n    transaction_id = Column(Integer, ForeignKey('transactions.id'), primary_key=True,\n                            doc=\"Transaction ID of parent transaction\")\n    transaction = relationship(\"DbTransaction\", back_populates='outputs',\n                               doc=\"Link to transaction object\")\n    output_n = Column(Integer, primary_key=True, doc=\"Sequence number of transaction output\")\n    key_id = Column(Integer, ForeignKey('keys.id'), index=True, doc=\"ID of key used in this transaction output\")\n    key = relationship(\"DbKey\", back_populates=\"transaction_outputs\", doc=\"List of DbKey object used in this output\")\n    address = Column(String(255),\n                     doc=\"Address string of output, used if no key is associated. \"\n                         \"An cryptocurrency address is a hash of the public key or a redeemscript\")\n    script = Column(LargeBinary, doc=\"Locking script which locks transaction output\")\n    script_type = Column(String(20), default='p2pkh',\n                         doc=\"Locking script type. Can be one of these values: 'p2pkh', 'multisig', 'p2sh', 'p2pk', \"\n                             \"'nulldata', 'unknown', 'p2wpkh', 'p2wsh', 'p2tr'. Default is p2pkh\")\n    value = Column(BigInteger, default=0, doc=\"Total transaction output value\")\n    spent = Column(Boolean, default=False, doc=\"Indicated if output is already spent in another transaction\")\n    spending_txid = Column(LargeBinary(32), doc=\"Transaction hash of input which spends this output\")\n    spending_index_n = Column(Integer, doc=\"Index number of transaction input which spends this output\")\n\n    __table_args__ = (UniqueConstraint('transaction_id', 'output_n', name='constraint_transaction_output_unique'),)",
  "def db_update_version_id(db, version):\n    _logger.info(\"Updated BitcoinLib database to version %s\" % version)\n    db.session.query(DbConfig).filter(DbConfig.variable == 'version').update(\n        {DbConfig.value: version})\n    db.session.commit()\n    return version",
  "def db_update(db, version_db, code_version=BITCOINLIB_VERSION):\n    # Database changes from version 0.5+\n    #\n    if version_db <= '0.6.3' and code_version > '0.6.3':\n        # Example: column = Column('latest_txid', String(32))\n        column = Column('witnesses', LargeBinary, doc=\"Witnesses (signatures) used in Segwit transaction inputs\")\n        add_column(db.engine, 'transaction_inputs', column)\n        # version_db = db_update_version_id(db, '0.6.4')\n    version_db = db_update_version_id(db, code_version)\n    return version_db",
  "def __init__(self, db_uri=None, password=None):\n        if db_uri is None:\n            db_uri = DEFAULT_DATABASE\n        self.o = urlparse(db_uri)\n        if not self.o.scheme or \\\n                len(self.o.scheme) < 2:  # Dirty hack to avoid issues with urlparse on Windows confusing drive with scheme\n            if password:\n                # Warning: This requires the pysqlcipher3 module\n                db_uri = 'sqlite+pysqlcipher://:%s@/%s?cipher=aes-256-cfb&kdf_iter=64000' % (password, db_uri)\n            else:\n                db_uri = 'sqlite:///%s' % db_uri\n        elif password:\n            raise NotImplementedError(\"Password protection is only available for sqlite databases at the moment\")\n\n        if db_uri.startswith(\"sqlite\") and ALLOW_DATABASE_THREADS:\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += \"check_same_thread=False\"\n        if self.o.scheme == 'mysql':\n            db_uri += \"&\" if \"?\" in db_uri else \"?\"\n            db_uri += 'binary_prefix=true'\n        self.engine = create_engine(db_uri, isolation_level='READ UNCOMMITTED')\n\n        Session = sessionmaker(bind=self.engine)\n        Base.metadata.create_all(self.engine)\n        self._import_config_data(Session)\n        self.session = Session()\n\n        _logger.info(\"Using database: %s://%s:%s/%s\" % (self.o.scheme or '', self.o.hostname or '',\n                                                        self.o.port or '', self.o.path or ''))\n        self.db_uri = db_uri\n\n        # VERIFY AND UPDATE DATABASE\n        # Just a very simple database update script, without any external libraries for now\n        #\n        version_db = self.session.query(DbConfig.value).filter_by(variable='version').scalar()\n        if version_db[:3] == '0.4' and BITCOINLIB_VERSION[:3] >= '0.5':\n            raise ValueError(\"Old database version found (<0.4.19). Can not convert to >0.5 version database \"\n                             \"automatically, use updatedb.py tool to update\")\n        try:\n            if BITCOINLIB_VERSION != version_db:\n                _logger.warning(\"BitcoinLib database (%s) is from different version then library code (%s). \"\n                                \"Let's try to update database.\" % (version_db, BITCOINLIB_VERSION))\n                db_update(self, version_db, BITCOINLIB_VERSION)\n        except Exception as e:\n            _logger.warning(\"Error when verifying version or updating database: %s\" % e)",
  "def drop_db(self, yes_i_am_sure=False):\n        if yes_i_am_sure:\n            self.session.commit()\n            self.session.close_all()\n            close_all_sessions()\n            Base.metadata.drop_all(self.engine)",
  "def _import_config_data(ses):\n        session = ses()\n        installation_date = session.query(DbConfig.value).filter_by(variable='installation_date').scalar()\n        if not installation_date:\n            session.merge(DbConfig(variable='version', value=BITCOINLIB_VERSION))\n            session.merge(DbConfig(variable='installation_date', value=str(datetime.now())))\n            url = ''\n            try:\n                url = str(session.bind.url)\n            except Exception:\n                pass\n            session.merge(DbConfig(variable='installation_url', value=url))\n            session.commit()\n        session.close()",
  "def process_bind_param(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_encrypt(value, self.key)",
  "def process_result_value(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_decrypt(value, self.key)",
  "def process_bind_param(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        if not isinstance(value, bytes):\n            value = bytes(value, 'utf8')\n        return aes_encrypt(value, self.key)",
  "def process_result_value(self, value, dialect):\n        if value is None or self.key is None or not DATABASE_ENCRYPTION_ENABLED:\n            return value\n        return aes_decrypt(value, self.key).decode('utf8')",
  "def __repr__(self):\n        return \"<DbWallet(name='%s', network='%s'>\" % (self.name, self.network_name)",
  "def __repr__(self):\n        return \"<DbKey(id='%s', name='%s', wif='%s'>\" % (self.id, self.name, self.wif)",
  "def __repr__(self):\n        return \"<DbNetwork(name='%s', description='%s'>\" % (self.name, self.description)",
  "def __repr__(self):\n        return \"<DbTransaction(txid='%s', confirmations='%s')>\" % (self.txid, self.confirmations)",
  "class BcoinClient(BaseClient):\n    \"\"\"\n    Class to interact with Bcoin API\n    \"\"\"\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, func, data='', parameter='', variables=None, method='get'):\n        url_path = func\n        if data:\n            url_path += '/' + str(data)\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        return self.request(url_path, variables, method, secure=False)\n\n    def _parse_transaction(self, tx):\n        status = 'unconfirmed'\n        if tx['confirmations']:\n            status = 'confirmed'\n        t = Transaction.parse_hex(tx['hex'], strict=False, network=self.network)\n        t.locktime = tx['locktime']\n        t.network = self.network\n        t.fee = tx['fee']\n        t.date = datetime.utcfromtimestamp(tx['time']) if tx['time'] else None\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['height'] if tx['height'] > 0 else None\n        t.block_hash = tx['block']\n        t.status = status\n        if not t.coinbase:\n            for i in t.inputs:\n                i.value = tx['inputs'][t.inputs.index(i)]['coin']['value']\n        for o in t.outputs:\n            o.spent = None\n        t.update_totals()\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0.0\n        from bitcoinlib.services.services import Service\n        for address in addresslist:\n            # First get all transactions for this address from the blockchain\n            srv = Service(network=self.network.name, providers=['bcoin'])\n            txs = srv.gettransactions(address, limit=MAX_TRANSACTIONS)\n\n            # Fail if large number of transactions are found\n            if not srv.complete:\n                raise ClientError(\"If not all transactions are known, we cannot determine utxo's. \"\n                                  \"Increase limit or use other provider.\")\n\n            for a in [output for outputs in [t.outputs for t in txs] for output in outputs]:\n                if a.address == address:\n                    balance += a.value\n            for a in [i for inputs in [t.inputs for t in txs] for i in inputs]:\n                if a.address == address:\n                    balance -= a.value\n        return int(balance)\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        # First get all transactions for this address from the blockchain\n        txs = self.gettransactions(address, limit=50)\n\n        # Fail if large number of transactions are found\n        if len(txs) > 50:\n            raise ClientError(\"If not all transactions are known, we cannot determine utxo's\")\n\n        utxos = []\n        for tx in txs:\n            for unspent in tx.outputs:\n                if unspent.address != address:\n                    continue\n                if not self.isspent(tx.txid, unspent.output_n):\n                    utxos.append(\n                        {\n                            'address': unspent.address,\n                            'txid': tx.txid,\n                            'confirmations': tx.confirmations,\n                            'output_n': unspent.output_n,\n                            'input_n': 0,\n                            'block_height': tx.block_height,\n                            'fee': tx.fee,\n                            'size': tx.size,\n                            'value': unspent.value,\n                            'script': unspent.lock_script.hex(),\n                            'date': tx.date,\n                         }\n                    )\n                    if tx.txid == after_txid:\n                        utxos = []\n        return utxos[:limit]\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        assert(limit > 0)\n        txs = []\n        while True:\n            variables = {'limit': limit, 'after': after_txid}\n            res = self.compose_request('tx', 'address', address, variables)\n            for tx in res:\n                txs.append(self._parse_transaction(tx))\n            if not txs or len(txs) >= limit:\n                break\n            if len(res) == limit:\n                after_txid = res[limit-1]['hash']\n            else:\n                break\n\n        # Check which outputs are spent/unspent for this address\n        if not after_txid and len(txs) != limit:\n            txs = transaction_update_spents(txs, address)\n        return txs\n\n    def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid)['hex']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('broadcast', variables={'tx': rawtx}, method='post')\n        txid = ''\n        if 'success' in res and res['success']:\n            t = Transaction.parse_hex(rawtx, network=self.network)\n            txid = t.txid\n        return {\n            'txid': txid,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        if blocks > 15:\n            blocks = 15\n        fee = self.compose_request('fee', variables={'blocks': blocks})['rate']\n        if not fee:\n            return False\n        return fee\n\n    def blockcount(self):\n        return self.compose_request('')['chain']['height']\n\n    def mempool(self, txid=''):\n        txids = self.compose_request('mempool')\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        block = self.compose_request('block', str(blockid))\n        block['tx_count'] = len(block['txs'])\n        txs = block['txs']\n        parsed_txs = []\n        if parse_transactions:\n            txs = txs[(page-1)*limit:page*limit]\n        for tx in txs:\n            tx['confirmations'] = block['depth']\n            tx['time'] = block['time']\n            tx['height'] = block['height']\n            tx['block'] = block['hash']\n            if parse_transactions:\n                t = self._parse_transaction(tx)\n                parsed_txs.append(t)\n            else:\n                parsed_txs.append(tx['hash'])\n\n        block['time'] = block['time']\n        block['txs'] = parsed_txs\n        block['page'] = page\n        block['pages'] = None if not limit else int(block['tx_count'] // limit) + (block['tx_count'] % limit > 0)\n        block['limit'] = limit\n        block['prev_block'] = block.pop('prevBlock')\n        block['merkle_root'] = block.pop('merkleRoot')\n        block['block_hash'] = block.pop('hash')\n        return block\n\n    def getrawblock(self, blockid):\n        try:\n            blockid = int(blockid)\n            data = {\n                \"method\": \"getblockbyheight\",\n                \"params\": [blockid, 0, 0]\n            }\n        except ValueError:\n            data = {\n                \"method\": \"getblock\",\n                \"params\": [blockid, 0, 0]\n            }\n        res = self.compose_request('', method='post', variables=data)\n        return res['result']\n\n    def isspent(self, txid, index):\n        try:\n            self.compose_request('coin', txid, str(index))\n        except ClientError:\n            return 1\n        return 0\n\n    def getinfo(self):\n        res = self.compose_request('', variables={'method': 'getmininginfo'}, method='post')\n        info = res['result']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': info['difficulty'],\n            'hashrate': info['networkhashps'],\n            'mempool_size': info['pooledtx']\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, func, data='', parameter='', variables=None, method='get'):\n        url_path = func\n        if data:\n            url_path += '/' + str(data)\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        return self.request(url_path, variables, method, secure=False)",
  "def _parse_transaction(self, tx):\n        status = 'unconfirmed'\n        if tx['confirmations']:\n            status = 'confirmed'\n        t = Transaction.parse_hex(tx['hex'], strict=False, network=self.network)\n        t.locktime = tx['locktime']\n        t.network = self.network\n        t.fee = tx['fee']\n        t.date = datetime.utcfromtimestamp(tx['time']) if tx['time'] else None\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['height'] if tx['height'] > 0 else None\n        t.block_hash = tx['block']\n        t.status = status\n        if not t.coinbase:\n            for i in t.inputs:\n                i.value = tx['inputs'][t.inputs.index(i)]['coin']['value']\n        for o in t.outputs:\n            o.spent = None\n        t.update_totals()\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0.0\n        from bitcoinlib.services.services import Service\n        for address in addresslist:\n            # First get all transactions for this address from the blockchain\n            srv = Service(network=self.network.name, providers=['bcoin'])\n            txs = srv.gettransactions(address, limit=MAX_TRANSACTIONS)\n\n            # Fail if large number of transactions are found\n            if not srv.complete:\n                raise ClientError(\"If not all transactions are known, we cannot determine utxo's. \"\n                                  \"Increase limit or use other provider.\")\n\n            for a in [output for outputs in [t.outputs for t in txs] for output in outputs]:\n                if a.address == address:\n                    balance += a.value\n            for a in [i for inputs in [t.inputs for t in txs] for i in inputs]:\n                if a.address == address:\n                    balance -= a.value\n        return int(balance)",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        # First get all transactions for this address from the blockchain\n        txs = self.gettransactions(address, limit=50)\n\n        # Fail if large number of transactions are found\n        if len(txs) > 50:\n            raise ClientError(\"If not all transactions are known, we cannot determine utxo's\")\n\n        utxos = []\n        for tx in txs:\n            for unspent in tx.outputs:\n                if unspent.address != address:\n                    continue\n                if not self.isspent(tx.txid, unspent.output_n):\n                    utxos.append(\n                        {\n                            'address': unspent.address,\n                            'txid': tx.txid,\n                            'confirmations': tx.confirmations,\n                            'output_n': unspent.output_n,\n                            'input_n': 0,\n                            'block_height': tx.block_height,\n                            'fee': tx.fee,\n                            'size': tx.size,\n                            'value': unspent.value,\n                            'script': unspent.lock_script.hex(),\n                            'date': tx.date,\n                         }\n                    )\n                    if tx.txid == after_txid:\n                        utxos = []\n        return utxos[:limit]",
  "def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        assert(limit > 0)\n        txs = []\n        while True:\n            variables = {'limit': limit, 'after': after_txid}\n            res = self.compose_request('tx', 'address', address, variables)\n            for tx in res:\n                txs.append(self._parse_transaction(tx))\n            if not txs or len(txs) >= limit:\n                break\n            if len(res) == limit:\n                after_txid = res[limit-1]['hash']\n            else:\n                break\n\n        # Check which outputs are spent/unspent for this address\n        if not after_txid and len(txs) != limit:\n            txs = transaction_update_spents(txs, address)\n        return txs",
  "def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid)['hex']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('broadcast', variables={'tx': rawtx}, method='post')\n        txid = ''\n        if 'success' in res and res['success']:\n            t = Transaction.parse_hex(rawtx, network=self.network)\n            txid = t.txid\n        return {\n            'txid': txid,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        if blocks > 15:\n            blocks = 15\n        fee = self.compose_request('fee', variables={'blocks': blocks})['rate']\n        if not fee:\n            return False\n        return fee",
  "def blockcount(self):\n        return self.compose_request('')['chain']['height']",
  "def mempool(self, txid=''):\n        txids = self.compose_request('mempool')\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        block = self.compose_request('block', str(blockid))\n        block['tx_count'] = len(block['txs'])\n        txs = block['txs']\n        parsed_txs = []\n        if parse_transactions:\n            txs = txs[(page-1)*limit:page*limit]\n        for tx in txs:\n            tx['confirmations'] = block['depth']\n            tx['time'] = block['time']\n            tx['height'] = block['height']\n            tx['block'] = block['hash']\n            if parse_transactions:\n                t = self._parse_transaction(tx)\n                parsed_txs.append(t)\n            else:\n                parsed_txs.append(tx['hash'])\n\n        block['time'] = block['time']\n        block['txs'] = parsed_txs\n        block['page'] = page\n        block['pages'] = None if not limit else int(block['tx_count'] // limit) + (block['tx_count'] % limit > 0)\n        block['limit'] = limit\n        block['prev_block'] = block.pop('prevBlock')\n        block['merkle_root'] = block.pop('merkleRoot')\n        block['block_hash'] = block.pop('hash')\n        return block",
  "def getrawblock(self, blockid):\n        try:\n            blockid = int(blockid)\n            data = {\n                \"method\": \"getblockbyheight\",\n                \"params\": [blockid, 0, 0]\n            }\n        except ValueError:\n            data = {\n                \"method\": \"getblock\",\n                \"params\": [blockid, 0, 0]\n            }\n        res = self.compose_request('', method='post', variables=data)\n        return res['result']",
  "def isspent(self, txid, index):\n        try:\n            self.compose_request('coin', txid, str(index))\n        except ClientError:\n            return 1\n        return 0",
  "def getinfo(self):\n        res = self.compose_request('', variables={'method': 'getmininginfo'}, method='post')\n        info = res['result']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': info['difficulty'],\n            'hashrate': info['networkhashps'],\n            'mempool_size': info['pooledtx']\n        }",
  "class BlockstreamClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='', method='get'):\n        url_path = function\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if parameter2:\n            url_path += '/' + parameter2\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', data=address)\n            balance += (res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum'])\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        res = self.compose_request('address', address, 'utxo')\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        utxos = []\n        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])\n        for a in res:\n            confirmations = 0\n            block_height = None\n            if 'block_height' in a['status']:\n                block_height = a['status']['block_height']\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': a['txid'],\n                'confirmations': confirmations,\n                'output_n': a['vout'],\n                'input_n': 0,\n                'block_height': block_height,\n                'fee': None,\n                'size': 0,\n                'value': a['value'],\n                'script': '',\n                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])\n            })\n            if a['txid'] == after_txid:\n                utxos = []\n        return utxos[:limit]\n\n    def _parse_transaction(self, tx):\n        confirmations = 0\n        block_height = None\n        if 'block_height' in tx['status']:\n            block_height = tx['status']['block_height']\n            confirmations = self.latest_block - block_height\n        status = 'unconfirmed'\n        if tx['status']['confirmed']:\n            status = 'confirmed'\n        fee = None if 'fee' not in tx else tx['fee']\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fee, size=tx['size'], txid=tx['txid'],\n                        date=None if 'block_time' not in tx['status'] else datetime.utcfromtimestamp(tx['status']['block_time']),\n                        confirmations=confirmations, block_height=block_height, status=status,\n                        coinbase=tx['vin'][0]['is_coinbase'])\n        index_n = 0\n        for ti in tx['vin']:\n            if tx['vin'][0]['is_coinbase']:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,\n                            unlocking_script=ti['scriptsig'], value=0, sequence=ti['sequence'], strict=self.strict)\n            else:\n                witnesses = []\n                if 'witness' in ti:\n                    witnesses = [bytes.fromhex(w) for w in ti['witness']]\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,\n                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],\n                            address='' if 'scriptpubkey_address' not in ti['prevout']\n                            else ti['prevout']['scriptpubkey_address'], sequence=ti['sequence'],\n                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], witnesses=witnesses, strict=self.strict)\n            index_n += 1\n        index_n = 0\n        if len(tx['vout']) > 101:\n            # Every output needs an extra query, stop execution if there are too many transaction outputs\n            return False\n        for to in tx['vout']:\n            address = ''\n            if 'scriptpubkey_address' in to:\n                address = to['scriptpubkey_address']\n            spent = self.isspent(t.txid, index_n)\n            t.add_output(value=to['value'], address=address, lock_script=to['scriptpubkey'],\n                         output_n=index_n, spent=spent, strict=self.strict)\n            index_n += 1\n        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:\n            t.witness_type = 'segwit'\n        t.update_totals()\n        t.size = tx['size']\n        return t\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        prtxs = []\n        before_txid = ''\n        while True:\n            parameter = 'txs'\n            if before_txid:\n                parameter = 'txs/chain/%s' % before_txid\n            res = self.compose_request('address', address, parameter)\n            prtxs += res\n            if len(res) == 25:\n                before_txid = res[-1:][0]['txid']\n            else:\n                break\n            if len(prtxs) > limit:\n                break\n        txs = []\n        for tx in prtxs[::-1]:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n            if t.txid == after_txid:\n                txs = []\n            if len(txs) > limit:\n                break\n        return txs[:limit]\n\n    def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid, 'hex')\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', post_data=rawtx, method='post')\n        return {\n            'txid': res,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        est = self.compose_request('fee-estimates')\n        closest = (sorted([int(i) - blocks for i in est.keys() if int(i) - blocks >= 0]))\n        # FIXME: temporary fix for too low testnet tx fees:\n        if self.network.name == 'testnet':\n            return 2000\n        if closest:\n            return int(est[str(closest[0] + blocks)] * 1000)\n        else:\n            return int(est[str(sorted([int(i) for i in est.keys()])[-1:][0])] * 1000)\n\n    def blockcount(self):\n        return self.compose_request('blocks', 'tip', 'height')\n\n    def mempool(self, txid):\n        if txid:\n            t = self.gettransaction(txid)\n            if t and not t.confirmations:\n                return [t.txid]\n            else:\n                return []\n        else:\n            return self.compose_request('mempool', 'txids')\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        if (page == 1 and limit == 10) or limit > 25:\n            limit = 25\n        # elif page > 1:\n        #     if limit % 25 != 0:\n        #         return False\n        bd = self.compose_request('block', blockid)\n        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))\n        if parse_transactions:\n            txs = []\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in btxs[:limit]:\n                # try:\n                txs.append(self._parse_transaction(tx))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['txid'], e))\n        else:\n            txs = [tx['txid'] for tx in btxs]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['id'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['timestamp'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        rawblock = self.compose_request('block', blockid, 'raw')\n        hexrawblock = rawblock.hex()\n        return hexrawblock\n\n    def isspent(self, txid, output_n):\n        res = self.compose_request('tx', txid, 'outspend', str(output_n))\n        return 1 if res['spent'] else 0",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='', method='get'):\n        url_path = function\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if parameter2:\n            url_path += '/' + parameter2\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', data=address)\n            balance += (res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum'])\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        res = self.compose_request('address', address, 'utxo')\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        utxos = []\n        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])\n        for a in res:\n            confirmations = 0\n            block_height = None\n            if 'block_height' in a['status']:\n                block_height = a['status']['block_height']\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': a['txid'],\n                'confirmations': confirmations,\n                'output_n': a['vout'],\n                'input_n': 0,\n                'block_height': block_height,\n                'fee': None,\n                'size': 0,\n                'value': a['value'],\n                'script': '',\n                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])\n            })\n            if a['txid'] == after_txid:\n                utxos = []\n        return utxos[:limit]",
  "def _parse_transaction(self, tx):\n        confirmations = 0\n        block_height = None\n        if 'block_height' in tx['status']:\n            block_height = tx['status']['block_height']\n            confirmations = self.latest_block - block_height\n        status = 'unconfirmed'\n        if tx['status']['confirmed']:\n            status = 'confirmed'\n        fee = None if 'fee' not in tx else tx['fee']\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fee, size=tx['size'], txid=tx['txid'],\n                        date=None if 'block_time' not in tx['status'] else datetime.utcfromtimestamp(tx['status']['block_time']),\n                        confirmations=confirmations, block_height=block_height, status=status,\n                        coinbase=tx['vin'][0]['is_coinbase'])\n        index_n = 0\n        for ti in tx['vin']:\n            if tx['vin'][0]['is_coinbase']:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,\n                            unlocking_script=ti['scriptsig'], value=0, sequence=ti['sequence'], strict=self.strict)\n            else:\n                witnesses = []\n                if 'witness' in ti:\n                    witnesses = [bytes.fromhex(w) for w in ti['witness']]\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], index_n=index_n,\n                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],\n                            address='' if 'scriptpubkey_address' not in ti['prevout']\n                            else ti['prevout']['scriptpubkey_address'], sequence=ti['sequence'],\n                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], witnesses=witnesses, strict=self.strict)\n            index_n += 1\n        index_n = 0\n        if len(tx['vout']) > 101:\n            # Every output needs an extra query, stop execution if there are too many transaction outputs\n            return False\n        for to in tx['vout']:\n            address = ''\n            if 'scriptpubkey_address' in to:\n                address = to['scriptpubkey_address']\n            spent = self.isspent(t.txid, index_n)\n            t.add_output(value=to['value'], address=address, lock_script=to['scriptpubkey'],\n                         output_n=index_n, spent=spent, strict=self.strict)\n            index_n += 1\n        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:\n            t.witness_type = 'segwit'\n        t.update_totals()\n        t.size = tx['size']\n        return t",
  "def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        prtxs = []\n        before_txid = ''\n        while True:\n            parameter = 'txs'\n            if before_txid:\n                parameter = 'txs/chain/%s' % before_txid\n            res = self.compose_request('address', address, parameter)\n            prtxs += res\n            if len(res) == 25:\n                before_txid = res[-1:][0]['txid']\n            else:\n                break\n            if len(prtxs) > limit:\n                break\n        txs = []\n        for tx in prtxs[::-1]:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n            if t.txid == after_txid:\n                txs = []\n            if len(txs) > limit:\n                break\n        return txs[:limit]",
  "def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid, 'hex')",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', post_data=rawtx, method='post')\n        return {\n            'txid': res,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        est = self.compose_request('fee-estimates')\n        closest = (sorted([int(i) - blocks for i in est.keys() if int(i) - blocks >= 0]))\n        # FIXME: temporary fix for too low testnet tx fees:\n        if self.network.name == 'testnet':\n            return 2000\n        if closest:\n            return int(est[str(closest[0] + blocks)] * 1000)\n        else:\n            return int(est[str(sorted([int(i) for i in est.keys()])[-1:][0])] * 1000)",
  "def blockcount(self):\n        return self.compose_request('blocks', 'tip', 'height')",
  "def mempool(self, txid):\n        if txid:\n            t = self.gettransaction(txid)\n            if t and not t.confirmations:\n                return [t.txid]\n            else:\n                return []\n        else:\n            return self.compose_request('mempool', 'txids')",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        if (page == 1 and limit == 10) or limit > 25:\n            limit = 25\n        # elif page > 1:\n        #     if limit % 25 != 0:\n        #         return False\n        bd = self.compose_request('block', blockid)\n        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))\n        if parse_transactions:\n            txs = []\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in btxs[:limit]:\n                # try:\n                txs.append(self._parse_transaction(tx))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['txid'], e))\n        else:\n            txs = [tx['txid'] for tx in btxs]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['id'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['timestamp'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        rawblock = self.compose_request('block', blockid, 'raw')\n        hexrawblock = rawblock.hex()\n        return hexrawblock",
  "def isspent(self, txid, output_n):\n        res = self.compose_request('tx', txid, 'outspend', str(output_n))\n        return 1 if res['spent'] else 0",
  "class ClientError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)\n\n    def __str__(self):\n        return self.msg",
  "class BaseClient(object):\n\n    def __init__(self, network, provider, base_url, denominator, api_key='', provider_coin_id='',\n                 network_overrides=None, timeout=TIMEOUT_REQUESTS, latest_block=None, strict=True):\n        try:\n            self.network = network\n            if not isinstance(network, Network):\n                self.network = Network(network)\n            self.provider = provider\n            self.base_url = base_url\n            self.resp = None\n            self.units = denominator\n            self.api_key = api_key\n            self.provider_coin_id = provider_coin_id\n            self.network_overrides = {}\n            self.timeout = timeout\n            self.latest_block = latest_block\n            if network_overrides is not None:\n                self.network_overrides = network_overrides\n            self.strict = strict\n        except Exception:\n            raise ClientError(\"This Network is not supported by %s Client\" % provider)\n\n    def request(self, url_path, variables=None, method='get', secure=True, post_data=''):\n        url_vars = ''\n        url = self.base_url + url_path\n        if not url or not self.base_url:\n            raise ClientError(\"No (complete) url provided: %s\" % url)\n        headers = {\n            'User-Agent': 'BitcoinLib/%s' % BITCOINLIB_VERSION,\n            'Accept': 'application/json',\n            # 'Content-Type': 'application/json',\n            \"Referrer\": \"https://www.github.com/1200wd/bitcoinlib\",\n        }\n        # ToDo: Check use 'headers = None' for some providers?\n        if method == 'get':\n            if variables is None:\n                variables = {}\n            if variables:\n                url_vars = '?' + urlencode(variables)\n            url += url_vars\n            log_url = url if '@' not in url else url.split('@')[1]\n            _logger.info(\"Url get request %s\" % log_url)\n            self.resp = requests.get(url, timeout=self.timeout, verify=secure, headers=headers)\n        elif method == 'post':\n            log_url = url if '@' not in url else url.split('@')[1]\n            _logger.info(\"Url post request %s\" % log_url)\n            self.resp = requests.post(url, json=dict(variables), data=post_data, timeout=self.timeout, verify=secure,\n                                      headers=headers)\n\n        resp_text = self.resp.text\n        if len(resp_text) > 1000:\n            resp_text = self.resp.text[:970] + '... truncated, length %d' % len(resp_text)\n        _logger.debug(\"Response [%d] %s\" % (self.resp.status_code, resp_text))\n        log_url = url if '@' not in url else url.split('@')[1]\n        if self.resp.status_code == 429:\n            raise ClientError(\"Maximum number of requests reached for %s with url %s, response [%d] %s\" %\n                              (self.provider, log_url, self.resp.status_code, resp_text))\n        elif not(self.resp.status_code == 200 or self.resp.status_code == 201):\n            raise ClientError(\"Error connecting to %s on url %s, response [%d] %s\" %\n                              (self.provider, log_url, self.resp.status_code, resp_text))\n        try:\n            if not self.resp.apparent_encoding and not self.resp.encoding:\n                return self.resp.content\n            return json.loads(self.resp.text)\n        except ValueError or json.decoder.JSONDecodeError:\n            return self.resp.text\n\n    def _address_convert(self, address):\n        if not isinstance(address, Address):\n            return Address.parse(address, network_overrides=self.network_overrides, network=self.network.name)\n\n    def _addresslist_convert(self, addresslist):\n        addresslistconv = []\n        for address in addresslist:\n            addresslistconv.append(self._address_convert(address))\n        return addresslistconv",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)",
  "def __str__(self):\n        return self.msg",
  "def __init__(self, network, provider, base_url, denominator, api_key='', provider_coin_id='',\n                 network_overrides=None, timeout=TIMEOUT_REQUESTS, latest_block=None, strict=True):\n        try:\n            self.network = network\n            if not isinstance(network, Network):\n                self.network = Network(network)\n            self.provider = provider\n            self.base_url = base_url\n            self.resp = None\n            self.units = denominator\n            self.api_key = api_key\n            self.provider_coin_id = provider_coin_id\n            self.network_overrides = {}\n            self.timeout = timeout\n            self.latest_block = latest_block\n            if network_overrides is not None:\n                self.network_overrides = network_overrides\n            self.strict = strict\n        except Exception:\n            raise ClientError(\"This Network is not supported by %s Client\" % provider)",
  "def request(self, url_path, variables=None, method='get', secure=True, post_data=''):\n        url_vars = ''\n        url = self.base_url + url_path\n        if not url or not self.base_url:\n            raise ClientError(\"No (complete) url provided: %s\" % url)\n        headers = {\n            'User-Agent': 'BitcoinLib/%s' % BITCOINLIB_VERSION,\n            'Accept': 'application/json',\n            # 'Content-Type': 'application/json',\n            \"Referrer\": \"https://www.github.com/1200wd/bitcoinlib\",\n        }\n        # ToDo: Check use 'headers = None' for some providers?\n        if method == 'get':\n            if variables is None:\n                variables = {}\n            if variables:\n                url_vars = '?' + urlencode(variables)\n            url += url_vars\n            log_url = url if '@' not in url else url.split('@')[1]\n            _logger.info(\"Url get request %s\" % log_url)\n            self.resp = requests.get(url, timeout=self.timeout, verify=secure, headers=headers)\n        elif method == 'post':\n            log_url = url if '@' not in url else url.split('@')[1]\n            _logger.info(\"Url post request %s\" % log_url)\n            self.resp = requests.post(url, json=dict(variables), data=post_data, timeout=self.timeout, verify=secure,\n                                      headers=headers)\n\n        resp_text = self.resp.text\n        if len(resp_text) > 1000:\n            resp_text = self.resp.text[:970] + '... truncated, length %d' % len(resp_text)\n        _logger.debug(\"Response [%d] %s\" % (self.resp.status_code, resp_text))\n        log_url = url if '@' not in url else url.split('@')[1]\n        if self.resp.status_code == 429:\n            raise ClientError(\"Maximum number of requests reached for %s with url %s, response [%d] %s\" %\n                              (self.provider, log_url, self.resp.status_code, resp_text))\n        elif not(self.resp.status_code == 200 or self.resp.status_code == 201):\n            raise ClientError(\"Error connecting to %s on url %s, response [%d] %s\" %\n                              (self.provider, log_url, self.resp.status_code, resp_text))\n        try:\n            if not self.resp.apparent_encoding and not self.resp.encoding:\n                return self.resp.content\n            return json.loads(self.resp.text)\n        except ValueError or json.decoder.JSONDecodeError:\n            return self.resp.text",
  "def _address_convert(self, address):\n        if not isinstance(address, Address):\n            return Address.parse(address, network_overrides=self.network_overrides, network=self.network.name)",
  "def _addresslist_convert(self, addresslist):\n        addresslistconv = []\n        for address in addresslist:\n            addresslistconv.append(self._address_convert(address))\n        return addresslistconv",
  "class BlockCypher(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, data, parameter='', variables=None, method='get'):\n        url_path = function + '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method)\n\n    def getbalance(self, addresslist):\n        addresslist = self._addresslist_convert(addresslist)\n        addresses = ';'.join([a.address for a in addresslist])\n        res = self.compose_request('addrs', addresses, 'balance')\n        balance = 0.0\n        if not isinstance(res, list):\n            res = [res]\n        for rec in res:\n            balance += float(rec['final_balance'])\n        return int(balance * self.units)\n\n    # Disabled: Invalid results for https://api.blockcypher.com/v1/ltc/main/addrs/LVqLipGhyQ1nWtPPc8Xp3zn6JxcU1Hi8eG?unspentOnly=1&limit=2000\n    # def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n    #     address = self._address_convert(address)\n    #     res = self.compose_request('addrs', address.address, variables={'unspentOnly': 1, 'limit': 2000})\n    #     transactions = []\n    #     if not isinstance(res, list):\n    #         res = [res]\n    #     for a in res:\n    #         txrefs = a.setdefault('txrefs', []) + a.get('unconfirmed_txrefs', [])\n    #         if len(txrefs) > 500:\n    #             _logger.warning(\"BlockCypher: Large number of transactions for address %s, \"\n    #                             \"Transaction list may be incomplete\" % address)\n    #         for tx in txrefs:\n    #             if tx['tx_hash'] == after_txid:\n    #                 break\n    #             tdate = None\n    #             if 'confirmed' in tx:\n    #                 try:\n    #                     tdate = datetime.strptime(tx['confirmed'], \"%Y-%m-%dT%H:%M:%SZ\")\n    #                 except ValueError:\n    #                     tdate = datetime.strptime(tx['confirmed'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n    #             transactions.append({\n    #                 'address': address.address_orig,\n    #                 'txid': tx['tx_hash'],\n    #                 'confirmations': tx['confirmations'],\n    #                 'output_n': tx['tx_output_n'],\n    #                 'index': 0,\n    #                 'value': int(round(tx['value'] * self.units, 0)),\n    #                 'script': '',\n    #                 'block_height': None,\n    #                 'date': tdate\n    #             })\n    #     return transactions[::-1][:limit]\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('txs', txid, variables={'includeHex': 'true'})\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        if tx['confirmations']:\n            t.status = 'confirmed'\n            t.date = datetime.strptime(tx['confirmed'][:19], \"%Y-%m-%dT%H:%M:%S\")\n        else:\n            t.status = 'unconfirmed'\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['block_height'] if tx['block_height'] > 0 else None\n        t.fee = tx['fees']\n        t.rawtx = bytes.fromhex(tx['hex'])\n        t.size = int(len(tx['hex']) / 2)\n        t.network = self.network\n        t.input_total = 0\n        if len(t.inputs) != len(tx['inputs']):\n            raise ClientError(\"Invalid number of inputs provided. Raw tx: %d, blockcypher: %d\" %\n                              (len(t.inputs), len(tx['inputs'])))\n        for n, i in enumerate(t.inputs):\n            if not t.coinbase and not (tx['inputs'][n]['output_index'] == i.output_n_int and\n                                       tx['inputs'][n]['prev_hash'] == i.prev_txid.hex()):\n                raise ClientError(\"Transaction inputs do not match raw transaction\")\n            if 'output_value' in tx['inputs'][n]:\n                if not t.coinbase:\n                    i.value = tx['inputs'][n]['output_value']\n                t.input_total += i.value\n        if len(t.outputs) != len(tx['outputs']):\n            raise ClientError(\"Invalid number of outputs provided. Raw tx: %d, blockcypher: %d\" %\n                              (len(t.outputs), len(tx['outputs'])))\n        for n, o in enumerate(t.outputs):\n            if 'spent_by' in tx['outputs'][n]:\n                o.spent = True\n                o.spending_txid = tx['outputs'][n]['spent_by']\n        return t\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, variables={'unspentOnly': 0, 'limit': 2000})\n        if not isinstance(res, list):\n            res = [res]\n        for a in res:\n            txrefs = a.get('txrefs', []) + a.get('unconfirmed_txrefs', [])\n            txids = []\n            for t in txrefs[::-1]:\n                if t['tx_hash'] not in txids:\n                    txids.append(t['tx_hash'])\n                if t['tx_hash'] == after_txid:\n                    txids = []\n            if len(txids) > 500:\n                _logger.info(\"BlockCypher: Large number of transactions for address %s, \"\n                             \"Transaction list may be incomplete\" % address.address_orig)\n            for txid in txids[:limit]:\n                t = self.gettransaction(txid)\n                txs.append(t)\n        return txs\n\n    def getrawtransaction(self, txid):\n        return self.compose_request('txs', txid, variables={'includeHex': 'true'})['hex']\n\n    def sendrawtransaction(self, rawtx):\n        # BlockCypher sometimes accepts transactions, but does not push them to the network :(\n        if self.network.name in ['bitcoin', 'litecoin']:\n            raise ClientError(\"Avoid stuck transactions, skip usage of blockcypher provider\")\n        res = self.compose_request('txs', 'push', variables={'tx': rawtx}, method='post')\n        return {\n            'txid': res['tx']['hash'],\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        res = self.compose_request('', '')\n        if blocks <= 10:\n            return res['medium_fee_per_kb']\n        else:\n            return res['low_fee_per_kb']\n\n    def blockcount(self):\n        return self.compose_request('', '')['height']\n\n    def mempool(self, txid):\n        if txid:\n            tx = self.compose_request('txs', txid)\n            if tx['confirmations'] == 0:\n                return [tx['hash']]\n            else:\n                return []\n        return False\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 100:\n            limit = 100\n        bd = self.compose_request('blocks', str(blockid), variables={'limit': limit, 'txstart': ((page-1)*limit)})\n        if parse_transactions:\n            txs = []\n            for txid in bd['txids']:\n                try:\n                    txs.append(self.gettransaction(txid))\n                except Exception as e:\n                    _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['txids']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['depth'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['mrkl_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['prev_block'],\n            'time': int(datetime.strptime(bd['time'], \"%Y-%m-%dT%H:%M:%SZ\").replace(tzinfo=timezone.utc).timestamp()),\n            'tx_count': bd['n_tx'],\n            'txs': txs,\n            'version': bd['ver'],\n            'page': page,\n            'pages': None if not limit else int(bd['n_tx'] // limit) + (bd['n_tx'] % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    # def getrawblock(self, blockid):\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, data, parameter='', variables=None, method='get'):\n        url_path = function + '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method)",
  "def getbalance(self, addresslist):\n        addresslist = self._addresslist_convert(addresslist)\n        addresses = ';'.join([a.address for a in addresslist])\n        res = self.compose_request('addrs', addresses, 'balance')\n        balance = 0.0\n        if not isinstance(res, list):\n            res = [res]\n        for rec in res:\n            balance += float(rec['final_balance'])\n        return int(balance * self.units)",
  "def gettransaction(self, txid):\n        tx = self.compose_request('txs', txid, variables={'includeHex': 'true'})\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        if tx['confirmations']:\n            t.status = 'confirmed'\n            t.date = datetime.strptime(tx['confirmed'][:19], \"%Y-%m-%dT%H:%M:%S\")\n        else:\n            t.status = 'unconfirmed'\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['block_height'] if tx['block_height'] > 0 else None\n        t.fee = tx['fees']\n        t.rawtx = bytes.fromhex(tx['hex'])\n        t.size = int(len(tx['hex']) / 2)\n        t.network = self.network\n        t.input_total = 0\n        if len(t.inputs) != len(tx['inputs']):\n            raise ClientError(\"Invalid number of inputs provided. Raw tx: %d, blockcypher: %d\" %\n                              (len(t.inputs), len(tx['inputs'])))\n        for n, i in enumerate(t.inputs):\n            if not t.coinbase and not (tx['inputs'][n]['output_index'] == i.output_n_int and\n                                       tx['inputs'][n]['prev_hash'] == i.prev_txid.hex()):\n                raise ClientError(\"Transaction inputs do not match raw transaction\")\n            if 'output_value' in tx['inputs'][n]:\n                if not t.coinbase:\n                    i.value = tx['inputs'][n]['output_value']\n                t.input_total += i.value\n        if len(t.outputs) != len(tx['outputs']):\n            raise ClientError(\"Invalid number of outputs provided. Raw tx: %d, blockcypher: %d\" %\n                              (len(t.outputs), len(tx['outputs'])))\n        for n, o in enumerate(t.outputs):\n            if 'spent_by' in tx['outputs'][n]:\n                o.spent = True\n                o.spending_txid = tx['outputs'][n]['spent_by']\n        return t",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, variables={'unspentOnly': 0, 'limit': 2000})\n        if not isinstance(res, list):\n            res = [res]\n        for a in res:\n            txrefs = a.get('txrefs', []) + a.get('unconfirmed_txrefs', [])\n            txids = []\n            for t in txrefs[::-1]:\n                if t['tx_hash'] not in txids:\n                    txids.append(t['tx_hash'])\n                if t['tx_hash'] == after_txid:\n                    txids = []\n            if len(txids) > 500:\n                _logger.info(\"BlockCypher: Large number of transactions for address %s, \"\n                             \"Transaction list may be incomplete\" % address.address_orig)\n            for txid in txids[:limit]:\n                t = self.gettransaction(txid)\n                txs.append(t)\n        return txs",
  "def getrawtransaction(self, txid):\n        return self.compose_request('txs', txid, variables={'includeHex': 'true'})['hex']",
  "def sendrawtransaction(self, rawtx):\n        # BlockCypher sometimes accepts transactions, but does not push them to the network :(\n        if self.network.name in ['bitcoin', 'litecoin']:\n            raise ClientError(\"Avoid stuck transactions, skip usage of blockcypher provider\")\n        res = self.compose_request('txs', 'push', variables={'tx': rawtx}, method='post')\n        return {\n            'txid': res['tx']['hash'],\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        res = self.compose_request('', '')\n        if blocks <= 10:\n            return res['medium_fee_per_kb']\n        else:\n            return res['low_fee_per_kb']",
  "def blockcount(self):\n        return self.compose_request('', '')['height']",
  "def mempool(self, txid):\n        if txid:\n            tx = self.compose_request('txs', txid)\n            if tx['confirmations'] == 0:\n                return [tx['hash']]\n            else:\n                return []\n        return False",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 100:\n            limit = 100\n        bd = self.compose_request('blocks', str(blockid), variables={'limit': limit, 'txstart': ((page-1)*limit)})\n        if parse_transactions:\n            txs = []\n            for txid in bd['txids']:\n                try:\n                    txs.append(self.gettransaction(txid))\n                except Exception as e:\n                    _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['txids']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['depth'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['mrkl_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['prev_block'],\n            'time': int(datetime.strptime(bd['time'], \"%Y-%m-%dT%H:%M:%SZ\").replace(tzinfo=timezone.utc).timestamp()),\n            'tx_count': bd['n_tx'],\n            'txs': txs,\n            'version': bd['ver'],\n            'page': page,\n            'pages': None if not limit else int(bd['n_tx'] // limit) + (bd['n_tx'] % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "class ConfigError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)\n\n    def __str__(self):\n        return self.msg",
  "def _read_from_config(configparser, section, value, fallback=None):\n    try:\n        return configparser.get(section, value)\n    except Exception:\n        return fallback",
  "class DogecoindClient(BaseClient):\n    \"\"\"\n    Class to interact with dogecoind, the Dogecoin daemon\n    \"\"\"\n\n    @staticmethod\n    def from_config(configfile=None, network='dogecoin'):\n        \"\"\"\n        Read settings from dogecoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet\n        :type: str\n\n        :return DogecoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'dogecoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'dogecoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.dogecoin', '~/Application Data/Dogecoin',\n                                '~/Library/Application Support/Dogecoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install dogecoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/dogecoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 44555\n        else:\n            port = 22555\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return DogecoindClient(network, url)\n\n    def __init__(self, network='dogecoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to dogecoin node\n\n        :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for dogecoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        if len(base_url.split(':')) != 4:\n            raise ConfigError(\"Dogecoind connection URL must be of format 'http(s)://user:password@host:port,\"\n                              \"current format is %s. Please set url in providers.json file or check dogecoin config \"\n                              \"file\" % base_url)\n        if 'password' in base_url:\n            raise ConfigError(\"Invalid password in dogecoind provider settings. \"\n                              \"Please replace default password and set url in providers.json or dogecoin.conf file\")\n        _logger.info(\"Connect to dogecoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def getutxos(self, address, after_txid='', max_txs=MAX_TRANSACTIONS):\n        txs = []\n\n        for t in self.proxy.listunspent(0, 99999999, [address]):\n            txs.append({\n                'address': t['address'],\n                'txid': t['txid'],\n                'confirmations': t['confirmations'],\n                'output_n': t['vout'],\n                'input_n': -1,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(t['amount'] * self.units),\n                'script': t['scriptPubKey'],\n                'date': None,\n            })\n\n        return txs\n\n    def gettransaction(self, txid, block_height=None, get_input_values=True):\n        tx = self.proxy.getrawtransaction(txid, 1)\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx['confirmations']\n        if t.confirmations:\n            t.status = 'confirmed'\n            t.verified = True\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.value = t.output_total\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.date = datetime.fromtimestamp(tx['blocktime'])\n        t.block_height = block_height\n        t.update_totals()\n        return t\n\n    def getrawtransaction(self, txid):\n        return self.proxy.getrawtransaction(txid)\n\n    def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"dogecoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)\n\n    def blockcount(self):\n        return self.proxy.getblockcount()\n\n    def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []\n\n    def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)",
  "def __str__(self):\n        return self.msg",
  "def from_config(configfile=None, network='dogecoin'):\n        \"\"\"\n        Read settings from dogecoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet\n        :type: str\n\n        :return DogecoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'dogecoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'dogecoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.dogecoin', '~/Application Data/Dogecoin',\n                                '~/Library/Application Support/Dogecoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install dogecoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/dogecoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 44555\n        else:\n            port = 22555\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return DogecoindClient(network, url)",
  "def __init__(self, network='dogecoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to dogecoin node\n\n        :param network: Dogecoin mainnet or testnet. Default is dogecoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for dogecoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        if len(base_url.split(':')) != 4:\n            raise ConfigError(\"Dogecoind connection URL must be of format 'http(s)://user:password@host:port,\"\n                              \"current format is %s. Please set url in providers.json file or check dogecoin config \"\n                              \"file\" % base_url)\n        if 'password' in base_url:\n            raise ConfigError(\"Invalid password in dogecoind provider settings. \"\n                              \"Please replace default password and set url in providers.json or dogecoin.conf file\")\n        _logger.info(\"Connect to dogecoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def getutxos(self, address, after_txid='', max_txs=MAX_TRANSACTIONS):\n        txs = []\n\n        for t in self.proxy.listunspent(0, 99999999, [address]):\n            txs.append({\n                'address': t['address'],\n                'txid': t['txid'],\n                'confirmations': t['confirmations'],\n                'output_n': t['vout'],\n                'input_n': -1,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(t['amount'] * self.units),\n                'script': t['scriptPubKey'],\n                'date': None,\n            })\n\n        return txs",
  "def gettransaction(self, txid, block_height=None, get_input_values=True):\n        tx = self.proxy.getrawtransaction(txid, 1)\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx['confirmations']\n        if t.confirmations:\n            t.status = 'confirmed'\n            t.verified = True\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.value = t.output_total\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.date = datetime.fromtimestamp(tx['blocktime'])\n        t.block_height = block_height\n        t.update_totals()\n        return t",
  "def getrawtransaction(self, txid):\n        return self.proxy.getrawtransaction(txid)",
  "def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"dogecoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)",
  "def blockcount(self):\n        return self.proxy.getblockcount()",
  "def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []",
  "def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "class ConfigError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)\n\n    def __str__(self):\n        return self.msg",
  "class DashdClient(BaseClient):\n    \"\"\"\n    Class to interact with dashd, the Dash deamon\n    \"\"\"\n\n    @staticmethod\n    def from_config(configfile=None, network='dash'):\n        \"\"\"\n        Read settings from dashd config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Dash mainnet or testnet. Default is dash mainnet\n        :type: str\n\n        :return DashdClient:\n        \"\"\"\n        config = configparser.ConfigParser(strict=False)\n        if not configfile:\n            cfn = os.path.join(os.path.expanduser(\"~\"), '.bitcoinlib/dash.conf')\n            if not os.path.isfile(cfn):\n                cfn = os.path.join(os.path.expanduser(\"~\"), '.dashcore/dash.conf')\n            if not os.path.isfile(cfn):\n                raise ConfigError(\"Please install dash client and specify a path to config file if path is not \"\n                                  \"default. Or place a config file in .bitcoinlib/dash.conf to reference to \"\n                                  \"an external server.\")\n        else:\n            cfn = os.path.join(BCL_DATA_DIR, 'config', configfile)\n            if not os.path.isfile(cfn):\n                raise ConfigError(\"Config file %s not found\" % cfn)\n        with open(cfn, 'r') as f:\n            config_string = '[rpc]\\n' + f.read()\n        config.read_string(config_string)\n\n        try:\n            if int(config.get('rpc', 'testnet')):\n                network = 'testnet'\n        except configparser.NoOptionError:\n            pass\n        if config.get('rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        try:\n            port = config.get('rpc', 'port')\n        except configparser.NoOptionError:\n            if network == 'testnet':\n                port = 19998\n            else:\n                port = 9998\n        server = '127.0.0.1'\n        if 'bind' in config['rpc']:\n            server = config.get('rpc', 'bind')\n        elif 'externalip' in config['rpc']:\n            server = config.get('rpc', 'externalip')\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return DashdClient(network, url)\n\n    def __init__(self, network='dash', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to dashcore node\n\n        :param network: Dash mainnet or testnet. Default is dash mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for Dash\n        :type: str\n        \"\"\"\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to dashd\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = None if 'confirmations' not in tx else tx['confirmations']\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n        t.block_height = block_height\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.date = datetime.utcfromtimestamp(tx['blocktime'])\n        t.update_totals()\n        return t\n\n    def gettransaction(self, txid):\n        tx = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx)\n\n    def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res\n\n    def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        try:\n            res = self.proxy.estimatesmartfee(blocks)['feerate']\n        except KeyError:\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)\n\n    def blockcount(self):\n        return self.proxy.getblockcount()\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n\n        txs_list = self.proxy.listunspent(0, 99999999, [address])\n        for t in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            txs.append({\n                'address': t['address'],\n                'txid': t['txid'],\n                'confirmations': t['confirmations'],\n                'output_n': t['vout'],\n                'input_n': -1,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(t['amount'] * self.units),\n                'script': t['scriptPubKey'],\n                'date': None,\n            })\n            if t['txid'] == after_txid:\n                txs = []\n\n        return txs\n\n    def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                # try:\n                tx['blocktime'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=False))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['txid'], e))\n            # txs += [tx['hash'] for tx in bd['tx'][len(txs):]]\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['time'],\n            'total_txs': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)\n\n    def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0\n\n    def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)",
  "def __str__(self):\n        return self.msg",
  "def from_config(configfile=None, network='dash'):\n        \"\"\"\n        Read settings from dashd config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Dash mainnet or testnet. Default is dash mainnet\n        :type: str\n\n        :return DashdClient:\n        \"\"\"\n        config = configparser.ConfigParser(strict=False)\n        if not configfile:\n            cfn = os.path.join(os.path.expanduser(\"~\"), '.bitcoinlib/dash.conf')\n            if not os.path.isfile(cfn):\n                cfn = os.path.join(os.path.expanduser(\"~\"), '.dashcore/dash.conf')\n            if not os.path.isfile(cfn):\n                raise ConfigError(\"Please install dash client and specify a path to config file if path is not \"\n                                  \"default. Or place a config file in .bitcoinlib/dash.conf to reference to \"\n                                  \"an external server.\")\n        else:\n            cfn = os.path.join(BCL_DATA_DIR, 'config', configfile)\n            if not os.path.isfile(cfn):\n                raise ConfigError(\"Config file %s not found\" % cfn)\n        with open(cfn, 'r') as f:\n            config_string = '[rpc]\\n' + f.read()\n        config.read_string(config_string)\n\n        try:\n            if int(config.get('rpc', 'testnet')):\n                network = 'testnet'\n        except configparser.NoOptionError:\n            pass\n        if config.get('rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        try:\n            port = config.get('rpc', 'port')\n        except configparser.NoOptionError:\n            if network == 'testnet':\n                port = 19998\n            else:\n                port = 9998\n        server = '127.0.0.1'\n        if 'bind' in config['rpc']:\n            server = config.get('rpc', 'bind')\n        elif 'externalip' in config['rpc']:\n            server = config.get('rpc', 'externalip')\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return DashdClient(network, url)",
  "def __init__(self, network='dash', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to dashcore node\n\n        :param network: Dash mainnet or testnet. Default is dash mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for Dash\n        :type: str\n        \"\"\"\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to dashd\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = None if 'confirmations' not in tx else tx['confirmations']\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n        t.block_height = block_height\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.date = datetime.utcfromtimestamp(tx['blocktime'])\n        t.update_totals()\n        return t",
  "def gettransaction(self, txid):\n        tx = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx)",
  "def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res",
  "def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        try:\n            res = self.proxy.estimatesmartfee(blocks)['feerate']\n        except KeyError:\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)",
  "def blockcount(self):\n        return self.proxy.getblockcount()",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n\n        txs_list = self.proxy.listunspent(0, 99999999, [address])\n        for t in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            txs.append({\n                'address': t['address'],\n                'txid': t['txid'],\n                'confirmations': t['confirmations'],\n                'output_n': t['vout'],\n                'input_n': -1,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(t['amount'] * self.units),\n                'script': t['scriptPubKey'],\n                'date': None,\n            })\n            if t['txid'] == after_txid:\n                txs = []\n\n        return txs",
  "def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                # try:\n                tx['blocktime'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=False))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['txid'], e))\n            # txs += [tx['hash'] for tx in bd['tx'][len(txs):]]\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['time'],\n            'total_txs': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)",
  "def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0",
  "def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "class CryptoID(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, func=None, path_type='api', variables=None, method='get'):\n        # API path: http://chainz.cryptoid.info/ltc/api.dws\n        # Explorer path for raw tx: https://chainz.cryptoid.info/explorer/tx.raw.dws\n        if variables is None:\n            variables = {}\n        if path_type == 'api':\n            url_path = '%s/api.dws' % self.provider_coin_id\n            variables.update({'q': func})\n        else:\n            url_path = 'explorer/tx.raw.dws'\n            variables.update({'coin': self.provider_coin_id})\n        # if not self.api_key:\n        #     raise ClientError(\"Request a CryptoID API key before using this provider\")\n        if self.api_key:\n            variables.update({'key': self.api_key})\n        return self.request(url_path, variables, method)\n\n    def getbalance(self, addresslist):\n        balance = 0.0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('getbalance', variables={'a': a.address})\n            balance += float(res)\n        return int(balance * self.units)\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        if not self.api_key:\n            raise ClientError(\"Method getutxos() is not available for CryptoID without API key\")\n        utxos = []\n        address = self._address_convert(address)\n        variables = {'active': address.address}\n        res = self.compose_request('unspent', variables=variables)\n        if len(res['unspent_outputs']) > 50:\n            _logger.info(\"CryptoID: Large number of outputs for address %s, \"\n                         \"UTXO list may be incomplete\" % address.address)\n        for utxo in res['unspent_outputs'][::-1]:\n            if utxo['txid'] == after_txid:\n                break\n            utxos.append({\n                'address': address.address_orig,\n                'txid': utxo['txid'],\n                'confirmations': utxo['confirmations'],\n                'output_n': utxo['tx_output_n'] if 'tx_output_n' in utxo else utxo['tx_ouput_n'],\n                'input_n': 0,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(utxo['value']),\n                'script': utxo['script'],\n                'date': None\n            })\n        return utxos[::-1][:limit]\n\n    def gettransaction(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        variables = {'t': txid}\n        tx_api = self.compose_request('txinfo', path_type='api', variables=variables)\n        for n, i in enumerate(t.inputs):\n            if i.script_type != 'coinbase':\n                i.value = int(round(tx_api['inputs'][n]['amount'] * self.units, 0))\n            else:\n                i.value = 0\n                t.coinbase = True\n        for n, o in enumerate(t.outputs):\n            o.spent = None\n        if tx['confirmations']:\n            t.status = 'confirmed'\n        else:\n            t.status = 'unconfirmed'\n        t.date = datetime.utcfromtimestamp(tx['time'])\n        t.block_height = tx_api['block']\n        t.block_hash = tx['blockhash']\n        t.confirmations = tx['confirmations']\n        t.rawtx = bytes.fromhex(tx['hex'])\n        t.size = tx['size']\n        t.network = self.network\n        t.locktime = tx['locktime']\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.output_total = int(round(tx_api['total_output'] * self.units, 0))\n        t.input_total = int(round(tx_api['total_input'] * self.units, 0))\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        return t\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        txs = []\n        txids = []\n        variables = {'active': address.address, 'n': 100}\n        res = self.compose_request('multiaddr', variables=variables)\n        for tx in res['txs']:\n            if tx['hash'] not in txids:\n                txids.insert(0, tx['hash'])\n        if after_txid:\n            txids = txids[txids.index(after_txid) + 1:]\n        for txid in txids[:limit]:\n            t = self.gettransaction(txid)\n            txs.append(t)\n        return txs\n\n    def getrawtransaction(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        return tx['hex']\n\n    # def sendrawtransaction\n\n    # def estimatefee\n\n    def blockcount(self):\n        r = self.compose_request('getblockcount', path_type='api')\n        return r\n\n    def mempool(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        if 'confirmations' not in tx:\n            return [tx['txid']]\n        return []",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, func=None, path_type='api', variables=None, method='get'):\n        # API path: http://chainz.cryptoid.info/ltc/api.dws\n        # Explorer path for raw tx: https://chainz.cryptoid.info/explorer/tx.raw.dws\n        if variables is None:\n            variables = {}\n        if path_type == 'api':\n            url_path = '%s/api.dws' % self.provider_coin_id\n            variables.update({'q': func})\n        else:\n            url_path = 'explorer/tx.raw.dws'\n            variables.update({'coin': self.provider_coin_id})\n        # if not self.api_key:\n        #     raise ClientError(\"Request a CryptoID API key before using this provider\")\n        if self.api_key:\n            variables.update({'key': self.api_key})\n        return self.request(url_path, variables, method)",
  "def getbalance(self, addresslist):\n        balance = 0.0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('getbalance', variables={'a': a.address})\n            balance += float(res)\n        return int(balance * self.units)",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        if not self.api_key:\n            raise ClientError(\"Method getutxos() is not available for CryptoID without API key\")\n        utxos = []\n        address = self._address_convert(address)\n        variables = {'active': address.address}\n        res = self.compose_request('unspent', variables=variables)\n        if len(res['unspent_outputs']) > 50:\n            _logger.info(\"CryptoID: Large number of outputs for address %s, \"\n                         \"UTXO list may be incomplete\" % address.address)\n        for utxo in res['unspent_outputs'][::-1]:\n            if utxo['txid'] == after_txid:\n                break\n            utxos.append({\n                'address': address.address_orig,\n                'txid': utxo['txid'],\n                'confirmations': utxo['confirmations'],\n                'output_n': utxo['tx_output_n'] if 'tx_output_n' in utxo else utxo['tx_ouput_n'],\n                'input_n': 0,\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(utxo['value']),\n                'script': utxo['script'],\n                'date': None\n            })\n        return utxos[::-1][:limit]",
  "def gettransaction(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        variables = {'t': txid}\n        tx_api = self.compose_request('txinfo', path_type='api', variables=variables)\n        for n, i in enumerate(t.inputs):\n            if i.script_type != 'coinbase':\n                i.value = int(round(tx_api['inputs'][n]['amount'] * self.units, 0))\n            else:\n                i.value = 0\n                t.coinbase = True\n        for n, o in enumerate(t.outputs):\n            o.spent = None\n        if tx['confirmations']:\n            t.status = 'confirmed'\n        else:\n            t.status = 'unconfirmed'\n        t.date = datetime.utcfromtimestamp(tx['time'])\n        t.block_height = tx_api['block']\n        t.block_hash = tx['blockhash']\n        t.confirmations = tx['confirmations']\n        t.rawtx = bytes.fromhex(tx['hex'])\n        t.size = tx['size']\n        t.network = self.network\n        t.locktime = tx['locktime']\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.output_total = int(round(tx_api['total_output'] * self.units, 0))\n        t.input_total = int(round(tx_api['total_input'] * self.units, 0))\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        return t",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        txs = []\n        txids = []\n        variables = {'active': address.address, 'n': 100}\n        res = self.compose_request('multiaddr', variables=variables)\n        for tx in res['txs']:\n            if tx['hash'] not in txids:\n                txids.insert(0, tx['hash'])\n        if after_txid:\n            txids = txids[txids.index(after_txid) + 1:]\n        for txid in txids[:limit]:\n            t = self.gettransaction(txid)\n            txs.append(t)\n        return txs",
  "def getrawtransaction(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        return tx['hex']",
  "def blockcount(self):\n        r = self.compose_request('getblockcount', path_type='api')\n        return r",
  "def mempool(self, txid):\n        variables = {'id': txid, 'hex': None}\n        tx = self.compose_request(path_type='explorer', variables=variables)\n        if 'confirmations' not in tx:\n            return [tx['txid']]\n        return []",
  "class LitecoinBlockexplorerClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + ('' if not cmd else '/' + cmd)\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)\n\n    def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else int(round(float(tx['valueIn']) * self.units, 0))\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.fee = fees\n        t.input_total = value_in\n        t.output_total = int(round(float(tx['valueOut']) * self.units, 0))\n        t.fees = int(round(float(tx['fees']) * self.units, 0))\n        t.date = txdate\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['blockheight']\n        if t.confirmations == 0:\n            t.block_height = None\n            t.date = None\n        t.block_hash = tx.get('blockhash', '')\n        t.status = status\n        for n, ti in enumerate(tx['vin']):\n            t.inputs[n].value = int(round(float(ti['value'] or 0) * self.units, 0))\n        for i, to in enumerate(tx['vout']):\n            t.outputs[i].spent = to['spent']\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('address', a.address)\n            balance += int(float(res['balance']) / self.network.denominator)\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('utxo', address.address)\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx.get('scriptPubKey', ''),\n                'date': None\n            })\n        return txs[::-1][:limit]\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._convert_to_transaction(tx)\n\n    # FIXME: Not available anymore\n    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n    #     address = self._address_convert(address)\n    #     res = self.compose_request('addrs', address.address, 'txs')\n    #     txs = []\n    #     txs_dict = res['items'][::-1]\n    #     if after_txid:\n    #         txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n    #     for tx in txs_dict[:limit]:\n    #         if tx['txid'] == after_txid:\n    #             break\n    #         txs.append(self._convert_to_transaction(tx))\n    #     return txs\n\n    def getrawtransaction(self, txid):\n        res = self.compose_request('tx', txid)\n        return res['hex']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('sendtx', data=rawtx)\n        return {\n            'txid': res['result'],\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        res = self.compose_request('estimatefee', str(int(blocks)+1))\n        return int(float(res['result']) / self.network.denominator)\n\n    def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['blockbook']['bestHeight']\n\n    def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for tx in bd['txs'][(page-1)*limit:page*limit]:\n                txs.append(self.gettransaction(tx['txid']))\n        else:\n            txs = [tx['txid'] for tx in bd['txs']]\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleRoot'],\n            'nonce': int(bd['nonce']),\n            'prev_block': bd['previousBlockHash'],\n            'time': bd['time'],\n            'tx_count': bd['txCount'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['txs']) // limit) + (len(bd['txs']) % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    # def getrawblock(self, blockid):\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0\n\n    def getinfo(self):\n        info = self.compose_request('status', '')\n        return {\n            'blockcount': info['backend']['blocks'],\n            'chain': info['backend']['chain'],\n            'difficulty': int(float(info['backend']['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': info['blockbook']['mempoolSize'],\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + ('' if not cmd else '/' + cmd)\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)",
  "def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else int(round(float(tx['valueIn']) * self.units, 0))\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.fee = fees\n        t.input_total = value_in\n        t.output_total = int(round(float(tx['valueOut']) * self.units, 0))\n        t.fees = int(round(float(tx['fees']) * self.units, 0))\n        t.date = txdate\n        t.confirmations = tx['confirmations']\n        t.block_height = tx['blockheight']\n        if t.confirmations == 0:\n            t.block_height = None\n            t.date = None\n        t.block_hash = tx.get('blockhash', '')\n        t.status = status\n        for n, ti in enumerate(tx['vin']):\n            t.inputs[n].value = int(round(float(ti['value'] or 0) * self.units, 0))\n        for i, to in enumerate(tx['vout']):\n            t.outputs[i].spent = to['spent']\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('address', a.address)\n            balance += int(float(res['balance']) / self.network.denominator)\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('utxo', address.address)\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx.get('scriptPubKey', ''),\n                'date': None\n            })\n        return txs[::-1][:limit]",
  "def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._convert_to_transaction(tx)",
  "def getrawtransaction(self, txid):\n        res = self.compose_request('tx', txid)\n        return res['hex']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('sendtx', data=rawtx)\n        return {\n            'txid': res['result'],\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        res = self.compose_request('estimatefee', str(int(blocks)+1))\n        return int(float(res['result']) / self.network.denominator)",
  "def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['blockbook']['bestHeight']",
  "def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for tx in bd['txs'][(page-1)*limit:page*limit]:\n                txs.append(self.gettransaction(tx['txid']))\n        else:\n            txs = [tx['txid'] for tx in bd['txs']]\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleRoot'],\n            'nonce': int(bd['nonce']),\n            'prev_block': bd['previousBlockHash'],\n            'time': bd['time'],\n            'tx_count': bd['txCount'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['txs']) // limit) + (len(bd['txs']) % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def getinfo(self):\n        info = self.compose_request('status', '')\n        return {\n            'blockcount': info['backend']['blocks'],\n            'chain': info['backend']['chain'],\n            'difficulty': int(float(info['backend']['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': info['blockbook']['mempoolSize'],\n        }",
  "class BlocksmurferClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, parameter='', parameter2='', variables=None, post_data='', method='get'):\n        url_path = function\n        if parameter:\n            url_path += '/' + str(parameter)\n        if parameter2:\n            url_path += '/' + str(parameter2)\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address_balance', address)\n            balance += res['balance']\n        return balance\n\n    # TODO: fix blocksmurfer api\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        res = self.compose_request('utxos', address, variables={'after_txid': after_txid})\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        utxos = []\n        for u in res:\n            block_height = None if not u['block_height'] else u['block_height']\n            confirmations = u['confirmations']\n            if block_height and not confirmations:\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': u['txid'],\n                'confirmations': confirmations,\n                'output_n': u['output_n'],\n                'input_n': u['input_n'],\n                'block_height': block_height,\n                'fee': u['fee'],\n                'size': u['size'],\n                'value': u['value'],\n                'script': u['script'],\n                'date': datetime.strptime(u['date'][:19], \"%Y-%m-%dT%H:%M:%S\")\n            })\n        return utxos[:limit]\n\n    def _parse_transaction(self, tx, block_height=None):\n        block_height = block_height if not tx['block_height'] else tx['block_height']\n        confirmations = tx['confirmations']\n        if block_height and not confirmations and tx['status'] == 'confirmed':\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            confirmations = self.latest_block - block_height\n        # FIXME: Blocksmurfer returns 'date' or 'time', should be consistent\n        tx_date = None if not tx.get('date') else datetime.strptime(tx['date'], \"%Y-%m-%dT%H:%M:%S\")\n        if not tx_date and 'time' in tx:\n            tx_date = datetime.utcfromtimestamp(tx['time'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, input_total=tx['input_total'],\n                        output_total=tx['output_total'], confirmations=confirmations, block_height=block_height,\n                        status=tx['status'], coinbase=tx['coinbase'], rawtx=bytes.fromhex(tx['raw_hex']),\n                        witness_type=tx['witness_type'])\n        for ti in tx['inputs']:\n            t.add_input(prev_txid=ti['prev_txid'], output_n=ti['output_n'], keys=ti.get('keys', []),\n                        index_n=ti['index_n'], unlocking_script=ti['script'], value=ti['value'],\n                        public_hash=bytes.fromhex(ti['public_hash']), address=ti['address'],\n                        witness_type=ti['witness_type'], locktime_cltv=ti['locktime_cltv'],\n                        locktime_csv=ti['locktime_csv'], signatures=ti['signatures'], compressed=ti['compressed'],\n                        encoding=ti['encoding'], unlocking_script_unsigned=ti['script_code'],\n                        sigs_required=ti['sigs_required'], sequence=ti['sequence'],\n                        witnesses=[bytes.fromhex(w) for w in ti['witnesses']], script_type=ti['script_type'],\n                        strict=self.strict)\n        for to in tx['outputs']:\n            t.add_output(value=to['value'], address=to['address'], public_hash=to['public_hash'],\n                         lock_script=to['script'], spent=to['spent'], strict=self.strict)\n        t.update_totals()\n        return t\n\n    def gettransaction(self, txid, block_count=None):\n        tx = self.compose_request('transaction', txid)\n        return self._parse_transaction(tx, block_count)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        prtxs = []\n        while True:\n            txs = self.compose_request('transactions', address, variables={'after_txid': after_txid})\n            prtxs += txs\n            if not txs or len(txs) < limit:\n                break\n            after_txid = txs[-1:][0]['txid']\n        txs = []\n        for tx in prtxs:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n        return txs[:limit]\n\n    def getrawtransaction(self, txid):\n        tx = self.compose_request('transaction', txid, variables={'raw': True})\n        return tx['raw_hex']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('transaction_broadcast', post_data=rawtx, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        variables = {\n            'blocks': str(blocks)\n        }\n        res = self.compose_request('fees', variables=variables)\n        return res['estimated_fee_sat_kb']\n\n    def blockcount(self):\n        return self.compose_request('blockcount')['blockcount']\n\n    def mempool(self, txid):\n        if txid:\n            t = self.gettransaction(txid)\n            if t and not t.confirmations:\n                return [t.txid]\n        # else:\n            # return self.compose_request('mempool', 'txids')\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        variables = {'parse_transactions': parse_transactions, 'page': page, 'limit': limit}\n        bd = self.compose_request('block', str(blockid), variables=variables)\n\n        txs = []\n        if parse_transactions and bd['transactions'] and isinstance(bd['transactions'][0], dict):\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in bd['transactions']:\n                tx['confirmations'] = bd['depth']\n                tx['time'] = bd['time']\n                tx['block_height'] = bd['height']\n                tx['block_hash'] = bd['block_hash']\n                t = self._parse_transaction(tx, self.latest_block)\n                if t.txid != tx['txid']:\n                    raise ClientError(\"Could not parse tx %s. Different txid's\" % (tx['txid']))\n                txs.append(t)\n        else:\n            txs = bd['transactions']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['depth'],\n            'block_hash': bd['block_hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['prev_block'],\n            'time': bd['time'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        res = self.compose_request('rawblock', blockid)\n        return res\n\n    def isspent(self, txid, output_n):\n        res = self.compose_request('isspent', txid, str(output_n))\n        return 1 if res['spent'] else 0\n\n    def getinfo(self):\n        res = self.compose_request('')\n        info = {k: v for k, v in res.items() if k in ['chain', 'blockcount', 'hashrate', 'mempool_size',\n                                                      'difficulty']}\n        return info",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, parameter='', parameter2='', variables=None, post_data='', method='get'):\n        url_path = function\n        if parameter:\n            url_path += '/' + str(parameter)\n        if parameter2:\n            url_path += '/' + str(parameter2)\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address_balance', address)\n            balance += res['balance']\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        res = self.compose_request('utxos', address, variables={'after_txid': after_txid})\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        utxos = []\n        for u in res:\n            block_height = None if not u['block_height'] else u['block_height']\n            confirmations = u['confirmations']\n            if block_height and not confirmations:\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': u['txid'],\n                'confirmations': confirmations,\n                'output_n': u['output_n'],\n                'input_n': u['input_n'],\n                'block_height': block_height,\n                'fee': u['fee'],\n                'size': u['size'],\n                'value': u['value'],\n                'script': u['script'],\n                'date': datetime.strptime(u['date'][:19], \"%Y-%m-%dT%H:%M:%S\")\n            })\n        return utxos[:limit]",
  "def _parse_transaction(self, tx, block_height=None):\n        block_height = block_height if not tx['block_height'] else tx['block_height']\n        confirmations = tx['confirmations']\n        if block_height and not confirmations and tx['status'] == 'confirmed':\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            confirmations = self.latest_block - block_height\n        # FIXME: Blocksmurfer returns 'date' or 'time', should be consistent\n        tx_date = None if not tx.get('date') else datetime.strptime(tx['date'], \"%Y-%m-%dT%H:%M:%S\")\n        if not tx_date and 'time' in tx:\n            tx_date = datetime.utcfromtimestamp(tx['time'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, input_total=tx['input_total'],\n                        output_total=tx['output_total'], confirmations=confirmations, block_height=block_height,\n                        status=tx['status'], coinbase=tx['coinbase'], rawtx=bytes.fromhex(tx['raw_hex']),\n                        witness_type=tx['witness_type'])\n        for ti in tx['inputs']:\n            t.add_input(prev_txid=ti['prev_txid'], output_n=ti['output_n'], keys=ti.get('keys', []),\n                        index_n=ti['index_n'], unlocking_script=ti['script'], value=ti['value'],\n                        public_hash=bytes.fromhex(ti['public_hash']), address=ti['address'],\n                        witness_type=ti['witness_type'], locktime_cltv=ti['locktime_cltv'],\n                        locktime_csv=ti['locktime_csv'], signatures=ti['signatures'], compressed=ti['compressed'],\n                        encoding=ti['encoding'], unlocking_script_unsigned=ti['script_code'],\n                        sigs_required=ti['sigs_required'], sequence=ti['sequence'],\n                        witnesses=[bytes.fromhex(w) for w in ti['witnesses']], script_type=ti['script_type'],\n                        strict=self.strict)\n        for to in tx['outputs']:\n            t.add_output(value=to['value'], address=to['address'], public_hash=to['public_hash'],\n                         lock_script=to['script'], spent=to['spent'], strict=self.strict)\n        t.update_totals()\n        return t",
  "def gettransaction(self, txid, block_count=None):\n        tx = self.compose_request('transaction', txid)\n        return self._parse_transaction(tx, block_count)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        prtxs = []\n        while True:\n            txs = self.compose_request('transactions', address, variables={'after_txid': after_txid})\n            prtxs += txs\n            if not txs or len(txs) < limit:\n                break\n            after_txid = txs[-1:][0]['txid']\n        txs = []\n        for tx in prtxs:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n        return txs[:limit]",
  "def getrawtransaction(self, txid):\n        tx = self.compose_request('transaction', txid, variables={'raw': True})\n        return tx['raw_hex']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('transaction_broadcast', post_data=rawtx, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        variables = {\n            'blocks': str(blocks)\n        }\n        res = self.compose_request('fees', variables=variables)\n        return res['estimated_fee_sat_kb']",
  "def blockcount(self):\n        return self.compose_request('blockcount')['blockcount']",
  "def mempool(self, txid):\n        if txid:\n            t = self.gettransaction(txid)\n            if t and not t.confirmations:\n                return [t.txid]\n        # else:\n            # return self.compose_request('mempool', 'txids')\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        variables = {'parse_transactions': parse_transactions, 'page': page, 'limit': limit}\n        bd = self.compose_request('block', str(blockid), variables=variables)\n\n        txs = []\n        if parse_transactions and bd['transactions'] and isinstance(bd['transactions'][0], dict):\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in bd['transactions']:\n                tx['confirmations'] = bd['depth']\n                tx['time'] = bd['time']\n                tx['block_height'] = bd['height']\n                tx['block_hash'] = bd['block_hash']\n                t = self._parse_transaction(tx, self.latest_block)\n                if t.txid != tx['txid']:\n                    raise ClientError(\"Could not parse tx %s. Different txid's\" % (tx['txid']))\n                txs.append(t)\n        else:\n            txs = bd['transactions']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['depth'],\n            'block_hash': bd['block_hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['prev_block'],\n            'time': bd['time'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        res = self.compose_request('rawblock', blockid)\n        return res",
  "def isspent(self, txid, output_n):\n        res = self.compose_request('isspent', txid, str(output_n))\n        return 1 if res['spent'] else 0",
  "def getinfo(self):\n        res = self.compose_request('')\n        info = {k: v for k, v in res.items() if k in ['chain', 'blockcount', 'hashrate', 'mempool_size',\n                                                      'difficulty']}\n        return info",
  "class BitcoinLibTestClient(BaseClient):\n    \"\"\"\n    Dummy service client for bitcoinlib test network. Only used for testing.\n\n    Does not make any connection to a service provider, so can be used offline.\n\n    \"\"\"\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def getbalance(self, addresslist):\n        \"\"\"\n        Dummy getbalance method for bitcoinlib testnet\n\n        :param addresslist: List of addresses\n        :type addresslist: list\n\n        :return int:\n        \"\"\"\n        return self.units * len(addresslist)\n\n    def _get_txid(self, address, n):\n        try:\n            pkh = str(n).encode() + addr_to_pubkeyhash(address)[1:]\n        except Exception:\n            pkh = str(n).encode() + addr_bech32_to_pubkeyhash(address)[1:]\n        return hashlib.sha256(pkh).hexdigest()\n\n    def getutxos(self, address, after_txid='', limit=10, utxos_per_address=2):\n        \"\"\"\n        Dummy method to retreive UTXO's. This method creates a new UTXO for each address provided out of the\n        testnet void, which can be used to create test transactions for the bitcoinlib testnet.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos. If used only provide a single address\n        :type after_txid: str\n        :param limit: Maximum number of utxo's to return\n        :type limit: int\n\n        :return list: The created UTXO set\n        \"\"\"\n        utxos = []\n        for n in range(utxos_per_address):\n            txid = self._get_txid(address, n)\n            utxos.append(\n                {\n                    'address': address,\n                    'txid': txid,\n                    'confirmations': 10,\n                    'output_n': 0,\n                    'index': 0,\n                    'value': 1 * self.units,\n                    'script': '',\n                }\n            )\n        return utxos\n\n    # def gettransaction(self, tx_id):\n\n    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n\n    def sendrawtransaction(self, rawtx):\n        \"\"\"\n        Dummy method to send transactions on the bitcoinlib testnet. The bitcoinlib testnet does not exists,\n        so it just returns the transaction hash.\n\n        :param rawtx: A raw transaction hash\n        :type rawtx: bytes, str\n\n        :return str: Transaction hash\n        \"\"\"\n        txid = double_sha256(to_bytes(rawtx))[::-1].hex()\n        return {\n            'txid': txid,\n            'response_dict': {}\n        }\n\n    def estimatefee(self, blocks):\n        \"\"\"\n        Dummy estimate fee method for the bitcoinlib testnet.\n\n        :param blocks: Number of blocks\n        :type blocks: int\n\n        :return int: Fee as 100000 // number of blocks\n        \"\"\"\n        return 100000 // blocks\n\n    def blockcount(self):\n        return 1\n\n    def mempool(self, txid=''):\n        return [txid]",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def getbalance(self, addresslist):\n        \"\"\"\n        Dummy getbalance method for bitcoinlib testnet\n\n        :param addresslist: List of addresses\n        :type addresslist: list\n\n        :return int:\n        \"\"\"\n        return self.units * len(addresslist)",
  "def _get_txid(self, address, n):\n        try:\n            pkh = str(n).encode() + addr_to_pubkeyhash(address)[1:]\n        except Exception:\n            pkh = str(n).encode() + addr_bech32_to_pubkeyhash(address)[1:]\n        return hashlib.sha256(pkh).hexdigest()",
  "def getutxos(self, address, after_txid='', limit=10, utxos_per_address=2):\n        \"\"\"\n        Dummy method to retreive UTXO's. This method creates a new UTXO for each address provided out of the\n        testnet void, which can be used to create test transactions for the bitcoinlib testnet.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos. If used only provide a single address\n        :type after_txid: str\n        :param limit: Maximum number of utxo's to return\n        :type limit: int\n\n        :return list: The created UTXO set\n        \"\"\"\n        utxos = []\n        for n in range(utxos_per_address):\n            txid = self._get_txid(address, n)\n            utxos.append(\n                {\n                    'address': address,\n                    'txid': txid,\n                    'confirmations': 10,\n                    'output_n': 0,\n                    'index': 0,\n                    'value': 1 * self.units,\n                    'script': '',\n                }\n            )\n        return utxos",
  "def sendrawtransaction(self, rawtx):\n        \"\"\"\n        Dummy method to send transactions on the bitcoinlib testnet. The bitcoinlib testnet does not exists,\n        so it just returns the transaction hash.\n\n        :param rawtx: A raw transaction hash\n        :type rawtx: bytes, str\n\n        :return str: Transaction hash\n        \"\"\"\n        txid = double_sha256(to_bytes(rawtx))[::-1].hex()\n        return {\n            'txid': txid,\n            'response_dict': {}\n        }",
  "def estimatefee(self, blocks):\n        \"\"\"\n        Dummy estimate fee method for the bitcoinlib testnet.\n\n        :param blocks: Number of blocks\n        :type blocks: int\n\n        :return int: Fee as 100000 // number of blocks\n        \"\"\"\n        return 100000 // blocks",
  "def blockcount(self):\n        return 1",
  "def mempool(self, txid=''):\n        return [txid]",
  "class ChainSo(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, data='', parameter='', variables=None, method='get'):\n        url_path = function\n        url_path += '/' + self.provider_coin_id\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'api_key': self.api_key})\n        return self.request(url_path, variables, method)\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('send_tx', variables={'tx_hex': rawtx}, method='post')\n        return {\n            'txid': '' if 'data' not in res else res['data']['txid'],\n            'response_dict': res\n        }\n\n    def getbalance(self, addresslist):\n        balance = 0.0\n        for address in addresslist:\n            res = self.compose_request('get_address_balance', address)\n            balance += float(res['data']['confirmed_balance']) + float(res['data']['unconfirmed_balance'])\n        return int(balance * self.units)\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        lasttx = after_txid\n        res = self.compose_request('get_tx_unspent', address, lasttx)\n        if res['status'] != 'success':\n            pass\n        for tx in res['data']['txs'][:limit]:\n            txs.append({\n                'address': address,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': -1 if 'output_no' not in tx else tx['output_no'],\n                'input_n': -1 if 'input_no' not in tx else tx['input_no'],\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(round(float(tx['value']) * self.units, 0)),\n                'script': tx['script_hex'],\n                'date': datetime.utcfromtimestamp(tx['time']),\n            })\n        if len(txs) >= 1000:\n            _logger.warning(\"ChainSo: transaction list has been truncated, and thus is incomplete\")\n        return txs\n\n    def getrawtransaction(self, txid):\n        res = self.compose_request('get_tx', txid)\n        return res['data']['tx_hex']\n\n    def gettransaction(self, txid, block_height=None):\n        res = self.compose_request('get_tx', txid)\n        tx = res['data']\n        rawtx = tx['tx_hex']\n        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)\n        input_total = 0\n        output_total = 0\n        if not t.coinbase:\n            for n, i in enumerate(t.inputs):\n                i.value = int(round(float(tx['inputs'][n]['value']) * self.units, 0))\n                input_total += i.value\n        for o in t.outputs:\n            o.spent = None\n            output_total += o.value\n        if not t.block_height and tx['confirmations']:\n            t.block_height = self.getblock(tx['blockhash'], False, 1, 1)['height']\n        t.block_hash = tx['blockhash']\n        t.rawtx = bytes.fromhex(rawtx)\n        t.size = tx['size']\n        t.network = self.network\n        t.locktime = tx['locktime']\n        t.input_total = input_total\n        t.output_total = output_total\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        t.confirmations = tx['confirmations']\n        if tx['confirmations']:\n            t.status = 'confirmed'\n            t.date = datetime.utcfromtimestamp(tx['time'])\n        else:\n            t.status = 'unconfirmed'\n            t.date = None\n        return t\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        res1 = self.compose_request('get_tx_received', address, after_txid)\n        if res1['status'] != 'success':\n            raise ClientError(\"Chainso get_tx_received request unsuccessful, status: %s\" % res1['status'])\n        res2 = self.compose_request('get_tx_spent', address, after_txid)\n        if res2['status'] != 'success':\n            raise ClientError(\"Chainso get_tx_spent request unsuccessful, status: %s\" % res2['status'])\n        res = res1['data']['txs'] + res2['data']['txs']\n        res = sorted(res, key=lambda x: x['time'])\n        tx_conf = []\n        for t in res:\n            tt = (t['confirmations'], t['txid'])\n            if tt not in tx_conf:\n                tx_conf.append(tt)\n        for tx in tx_conf[:limit]:\n            t = self.gettransaction(tx[1])\n            txs.append(t)\n        return txs\n\n    def blockcount(self):\n        return self.compose_request('get_info')['data']['blocks']\n\n    def mempool(self, txid):\n        res = self.compose_request('is_tx_confirmed', txid)\n        if res['status'] == 'success' and res['data']['confirmations'] == 0:\n            return [txid]\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 5:\n            limit = 5\n        bd = self.compose_request('get_block', str(blockid))['data']\n        if parse_transactions:\n            txs = []\n            for txid in bd['txs'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(txid, block_height=bd['block_no']))\n                # except Exception as e:\n                #     raise ClientError(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['txs']\n\n        n_txs = len(bd['txs'])\n        block = {\n            'bits': None,\n            'depth': bd['confirmations'],\n            'block_hash': bd['blockhash'],\n            'height': bd['block_no'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': None,\n            'prev_block': bd['previous_blockhash'],\n            'time': bd['time'],\n            'tx_count': n_txs,\n            'txs': txs,\n            'version': b'',\n            'page': page,\n            'pages': None if not limit else int(n_txs // limit) + (n_txs % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    # def getrawblock(self, blockid):\n\n    # def isspent(self, txid, output_n):\n\n    def getinfo(self):\n        info = self.compose_request('get_info')['data']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['name'],\n            'difficulty': int(float(info['mining_difficulty'])),\n            'hashrate': int(float(info['hashrate'])),\n            'mempool_size': int(info['unconfirmed_txs']),\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, data='', parameter='', variables=None, method='get'):\n        url_path = function\n        url_path += '/' + self.provider_coin_id\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'api_key': self.api_key})\n        return self.request(url_path, variables, method)",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('send_tx', variables={'tx_hex': rawtx}, method='post')\n        return {\n            'txid': '' if 'data' not in res else res['data']['txid'],\n            'response_dict': res\n        }",
  "def getbalance(self, addresslist):\n        balance = 0.0\n        for address in addresslist:\n            res = self.compose_request('get_address_balance', address)\n            balance += float(res['data']['confirmed_balance']) + float(res['data']['unconfirmed_balance'])\n        return int(balance * self.units)",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        lasttx = after_txid\n        res = self.compose_request('get_tx_unspent', address, lasttx)\n        if res['status'] != 'success':\n            pass\n        for tx in res['data']['txs'][:limit]:\n            txs.append({\n                'address': address,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': -1 if 'output_no' not in tx else tx['output_no'],\n                'input_n': -1 if 'input_no' not in tx else tx['input_no'],\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(round(float(tx['value']) * self.units, 0)),\n                'script': tx['script_hex'],\n                'date': datetime.utcfromtimestamp(tx['time']),\n            })\n        if len(txs) >= 1000:\n            _logger.warning(\"ChainSo: transaction list has been truncated, and thus is incomplete\")\n        return txs",
  "def getrawtransaction(self, txid):\n        res = self.compose_request('get_tx', txid)\n        return res['data']['tx_hex']",
  "def gettransaction(self, txid, block_height=None):\n        res = self.compose_request('get_tx', txid)\n        tx = res['data']\n        rawtx = tx['tx_hex']\n        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)\n        input_total = 0\n        output_total = 0\n        if not t.coinbase:\n            for n, i in enumerate(t.inputs):\n                i.value = int(round(float(tx['inputs'][n]['value']) * self.units, 0))\n                input_total += i.value\n        for o in t.outputs:\n            o.spent = None\n            output_total += o.value\n        if not t.block_height and tx['confirmations']:\n            t.block_height = self.getblock(tx['blockhash'], False, 1, 1)['height']\n        t.block_hash = tx['blockhash']\n        t.rawtx = bytes.fromhex(rawtx)\n        t.size = tx['size']\n        t.network = self.network\n        t.locktime = tx['locktime']\n        t.input_total = input_total\n        t.output_total = output_total\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        t.confirmations = tx['confirmations']\n        if tx['confirmations']:\n            t.status = 'confirmed'\n            t.date = datetime.utcfromtimestamp(tx['time'])\n        else:\n            t.status = 'unconfirmed'\n            t.date = None\n        return t",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        res1 = self.compose_request('get_tx_received', address, after_txid)\n        if res1['status'] != 'success':\n            raise ClientError(\"Chainso get_tx_received request unsuccessful, status: %s\" % res1['status'])\n        res2 = self.compose_request('get_tx_spent', address, after_txid)\n        if res2['status'] != 'success':\n            raise ClientError(\"Chainso get_tx_spent request unsuccessful, status: %s\" % res2['status'])\n        res = res1['data']['txs'] + res2['data']['txs']\n        res = sorted(res, key=lambda x: x['time'])\n        tx_conf = []\n        for t in res:\n            tt = (t['confirmations'], t['txid'])\n            if tt not in tx_conf:\n                tx_conf.append(tt)\n        for tx in tx_conf[:limit]:\n            t = self.gettransaction(tx[1])\n            txs.append(t)\n        return txs",
  "def blockcount(self):\n        return self.compose_request('get_info')['data']['blocks']",
  "def mempool(self, txid):\n        res = self.compose_request('is_tx_confirmed', txid)\n        if res['status'] == 'success' and res['data']['confirmations'] == 0:\n            return [txid]\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 5:\n            limit = 5\n        bd = self.compose_request('get_block', str(blockid))['data']\n        if parse_transactions:\n            txs = []\n            for txid in bd['txs'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(txid, block_height=bd['block_no']))\n                # except Exception as e:\n                #     raise ClientError(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['txs']\n\n        n_txs = len(bd['txs'])\n        block = {\n            'bits': None,\n            'depth': bd['confirmations'],\n            'block_hash': bd['blockhash'],\n            'height': bd['block_no'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': None,\n            'prev_block': bd['previous_blockhash'],\n            'time': bd['time'],\n            'tx_count': n_txs,\n            'txs': txs,\n            'version': b'',\n            'page': page,\n            'pages': None if not limit else int(n_txs // limit) + (n_txs % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getinfo(self):\n        info = self.compose_request('get_info')['data']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['name'],\n            'difficulty': int(float(info['mining_difficulty'])),\n            'hashrate': int(float(info['hashrate'])),\n            'mempool_size': int(info['unconfirmed_txs']),\n        }",
  "class ConfigError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)\n\n    def __str__(self):\n        return self.msg",
  "def _read_from_config(configparser, section, value, fallback=None):\n    try:\n        return configparser.get(section, value)\n    except Exception:\n        return fallback",
  "class LitecoindClient(BaseClient):\n    \"\"\"\n    Class to interact with litecoind, the Litecoin deamon\n    \"\"\"\n\n    @staticmethod\n    def from_config(configfile=None, network='litecoin'):\n        \"\"\"\n        Read settings from litecoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet\n        :type: str\n\n        :return LitecoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'litecoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'litecoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.litecoin', '~/Application Data/Litecoin',\n                                '~/Library/Application Support/Litecoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install Litecoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/litecoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 19332\n        else:\n            port = 9332\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return LitecoindClient(network, url)\n\n    def __init__(self, network='litecoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to litecoin node\n\n        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for litecoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to litecoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.proxy.getaddressinfo(address)\n            if not (res['ismine'] or res['iswatchonly']):\n                raise ClientError(\n                    \"Address %s not found in litceoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                    \"address to wallet.\" % address)\n            txs_list = self.proxy.listunspent(0, 99999999, [address])\n            for tx in txs_list:\n                balance += int(tx['amount'] * self.units)\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in litecoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n\n        txs_list = self.proxy.listunspent(0, 99999999, [address])\n        blockcount = self.blockcount()\n        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            utxos.append({\n                'address': tx['address'],\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': -1,\n                'block_height': blockcount - tx['confirmations'] + 1,\n                'fee': None,\n                'size': 0,\n                'value': int(tx['amount'] * self.units),\n                'script': tx['scriptPubKey'],\n                'date': None,\n            })\n            if tx['txid'] == after_txid:\n                utxos = []\n\n        return utxos\n\n    def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx.get('confirmations')\n        t.block_hash = tx.get('blockhash')\n        t.status = 'unconfirmed'\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n\n        if not block_height and t.block_hash:\n            block_height = self.proxy.getblock(t.block_hash, 1)['height']\n        t.block_height = block_height\n        if not t.confirmations and block_height is not None:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.confirmations = (self.latest_block - block_height) + 1\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.version_int = tx['version']\n        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])\n        t.update_totals()\n        return t\n\n    def gettransaction(self, txid):\n        tx_raw = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx_raw)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        MAX_WALLET_TRANSACTIONS = 1000\n        txs = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n        txs_list = self.proxy.listtransactions(\"*\", MAX_WALLET_TRANSACTIONS, 0, True)\n        if len(txs_list) >= MAX_WALLET_TRANSACTIONS:\n            raise ClientError(\"Bitcoind wallet contains too many transactions %d, use other service provider for this \"\n                              \"wallet\" % MAX_WALLET_TRANSACTIONS)\n        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))\n        for (txid, blockheight) in txids:\n            tx_raw = self.proxy.getrawtransaction(txid, 1)\n            t = self._parse_transaction(tx_raw, blockheight)\n            txs.append(t)\n            if txid == after_txid:\n                txs = []\n        return txs\n\n    def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res\n\n    def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"litecoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)\n\n    def blockcount(self):\n        return self.proxy.getblockcount()\n\n    def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []\n\n    def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int) or len(blockid) < 10:\n            blockid = self.proxy.getblockhash(int(blockid))\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                tx['time'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)\n\n    def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0\n\n    def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)",
  "def __str__(self):\n        return self.msg",
  "def from_config(configfile=None, network='litecoin'):\n        \"\"\"\n        Read settings from litecoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet\n        :type: str\n\n        :return LitecoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'litecoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'litecoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.litecoin', '~/Application Data/Litecoin',\n                                '~/Library/Application Support/Litecoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install Litecoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/litecoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 19332\n        else:\n            port = 9332\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return LitecoindClient(network, url)",
  "def __init__(self, network='litecoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to litecoin node\n\n        :param network: Litecoin mainnet or testnet. Default is litecoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for litecoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to litecoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.proxy.getaddressinfo(address)\n            if not (res['ismine'] or res['iswatchonly']):\n                raise ClientError(\n                    \"Address %s not found in litceoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                    \"address to wallet.\" % address)\n            txs_list = self.proxy.listunspent(0, 99999999, [address])\n            for tx in txs_list:\n                balance += int(tx['amount'] * self.units)\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in litecoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n\n        txs_list = self.proxy.listunspent(0, 99999999, [address])\n        blockcount = self.blockcount()\n        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            utxos.append({\n                'address': tx['address'],\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': -1,\n                'block_height': blockcount - tx['confirmations'] + 1,\n                'fee': None,\n                'size': 0,\n                'value': int(tx['amount'] * self.units),\n                'script': tx['scriptPubKey'],\n                'date': None,\n            })\n            if tx['txid'] == after_txid:\n                utxos = []\n\n        return utxos",
  "def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx.get('confirmations')\n        t.block_hash = tx.get('blockhash')\n        t.status = 'unconfirmed'\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n\n        if not block_height and t.block_hash:\n            block_height = self.proxy.getblock(t.block_hash, 1)['height']\n        t.block_height = block_height\n        if not t.confirmations and block_height is not None:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.confirmations = (self.latest_block - block_height) + 1\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.version_int = tx['version']\n        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])\n        t.update_totals()\n        return t",
  "def gettransaction(self, txid):\n        tx_raw = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx_raw)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        MAX_WALLET_TRANSACTIONS = 1000\n        txs = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n        txs_list = self.proxy.listtransactions(\"*\", MAX_WALLET_TRANSACTIONS, 0, True)\n        if len(txs_list) >= MAX_WALLET_TRANSACTIONS:\n            raise ClientError(\"Bitcoind wallet contains too many transactions %d, use other service provider for this \"\n                              \"wallet\" % MAX_WALLET_TRANSACTIONS)\n        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))\n        for (txid, blockheight) in txids:\n            tx_raw = self.proxy.getrawtransaction(txid, 1)\n            t = self._parse_transaction(tx_raw, blockheight)\n            txs.append(t)\n            if txid == after_txid:\n                txs = []\n        return txs",
  "def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res",
  "def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"litecoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)",
  "def blockcount(self):\n        return self.proxy.getblockcount()",
  "def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []",
  "def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int) or len(blockid) < 10:\n            blockid = self.proxy.getblockhash(int(blockid))\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                tx['time'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)",
  "def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0",
  "def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "class BlockchainInfoClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, cmd, parameter='', variables=None, method='get'):\n        url_path = cmd\n        if parameter:\n            url_path += '/' + parameter\n        return self.request(url_path, variables, method=method)\n\n    def getbalance(self, addresslist):\n        addresses = {'active': '|'.join(addresslist)}\n        res = self.compose_request('balance', variables=addresses)\n        balance = 0\n        for address in res:\n            balance += res[address]['final_balance']\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        variables = {'active': address, 'limit': 1000}\n        res = self.compose_request('unspent', variables=variables)\n        if len(res['unspent_outputs']) > 299:\n            _logger.info(\"BlockchainInfoClient: Large number of outputs for address %s, \"\n                         \"UTXO list may be incomplete\" % address)\n        res['unspent_outputs'].sort(key=lambda x: x['confirmations'])\n        for utxo in res['unspent_outputs']:\n            if utxo['tx_hash_big_endian'] == after_txid:\n                break\n            utxos.append({\n                'address': address,\n                'txid': utxo['tx_hash_big_endian'],\n                'confirmations': utxo['confirmations'],\n                'output_n': utxo['tx_output_n'],\n                'input_n':  utxo['tx_index'],\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(round(utxo['value'] * self.units, 0)),\n                'script': utxo['script'],\n                'date': None\n            })\n        return utxos[::-1][:limit]\n\n    def gettransaction(self, txid, latest_block=None):\n        self.latest_block = self.latest_block if not latest_block else latest_block\n        tx = self.compose_request('rawtx', txid)\n        rawtx = self.getrawtransaction(txid)\n        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)\n        input_total = 0\n        for n, i in enumerate(t.inputs):\n            if 'prev_out' in tx['inputs'][n]:\n                i.value = 0 if not tx['inputs'][n]['prev_out'] else tx['inputs'][n]['prev_out']['value']\n                input_total += i.value\n        for n, o in enumerate(t.outputs):\n            o.spent = tx['out'][n]['spent']\n        if 'block_height' in tx and tx['block_height']:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.status = 'confirmed'\n            t.date = datetime.utcfromtimestamp(tx['time'])\n            t.block_height = tx['block_height']\n            t.confirmations = 1\n            if self.latest_block > t.block_height:\n                t.confirmations = self.latest_block - t.block_height\n        else:\n            t.status = 'unconfirmed'\n            t.confirmations = 0\n            t.date = None\n        t.rawtx = bytes.fromhex(rawtx)\n        t.size = tx['size']\n        t.network_name = self.network\n        t.locktime = tx['lock_time']\n        t.version_int = tx['ver']\n        t.version = tx['ver'].to_bytes(4, 'big')\n        t.input_total = input_total\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        return t\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        txids = []\n        variables = {'limit': 100}\n        res = self.compose_request('rawaddr', address, variables=variables)\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        for tx in res['txs']:\n            if tx['hash'] not in txids:\n                txids.insert(0, tx['hash'])\n        if after_txid:\n            txids = txids[txids.index(after_txid) + 1:]\n        for txid in txids[:limit]:\n            t = self.gettransaction(txid, latest_block=self.latest_block)\n            t.confirmations = 0 if not t.block_height else self.latest_block - t.block_height\n            txs.append(t)\n        return txs\n\n    def getrawtransaction(self, txid):\n        return self.compose_request('rawtx', txid, {'format': 'hex'})\n\n    # def sendrawtransaction()\n\n    # def estimatefee()\n\n    def blockcount(self):\n        return self.compose_request('latestblock')['height']\n\n    def mempool(self, txid=''):\n        if txid:\n            tx = self.compose_request('rawtx', txid)\n            if 'block_height' not in tx:\n                return [tx['hash']]\n        else:\n            txs = self.compose_request('unconfirmed-transactions', variables={'format': 'json'})\n            return [tx['hash'] for tx in txs['txs']]\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('rawblock', str(blockid))\n        if parse_transactions:\n            txs = []\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in bd['tx'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(tx['hash'], latest_block=self.latest_block))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['hash'], e))\n        else:\n            txs = [tx['hash'] for tx in bd['tx']]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['mrkl_root'],\n            'nonce': abs(bd['nonce']),\n            'prev_block': bd['prev_block'],\n            'time': bd['time'],\n            'tx_count': len(bd['tx']),\n            'txs': txs,\n            'version': bd['ver'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        return self.compose_request('rawblock', str(blockid), {'format': 'hex'})\n\n    # def isspent(self, txid, index):\n\n    def getinfo(self):\n        import requests\n        import json\n        info = json.loads(requests.get('https://api.blockchain.info/stats', timeout=self.timeout).text)\n        unconfirmed = self.compose_request('q', 'unconfirmedcount')\n        return {\n            'blockcount': info['n_blocks_total'],\n            'chain': '',\n            'difficulty': info['difficulty'],\n            'hashrate': int(float(info['hash_rate'] * 10**9)),\n            'mempool_size': unconfirmed,\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, cmd, parameter='', variables=None, method='get'):\n        url_path = cmd\n        if parameter:\n            url_path += '/' + parameter\n        return self.request(url_path, variables, method=method)",
  "def getbalance(self, addresslist):\n        addresses = {'active': '|'.join(addresslist)}\n        res = self.compose_request('balance', variables=addresses)\n        balance = 0\n        for address in res:\n            balance += res[address]['final_balance']\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        variables = {'active': address, 'limit': 1000}\n        res = self.compose_request('unspent', variables=variables)\n        if len(res['unspent_outputs']) > 299:\n            _logger.info(\"BlockchainInfoClient: Large number of outputs for address %s, \"\n                         \"UTXO list may be incomplete\" % address)\n        res['unspent_outputs'].sort(key=lambda x: x['confirmations'])\n        for utxo in res['unspent_outputs']:\n            if utxo['tx_hash_big_endian'] == after_txid:\n                break\n            utxos.append({\n                'address': address,\n                'txid': utxo['tx_hash_big_endian'],\n                'confirmations': utxo['confirmations'],\n                'output_n': utxo['tx_output_n'],\n                'input_n':  utxo['tx_index'],\n                'block_height': None,\n                'fee': None,\n                'size': 0,\n                'value': int(round(utxo['value'] * self.units, 0)),\n                'script': utxo['script'],\n                'date': None\n            })\n        return utxos[::-1][:limit]",
  "def gettransaction(self, txid, latest_block=None):\n        self.latest_block = self.latest_block if not latest_block else latest_block\n        tx = self.compose_request('rawtx', txid)\n        rawtx = self.getrawtransaction(txid)\n        t = Transaction.parse_hex(rawtx, strict=self.strict, network=self.network)\n        input_total = 0\n        for n, i in enumerate(t.inputs):\n            if 'prev_out' in tx['inputs'][n]:\n                i.value = 0 if not tx['inputs'][n]['prev_out'] else tx['inputs'][n]['prev_out']['value']\n                input_total += i.value\n        for n, o in enumerate(t.outputs):\n            o.spent = tx['out'][n]['spent']\n        if 'block_height' in tx and tx['block_height']:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.status = 'confirmed'\n            t.date = datetime.utcfromtimestamp(tx['time'])\n            t.block_height = tx['block_height']\n            t.confirmations = 1\n            if self.latest_block > t.block_height:\n                t.confirmations = self.latest_block - t.block_height\n        else:\n            t.status = 'unconfirmed'\n            t.confirmations = 0\n            t.date = None\n        t.rawtx = bytes.fromhex(rawtx)\n        t.size = tx['size']\n        t.network_name = self.network\n        t.locktime = tx['lock_time']\n        t.version_int = tx['ver']\n        t.version = tx['ver'].to_bytes(4, 'big')\n        t.input_total = input_total\n        t.fee = 0\n        if t.input_total:\n            t.fee = t.input_total - t.output_total\n        return t",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txs = []\n        txids = []\n        variables = {'limit': 100}\n        res = self.compose_request('rawaddr', address, variables=variables)\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        for tx in res['txs']:\n            if tx['hash'] not in txids:\n                txids.insert(0, tx['hash'])\n        if after_txid:\n            txids = txids[txids.index(after_txid) + 1:]\n        for txid in txids[:limit]:\n            t = self.gettransaction(txid, latest_block=self.latest_block)\n            t.confirmations = 0 if not t.block_height else self.latest_block - t.block_height\n            txs.append(t)\n        return txs",
  "def getrawtransaction(self, txid):\n        return self.compose_request('rawtx', txid, {'format': 'hex'})",
  "def blockcount(self):\n        return self.compose_request('latestblock')['height']",
  "def mempool(self, txid=''):\n        if txid:\n            tx = self.compose_request('rawtx', txid)\n            if 'block_height' not in tx:\n                return [tx['hash']]\n        else:\n            txs = self.compose_request('unconfirmed-transactions', variables={'format': 'json'})\n            return [tx['hash'] for tx in txs['txs']]\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('rawblock', str(blockid))\n        if parse_transactions:\n            txs = []\n            self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n            for tx in bd['tx'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(tx['hash'], latest_block=self.latest_block))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (tx['hash'], e))\n        else:\n            txs = [tx['hash'] for tx in bd['tx']]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['mrkl_root'],\n            'nonce': abs(bd['nonce']),\n            'prev_block': bd['prev_block'],\n            'time': bd['time'],\n            'tx_count': len(bd['tx']),\n            'txs': txs,\n            'version': bd['ver'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        return self.compose_request('rawblock', str(blockid), {'format': 'hex'})",
  "def getinfo(self):\n        import requests\n        import json\n        info = json.loads(requests.get('https://api.blockchain.info/stats', timeout=self.timeout).text)\n        unconfirmed = self.compose_request('q', 'unconfirmedcount')\n        return {\n            'blockcount': info['n_blocks_total'],\n            'chain': '',\n            'difficulty': info['difficulty'],\n            'hashrate': int(float(info['hash_rate'] * 10**9)),\n            'mempool_size': unconfirmed,\n        }",
  "class BitflyerClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, parameter='', parameter2='', method='get'):\n        url_path = function\n        if parameter:\n            url_path += '/' + str(parameter)\n        if parameter2:\n            url_path += '/' + str(parameter2)\n        return self.request(url_path, method=method)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', address)\n            balance += res['unconfirmed_balance']\n        return balance\n\n    # def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n\n    # def gettransaction(self, txid, block_count=None):\n    #     tx = self.compose_request('tx', txid)\n    #     # tx_date = None if not tx.get('received_date') else datetime.strptime(tx['received_date'],\n    #     #                                                                      \"%Y-%m-%dT%H:%M:%S.%f\")\n    #     t = Transaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,\n    #                     # fee=tx['fees'], size=tx['size'], txid=tx['tx_hash'], date=tx_date,\n    #                     confirmations=tx['confirmed'], block_height=tx['block_height'],\n    #                     status='confirmed' if tx['confirmed'] else 'unconfirmed')\n    #     for ti in tx['inputs']:\n    #         a = Address.parse(ti['address'])\n    #         t.add_input(prev_txid=ti['prev_hash'], output_n=ti['prev_index'], unlocking_script=ti['script'],\n    #                     value=ti['value'], address=ti['address'], sequence=ti['sequence'],\n    #                     witness_type=a.witness_type, strict=self.strict)\n    #     if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:\n    #         t.witness_type = 'segwit'\n    #     for to in tx['outputs']:\n    #         t.add_output(value=to['value'], address=to['address'], lock_script=to['script'], strict=self.strict)\n    #     t.update_totals()\n    #     return t\n\n    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n\n    # def getrawtransaction(self, txid):\n\n    # def sendrawtransaction(self, rawtx):\n\n    # def estimatefee(self, blocks):\n\n    def blockcount(self):\n        res = self.compose_request('block', 'latest')\n        return res['height']",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, parameter='', parameter2='', method='get'):\n        url_path = function\n        if parameter:\n            url_path += '/' + str(parameter)\n        if parameter2:\n            url_path += '/' + str(parameter2)\n        return self.request(url_path, method=method)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', address)\n            balance += res['unconfirmed_balance']\n        return balance",
  "def blockcount(self):\n        res = self.compose_request('block', 'latest')\n        return res['height']",
  "class ConfigError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)\n\n    def __str__(self):\n        return self.msg",
  "def _read_from_config(configparser, section, value, fallback=None):\n    try:\n        return configparser.get(section, value)\n    except Exception:\n        return fallback",
  "class BitcoindClient(BaseClient):\n    \"\"\"\n    Class to interact with bitcoind, the Bitcoin deamon\n    \"\"\"\n\n    @staticmethod\n    def from_config(configfile=None, network='bitcoin'):\n        \"\"\"\n        Read settings from bitcoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet\n        :type: str\n\n        :return BitcoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'bitcoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'bitcoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.bitcoin', '~/Application Data/Bitcoin',\n                                '~/Library/Application Support/Bitcoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install bitcoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/bitcoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 18332\n        else:\n            port = 8332\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return BitcoindClient(network, url)\n\n    def __init__(self, network='bitcoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to bitcoin node\n\n        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for bitcoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to bitcoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.proxy.getaddressinfo(address)\n            if not (res['ismine'] or res['iswatchonly']):\n                raise ClientError(\n                    \"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                    \"address to wallet.\" % address)\n            txs_list = self.proxy.listunspent(0, 99999999, [address])\n            for tx in txs_list:\n                balance += int(tx['amount'] * self.units)\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n\n        txs_list = self.proxy.listunspent(0, 9999999, [address])\n        blockcount = self.blockcount()\n        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            utxos.append({\n                'address': tx['address'],\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': -1,\n                'block_height': blockcount - tx['confirmations'] + 1,\n                'fee': None,\n                'size': 0,\n                'value': int(tx['amount'] * self.units),\n                'script': tx['scriptPubKey'],\n                'date': None,\n            })\n            if tx['txid'] == after_txid:\n                utxos = []\n\n        return utxos\n\n    def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx.get('confirmations')\n        t.block_hash = tx.get('blockhash')\n        t.status = 'unconfirmed'\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n\n        if not block_height and t.block_hash:\n            block_height = self.proxy.getblock(t.block_hash, 1)['height']\n        t.block_height = block_height\n        if not t.confirmations and block_height is not None:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.confirmations = (self.latest_block - block_height) + 1\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.version_int = tx['version']\n        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])\n        t.update_totals()\n        return t\n\n    def gettransaction(self, txid):\n        tx_raw = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx_raw)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        MAX_WALLET_TRANSACTIONS = 1000\n        txs = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n        txs_list = self.proxy.listtransactions(\"*\", MAX_WALLET_TRANSACTIONS, 0, True)\n        if len(txs_list) >= MAX_WALLET_TRANSACTIONS:\n            raise ClientError(\"Bitcoind wallet contains too many transactions %d, use other service provider for this \"\n                              \"wallet\" % MAX_WALLET_TRANSACTIONS)\n        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))\n        for (txid, blockheight) in txids:\n            tx_raw = self.proxy.getrawtransaction(txid, 1)\n            t = self._parse_transaction(tx_raw, blockheight)\n            txs.append(t)\n            if txid == after_txid:\n                txs = []\n        return txs\n\n    def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res\n\n    def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"bitcoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)\n\n    def blockcount(self):\n        bcinfo = self.proxy.getblockchaininfo()\n        if bcinfo['headers'] - bcinfo['blocks'] > 2:\n            raise ClientError(\"Node not fully synced! Currently %d blocks synced and %d blocks known\" %\n                              (bcinfo['blocks'], bcinfo['headers']))\n        return bcinfo['blocks']\n\n    def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []\n\n    def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int) or len(blockid) < 10:\n            blockid = self.proxy.getblockhash(int(blockid))\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                tx['time'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)\n\n    def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0\n\n    def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.info(msg)",
  "def __str__(self):\n        return self.msg",
  "def from_config(configfile=None, network='bitcoin'):\n        \"\"\"\n        Read settings from bitcoind config file\n\n        :param configfile: Path to config file. Leave empty to look in default places\n        :type: str\n        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet\n        :type: str\n\n        :return BitcoindClient:\n        \"\"\"\n        try:\n            config = configparser.ConfigParser(strict=False)\n        except TypeError:\n            config = configparser.ConfigParser()\n        config_fn = 'bitcoin.conf'\n        if isinstance(network, Network):\n            network = network.name\n        if network == 'testnet':\n            config_fn = 'bitcoin-testnet.conf'\n\n        cfn = None\n        if not configfile:\n            config_locations = ['~/.bitcoinlib', '~/.bitcoin', '~/Application Data/Bitcoin',\n                                '~/Library/Application Support/Bitcoin']\n            for location in config_locations:\n                cfn = Path(location, config_fn).expanduser()\n                if cfn.exists():\n                    break\n        else:\n            cfn = Path(BCL_DATA_DIR, 'config', configfile)\n\n        if not cfn or not cfn.is_file():\n            raise ConfigError(\"Config file %s not found. Please install bitcoin client and specify a path to config \"\n                              \"file if path is not default. Or place a config file in .bitcoinlib/bitcoin.conf to \"\n                              \"reference to an external server.\" % cfn)\n\n        try:\n            config.read(cfn)\n        except Exception:\n            with cfn.open() as f:\n                config_string = '[rpc]\\n' + f.read()\n            config.read_string(config_string)\n\n        testnet = _read_from_config(config, 'rpc', 'testnet')\n        if testnet:\n            network = 'testnet'\n        if _read_from_config(config, 'rpc', 'rpcpassword') == 'specify_rpc_password':\n            raise ConfigError(\"Please update config settings in %s\" % cfn)\n        if network == 'testnet':\n            port = 18332\n        else:\n            port = 8332\n        port = _read_from_config(config, 'rpc', 'rpcport', port)\n        server = '127.0.0.1'\n        server = _read_from_config(config, 'rpc', 'rpcconnect', server)\n        server = _read_from_config(config, 'rpc', 'bind', server)\n        server = _read_from_config(config, 'rpc', 'externalip', server)\n\n        url = \"http://%s:%s@%s:%s\" % (config.get('rpc', 'rpcuser'), config.get('rpc', 'rpcpassword'), server, port)\n        return BitcoindClient(network, url)",
  "def __init__(self, network='bitcoin', base_url='', denominator=100000000, *args):\n        \"\"\"\n        Open connection to bitcoin node\n\n        :param network: Bitcoin mainnet or testnet. Default is bitcoin mainnet\n        :type: str\n        :param base_url: Connection URL in format http(s)://user:password@host:port.\n        :type: str\n        :param denominator: Denominator for this currency. Should be always 100000000 (satoshis) for bitcoin\n        :type: str\n        \"\"\"\n        if isinstance(network, Network):\n            network = network.name\n        if not base_url:\n            bdc = self.from_config('', network)\n            base_url = bdc.base_url\n            network = bdc.network\n        _logger.info(\"Connect to bitcoind\")\n        self.proxy = AuthServiceProxy(base_url)\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.proxy.getaddressinfo(address)\n            if not (res['ismine'] or res['iswatchonly']):\n                raise ClientError(\n                    \"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                    \"address to wallet.\" % address)\n            txs_list = self.proxy.listunspent(0, 99999999, [address])\n            for tx in txs_list:\n                balance += int(tx['amount'] * self.units)\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n\n        txs_list = self.proxy.listunspent(0, 9999999, [address])\n        blockcount = self.blockcount()\n        for tx in sorted(txs_list, key=lambda x: x['confirmations'], reverse=True):\n            utxos.append({\n                'address': tx['address'],\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': -1,\n                'block_height': blockcount - tx['confirmations'] + 1,\n                'fee': None,\n                'size': 0,\n                'value': int(tx['amount'] * self.units),\n                'script': tx['scriptPubKey'],\n                'date': None,\n            })\n            if tx['txid'] == after_txid:\n                utxos = []\n\n        return utxos",
  "def _parse_transaction(self, tx, block_height=None, get_input_values=True):\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.confirmations = tx.get('confirmations')\n        t.block_hash = tx.get('blockhash')\n        t.status = 'unconfirmed'\n        for i in t.inputs:\n            if i.prev_txid == b'\\x00' * 32:\n                i.script_type = 'coinbase'\n                continue\n            if get_input_values:\n                txi = self.proxy.getrawtransaction(i.prev_txid.hex(), 1)\n                i.value = int(round(float(txi['vout'][i.output_n_int]['value']) / self.network.denominator))\n        for o in t.outputs:\n            o.spent = None\n\n        if not block_height and t.block_hash:\n            block_height = self.proxy.getblock(t.block_hash, 1)['height']\n        t.block_height = block_height\n        if not t.confirmations and block_height is not None:\n            if not self.latest_block:\n                self.latest_block = self.blockcount()\n            t.confirmations = (self.latest_block - block_height) + 1\n        if t.confirmations or block_height:\n            t.status = 'confirmed'\n            t.verified = True\n        t.version = tx['version'].to_bytes(4, 'big')\n        t.version_int = tx['version']\n        t.date = None if 'time' not in tx else datetime.utcfromtimestamp(tx['time'])\n        t.update_totals()\n        return t",
  "def gettransaction(self, txid):\n        tx_raw = self.proxy.getrawtransaction(txid, 1)\n        return self._parse_transaction(tx_raw)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        MAX_WALLET_TRANSACTIONS = 1000\n        txs = []\n        res = self.proxy.getaddressinfo(address)\n        if not (res['ismine'] or res['iswatchonly']):\n            raise ClientError(\"Address %s not found in bitcoind wallet, use 'importpubkey' or 'importaddress' to add \"\n                              \"address to wallet.\" % address)\n        txs_list = self.proxy.listtransactions(\"*\", MAX_WALLET_TRANSACTIONS, 0, True)\n        if len(txs_list) >= MAX_WALLET_TRANSACTIONS:\n            raise ClientError(\"Bitcoind wallet contains too many transactions %d, use other service provider for this \"\n                              \"wallet\" % MAX_WALLET_TRANSACTIONS)\n        txids = list(set([(tx['txid'], tx['blockheight']) for tx in txs_list if tx['address'] == address]))\n        for (txid, blockheight) in txids:\n            tx_raw = self.proxy.getrawtransaction(txid, 1)\n            t = self._parse_transaction(tx_raw, blockheight)\n            txs.append(t)\n            if txid == after_txid:\n                txs = []\n        return txs",
  "def getrawtransaction(self, txid):\n        res = self.proxy.getrawtransaction(txid)\n        return res",
  "def sendrawtransaction(self, rawtx):\n        res = self.proxy.sendrawtransaction(rawtx)\n        return {\n            'txid': res,\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        pres = ''\n        try:\n            pres = self.proxy.estimatesmartfee(blocks)\n            res = pres['feerate']\n        except KeyError as e:\n            _logger.info(\"bitcoind error: %s, %s\" % (e, pres))\n            res = self.proxy.estimatefee(blocks)\n        return int(res * self.units)",
  "def blockcount(self):\n        bcinfo = self.proxy.getblockchaininfo()\n        if bcinfo['headers'] - bcinfo['blocks'] > 2:\n            raise ClientError(\"Node not fully synced! Currently %d blocks synced and %d blocks known\" %\n                              (bcinfo['blocks'], bcinfo['headers']))\n        return bcinfo['blocks']",
  "def mempool(self, txid=''):\n        txids = self.proxy.getrawmempool()\n        if not txid:\n            return txids\n        elif txid in txids:\n            return [txid]\n        return []",
  "def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        if isinstance(blockid, int) or len(blockid) < 10:\n            blockid = self.proxy.getblockhash(int(blockid))\n        if not limit:\n            limit = 99999\n\n        txs = []\n        if parse_transactions:\n            bd = self.proxy.getblock(blockid, 2)\n            for tx in bd['tx'][(page - 1) * limit:page * limit]:\n                tx['time'] = bd['time']\n                tx['blockhash'] = bd['hash']\n                txs.append(self._parse_transaction(tx, block_height=bd['height'], get_input_values=True))\n        else:\n            bd = self.proxy.getblock(blockid, 1)\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': None if 'previousblockhash' not in bd else bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': bd['nTx'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None,\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.proxy.getblockhash(blockid)\n        return self.proxy.getblock(blockid, 0)",
  "def isspent(self, txid, index):\n        res = self.proxy.gettxout(txid, index)\n        if not res:\n            return 1\n        return 0",
  "def getinfo(self):\n        info = self.proxy.getmininginfo()\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['chain'],\n            'difficulty': int(info['difficulty']),\n            'hashrate': int(info['networkhashps']),\n            'mempool_size': int(info['pooledtx']),\n        }",
  "class InsightDashClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + '/' + cmd\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)\n\n    def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else tx['valueIn']\n        isCoinbase = False\n        if 'isCoinBase' in tx and tx['isCoinBase']:\n            isCoinbase = True\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fees, size=tx['size'], txid=tx['txid'],\n                        date=txdate, confirmations=tx['confirmations'],\n                        block_height=tx['blockheight'], status=status,\n                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,\n                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))\n        for ti in tx['vin']:\n            if isCoinbase:\n                t.add_input(prev_txid=32 * b'\\0', output_n=4*b'\\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],\n                            script_type='coinbase', sequence=ti['sequence'], value=0)\n            else:\n                value = int(round(float(ti['value']) * self.units, 0))\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],\n                            index_n=ti['n'], value=value, sequence=ti['sequence'],\n                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'],\n                            strict=self.strict)\n        for to in tx['vout']:\n            value = int(round(float(to['value']) * self.units, 0))\n            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],\n                         spent=True if to['spentTxId'] else False, output_n=to['n'],\n                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],\n                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('addr', a.address, 'balance')\n            balance += res\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'utxo')\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx['scriptPubKey'],\n                'date': None\n            })\n        return txs[::-1][:limit]\n\n    def gettransaction(self, tx_id):\n        tx = self.compose_request('tx', tx_id)\n        return self._convert_to_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'txs')\n        txs = []\n        txs_dict = res['items'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs\n\n    def getrawtransaction(self, tx_id):\n        res = self.compose_request('rawtx', tx_id)\n        return res['rawtx']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }\n\n    # def estimatefee\n\n    def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['info']['blocks']\n\n    def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for txid in bd['tx'][(page-1)*limit:page*limit]:\n                try:\n                    txs.append(self.gettransaction(txid))\n                except Exception as e:\n                    _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['tx']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['confirmations'],\n            'hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': datetime.utcfromtimestamp(bd['time']),\n            'total_txs': len(bd['tx']),\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0\n\n    def getinfo(self):\n        info = self.compose_request('status', '')['info']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['network'],\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': 0,\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + '/' + cmd\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)",
  "def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else tx['valueIn']\n        isCoinbase = False\n        if 'isCoinBase' in tx and tx['isCoinBase']:\n            isCoinbase = True\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fees, size=tx['size'], txid=tx['txid'],\n                        date=txdate, confirmations=tx['confirmations'],\n                        block_height=tx['blockheight'], status=status,\n                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,\n                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))\n        for ti in tx['vin']:\n            if isCoinbase:\n                t.add_input(prev_txid=32 * b'\\0', output_n=4*b'\\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],\n                            script_type='coinbase', sequence=ti['sequence'], value=0)\n            else:\n                value = int(round(float(ti['value']) * self.units, 0))\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],\n                            index_n=ti['n'], value=value, sequence=ti['sequence'],\n                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'],\n                            strict=self.strict)\n        for to in tx['vout']:\n            value = int(round(float(to['value']) * self.units, 0))\n            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],\n                         spent=True if to['spentTxId'] else False, output_n=to['n'],\n                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],\n                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('addr', a.address, 'balance')\n            balance += res\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'utxo')\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx['scriptPubKey'],\n                'date': None\n            })\n        return txs[::-1][:limit]",
  "def gettransaction(self, tx_id):\n        tx = self.compose_request('tx', tx_id)\n        return self._convert_to_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'txs')\n        txs = []\n        txs_dict = res['items'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs",
  "def getrawtransaction(self, tx_id):\n        res = self.compose_request('rawtx', tx_id)\n        return res['rawtx']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }",
  "def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['info']['blocks']",
  "def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for txid in bd['tx'][(page-1)*limit:page*limit]:\n                try:\n                    txs.append(self.gettransaction(txid))\n                except Exception as e:\n                    _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['tx']\n\n        block = {\n            'bits': bd['bits'],\n            'depth': bd['confirmations'],\n            'hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': datetime.utcfromtimestamp(bd['time']),\n            'total_txs': len(bd['tx']),\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def getinfo(self):\n        info = self.compose_request('status', '')['info']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['network'],\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': 0,\n        }",
  "class ServiceError(Exception):\n    def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)\n\n    def __str__(self):\n        return self.msg",
  "class Service(object):\n    \"\"\"\n    Class to connect to various cryptocurrency service providers. Use to receive network and blockchain information,\n    get specific transaction information, current network fees or push a raw transaction.\n\n    The Service class connects to 1 or more service providers at random to retrieve or send information. If a service\n    providers fails to correctly respond the Service class will try another available provider.\n\n    \"\"\"\n\n    def __init__(self, network=DEFAULT_NETWORK, min_providers=1, max_providers=1, providers=None,\n                 timeout=TIMEOUT_REQUESTS, cache_uri=None, ignore_priority=False, exclude_providers=None,\n                 max_errors=SERVICE_MAX_ERRORS, strict=True):\n        \"\"\"\n        Create a service object for the specified network. By default, the object connect to 1 service provider, but you\n        can specify a list of providers or a minimum or maximum number of providers.\n\n        :param network: Specify network used\n        :type network: str, Network\n        :param min_providers: Minimum number of providers to connect to. Default is 1. Use for instance to receive fee information from a number of providers and calculate the average fee.\n        :type min_providers: int\n        :param max_providers: Maximum number of providers to connect to. Default is 1.\n        :type max_providers: int\n        :param providers: List of providers to connect to. Default is all providers and select a provider at random.\n        :type providers: list of str\n        :param timeout: Timeout for web requests. Leave empty to use default from config settings\n        :type timeout: int\n        :param cache_uri: Database to use for caching\n        :type cache_uri: str\n        :param ignore_priority: Ignores provider priority if set to True. Could be used for unit testing, so no providers are missed when testing. Default is False\n        :type ignore_priority: bool\n        :param exclude_providers: Exclude providers in this list, can be used when problems with certain providers arise.\n        :type exclude_providers: list of str\n        :param strict: Strict checks of valid signatures, scripts and transactions. Normally use strict=True for wallets, transaction validations etcetera. For blockchain parsing strict=False should be used, but be sure to check warnings in the log file. Default is True.\n        :type strict: bool\n\n        \"\"\"\n\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        if min_providers > max_providers:\n            max_providers = min_providers\n        fn = Path(BCL_DATA_DIR, 'providers.json')\n        f = fn.open(\"r\")\n\n        try:\n            self.providers_defined = json.loads(f.read())\n        except json.decoder.JSONDecodeError as e:  # pragma: no cover\n            errstr = \"Error reading provider definitions from %s: %s\" % (fn, e)\n            _logger.warning(errstr)\n            raise ServiceError(errstr)\n        f.close()\n\n        provider_list = list([self.providers_defined[x]['provider'] for x in self.providers_defined])\n        if providers is None:\n            providers = []\n        if exclude_providers is None:\n            exclude_providers = []\n        if not isinstance(providers, list):\n            providers = [providers]\n        for p in providers:\n            if p not in provider_list:\n                raise ServiceError(\"Provider '%s' not found in provider definitions\" % p)\n\n        self.providers = {}\n        for p in self.providers_defined:\n            if (self.providers_defined[p]['network'] == network or self.providers_defined[p]['network'] == '') and \\\n                    (not providers or self.providers_defined[p]['provider'] in providers):\n                self.providers.update({p: self.providers_defined[p]})\n        for nop in exclude_providers:\n            if nop in self.providers:\n                del(self.providers[nop])\n\n        if not self.providers:\n            raise ServiceError(\"No providers found for network %s\" % network)\n        self.min_providers = min_providers\n        self.max_providers = max_providers\n        self.results = {}\n        self.errors = {}\n        self.resultcount = 0\n        self.max_errors = max_errors\n        self.complete = None\n        self.timeout = timeout\n        self._blockcount_update = 0\n        self._blockcount = None\n        self.cache = None\n        self.cache_uri = cache_uri\n        try:\n            self.cache = Cache(self.network, db_uri=cache_uri)\n        except Exception as e:\n            self.cache = Cache(self.network, db_uri='')\n            _logger.warning(\"Could not connect to cache database. Error: %s\" % e)\n        self.results_cache_n = 0\n        self.ignore_priority = ignore_priority\n        self.strict = strict\n        if self.min_providers > 1:\n            self._blockcount = Service(network=network, cache_uri=cache_uri).blockcount()\n        else:\n            self._blockcount = self.blockcount()\n\n    def __exit__(self):\n        try:\n            self.cache.session.close()\n        except Exception:\n            pass\n\n    def _reset_results(self):\n        self.results = {}\n        self.errors = {}\n        self.complete = None\n        self.resultcount = 0\n\n    def _provider_execute(self, method, *arguments):\n        self._reset_results()\n        provider_lst = [p[0] for p in sorted([(x, self.providers[x]['priority']) for x in self.providers],\n                        key=lambda x: (x[1], random.random()), reverse=True)]\n        if self.ignore_priority:\n            random.shuffle(provider_lst)\n\n        for sp in provider_lst:\n            if self.resultcount >= self.max_providers:\n                break\n            try:\n                if sp not in ['bitcoind', 'litecoind', 'dashd', 'dogecoind', 'caching'] and not self.providers[sp]['url'] and \\\n                        self.network.name != 'bitcoinlib_test':\n                    continue\n                client = getattr(services, self.providers[sp]['provider'])\n                providerclient = getattr(client, self.providers[sp]['client_class'])\n                pc_instance = providerclient(\n                    self.network, self.providers[sp]['url'], self.providers[sp]['denominator'],\n                    self.providers[sp]['api_key'], self.providers[sp]['provider_coin_id'],\n                    self.providers[sp]['network_overrides'], self.timeout, self._blockcount, self.strict)\n                if not hasattr(pc_instance, method):\n                    _logger.debug(\"Method %s not found for provider %s\" % (method, sp))\n                    continue\n                if self.providers[sp]['api_key'] == 'api-key-needed':\n                    _logger.debug(\"API key needed for provider %s\" % sp)\n                    continue\n                providermethod = getattr(pc_instance, method)\n                res = providermethod(*arguments)\n                if res is False:  # pragma: no cover\n                    self.errors.update(\n                        {sp: 'Received empty response'}\n                    )\n                    _logger.info(\"Empty response from %s when calling %s\" % (sp, method))\n                    continue\n                self.results.update(\n                    {sp: res}\n                )\n                _logger.debug(\"Executed method %s from provider %s\" % (method, sp))\n                self.resultcount += 1\n            except Exception as e:\n                if not isinstance(e, AttributeError):\n                    try:\n                        err = e.msg\n                    except AttributeError:\n                        err = e\n                    self.errors.update(\n                        {sp: err}\n                    )\n                    _logger.debug(\"Error %s on provider %s\" % (e, sp))\n                    # -- Use this to debug specific Services errors --\n                    # from pprint import pprint\n                    # pprint(self.errors)\n\n                if len(self.errors) >= self.max_errors:\n                    _logger.warning(\"Aborting, max errors exceeded: %s\" %\n                                    list(self.errors.keys()))\n                    if len(self.results):\n                        return list(self.results.values())[0]\n                    else:\n                        return False\n\n            if self.resultcount >= self.max_providers:\n                break\n\n        if not self.resultcount:\n            raise ServiceError(\"No successful response from any serviceprovider: %s\" % list(self.providers.keys()))\n        return list(self.results.values())[0]\n\n    def getbalance(self, addresslist, addresses_per_request=5):\n        \"\"\"\n        Get total balance for address or list of addresses\n\n        :param addresslist: Address or list of addresses\n        :type addresslist: list, str\n        :param addresses_per_request: Maximum number of addresses per request. Default is 5. Use lower setting when you experience timeouts or service request errors, or higher when possible.\n        :type addresses_per_request: int\n\n        :return dict: Balance per address\n        \"\"\"\n        if isinstance(addresslist, TYPE_TEXT):\n            addresslist = [addresslist]\n\n        tot_balance = 0\n        while addresslist:\n            for address in addresslist:\n                db_addr = self.cache.getaddress(address)\n                if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount() and db_addr.balance:\n                    tot_balance += db_addr.balance\n                    addresslist.remove(address)\n\n            balance = self._provider_execute('getbalance', addresslist[:addresses_per_request])\n            if balance:\n                tot_balance += balance\n            if len(addresslist) == 1:\n                self.cache.store_address(addresslist[0], balance=balance)\n            addresslist = addresslist[addresses_per_request:]\n        return tot_balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get list of unspent outputs (UTXO's) for specified address.\n\n        Sorted from old to new, so the highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.\n        :type after_txid: str\n        :param limit: Maximum number of utxo's to return. Sometimes ignored by service providers if more results are returned by default.\n        :type limit: int\n\n        :return dict: UTXO's per address\n        \"\"\"\n        if not isinstance(address, TYPE_TEXT):\n            raise ServiceError(\"Address parameter must be of type text\")\n        self.results_cache_n = 0\n        self.complete = True\n\n        utxos_cache = []\n        if self.min_providers <= 1:\n            utxos_cache = self.cache.getutxos(address, bytes.fromhex(after_txid)) or []\n        if utxos_cache:\n            self.results_cache_n = len(utxos_cache)\n\n            # Last updated block does not always include spent info...\n            # if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount():\n            #     return utxos_cache\n            after_txid = utxos_cache[-1:][0]['txid']\n\n        utxos = self._provider_execute('getutxos', address, after_txid, limit)\n        if utxos is False:\n            raise ServiceError(\"Error when retrieving UTXO's\")\n        else:\n            # Update cache_transactions_node\n            for utxo in utxos:\n                self.cache.store_utxo(utxo['txid'], utxo['output_n'], commit=False)\n            self.cache.commit()\n            if utxos and len(utxos) >= limit:\n                self.complete = False\n            elif not after_txid:\n                balance = sum(u['value'] for u in utxos)\n                self.cache.store_address(address, balance=balance, n_utxos=len(utxos))\n\n        return utxos_cache + utxos\n\n    def gettransaction(self, txid):\n        \"\"\"\n        Get a transaction by its transaction hash. Convert to Bitcoinlib Transaction object.\n\n        :param txid: Transaction identification hash\n        :type txid: str\n\n        :return Transaction: A single transaction object\n        \"\"\"\n        tx = None\n        self.results_cache_n = 0\n\n        if self.min_providers <= 1:\n            tx = self.cache.gettransaction(bytes.fromhex(txid))\n            if tx:\n                self.results_cache_n = 1\n        if not tx:\n            tx = self._provider_execute('gettransaction', txid)\n            if tx and tx.txid != txid:\n                _logger.warning(\"Incorrect txid after parsing\")\n                tx.txid = txid\n            if len(self.results) and self.min_providers <= 1:\n                self.cache.store_transaction(tx)\n        return tx\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get all transactions for specified address.\n\n        Sorted from old to new, so transactions with highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for transactions after given tx id. Default: Leave empty to return all transaction. If used only provide a single address\n        :type after_txid: str\n        :param limit: Maximum number of transactions to return\n        :type limit: int\n\n        :return list: List of Transaction objects\n        \"\"\"\n        self._reset_results()\n        self.results_cache_n = 0\n        if not address:\n            return []\n        if not isinstance(address, TYPE_TEXT):\n            raise ServiceError(\"Address parameter must be of type text\")\n        if after_txid is None:\n            after_txid = ''\n        db_addr = self.cache.getaddress(address)\n        txs_cache = []\n        qry_after_txid = bytes.fromhex(after_txid)\n\n        # Retrieve transactions from cache\n        caching_enabled = True\n        if self.min_providers > 1:  # Disable cache if comparing providers\n            caching_enabled = False\n\n        if caching_enabled:\n            txs_cache = self.cache.gettransactions(address, qry_after_txid, limit) or []\n            if txs_cache:\n                self.results_cache_n = len(txs_cache)\n                if len(txs_cache) == limit:\n                    return txs_cache\n                limit = limit - len(txs_cache)\n                qry_after_txid = bytes.fromhex(txs_cache[-1:][0].txid)\n\n        # Get (extra) transactions from service providers\n        txs = []\n        if not(db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount()) or not caching_enabled:\n            txs = self._provider_execute('gettransactions', address, qry_after_txid.hex(),  limit)\n            if txs is False:\n                raise ServiceError(\"Error when retrieving transactions from service provider\")\n\n        # Store transactions and address in cache\n        # - disable cache if comparing providers or if after_txid is used and no cache is available\n        last_block = None\n        last_txid = None\n        if self.min_providers <= 1 and not(after_txid and not db_addr) and caching_enabled:\n            last_block = self.blockcount()\n            last_txid = qry_after_txid\n            self.complete = True\n            if len(txs) == limit:\n                self.complete = False\n                last_block = txs[-1:][0].block_height\n            if len(txs):\n                last_txid = bytes.fromhex(txs[-1:][0].txid)\n            if len(self.results):\n                order_n = 0\n                for t in txs:\n                    if t.confirmations != 0:\n                        res = self.cache.store_transaction(t, order_n, commit=False)\n                        order_n += 1\n                        # Failure to store transaction: stop caching transaction and store last tx block height - 1\n                        if res is False:\n                            if t.block_height:\n                                last_block = t.block_height - 1\n                            break\n                self.cache.commit()\n                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=self.complete)\n\n        all_txs = txs_cache + txs\n        # If we have txs for this address update spent and balance information in cache\n        if self.complete:\n            all_txs = transaction_update_spents(all_txs, address)\n            if caching_enabled:\n                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=True)\n                for t in all_txs:\n                    self.cache.store_transaction(t, commit=False)\n                self.cache.commit()\n        return all_txs\n\n    def getrawtransaction(self, txid):\n        \"\"\"\n        Get a raw transaction by its transaction hash\n\n        :param txid: Transaction identification hash\n        :type txid: str\n\n        :return str: Raw transaction as hexstring\n        \"\"\"\n        self.results_cache_n = 0\n        rawtx = self.cache.getrawtransaction(bytes.fromhex(txid))\n        if rawtx:\n            self.results_cache_n = 1\n            return rawtx\n        return self._provider_execute('getrawtransaction', txid)\n\n    def sendrawtransaction(self, rawtx):\n        \"\"\"\n        Push a raw transaction to the network\n\n        :param rawtx: Raw transaction as hexstring or bytes\n        :type rawtx: str\n\n        :return dict: Send transaction result\n        \"\"\"\n        return self._provider_execute('sendrawtransaction', rawtx)\n\n    def estimatefee(self, blocks=3, priority=''):\n        \"\"\"\n        Estimate fee per kilobyte for a transaction for this network with expected confirmation within a certain\n        amount of blocks\n\n        :param blocks: Expected confirmation time in blocks. Default is 3.\n        :type blocks: int\n        :param priority: Priority for transaction: can be 'low', 'medium' or 'high'. Overwrites value supplied in 'blocks' argument\n        :type priority: str\n\n        :return int: Fee in the smallest network denominator (satoshi)\n        \"\"\"\n        self.results_cache_n = 0\n        if priority:\n            if priority == 'low':\n                blocks = 10\n            elif priority == 'high':\n                blocks = 1\n        if self.min_providers <= 1:  # Disable cache if comparing providers\n            fee = self.cache.estimatefee(blocks)\n            if fee:\n                self.results_cache_n = 1\n                return fee\n        fee = self._provider_execute('estimatefee', blocks)\n        if not fee:  # pragma: no cover\n            if self.network.fee_default:\n                fee = self.network.fee_default\n            else:\n                raise ServiceError(\"Could not estimate fees, please define default fees in network settings\")\n        if fee < self.network.fee_min:\n            fee = self.network.fee_min\n        elif fee > self.network.fee_max:\n            fee = self.network.fee_max\n        self.cache.store_estimated_fee(blocks, fee)\n        return fee\n\n    def blockcount(self):\n        \"\"\"\n        Get the latest block number: The block number of last block in longest chain on the Blockchain.\n\n        Block count is cashed for BLOCK_COUNT_CACHE_TIME seconds to avoid to many calls to service providers.\n\n        :return int:\n        \"\"\"\n\n        blockcount = self.cache.blockcount()\n        last_cache_blockcount = self.cache.blockcount(never_expires=True)\n        if blockcount:\n            self._blockcount = blockcount\n            return blockcount\n\n        current_timestamp = time.time()\n        if self._blockcount_update < current_timestamp - BLOCK_COUNT_CACHE_TIME:\n            new_count = self._provider_execute('blockcount')\n            if not self._blockcount or (new_count and new_count > self._blockcount):\n                self._blockcount = new_count\n                self._blockcount_update = current_timestamp\n            if last_cache_blockcount > self._blockcount:\n                return last_cache_blockcount\n            # Store result in cache\n            if len(self.results) and list(self.results.keys())[0] != 'caching':\n                self.cache.store_blockcount(self._blockcount)\n        return self._blockcount\n\n    def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        \"\"\"\n        Get block with specified block height or block hash from service providers.\n\n        If parse_transaction is set to True a list of Transaction object will be returned otherwise a\n        list of transaction ID's.\n\n        Some providers require 1 or 2 extra request per transaction, so to avoid timeouts or rate limiting errors\n        you can specify a page and limit for the transaction. For instance with page=2, limit=4 only transaction\n        5 to 8 are returned to the Blocks's 'transaction' attribute.\n\n        If you only use a local bcoin or bitcoind provider, make sure you set the limit to maximum (i.e. 9999)\n        because all transactions are already downloaded when fetching the block.\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b\n        <Block(000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f, 0, transactions: 1)>\n\n        :param blockid: Hash or block height of block\n        :type blockid: str, int\n        :param parse_transactions: Return Transaction objects or just transaction ID's. Default is return txids.\n        :type parse_transactions: bool\n        :param page: Page number of transaction paging. Default is start from the beginning: 1\n        :type page: int\n        :param limit: Maximum amount of transaction to return. Default is 25 if parse transaction is enabled, otherwise returns all txid's (9999)\n        :type limit: int\n\n        :return Block:\n        \"\"\"\n        if limit is None:\n            limit = 25 if parse_transactions else 99999\n\n        block = self.cache.getblock(blockid)\n        is_last_page = False\n        if block:\n            # Block found get transactions from cache\n            txs = self.cache.getblocktransactions(block.height, page, limit)\n            if parse_transactions:\n                block.transactions = txs\n            else:\n                block.transactions = [tx.txid for tx in txs]\n            if block.transactions:\n                self.results_cache_n = 1\n            is_last_page = page*limit > block.tx_count\n        if not block or (not len(block.transactions) and limit != 0) or (not is_last_page and len(block.transactions) < limit) or \\\n                (is_last_page and ((page-1)*limit - block.tx_count + len(block.transactions)) < 0):\n            self.results_cache_n = 0\n            bd = self._provider_execute('getblock', blockid, parse_transactions, page, limit)\n            if not bd or isinstance(bd, bool):\n                return False\n            block = Block(bd['block_hash'], bd['version'], bd['prev_block'], bd['merkle_root'], bd['time'], bd['bits'],\n                          bd['nonce'], bd['txs'], bd['height'], bd['depth'], self.network)\n            block.tx_count = bd['tx_count']\n            block.limit = limit\n            block.page = page\n\n            if parse_transactions and self.min_providers <= 1:\n                order_n = (page-1)*limit\n                for tx in block.transactions:\n                    if isinstance(tx, Transaction):\n                        self.cache.store_transaction(tx, order_n, commit=False)\n                    order_n += 1\n                self.cache.commit()\n            self.complete = True if len(block.transactions) == block.tx_count else False\n            self.cache.store_block(block)\n        return block\n\n    def getrawblock(self, blockid):\n        \"\"\"\n        Get raw block as hexadecimal string for block with specified hash or block height.\n\n        Not many providers offer this option, and it can be slow, so it is advised to use a local client such\n        as bitcoind.\n\n        :param blockid: Block hash or block height\n        :type blockid: str, int\n\n        :return str:\n        \"\"\"\n        return self._provider_execute('getrawblock', blockid)\n\n    def mempool(self, txid=''):\n        \"\"\"\n        Get list of all transaction IDs in the current mempool\n\n        A full list of transactions ID's will only be returned if a bcoin or bitcoind client is available. Otherwise\n        specify the txid option to verify if a transaction is added to the mempool.\n\n        :param txid: Check if transaction with this hash exists in memory pool\n        :type txid: str\n\n        :return list:\n        \"\"\"\n        return self._provider_execute('mempool', txid)\n\n    def getcacheaddressinfo(self, address):\n        \"\"\"\n        Get address information from cache. I.e. balance, number of transactions, number of utox's, etc\n\n        Cache will only be filled after all transactions for a specific address are retrieved (with gettransactions ie)\n\n        :param address: address string\n        :type address: str\n\n        :return dict:\n        \"\"\"\n        addr_dict = {'address': address}\n        addr_rec = self.cache.getaddress(address)\n        if isinstance(addr_rec, DbCacheAddress):\n            addr_dict['balance'] = addr_rec.balance\n            addr_dict['last_block'] = addr_rec.last_block\n            addr_dict['n_txs'] = addr_rec.n_txs\n            addr_dict['n_utxos'] = addr_rec.n_utxos\n        return addr_dict\n\n    def isspent(self, txid, output_n):\n        \"\"\"\n        Check if the output with provided transaction ID and output number is spent.\n\n        :param txid: Transaction ID hex\n        :type txid: str\n        :param output_n: Output number\n        :type output_n: int\n\n        :return bool:\n        \"\"\"\n        t = self.cache.gettransaction(bytes.fromhex(txid))\n        if t and len(t.outputs) > output_n and t.outputs[output_n].spent is not None:\n            return t.outputs[output_n].spent\n        else:\n            return bool(self._provider_execute('isspent', txid, output_n))\n\n    def getinfo(self):\n        \"\"\"\n        Returns info about current network. Such as difficulty, latest block, mempool size and network hashrate.\n\n        :return dict:\n        \"\"\"\n        return self._provider_execute('getinfo')\n\n    def getinputvalues(self, t):\n        \"\"\"\n        Retrieve values for transaction inputs for given Transaction.\n\n        Raw transactions as stored on the blockchain do not contain the input values but only the previous\n        transaction hash and index number. This method retrieves the previous transaction and reads the value.\n\n        :param t: Transaction\n        :type t: Transaction\n\n        :return Transaction:\n        \"\"\"\n        prev_txs = []\n        for i in t.inputs:\n            if not i.value:\n                if i.prev_txid not in prev_txs:\n                    prev_t = self.gettransaction(i.prev_txid.hex())\n                else:\n                    prev_t = [t for t in prev_txs if t.txid == i.prev_txid][0]\n                i.value = prev_t.outputs[i.output_n_int].value\n        return t",
  "class Cache(object):\n    \"\"\"\n    Store transaction, utxo and address information in database to increase speed and avoid duplicate calls to\n    service providers.\n\n    Once confirmed a transaction is immutable so we have to fetch it from a service provider only once. When checking\n    for new transactions or utxo's for a certain address we only have to check the new blocks.\n\n    This class is used by the Service class and normally you won't need to access it directly.\n\n    \"\"\"\n\n    def __init__(self, network, db_uri=''):\n        \"\"\"\n        Open Cache class\n\n        :param network: Specify network used\n        :type network: str, Network\n        :param db_uri: Database to use for caching\n        :type db_uri: str\n        \"\"\"\n        self.session = None\n        if SERVICE_CACHING_ENABLED:\n            self.session = DbCache(db_uri=db_uri).session\n        self.network = network\n\n    def __exit__(self):\n        try:\n            self.session.close()\n        except Exception:\n            pass\n\n    def cache_enabled(self):\n        \"\"\"\n        Check if caching is enabled. Returns False if SERVICE_CACHING_ENABLED is False or no session is defined.\n\n        :return bool:\n        \"\"\"\n        if not SERVICE_CACHING_ENABLED or not self.session:\n            return False\n        return True\n\n    def commit(self):\n        \"\"\"\n        Commit queries in self.session. Rollback if commit fails.\n\n        :return:\n        \"\"\"\n        if not self.session:\n            return\n        try:\n            self.session.commit()\n        except Exception:\n            self.session.rollback()\n            raise\n\n    @staticmethod\n    def _parse_db_transaction(db_tx):\n        t = Transaction(locktime=db_tx.locktime, version=db_tx.version, network=db_tx.network_name,\n                        fee=db_tx.fee, txid=db_tx.txid.hex(), date=db_tx.date, confirmations=db_tx.confirmations,\n                        block_height=db_tx.block_height, status='confirmed', witness_type=db_tx.witness_type.value)\n        for n in db_tx.nodes:\n            if n.is_input:\n                if n.ref_txid == b'\\00' * 32:\n                    t.coinbase = True\n                t.add_input(n.ref_txid.hex(), n.ref_index_n, unlocking_script=n.script, address=n.address,\n                            sequence=n.sequence, value=n.value, index_n=n.index_n, witnesses=n.witnesses, strict=False)\n            else:\n                t.add_output(n.value, n.address, lock_script=n.script, spent=n.spent, output_n=n.index_n,\n                             spending_txid=None if not n.ref_txid else n.ref_txid.hex(),\n                             spending_index_n=n.ref_index_n, strict=False)\n\n        t.update_totals()\n        t.size = len(t.raw())\n        t.calc_weight_units()\n        _logger.info(\"Retrieved transaction %s from cache\" % t.txid)\n        return t\n\n    def gettransaction(self, txid):\n        \"\"\"\n        Get transaction from cache. Returns False if not available\n\n        :param txid: Transaction identification hash\n        :type txid: bytes\n\n        :return Transaction: A single Transaction object\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()\n        if not db_tx:\n            return False\n        db_tx.txid = txid\n        t = self._parse_db_transaction(db_tx)\n        if t.block_height:\n            t.confirmations = (self.blockcount() - t.block_height) + 1\n        return t\n\n    def getaddress(self, address):\n        \"\"\"\n        Get address information from cache, with links to transactions and utxo's and latest update information.\n\n        :param address: Address string\n        :type address: str\n\n        :return DbCacheAddress: An address cache database object\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        return self.session.query(DbCacheAddress).filter_by(address=address, network_name=self.network.name).scalar()\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get transactions from cache. Returns empty list if no transactions are found or caching is disabled.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for transactions after given tx id. Default: Leave empty to return all transaction. If used only provide a single address\n        :type after_txid: bytes\n        :param limit: Maximum number of transactions to return\n        :type limit: int\n\n        :return list: List of Transaction objects\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_addr = self.getaddress(address)\n        txs = []\n        if db_addr:\n            if after_txid:\n                after_tx = self.session.query(DbCacheTransaction).\\\n                    filter_by(txid=after_txid, network_name=self.network.name).scalar()\n                if after_tx and db_addr.last_block and after_tx.block_height:\n                    db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).\\\n                        filter(DbCacheTransactionNode.address == address,\n                               DbCacheTransaction.block_height >= after_tx.block_height,\n                               DbCacheTransaction.block_height <= db_addr.last_block).\\\n                        order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()\n                    db_txs2 = []\n                    for d in db_txs:\n                        db_txs2.append(d)\n                        if d.txid == after_txid:\n                            db_txs2 = []\n                    db_txs = db_txs2\n                else:\n                    return []\n            else:\n                db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode). \\\n                    filter(DbCacheTransactionNode.address == address). \\\n                    order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()\n            for db_tx in db_txs:\n                t = self._parse_db_transaction(db_tx)\n                if t:\n                    if t.block_height:\n                        t.confirmations = (self.blockcount() - t.block_height) + 1\n                    txs.append(t)\n                    if len(txs) >= limit:\n                        break\n            return txs\n        return []\n\n    def getblocktransactions(self, height, page, limit):\n        \"\"\"\n        Get range of transactions from a block\n\n        :param height: Block height\n        :type height: int\n        :param page: Transaction page\n        :type page: int\n        :param limit: Number of transactions per page\n        :type limit: int\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        n_from = (page-1) * limit\n        n_to = page * limit\n        db_txs = self.session.query(DbCacheTransaction).\\\n            filter(DbCacheTransaction.block_height == height, DbCacheTransaction.order_n >= n_from,\n                   DbCacheTransaction.order_n < n_to).all()\n        txs = []\n        for db_tx in db_txs:\n            t = self._parse_db_transaction(db_tx)\n            if t:\n                txs.append(t)\n        return txs\n\n    def getrawtransaction(self, txid):\n        \"\"\"\n        Get a raw transaction string from the database cache if available\n\n        :param txid: Transaction identification hash\n        :type txid: bytes\n\n        :return str: Raw transaction as hexstring\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()\n        if not tx:\n            return False\n        t = self._parse_db_transaction(tx)\n        return t.raw_hex()\n\n    def getutxos(self, address, after_txid=''):\n        \"\"\"\n        Get list of unspent outputs (UTXO's) for specified address from database cache.\n\n        Sorted from old to new, so highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.\n        :type after_txid: bytes\n\n        :return dict: UTXO's per address\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_utxos = self.session.query(DbCacheTransactionNode.spent, DbCacheTransactionNode.index_n,\n                                      DbCacheTransactionNode.value, DbCacheTransaction.confirmations,\n                                      DbCacheTransaction.block_height, DbCacheTransaction.fee,\n                                      DbCacheTransaction.date, DbCacheTransaction.txid).join(DbCacheTransaction). \\\n            order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n). \\\n            filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.is_input == False,\n                   DbCacheTransaction.network_name == self.network.name).all()\n        utxos = []\n        for db_utxo in db_utxos:\n            if db_utxo.spent is False:\n                utxos.append({\n                    'address': address,\n                    'txid': db_utxo.txid.hex(),\n                    'confirmations': db_utxo.confirmations,\n                    'output_n': db_utxo.index_n,\n                    'input_n': 0,\n                    'block_height': db_utxo.block_height,\n                    'fee': db_utxo.fee,\n                    'size': 0,\n                    'value': db_utxo.value,\n                    'script': '',\n                    'date': db_utxo.date\n                })\n            elif db_utxo.spent is None:\n                return utxos\n            if db_utxo.txid == after_txid:\n                utxos = []\n        return utxos\n\n    def estimatefee(self, blocks):\n        \"\"\"\n        Get fee estimation from cache for confirmation within specified amount of blocks.\n\n        Stored in cache in three groups: low, medium and high fees.\n\n        :param blocks: Expected confirmation time in blocks.\n        :type blocks: int\n\n        :return int: Fee in the smallest network denominator (satoshi)\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        if blocks <= 1:\n            varname = 'fee_high'\n        elif blocks <= 5:\n            varname = 'fee_medium'\n        else:\n            varname = 'fee_low'\n        dbvar = self.session.query(DbCacheVars).filter_by(varname=varname, network_name=self.network.name).\\\n            filter(DbCacheVars.expires > datetime.now()).scalar()\n        if dbvar:\n            return int(dbvar.value)\n        return False\n\n    def blockcount(self, never_expires=False):\n        \"\"\"\n        Get number of blocks on the current network from cache if recent data is available.\n\n        :param never_expires: Always return latest blockcount found. Can be used to avoid return to old blocks if service providers are not up-to-date.\n        :type never_expires: bool\n\n        :return int:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        qr = self.session.query(DbCacheVars).filter_by(varname='blockcount', network_name=self.network.name)\n        if not never_expires:\n            qr = qr.filter(DbCacheVars.expires > datetime.now())\n        dbvar = qr.scalar()\n        if dbvar:\n            return int(dbvar.value)\n        return False\n\n    def getblock(self, blockid):\n        \"\"\"\n        Get specific block from database cache.\n\n        :param blockid: Block height or block hash\n        :type blockid: int, str\n\n        :return Block:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        qr = self.session.query(DbCacheBlock)\n        if isinstance(blockid, int):\n            block = qr.filter_by(height=blockid, network_name=self.network.name).scalar()\n        else:\n            block = qr.filter_by(block_hash=to_bytes(blockid)).scalar()\n        if not block:\n            return False\n        b = Block(block_hash=block.block_hash, height=block.height, network=block.network_name,\n                  merkle_root=block.merkle_root, time=block.time, nonce=block.nonce,\n                  version=block.version, prev_block=block.prev_block, bits=block.bits)\n        b.tx_count = block.tx_count\n        _logger.info(\"Retrieved block with height %d from cache\" % b.height)\n        return b\n\n    def store_blockcount(self, blockcount):\n        \"\"\"\n        Store network blockcount in cache for 60 seconds\n\n        :param blockcount: Number of latest block\n        :type blockcount: int, str\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        dbvar = DbCacheVars(varname='blockcount', network_name=self.network.name, value=str(blockcount), type='int',\n                            expires=datetime.now() + timedelta(seconds=60))\n        self.session.merge(dbvar)\n        self.commit()\n\n    def store_transaction(self, t, order_n=None, commit=True):\n        \"\"\"\n        Store transaction in cache. Use order number to determine order in a block\n\n        :param t: Transaction\n        :type t: Transaction\n        :param order_n: Order in block\n        :type order_n: int\n        :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.\n        :type commit: bool\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        # Only store complete and confirmed transaction in cache\n        if not t.txid:    # pragma: no cover\n            _logger.info(\"Caching failure tx: Missing transaction hash\")\n            return False\n        elif not t.date or not t.block_height or not t.network:\n            _logger.info(\"Caching failure tx: Incomplete transaction missing date, block height or network info\")\n            return False\n        elif not t.coinbase and [i for i in t.inputs if not i.value]:\n            _logger.info(\"Caching failure tx: One the transaction inputs has value 0\")\n            return False\n        # TODO: Check if inputs / outputs are complete? script, value, prev_txid, sequence, output/input_n\n\n        txid = bytes.fromhex(t.txid)\n        if self.session.query(DbCacheTransaction).filter_by(txid=txid).count():\n            return\n        new_tx = DbCacheTransaction(txid=txid, date=t.date, confirmations=t.confirmations,\n                                    block_height=t.block_height, network_name=t.network.name,\n                                    fee=t.fee, order_n=order_n, version=t.version_int,\n                                    locktime=t.locktime, witness_type=t.witness_type)\n        self.session.add(new_tx)\n        for i in t.inputs:\n            if i.value is None or i.address is None or i.output_n is None:    # pragma: no cover\n                _logger.info(\"Caching failure tx: Input value, address or output_n missing\")\n                return False\n            witnesses = int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n            new_node = DbCacheTransactionNode(txid=txid, address=i.address, index_n=i.index_n, value=i.value,\n                                              is_input=True, ref_txid=i.prev_txid, ref_index_n=i.output_n_int,\n                                              script=i.unlocking_script, sequence=i.sequence, witnesses=witnesses)\n            self.session.add(new_node)\n        for o in t.outputs:\n            if o.value is None or o.address is None or o.output_n is None:    # pragma: no cover\n                _logger.info(\"Caching failure tx: Output value, address or output_n missing\")\n                return False\n            new_node = DbCacheTransactionNode(\n                txid=txid, address=o.address, index_n=o.output_n, value=o.value, is_input=False, spent=o.spent,\n                ref_txid=None if not o.spending_txid else bytes.fromhex(o.spending_txid),\n                ref_index_n=o.spending_index_n, script=o.lock_script)\n            self.session.add(new_node)\n\n        if commit:\n            try:\n                self.commit()\n                _logger.info(\"Added transaction %s to cache\" % t.txid)\n            except Exception as e:    # pragma: no cover\n                _logger.warning(\"Caching failure tx: %s\" % e)\n\n    def store_utxo(self, txid, index_n, commit=True):\n        \"\"\"\n        Store utxo in cache. Updates only known transaction outputs for transactions which are fully cached\n\n        :param txid: Transaction ID\n        :type txid: str\n        :param index_n: Index number of output\n        :type index_n: int\n        :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.\n        :type commit: bool\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        txid = bytes.fromhex(txid)\n        result = self.session.query(DbCacheTransactionNode). \\\n            filter(DbCacheTransactionNode.txid == txid, DbCacheTransactionNode.index_n == index_n,\n                   DbCacheTransactionNode.is_input == False).\\\n            update({DbCacheTransactionNode.spent: False})\n        if commit:\n            try:\n                self.commit()\n            except Exception as e:    # pragma: no cover\n                _logger.warning(\"Caching failure utxo %s:%d: %s\" % (txid.hex(), index_n, e))\n\n    def store_address(self, address, last_block=None, balance=0, n_utxos=None, txs_complete=False, last_txid=None):\n        \"\"\"\n        Store address information in cache\n\n        :param address: Address string\n        :type address: str\n        :param last_block: Number or last block retrieved from service provider. For instance if address contains a large number of transactions and they will be retrieved in more then one request.\n        :type last_block: int\n        :param balance: Total balance of address in sathosis, or smallest network detominator\n        :type balance: int\n        :param n_utxos: Total number of UTXO's for this address\n        :type n_utxos: int\n        :param txs_complete: True if all transactions for this address are added to cache\n        :type txs_complete: bool\n        :param last_txid: Transaction ID of last transaction downloaded from blockchain\n        :type last_txid: bytes\n\n .       :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        n_txs = None\n        if txs_complete:\n            n_txs = len(self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).\n                        filter(DbCacheTransactionNode.address == address).all())\n            if n_utxos is None:\n                n_utxos = self.session.query(DbCacheTransactionNode).\\\n                    filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(False),\n                           DbCacheTransactionNode.is_input.is_(False)).count()\n                if self.session.query(DbCacheTransactionNode).\\\n                        filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(None),\n                               DbCacheTransactionNode.is_input.is_(False)).count():\n                    n_utxos = None\n            if not balance:\n                plusmin = self.session.query(DbCacheTransactionNode.is_input, func.sum(DbCacheTransactionNode.value)). \\\n                    filter(DbCacheTransactionNode.address == address). \\\n                    group_by(DbCacheTransactionNode.is_input).all()\n                balance = 0 if not plusmin else sum([(-p[1] if p[0] else p[1]) for p in plusmin])\n        db_addr = self.getaddress(address)\n        new_address = DbCacheAddress(\n            address=address, network_name=self.network.name,\n            last_block=last_block if last_block else getattr(db_addr, 'last_block', None),\n            balance=balance if balance is not None else getattr(db_addr, 'balance', None),\n            n_utxos=n_utxos if n_utxos is not None else getattr(db_addr, 'n_utxos', None),\n            n_txs=n_txs if n_txs is not None else getattr(db_addr, 'n_txs', None),\n            last_txid=last_txid if last_txid is not None else getattr(db_addr, 'last_txid', None))\n        self.session.merge(new_address)\n        try:\n            self.commit()\n        except Exception as e:    # pragma: no cover\n            _logger.warning(\"Caching failure addr: %s\" % e)\n\n    def store_estimated_fee(self, blocks, fee):\n        \"\"\"\n        Store estimated fee retrieved from service providers in cache.\n\n        :param blocks: Confirmation within x blocks\n        :type blocks: int\n        :param fee: Estimated fee in Sathosis\n        :type fee: int\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        if blocks <= 1:\n            varname = 'fee_high'\n        elif blocks <= 5:\n            varname = 'fee_medium'\n        else:\n            varname = 'fee_low'\n        dbvar = DbCacheVars(varname=varname, network_name=self.network.name, value=str(fee), type='int',\n                            expires=datetime.now() + timedelta(seconds=600))\n        self.session.merge(dbvar)\n        self.commit()\n\n    def store_block(self, block):\n        \"\"\"\n        Store block in cache database\n\n        :param block: Block\n        :type block: Block\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        if not (block.height and block.block_hash and block.prev_block and block.merkle_root and\n                block.bits and block.version) \\\n                and not block.block_hash == b'\\x00\\x00\\x00\\x00\\x00\\x19\\xd6h\\x9c\\x08Z\\xe1e\\x83\\x1e\\x93O\\xf7c\\xaeF' \\\n                                            b'\\xa2\\xa6\\xc1r\\xb3\\xf1\\xb6\\n\\x8c\\xe2o':  # Bitcoin genesis block\n            _logger.info(\"Caching failure block: incomplete data\")\n            return\n\n        new_block = DbCacheBlock(\n            block_hash=block.block_hash, height=block.height, network_name=self.network.name,\n            version=block.version_int, prev_block=block.prev_block, bits=block.bits_int,\n            merkle_root=block.merkle_root, nonce=block.nonce_int, time=block.time, tx_count=block.tx_count)\n        self.session.merge(new_block)\n        try:\n            self.commit()\n        except Exception as e:    # pragma: no cover\n            _logger.warning(\"Caching failure block: %s\" % e)",
  "def __init__(self, msg=''):\n        self.msg = msg\n        _logger.error(msg)",
  "def __str__(self):\n        return self.msg",
  "def __init__(self, network=DEFAULT_NETWORK, min_providers=1, max_providers=1, providers=None,\n                 timeout=TIMEOUT_REQUESTS, cache_uri=None, ignore_priority=False, exclude_providers=None,\n                 max_errors=SERVICE_MAX_ERRORS, strict=True):\n        \"\"\"\n        Create a service object for the specified network. By default, the object connect to 1 service provider, but you\n        can specify a list of providers or a minimum or maximum number of providers.\n\n        :param network: Specify network used\n        :type network: str, Network\n        :param min_providers: Minimum number of providers to connect to. Default is 1. Use for instance to receive fee information from a number of providers and calculate the average fee.\n        :type min_providers: int\n        :param max_providers: Maximum number of providers to connect to. Default is 1.\n        :type max_providers: int\n        :param providers: List of providers to connect to. Default is all providers and select a provider at random.\n        :type providers: list of str\n        :param timeout: Timeout for web requests. Leave empty to use default from config settings\n        :type timeout: int\n        :param cache_uri: Database to use for caching\n        :type cache_uri: str\n        :param ignore_priority: Ignores provider priority if set to True. Could be used for unit testing, so no providers are missed when testing. Default is False\n        :type ignore_priority: bool\n        :param exclude_providers: Exclude providers in this list, can be used when problems with certain providers arise.\n        :type exclude_providers: list of str\n        :param strict: Strict checks of valid signatures, scripts and transactions. Normally use strict=True for wallets, transaction validations etcetera. For blockchain parsing strict=False should be used, but be sure to check warnings in the log file. Default is True.\n        :type strict: bool\n\n        \"\"\"\n\n        self.network = network\n        if not isinstance(network, Network):\n            self.network = Network(network)\n        if min_providers > max_providers:\n            max_providers = min_providers\n        fn = Path(BCL_DATA_DIR, 'providers.json')\n        f = fn.open(\"r\")\n\n        try:\n            self.providers_defined = json.loads(f.read())\n        except json.decoder.JSONDecodeError as e:  # pragma: no cover\n            errstr = \"Error reading provider definitions from %s: %s\" % (fn, e)\n            _logger.warning(errstr)\n            raise ServiceError(errstr)\n        f.close()\n\n        provider_list = list([self.providers_defined[x]['provider'] for x in self.providers_defined])\n        if providers is None:\n            providers = []\n        if exclude_providers is None:\n            exclude_providers = []\n        if not isinstance(providers, list):\n            providers = [providers]\n        for p in providers:\n            if p not in provider_list:\n                raise ServiceError(\"Provider '%s' not found in provider definitions\" % p)\n\n        self.providers = {}\n        for p in self.providers_defined:\n            if (self.providers_defined[p]['network'] == network or self.providers_defined[p]['network'] == '') and \\\n                    (not providers or self.providers_defined[p]['provider'] in providers):\n                self.providers.update({p: self.providers_defined[p]})\n        for nop in exclude_providers:\n            if nop in self.providers:\n                del(self.providers[nop])\n\n        if not self.providers:\n            raise ServiceError(\"No providers found for network %s\" % network)\n        self.min_providers = min_providers\n        self.max_providers = max_providers\n        self.results = {}\n        self.errors = {}\n        self.resultcount = 0\n        self.max_errors = max_errors\n        self.complete = None\n        self.timeout = timeout\n        self._blockcount_update = 0\n        self._blockcount = None\n        self.cache = None\n        self.cache_uri = cache_uri\n        try:\n            self.cache = Cache(self.network, db_uri=cache_uri)\n        except Exception as e:\n            self.cache = Cache(self.network, db_uri='')\n            _logger.warning(\"Could not connect to cache database. Error: %s\" % e)\n        self.results_cache_n = 0\n        self.ignore_priority = ignore_priority\n        self.strict = strict\n        if self.min_providers > 1:\n            self._blockcount = Service(network=network, cache_uri=cache_uri).blockcount()\n        else:\n            self._blockcount = self.blockcount()",
  "def __exit__(self):\n        try:\n            self.cache.session.close()\n        except Exception:\n            pass",
  "def _reset_results(self):\n        self.results = {}\n        self.errors = {}\n        self.complete = None\n        self.resultcount = 0",
  "def _provider_execute(self, method, *arguments):\n        self._reset_results()\n        provider_lst = [p[0] for p in sorted([(x, self.providers[x]['priority']) for x in self.providers],\n                        key=lambda x: (x[1], random.random()), reverse=True)]\n        if self.ignore_priority:\n            random.shuffle(provider_lst)\n\n        for sp in provider_lst:\n            if self.resultcount >= self.max_providers:\n                break\n            try:\n                if sp not in ['bitcoind', 'litecoind', 'dashd', 'dogecoind', 'caching'] and not self.providers[sp]['url'] and \\\n                        self.network.name != 'bitcoinlib_test':\n                    continue\n                client = getattr(services, self.providers[sp]['provider'])\n                providerclient = getattr(client, self.providers[sp]['client_class'])\n                pc_instance = providerclient(\n                    self.network, self.providers[sp]['url'], self.providers[sp]['denominator'],\n                    self.providers[sp]['api_key'], self.providers[sp]['provider_coin_id'],\n                    self.providers[sp]['network_overrides'], self.timeout, self._blockcount, self.strict)\n                if not hasattr(pc_instance, method):\n                    _logger.debug(\"Method %s not found for provider %s\" % (method, sp))\n                    continue\n                if self.providers[sp]['api_key'] == 'api-key-needed':\n                    _logger.debug(\"API key needed for provider %s\" % sp)\n                    continue\n                providermethod = getattr(pc_instance, method)\n                res = providermethod(*arguments)\n                if res is False:  # pragma: no cover\n                    self.errors.update(\n                        {sp: 'Received empty response'}\n                    )\n                    _logger.info(\"Empty response from %s when calling %s\" % (sp, method))\n                    continue\n                self.results.update(\n                    {sp: res}\n                )\n                _logger.debug(\"Executed method %s from provider %s\" % (method, sp))\n                self.resultcount += 1\n            except Exception as e:\n                if not isinstance(e, AttributeError):\n                    try:\n                        err = e.msg\n                    except AttributeError:\n                        err = e\n                    self.errors.update(\n                        {sp: err}\n                    )\n                    _logger.debug(\"Error %s on provider %s\" % (e, sp))\n                    # -- Use this to debug specific Services errors --\n                    # from pprint import pprint\n                    # pprint(self.errors)\n\n                if len(self.errors) >= self.max_errors:\n                    _logger.warning(\"Aborting, max errors exceeded: %s\" %\n                                    list(self.errors.keys()))\n                    if len(self.results):\n                        return list(self.results.values())[0]\n                    else:\n                        return False\n\n            if self.resultcount >= self.max_providers:\n                break\n\n        if not self.resultcount:\n            raise ServiceError(\"No successful response from any serviceprovider: %s\" % list(self.providers.keys()))\n        return list(self.results.values())[0]",
  "def getbalance(self, addresslist, addresses_per_request=5):\n        \"\"\"\n        Get total balance for address or list of addresses\n\n        :param addresslist: Address or list of addresses\n        :type addresslist: list, str\n        :param addresses_per_request: Maximum number of addresses per request. Default is 5. Use lower setting when you experience timeouts or service request errors, or higher when possible.\n        :type addresses_per_request: int\n\n        :return dict: Balance per address\n        \"\"\"\n        if isinstance(addresslist, TYPE_TEXT):\n            addresslist = [addresslist]\n\n        tot_balance = 0\n        while addresslist:\n            for address in addresslist:\n                db_addr = self.cache.getaddress(address)\n                if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount() and db_addr.balance:\n                    tot_balance += db_addr.balance\n                    addresslist.remove(address)\n\n            balance = self._provider_execute('getbalance', addresslist[:addresses_per_request])\n            if balance:\n                tot_balance += balance\n            if len(addresslist) == 1:\n                self.cache.store_address(addresslist[0], balance=balance)\n            addresslist = addresslist[addresses_per_request:]\n        return tot_balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get list of unspent outputs (UTXO's) for specified address.\n\n        Sorted from old to new, so the highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.\n        :type after_txid: str\n        :param limit: Maximum number of utxo's to return. Sometimes ignored by service providers if more results are returned by default.\n        :type limit: int\n\n        :return dict: UTXO's per address\n        \"\"\"\n        if not isinstance(address, TYPE_TEXT):\n            raise ServiceError(\"Address parameter must be of type text\")\n        self.results_cache_n = 0\n        self.complete = True\n\n        utxos_cache = []\n        if self.min_providers <= 1:\n            utxos_cache = self.cache.getutxos(address, bytes.fromhex(after_txid)) or []\n        if utxos_cache:\n            self.results_cache_n = len(utxos_cache)\n\n            # Last updated block does not always include spent info...\n            # if db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount():\n            #     return utxos_cache\n            after_txid = utxos_cache[-1:][0]['txid']\n\n        utxos = self._provider_execute('getutxos', address, after_txid, limit)\n        if utxos is False:\n            raise ServiceError(\"Error when retrieving UTXO's\")\n        else:\n            # Update cache_transactions_node\n            for utxo in utxos:\n                self.cache.store_utxo(utxo['txid'], utxo['output_n'], commit=False)\n            self.cache.commit()\n            if utxos and len(utxos) >= limit:\n                self.complete = False\n            elif not after_txid:\n                balance = sum(u['value'] for u in utxos)\n                self.cache.store_address(address, balance=balance, n_utxos=len(utxos))\n\n        return utxos_cache + utxos",
  "def gettransaction(self, txid):\n        \"\"\"\n        Get a transaction by its transaction hash. Convert to Bitcoinlib Transaction object.\n\n        :param txid: Transaction identification hash\n        :type txid: str\n\n        :return Transaction: A single transaction object\n        \"\"\"\n        tx = None\n        self.results_cache_n = 0\n\n        if self.min_providers <= 1:\n            tx = self.cache.gettransaction(bytes.fromhex(txid))\n            if tx:\n                self.results_cache_n = 1\n        if not tx:\n            tx = self._provider_execute('gettransaction', txid)\n            if tx and tx.txid != txid:\n                _logger.warning(\"Incorrect txid after parsing\")\n                tx.txid = txid\n            if len(self.results) and self.min_providers <= 1:\n                self.cache.store_transaction(tx)\n        return tx",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get all transactions for specified address.\n\n        Sorted from old to new, so transactions with highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for transactions after given tx id. Default: Leave empty to return all transaction. If used only provide a single address\n        :type after_txid: str\n        :param limit: Maximum number of transactions to return\n        :type limit: int\n\n        :return list: List of Transaction objects\n        \"\"\"\n        self._reset_results()\n        self.results_cache_n = 0\n        if not address:\n            return []\n        if not isinstance(address, TYPE_TEXT):\n            raise ServiceError(\"Address parameter must be of type text\")\n        if after_txid is None:\n            after_txid = ''\n        db_addr = self.cache.getaddress(address)\n        txs_cache = []\n        qry_after_txid = bytes.fromhex(after_txid)\n\n        # Retrieve transactions from cache\n        caching_enabled = True\n        if self.min_providers > 1:  # Disable cache if comparing providers\n            caching_enabled = False\n\n        if caching_enabled:\n            txs_cache = self.cache.gettransactions(address, qry_after_txid, limit) or []\n            if txs_cache:\n                self.results_cache_n = len(txs_cache)\n                if len(txs_cache) == limit:\n                    return txs_cache\n                limit = limit - len(txs_cache)\n                qry_after_txid = bytes.fromhex(txs_cache[-1:][0].txid)\n\n        # Get (extra) transactions from service providers\n        txs = []\n        if not(db_addr and db_addr.last_block and db_addr.last_block >= self.blockcount()) or not caching_enabled:\n            txs = self._provider_execute('gettransactions', address, qry_after_txid.hex(),  limit)\n            if txs is False:\n                raise ServiceError(\"Error when retrieving transactions from service provider\")\n\n        # Store transactions and address in cache\n        # - disable cache if comparing providers or if after_txid is used and no cache is available\n        last_block = None\n        last_txid = None\n        if self.min_providers <= 1 and not(after_txid and not db_addr) and caching_enabled:\n            last_block = self.blockcount()\n            last_txid = qry_after_txid\n            self.complete = True\n            if len(txs) == limit:\n                self.complete = False\n                last_block = txs[-1:][0].block_height\n            if len(txs):\n                last_txid = bytes.fromhex(txs[-1:][0].txid)\n            if len(self.results):\n                order_n = 0\n                for t in txs:\n                    if t.confirmations != 0:\n                        res = self.cache.store_transaction(t, order_n, commit=False)\n                        order_n += 1\n                        # Failure to store transaction: stop caching transaction and store last tx block height - 1\n                        if res is False:\n                            if t.block_height:\n                                last_block = t.block_height - 1\n                            break\n                self.cache.commit()\n                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=self.complete)\n\n        all_txs = txs_cache + txs\n        # If we have txs for this address update spent and balance information in cache\n        if self.complete:\n            all_txs = transaction_update_spents(all_txs, address)\n            if caching_enabled:\n                self.cache.store_address(address, last_block, last_txid=last_txid, txs_complete=True)\n                for t in all_txs:\n                    self.cache.store_transaction(t, commit=False)\n                self.cache.commit()\n        return all_txs",
  "def getrawtransaction(self, txid):\n        \"\"\"\n        Get a raw transaction by its transaction hash\n\n        :param txid: Transaction identification hash\n        :type txid: str\n\n        :return str: Raw transaction as hexstring\n        \"\"\"\n        self.results_cache_n = 0\n        rawtx = self.cache.getrawtransaction(bytes.fromhex(txid))\n        if rawtx:\n            self.results_cache_n = 1\n            return rawtx\n        return self._provider_execute('getrawtransaction', txid)",
  "def sendrawtransaction(self, rawtx):\n        \"\"\"\n        Push a raw transaction to the network\n\n        :param rawtx: Raw transaction as hexstring or bytes\n        :type rawtx: str\n\n        :return dict: Send transaction result\n        \"\"\"\n        return self._provider_execute('sendrawtransaction', rawtx)",
  "def estimatefee(self, blocks=3, priority=''):\n        \"\"\"\n        Estimate fee per kilobyte for a transaction for this network with expected confirmation within a certain\n        amount of blocks\n\n        :param blocks: Expected confirmation time in blocks. Default is 3.\n        :type blocks: int\n        :param priority: Priority for transaction: can be 'low', 'medium' or 'high'. Overwrites value supplied in 'blocks' argument\n        :type priority: str\n\n        :return int: Fee in the smallest network denominator (satoshi)\n        \"\"\"\n        self.results_cache_n = 0\n        if priority:\n            if priority == 'low':\n                blocks = 10\n            elif priority == 'high':\n                blocks = 1\n        if self.min_providers <= 1:  # Disable cache if comparing providers\n            fee = self.cache.estimatefee(blocks)\n            if fee:\n                self.results_cache_n = 1\n                return fee\n        fee = self._provider_execute('estimatefee', blocks)\n        if not fee:  # pragma: no cover\n            if self.network.fee_default:\n                fee = self.network.fee_default\n            else:\n                raise ServiceError(\"Could not estimate fees, please define default fees in network settings\")\n        if fee < self.network.fee_min:\n            fee = self.network.fee_min\n        elif fee > self.network.fee_max:\n            fee = self.network.fee_max\n        self.cache.store_estimated_fee(blocks, fee)\n        return fee",
  "def blockcount(self):\n        \"\"\"\n        Get the latest block number: The block number of last block in longest chain on the Blockchain.\n\n        Block count is cashed for BLOCK_COUNT_CACHE_TIME seconds to avoid to many calls to service providers.\n\n        :return int:\n        \"\"\"\n\n        blockcount = self.cache.blockcount()\n        last_cache_blockcount = self.cache.blockcount(never_expires=True)\n        if blockcount:\n            self._blockcount = blockcount\n            return blockcount\n\n        current_timestamp = time.time()\n        if self._blockcount_update < current_timestamp - BLOCK_COUNT_CACHE_TIME:\n            new_count = self._provider_execute('blockcount')\n            if not self._blockcount or (new_count and new_count > self._blockcount):\n                self._blockcount = new_count\n                self._blockcount_update = current_timestamp\n            if last_cache_blockcount > self._blockcount:\n                return last_cache_blockcount\n            # Store result in cache\n            if len(self.results) and list(self.results.keys())[0] != 'caching':\n                self.cache.store_blockcount(self._blockcount)\n        return self._blockcount",
  "def getblock(self, blockid, parse_transactions=True, page=1, limit=None):\n        \"\"\"\n        Get block with specified block height or block hash from service providers.\n\n        If parse_transaction is set to True a list of Transaction object will be returned otherwise a\n        list of transaction ID's.\n\n        Some providers require 1 or 2 extra request per transaction, so to avoid timeouts or rate limiting errors\n        you can specify a page and limit for the transaction. For instance with page=2, limit=4 only transaction\n        5 to 8 are returned to the Blocks's 'transaction' attribute.\n\n        If you only use a local bcoin or bitcoind provider, make sure you set the limit to maximum (i.e. 9999)\n        because all transactions are already downloaded when fetching the block.\n\n        >>> from bitcoinlib.services.services import Service\n        >>> srv = Service()\n        >>> b = srv.getblock(0)\n        >>> b\n        <Block(000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f, 0, transactions: 1)>\n\n        :param blockid: Hash or block height of block\n        :type blockid: str, int\n        :param parse_transactions: Return Transaction objects or just transaction ID's. Default is return txids.\n        :type parse_transactions: bool\n        :param page: Page number of transaction paging. Default is start from the beginning: 1\n        :type page: int\n        :param limit: Maximum amount of transaction to return. Default is 25 if parse transaction is enabled, otherwise returns all txid's (9999)\n        :type limit: int\n\n        :return Block:\n        \"\"\"\n        if limit is None:\n            limit = 25 if parse_transactions else 99999\n\n        block = self.cache.getblock(blockid)\n        is_last_page = False\n        if block:\n            # Block found get transactions from cache\n            txs = self.cache.getblocktransactions(block.height, page, limit)\n            if parse_transactions:\n                block.transactions = txs\n            else:\n                block.transactions = [tx.txid for tx in txs]\n            if block.transactions:\n                self.results_cache_n = 1\n            is_last_page = page*limit > block.tx_count\n        if not block or (not len(block.transactions) and limit != 0) or (not is_last_page and len(block.transactions) < limit) or \\\n                (is_last_page and ((page-1)*limit - block.tx_count + len(block.transactions)) < 0):\n            self.results_cache_n = 0\n            bd = self._provider_execute('getblock', blockid, parse_transactions, page, limit)\n            if not bd or isinstance(bd, bool):\n                return False\n            block = Block(bd['block_hash'], bd['version'], bd['prev_block'], bd['merkle_root'], bd['time'], bd['bits'],\n                          bd['nonce'], bd['txs'], bd['height'], bd['depth'], self.network)\n            block.tx_count = bd['tx_count']\n            block.limit = limit\n            block.page = page\n\n            if parse_transactions and self.min_providers <= 1:\n                order_n = (page-1)*limit\n                for tx in block.transactions:\n                    if isinstance(tx, Transaction):\n                        self.cache.store_transaction(tx, order_n, commit=False)\n                    order_n += 1\n                self.cache.commit()\n            self.complete = True if len(block.transactions) == block.tx_count else False\n            self.cache.store_block(block)\n        return block",
  "def getrawblock(self, blockid):\n        \"\"\"\n        Get raw block as hexadecimal string for block with specified hash or block height.\n\n        Not many providers offer this option, and it can be slow, so it is advised to use a local client such\n        as bitcoind.\n\n        :param blockid: Block hash or block height\n        :type blockid: str, int\n\n        :return str:\n        \"\"\"\n        return self._provider_execute('getrawblock', blockid)",
  "def mempool(self, txid=''):\n        \"\"\"\n        Get list of all transaction IDs in the current mempool\n\n        A full list of transactions ID's will only be returned if a bcoin or bitcoind client is available. Otherwise\n        specify the txid option to verify if a transaction is added to the mempool.\n\n        :param txid: Check if transaction with this hash exists in memory pool\n        :type txid: str\n\n        :return list:\n        \"\"\"\n        return self._provider_execute('mempool', txid)",
  "def getcacheaddressinfo(self, address):\n        \"\"\"\n        Get address information from cache. I.e. balance, number of transactions, number of utox's, etc\n\n        Cache will only be filled after all transactions for a specific address are retrieved (with gettransactions ie)\n\n        :param address: address string\n        :type address: str\n\n        :return dict:\n        \"\"\"\n        addr_dict = {'address': address}\n        addr_rec = self.cache.getaddress(address)\n        if isinstance(addr_rec, DbCacheAddress):\n            addr_dict['balance'] = addr_rec.balance\n            addr_dict['last_block'] = addr_rec.last_block\n            addr_dict['n_txs'] = addr_rec.n_txs\n            addr_dict['n_utxos'] = addr_rec.n_utxos\n        return addr_dict",
  "def isspent(self, txid, output_n):\n        \"\"\"\n        Check if the output with provided transaction ID and output number is spent.\n\n        :param txid: Transaction ID hex\n        :type txid: str\n        :param output_n: Output number\n        :type output_n: int\n\n        :return bool:\n        \"\"\"\n        t = self.cache.gettransaction(bytes.fromhex(txid))\n        if t and len(t.outputs) > output_n and t.outputs[output_n].spent is not None:\n            return t.outputs[output_n].spent\n        else:\n            return bool(self._provider_execute('isspent', txid, output_n))",
  "def getinfo(self):\n        \"\"\"\n        Returns info about current network. Such as difficulty, latest block, mempool size and network hashrate.\n\n        :return dict:\n        \"\"\"\n        return self._provider_execute('getinfo')",
  "def getinputvalues(self, t):\n        \"\"\"\n        Retrieve values for transaction inputs for given Transaction.\n\n        Raw transactions as stored on the blockchain do not contain the input values but only the previous\n        transaction hash and index number. This method retrieves the previous transaction and reads the value.\n\n        :param t: Transaction\n        :type t: Transaction\n\n        :return Transaction:\n        \"\"\"\n        prev_txs = []\n        for i in t.inputs:\n            if not i.value:\n                if i.prev_txid not in prev_txs:\n                    prev_t = self.gettransaction(i.prev_txid.hex())\n                else:\n                    prev_t = [t for t in prev_txs if t.txid == i.prev_txid][0]\n                i.value = prev_t.outputs[i.output_n_int].value\n        return t",
  "def __init__(self, network, db_uri=''):\n        \"\"\"\n        Open Cache class\n\n        :param network: Specify network used\n        :type network: str, Network\n        :param db_uri: Database to use for caching\n        :type db_uri: str\n        \"\"\"\n        self.session = None\n        if SERVICE_CACHING_ENABLED:\n            self.session = DbCache(db_uri=db_uri).session\n        self.network = network",
  "def __exit__(self):\n        try:\n            self.session.close()\n        except Exception:\n            pass",
  "def cache_enabled(self):\n        \"\"\"\n        Check if caching is enabled. Returns False if SERVICE_CACHING_ENABLED is False or no session is defined.\n\n        :return bool:\n        \"\"\"\n        if not SERVICE_CACHING_ENABLED or not self.session:\n            return False\n        return True",
  "def commit(self):\n        \"\"\"\n        Commit queries in self.session. Rollback if commit fails.\n\n        :return:\n        \"\"\"\n        if not self.session:\n            return\n        try:\n            self.session.commit()\n        except Exception:\n            self.session.rollback()\n            raise",
  "def _parse_db_transaction(db_tx):\n        t = Transaction(locktime=db_tx.locktime, version=db_tx.version, network=db_tx.network_name,\n                        fee=db_tx.fee, txid=db_tx.txid.hex(), date=db_tx.date, confirmations=db_tx.confirmations,\n                        block_height=db_tx.block_height, status='confirmed', witness_type=db_tx.witness_type.value)\n        for n in db_tx.nodes:\n            if n.is_input:\n                if n.ref_txid == b'\\00' * 32:\n                    t.coinbase = True\n                t.add_input(n.ref_txid.hex(), n.ref_index_n, unlocking_script=n.script, address=n.address,\n                            sequence=n.sequence, value=n.value, index_n=n.index_n, witnesses=n.witnesses, strict=False)\n            else:\n                t.add_output(n.value, n.address, lock_script=n.script, spent=n.spent, output_n=n.index_n,\n                             spending_txid=None if not n.ref_txid else n.ref_txid.hex(),\n                             spending_index_n=n.ref_index_n, strict=False)\n\n        t.update_totals()\n        t.size = len(t.raw())\n        t.calc_weight_units()\n        _logger.info(\"Retrieved transaction %s from cache\" % t.txid)\n        return t",
  "def gettransaction(self, txid):\n        \"\"\"\n        Get transaction from cache. Returns False if not available\n\n        :param txid: Transaction identification hash\n        :type txid: bytes\n\n        :return Transaction: A single Transaction object\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()\n        if not db_tx:\n            return False\n        db_tx.txid = txid\n        t = self._parse_db_transaction(db_tx)\n        if t.block_height:\n            t.confirmations = (self.blockcount() - t.block_height) + 1\n        return t",
  "def getaddress(self, address):\n        \"\"\"\n        Get address information from cache, with links to transactions and utxo's and latest update information.\n\n        :param address: Address string\n        :type address: str\n\n        :return DbCacheAddress: An address cache database object\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        return self.session.query(DbCacheAddress).filter_by(address=address, network_name=self.network.name).scalar()",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        \"\"\"\n        Get transactions from cache. Returns empty list if no transactions are found or caching is disabled.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for transactions after given tx id. Default: Leave empty to return all transaction. If used only provide a single address\n        :type after_txid: bytes\n        :param limit: Maximum number of transactions to return\n        :type limit: int\n\n        :return list: List of Transaction objects\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_addr = self.getaddress(address)\n        txs = []\n        if db_addr:\n            if after_txid:\n                after_tx = self.session.query(DbCacheTransaction).\\\n                    filter_by(txid=after_txid, network_name=self.network.name).scalar()\n                if after_tx and db_addr.last_block and after_tx.block_height:\n                    db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).\\\n                        filter(DbCacheTransactionNode.address == address,\n                               DbCacheTransaction.block_height >= after_tx.block_height,\n                               DbCacheTransaction.block_height <= db_addr.last_block).\\\n                        order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()\n                    db_txs2 = []\n                    for d in db_txs:\n                        db_txs2.append(d)\n                        if d.txid == after_txid:\n                            db_txs2 = []\n                    db_txs = db_txs2\n                else:\n                    return []\n            else:\n                db_txs = self.session.query(DbCacheTransaction).join(DbCacheTransactionNode). \\\n                    filter(DbCacheTransactionNode.address == address). \\\n                    order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n).all()\n            for db_tx in db_txs:\n                t = self._parse_db_transaction(db_tx)\n                if t:\n                    if t.block_height:\n                        t.confirmations = (self.blockcount() - t.block_height) + 1\n                    txs.append(t)\n                    if len(txs) >= limit:\n                        break\n            return txs\n        return []",
  "def getblocktransactions(self, height, page, limit):\n        \"\"\"\n        Get range of transactions from a block\n\n        :param height: Block height\n        :type height: int\n        :param page: Transaction page\n        :type page: int\n        :param limit: Number of transactions per page\n        :type limit: int\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        n_from = (page-1) * limit\n        n_to = page * limit\n        db_txs = self.session.query(DbCacheTransaction).\\\n            filter(DbCacheTransaction.block_height == height, DbCacheTransaction.order_n >= n_from,\n                   DbCacheTransaction.order_n < n_to).all()\n        txs = []\n        for db_tx in db_txs:\n            t = self._parse_db_transaction(db_tx)\n            if t:\n                txs.append(t)\n        return txs",
  "def getrawtransaction(self, txid):\n        \"\"\"\n        Get a raw transaction string from the database cache if available\n\n        :param txid: Transaction identification hash\n        :type txid: bytes\n\n        :return str: Raw transaction as hexstring\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        tx = self.session.query(DbCacheTransaction).filter_by(txid=txid, network_name=self.network.name).first()\n        if not tx:\n            return False\n        t = self._parse_db_transaction(tx)\n        return t.raw_hex()",
  "def getutxos(self, address, after_txid=''):\n        \"\"\"\n        Get list of unspent outputs (UTXO's) for specified address from database cache.\n\n        Sorted from old to new, so highest number of confirmations first.\n\n        :param address: Address string\n        :type address: str\n        :param after_txid: Transaction ID of last known transaction. Only check for utxos after given tx id. Default: Leave empty to return all utxos.\n        :type after_txid: bytes\n\n        :return dict: UTXO's per address\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        db_utxos = self.session.query(DbCacheTransactionNode.spent, DbCacheTransactionNode.index_n,\n                                      DbCacheTransactionNode.value, DbCacheTransaction.confirmations,\n                                      DbCacheTransaction.block_height, DbCacheTransaction.fee,\n                                      DbCacheTransaction.date, DbCacheTransaction.txid).join(DbCacheTransaction). \\\n            order_by(DbCacheTransaction.block_height, DbCacheTransaction.order_n). \\\n            filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.is_input == False,\n                   DbCacheTransaction.network_name == self.network.name).all()\n        utxos = []\n        for db_utxo in db_utxos:\n            if db_utxo.spent is False:\n                utxos.append({\n                    'address': address,\n                    'txid': db_utxo.txid.hex(),\n                    'confirmations': db_utxo.confirmations,\n                    'output_n': db_utxo.index_n,\n                    'input_n': 0,\n                    'block_height': db_utxo.block_height,\n                    'fee': db_utxo.fee,\n                    'size': 0,\n                    'value': db_utxo.value,\n                    'script': '',\n                    'date': db_utxo.date\n                })\n            elif db_utxo.spent is None:\n                return utxos\n            if db_utxo.txid == after_txid:\n                utxos = []\n        return utxos",
  "def estimatefee(self, blocks):\n        \"\"\"\n        Get fee estimation from cache for confirmation within specified amount of blocks.\n\n        Stored in cache in three groups: low, medium and high fees.\n\n        :param blocks: Expected confirmation time in blocks.\n        :type blocks: int\n\n        :return int: Fee in the smallest network denominator (satoshi)\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        if blocks <= 1:\n            varname = 'fee_high'\n        elif blocks <= 5:\n            varname = 'fee_medium'\n        else:\n            varname = 'fee_low'\n        dbvar = self.session.query(DbCacheVars).filter_by(varname=varname, network_name=self.network.name).\\\n            filter(DbCacheVars.expires > datetime.now()).scalar()\n        if dbvar:\n            return int(dbvar.value)\n        return False",
  "def blockcount(self, never_expires=False):\n        \"\"\"\n        Get number of blocks on the current network from cache if recent data is available.\n\n        :param never_expires: Always return latest blockcount found. Can be used to avoid return to old blocks if service providers are not up-to-date.\n        :type never_expires: bool\n\n        :return int:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        qr = self.session.query(DbCacheVars).filter_by(varname='blockcount', network_name=self.network.name)\n        if not never_expires:\n            qr = qr.filter(DbCacheVars.expires > datetime.now())\n        dbvar = qr.scalar()\n        if dbvar:\n            return int(dbvar.value)\n        return False",
  "def getblock(self, blockid):\n        \"\"\"\n        Get specific block from database cache.\n\n        :param blockid: Block height or block hash\n        :type blockid: int, str\n\n        :return Block:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        qr = self.session.query(DbCacheBlock)\n        if isinstance(blockid, int):\n            block = qr.filter_by(height=blockid, network_name=self.network.name).scalar()\n        else:\n            block = qr.filter_by(block_hash=to_bytes(blockid)).scalar()\n        if not block:\n            return False\n        b = Block(block_hash=block.block_hash, height=block.height, network=block.network_name,\n                  merkle_root=block.merkle_root, time=block.time, nonce=block.nonce,\n                  version=block.version, prev_block=block.prev_block, bits=block.bits)\n        b.tx_count = block.tx_count\n        _logger.info(\"Retrieved block with height %d from cache\" % b.height)\n        return b",
  "def store_blockcount(self, blockcount):\n        \"\"\"\n        Store network blockcount in cache for 60 seconds\n\n        :param blockcount: Number of latest block\n        :type blockcount: int, str\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        dbvar = DbCacheVars(varname='blockcount', network_name=self.network.name, value=str(blockcount), type='int',\n                            expires=datetime.now() + timedelta(seconds=60))\n        self.session.merge(dbvar)\n        self.commit()",
  "def store_transaction(self, t, order_n=None, commit=True):\n        \"\"\"\n        Store transaction in cache. Use order number to determine order in a block\n\n        :param t: Transaction\n        :type t: Transaction\n        :param order_n: Order in block\n        :type order_n: int\n        :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.\n        :type commit: bool\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        # Only store complete and confirmed transaction in cache\n        if not t.txid:    # pragma: no cover\n            _logger.info(\"Caching failure tx: Missing transaction hash\")\n            return False\n        elif not t.date or not t.block_height or not t.network:\n            _logger.info(\"Caching failure tx: Incomplete transaction missing date, block height or network info\")\n            return False\n        elif not t.coinbase and [i for i in t.inputs if not i.value]:\n            _logger.info(\"Caching failure tx: One the transaction inputs has value 0\")\n            return False\n        # TODO: Check if inputs / outputs are complete? script, value, prev_txid, sequence, output/input_n\n\n        txid = bytes.fromhex(t.txid)\n        if self.session.query(DbCacheTransaction).filter_by(txid=txid).count():\n            return\n        new_tx = DbCacheTransaction(txid=txid, date=t.date, confirmations=t.confirmations,\n                                    block_height=t.block_height, network_name=t.network.name,\n                                    fee=t.fee, order_n=order_n, version=t.version_int,\n                                    locktime=t.locktime, witness_type=t.witness_type)\n        self.session.add(new_tx)\n        for i in t.inputs:\n            if i.value is None or i.address is None or i.output_n is None:    # pragma: no cover\n                _logger.info(\"Caching failure tx: Input value, address or output_n missing\")\n                return False\n            witnesses = int_to_varbyteint(len(i.witnesses)) + b''.join([bytes(varstr(w)) for w in i.witnesses])\n            new_node = DbCacheTransactionNode(txid=txid, address=i.address, index_n=i.index_n, value=i.value,\n                                              is_input=True, ref_txid=i.prev_txid, ref_index_n=i.output_n_int,\n                                              script=i.unlocking_script, sequence=i.sequence, witnesses=witnesses)\n            self.session.add(new_node)\n        for o in t.outputs:\n            if o.value is None or o.address is None or o.output_n is None:    # pragma: no cover\n                _logger.info(\"Caching failure tx: Output value, address or output_n missing\")\n                return False\n            new_node = DbCacheTransactionNode(\n                txid=txid, address=o.address, index_n=o.output_n, value=o.value, is_input=False, spent=o.spent,\n                ref_txid=None if not o.spending_txid else bytes.fromhex(o.spending_txid),\n                ref_index_n=o.spending_index_n, script=o.lock_script)\n            self.session.add(new_node)\n\n        if commit:\n            try:\n                self.commit()\n                _logger.info(\"Added transaction %s to cache\" % t.txid)\n            except Exception as e:    # pragma: no cover\n                _logger.warning(\"Caching failure tx: %s\" % e)",
  "def store_utxo(self, txid, index_n, commit=True):\n        \"\"\"\n        Store utxo in cache. Updates only known transaction outputs for transactions which are fully cached\n\n        :param txid: Transaction ID\n        :type txid: str\n        :param index_n: Index number of output\n        :type index_n: int\n        :param commit: Commit transaction to database. Default is True. Can be disabled if a larger number of transactions are added to cache, so you can commit outside this method.\n        :type commit: bool\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return False\n        txid = bytes.fromhex(txid)\n        result = self.session.query(DbCacheTransactionNode). \\\n            filter(DbCacheTransactionNode.txid == txid, DbCacheTransactionNode.index_n == index_n,\n                   DbCacheTransactionNode.is_input == False).\\\n            update({DbCacheTransactionNode.spent: False})\n        if commit:\n            try:\n                self.commit()\n            except Exception as e:    # pragma: no cover\n                _logger.warning(\"Caching failure utxo %s:%d: %s\" % (txid.hex(), index_n, e))",
  "def store_address(self, address, last_block=None, balance=0, n_utxos=None, txs_complete=False, last_txid=None):\n        \"\"\"\n        Store address information in cache\n\n        :param address: Address string\n        :type address: str\n        :param last_block: Number or last block retrieved from service provider. For instance if address contains a large number of transactions and they will be retrieved in more then one request.\n        :type last_block: int\n        :param balance: Total balance of address in sathosis, or smallest network detominator\n        :type balance: int\n        :param n_utxos: Total number of UTXO's for this address\n        :type n_utxos: int\n        :param txs_complete: True if all transactions for this address are added to cache\n        :type txs_complete: bool\n        :param last_txid: Transaction ID of last transaction downloaded from blockchain\n        :type last_txid: bytes\n\n .       :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        n_txs = None\n        if txs_complete:\n            n_txs = len(self.session.query(DbCacheTransaction).join(DbCacheTransactionNode).\n                        filter(DbCacheTransactionNode.address == address).all())\n            if n_utxos is None:\n                n_utxos = self.session.query(DbCacheTransactionNode).\\\n                    filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(False),\n                           DbCacheTransactionNode.is_input.is_(False)).count()\n                if self.session.query(DbCacheTransactionNode).\\\n                        filter(DbCacheTransactionNode.address == address, DbCacheTransactionNode.spent.is_(None),\n                               DbCacheTransactionNode.is_input.is_(False)).count():\n                    n_utxos = None\n            if not balance:\n                plusmin = self.session.query(DbCacheTransactionNode.is_input, func.sum(DbCacheTransactionNode.value)). \\\n                    filter(DbCacheTransactionNode.address == address). \\\n                    group_by(DbCacheTransactionNode.is_input).all()\n                balance = 0 if not plusmin else sum([(-p[1] if p[0] else p[1]) for p in plusmin])\n        db_addr = self.getaddress(address)\n        new_address = DbCacheAddress(\n            address=address, network_name=self.network.name,\n            last_block=last_block if last_block else getattr(db_addr, 'last_block', None),\n            balance=balance if balance is not None else getattr(db_addr, 'balance', None),\n            n_utxos=n_utxos if n_utxos is not None else getattr(db_addr, 'n_utxos', None),\n            n_txs=n_txs if n_txs is not None else getattr(db_addr, 'n_txs', None),\n            last_txid=last_txid if last_txid is not None else getattr(db_addr, 'last_txid', None))\n        self.session.merge(new_address)\n        try:\n            self.commit()\n        except Exception as e:    # pragma: no cover\n            _logger.warning(\"Caching failure addr: %s\" % e)",
  "def store_estimated_fee(self, blocks, fee):\n        \"\"\"\n        Store estimated fee retrieved from service providers in cache.\n\n        :param blocks: Confirmation within x blocks\n        :type blocks: int\n        :param fee: Estimated fee in Sathosis\n        :type fee: int\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        if blocks <= 1:\n            varname = 'fee_high'\n        elif blocks <= 5:\n            varname = 'fee_medium'\n        else:\n            varname = 'fee_low'\n        dbvar = DbCacheVars(varname=varname, network_name=self.network.name, value=str(fee), type='int',\n                            expires=datetime.now() + timedelta(seconds=600))\n        self.session.merge(dbvar)\n        self.commit()",
  "def store_block(self, block):\n        \"\"\"\n        Store block in cache database\n\n        :param block: Block\n        :type block: Block\n\n        :return:\n        \"\"\"\n        if not self.cache_enabled():\n            return\n        if not (block.height and block.block_hash and block.prev_block and block.merkle_root and\n                block.bits and block.version) \\\n                and not block.block_hash == b'\\x00\\x00\\x00\\x00\\x00\\x19\\xd6h\\x9c\\x08Z\\xe1e\\x83\\x1e\\x93O\\xf7c\\xaeF' \\\n                                            b'\\xa2\\xa6\\xc1r\\xb3\\xf1\\xb6\\n\\x8c\\xe2o':  # Bitcoin genesis block\n            _logger.info(\"Caching failure block: incomplete data\")\n            return\n\n        new_block = DbCacheBlock(\n            block_hash=block.block_hash, height=block.height, network_name=self.network.name,\n            version=block.version_int, prev_block=block.prev_block, bits=block.bits_int,\n            merkle_root=block.merkle_root, nonce=block.nonce_int, time=block.time, tx_count=block.tx_count)\n        self.session.merge(new_block)\n        try:\n            self.commit()\n        except Exception as e:    # pragma: no cover\n            _logger.warning(\"Caching failure block: %s\" % e)",
  "class LitecoreIOClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + '/' + cmd\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)\n\n    def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else tx['valueIn']\n        isCoinbase = False\n        if 'isCoinBase' in tx and tx['isCoinBase']:\n            isCoinbase = True\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fees, size=tx['size'], txid=tx['txid'],\n                        date=txdate, confirmations=tx['confirmations'],\n                        block_height=tx['blockheight'], status=status,\n                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,\n                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))\n        for ti in tx['vin']:\n            if isCoinbase:\n                t.add_input(prev_txid=32 * b'\\0', output_n=4*b'\\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],\n                            script_type='coinbase', sequence=ti['sequence'], value=0)\n            else:\n                value = int(round(float(ti['value']) * self.units, 0))\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],\n                            index_n=ti['n'], value=value, sequence=ti['sequence'],\n                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'])\n        for to in tx['vout']:\n            value = int(round(float(to['value']) * self.units, 0))\n            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],\n                         spent=True if to['spentTxId'] else False, output_n=to['n'],\n                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],\n                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('addr', a.address, 'balance')\n            balance += res\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'utxo')\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx['scriptPubKey'],\n                'date': None\n            })\n        return txs[::-1][:limit]\n\n    def gettransaction(self, tx_id):\n        tx = self.compose_request('tx', tx_id)\n        return self._convert_to_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'txs')\n        txs = []\n        txs_dict = res['items'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs\n\n    def getrawtransaction(self, tx_id):\n        res = self.compose_request('rawtx', tx_id)\n        return res['rawtx']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }\n\n    # def estimatefee\n\n    def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['info']['blocks']\n\n    def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-index', str(blockid))['blockHash']\n        bd = self.compose_request('block', blockid)\n        if parse_transactions:\n            txs = []\n            for txid in bd['tx'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(txid))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': len(bd['tx']),\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0\n\n    def getinfo(self):\n        info = self.compose_request('status', '')['info']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['network'],\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': 0,\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, data, cmd='', variables=None, method='get', offset=0):\n        url_path = category\n        if data:\n            url_path += '/' + data + '/' + cmd\n        if variables is None:\n            variables = {}\n        variables.update({'from': offset, 'to': offset+REQUEST_LIMIT})\n        return self.request(url_path, variables, method=method)",
  "def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        fees = None if 'fees' not in tx else int(round(float(tx['fees']) * self.units, 0))\n        value_in = 0 if 'valueIn' not in tx else tx['valueIn']\n        isCoinbase = False\n        if 'isCoinBase' in tx and tx['isCoinBase']:\n            isCoinbase = True\n        txdate = None\n        if 'blocktime' in tx:\n            txdate = datetime.utcfromtimestamp(tx['blocktime'])\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network,\n                        fee=fees, size=tx['size'], txid=tx['txid'],\n                        date=txdate, confirmations=tx['confirmations'],\n                        block_height=tx['blockheight'], status=status,\n                        input_total=int(round(float(value_in) * self.units, 0)), coinbase=isCoinbase,\n                        output_total=int(round(float(tx['valueOut']) * self.units, 0)))\n        for ti in tx['vin']:\n            if isCoinbase:\n                t.add_input(prev_txid=32 * b'\\0', output_n=4*b'\\xff', unlocking_script=ti['coinbase'], index_n=ti['n'],\n                            script_type='coinbase', sequence=ti['sequence'], value=0)\n            else:\n                value = int(round(float(ti['value']) * self.units, 0))\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptSig']['hex'],\n                            index_n=ti['n'], value=value, sequence=ti['sequence'],\n                            double_spend=False if ti['doubleSpentTxID'] is None else ti['doubleSpentTxID'])\n        for to in tx['vout']:\n            value = int(round(float(to['value']) * self.units, 0))\n            t.add_output(value=value, lock_script=to['scriptPubKey']['hex'],\n                         spent=True if to['spentTxId'] else False, output_n=to['n'],\n                         spending_txid=None if not to['spentTxId'] else to['spentTxId'],\n                         spending_index_n=None if not to['spentIndex'] else to['spentIndex'], strict=self.strict)\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('addr', a.address, 'balance')\n            balance += res\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'utxo')\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx['height'],\n                'fee': None,\n                'size': 0,\n                'value': tx['satoshis'],\n                'script': tx['scriptPubKey'],\n                'date': None\n            })\n        return txs[::-1][:limit]",
  "def gettransaction(self, tx_id):\n        tx = self.compose_request('tx', tx_id)\n        return self._convert_to_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('addrs', address.address, 'txs')\n        txs = []\n        txs_dict = res['items'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs",
  "def getrawtransaction(self, tx_id):\n        res = self.compose_request('rawtx', tx_id)\n        return res['rawtx']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('tx', 'send', variables={'rawtx': rawtx}, method='post')\n        return {\n            'txid': res['txid'],\n            'response_dict': res\n        }",
  "def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['info']['blocks']",
  "def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-index', str(blockid))['blockHash']\n        bd = self.compose_request('block', blockid)\n        if parse_transactions:\n            txs = []\n            for txid in bd['tx'][(page-1)*limit:page*limit]:\n                # try:\n                txs.append(self.gettransaction(txid))\n                # except Exception as e:\n                #     _logger.error(\"Could not parse tx %s with error %s\" % (txid, e))\n        else:\n            txs = bd['tx']\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleroot'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['time'],\n            'tx_count': len(bd['tx']),\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['tx']) // limit) + (len(bd['tx']) % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def getinfo(self):\n        info = self.compose_request('status', '')['info']\n        return {\n            'blockcount': info['blocks'],\n            'chain': info['network'],\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': 0,\n        }",
  "class JSONRPCException(Exception):\n    def __init__(self, rpc_error):\n        parent_args = []\n        try:\n            parent_args.append(rpc_error['message'])\n        except Exception:\n            pass\n        Exception.__init__(self, *parent_args)\n        self.error = rpc_error\n        self.code = rpc_error['code'] if 'code' in rpc_error else None\n        self.message = rpc_error['message'] if 'message' in rpc_error else None\n\n    def __str__(self):\n        return '%d: %s' % (self.code, self.message)\n\n    def __repr__(self):\n        return '<%s \\'%s\\'>' % (self.__class__.__name__, self)",
  "def EncodeDecimal(o):\n    if isinstance(o, decimal.Decimal):\n        try:\n            return float(round(o, 8))\n        except decimal.DecimalException as e:\n            return float(o)\n    raise TypeError(repr(o) + \" is not JSON serializable\")",
  "class AuthServiceProxy(object):\n    __id_count = 0\n\n    def __init__(self, service_url, service_name=None, timeout=HTTP_TIMEOUT, connection=None):\n        self.__service_url = service_url\n        self.__service_name = service_name\n        self.__url = urlparse.urlparse(service_url)\n        if self.__url.port is None:\n            port = 443 if self.__url.scheme == 'https' else 80\n        else:\n            port = self.__url.port\n        (user, passwd) = (self.__url.username, self.__url.password)\n        try:\n            user = user.encode('utf8')\n        except AttributeError:\n            pass\n        try:\n            passwd = passwd.encode('utf8')\n        except AttributeError:\n            pass\n        if not (user is None or passwd is None):\n            authpair = user + b':' + passwd\n            self.__auth_header = b'Basic ' + base64.b64encode(authpair)\n\n        self.__timeout = timeout\n\n        if connection:\n            # Callables re-use the connection of the original proxy\n            self.__conn = connection\n        elif self.__url.scheme == 'https':\n            self.__conn = httplib.HTTPSConnection(self.__url.hostname, port,\n                                                  timeout=timeout)\n        else:\n            self.__conn = httplib.HTTPConnection(self.__url.hostname, port,\n                                                 timeout=timeout)\n\n    def __getattr__(self, name):\n        if name.startswith('__') and name.endswith('__'):\n            # Python internal stuff\n            raise AttributeError\n        if self.__service_name is not None:\n            name = \"%s.%s\" % (self.__service_name, name)\n        return AuthServiceProxy(self.__service_url, name, self.__timeout, self.__conn)\n\n    def __call__(self, *args):\n        AuthServiceProxy.__id_count += 1\n\n        log.info(\"-%s-> %s %s\" % (AuthServiceProxy.__id_count, self.__service_name,\n                                   json.dumps(args, default=EncodeDecimal)))\n        postdata = json.dumps({'version': '1.1',\n                               'method': self.__service_name,\n                               'params': args,\n                               'id': AuthServiceProxy.__id_count}, default=EncodeDecimal)\n        self.__conn.request('POST', self.__url.path, postdata,\n                            {'Host': self.__url.hostname,\n                             'User-Agent': USER_AGENT,\n                             'Authorization': self.__auth_header,\n                             'Content-type': 'application/json'})\n        self.__conn.sock.settimeout(self.__timeout)\n\n        response = self._get_response()\n        if response.get('error') is not None:\n            raise JSONRPCException(response['error'])\n        elif 'result' not in response:\n            raise JSONRPCException({\n                'code': -343, 'message': 'missing JSON-RPC result'})\n        self.__conn.close()\n        return response['result']\n\n    def batch_(self, rpc_calls):\n        \"\"\"Batch RPC call.\n           Pass array of arrays: [ [ \"method\", params... ], ... ]\n           Returns array of results.\n        \"\"\"\n        batch_data = []\n        for rpc_call in rpc_calls:\n            AuthServiceProxy.__id_count += 1\n            m = rpc_call.pop(0)\n            batch_data.append({\"jsonrpc\": \"2.0\", \"method\": m, \"params\": rpc_call, \"id\": AuthServiceProxy.__id_count})\n\n        postdata = json.dumps(batch_data, default=EncodeDecimal)\n        log.debug(\"--> \" + postdata)\n        self.__conn.request('POST', self.__url.path, postdata,\n                            {'Host': self.__url.hostname,\n                             'User-Agent': USER_AGENT,\n                             'Authorization': self.__auth_header,\n                             'Content-type': 'application/json'})\n        results = []\n        responses = self._get_response()\n        for response in responses:\n            if response['error'] is not None:\n                raise JSONRPCException(response['error'])\n            elif 'result' not in response:\n                raise JSONRPCException({\n                    'code': -343, 'message': 'missing JSON-RPC result'})\n            else:\n                results.append(response['result'])\n        return results\n\n    def _get_response(self):\n        http_response = self.__conn.getresponse()\n        if http_response is None:\n            raise JSONRPCException({\n                'code': -342, 'message': 'missing HTTP response from server'})\n\n        content_type = http_response.getheader('Content-Type')\n        if content_type != 'application/json':\n            raise JSONRPCException({\n                'code': -342, 'message': 'non-JSON HTTP response with \\'%i %s\\' from server' % (\n                http_response.status, http_response.reason)})\n\n        responsedata = http_response.read().decode('utf8')\n        response = json.loads(responsedata, parse_float=decimal.Decimal)\n        if \"error\" in response and response[\"error\"] is None:\n            log.debug(\"<-%s- %s\" % (response[\"id\"], json.dumps(response[\"result\"], default=EncodeDecimal)[:1000]))\n        else:\n            log.debug(\"<-- \" + responsedata[:1000])\n        return response",
  "def __init__(self, rpc_error):\n        parent_args = []\n        try:\n            parent_args.append(rpc_error['message'])\n        except Exception:\n            pass\n        Exception.__init__(self, *parent_args)\n        self.error = rpc_error\n        self.code = rpc_error['code'] if 'code' in rpc_error else None\n        self.message = rpc_error['message'] if 'message' in rpc_error else None",
  "def __str__(self):\n        return '%d: %s' % (self.code, self.message)",
  "def __repr__(self):\n        return '<%s \\'%s\\'>' % (self.__class__.__name__, self)",
  "def __init__(self, service_url, service_name=None, timeout=HTTP_TIMEOUT, connection=None):\n        self.__service_url = service_url\n        self.__service_name = service_name\n        self.__url = urlparse.urlparse(service_url)\n        if self.__url.port is None:\n            port = 443 if self.__url.scheme == 'https' else 80\n        else:\n            port = self.__url.port\n        (user, passwd) = (self.__url.username, self.__url.password)\n        try:\n            user = user.encode('utf8')\n        except AttributeError:\n            pass\n        try:\n            passwd = passwd.encode('utf8')\n        except AttributeError:\n            pass\n        if not (user is None or passwd is None):\n            authpair = user + b':' + passwd\n            self.__auth_header = b'Basic ' + base64.b64encode(authpair)\n\n        self.__timeout = timeout\n\n        if connection:\n            # Callables re-use the connection of the original proxy\n            self.__conn = connection\n        elif self.__url.scheme == 'https':\n            self.__conn = httplib.HTTPSConnection(self.__url.hostname, port,\n                                                  timeout=timeout)\n        else:\n            self.__conn = httplib.HTTPConnection(self.__url.hostname, port,\n                                                 timeout=timeout)",
  "def __getattr__(self, name):\n        if name.startswith('__') and name.endswith('__'):\n            # Python internal stuff\n            raise AttributeError\n        if self.__service_name is not None:\n            name = \"%s.%s\" % (self.__service_name, name)\n        return AuthServiceProxy(self.__service_url, name, self.__timeout, self.__conn)",
  "def __call__(self, *args):\n        AuthServiceProxy.__id_count += 1\n\n        log.info(\"-%s-> %s %s\" % (AuthServiceProxy.__id_count, self.__service_name,\n                                   json.dumps(args, default=EncodeDecimal)))\n        postdata = json.dumps({'version': '1.1',\n                               'method': self.__service_name,\n                               'params': args,\n                               'id': AuthServiceProxy.__id_count}, default=EncodeDecimal)\n        self.__conn.request('POST', self.__url.path, postdata,\n                            {'Host': self.__url.hostname,\n                             'User-Agent': USER_AGENT,\n                             'Authorization': self.__auth_header,\n                             'Content-type': 'application/json'})\n        self.__conn.sock.settimeout(self.__timeout)\n\n        response = self._get_response()\n        if response.get('error') is not None:\n            raise JSONRPCException(response['error'])\n        elif 'result' not in response:\n            raise JSONRPCException({\n                'code': -343, 'message': 'missing JSON-RPC result'})\n        self.__conn.close()\n        return response['result']",
  "def batch_(self, rpc_calls):\n        \"\"\"Batch RPC call.\n           Pass array of arrays: [ [ \"method\", params... ], ... ]\n           Returns array of results.\n        \"\"\"\n        batch_data = []\n        for rpc_call in rpc_calls:\n            AuthServiceProxy.__id_count += 1\n            m = rpc_call.pop(0)\n            batch_data.append({\"jsonrpc\": \"2.0\", \"method\": m, \"params\": rpc_call, \"id\": AuthServiceProxy.__id_count})\n\n        postdata = json.dumps(batch_data, default=EncodeDecimal)\n        log.debug(\"--> \" + postdata)\n        self.__conn.request('POST', self.__url.path, postdata,\n                            {'Host': self.__url.hostname,\n                             'User-Agent': USER_AGENT,\n                             'Authorization': self.__auth_header,\n                             'Content-type': 'application/json'})\n        results = []\n        responses = self._get_response()\n        for response in responses:\n            if response['error'] is not None:\n                raise JSONRPCException(response['error'])\n            elif 'result' not in response:\n                raise JSONRPCException({\n                    'code': -343, 'message': 'missing JSON-RPC result'})\n            else:\n                results.append(response['result'])\n        return results",
  "def _get_response(self):\n        http_response = self.__conn.getresponse()\n        if http_response is None:\n            raise JSONRPCException({\n                'code': -342, 'message': 'missing HTTP response from server'})\n\n        content_type = http_response.getheader('Content-Type')\n        if content_type != 'application/json':\n            raise JSONRPCException({\n                'code': -342, 'message': 'non-JSON HTTP response with \\'%i %s\\' from server' % (\n                http_response.status, http_response.reason)})\n\n        responsedata = http_response.read().decode('utf8')\n        response = json.loads(responsedata, parse_float=decimal.Decimal)\n        if \"error\" in response and response[\"error\"] is None:\n            log.debug(\"<-%s- %s\" % (response[\"id\"], json.dumps(response[\"result\"], default=EncodeDecimal)[:1000]))\n        else:\n            log.debug(\"<-- \" + responsedata[:1000])\n        return response",
  "class BitapsClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, command='', data='', variables=None, req_type='blockchain', method='get'):\n        url_path = req_type + '/' + category\n        if command:\n            url_path += '/' + command\n        if data:\n            if url_path[-1:] != '/':\n                url_path += '/'\n            url_path += data\n        return self.request(url_path, variables=variables, method=method)\n\n    def _parse_transaction(self, tx):\n        status = 'unconfirmed'\n        if tx['confirmations']:\n            status = 'confirmed'\n        date = None\n        if 'timestamp' in tx and tx['timestamp']:\n            date = datetime.utcfromtimestamp(tx['timestamp'])\n        elif 'blockTime' in tx and tx['blockTime']:\n            date = datetime.utcfromtimestamp(tx['blockTime'])\n        block_height = None\n        if 'blockHeight' in tx:\n            block_height = tx['blockHeight']\n        witness_type = 'legacy'\n        if tx['segwit']:\n            witness_type = 'segwit'\n\n        t = Transaction(\n            locktime=tx['lockTime'], version=tx['version'], network=self.network, fee=tx['fee'],\n            fee_per_kb=None if 'feeRate' not in tx else int(tx['feeRate']), size=tx['size'],\n            txid=tx['txId'], date=date, confirmations=tx['confirmations'], block_height=block_height,\n            input_total=tx['inputsAmount'], output_total=tx['outputsAmount'], status=status, coinbase=tx['coinbase'],\n            verified=None if 'valid' not in tx else tx['valid'], witness_type=witness_type)\n\n        for n, ti in tx['vIn'].items():\n            if t.coinbase:\n                t.add_input(prev_txid=ti['txId'], output_n=ti['vOut'], unlocking_script=ti['scriptSig'],\n                            sequence=ti['sequence'], index_n=int(n), value=0)\n            else:\n                t.add_input(prev_txid=ti['txId'], output_n=ti['vOut'], unlocking_script=ti['scriptSig'],\n                            unlocking_script_unsigned=ti['scriptPubKey'], witnesses=ti.get('txInWitness', []),\n                            address='' if 'address' not in ti else ti['address'], sequence=ti['sequence'],\n                            index_n=int(n), value=ti['amount'], strict=self.strict)\n\n        for _, to in tx['vOut'].items():\n            spending_txid = None if not to['spent'] else to['spent'][0]['txId']\n            spending_index_n = None if not to['spent'] else to['spent'][0]['vIn']\n            t.add_output(to['value'], '' if 'address' not in to else to['address'],\n                         '' if 'addressHash' not in to else to['addressHash'], lock_script=to['scriptPubKey'],\n                         spent=bool(to['spent']), spending_txid=spending_txid, spending_index_n=spending_index_n,\n                         strict=self.strict)\n\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', 'state', address)\n            balance += res['data']['balance']\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        page = 1\n        while True:\n            variables = {'mode': 'verbose', 'limit': 50, 'page': page, 'order': 'asc'}\n            try:\n                res = self.compose_request('address', 'transactions', address, variables)\n                res2 = self.compose_request('address', 'unconfirmed/transactions', address, variables)\n            except ClientError as e:\n                if \"address not found\" in self.resp.text:\n                    return []\n                else:\n                    raise ClientError(e.msg)\n            txs = res['data']['list']\n            txs += res2['data']['list']\n            for tx in txs:\n                for outp in tx['vOut']:\n                    utxo = tx['vOut'][outp]\n                    if 'address' not in utxo or utxo['address'] != address or utxo['spent']:\n                        continue\n                    utxos.append(\n                        {\n                            'address': utxo['address'],\n                            'txid': tx['txId'],\n                            'confirmations': 0 if 'confirmations' not in tx else tx['confirmations'],\n                            'output_n': int(outp),\n                            'input_n': 0,\n                            'block_height': None if 'blockHeight' not in tx else tx['blockHeight'],\n                            'fee': None,\n                            'size': 0,\n                            'value': utxo['value'],\n                            'script': utxo['scriptPubKey'],\n                            'date': datetime.utcfromtimestamp(tx['timestamp'])\n                         }\n                    )\n                if tx['txId'] == after_txid:\n                    utxos = []\n            page += 1\n            if page > res['data']['pages']:\n                break\n        return utxos[:limit]\n\n    def gettransaction(self, txid):\n        res = self.compose_request('transaction', txid)\n        return self._parse_transaction(res['data'])\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        page = 0\n        txs = []\n        while True:\n            variables = {'mode': 'verbose', 'limit': MAX_TRANSACTIONS, 'page': page, 'order': 'asc'}\n            try:\n                res = self.compose_request('address', 'transactions', address, variables)\n            except ClientError:\n                if \"address not found\" in self.resp.text:\n                    return []\n            for tx in res['data']['list']:\n                txs.append(self._parse_transaction(tx))\n                if tx['txId'] == after_txid:\n                    txs = []\n            if len(txs) > limit:\n                break\n            page += 1\n            if page >= res['data']['pages']:\n                break\n        return txs[:limit]\n\n    # def getrawtransaction(self, txid):\n    #     tx = self.compose_request('transaction', txid)\n    #     return tx['data']['rawTx']\n\n    # def sendrawtransaction\n\n    # def estimatefee\n\n    def blockcount(self):\n        return self.compose_request('block', 'last')['data']['height']",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, command='', data='', variables=None, req_type='blockchain', method='get'):\n        url_path = req_type + '/' + category\n        if command:\n            url_path += '/' + command\n        if data:\n            if url_path[-1:] != '/':\n                url_path += '/'\n            url_path += data\n        return self.request(url_path, variables=variables, method=method)",
  "def _parse_transaction(self, tx):\n        status = 'unconfirmed'\n        if tx['confirmations']:\n            status = 'confirmed'\n        date = None\n        if 'timestamp' in tx and tx['timestamp']:\n            date = datetime.utcfromtimestamp(tx['timestamp'])\n        elif 'blockTime' in tx and tx['blockTime']:\n            date = datetime.utcfromtimestamp(tx['blockTime'])\n        block_height = None\n        if 'blockHeight' in tx:\n            block_height = tx['blockHeight']\n        witness_type = 'legacy'\n        if tx['segwit']:\n            witness_type = 'segwit'\n\n        t = Transaction(\n            locktime=tx['lockTime'], version=tx['version'], network=self.network, fee=tx['fee'],\n            fee_per_kb=None if 'feeRate' not in tx else int(tx['feeRate']), size=tx['size'],\n            txid=tx['txId'], date=date, confirmations=tx['confirmations'], block_height=block_height,\n            input_total=tx['inputsAmount'], output_total=tx['outputsAmount'], status=status, coinbase=tx['coinbase'],\n            verified=None if 'valid' not in tx else tx['valid'], witness_type=witness_type)\n\n        for n, ti in tx['vIn'].items():\n            if t.coinbase:\n                t.add_input(prev_txid=ti['txId'], output_n=ti['vOut'], unlocking_script=ti['scriptSig'],\n                            sequence=ti['sequence'], index_n=int(n), value=0)\n            else:\n                t.add_input(prev_txid=ti['txId'], output_n=ti['vOut'], unlocking_script=ti['scriptSig'],\n                            unlocking_script_unsigned=ti['scriptPubKey'], witnesses=ti.get('txInWitness', []),\n                            address='' if 'address' not in ti else ti['address'], sequence=ti['sequence'],\n                            index_n=int(n), value=ti['amount'], strict=self.strict)\n\n        for _, to in tx['vOut'].items():\n            spending_txid = None if not to['spent'] else to['spent'][0]['txId']\n            spending_index_n = None if not to['spent'] else to['spent'][0]['vIn']\n            t.add_output(to['value'], '' if 'address' not in to else to['address'],\n                         '' if 'addressHash' not in to else to['addressHash'], lock_script=to['scriptPubKey'],\n                         spent=bool(to['spent']), spending_txid=spending_txid, spending_index_n=spending_index_n,\n                         strict=self.strict)\n\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', 'state', address)\n            balance += res['data']['balance']\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        page = 1\n        while True:\n            variables = {'mode': 'verbose', 'limit': 50, 'page': page, 'order': 'asc'}\n            try:\n                res = self.compose_request('address', 'transactions', address, variables)\n                res2 = self.compose_request('address', 'unconfirmed/transactions', address, variables)\n            except ClientError as e:\n                if \"address not found\" in self.resp.text:\n                    return []\n                else:\n                    raise ClientError(e.msg)\n            txs = res['data']['list']\n            txs += res2['data']['list']\n            for tx in txs:\n                for outp in tx['vOut']:\n                    utxo = tx['vOut'][outp]\n                    if 'address' not in utxo or utxo['address'] != address or utxo['spent']:\n                        continue\n                    utxos.append(\n                        {\n                            'address': utxo['address'],\n                            'txid': tx['txId'],\n                            'confirmations': 0 if 'confirmations' not in tx else tx['confirmations'],\n                            'output_n': int(outp),\n                            'input_n': 0,\n                            'block_height': None if 'blockHeight' not in tx else tx['blockHeight'],\n                            'fee': None,\n                            'size': 0,\n                            'value': utxo['value'],\n                            'script': utxo['scriptPubKey'],\n                            'date': datetime.utcfromtimestamp(tx['timestamp'])\n                         }\n                    )\n                if tx['txId'] == after_txid:\n                    utxos = []\n            page += 1\n            if page > res['data']['pages']:\n                break\n        return utxos[:limit]",
  "def gettransaction(self, txid):\n        res = self.compose_request('transaction', txid)\n        return self._parse_transaction(res['data'])",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        page = 0\n        txs = []\n        while True:\n            variables = {'mode': 'verbose', 'limit': MAX_TRANSACTIONS, 'page': page, 'order': 'asc'}\n            try:\n                res = self.compose_request('address', 'transactions', address, variables)\n            except ClientError:\n                if \"address not found\" in self.resp.text:\n                    return []\n            for tx in res['data']['list']:\n                txs.append(self._parse_transaction(tx))\n                if tx['txId'] == after_txid:\n                    txs = []\n            if len(txs) > limit:\n                break\n            page += 1\n            if page >= res['data']['pages']:\n                break\n        return txs[:limit]",
  "def blockcount(self):\n        return self.compose_request('block', 'last')['data']['height']",
  "class BlockbookClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, data, cmd='', variables=None, method='get'):\n        url_path = category\n        if data:\n            url_path += '/' + data + ('' if not cmd else '/' + cmd)\n        if variables is None:\n            variables = {}\n        return self.request(url_path, variables, method=method)\n\n    def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        txdate = datetime.utcfromtimestamp(tx['blockTime'])\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.input_total = int(tx['valueIn'])\n        t.output_total = int(tx['value'])\n        t.fee = int(tx['fees'])\n        t.date = txdate if tx['confirmations'] else None\n        t.confirmations = tx['confirmations']\n        t.block_height = None if tx['blockHeight'] == -1 else tx['blockHeight']\n        t.block_hash = tx.get('blockHash', '')\n        t.status = status\n        for n, ti in enumerate(tx['vin']):\n            t.inputs[n].value = int(ti.get('value', 0))\n        for i, to in enumerate(tx['vout']):\n            t.outputs[i].spent = to.get('spent', False)\n        return t\n\n    def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('address', a.address)\n            balance += int(res['balance'])\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('utxo', address.address)\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx.get('height', 0),\n                'fee': None,\n                'size': 0,\n                'value': int(tx['value']),\n                'script': tx.get('scriptPubKey', ''),\n                'date': None\n            })\n        return txs[::-1][:limit]\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._convert_to_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('address', address.address, variables={'details': 'txs'})\n        if 'transactions' not in res:\n            return []\n        txs = []\n        txs_dict = res['transactions'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs\n\n    def getrawtransaction(self, txid):\n        res = self.compose_request('tx', txid)\n        return res['hex']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('sendtx', data=rawtx)\n        return {\n            'txid': res.get('result', None),\n            'error': None if \"error\" not in res else res['error']['message'],\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        res = self.compose_request('estimatefee', str(int(blocks)+1))\n        return int(float(res['result']) / self.network.denominator)\n\n    def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['blockbook']['bestHeight']\n\n    def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for tx in bd['txs'][(page-1)*limit:page*limit]:\n                txs.append(self.gettransaction(tx['txid']))\n        else:\n            txs = [tx['txid'] for tx in bd['txs']]\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleRoot'],\n            'nonce': int(bd['nonce']),\n            'prev_block': bd['previousBlockHash'],\n            'time': bd['time'],\n            'tx_count': bd['txCount'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['txs']) // limit) + (len(bd['txs']) % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    # def getrawblock(self, blockid):\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0\n\n    def getinfo(self):\n        info = self.compose_request('status', '')\n        return {\n            'blockcount': info['backend']['blocks'],\n            'chain': info['backend']['chain'],\n            'difficulty': int(float(info['backend']['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': info['blockbook']['mempoolSize'],\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, data, cmd='', variables=None, method='get'):\n        url_path = category\n        if data:\n            url_path += '/' + data + ('' if not cmd else '/' + cmd)\n        if variables is None:\n            variables = {}\n        return self.request(url_path, variables, method=method)",
  "def _convert_to_transaction(self, tx):\n        if tx['confirmations']:\n            status = 'confirmed'\n        else:\n            status = 'unconfirmed'\n        txdate = datetime.utcfromtimestamp(tx['blockTime'])\n        t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n        t.input_total = int(tx['valueIn'])\n        t.output_total = int(tx['value'])\n        t.fee = int(tx['fees'])\n        t.date = txdate if tx['confirmations'] else None\n        t.confirmations = tx['confirmations']\n        t.block_height = None if tx['blockHeight'] == -1 else tx['blockHeight']\n        t.block_hash = tx.get('blockHash', '')\n        t.status = status\n        for n, ti in enumerate(tx['vin']):\n            t.inputs[n].value = int(ti.get('value', 0))\n        for i, to in enumerate(tx['vout']):\n            t.outputs[i].spent = to.get('spent', False)\n        return t",
  "def getbalance(self, addresslist):\n        balance = 0\n        addresslist = self._addresslist_convert(addresslist)\n        for a in addresslist:\n            res = self.compose_request('address', a.address)\n            balance += int(res['balance'])\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('utxo', address.address)\n        txs = []\n        for tx in res:\n            if tx['txid'] == after_txid:\n                break\n            txs.append({\n                'address': address.address_orig,\n                'txid': tx['txid'],\n                'confirmations': tx['confirmations'],\n                'output_n': tx['vout'],\n                'input_n': 0,\n                'block_height': tx.get('height', 0),\n                'fee': None,\n                'size': 0,\n                'value': int(tx['value']),\n                'script': tx.get('scriptPubKey', ''),\n                'date': None\n            })\n        return txs[::-1][:limit]",
  "def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._convert_to_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        address = self._address_convert(address)\n        res = self.compose_request('address', address.address, variables={'details': 'txs'})\n        if 'transactions' not in res:\n            return []\n        txs = []\n        txs_dict = res['transactions'][::-1]\n        if after_txid:\n            txs_dict = txs_dict[[t['txid'] for t in txs_dict].index(after_txid) + 1:]\n        for tx in txs_dict[:limit]:\n            if tx['txid'] == after_txid:\n                break\n            txs.append(self._convert_to_transaction(tx))\n        return txs",
  "def getrawtransaction(self, txid):\n        res = self.compose_request('tx', txid)\n        return res['hex']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('sendtx', data=rawtx)\n        return {\n            'txid': res.get('result', None),\n            'error': None if \"error\" not in res else res['error']['message'],\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        res = self.compose_request('estimatefee', str(int(blocks)+1))\n        return int(float(res['result']) / self.network.denominator)",
  "def blockcount(self):\n        res = self.compose_request('status', '', variables={'q': 'getinfo'})\n        return res['blockbook']['bestHeight']",
  "def mempool(self, txid):\n        res = self.compose_request('tx', txid)\n        if res['confirmations'] == 0:\n            return res['txid']\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        bd = self.compose_request('block', str(blockid))\n        if parse_transactions:\n            txs = []\n            for tx in bd['txs'][(page-1)*limit:page*limit]:\n                txs.append(self.gettransaction(tx['txid']))\n        else:\n            txs = [tx['txid'] for tx in bd['txs']]\n\n        block = {\n            'bits': int(bd['bits'], 16),\n            'depth': bd['confirmations'],\n            'block_hash': bd['hash'],\n            'height': bd['height'],\n            'merkle_root': bd['merkleRoot'],\n            'nonce': int(bd['nonce']),\n            'prev_block': bd['previousBlockHash'],\n            'time': bd['time'],\n            'tx_count': bd['txCount'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(len(bd['txs']) // limit) + (len(bd['txs']) % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def getinfo(self):\n        info = self.compose_request('status', '')\n        return {\n            'blockcount': info['backend']['blocks'],\n            'chain': info['backend']['chain'],\n            'difficulty': int(float(info['backend']['difficulty'])),\n            'hashrate': 0,\n            'mempool_size': info['blockbook']['mempoolSize'],\n        }",
  "class BlockChairClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, command, query_vars=None, variables=None, data=None, offset=0, limit=REQUEST_LIMIT,\n                        method='get'):\n        url_path = ''\n        if not variables:\n            variables = {}\n        if command not in ['stats', 'mempool']:\n            variables.update({'limit': limit})\n        if offset:\n            variables.update({'offset': offset})\n        if command:\n            url_path += command\n        if data:\n            if url_path[-1:] != '/':\n                url_path += '/'\n            url_path += data\n        if query_vars:\n            varstr = ','.join(['%s(%s)' % (qv, query_vars[qv]) for qv in query_vars])\n            variables.update({'q': varstr})\n        return self.request(url_path, variables, method=method)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('dashboards/address/', data=address)\n            balance += int(res['data'][address]['address']['balance'])\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        offset = 0\n        while True:\n            res = self.compose_request('outputs', {'recipient': address, 'is_spent': 'false'}, offset=offset)\n            if len(res['data']) == REQUEST_LIMIT:\n                raise ClientError(\"Blockchair returned more then maximum of %d data rows\" % REQUEST_LIMIT)\n            current_block = res['context']['state']\n            for utxo in res['data'][::-1]:\n                if utxo['is_spent']:\n                    continue\n                if utxo['transaction_hash'] == after_txid:\n                    utxos = []\n                    continue\n                utxos.append({\n                    'address': address,\n                    'txid': utxo['transaction_hash'],\n                    'confirmations': current_block - utxo['block_id'],\n                    'output_n': utxo['index'],\n                    'input_n': 0,\n                    'block_height': utxo['block_id'],\n                    'fee': None,\n                    'size': 0,\n                    'value': utxo['value'],\n                    'script': utxo['script_hex'],\n                    'date': datetime.strptime(utxo['time'], \"%Y-%m-%d %H:%M:%S\")\n                })\n            if not len(res['data']) or len(res['data']) < REQUEST_LIMIT:\n                break\n            offset += REQUEST_LIMIT\n        return utxos[:limit]\n\n    def gettransaction(self, tx_id):\n        res = self.compose_request('dashboards/transaction/', data=tx_id)\n\n        tx = res['data'][tx_id]['transaction']\n        confirmations = 0 if tx['block_id'] <= 0 else res['context']['state'] - tx['block_id']\n        status = 'unconfirmed'\n        if confirmations:\n            status = 'confirmed'\n        witness_type = 'legacy'\n        if tx['has_witness']:\n            witness_type = 'segwit'\n        input_total = tx['input_total']\n        t = Transaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,\n                        fee=tx['fee'], size=tx['size'], txid=tx['hash'],\n                        date=None if not confirmations else datetime.strptime(tx['time'], \"%Y-%m-%d %H:%M:%S\"),\n                        confirmations=confirmations, block_height=tx['block_id'] if tx['block_id'] > 0 else None,\n                        status=status, input_total=input_total, coinbase=tx['is_coinbase'],\n                        output_total=tx['output_total'], witness_type=witness_type)\n        index_n = 0\n        if not res['data'][tx_id]['inputs']:\n            # This is a coinbase transaction, add input\n            t.add_input(prev_txid=b'\\00' * 32, output_n=0, value=0)\n\n        for ti in res['data'][tx_id]['inputs']:\n            if ti['spending_witness']:\n                # witnesses = b\"\".join([varstr(bytes.fromhex(x)) for x in ti['spending_witness'].split(\",\")])\n                witnesses = ti['spending_witness'].split(\",\")\n                address = Address.parse(ti['recipient'])\n                if address.script_type == 'p2sh':\n                    witness_type = 'p2sh-segwit'\n                else:\n                    witness_type = 'segwit'\n                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],\n                            unlocking_script=ti['spending_signature_hex'],\n                            witnesses=witnesses, index_n=index_n, value=ti['value'],\n                            address=address, witness_type=witness_type, sequence=ti['spending_sequence'], strict=self.strict)\n            else:\n                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],\n                            unlocking_script=ti['spending_signature_hex'], index_n=index_n, value=ti['value'],\n                            address=ti['recipient'], unlocking_script_unsigned=ti['script_hex'],\n                            sequence=ti['spending_sequence'], strict=self.strict)\n            index_n += 1\n        for to in res['data'][tx_id]['outputs']:\n            try:\n                deserialize_address(to['recipient'], network=self.network.name)\n                addr = to['recipient']\n            except EncodingError:\n                addr = ''\n            t.add_output(value=to['value'], address=addr, lock_script=to['script_hex'],\n                         spent=to['is_spent'], output_n=to['index'], spending_txid=to['spending_transaction_hash'],\n                         spending_index_n=to['spending_index'], strict=self.strict)\n        return t\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txids = []\n        offset = 0\n        while True:\n            res = self.compose_request('dashboards/address/', data=address, offset=offset)\n            addr = res['data'][address]\n            if not addr['transactions']:\n                break\n            txids = addr['transactions'][::-1] + txids\n            offset += 50\n            if len(txids) > limit:\n                break\n        if after_txid:\n            txids = txids[txids.index(after_txid)+1:]\n        txs = []\n        for txid in txids[:limit]:\n            txs.append(self.gettransaction(txid))\n        return txs\n\n    def getrawtransaction(self, txid):\n        res = self.compose_request('raw/transaction', data=txid)\n        return res['data'][txid]['raw_transaction']\n\n    def sendrawtransaction(self, rawtx):\n        res = self.compose_request('push/transaction', variables={'data': rawtx}, method='post')\n        return {\n            'txid': res['data']['transaction_hash'],\n            'response_dict': res\n        }\n\n    def estimatefee(self, blocks):\n        return self.compose_request('stats')['data']['suggested_transaction_fee_per_byte_sat'] * 1000\n\n    def blockcount(self):\n        \"\"\"\n        Get latest block number: The block number of last block in longest chain on the blockchain\n\n        :return int:\n        \"\"\"\n        res = self.compose_request('stats')\n        return res['context']['state']\n\n    def mempool(self, txid=''):\n        if txid:\n            res = self.compose_request('mempool', {'hash': txid}, data='transactions')\n        else:\n            res = self.compose_request('mempool', data='transactions')\n        return [tx['hash'] for tx in res['data'] if 'hash' in tx]\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 100:\n            limit = 100\n        res = self.compose_request('dashboards/block/', data=str(blockid), offset=(page-1)*limit, limit=limit)\n        bd = res['data'][str(blockid)]['block']\n        txids = res['data'][str(blockid)]['transactions']\n        if parse_transactions:\n            txs = []\n            for txid in txids:\n                txs.append(self.gettransaction(txid))\n        else:\n            txs = txids\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['hash'],\n            'height': bd['id'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': b'',\n            'time': int(datetime.strptime(bd['time'], \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=timezone.utc).timestamp()),\n            'tx_count': bd['transaction_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['transaction_count'] // limit) + (bd['transaction_count'] % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        res = self.compose_request('raw/block/', data=str(blockid))\n        rb = res['data'][str(blockid)]['raw_block']\n        return rb\n\n    def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0\n\n    def getinfo(self):\n        info = self.compose_request('stats')['data']\n        return {\n            'blockcount': info['best_block_height'],\n            'chain': '',\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': int(info['hashrate_24h']),\n            'mempool_size': int(info['mempool_transactions']),\n        }",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, command, query_vars=None, variables=None, data=None, offset=0, limit=REQUEST_LIMIT,\n                        method='get'):\n        url_path = ''\n        if not variables:\n            variables = {}\n        if command not in ['stats', 'mempool']:\n            variables.update({'limit': limit})\n        if offset:\n            variables.update({'offset': offset})\n        if command:\n            url_path += command\n        if data:\n            if url_path[-1:] != '/':\n                url_path += '/'\n            url_path += data\n        if query_vars:\n            varstr = ','.join(['%s(%s)' % (qv, query_vars[qv]) for qv in query_vars])\n            variables.update({'q': varstr})\n        return self.request(url_path, variables, method=method)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('dashboards/address/', data=address)\n            balance += int(res['data'][address]['address']['balance'])\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        offset = 0\n        while True:\n            res = self.compose_request('outputs', {'recipient': address, 'is_spent': 'false'}, offset=offset)\n            if len(res['data']) == REQUEST_LIMIT:\n                raise ClientError(\"Blockchair returned more then maximum of %d data rows\" % REQUEST_LIMIT)\n            current_block = res['context']['state']\n            for utxo in res['data'][::-1]:\n                if utxo['is_spent']:\n                    continue\n                if utxo['transaction_hash'] == after_txid:\n                    utxos = []\n                    continue\n                utxos.append({\n                    'address': address,\n                    'txid': utxo['transaction_hash'],\n                    'confirmations': current_block - utxo['block_id'],\n                    'output_n': utxo['index'],\n                    'input_n': 0,\n                    'block_height': utxo['block_id'],\n                    'fee': None,\n                    'size': 0,\n                    'value': utxo['value'],\n                    'script': utxo['script_hex'],\n                    'date': datetime.strptime(utxo['time'], \"%Y-%m-%d %H:%M:%S\")\n                })\n            if not len(res['data']) or len(res['data']) < REQUEST_LIMIT:\n                break\n            offset += REQUEST_LIMIT\n        return utxos[:limit]",
  "def gettransaction(self, tx_id):\n        res = self.compose_request('dashboards/transaction/', data=tx_id)\n\n        tx = res['data'][tx_id]['transaction']\n        confirmations = 0 if tx['block_id'] <= 0 else res['context']['state'] - tx['block_id']\n        status = 'unconfirmed'\n        if confirmations:\n            status = 'confirmed'\n        witness_type = 'legacy'\n        if tx['has_witness']:\n            witness_type = 'segwit'\n        input_total = tx['input_total']\n        t = Transaction(locktime=tx['lock_time'], version=tx['version'], network=self.network,\n                        fee=tx['fee'], size=tx['size'], txid=tx['hash'],\n                        date=None if not confirmations else datetime.strptime(tx['time'], \"%Y-%m-%d %H:%M:%S\"),\n                        confirmations=confirmations, block_height=tx['block_id'] if tx['block_id'] > 0 else None,\n                        status=status, input_total=input_total, coinbase=tx['is_coinbase'],\n                        output_total=tx['output_total'], witness_type=witness_type)\n        index_n = 0\n        if not res['data'][tx_id]['inputs']:\n            # This is a coinbase transaction, add input\n            t.add_input(prev_txid=b'\\00' * 32, output_n=0, value=0)\n\n        for ti in res['data'][tx_id]['inputs']:\n            if ti['spending_witness']:\n                # witnesses = b\"\".join([varstr(bytes.fromhex(x)) for x in ti['spending_witness'].split(\",\")])\n                witnesses = ti['spending_witness'].split(\",\")\n                address = Address.parse(ti['recipient'])\n                if address.script_type == 'p2sh':\n                    witness_type = 'p2sh-segwit'\n                else:\n                    witness_type = 'segwit'\n                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],\n                            unlocking_script=ti['spending_signature_hex'],\n                            witnesses=witnesses, index_n=index_n, value=ti['value'],\n                            address=address, witness_type=witness_type, sequence=ti['spending_sequence'], strict=self.strict)\n            else:\n                t.add_input(prev_txid=ti['transaction_hash'], output_n=ti['index'],\n                            unlocking_script=ti['spending_signature_hex'], index_n=index_n, value=ti['value'],\n                            address=ti['recipient'], unlocking_script_unsigned=ti['script_hex'],\n                            sequence=ti['spending_sequence'], strict=self.strict)\n            index_n += 1\n        for to in res['data'][tx_id]['outputs']:\n            try:\n                deserialize_address(to['recipient'], network=self.network.name)\n                addr = to['recipient']\n            except EncodingError:\n                addr = ''\n            t.add_output(value=to['value'], address=addr, lock_script=to['script_hex'],\n                         spent=to['is_spent'], output_n=to['index'], spending_txid=to['spending_transaction_hash'],\n                         spending_index_n=to['spending_index'], strict=self.strict)\n        return t",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        txids = []\n        offset = 0\n        while True:\n            res = self.compose_request('dashboards/address/', data=address, offset=offset)\n            addr = res['data'][address]\n            if not addr['transactions']:\n                break\n            txids = addr['transactions'][::-1] + txids\n            offset += 50\n            if len(txids) > limit:\n                break\n        if after_txid:\n            txids = txids[txids.index(after_txid)+1:]\n        txs = []\n        for txid in txids[:limit]:\n            txs.append(self.gettransaction(txid))\n        return txs",
  "def getrawtransaction(self, txid):\n        res = self.compose_request('raw/transaction', data=txid)\n        return res['data'][txid]['raw_transaction']",
  "def sendrawtransaction(self, rawtx):\n        res = self.compose_request('push/transaction', variables={'data': rawtx}, method='post')\n        return {\n            'txid': res['data']['transaction_hash'],\n            'response_dict': res\n        }",
  "def estimatefee(self, blocks):\n        return self.compose_request('stats')['data']['suggested_transaction_fee_per_byte_sat'] * 1000",
  "def blockcount(self):\n        \"\"\"\n        Get latest block number: The block number of last block in longest chain on the blockchain\n\n        :return int:\n        \"\"\"\n        res = self.compose_request('stats')\n        return res['context']['state']",
  "def mempool(self, txid=''):\n        if txid:\n            res = self.compose_request('mempool', {'hash': txid}, data='transactions')\n        else:\n            res = self.compose_request('mempool', data='transactions')\n        return [tx['hash'] for tx in res['data'] if 'hash' in tx]",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if limit > 100:\n            limit = 100\n        res = self.compose_request('dashboards/block/', data=str(blockid), offset=(page-1)*limit, limit=limit)\n        bd = res['data'][str(blockid)]['block']\n        txids = res['data'][str(blockid)]['transactions']\n        if parse_transactions:\n            txs = []\n            for txid in txids:\n                txs.append(self.gettransaction(txid))\n        else:\n            txs = txids\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['hash'],\n            'height': bd['id'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': b'',\n            'time': int(datetime.strptime(bd['time'], \"%Y-%m-%d %H:%M:%S\").replace(tzinfo=timezone.utc).timestamp()),\n            'tx_count': bd['transaction_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['transaction_count'] // limit) + (bd['transaction_count'] % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        res = self.compose_request('raw/block/', data=str(blockid))\n        rb = res['data'][str(blockid)]['raw_block']\n        return rb",
  "def isspent(self, txid, output_n):\n        t = self.gettransaction(txid)\n        return 1 if t.outputs[output_n].spent else 0",
  "def getinfo(self):\n        info = self.compose_request('stats')['data']\n        return {\n            'blockcount': info['best_block_height'],\n            'chain': '',\n            'difficulty': int(float(info['difficulty'])),\n            'hashrate': int(info['hashrate_24h']),\n            'mempool_size': int(info['mempool_transactions']),\n        }",
  "class BitGoClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, category, data, cmd='', variables=None, method='get'):\n        if data:\n            data = '/' + data\n        url_path = category + data\n        if cmd != '':\n            url_path += '/' + cmd\n        return self.request(url_path, variables, method=method)\n\n    # def getbalance(self, addresslist):\n    #     balance = 0\n    #     for address in addresslist:\n    #         res = self.compose_request('address', address)\n    #         balance += res['balance']\n    #     return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        skip = 0\n        total = 1\n        while total > skip:\n            variables = {'limit': 100, 'skip': skip}\n            res = self.compose_request('address', address, 'unspents', variables)\n            for utxo in res['unspents'][::-1]:\n                if utxo['tx_hash'] == after_txid:\n                    break\n                utxos.append(\n                    {\n                        'address': utxo['address'],\n                        'txid': utxo['tx_hash'],\n                        'confirmations': utxo['confirmations'],\n                        'output_n': utxo['tx_output_n'],\n                        'input_n': 0,\n                        'block_height': int(utxo['blockHeight']) if utxo['blockHeight'] else None,\n                        'fee': None,\n                        'size': 0,\n                        'value': int(round(utxo['value'] * self.units, 0)),\n                        'script': utxo['script'],\n                        'date': datetime.strptime(utxo['date'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n                     }\n                )\n            total = res['total']\n            skip = res['start'] + res['count']\n            if skip > 2000:\n                _logger.info(\"BitGoClient: UTXO's list has been truncated, list is incomplete\")\n                break\n        return utxos[::-1][:limit]\n\n    # RAW TRANSACTION DOES NOT CONTAIN CORRECT RAW TRANSACTION (MISSING SIGS)\n    # def gettransaction(self, txid):\n    #     tx = self.compose_request('tx', txid)\n    #     t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n    #     t.status = 'unconfirmed'\n    #     t.date = None\n    #     if tx['confirmations']:\n    #         t.status = 'confirmed'\n    #         t.date = datetime.strptime(tx['date'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n    #     t.confirmations = tx['confirmations']\n    #     if 'height' in tx:\n    #         t.block_height = tx['height']\n    #         t.block_hash = tx['blockhash']\n    #     t.fee = tx['fee']\n    #     t.rawtx = to_bytes(tx['hex'])\n    #     t.size = len(tx['hex']) // 2\n    #     t.network = self.network\n    #     if t.coinbase:\n    #         input_values = []\n    #         t.input_total = t.output_total\n    #     else:\n    #         input_values = [(inp['account'], -inp['value']) for inp in tx['entries'] if inp['value'] < 0]\n    #         if len(input_values) >= 49:\n    #             raise ClientError(\"More then 49 transaction inputs not supported by bitgo\")\n    #         t.input_total = sum([x[1] for x in input_values])\n    #     for i in t.inputs:\n    #         if not i.address and not t.coinbase:\n    #             raise ClientError(\"Address missing in input. Provider might not support segwit transactions\")\n    #         if len(t.inputs) != len(input_values):\n    #             i.value = None\n    #             continue\n    #         value = [x[1] for x in input_values if x[0] == i.address]\n    #         if len(value) != 1:\n    #             _logger.info(\"BitGoClient: Address %s input value should be found exactly 1 times in value list\" %\n    #                             i.address)\n    #             i.value = None\n    #         else:\n    #             i.value = value[0]\n    #     for o in t.outputs:\n    #         o.spent = None\n    #     if t.input_total != t.output_total + t.fee:\n    #         t.input_total = t.output_total + t.fee\n    #     return t\n\n    # RAW TRANSACTION DOES NOT CONTAIN CORRECT RAW TRANSACTION (MISSING SIGS)\n    # def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n    #     txs = []\n    #     txids = []\n    #     skip = 0\n    #     total = 1\n    #     while total > skip:\n    #         variables = {'limit': LIMIT_TX, 'skip': skip}\n    #         res = self.compose_request('address', address, 'tx', variables)\n    #         for tx in res['transactions']:\n    #             if tx['id'] not in txids:\n    #                 txids.insert(0, tx['id'])\n    #         total = res['total']\n    #         # if total > 2000:\n    #         #     raise ClientError(\"BitGoClient: Transactions list limit exceeded > 2000\")\n    #         skip = res['start'] + res['count']\n    #         if len(txids) > limit:\n    #             break\n    #     if after_txid:\n    #         txids = txids[txids.index(after_txid) + 1:]\n    #     for txid in txids[:limit]:\n    #         txs.append(self.gettransaction(txid))\n    #     return txs\n\n    # RAW TRANSACTION DOES NOT CONTAIN CORRECT RAW TRANSACTION (MISSING SIGS)\n    # def getrawtransaction(self, txid):\n    #     tx = self.compose_request('tx', txid)\n    #     t = Transaction.parse_hex(tx['hex'], strict=self.strict, network=self.network)\n    #     for i in t.inputs:\n    #         if not i.address:\n    #             raise ClientError(\"Address missing in input. Provider might not support segwit transactions\")\n    #     return tx['hex']\n\n    # def sendrawtransaction\n\n    def estimatefee(self, blocks):\n        res = self.compose_request('tx', 'fee', variables={'numBlocks': blocks})\n        return res['feePerKb']\n\n    def blockcount(self):\n        return self.compose_request('block', 'latest')['height']",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, category, data, cmd='', variables=None, method='get'):\n        if data:\n            data = '/' + data\n        url_path = category + data\n        if cmd != '':\n            url_path += '/' + cmd\n        return self.request(url_path, variables, method=method)",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        utxos = []\n        skip = 0\n        total = 1\n        while total > skip:\n            variables = {'limit': 100, 'skip': skip}\n            res = self.compose_request('address', address, 'unspents', variables)\n            for utxo in res['unspents'][::-1]:\n                if utxo['tx_hash'] == after_txid:\n                    break\n                utxos.append(\n                    {\n                        'address': utxo['address'],\n                        'txid': utxo['tx_hash'],\n                        'confirmations': utxo['confirmations'],\n                        'output_n': utxo['tx_output_n'],\n                        'input_n': 0,\n                        'block_height': int(utxo['blockHeight']) if utxo['blockHeight'] else None,\n                        'fee': None,\n                        'size': 0,\n                        'value': int(round(utxo['value'] * self.units, 0)),\n                        'script': utxo['script'],\n                        'date': datetime.strptime(utxo['date'], \"%Y-%m-%dT%H:%M:%S.%fZ\")\n                     }\n                )\n            total = res['total']\n            skip = res['start'] + res['count']\n            if skip > 2000:\n                _logger.info(\"BitGoClient: UTXO's list has been truncated, list is incomplete\")\n                break\n        return utxos[::-1][:limit]",
  "def estimatefee(self, blocks):\n        res = self.compose_request('tx', 'fee', variables={'numBlocks': blocks})\n        return res['feePerKb']",
  "def blockcount(self):\n        return self.compose_request('block', 'latest')['height']",
  "class MempoolClient(BaseClient):\n\n    def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)\n\n    def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='',\n                        method='get'):\n        url_path = function\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if parameter2:\n            url_path += '/' + parameter2\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)\n\n    def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', address)\n            balance += res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum']\n        return balance\n\n    def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        res = self.compose_request('address', address, 'utxo')\n        utxos = []\n        # # key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True\n        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])\n        for a in res:\n            confirmations = 0\n            block_height = None\n            if 'block_height' in a['status']:\n                block_height = a['status']['block_height']\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': a['txid'],\n                'confirmations': confirmations,\n                'output_n': a['vout'],\n                'input_n': 0,\n                'block_height': block_height,\n                'fee': None,\n                'size': 0,\n                'value': a['value'],\n                'script': '',\n                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])\n            })\n            if a['txid'] == after_txid:\n                utxos = []\n        return utxos[:limit]\n\n    def _parse_transaction(self, tx):\n        block_height = None if 'block_height' not in tx['status'] else tx['status']['block_height']\n        confirmations = 0\n        tx_date = None\n        status = 'unconfirmed'\n        if tx['status']['confirmed']:\n            if block_height:\n                self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n                confirmations = self.latest_block - block_height + 1\n            tx_date = datetime.utcfromtimestamp(tx['status']['block_time'])\n            status = 'confirmed'\n\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network, block_height=block_height,\n                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, confirmations=confirmations,\n                        status=status, coinbase=tx['vin'][0]['is_coinbase'])\n        for ti in tx['vin']:\n            if ti['is_coinbase']:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptsig'], value=0,\n                            sequence=ti['sequence'], strict=self.strict)\n            else:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'],\n                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],\n                            address=ti['prevout'].get('scriptpubkey_address', ''),\n                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], sequence=ti['sequence'],\n                            witnesses=None if 'witness' not in ti else [bytes.fromhex(w) for w in ti['witness']],\n                            strict=self.strict)\n        for to in tx['vout']:\n            t.add_output(value=to['value'], address=to.get('scriptpubkey_address', ''), spent=None,\n                         lock_script=to['scriptpubkey'], strict=self.strict)\n        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:\n            t.witness_type = 'segwit'\n        t.update_totals()\n        return t\n\n    def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)\n\n    def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        prtxs = []\n        before_txid = ''\n        while True:\n            txs = self.compose_request('address', address, 'txs', before_txid)\n            prtxs += txs\n            if len(txs) == 25:\n                before_txid = txs[-1:][0]['txid']\n            else:\n                break\n            if len(prtxs) > 100:\n                break\n        txs = []\n        for tx in prtxs[::-1]:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n            if t.txid == after_txid:\n                txs = []\n            if len(txs) > limit:\n                break\n        return txs[:limit]\n\n    def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid, 'hex')\n\n    def sendrawtransaction(self, rawtx):\n        return self.compose_request('tx', post_data=rawtx, method='post')\n\n    def estimatefee(self, blocks):\n        estimates = self.compose_request('v1/fees', 'recommended')\n        if blocks < 2:\n            return estimates['fastestFee'] * 1000\n        elif blocks < 4:\n            return estimates['halfHourFee'] * 1000\n        if blocks < 7:\n            return estimates['hourFee'] * 1000\n        else:\n            return estimates['minimumFee'] * 1000\n\n    def blockcount(self):\n        res = self.compose_request('blocks', 'tip', 'height')\n        return res\n\n    def mempool(self, txid=''):\n        txids = self.compose_request('mempool', 'txids')\n        if not txid:\n            return txids\n        if txid in txids:\n            return [txid]\n        return []\n\n    def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        if (page == 1 and limit == 10) or limit > 25:\n            limit = 25\n        bd = self.compose_request('block', blockid)\n        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))\n        if parse_transactions:\n            txs = []\n            for tx in btxs[:limit]:\n                txs.append(self._parse_transaction(tx))\n        else:\n            txs = [tx['txid'] for tx in btxs]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['id'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['timestamp'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block\n\n    def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        return self.compose_request('block', blockid, 'raw').hex()\n\n    def isspent(self, txid, output_n):\n        res = self.compose_request('tx', txid, 'outspend', str(output_n))\n        return 1 if res['spent'] else 0",
  "def __init__(self, network, base_url, denominator, *args):\n        super(self.__class__, self).__init__(network, PROVIDERNAME, base_url, denominator, *args)",
  "def compose_request(self, function, data='', parameter='', parameter2='', variables=None, post_data='',\n                        method='get'):\n        url_path = function\n        if data:\n            url_path += '/' + data\n        if parameter:\n            url_path += '/' + parameter\n        if parameter2:\n            url_path += '/' + parameter2\n        if variables is None:\n            variables = {}\n        if self.api_key:\n            variables.update({'token': self.api_key})\n        return self.request(url_path, variables, method, post_data=post_data)",
  "def getbalance(self, addresslist):\n        balance = 0\n        for address in addresslist:\n            res = self.compose_request('address', address)\n            balance += res['chain_stats']['funded_txo_sum'] - res['chain_stats']['spent_txo_sum']\n        return balance",
  "def getutxos(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n        res = self.compose_request('address', address, 'utxo')\n        utxos = []\n        # # key=lambda k: (k[2], pow(10, 20)-k[0].transaction_id, k[3]), reverse=True\n        res = sorted(res, key=lambda k: 0 if 'block_height' not in k['status'] else k['status']['block_height'])\n        for a in res:\n            confirmations = 0\n            block_height = None\n            if 'block_height' in a['status']:\n                block_height = a['status']['block_height']\n                confirmations = self.latest_block - block_height\n            utxos.append({\n                'address': address,\n                'txid': a['txid'],\n                'confirmations': confirmations,\n                'output_n': a['vout'],\n                'input_n': 0,\n                'block_height': block_height,\n                'fee': None,\n                'size': 0,\n                'value': a['value'],\n                'script': '',\n                'date': None if 'block_time' not in a['status'] else datetime.utcfromtimestamp(a['status']['block_time'])\n            })\n            if a['txid'] == after_txid:\n                utxos = []\n        return utxos[:limit]",
  "def _parse_transaction(self, tx):\n        block_height = None if 'block_height' not in tx['status'] else tx['status']['block_height']\n        confirmations = 0\n        tx_date = None\n        status = 'unconfirmed'\n        if tx['status']['confirmed']:\n            if block_height:\n                self.latest_block = self.blockcount() if not self.latest_block else self.latest_block\n                confirmations = self.latest_block - block_height + 1\n            tx_date = datetime.utcfromtimestamp(tx['status']['block_time'])\n            status = 'confirmed'\n\n        t = Transaction(locktime=tx['locktime'], version=tx['version'], network=self.network, block_height=block_height,\n                        fee=tx['fee'], size=tx['size'], txid=tx['txid'], date=tx_date, confirmations=confirmations,\n                        status=status, coinbase=tx['vin'][0]['is_coinbase'])\n        for ti in tx['vin']:\n            if ti['is_coinbase']:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'], unlocking_script=ti['scriptsig'], value=0,\n                            sequence=ti['sequence'], strict=self.strict)\n            else:\n                t.add_input(prev_txid=ti['txid'], output_n=ti['vout'],\n                            unlocking_script=ti['scriptsig'], value=ti['prevout']['value'],\n                            address=ti['prevout'].get('scriptpubkey_address', ''),\n                            unlocking_script_unsigned=ti['prevout']['scriptpubkey'], sequence=ti['sequence'],\n                            witnesses=None if 'witness' not in ti else [bytes.fromhex(w) for w in ti['witness']],\n                            strict=self.strict)\n        for to in tx['vout']:\n            t.add_output(value=to['value'], address=to.get('scriptpubkey_address', ''), spent=None,\n                         lock_script=to['scriptpubkey'], strict=self.strict)\n        if 'segwit' in [i.witness_type for i in t.inputs] or 'p2sh-segwit' in [i.witness_type for i in t.inputs]:\n            t.witness_type = 'segwit'\n        t.update_totals()\n        return t",
  "def gettransaction(self, txid):\n        tx = self.compose_request('tx', txid)\n        return self._parse_transaction(tx)",
  "def gettransactions(self, address, after_txid='', limit=MAX_TRANSACTIONS):\n        prtxs = []\n        before_txid = ''\n        while True:\n            txs = self.compose_request('address', address, 'txs', before_txid)\n            prtxs += txs\n            if len(txs) == 25:\n                before_txid = txs[-1:][0]['txid']\n            else:\n                break\n            if len(prtxs) > 100:\n                break\n        txs = []\n        for tx in prtxs[::-1]:\n            t = self._parse_transaction(tx)\n            if t:\n                txs.append(t)\n            if t.txid == after_txid:\n                txs = []\n            if len(txs) > limit:\n                break\n        return txs[:limit]",
  "def getrawtransaction(self, txid):\n        return self.compose_request('tx', txid, 'hex')",
  "def sendrawtransaction(self, rawtx):\n        return self.compose_request('tx', post_data=rawtx, method='post')",
  "def estimatefee(self, blocks):\n        estimates = self.compose_request('v1/fees', 'recommended')\n        if blocks < 2:\n            return estimates['fastestFee'] * 1000\n        elif blocks < 4:\n            return estimates['halfHourFee'] * 1000\n        if blocks < 7:\n            return estimates['hourFee'] * 1000\n        else:\n            return estimates['minimumFee'] * 1000",
  "def blockcount(self):\n        res = self.compose_request('blocks', 'tip', 'height')\n        return res",
  "def mempool(self, txid=''):\n        txids = self.compose_request('mempool', 'txids')\n        if not txid:\n            return txids\n        if txid in txids:\n            return [txid]\n        return []",
  "def getblock(self, blockid, parse_transactions, page, limit):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        if (page == 1 and limit == 10) or limit > 25:\n            limit = 25\n        bd = self.compose_request('block', blockid)\n        btxs = self.compose_request('block', blockid, 'txs', str((page-1)*limit))\n        if parse_transactions:\n            txs = []\n            for tx in btxs[:limit]:\n                txs.append(self._parse_transaction(tx))\n        else:\n            txs = [tx['txid'] for tx in btxs]\n\n        block = {\n            'bits': bd['bits'],\n            'depth': None,\n            'block_hash': bd['id'],\n            'height': bd['height'],\n            'merkle_root': bd['merkle_root'],\n            'nonce': bd['nonce'],\n            'prev_block': bd['previousblockhash'],\n            'time': bd['timestamp'],\n            'tx_count': bd['tx_count'],\n            'txs': txs,\n            'version': bd['version'],\n            'page': page,\n            'pages': None if not limit else int(bd['tx_count'] // limit) + (bd['tx_count'] % limit > 0),\n            'limit': limit\n        }\n        return block",
  "def getrawblock(self, blockid):\n        if isinstance(blockid, int):\n            blockid = self.compose_request('block-height', str(blockid))\n        return self.compose_request('block', blockid, 'raw').hex()",
  "def isspent(self, txid, output_n):\n        res = self.compose_request('tx', txid, 'outspend', str(output_n))\n        return 1 if res['spent'] else 0",
  "def parse_args():\n    parser = argparse.ArgumentParser(description='BitcoinLib command line wallet')\n    parser.add_argument('wallet_name', nargs='?', default='',\n                        help=\"Name of wallet to create or open. Used to store your all your wallet keys \"\n                             \"and will be printed on each paper wallet\")\n\n    group_wallet = parser.add_argument_group(\"Wallet Actions\")\n    group_wallet.add_argument('--wallet-remove', action='store_true',\n                              help=\"Name or ID of wallet to remove, all keys and transactions will be deleted\")\n    group_wallet.add_argument('--list-wallets', '-l', action='store_true',\n                              help=\"List all known wallets in BitcoinLib database\")\n    group_wallet.add_argument('--wallet-info', '-w', action='store_true',\n                              help=\"Show wallet information\")\n    group_wallet.add_argument('--update-utxos', '-x', action='store_true',\n                              help=\"Update unspent transaction outputs (UTXO's) for this wallet\")\n    group_wallet.add_argument('--update-transactions', '-u', action='store_true',\n                              help=\"Update all transactions and UTXO's for this wallet\")\n    group_wallet.add_argument('--wallet-recreate', '-z', action='store_true',\n                              help=\"Delete all keys and transactions and recreate wallet, except for the masterkey(s).\"\n                                   \" Use when updating fails or other errors occur. Please backup your database and \"\n                                   \"masterkeys first.\")\n    group_wallet.add_argument('--receive', '-r', nargs='?', type=int,\n                              help=\"Show unused address to receive funds. Specify cosigner-id to generate address for \"\n                                   \"specific cosigner. Default is -1 for own wallet\",\n                              const=-1, metavar='COSIGNER_ID')\n    group_wallet.add_argument('--generate-key', '-g', action='store_true', help=\"Generate a new masterkey, and show\"\n                              \" passphrase, WIF and public account key. Can be used to create a multisig wallet\")\n    group_wallet.add_argument('--export-private', '-e', action='store_true',\n                              help=\"Export private key for this wallet and exit\")\n    group_wallet.add_argument('--import-private', '-k',\n                              help=\"Import private key in this wallet\")\n\n    group_wallet2 = parser.add_argument_group(\"Wallet Setup\")\n    group_wallet2.add_argument('--passphrase', nargs=\"*\", default=None,\n                               help=\"Passphrase to recover or create a wallet. Usually 12 or 24 words\")\n    group_wallet2.add_argument('--passphrase-strength', type=int, default=128,\n                               help=\"Number of bits for passphrase key. Default is 128, lower is not adviced but can \"\n                                    \"be used for testing. Set to 256 bits for more future proof passphrases\")\n    group_wallet2.add_argument('--network', '-n',\n                               help=\"Specify 'bitcoin', 'litecoin', 'testnet' or other supported network\")\n    group_wallet2.add_argument('--database', '-d',\n                               help=\"URI of the database to use\",)\n    group_wallet2.add_argument('--create-from-key', '-c', metavar='KEY',\n                               help=\"Create a new wallet from specified key\")\n    group_wallet2.add_argument('--create-multisig', '-m', nargs='*',\n                               metavar='.',\n                               help='[NUMBER_OF_SIGNATURES, NUMBER_OF_SIGNATURES_REQUIRED, [KEY1, KEY2, ... KEY3]]'\n                                    'Specificy number of signatures followed by the number of signatures required and '\n                                    'then a list of public or private keys for this wallet. Private keys will be '\n                                    'created if not provided in key list.'\n                                    '\\nExample, create a 2-of-2 multisig wallet and provide 1 key and create another '\n                                    'key: -m 2 2 tprv8ZgxMBicQKsPd1Q44tfDiZC98iYouKRC2CzjT3HGt1yYw2zuX2awTotzGAZQ'\n                                    'EAU9bi2M5MCj8iedP9MREPjUgpDEBwBgGi2C8eK5zNYeiX8 tprv8ZgxMBicQKsPeUbMS6kswJc11zgV'\n                                    'EXUnUZuGo3bF6bBrAg1ieFfUdPc9UHqbD5HcXizThrcKike1c4z6xHrz6MWGwy8L6YKVbgJMeQHdWDp')\n    group_wallet2.add_argument('--witness-type', '-y', metavar='WITNESS_TYPE', default=None,\n                               help='Witness type of wallet: lecacy (default), p2sh-segwit or segwit')\n    group_wallet2.add_argument('--cosigner-id', '-s', type=int, default=0,\n                               help='Set this if wallet contains only public keys, more then one private key or if '\n                                    'you would like to create keys for other cosigners.')\n    group_transaction = parser.add_argument_group(\"Transactions\")\n    group_transaction.add_argument('--create-transaction', '-t', metavar=('ADDRESS_1', 'AMOUNT_1'),\n                                   help=\"Create transaction. Specify address followed by amount in satoshis. Repeat for multiple \"\n                                   \"outputs\", nargs='*')\n    group_transaction.add_argument('--sweep', metavar=\"ADDRESS\",\n                                   help=\"Sweep wallet, transfer all funds to specified address\")\n    group_transaction.add_argument('--fee', '-f', type=int, help=\"Transaction fee\")\n    group_transaction.add_argument('--fee-per-kb', type=int,\n                                   help=\"Transaction fee in sathosis (or smallest denominator) per kilobyte\")\n    group_transaction.add_argument('--push', '-p', action='store_true', help=\"Push created transaction to the network\")\n    group_transaction.add_argument('--import-tx', '-i', metavar=\"TRANSACTION\",\n                                   help=\"Import raw transaction hash or transaction dictionary in wallet and sign \"\n                                        \"it with available key(s)\")\n    group_transaction.add_argument('--import-tx-file', '-a', metavar=\"FILENAME_TRANSACTION\",\n                                   help=\"Import transaction dictionary or raw transaction string from specified \"\n                                        \"filename and sign it with available key(s)\")\n\n    pa = parser.parse_args()\n    if pa.receive and pa.create_transaction:\n        parser.error(\"Please select receive or create transaction option not both\")\n    if pa.wallet_name:\n        pa.wallet_info = True\n    else:\n        pa.list_wallets = True\n    return pa",
  "def get_passphrase(args):\n    inp_passphrase = Mnemonic('english').generate(args.passphrase_strength)\n    print(\"\\nYour mnemonic private key sentence is: %s\" % inp_passphrase)\n    print(\"\\nPlease write down on paper and backup. With this key you can restore your wallet and all keys\")\n    passphrase = inp_passphrase.split(' ')\n    inp = input(\"\\nType 'yes' if you understood and wrote down your key: \")\n    if inp not in ['yes', 'Yes', 'YES']:\n        clw_exit(\"Exiting...\")\n    return passphrase",
  "def create_wallet(wallet_name, args, db_uri):\n    if args.network is None:\n        args.network = DEFAULT_NETWORK\n    print(\"\\nCREATE wallet '%s' (%s network)\" % (wallet_name, args.network))\n    if args.create_multisig:\n        if not isinstance(args.create_multisig, list) or len(args.create_multisig) < 2:\n            clw_exit(\"Please enter multisig creation parameter in the following format: \"\n                     \"<number-of-signatures> <number-of-signatures-required> \"\n                     \"<key-0> <key-1> [<key-2> ... <key-n>]\")\n        try:\n            sigs_total = int(args.create_multisig[0])\n        except ValueError:\n            clw_exit(\"Number of total signatures (first argument) must be a numeric value. %s\" %\n                     args.create_multisig[0])\n        try:\n            sigs_required = int(args.create_multisig[1])\n        except ValueError:\n            clw_exit(\"Number of signatures required (second argument) must be a numeric value. %s\" %\n                     args.create_multisig[1])\n        key_list = args.create_multisig[2:]\n        keys_missing = sigs_total - len(key_list)\n        assert(keys_missing >= 0)\n        if keys_missing:\n            print(\"Not all keys provided, creating %d additional key(s)\" % keys_missing)\n            for _ in range(keys_missing):\n                passphrase = get_passphrase(args)\n                passphrase = ' '.join(passphrase)\n                seed = Mnemonic().to_seed(passphrase).hex()\n                key_list.append(HDKey.from_seed(seed, network=args.network))\n        return Wallet.create(wallet_name, key_list, sigs_required=sigs_required, network=args.network,\n                             cosigner_id=args.cosigner_id, db_uri=db_uri, witness_type=args.witness_type)\n    elif args.create_from_key:\n        from bitcoinlib.keys import get_key_format\n        import_key = args.create_from_key\n        kf = get_key_format(import_key)\n        if kf['format'] == 'wif_protected':\n            password = input('Key password? ')\n            import_key, _ = HDKey._bip38_decrypt(import_key, password)\n        return Wallet.create(wallet_name, import_key, network=args.network, db_uri=db_uri,\n                             witness_type=args.witness_type)\n    else:\n        passphrase = args.passphrase\n        if passphrase is None:\n            passphrase = get_passphrase(args)\n        elif not passphrase:\n            passphrase = input(\"Enter Passphrase: \")\n        if not isinstance(passphrase, list):\n            passphrase = passphrase.split(' ')\n        elif len(passphrase) == 1:\n            passphrase = passphrase[0].split(' ')\n        if len(passphrase) < 12:\n            clw_exit(\"Please specify passphrase with 12 words or more\")\n        passphrase = ' '.join(passphrase)\n        seed = Mnemonic().to_seed(passphrase).hex()\n        hdkey = HDKey.from_seed(seed, network=args.network)\n        return Wallet.create(wallet_name, hdkey, network=args.network, witness_type=args.witness_type,\n                               db_uri=db_uri)",
  "def create_transaction(wlt, send_args, args):\n    output_arr = []\n    while send_args:\n        if len(send_args) == 1:\n            raise ValueError(\"Invalid number of transaction inputs. Use <address_1> <amount_1> ... <address_n> <amount_n>\")\n        try:\n            amount = int(send_args[1])\n        except ValueError:\n            clw_exit(\"Amount must be in satoshis, an integer value: %s\" % send_args[1])\n        output_arr.append((send_args[0], amount))\n        send_args = send_args[2:]\n    return wlt.transaction_create(output_arr=output_arr, network=args.network, fee=args.fee, min_confirms=0)",
  "def print_transaction(wt):\n    tx_dict = {\n        'network': wt.network.name, 'fee': wt.fee, 'raw': wt.raw_hex(), 'outputs': [{\n            'address': o.address, 'value': o.value\n        } for o in wt.outputs], 'inputs': [{\n            'prev_hash': i.prev_txid.hex(), 'output_n': int.from_bytes(i.output_n, 'big'),\n            'address': i.address, 'signatures': [{\n                'signature': s.hex(), 'sig_der': s.as_der_encoded(as_hex=True),\n                'pub_key': s.public_key.public_hex,\n            } for s in i.signatures], 'value': i.value\n        } for i in wt.inputs]\n    }\n    pprint(tx_dict)",
  "def clw_exit(msg=None):\n    if msg:\n        print(msg)\n    sys.exit()",
  "def main():\n    print(\"Command Line Wallet - BitcoinLib %s\\n\" % BITCOINLIB_VERSION)\n    # --- Parse commandline arguments ---\n    args = parse_args()\n\n    db_uri = args.database\n\n    if args.generate_key:\n        passphrase = get_passphrase(args)\n        passphrase = ' '.join(passphrase)\n        seed = Mnemonic().to_seed(passphrase).hex()\n        hdkey = HDKey.from_seed(seed, network=args.network)\n        print(\"Private Master key, to create multisig wallet on this machine:\\n%s\" % hdkey.wif_private())\n        print(\"Public Master key, to share with other cosigner multisig wallets:\\n%s\" %\n              hdkey.public_master(witness_type=args.witness_type, multisig=True).wif())\n        print(\"Network: %s\" % hdkey.network.name)\n        clw_exit()\n\n    # List wallets, then exit\n    if args.list_wallets:\n        print(\"BitcoinLib wallets:\")\n        for w in wallets_list(db_uri=db_uri):\n            if 'parent_id' in w and w['parent_id']:\n                continue\n            print(\"[%d] %s (%s) %s\" % (w['id'], w['name'], w['network'], w['owner']))\n        clw_exit()\n\n    # Delete specified wallet, then exit\n    if args.wallet_remove:\n        if not wallet_exists(args.wallet_name, db_uri=db_uri):\n            clw_exit(\"Wallet '%s' not found\" % args.wallet_name)\n        inp = input(\"\\nWallet '%s' with all keys and will be removed, without private key it cannot be restored.\"\n                    \"\\nPlease retype exact name of wallet to proceed: \" % args.wallet_name)\n        if inp == args.wallet_name:\n            if wallet_delete(args.wallet_name, force=True, db_uri=db_uri):\n                clw_exit(\"\\nWallet %s has been removed\" % args.wallet_name)\n            else:\n                clw_exit(\"\\nError when deleting wallet\")\n        else:\n            clw_exit(\"\\nSpecified wallet name incorrect\")\n\n    wlt = None\n    if args.wallet_name and not args.wallet_name.isdigit() and not wallet_exists(args.wallet_name,\n                                                                                 db_uri=db_uri):\n        if not args.create_from_key and input(\n                    \"Wallet %s does not exist, create new wallet [yN]? \" % args.wallet_name).lower() != 'y':\n            clw_exit('Aborted')\n        wlt = create_wallet(args.wallet_name, args, db_uri)\n        args.wallet_info = True\n    else:\n        try:\n            wlt = Wallet(args.wallet_name, db_uri=db_uri)\n            if args.passphrase is not None:\n                print(\"WARNING: Using passphrase option for existing wallet ignored\")\n            if args.create_from_key is not None:\n                print(\"WARNING: Using create_from_key option for existing wallet ignored\")\n        except WalletError as e:\n            clw_exit(\"Error: %s\" % e.msg)\n\n    if wlt is None:\n        clw_exit(\"Could not open wallet %s\" % args.wallet_name)\n\n    if args.import_private:\n        if wlt.import_key(args.import_private):\n            clw_exit(\"Private key imported\")\n        else:\n            clw_exit(\"Failed to import key\")\n\n    if args.wallet_recreate:\n        wallet_empty(args.wallet_name)\n        print(\"Removed transactions and generated keys from this wallet\")\n    if args.update_utxos:\n        wlt.utxos_update()\n    if args.update_transactions:\n        wlt.scan(scan_gap_limit=5)\n\n    if args.export_private:\n        if wlt.scheme == 'multisig':\n            for w in wlt.cosigner:\n                if w.main_key and w.main_key.is_private:\n                    print(w.main_key.wif)\n        elif not wlt.main_key or not wlt.main_key.is_private:\n            print(\"No private key available for this wallet\")\n        else:\n            print(wlt.main_key.wif)\n        clw_exit()\n\n    if args.network is None:\n        args.network = wlt.network.name\n\n    tx_import = None\n    if args.import_tx_file:\n        try:\n            fn = args.import_tx_file\n            f = open(fn, \"r\")\n        except FileNotFoundError:\n            clw_exit(\"File %s not found\" % args.import_tx_file)\n        try:\n            tx_import = ast.literal_eval(f.read())\n        except (ValueError, SyntaxError):\n            tx_import = f.read()\n    if args.import_tx:\n        try:\n            tx_import = ast.literal_eval(args.import_tx)\n        except (ValueError, SyntaxError):\n            tx_import = args.import_tx\n    if tx_import:\n        if isinstance(tx_import, dict):\n            wt = wlt.transaction_import(tx_import)\n        else:\n            wt = wlt.transaction_import_raw(tx_import, network=args.network)\n        wt.sign()\n        if args.push:\n            res = wt.send()\n            if res:\n                print(\"Transaction pushed to network. Transaction ID: %s\" % wt.txid)\n            else:\n                print(\"Error creating transaction: %s\" % wt.error)\n        wt.info()\n        print(\"Signed transaction:\")\n        print_transaction(wt)\n        clw_exit()\n\n    if args.receive:\n        cosigner_id = args.receive\n        if args.receive == -1:\n            cosigner_id = None\n        key = wlt.get_key(network=args.network, cosigner_id=cosigner_id)\n        print(\"Receive address: %s\" % key.address)\n        if QRCODES_AVAILABLE:\n            qrcode = pyqrcode.create(key.address)\n            print(qrcode.terminal())\n        else:\n            print(\"Install qr code module to show QR codes: pip install pyqrcode\")\n        clw_exit()\n    if args.create_transaction == []:\n        clw_exit(\"Missing arguments for --create-transaction/-t option\")\n    if args.create_transaction:\n        if args.fee_per_kb:\n            clw_exit(\"Fee-per-kb option not allowed with --create-transaction\")\n        try:\n            wt = create_transaction(wlt, args.create_transaction, args)\n        except WalletError as e:\n            clw_exit(\"Cannot create transaction: %s\" % e.msg)\n        wt.sign()\n        print(\"Transaction created\")\n        wt.info()\n        if args.push:\n            wt.send()\n            if wt.pushed:\n                print(\"Transaction pushed to network. Transaction ID: %s\" % wt.txid)\n            else:\n                print(\"Error creating transaction: %s\" % wt.error)\n        else:\n            print(\"\\nTransaction created but not sent yet. Transaction dictionary for export: \")\n            print_transaction(wt)\n        clw_exit()\n    if args.sweep:\n        if args.fee:\n            clw_exit(\"Fee option not allowed with --sweep\")\n        offline = True\n        print(\"Sweep wallet. Send all funds to %s\" % args.sweep)\n        if args.push:\n            offline = False\n        wt = wlt.sweep(args.sweep, offline=offline, network=args.network, fee_per_kb=args.fee_per_kb)\n        if not wt:\n            clw_exit(\"Error occurred when sweeping wallet: %s. Are UTXO's available and updated?\" % wt)\n        wt.info()\n        if args.push:\n            if wt.pushed:\n                print(\"Transaction pushed to network. Transaction ID: %s\" % wt.txid)\n            elif not wt:\n                print(\"Cannot sweep wallet, are UTXO's updated and available?\")\n            else:\n                print(\"Error sweeping wallet: %s\" % wt.error)\n        else:\n            print(\"\\nTransaction created but not sent yet. Transaction dictionary for export: \")\n            print_transaction(wt)\n        clw_exit()\n\n    # print(\"Updating wallet\")\n    if args.network == 'bitcoinlib_test':\n        wlt.utxos_update()\n    print(\"Wallet info for %s\" % wlt.name)\n    wlt.info()",
  "def read_config():\n    config = configparser.ConfigParser()\n\n    def config_get(section, var, fallback, is_boolean=False):\n        try:\n            if is_boolean:\n                val = config.getboolean(section, var, fallback=fallback)\n            else:\n                val = config.get(section, var, fallback=fallback)\n            return val\n        except Exception:\n            return fallback\n\n    global BCL_INSTALL_DIR, BCL_DATABASE_DIR, DEFAULT_DATABASE, BCL_DATA_DIR, BCL_CONFIG_FILE\n    global ALLOW_DATABASE_THREADS, DEFAULT_DATABASE_CACHE\n    global BCL_LOG_FILE, LOGLEVEL, ENABLE_BITCOINLIB_LOGGING\n    global TIMEOUT_REQUESTS, DEFAULT_LANGUAGE, DEFAULT_NETWORK, DEFAULT_WITNESS_TYPE\n    global UNITTESTS_FULL_DATABASE_TEST, SERVICE_CACHING_ENABLED, DATABASE_ENCRYPTION_ENABLED, DB_FIELD_ENCRYPTION_KEY\n    global SERVICE_MAX_ERRORS, BLOCK_COUNT_CACHE_TIME, MAX_TRANSACTIONS\n\n    # Read settings from Configuration file provided in OS environment~/.bitcoinlib/ directory\n    config_file_name = os.environ.get('BCL_CONFIG_FILE')\n    if not config_file_name:\n        BCL_CONFIG_FILE = Path('~/.bitcoinlib/config.ini').expanduser()\n    else:\n        BCL_CONFIG_FILE = Path(config_file_name)\n        if not BCL_CONFIG_FILE.is_absolute():\n            BCL_CONFIG_FILE = Path(Path.home(), '.bitcoinlib', BCL_CONFIG_FILE)\n        if not BCL_CONFIG_FILE.exists():\n            BCL_CONFIG_FILE = Path(BCL_INSTALL_DIR, 'data', config_file_name)\n        if not BCL_CONFIG_FILE.exists():\n            raise IOError('Bitcoinlib configuration file not found: %s' % str(BCL_CONFIG_FILE))\n    data = config.read(str(BCL_CONFIG_FILE))\n    BCL_DATA_DIR = Path(config_get('locations', 'data_dir', fallback='~/.bitcoinlib')).expanduser()\n\n    # Database settings\n    BCL_DATABASE_DIR = Path(BCL_DATA_DIR, config_get('locations', 'database_dir', 'database'))\n    BCL_DATABASE_DIR.mkdir(parents=True, exist_ok=True)\n    default_databasefile = DEFAULT_DATABASE = \\\n        config_get('locations', 'default_databasefile', fallback='bitcoinlib.sqlite')\n    if not default_databasefile.startswith('postgresql') or default_databasefile.startswith('mysql'):\n        DEFAULT_DATABASE = str(Path(BCL_DATABASE_DIR, default_databasefile))\n    default_databasefile_cache = DEFAULT_DATABASE_CACHE = \\\n        config_get('locations', 'default_databasefile_cache', fallback='bitcoinlib_cache.sqlite')\n    if not default_databasefile_cache.startswith('postgresql') or default_databasefile_cache.startswith('mysql'):\n        DEFAULT_DATABASE_CACHE = str(Path(BCL_DATABASE_DIR, default_databasefile_cache))\n    ALLOW_DATABASE_THREADS = config_get(\"common\", \"allow_database_threads\", fallback=True, is_boolean=True)\n    SERVICE_CACHING_ENABLED = config_get('common', 'service_caching_enabled', fallback=True, is_boolean=True)\n    DATABASE_ENCRYPTION_ENABLED = config_get('common', 'database_encryption_enabled', fallback=False, is_boolean=True)\n    DB_FIELD_ENCRYPTION_KEY = os.environ.get('DB_FIELD_ENCRYPTION_KEY')\n\n    # Log settings\n    ENABLE_BITCOINLIB_LOGGING = config_get(\"logs\", \"enable_bitcoinlib_logging\", fallback=True, is_boolean=True)\n    BCL_LOG_FILE = Path(BCL_DATA_DIR, config_get('logs', 'log_file', fallback='bitcoinlib.log'))\n    BCL_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)\n    LOGLEVEL = config_get('logs', 'loglevel', fallback=LOGLEVEL)\n\n    # Service settings\n    TIMEOUT_REQUESTS = int(config_get('common', 'timeout_requests', fallback=TIMEOUT_REQUESTS))\n    SERVICE_MAX_ERRORS = int(config_get('common', 'service_max_errors', fallback=SERVICE_MAX_ERRORS))\n    MAX_TRANSACTIONS = int(config_get('common', 'max_transactions', fallback=MAX_TRANSACTIONS))\n    BLOCK_COUNT_CACHE_TIME = int(config_get('common', 'block_count_cache_time', fallback=BLOCK_COUNT_CACHE_TIME))\n\n    # Other settings\n    DEFAULT_LANGUAGE = config_get('common', 'default_language', fallback=DEFAULT_LANGUAGE)\n    DEFAULT_NETWORK = config_get('common', 'default_network', fallback=DEFAULT_NETWORK)\n    DEFAULT_WITNESS_TYPE = config_get('common', 'default_witness_type', fallback=DEFAULT_WITNESS_TYPE)\n\n    full_db_test = os.environ.get('UNITTESTS_FULL_DATABASE_TEST')\n    if full_db_test in [1, True, 'True', 'true', 'TRUE']:\n        UNITTESTS_FULL_DATABASE_TEST = True\n\n    if not data:\n        return False\n    return True",
  "def initialize_lib():\n    global BCL_INSTALL_DIR, BCL_DATA_DIR, BITCOINLIB_VERSION\n    instlogfile = Path(BCL_DATA_DIR, 'install.log')\n    if instlogfile.exists():\n        return\n\n    with instlogfile.open('w') as f:\n        install_message = \"BitcoinLib installed, check further logs in bitcoinlib.log\\n\\n\" \\\n                          \"If you remove this file all settings will be reset again to the default settings. \" \\\n                          \"This might be usefull after an update or when problems occur.\\n\\n\" \\\n                          \"Installation parameters. Include this parameters when reporting bugs and issues:\\n\" \\\n                          \"Bitcoinlib version: %s\\n\" \\\n                          \"Installation date : %s\\n\" \\\n                          \"Python            : %s\\n\" \\\n                          \"Compiler          : %s\\n\" \\\n                          \"Build             : %s\\n\" \\\n                          \"OS Version        : %s\\n\" \\\n                          \"Platform          : %s\\n\" % \\\n                          (BITCOINLIB_VERSION, datetime.now().isoformat(), platform.python_version(),\n                           platform.python_compiler(), platform.python_build(), platform.version(), platform.platform())\n        f.write(install_message)\n\n    # Copy data and settings file\n    from shutil import copyfile\n    for file in Path(BCL_INSTALL_DIR, 'data').iterdir():\n        if file.suffix not in ['.ini', '.json']:\n            continue\n        copyfile(str(file), Path(BCL_DATA_DIR, file.name))",
  "def config_get(section, var, fallback, is_boolean=False):\n        try:\n            if is_boolean:\n                val = config.getboolean(section, var, fallback=fallback)\n            else:\n                val = config.get(section, var, fallback=fallback)\n            return val\n        except Exception:\n            return fallback",
  "def op():\n    pass",
  "def _set_opcodes():\n    idx = 0\n    opcodenames = {}\n    for opcode in _opcodes:\n        if isinstance(opcode, tuple):\n            var, idx = opcode\n        else:\n            var = opcode\n        opcodenames.update({idx: var})\n        setattr(op, var.lower(), idx)\n        idx += 1\n    return opcodenames"
]